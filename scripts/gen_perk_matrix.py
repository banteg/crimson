from __future__ import annotations

import ast
from dataclasses import dataclass
from pathlib import Path
import re
import sys
from typing import Callable


_PERK_REF_RE = re.compile(r"\bPerkId\.([A-Z0-9_]+)\b")


@dataclass(frozen=True, slots=True)
class _Context:
    start: int
    end: int
    name: str


def _build_contexts(path: Path, text: str) -> list[_Context]:
    try:
        tree = ast.parse(text, filename=str(path))
    except SyntaxError:
        return []

    contexts: list[_Context] = []

    def visit(node: ast.AST, prefix: str) -> None:
        body = getattr(node, "body", None)
        if not body:
            return
        for child in body:
            if isinstance(child, ast.ClassDef):
                name = f"{prefix}{child.name}"
                contexts.append(_Context(int(child.lineno), int(child.end_lineno or child.lineno), name))
                visit(child, f"{name}.")
            elif isinstance(child, (ast.FunctionDef, ast.AsyncFunctionDef)):
                name = f"{prefix}{child.name}"
                contexts.append(_Context(int(child.lineno), int(child.end_lineno or child.lineno), name))
                visit(child, f"{name}.")

    visit(tree, "")
    return contexts


def _context_for_line(contexts: list[_Context], line: int) -> str:
    best: _Context | None = None
    for ctx in contexts:
        if ctx.start <= line <= ctx.end:
            if best is None:
                best = ctx
            elif ctx.start >= best.start and ctx.end <= best.end:
                best = ctx
    return best.name if best is not None else "<module>"


def _iter_python_files(root: Path) -> list[Path]:
    out: list[Path] = []
    for path in root.rglob("*.py"):
        if "__pycache__" in path.parts:
            continue
        out.append(path)
    return sorted(out)


def _is_runtime_ref_file(path: Path) -> bool:
    if path.name == "perks.py":
        return False
    if path.name == "game.py":
        return False
    if "modes" in path.parts:
        return False
    if "quests" in path.parts:
        return False
    if "views" in path.parts:
        return False
    return True


def _collect_refs(
    root: Path,
    *,
    repo_root: Path,
    allow: set[str],
    include_context: bool,
    exclude_predicate: Callable[[Path], bool] | None = None,
) -> dict[str, set[str]]:
    refs: dict[str, set[str]] = {name: set() for name in allow}
    for path in _iter_python_files(root):
        if exclude_predicate is not None and exclude_predicate(path):
            continue
        text = path.read_text(encoding="utf-8")
        contexts = _build_contexts(path, text) if include_context else []
        rel = path.relative_to(repo_root)
        for lineno, line in enumerate(text.splitlines(), start=1):
            for match in _PERK_REF_RE.finditer(line):
                perk_name = match.group(1)
                if perk_name not in refs:
                    continue
                if include_context:
                    ctx = _context_for_line(contexts, lineno)
                    refs[perk_name].add(f"{rel}:{ctx}")
                else:
                    refs[perk_name].add(str(rel))
    return refs


def _format_cell(items: list[str], *, max_items: int) -> str:
    if not items:
        return "â€”"
    if len(items) > max_items:
        items = [*items[:max_items], f"+{len(items) - max_items} more"]
    return "<br>".join(f"`{item}`" for item in items)


def main() -> int:
    repo_root = Path(__file__).resolve().parents[1]
    sys.path.insert(0, str(repo_root / "src"))

    try:
        from crimson.perks import PERK_TABLE  # type: ignore[import-not-found]
    except Exception as exc:  # pragma: no cover
        print(f"error: failed to import perks table: {exc}", file=sys.stderr)
        return 1

    perk_names = {meta.perk_id.name for meta in PERK_TABLE}

    src_root = repo_root / "src" / "crimson"
    tests_root = repo_root / "tests"
    out_path = repo_root / "docs" / "rewrite" / "perk-matrix.md"

    src_refs = _collect_refs(
        src_root,
        repo_root=repo_root,
        allow=perk_names,
        include_context=True,
        exclude_predicate=lambda p: not _is_runtime_ref_file(p),
    )
    test_refs = _collect_refs(
        tests_root,
        repo_root=repo_root,
        allow=perk_names,
        include_context=False,
        exclude_predicate=lambda p: "__snapshots__" in p.parts,
    )

    lines: list[str] = []
    lines.append("# Perk implementation matrix (rewrite)")
    lines.append("")
    lines.append("This page tracks **where perks are wired** in the Python rewrite under `src/`,")
    lines.append("and which perks have direct scenario tests.")
    lines.append("")
    lines.append("Generated by `uv run python scripts/gen_perk_matrix.py`.")
    lines.append("")
    lines.append("Notes:")
    lines.append("- `Port refs` excludes perk metadata (`perks.py`), quests, modes, and UI views.")
    lines.append("- `Original hook` is not filled yet; use the decompile + runtime evidence to promote it.")
    lines.append("")
    lines.append("| ID | PerkId | Name | Original hook | Port refs | Tests |")
    lines.append("| -- | ------ | ---- | ------------ | -------- | ----- |")
    for meta in sorted(PERK_TABLE, key=lambda m: int(m.perk_id)):
        perk_name = meta.perk_id.name
        port = _format_cell(sorted(src_refs.get(perk_name, set())), max_items=3)
        tests = _format_cell(sorted(test_refs.get(perk_name, set())), max_items=2)
        original = meta.notes or "TBD"
        original = original.replace("|", "\\|")
        name = str(meta.name).replace("|", "\\|")
        lines.append(f"| {int(meta.perk_id)} | {perk_name} | {name} | {original} | {port} | {tests} |")

    out_path.parent.mkdir(parents=True, exist_ok=True)
    out_path.write_text("\n".join(lines).rstrip() + "\n", encoding="utf-8")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
