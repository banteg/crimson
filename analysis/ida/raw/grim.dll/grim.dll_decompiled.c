
// nullsub_11 @ 0x10001030
void nullsub_11()
{
  ;
}

// nullsub_12 @ 0x10001050
void nullsub_12()
{
  ;
}

// nullsub_13 @ 0x10001070
void nullsub_13()
{
  ;
}

// nullsub_14 @ 0x10001090
void nullsub_14()
{
  ;
}

// nullsub_15 @ 0x100010B0
void nullsub_15()
{
  ;
}

// nullsub_16 @ 0x100010D0
void nullsub_16()
{
  ;
}

// nullsub_17 @ 0x100010F0
void nullsub_17()
{
  ;
}

// nullsub_18 @ 0x10001110
void nullsub_18()
{
  ;
}

// nullsub_19 @ 0x10001130
void nullsub_19()
{
  ;
}

// sub_10001140 @ 0x10001140
char sub_10001140()
{
  grim_error_text = (int)aSystemNoFrameF;
  return 0;
}

// grim_noop @ 0x10001160
// debug stub (no-op)
void grim_noop()
{
  ;
}

// sub_10001170 @ 0x10001170
INT_PTR __stdcall sub_10001170(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  INT_PTR result; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND DlgItem; // eax
  int v14; // eax
  HWND v15; // eax
  int v16; // eax
  HWND v17; // eax
  int v18; // eax
  HWND v19; // eax
  int v20; // eax
  HWND v21; // eax
  int v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  WPARAM v34; // [esp-8h] [ebp-18h]
  WPARAM v35; // [esp-8h] [ebp-18h]
  WPARAM v36; // [esp-8h] [ebp-18h]

  if ( a2 == 16 )
  {
    EndDialog(hDlg, (unsigned __int16)a3);
    return 0;
  }
  if ( a2 == 272 )
  {
    SendMessageA(hDlg, 0x80u, 1u, lParam);
    SendMessageA(hDlg, 0x80u, 0, lParam);
    dword_1005BC18[0] = 0;
    dword_1005D80C = 1;
    DlgItem = GetDlgItem(hDlg, 1026);
    SendMessageA(DlgItem, 0x143u, 0, (LPARAM)aAutodetectSele);
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           21) >= 0 )
    {
      v14 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 21;
      dword_1005D80C = v14 + 1;
      v15 = GetDlgItem(hDlg, 1026);
      SendMessageA(v15, 0x143u, 0, (LPARAM)a32BitA8r8g8b8H);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           29) >= 0 )
    {
      v16 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 29;
      dword_1005D80C = v16 + 1;
      v17 = GetDlgItem(hDlg, 1026);
      SendMessageA(v17, 0x143u, 0, (LPARAM)a16BitA8r3g3b2);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           26) >= 0 )
    {
      v18 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 26;
      dword_1005D80C = v18 + 1;
      v19 = GetDlgItem(hDlg, 1026);
      SendMessageA(v19, 0x143u, 0, (LPARAM)a16BitA4r4g4b4);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           861165636) >= 0 )
    {
      v20 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 861165636;
      dword_1005D80C = v20 + 1;
      v21 = GetDlgItem(hDlg, 1026);
      SendMessageA(v21, 0x143u, 0, (LPARAM)aDxt3Compressed);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           894720068) >= 0 )
    {
      v22 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 894720068;
      dword_1005D80C = v22 + 1;
      v23 = GetDlgItem(hDlg, 1026);
      SendMessageA(v23, 0x143u, 0, (LPARAM)aDxt5Compressed);
    }
    v24 = GetDlgItem(hDlg, 1026);
    SendMessageA(v24, 0x14Eu, 0, 0);
    v25 = GetDlgItem(hDlg, 1032);
    SendMessageA(v25, 0x143u, 0, (LPARAM)aDoubleSlowest4);
    v26 = GetDlgItem(hDlg, 1032);
    SendMessageA(v26, 0x143u, 0, (LPARAM)aFullDefault);
    v27 = GetDlgItem(hDlg, 1032);
    SendMessageA(v27, 0x143u, 0, (LPARAM)aHalfFaster4xLe);
    v28 = GetDlgItem(hDlg, 1032);
    SendMessageA(v28, 0x143u, 0, (LPARAM)aNoneStaticText);
    v29 = GetDlgItem(hDlg, 1032);
    SendMessageA(v29, 0x14Eu, 1u, 0);
    if ( *(float *)&dword_1005D118 == 0.5 )
    {
      v34 = 0;
LABEL_33:
      v30 = GetDlgItem(hDlg, 1032);
      SendMessageA(v30, 0x14Eu, v34, 0);
      byte_1005D400 = byte_1005D0C8;
      if ( byte_1005D0C8 )
      {
        v31 = GetDlgItem(hDlg, 1032);
        SendMessageA(v31, 0x14Eu, 3u, 0);
      }
      v35 = byte_1005D0B8 == 1;
      v32 = GetDlgItem(hDlg, 1029);
      SendMessageA(v32, 0xF1u, v35, 0);
      v36 = (_BYTE)dword_1005D108 != 0;
      v33 = GetDlgItem(hDlg, 1028);
      SendMessageA(v33, 0xF1u, v36, 0);
      return 1;
    }
    if ( *(float *)&dword_1005D118 != 1.0 )
    {
      if ( *(float *)&dword_1005D118 == 2.0 )
      {
        v34 = 2;
        goto LABEL_33;
      }
      if ( *(float *)&dword_1005D118 == 4.0 )
      {
        v34 = 3;
        goto LABEL_33;
      }
      dword_1005D118 = 1065353216;
    }
    v34 = 1;
    goto LABEL_33;
  }
  if ( a2 != 273 )
    return 0;
  if ( (unsigned __int16)a3 == 1001 )
  {
    EndDialog(hDlg, 1001);
    return 0;
  }
  if ( (unsigned __int16)a3 != 1027 )
  {
    if ( (unsigned __int16)a3 == 1030 )
    {
      byte_1005D0B8 = 0;
      v4 = GetDlgItem(hDlg, 1029);
      SendMessageA(v4, 0xF1u, 0, 0);
      LOBYTE(dword_1005D108) = 1;
      v5 = GetDlgItem(hDlg, 1028);
      SendMessageA(v5, 0xF1u, 1u, 0);
      dword_1005D118 = 1065353216;
      v6 = GetDlgItem(hDlg, 1032);
      SendMessageA(v6, 0x14Eu, 1u, 0);
      v7 = GetDlgItem(hDlg, 1026);
      SendMessageA(v7, 0x14Eu, 0, 0);
      return 0;
    }
    return 0;
  }
  v9 = GetDlgItem(hDlg, 1028);
  LOBYTE(dword_1005D108) = SendMessageA(v9, 0xF0u, 0, 0) != 0;
  v10 = GetDlgItem(hDlg, 1026);
  grim_preferred_texture_format = dword_1005BC18[SendMessageA(v10, 0x147u, 0, 0)];
  v11 = GetDlgItem(hDlg, 1029);
  byte_1005D0B8 = SendMessageA(v11, 0xF0u, 0, 0) != 0;
  byte_1005D400 = 0;
  v12 = GetDlgItem(hDlg, 1032);
  switch ( SendMessageA(v12, 0x147u, 0, 0) )
  {
    case 0:
      dword_1005D118 = 1056964608;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    case 2:
      dword_1005D118 = 0x40000000;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    case 3:
      byte_1005D400 = 1;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    default:
      dword_1005D118 = 1065353216;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
  }
  return result;
}

// sub_10001710 @ 0x10001710
int sub_10001710()
{
  int v0; // ebx
  int v1; // ebp
  char *v3; // [esp+10h] [ebp-4h]

  dword_1005C48C = 0;
  dword_1005C490 = 0;
  byte_1005C860 = 0;
  byte_1005C861 = 1;
  dword_1005C864 = 0;
  dword_1005C88C = 1056964608;
  dword_1005C868 = 1;
  dword_1005C890 = 257;
  dword_1005C894 = 258;
  byte_1005C886 = 0;
  dword_1005C488 = 1065353216;
  byte_1005C885 = 0;
  byte_1005C494 = 0;
  v0 = 0;
  v3 = (char *)&unk_1005C4C0;
  v1 = 34;
  do
  {
    grim_config_blob[v1++] = v0;
    strcpy(v3, aDefault);
    ++v0;
    v3 += 27;
  }
  while ( v1 < 42 );
  HIWORD(grim_config_blob[0]) = 0;
  memset(byte_1005C598, 0, 0x20u);
  strcpy(byte_1005C598, a10tons);
  dword_1005C49C = 1;
  dword_1005C498 = 0;
  LOWORD(grim_config_blob[0]) = 0;
  byte_1005C884 = 0;
  byte_1005C878 = 1;
  dword_1005C5C0 = 0;
  dword_1005C5C4 = 0;
  dword_1005C484 = 0;
  dword_1005C5D0 = 32;
  byte_1005C5DC = 0;
  dword_1005C430 = 1;
  byte_1005C426 = 1;
  byte_1005C427 = 0;
  byte_1005C428 = 1;
  dword_1005C434 = 2;
  dword_1005C438 = 2;
  dword_1005C45C = 0;
  dword_1005C460 = 0;
  byte_1005C429 = 1;
  dword_1005C42C = 1;
  dword_1005C5EC = 32;
  dword_1005C888 = 5;
  dword_1005C5C8 = 9000;
  dword_1005C5CC = 27000;
  dword_1005C5BC = 100;
  dword_1005C5D4 = 800;
  dword_1005C5D8 = 600;
  dword_1005C87C = 1065353216;
  dword_1005C880 = 1065353216;
  dword_1005C5E0 = 17;
  dword_1005C5E4 = 31;
  dword_1005C5E8 = 30;
  dword_1005C5F0 = 256;
  dword_1005C5F4 = 382;
  dword_1005C5F8 = 382;
  dword_1005C5FC = 16;
  dword_1005C600 = 18;
  dword_1005C604 = 319;
  dword_1005C608 = 320;
  dword_1005C60C = 321;
  dword_1005C610 = 339;
  dword_1005C614 = 382;
  dword_1005C618 = 382;
  dword_1005C61C = 382;
  dword_1005C620 = 200;
  dword_1005C624 = 208;
  dword_1005C628 = 203;
  dword_1005C62C = 205;
  dword_1005C630 = 157;
  dword_1005C634 = 382;
  dword_1005C638 = 382;
  dword_1005C63C = 211;
  dword_1005C640 = 209;
  dword_1005C644 = 319;
  dword_1005C648 = 320;
  dword_1005C64C = 321;
  dword_1005C650 = 339;
  dword_1005C654 = 382;
  dword_1005C658 = 382;
  dword_1005C65C = 382;
  word_1005C41C = 257;
  return 382;
}

// sub_100019F0 @ 0x100019F0
char sub_100019F0()
{
  FILE *v0; // eax
  FILE *v1; // esi

  v0 = fopen(FileName, Mode);
  v1 = v0;
  if ( v0 )
  {
    fwrite(grim_config_blob, 0x480u, 1u, v0);
    fclose(v1);
  }
  return 1;
}

// sub_10001A30 @ 0x10001A30
char sub_10001A30()
{
  FILE *v0; // esi

  v0 = fopen(FileName, aRb);
  if ( !v0 )
  {
    sub_100019F0();
    v0 = fopen(FileName, aRb);
    if ( !v0 )
      return 0;
  }
  fseek(v0, 0, 2);
  if ( ftell(v0) == 1152 )
  {
    fseek(v0, 0, 0);
    fread(grim_config_blob, 0x480u, 1u, v0);
    fclose(v0);
  }
  else
  {
    fclose(v0);
    sub_100019F0();
  }
  return 1;
}

// DialogFunc @ 0x10001AD0
INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  unsigned int v12; // edx
  char v13; // bl
  HWND DlgItem; // eax
  HWND v15; // eax
  HWND v16; // eax
  WPARAM v17; // [esp-8h] [ebp-18h]
  WPARAM v18; // [esp-8h] [ebp-18h]
  WPARAM v19; // [esp-8h] [ebp-18h]
  const CHAR *v20; // [esp-4h] [ebp-14h]
  const CHAR *v21; // [esp-4h] [ebp-14h]
  const CHAR *v22; // [esp-4h] [ebp-14h]
  const CHAR *v23; // [esp-4h] [ebp-14h]

  switch ( a2 )
  {
    case 0x10u:
      EndDialog(hDlg, (unsigned __int16)a3);
      return 0;
    case 0x110u:
      SendMessageA(hDlg, 0x80u, 1u, lParam);
      SendMessageA(hDlg, 0x80u, 0, lParam);
      if ( byte_1005C884 )
      {
        v22 = lpString;
        DlgItem = GetDlgItem(hDlg, 1034);
        SetWindowTextA(DlgItem, v22);
        v19 = 1;
      }
      else
      {
        v23 = off_1005306C;
        v15 = GetDlgItem(hDlg, 1034);
        SetWindowTextA(v15, v23);
        v19 = 0;
      }
      v16 = GetDlgItem(hDlg, 1024);
      SendMessageA(v16, 0xF1u, v19, 0);
      return 1;
    case 0x111u:
      if ( (unsigned __int16)a3 <= 0x403u )
      {
        switch ( (unsigned __int16)a3 )
        {
          case 0x403u:
            EndDialog(hDlg, 1027);
            return 0;
          case 2u:
            EndDialog(hDlg, 2);
            return 0;
          case 0x400u:
            v17 = byte_1005C884 != 0;
            v4 = GetDlgItem(hDlg, 1024);
            SendMessageA(v4, 0xF1u, v17, 0);
            if ( byte_1005C884 )
            {
              if ( (_BYTE)dword_1005C48C )
              {
                DialogBoxParamA(grim_module_handle, (LPCSTR)0x8B, hDlg, DialogFunc, 0);
              }
              else
              {
                byte_1005C884 = 0;
                sub_100019F0();
              }
            }
            else
            {
              DialogBoxParamA(grim_module_handle, (LPCSTR)0x8C, hDlg, DialogFunc, 0);
            }
            if ( byte_1005C884 )
            {
              v20 = lpString;
              v5 = GetDlgItem(hDlg, 1034);
              SetWindowTextA(v5, v20);
              v18 = 1;
            }
            else
            {
              v21 = off_1005306C;
              v6 = GetDlgItem(hDlg, 1034);
              SetWindowTextA(v6, v21);
              v18 = 0;
            }
            v7 = GetDlgItem(hDlg, 1024);
            SendMessageA(v7, 0xF1u, v18, 0);
            return 0;
        }
        return 0;
      }
      if ( (unsigned __int16)a3 == 1032 )
      {
        v11 = GetDlgItem(hDlg, 1031);
        GetWindowTextA(v11, dword_1005BCFC, 255);
        v12 = 0;
        v13 = 1;
        if ( !strlen((const char *)&dword_1005C48C) )
          goto LABEL_33;
        do
        {
          if ( *((_BYTE *)&dword_1005C48C + v12) != dword_1005BCFC[v12] )
            v13 = 0;
          ++v12;
        }
        while ( v12 < strlen((const char *)&dword_1005C48C) );
        if ( v13 )
        {
LABEL_33:
          byte_1005C884 = 0;
          LOBYTE(dword_1005C48C) = 0;
          sub_100019F0();
          EndDialog(hDlg, 1032);
          return 0;
        }
        else
        {
          MessageBoxA(hDlg, aPasswordIsInco, aAboutPassword, 0x30u);
          return 0;
        }
      }
      else
      {
        if ( (unsigned __int16)a3 != 1033 )
          return 0;
        v9 = GetDlgItem(hDlg, 1031);
        GetWindowTextA(v9, dword_1005BCFC, 255);
        v10 = GetDlgItem(hDlg, 1035);
        GetWindowTextA(v10, byte_1005BDFC, 255);
        if ( !strcmp(dword_1005BCFC, byte_1005BDFC) )
        {
          if ( dword_1005BCFC[0] )
          {
            dword_1005C48C = *(_DWORD *)dword_1005BCFC;
            dword_1005C490 = dword_1005BD00;
            byte_1005C494 = 0;
            byte_1005C884 = 1;
            sub_100019F0();
            EndDialog(hDlg, 1033);
          }
          else
          {
            MessageBoxA(hDlg, aPleaseGiveAPas, aAboutPassword, 0x30u);
          }
          return 0;
        }
        else
        {
          MessageBoxA(hDlg, aGivenPasswords, aAboutPasswords, 0x30u);
          return 0;
        }
      }
    default:
      return 0;
  }
}

// sub_10001E90 @ 0x10001E90
LRESULT sub_10001E90()
{
  HWND DlgItem; // eax
  HWND v1; // eax
  HWND v2; // eax
  HWND v3; // eax
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  int v14; // eax
  int v15; // eax
  HWND v16; // eax
  WPARAM v18; // [esp-8h] [ebp-10h]
  WPARAM v19; // [esp-8h] [ebp-10h]

  v18 = (unsigned __int8)dword_1005CEC8;
  byte_10053064 = (dword_1005A4A4 & 0x80000) != 0;
  DlgItem = GetDlgItem(hDlg, 1005);
  SendMessageA(DlgItem, 0xF1u, v18, 0);
  byte_1005D400 = byte_1005D0C8;
  byte_10053065 = (*(int (__stdcall **)(int, _DWORD, int, int, int, _DWORD))(*(_DWORD *)grim_d3d8_probe + 36))(
                    grim_d3d8_probe,
                    0,
                    1,
                    22,
                    22,
                    0) >= 0;
  v1 = GetDlgItem(hDlg, 1017);
  SendMessageA(v1, 0x14Bu, 0, 0);
  if ( byte_10053064 )
  {
    v2 = GetDlgItem(hDlg, 1017);
    SendMessageA(v2, 0x143u, 0, (LPARAM)a640x480Windowe);
    v3 = GetDlgItem(hDlg, 1017);
    SendMessageA(v3, 0x143u, 0, (LPARAM)a800x600Windowe);
    v4 = GetDlgItem(hDlg, 1017);
    SendMessageA(v4, 0x143u, 0, (LPARAM)a960x600WideWin);
    v5 = GetDlgItem(hDlg, 1017);
    SendMessageA(v5, 0x143u, 0, (LPARAM)a1024x768Window);
  }
  v6 = GetDlgItem(hDlg, 1017);
  SendMessageA(v6, 0x143u, 0, (LPARAM)a640x480x16);
  v7 = GetDlgItem(hDlg, 1017);
  SendMessageA(v7, 0x143u, 0, (LPARAM)a800x600x16);
  v8 = GetDlgItem(hDlg, 1017);
  SendMessageA(v8, 0x143u, 0, (LPARAM)a960x600x16Wide);
  v9 = GetDlgItem(hDlg, 1017);
  SendMessageA(v9, 0x143u, 0, (LPARAM)a1024x768x16);
  if ( byte_10053065 )
  {
    v10 = GetDlgItem(hDlg, 1017);
    SendMessageA(v10, 0x143u, 0, (LPARAM)a640x480x32);
    v11 = GetDlgItem(hDlg, 1017);
    SendMessageA(v11, 0x143u, 0, (LPARAM)a800x600x32);
    v12 = GetDlgItem(hDlg, 1017);
    SendMessageA(v12, 0x143u, 0, (LPARAM)a960x600x32Wide);
    v13 = GetDlgItem(hDlg, 1017);
    SendMessageA(v13, 0x143u, 0, (LPARAM)a1024x768x32);
  }
  switch ( dword_1005CE18 )
  {
    case 640:
      v14 = 0;
      break;
    case 800:
      v14 = 1;
      break;
    case 960:
      v14 = 2;
      break;
    case 1024:
      v14 = 3;
      break;
    default:
      v15 = -(dword_1005CE18 != 1680);
      LOBYTE(v15) = v15 & 0xFD;
      v14 = v15 + 4;
      break;
  }
  if ( (_BYTE)dword_1005CC08 != 1 || !byte_10053064 )
  {
    if ( dword_1005CE38 == 16 )
    {
      v14 += 4;
    }
    else if ( dword_1005CE38 == 32 )
    {
      v14 += 8;
    }
    if ( !byte_10053064 )
      v14 -= 4;
  }
  v19 = v14;
  v16 = GetDlgItem(hDlg, 1017);
  return SendMessageA(v16, 0x14Eu, v19, 0);
}

// grim_config_dialog_proc @ 0x10002120
// dialog procedure for the Grim2D config UI
int grim_config_dialog_proc(int hwnd, unsigned int msg, unsigned int wparam, int lparam)
{
  HWND v4; // eax
  int result; // eax
  HWND v6; // eax
  HWND DlgItem; // eax
  HWND v8; // eax
  HWND v9; // eax
  char *v10; // eax
  const char *v11; // edi
  char *v12; // eax
  int v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  int v17; // eax
  int v18; // edi
  HWND v19; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // eax
  LRESULT v23; // [esp+2Ch] [ebp-420h]
  WPARAM v24; // [esp+2Ch] [ebp-420h]
  INT_PTR v25; // [esp+30h] [ebp-41Ch]
  int v26; // [esp+34h] [ebp-418h]
  int i; // [esp+44h] [ebp-408h]
  char *String; // [esp+48h] [ebp-404h]
  char lParam[512]; // [esp+4Ch] [ebp-400h] BYREF
  LPARAM v30; // [esp+24Ch] [ebp-200h] BYREF
  char Buffer[508]; // [esp+250h] [ebp-1FCh] BYREF

  if ( msg == 16 )
  {
    grim_config_dialog_canceled = 1;
    v25 = (unsigned __int16)wparam;
LABEL_33:
    EndDialog((HWND)hwnd, v25);
    return 0;
  }
  if ( msg != 272 )
  {
    if ( msg == 273 )
    {
      switch ( (__int16)wparam )
      {
        case 1000:
          DlgItem = GetDlgItem((HWND)hwnd, 1007);
          byte_1005D0C8 = SendMessageA(DlgItem, 0xF0u, 0, 0) != 0;
          v8 = GetDlgItem((HWND)hwnd, 1017);
          memset(lParam, 0, sizeof(lParam));
          v23 = SendMessageA(v8, 0x147u, 0, 0);
          v9 = GetDlgItem((HWND)hwnd, 1017);
          SendMessageA(v9, 0x148u, v23, (LPARAM)lParam);
          byte_1005B280 = strstr(lParam, SubStr) != 0;
          v10 = strchr(lParam, 120);
          *v10 = 0;
          v11 = v10 + 1;
          v12 = strchr(v10 + 1, 120);
          if ( v12 )
          {
            *v12 = 0;
            String = v12 + 1;
            v12[4] = 0;
          }
          else
          {
            String = a32;
          }
          dword_10053054 = atoi(lParam);
          dword_10053058 = atoi(v11);
          dword_1005CE28 = dword_10053058;
          dword_1005CE18 = dword_10053054;
          LOBYTE(dword_1005B2B8) = atoi(String) == 16;
          v13 = -(unsigned __int8)dword_1005B2B8;
          LOBYTE(v13) = v13 & 0xF0;
          dword_1005CE38 = v13 + 32;
          sprintf(lParam, "w: %d h %d bpp %d\n", dword_10053054, dword_10053058, (unsigned __int8)dword_1005B2B8);
          grim_config_dialog_canceled = 0;
          v14 = GetDlgItem((HWND)hwnd, 1009);
          wParam = SendMessageA(v14, 0x147u, 0, 0);
          EndDialog((HWND)hwnd, (unsigned __int16)wparam);
          return 0;
        case 1001:
          grim_config_dialog_canceled = 1;
          v25 = (unsigned __int16)wparam;
          goto LABEL_33;
        case 1009:
          v4 = GetDlgItem((HWND)hwnd, 1009);
          wParam = SendMessageA(v4, 0x147u, 0, 0);
          sub_10001E90();
          result = 0;
          break;
        case 1010:
          if ( HlinkNavigateString(0, szTarget) >= 0 )
            return 0;
          MessageBoxA(0, aFailedToOpenBr, aCrimsonland, 0x30u);
          result = 0;
          break;
        case 1013:
          if ( WinExec(CmdLine, 3u) > 0x1F )
            return 0;
          MessageBoxA(0, aFailedToOpenTh, aCrimsonland, 0x30u);
          result = 0;
          break;
        case 1019:
          if ( sub_10001A30() )
            DialogBoxParamA(grim_module_handle, (LPCSTR)0x89, (HWND)hwnd, DialogFunc, 0);
          else
            MessageBoxA((HWND)hwnd, aUnableToLoadCo, aParentalLockPr, 0x40u);
          result = 0;
          break;
        case 1020:
          v6 = GetDlgItem((HWND)hwnd, 1009);
          wParam = SendMessageA(v6, 0x147u, 0, 0);
          DialogBoxParamA(grim_module_handle, (LPCSTR)0x8A, (HWND)hwnd, sub_10001170, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return 0;
  }
  hDlg = (HWND)hwnd;
  v15 = GetDlgItem((HWND)hwnd, 1010);
  ShowWindow(v15, 5);
  v16 = GetDlgItem((HWND)hwnd, 1035);
  ShowWindow(v16, 0);
  SendMessageA((HWND)hwnd, 0x80u, 1u, ::lParam);
  SendMessageA((HWND)hwnd, 0x80u, 0, ::lParam);
  GetLocalTime(&SystemTime);
  v17 = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_d3d8_probe + 16))(grim_d3d8_probe);
  v18 = 0;
  byte_1005BDFC[256] = 0;
  for ( i = v17; v18 < i; ++v18 )
  {
    (*(void (__stdcall **)(void *, int, int, void *, int))(*(_DWORD *)grim_d3d8_probe + 20))(
      grim_d3d8_probe,
      v18,
      2,
      &unk_10059788,
      v26);
    if ( v18 )
      sprintf(Buffer, "%s", &unk_10059988);
    else
      sprintf(Buffer, "%s (default)", &unk_10059988);
    v26 = 0;
    if ( (*(int (__stdcall **)(void *, int, int, int, int))(*(_DWORD *)grim_d3d8_probe + 36))(
           grim_d3d8_probe,
           v18,
           1,
           23,
           23) >= 0
      || (*(int (__stdcall **)(void *, int, int, int, int, _DWORD))(*(_DWORD *)grim_d3d8_probe + 36))(
           grim_d3d8_probe,
           v18,
           1,
           22,
           22,
           0) >= 0 )
    {
      v19 = GetDlgItem((HWND)hwnd, 1009);
      SendMessageA(v19, 0x143u, 0, (LPARAM)&v30);
      byte_1005BDFC[256] = 1;
    }
  }
  v24 = wParam;
  v20 = GetDlgItem((HWND)hwnd, 1009);
  SendMessageA(v20, 0x14Eu, v24, 0);
  v21 = GetDlgItem((HWND)hwnd, 1009);
  wParam = SendMessageA(v21, 0x147u, 0, 0);
  sub_10001E90();
  if ( !byte_1005BDFC[256] )
  {
    v22 = GetDlgItem((HWND)hwnd, 1009);
    SendMessageA(v22, 0x143u, 0, (LPARAM)aNoSupportedDis);
    if ( MessageBoxA((HWND)hwnd, aNoSupportedDis_0, aCrimsonland, 0x33u) != 6 )
    {
      grim_config_dialog_canceled = 1;
      EndDialog((HWND)hwnd, (unsigned __int16)wparam);
    }
  }
  return 1;
}

// grim_window_create @ 0x10002680
// registers the window class and creates the main game window
BOOL grim_window_create()
{
  CHAR *ModuleHandleA; // eax
  HWND Window; // eax
  int v2; // esi
  int SystemMetrics; // eax
  BOOL result; // eax
  int v5; // [esp-20h] [ebp-30h]
  int v6; // [esp-1Ch] [ebp-2Ch]
  HWND v7; // [esp-18h] [ebp-28h]
  HWND DesktopWindow; // [esp-18h] [ebp-28h]
  HINSTANCE v9; // [esp-10h] [ebp-20h]
  HINSTANCE v10; // [esp-10h] [ebp-20h]
  struct tagRECT Rect; // [esp+0h] [ebp-10h] BYREF

  ModuleHandleA = (CHAR *)lpModuleName;
  if ( !lpModuleName )
  {
    ModuleHandleA = (CHAR *)GetModuleHandleA(0);
    lpModuleName = ModuleHandleA;
  }
  stru_10059DC8.hInstance = (HINSTANCE)ModuleHandleA;
  stru_10059DC8.cbSize = 48;
  stru_10059DC8.style = 3;
  stru_10059DC8.lpfnWndProc = sub_100033B0;
  stru_10059DC8.cbClsExtra = 0;
  stru_10059DC8.cbWndExtra = 0;
  stru_10059DC8.hIcon = (HICON)lParam;
  stru_10059DC8.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  stru_10059DC8.hbrBackground = (HBRUSH)GetStockObject(4);
  stru_10059DC8.lpszMenuName = 0;
  stru_10059DC8.lpszClassName = aCrimson;
  stru_10059DC8.hIconSm = (HICON)lParam;
  RegisterClassExA(&stru_10059DC8);
  if ( (_BYTE)dword_1005CC08 )
  {
    v2 = GetSystemMetrics(0) / 2;
    SystemMetrics = GetSystemMetrics(1);
    Rect.right = v2 + ((unsigned int)grim_backbuffer_width >> 1);
    SystemMetrics /= 2;
    Rect.left = v2 - ((unsigned int)grim_backbuffer_width >> 1);
    Rect.top = SystemMetrics - ((unsigned int)grim_backbuffer_height >> 1);
    Rect.bottom = SystemMetrics + ((unsigned int)grim_backbuffer_height >> 1);
    AdjustWindowRectEx(&Rect, 0xCB0000u, 0, 0x40000u);
    v10 = (HINSTANCE)lpModuleName;
    DesktopWindow = GetDesktopWindow();
    Window = CreateWindowExA(
               0x40000u,
               stru_10059DC8.lpszClassName,
               lpWindowName,
               0xCB0000u,
               Rect.left,
               Rect.top,
               Rect.right - Rect.left,
               Rect.bottom - Rect.top,
               DesktopWindow,
               0,
               v10,
               0);
  }
  else
  {
    v9 = (HINSTANCE)lpModuleName;
    v7 = GetDesktopWindow();
    v6 = GetSystemMetrics(1);
    v5 = GetSystemMetrics(0);
    Window = CreateWindowExA(8u, stru_10059DC8.lpszClassName, lpWindowName, 0x80000000, 0, 0, v5, v6, v7, 0, v9, 0);
  }
  hwnd = Window;
  if ( Window )
  {
    ShowWindow(Window, 1);
    UpdateWindow(hwnd);
    SetFocus(hwnd);
    ShowWindow(hwnd, 1);
    result = UpdateWindow(hwnd);
    LOBYTE(result) = 1;
  }
  else
  {
    grim_error_text = (int)aWinCouldNotCre;
    result = grim_window_destroy();
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_window_destroy @ 0x10002880
// posts quit and destroys the main window
BOOL grim_window_destroy()
{
  HWND v0; // eax

  PostQuitMessage(0);
  v0 = hwnd;
  if ( hwnd )
  {
    DestroyWindow(hwnd);
    v0 = hwnd;
  }
  if ( dword_1005D3FC )
    DestroyWindow(v0);
  return UnregisterClassA(stru_10059DC8.lpszClassName, stru_10059DC8.hInstance);
}

// grim_backup_textures @ 0x100028D0
// backup texture surfaces before device reset
int grim_backup_textures()
{
  int result; // eax
  int v1; // edi
  void **v2; // esi
  int v3; // ebp
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+40h] [ebp-14h] BYREF
  int v9; // [esp+44h] [ebp-10h]
  int v10; // [esp+48h] [ebp-Ch]
  __int64 v11; // [esp+4Ch] [ebp-8h]

  grim_noop();
  if ( byte_1005D810 )
  {
    grim_noop();
    if ( byte_1005D810 )
    {
      LOBYTE(result) = 1;
      return result;
    }
  }
  result = dword_1005305C;
  v1 = 0;
  v8 = 0;
  if ( dword_1005305C < 0 )
  {
LABEL_15:
    LOBYTE(result) = 1;
    byte_1005D810 = 1;
    return result;
  }
  v2 = &grim_texture_slots;
  while ( 1 )
  {
    if ( !*v2 || !*((_BYTE *)*v2 + 8) )
      goto LABEL_14;
    grim_noop();
    if ( (*(int (__stdcall **)(void *, _DWORD, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 108))(
           grim_d3d_device,
           *((_DWORD *)*v2 + 3),
           *((_DWORD *)*v2 + 4),
           grim_texture_format,
           (int)*v2 + 20) < 0 )
    {
      grim_error_text = (int)aD3dUnableToBac;
      grim_noop();
      grim_noop();
      LOBYTE(result) = 0;
      return result;
    }
    if ( (*(int (__stdcall **)(_DWORD, _DWORD, int *))(**((_DWORD **)*v2 + 1) + 60))(*((_DWORD *)*v2 + 1), 0, &v8) < 0 )
      break;
    v3 = (*(int (__stdcall **)(void *, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 112))(
           grim_d3d_device,
           v8,
           0,
           0,
           *((_DWORD *)*v2 + 5),
           0);
    if ( v3 < 0 )
    {
      v6 = (int)*(&grim_texture_slots + v1);
      v7 = *(_DWORD *)(v6 + 20);
      if ( v7 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(_DWORD *)(v6 + 20)) )
        *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
      if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
        v8 = 0;
      grim_error_text = (int)aD3dUnableToBac_1;
      grim_noop();
      LOBYTE(v9) = 1;
      dword_1005D0F8 = v9;
      dword_1005D0FC = v10;
      qword_1005D100 = v11;
      grim_noop();
      LOBYTE(result) = 0;
      return result;
    }
    if ( v8 )
    {
      if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
        v8 = 0;
    }
LABEL_14:
    result = dword_1005305C;
    ++v1;
    ++v2;
    if ( v1 > dword_1005305C )
      goto LABEL_15;
  }
  v4 = (int)*(&grim_texture_slots + v1);
  v5 = *(_DWORD *)(v4 + 20);
  if ( v5 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(*(_DWORD *)(v4 + 20)) )
    *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
  grim_error_text = (int)aD3dUnableToBac_0;
  grim_noop();
  grim_noop();
  LOBYTE(result) = 0;
  return result;
}

// grim_restore_textures @ 0x10002B40
// restore texture surfaces after device reset
int grim_restore_textures()
{
  int result; // eax
  int v1; // edi
  void **v2; // esi
  _BYTE *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+28h] [ebp-14h] BYREF
  int v9; // [esp+2Ch] [ebp-10h]
  int v10; // [esp+30h] [ebp-Ch]
  __int64 v11; // [esp+34h] [ebp-8h]

  if ( byte_1005D804 )
  {
    LOBYTE(result) = 0;
    return result;
  }
  grim_noop();
  if ( !byte_1005D810 )
  {
    grim_noop();
    if ( !byte_1005D810 )
    {
      LOBYTE(result) = 0;
      return result;
    }
  }
  result = dword_1005305C;
  v1 = 0;
  v8 = 0;
  if ( dword_1005305C < 0 )
  {
LABEL_21:
    byte_1005D810 = 0;
    LOBYTE(result) = 1;
    return result;
  }
  v2 = &grim_texture_slots;
  while ( 1 )
  {
    v3 = *v2;
    if ( *v2 )
    {
      if ( v3[8] && *((_DWORD *)v3 + 5) )
        break;
    }
LABEL_20:
    result = dword_1005305C;
    ++v1;
    ++v2;
    if ( v1 > dword_1005305C )
      goto LABEL_21;
  }
  grim_noop();
  v4 = *((_DWORD *)*v2 + 1);
  if ( v4 && (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v4 + 60))(v4, 0, &v8) < 0 )
  {
    grim_error_text = (int)aD3dUnableToRec;
    grim_noop();
    LOBYTE(result) = 0;
    return result;
  }
  if ( (*(int (__stdcall **)(void *, _DWORD, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 112))(
         grim_d3d_device,
         *((_DWORD *)*v2 + 5),
         0,
         0,
         v8,
         0) >= 0 )
  {
    if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
      v8 = 0;
    v5 = *((_DWORD *)*v2 + 5);
    if ( v5 )
    {
      if ( !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(*((_DWORD *)*v2 + 5)) )
        *((_DWORD *)*v2 + 5) = 0;
    }
    goto LABEL_20;
  }
  if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
    v8 = 0;
  v6 = (int)*(&grim_texture_slots + v1);
  v7 = *(_DWORD *)(v6 + 20);
  if ( v7 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(_DWORD *)(v6 + 20)) )
    *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
  LOBYTE(v9) = 1;
  dword_1005D0F8 = v9;
  byte_1005D810 = 0;
  grim_error_text = (int)aD3dUnableToRes;
  dword_1005D0FC = v10;
  qword_1005D100 = v11;
  grim_noop();
  LOBYTE(result) = 0;
  return result;
}

// sub_10002CF0 @ 0x10002CF0
int sub_10002CF0()
{
  int v0; // edi
  void **v1; // esi
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // edi
  void **v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edi
  void **v10; // esi
  _BYTE *v11; // eax
  int v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+20h] [ebp-Ch]
  int v15; // [esp+24h] [ebp-8h]
  int v16; // [esp+28h] [ebp-4h]

  grim_noop();
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  v0 = 0;
  if ( dword_1005305C >= 0 )
  {
    v1 = &grim_texture_slots;
    do
    {
      v2 = *v1;
      if ( *v1 )
      {
        if ( *((_BYTE *)v2 + 8) )
        {
          v3 = v2[1];
          if ( v3 )
          {
            if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3) )
              *((_DWORD *)*v1 + 1) = 0;
          }
        }
      }
      ++v0;
      ++v1;
    }
    while ( v0 <= dword_1005305C );
  }
  while ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)grim_d3d_device + 56))(grim_d3d_device, &grim_present_width) )
  {
    ++dword_1005D808;
    Sleep(0x1F4u);
    if ( dword_1005D808 >= 4 )
    {
      grim_error_text = (int)aD3dUnableToRes_0;
      if ( MessageBoxA(hwnd, aD3dUnableToRes_0, Caption, 5u) == 2 )
      {
        grim_noop();
        return -2005530519;
      }
      v4 = 0;
      if ( dword_1005305C >= 0 )
      {
        v5 = &grim_texture_slots;
        do
        {
          v6 = *v5;
          if ( *v5 && *((_BYTE *)v6 + 8) )
          {
            v7 = v6[5];
            if ( v7 && !(*(int (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7) )
              *((_DWORD *)*v5 + 5) = 0;
            v8 = *((_DWORD *)*v5 + 1);
            if ( v8 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 8))(*((_DWORD *)*v5 + 1)) )
              *((_DWORD *)*v5 + 1) = 0;
            LOBYTE(v13) = 1;
            dword_1005D0F8 = v13;
            dword_1005D0FC = v14;
            qword_1005D100 = v15;
            MEMORY[0x1005D104] = v16;
          }
          ++v4;
          ++v5;
        }
        while ( v4 <= dword_1005305C );
      }
    }
  }
  sub_10004520();
  v9 = 0;
  if ( dword_1005305C >= 0 )
  {
    v10 = &grim_texture_slots;
    do
    {
      v11 = *v10;
      if ( *v10
        && v11[8]
        && (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d_device + 80))(
             grim_d3d_device,
             *((_DWORD *)v11 + 3),
             *((_DWORD *)v11 + 4),
             1,
             1,
             grim_texture_format,
             0,
             v11 + 4) < 0 )
      {
        grim_error_text = (int)aD3dUnableToRec_0;
        grim_noop();
        *((_DWORD *)*v10 + 1) = 0;
        Sleep(0xC8u);
      }
      ++v9;
      ++v10;
    }
    while ( v9 <= dword_1005305C );
  }
  if ( !grim_restore_textures() )
    grim_noop();
  grim_noop();
  dword_1005D808 = 0;
  return 0;
}

// FUN_10002f60 @ 0x10002F60
// [binja] BOOL __fastcall sub_10002f60(void* arg1)
bool FUN_10002f60(void *arg1)
{
  int v1; // ecx
  int v2; // esi
  int v3; // eax

  v2 = v1;
  v3 = *(_DWORD *)(v1 + 28);
  if ( v3 )
  {
    LOBYTE(v3) = DeleteObject(*(HGDIOBJ *)(v1 + 28));
    *(_DWORD *)(v2 + 28) = 0;
  }
  return v3;
}

// FUN_10002f80 @ 0x10002F80
// [binja] uint32_t __fastcall sub_10002f80(void* arg1)
uint FUN_10002f80(void *arg1)
{
  int v1; // ecx
  int v2; // esi
  uint result; // eax
  int v4; // edx
  signed int v5; // edx

  v2 = v1;
  result = timeGetTime();
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 >= 0 )
  {
    *(_DWORD *)(v2 + 4) = result;
    v5 = result - v4 + *(_DWORD *)(v2 + 8);
    result = v5;
    *(_DWORD *)(v2 + 8) = v5;
    if ( v5 >= 30 )
    {
      result = v5 / 30;
      LOBYTE(result) = 1;
      *(_DWORD *)(v2 + 8) = v5 % 30;
    }
    else
    {
      LOBYTE(result) = 0;
    }
  }
  else
  {
    *(_DWORD *)(v2 + 4) = result;
    LOBYTE(result) = 0;
  }
  return result;
}

// FUN_10002fc0 @ 0x10002FC0
// [binja] int32_t __fastcall sub_10002fc0(char* arg1)
int FUN_10002fc0(char *arg1)
{
  int v1; // ecx
  int v2; // esi
  LONG bottom; // eax
  int result; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF

  v2 = v1;
  grim_noop();
  *(_BYTE *)v2 = 0;
  *(_DWORD *)(v2 + 4) = -1;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 28) = 0;
  *(_DWORD *)(v2 + 36) = 0;
  *(_BYTE *)(v2 + 41) = 0;
  *(_BYTE *)(v2 + 40) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  GetClientRect(hwnd, &Rect);
  bottom = Rect.bottom;
  *(_DWORD *)(v2 + 16) = Rect.right;
  *(_DWORD *)(v2 + 12) = bottom;
  *(_DWORD *)(v2 + 16) = grim_backbuffer_width;
  *(_DWORD *)(v2 + 12) = grim_backbuffer_height;
  memset(DstBuf, 0, 0x104u);
  getcwd(DstBuf, 260);
  LOBYTE(Rect.left) = 0;
  xmmword_1005D1C8 = (__int128)Rect;
  result = Rect.bottom;
  LOBYTE(result) = 1;
  return result;
}

// sub_100030B0 @ 0x100030B0
char sub_100030B0()
{
  int v0; // eax
  int v1; // edi
  void **v2; // esi
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // esi
  void **v6; // edi
  _BYTE *v7; // eax
  _DWORD *v8; // ecx
  int v10; // edi
  void **v11; // esi
  _DWORD *v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edi
  void **v16; // esi
  _DWORD *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // [esp+28h] [ebp-10h]
  int v21; // [esp+2Ch] [ebp-Ch]
  int v22; // [esp+30h] [ebp-8h]
  int v23; // [esp+34h] [ebp-4h]

  if ( !grim_d3d_device )
    return 0;
  v0 = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
  byte_1005C898 = v0 == 0;
  if ( v0 != -2005530519 )
    return 1;
  Sleep(0x64u);
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  v1 = 0;
  if ( dword_1005305C >= 0 )
  {
    v2 = &grim_texture_slots;
    do
    {
      v3 = *v2;
      if ( *v2 )
      {
        if ( *((_BYTE *)v3 + 8) )
        {
          v4 = v3[1];
          if ( v4 )
          {
            if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4) )
              *((_DWORD *)*v2 + 1) = 0;
          }
        }
      }
      ++v1;
      ++v2;
    }
    while ( v1 <= dword_1005305C );
  }
  if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)grim_d3d_device + 56))(grim_d3d_device, &grim_present_width) )
  {
    ++dword_1005D808;
    Sleep(0x1F4u);
    if ( dword_1005D808 == 5 )
    {
      v10 = 0;
      if ( dword_1005305C < 0 )
        return 1;
      v11 = &grim_texture_slots;
      do
      {
        v12 = *v11;
        if ( *v11 && *((_BYTE *)v12 + 8) )
        {
          v13 = v12[5];
          if ( v13 && !(*(int (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13) )
            *((_DWORD *)*v11 + 5) = 0;
          v14 = *((_DWORD *)*v11 + 1);
          if ( v14 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v14 + 8))(*((_DWORD *)*v11 + 1)) )
            *((_DWORD *)*v11 + 1) = 0;
          LOBYTE(v20) = 1;
          dword_1005D0FC = v21;
          dword_1005D0F8 = v20;
          qword_1005D100 = v22;
          MEMORY[0x1005D104] = v23;
        }
        ++v10;
        ++v11;
      }
      while ( v10 <= dword_1005305C );
    }
    if ( dword_1005D808 > 6 )
    {
      grim_error_text = (int)aD3dUnableToRes_0;
      if ( MessageBoxA(hwnd, aD3dUnableToRes_0, Caption, 5u) != 2 )
      {
        v15 = 0;
        if ( dword_1005305C >= 0 )
        {
          v16 = &grim_texture_slots;
          do
          {
            v17 = *v16;
            if ( *v16 && *((_BYTE *)v17 + 8) )
            {
              v18 = v17[5];
              if ( v18 && !(*(int (__stdcall **)(int))(*(_DWORD *)v18 + 8))(v18) )
                *((_DWORD *)*v16 + 5) = 0;
              v19 = *((_DWORD *)*v16 + 1);
              if ( v19 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v19 + 8))(*((_DWORD *)*v16 + 1)) )
                *((_DWORD *)*v16 + 1) = 0;
              LOBYTE(v20) = 1;
              dword_1005D0FC = v21;
              dword_1005D0F8 = v20;
              qword_1005D100 = v22;
              MEMORY[0x1005D104] = v23;
            }
            ++v15;
            ++v16;
          }
          while ( v15 <= dword_1005305C );
        }
        return 1;
      }
      return 0;
    }
    return 1;
  }
  sub_10004520();
  v5 = 0;
  if ( dword_1005305C >= 0 )
  {
    v6 = &grim_texture_slots;
    do
    {
      v7 = *v6;
      if ( *v6
        && v7[8]
        && (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d_device + 80))(
             grim_d3d_device,
             *((_DWORD *)v7 + 3),
             *((_DWORD *)v7 + 4),
             1,
             1,
             grim_texture_format,
             0,
             v7 + 4) < 0 )
      {
        v8 = *v6;
        grim_error_text = (int)aD3dUnableToRec_0;
        v8[1] = 0;
        grim_noop();
        grim_noop();
      }
      ++v5;
      ++v6;
    }
    while ( v5 <= dword_1005305C );
  }
  grim_restore_textures();
  dword_1005D808 = 0;
  return 1;
}

// sub_100033B0 @ 0x100033B0
int __stdcall sub_100033B0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax
  int v5; // eax
  struct tagPAINTSTRUCT Paint; // [esp+Ch] [ebp-40h] BYREF

  grim_noop();
  if ( byte_1005D804 )
  {
    switch ( Msg )
    {
      case 2u:
      case 0x10u:
        byte_1005D804 = 0;
        byte_1005BC00 = 0;
        goto LABEL_19;
      case 6u:
        if ( !(_WORD)wParam || HIWORD(wParam) )
        {
          grim_noop();
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
          byte_1005A470 = 1;
          dword_1005D3A8();
          grim_backup_textures();
          byte_1005C898 = 0;
          return 0;
        }
        grim_noop();
        sub_100030B0();
        if ( !grim_d3d_device )
          goto LABEL_12;
        goto LABEL_10;
      case 0xFu:
        BeginPaint(hwnd, &Paint);
        EndPaint(hwnd, &Paint);
        byte_1005BC01 = 1;
        LOBYTE(dword_1005D0F8) = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x14u:
        goto LABEL_74;
      case 0x1Cu:
        if ( !wParam )
        {
          grim_noop();
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
          byte_1005A470 = 1;
          if ( !byte_1005C898 )
            goto LABEL_41;
          dword_1005D3A8();
          grim_backup_textures();
          byte_1005C898 = 0;
          return 0;
        }
        grim_noop();
        sub_100030B0();
        if ( !byte_1005C898 )
          goto LABEL_12;
LABEL_10:
        grim_restore_textures();
        sub_10004520();
        break;
      case 0x1Fu:
        grim_noop();
        grim_backup_textures();
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
LABEL_11:
    byte_1005D811 = 0;
    byte_1005A470 = 0;
    return 0;
  }
  if ( Msg > 0x200 )
  {
    switch ( Msg )
    {
      case 0x201u:
        if ( (_BYTE)grim_input_cached )
          grim_mouse_button_cache = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x202u:
        if ( (_BYTE)grim_input_cached )
          grim_mouse_button_cache = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x204u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A045 = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x205u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A045 = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x207u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A046 = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x208u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A046 = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x20Au:
        if ( (_BYTE)grim_input_cached )
          flt_1005D3B8 = (float)SHIWORD(wParam);
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x231u:
LABEL_40:
        byte_1005A470 = 1;
LABEL_41:
        byte_1005C898 = 0;
        result = 0;
        break;
      case 0x232u:
        goto LABEL_52;
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
  }
  else if ( Msg == 512 )
  {
    if ( (_BYTE)grim_input_cached )
    {
      grim_mouse_x_cached = (float)(__int16)lParam;
      grim_mouse_y_cached = (float)SHIWORD(lParam);
    }
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  else if ( Msg > 0x1C )
  {
    switch ( Msg )
    {
      case 0x1Fu:
        grim_noop();
        grim_backup_textures();
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x102u:
        if ( (_BYTE)wParam != 0xA7 && (_BYTE)wParam != 9 )
        {
          v5 = dword_1005D3E4;
          if ( dword_1005D3E4 < 7 )
          {
            dword_1005D3C4[dword_1005D3E4] = wParam;
            dword_1005D3E4 = v5 + 1;
          }
          if ( wParam == 8 )
          {
            if ( *(int *)off_1005304C <= 0 )
            {
              *(_BYTE *)off_10053048 = 0;
            }
            else
            {
              --*(_DWORD *)off_1005304C;
              *((_BYTE *)off_10053048 + *(_DWORD *)off_1005304C) = 0;
            }
          }
          else if ( wParam != 13 && *(_DWORD *)off_1005304C < dword_10053050 - 1 )
          {
            *((_BYTE *)off_10053048 + (*(_DWORD *)off_1005304C)++) = wParam;
            *((_BYTE *)off_10053048 + *(_DWORD *)off_1005304C) = 0;
          }
        }
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x104u:
      case 0x105u:
        goto LABEL_74;
      case 0x112u:
        if ( wParam > 0xF030 )
        {
          if ( wParam != 61760 && wParam != 61808 )
            return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        else if ( wParam != 61488 && wParam != 61440 && wParam != 61456 )
        {
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        if ( (_BYTE)dword_1005CC08 )
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
LABEL_74:
        result = 1;
        break;
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
  }
  else
  {
    if ( Msg != 28 )
    {
      switch ( Msg )
      {
        case 1u:
          SendMessageA(hwnd, 0x80u, 1u, ::lParam);
          SendMessageA(hwnd, 0x80u, 0, ::lParam);
          hwnd = hWnd;
          SetFocus(hWnd);
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        case 5u:
          if ( wParam == 4 || wParam == 1 )
          {
            byte_1005A470 = 1;
            byte_1005C898 = 0;
          }
          else
          {
            byte_1005A470 = 0;
          }
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        case 6u:
          if ( !(_WORD)wParam || HIWORD(wParam) )
          {
            grim_noop();
            if ( !byte_1005C898 )
              grim_noop();
            if ( grim_d3d_device )
            {
              grim_backup_textures();
              dword_1005D3A8();
            }
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
            goto LABEL_40;
          }
          grim_noop();
          if ( !byte_1005C898 )
          {
            grim_noop();
            if ( !byte_1005C898 )
            {
LABEL_12:
              byte_1005D811 = 1;
              byte_1005A470 = 0;
              return 0;
            }
          }
          grim_restore_textures();
          sub_10004520();
          dword_10059770();
          break;
        case 0x10u:
LABEL_19:
          PostQuitMessage(0);
          return 0;
        default:
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
      goto LABEL_11;
    }
    if ( wParam )
    {
      grim_noop();
      if ( byte_1005C898 || (grim_noop(), byte_1005C898) )
      {
        grim_restore_textures();
        sub_10004520();
        dword_10059770();
        byte_1005D811 = 0;
        byte_1005A470 = 0;
        return 0;
      }
      else
      {
        byte_1005D811 = 1;
LABEL_52:
        byte_1005A470 = 0;
        return 0;
      }
    }
    else
    {
      grim_noop();
      if ( !byte_1005C898 )
        grim_noop();
      if ( grim_d3d_device )
      {
        grim_backup_textures();
        dword_1005D3A8();
      }
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
      byte_1005A470 = 1;
      byte_1005C898 = 0;
      return 0;
    }
  }
  return result;
}

// sub_10003C00 @ 0x10003C00
int __usercall sub_10003C00@<eax>(char *a1@<edi>)
{
  float *v1; // ecx
  double v2; // st7
  int v3; // eax
  int v4; // eax
  struct tagMSG Msg; // [esp+0h] [ebp-1Ch] BYREF

  memset(&Msg, 0, sizeof(Msg));
  PeekMessageA(&Msg, 0, 0, 0, 0);
  sub_10004920();
  sub_10004970();
  sub_10004920();
  sub_10004970();
  sub_10004970();
  FUN_10002fc0(a1);
  SetFocus(hwnd);
  SetForegroundWindow(hwnd);
  if ( hwnd && Msg.message != 18 )
  {
    do
    {
      if ( PeekMessageA(&Msg, 0, 0, 0, 1u) )
      {
        TranslateMessage(&Msg);
        DispatchMessageA(&Msg);
      }
      else
      {
        if ( !byte_1005D804 )
          sub_10004970();
        if ( !grim_paused_flag && !byte_1005D804 && byte_1005C898 && !byte_1005A470 )
        {
          if ( (_BYTE)dword_1005CC38 )
          {
            grim_keyboard_poll();
            v1 = flt_1005A058;
            do
            {
              v2 = *v1 - grim_frame_dt;
              *v1 = v2;
              if ( v2 < 0.0 )
                *v1 = 0.0;
              ++v1;
            }
            while ( (int)v1 < (int)&ElementSize );
          }
          grim_joystick_poll();
          dword_1005CF14 = (int)&grim_joystick_state;
          if ( !(_BYTE)grim_input_cached )
          {
            LODWORD(grim_mouse_x_cached) = grim_mouse_x;
            LODWORD(grim_mouse_y_cached) = grim_mouse_y;
            grim_mouse_poll();
          }
        }
        byte_1005C898 = 0;
        if ( byte_1005D804 )
        {
          byte_1005A470 = 1;
          FUN_10003090();
        }
        if ( byte_1005A470 )
        {
          if ( !byte_1005D804 )
            Sleep(0x32u);
        }
        else if ( !byte_1005D804 && grim_d3d_device )
        {
          v3 = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
          byte_1005C898 = v3 == 0;
          if ( v3 )
          {
            Sleep(0x1F4u);
            v4 = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
            byte_1005C898 = v4 == 0;
            if ( v4 == -2005530519 && sub_10002CF0() == -2005530519 )
              break;
          }
          else
          {
            if ( byte_1005D811 )
            {
              dword_10059770();
              byte_1005D811 = 0;
            }
            if ( !(unsigned __int8)dword_1005977C() )
              break;
            if ( dword_1005D3B4 )
              (*(void (__thiscall **)(int))(*(_DWORD *)dword_1005D3B4 + 20))(dword_1005D3B4);
            if ( !grim_render_disabled )
              (*(void (__stdcall **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 60))(
                grim_d3d_device,
                0,
                0,
                0,
                0);
          }
        }
      }
    }
    while ( Msg.message != 18 );
  }
  timeEndPeriod(1u);
  j_FUN_10002f60(dword_1005BBD8);
  if ( (_BYTE)grim_input_cached )
    ShowCursor(1);
  grim_window_destroy();
  return 0;
}

// grim_d3d_init @ 0x10003E60
// creates the Direct3D8 interface, configures display mode, and opens the window
int grim_d3d_init()
{
  int result; // eax
  bool v1; // bl
  char *v2; // eax
  HRSRC ResourceA; // esi
  HGLOBAL Resource; // eax
  void *v5; // edi
  int *v6; // eax
  HRSRC v7; // esi
  HGLOBAL v8; // eax
  void *v9; // edi
  int *v10; // eax
  _BYTE v11[12]; // [esp+20h] [ebp-43Ch] BYREF
  int v12; // [esp+2Ch] [ebp-430h]
  char v13[512]; // [esp+30h] [ebp-42Ch] BYREF
  char Str[556]; // [esp+230h] [ebp-22Ch] BYREF

  byte_1005C898 = 0;
  grim_d3d8 = 0;
  grim_d3d_device = 0;
  dword_1005B2B4 = 1;
  if ( (_BYTE)dword_1005CEC8 == 1 )
    dword_1005B2B4 = 2;
  result = Direct3DCreate8(220);
  grim_d3d8 = (void *)result;
  if ( !result )
  {
    grim_error_text = (int)Text;
    LOBYTE(result) = 0;
    return result;
  }
  (*(void (__stdcall **)(int, WPARAM, int, void *))(*(_DWORD *)result + 52))(
    result,
    wParam,
    dword_1005B2B4,
    &unk_1005A498);
  v1 = 0;
  (*(void (__stdcall **)(void *, WPARAM, int, char *))(*(_DWORD *)grim_d3d8 + 20))(grim_d3d8, wParam, 2, v13);
  v2 = strchr(Str, 86);
  if ( v2 && v2[1] == 111 && v2[2] == 111 && v2[3] == 100 && v2[4] == 111 && v2[5] == 111 )
    v1 = v2[6] == 51;
  if ( (*(int (__stdcall **)(void *, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d8 + 32))(grim_d3d8, 0, v11) >= 0 )
  {
    result = grim_window_create();
    if ( !(_BYTE)result )
      return result;
    memset(&grim_present_width, 0, 0x34u);
    dword_10059E04 = dword_1005CEB8;
    if ( (_BYTE)dword_1005CC08 == 1 )
    {
      dword_10059E14 = 1;
      dword_10059E0C = 1;
      grim_texture_format = v12;
    }
    else
    {
      dword_10059E14 = 0;
      dword_10059E24 = 0;
      dword_10059E0C = v1 + 1;
      dword_10059E28 = 0x80000000;
    }
    grim_present_height = grim_backbuffer_height;
    grim_present_width = grim_backbuffer_width;
    dword_10059E00 = grim_texture_format;
    dword_10059E08 = 0;
    dword_10059E20 = 1;
    dword_10059E18 = byte_1005CED8 != 0;
    dword_10059E1C = 80;
    dword_10059E10 = dword_1005D3FC;
    if ( !dword_1005D3FC )
      dword_10059E10 = (int)hwnd;
    if ( (*(int (__stdcall **)(void *, WPARAM, int, HWND, int, int *, void **))(*(_DWORD *)grim_d3d8 + 60))(
           grim_d3d8,
           wParam,
           dword_1005B2B4,
           hwnd,
           32,
           &grim_present_width,
           &grim_d3d_device) < 0 )
    {
      grim_error_text = (int)aD3dCouldNotSet;
      MessageBoxA(0, aD3dCouldNotSet, Caption, 0);
      sub_10004280(&grim_vertex_buffer);
      result = grim_window_destroy();
      LOBYTE(result) = 0;
      return result;
    }
    (*(void (__stdcall **)(void *, WPARAM, int, void *))(*(_DWORD *)grim_d3d8 + 52))(
      grim_d3d8,
      wParam,
      dword_1005B2B4,
      &unk_1005A498);
    if ( !sub_10004350() )
    {
      sub_10004280(&grim_vertex_buffer);
      result = grim_window_destroy();
      LOBYTE(result) = 0;
      return result;
    }
    memset(&grim_texture_slots, 0, 0x400u);
    if ( grim_preferred_texture_format )
    {
      if ( (unsigned __int8)grim_is_texture_format_supported((unsigned int)grim_preferred_texture_format) )
      {
        if ( grim_preferred_texture_format )
        {
LABEL_33:
          sub_10004520();
          ResourceA = FindResourceA(grim_module_handle, (LPCSTR)0x6F, (LPCSTR)0xA);
          Resource = LoadResource(grim_module_handle, ResourceA);
          v5 = LockResource(Resource);
          v6 = (int *)SizeofResource(grim_module_handle, ResourceA);
          result = FUN_1000cb5c(
                     (int **)grim_d3d_device,
                     v5,
                     v6,
                     -1,
                     -1,
                     1,
                     0,
                     grim_preferred_texture_format,
                     1,
                     -1,
                     (int **)0xFFFFFFFF,
                     0,
                     0,
                     0,
                     (int)&grim_font_texture);
          if ( result >= 0 )
          {
            v7 = FindResourceA(grim_module_handle, (LPCSTR)0x71, (LPCSTR)0xA);
            v8 = LoadResource(grim_module_handle, v7);
            v9 = LockResource(v8);
            v10 = (int *)SizeofResource(grim_module_handle, v7);
            result = FUN_1000cb5c(
                       (int **)grim_d3d_device,
                       v9,
                       v10,
                       -1,
                       -1,
                       1,
                       0,
                       grim_preferred_texture_format,
                       1,
                       -1,
                       (int **)0xFFFFFFFF,
                       0,
                       0,
                       0,
                       (int)&dword_1005D3F0);
            if ( result >= 0 )
            {
              result = (int)grim_d3d8;
              grim_backbuffer_surface = 0;
              grim_render_target_surface = 0;
              dword_1005D094 = (int)grim_d3d8;
              dword_1005D0A4 = (int)grim_d3d_device;
              byte_1005C898 = 1;
              LOBYTE(result) = 1;
            }
            else
            {
              grim_error_text = (int)aD3dUnableToLoa_0;
              LOBYTE(result) = 0;
            }
          }
          else
          {
            grim_error_text = (int)aD3dUnableToLoa;
            LOBYTE(result) = 0;
          }
          return result;
        }
      }
      else
      {
        grim_preferred_texture_format = 0;
      }
    }
    if ( !(unsigned __int8)grim_select_texture_format() )
    {
      grim_error_text = (int)aD3dCouldNotFin;
      sub_10004280(&byte_1005D804);
      grim_window_destroy();
    }
    goto LABEL_33;
  }
  result = (int)grim_d3d8;
  grim_error_text = (int)aD3dErrorGettin;
  if ( grim_d3d8 )
  {
    result = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_d3d8 + 8))(grim_d3d8);
    if ( !result )
      grim_d3d8 = 0;
  }
  LOBYTE(result) = 0;
  return result;
}

// sub_10004280 @ 0x10004280
void *__usercall sub_10004280@<eax>(void *a1@<edi>)
{
  void **v1; // edi
  void *v2; // esi
  void *result; // eax
  void *v4; // [esp-8h] [ebp-Ch]

  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(void *))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(void *))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_font_texture && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_font_texture + 8))(grim_font_texture) )
    grim_font_texture = 0;
  if ( dword_1005D3F0 && !(*(int (__stdcall **)(int))(*(_DWORD *)dword_1005D3F0 + 8))(dword_1005D3F0) )
    dword_1005D3F0 = 0;
  v4 = a1;
  v1 = &grim_texture_slots;
  do
  {
    v2 = *v1;
    if ( *v1 )
    {
      grim_texture_release(v4);
      operator delete(v2);
      *v1 = 0;
    }
    ++v1;
  }
  while ( (int)v1 < (int)&byte_1005D804 );
  sub_100044E0();
  if ( grim_d3d_device )
    (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 8))(grim_d3d_device);
  result = grim_d3d8;
  grim_d3d_device = 0;
  if ( grim_d3d8 )
    result = (void *)(*(int (__stdcall **)(void *))(*(_DWORD *)grim_d3d8 + 8))(grim_d3d8);
  grim_d3d8 = 0;
  return result;
}

// sub_10004350 @ 0x10004350
char sub_10004350()
{
  int v1; // eax
  __int16 v2; // cx
  __int16 v3; // di

  grim_vertex_capacity = 256;
  if ( (*(int (__stdcall **)(int, int, int, _DWORD, int, int *))(*(_DWORD *)grim_d3d_device + 92))(
         grim_d3d_device,
         7168,
         536,
         0,
         2,
         &grim_vertex_buffer) >= 0 )
  {
    if ( (*(int (__stdcall **)(int, int, int, int, int, int *))(*(_DWORD *)grim_d3d_device + 96))(
           grim_d3d_device,
           12 * grim_vertex_capacity,
           536,
           101,
           2,
           &dword_10059BB8) >= 0 )
    {
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)dword_10059BB8 + 44))(
             dword_10059BB8,
             0,
             0,
             &dword_1005B2C0,
             0x2000) >= 0 )
      {
        if ( grim_vertex_capacity )
        {
          v1 = 2;
          do
          {
            v2 = v1 - 2;
            *(_WORD *)dword_1005B2C0 = v1 - 2;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1 - 1;
            v3 = v1 + 1;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1;
            v1 += 4;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v3;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v2;
            dword_1005B2C0 += 2;
          }
          while ( (unsigned __int16)(v1 - 2) < (unsigned int)grim_vertex_capacity );
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)dword_10059BB8 + 48))(dword_10059BB8);
        (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 332))(
          grim_d3d_device,
          0,
          grim_vertex_buffer,
          28);
        (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 340))(grim_d3d_device, dword_10059BB8, 0);
        return 1;
      }
      else
      {
        byte_1005C898 = 0;
        return 0;
      }
    }
    else
    {
      grim_error_text = (int)aD3dInternalCou_0;
      sub_100044E0();
      return 0;
    }
  }
  else
  {
    grim_error_text = (int)aD3dInternalCou;
    return 0;
  }
}

// sub_100044E0 @ 0x100044E0
int sub_100044E0()
{
  int result; // eax

  if ( grim_vertex_buffer )
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 8))(grim_vertex_buffer);
  result = dword_10059BB8;
  grim_vertex_buffer = 0;
  if ( dword_10059BB8 )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)dword_10059BB8 + 8))(dword_10059BB8);
  dword_10059BB8 = 0;
  return result;
}

// sub_10004520 @ 0x10004520
int sub_10004520()
{
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 137, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 29, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 7, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 14, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 28, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 143, 0);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 22, 1);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 9, 2);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
    grim_d3d_device,
    26,
    (unsigned __int8)dword_1005D108);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 15, 1);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 25, 7);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 24, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 17, 2);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 16, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 18, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
  (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
  (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 11, 0);
  (*(void (__stdcall **)(int, int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 11, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 128, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 129, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 130, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 131, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 332))(
    grim_d3d_device,
    0,
    grim_vertex_buffer,
    28);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 340))(grim_d3d_device, dword_10059BB8, 0);
  (*(void (__stdcall **)(int, int))(*(_DWORD *)grim_d3d_device + 304))(grim_d3d_device, 324);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
    grim_d3d_device,
    27,
    (unsigned __int8)dword_1005CCA8);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 19, dword_1005CCB8);
  return (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 20, dword_1005CCC8);
}

// grim_is_texture_format_supported @ 0x100047F0
// checks device support for a texture format
int grim_is_texture_format_supported(unsigned int format)
{
  int result; // eax

  result = (*(int (__stdcall **)(void *, WPARAM, int, int, _DWORD, int, unsigned int))(*(_DWORD *)grim_d3d8 + 40))(
             grim_d3d8,
             wParam,
             dword_1005B2B4,
             grim_texture_format,
             0,
             3,
             format);
  LOBYTE(result) = result >= 0;
  return result;
}

// grim_select_texture_format @ 0x10004830
// chooses the first supported texture format
int grim_select_texture_format()
{
  int result; // eax

  result = grim_is_texture_format_supported(0x15u);
  if ( (_BYTE)result )
  {
    grim_preferred_texture_format = (void *)21;
    LOBYTE(result) = 1;
  }
  else
  {
    result = grim_is_texture_format_supported(0x33545844u);
    if ( (_BYTE)result )
    {
      grim_preferred_texture_format = (void *)861165636;
      LOBYTE(result) = 1;
    }
    else
    {
      result = grim_is_texture_format_supported(0x1Au);
      if ( (_BYTE)result )
      {
        grim_preferred_texture_format = (void *)26;
        LOBYTE(result) = 1;
      }
      else
      {
        result = grim_is_texture_format_supported(0x19u);
        if ( (_BYTE)result )
        {
          grim_preferred_texture_format = (void *)25;
          LOBYTE(result) = 1;
        }
        else
        {
          result = grim_is_texture_format_supported(0x14u);
          if ( (_BYTE)result )
          {
            grim_preferred_texture_format = (void *)20;
            LOBYTE(result) = 1;
          }
          else
          {
            result = grim_is_texture_format_supported(0x16u);
            if ( (_BYTE)result )
            {
              grim_preferred_texture_format = (void *)22;
              LOBYTE(result) = 1;
            }
            else
            {
              result = grim_is_texture_format_supported(0x14u);
              if ( (_BYTE)result )
              {
                grim_preferred_texture_format = (void *)20;
                LOBYTE(result) = 1;
              }
              else
              {
                result = grim_is_texture_format_supported(0x17u);
                if ( (_BYTE)result )
                {
                  grim_preferred_texture_format = (void *)23;
                  LOBYTE(result) = 1;
                }
                else
                {
                  grim_error_text = (int)aD3dNoSupported;
                  LOBYTE(result) = 0;
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

// sub_10004920 @ 0x10004920
MMRESULT sub_10004920()
{
  dword_1005D3B0 = 981668463;
  dword_1005BAD4 = timeGetTime();
  grim_fps = 0;
  grim_frame_dt = 0.0;
  grim_time_ms = 0;
  dword_10059DC4 = dword_1005BAD4;
  dword_1005BAD0 = dword_1005BAD4;
  byte_1005A470 = 0;
  return timeBeginPeriod(1u);
}

// sub_10004970 @ 0x10004970
int sub_10004970()
{
  int v0; // eax
  int result; // eax
  double v2; // st7
  __int64 v3; // [esp+4h] [ebp-8h]
  __int64 v4; // [esp+4h] [ebp-8h]

  dword_10059DC4 = dword_1005BAD0;
  do
  {
    dword_1005BAD0 = timeGetTime();
    v0 = dword_1005BAD0 - dword_10059DC4;
  }
  while ( (unsigned int)(dword_1005BAD0 - dword_10059DC4) <= 1 );
  if ( byte_1005A470 )
  {
    grim_frame_dt = 0.0;
    dword_1005BAD4 += v0;
  }
  else
  {
    grim_time_ms += v0;
    ++dword_1005D814;
    dword_1005D818 += v0;
    grim_frame_dt = (double)(unsigned int)v0 * *(float *)&dword_1005D3B0;
  }
  result = dword_1005D818;
  if ( (unsigned int)dword_1005D818 > 0x1F4 )
  {
    v3 = (unsigned int)dword_1005D814;
    dword_1005D814 = 0;
    v2 = (double)v3;
    v4 = (unsigned int)dword_1005D818;
    result = dword_1005D818 - 500;
    dword_1005D818 -= 500;
    *(float *)&grim_fps = v2 / ((double)v4 * *(float *)&dword_1005D3B0);
  }
  return result;
}

// grim_texture_init @ 0x10004A50
// allocates/copies texture name and zeroes fields
void *grim_texture_init(void *texture, char *name)
{
  char **v2; // ecx
  char **v3; // ebx
  char *v4; // edx

  v3 = v2;
  v4 = (char *)operator new(strlen((const char *)texture) + 1);
  *v3 = v4;
  strcpy(v4, (const char *)texture);
  v3[1] = 0;
  *((_BYTE *)v3 + 8) = 0;
  v3[5] = 0;
  return v3;
}

// grim_texture_release @ 0x10004AB0
// releases COM objects and frees texture name
void grim_texture_release(void *texture)
{
  int v1; // ecx
  int v2; // esi
  int v3; // eax
  int v4; // eax
  void *v5; // eax

  v2 = v1;
  v3 = *(_DWORD *)(v1 + 4);
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  v4 = *(_DWORD *)(v2 + 20);
  *(_DWORD *)(v2 + 4) = 0;
  if ( v4 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
  v5 = *(void **)v2;
  *(_DWORD *)(v2 + 20) = 0;
  if ( v5 )
    operator delete(v5);
  *(_DWORD *)v2 = 0;
}

// sub_10004B00 @ 0x10004B00
bool __cdecl sub_10004B00(const char *a1, const char *a2)
{
  signed int v2; // edx
  signed int v3; // esi
  char v4; // cl
  char v5; // al
  int v6; // esi
  int v7; // edx
  bool result; // al

  v2 = strlen(a1) - 3;
  v3 = strlen(a2) - 3;
  result = v2 >= 0
        && v3 >= 0
        && (v4 = a2[v3], v5 = a1[v2], v6 = v3 + 1, v7 = v2 + 1, v5 == v4)
        && a1[v7] == a2[v6]
        && a1[v7 + 1] == a2[v6 + 1];
  return result;
}

// FUN_10004b70 @ 0x10004B70
// [binja] char* sub_10004b70(char* arg1, void** arg2, int32_t* arg3, int32_t* arg4)
char *FUN_10004b70(char *arg1, void **arg2, int *arg3, int *arg4)
{
  char *v4; // eax
  int v5; // edx
  char *v6; // eax
  int *v8; // ebx
  int v9; // ecx
  unsigned int v10; // edx
  char *v11; // esi
  _DWORD *v12; // edi
  unsigned int v13; // edx
  int v14; // ecx
  int v15; // eax
  char v16; // bl
  char *v17; // esi
  int v18; // edx
  void *v19; // ecx
  int v20; // ebx
  int v21; // edi
  char *v22; // edx
  int v23; // eax
  int v24; // ecx
  int v25; // edx
  int v26; // eax
  int v27; // ecx
  int v28; // [esp-28h] [ebp-2D4h]
  int v29; // [esp+0h] [ebp-2ACh]
  void (__cdecl __noreturn *v30[33])(int); // [esp+Ch] [ebp-2A0h] BYREF
  char v31[64]; // [esp+90h] [ebp-21Ch] BYREF
  _DWORD v32[23]; // [esp+D0h] [ebp-1DCh] BYREF
  int v33; // [esp+12Ch] [ebp-180h]
  unsigned int v34; // [esp+130h] [ebp-17Ch]
  int v35; // [esp+138h] [ebp-174h]
  unsigned int v36; // [esp+148h] [ebp-164h]
  uint v37; // [esp+278h] [ebp-34h] BYREF
  int v38; // [esp+27Ch] [ebp-30h]
  char *v39; // [esp+280h] [ebp-2Ch]
  char *v40; // [esp+284h] [ebp-28h]
  int v41; // [esp+288h] [ebp-24h]
  int v42; // [esp+28Ch] [ebp-20h]
  void *v43; // [esp+290h] [ebp-1Ch]
  int v44; // [esp+294h] [ebp-18h]
  void *v45; // [esp+298h] [ebp-14h]
  int v46; // [esp+2A8h] [ebp-4h]
  unsigned int *v47; // [esp+2C4h] [ebp+18h]

  FUN_1000a810(v29);
  v46 = 0;
  v45 = 0;
  v4 = FUN_1000a880(arg1, &v37);
  v43 = v4;
  *arg4 = 0;
  *v47 = 0;
  v5 = *(_DWORD *)v4;
  v39 = v4 + 4;
  v41 = v5;
  if ( v4 == (char *)-4 )
    goto LABEL_7;
  v32[0] = sub_1003AB10(v30);
  v30[0] = (void (__cdecl __noreturn *)(int))sub_10004E90;
  if ( setjmp3(v31, 3, &_CxxLongjmpUnwind) )
  {
    sub_10009B20((int)v32);
    if ( v45 )
      operator delete(v45);
    goto LABEL_7;
  }
  sub_10009A50(v32, 61, 424);
  sub_1003A990((int)v32, (int)v39, v41);
  sub_10009B30(v32, 1);
  sub_10009EC0((int)v32);
  v28 = 4 * v33 * v34 + 18;
  *arg3 = v28;
  v6 = (char *)operator new(v28);
  v45 = v6;
  if ( !v6 )
  {
    sub_10009B20((int)v32);
LABEL_7:
    v46 = -1;
    grim_noop();
    return 0;
  }
  v8 = arg4;
  v9 = v33;
  v10 = v34;
  v11 = v6 + 18;
  *arg4 = v33;
  v45 = v6 + 18;
  *v47 = v10;
  v12 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int, int))(v32[1] + 8))(v32, 1, v9 * v35, 1);
  while ( v36 < v34 )
  {
    sub_1000A070(v32, (int)v12, 1);
    v13 = 0;
    if ( *v8 )
    {
      v14 = 0;
      v15 = (int)&v11[4 * *v8 * (*v47 - v36) + 2];
      do
      {
        *(_BYTE *)(v15 + 1) = -1;
        ++v13;
        v15 += 4;
        v16 = *(_BYTE *)(*v12 + v14);
        v14 += 3;
        *(_BYTE *)(v15 - 4) = v16;
        *(_BYTE *)(v15 - 5) = *(_BYTE *)(*v12 + v14 - 2);
        *(_BYTE *)(v15 - 6) = *(_BYTE *)(*v12 + v14 - 1);
        v8 = arg4;
      }
      while ( v13 < *arg4 );
    }
  }
  v17 = v11 - 18;
  v45 = v17;
  sub_10009E00((int)v32);
  sub_10009B20((int)v32);
  *v17 = 0;
  v17[1] = 0;
  v17[2] = 2;
  *(_DWORD *)(v17 + 3) = 0;
  v17[7] = 0;
  *((_WORD *)v17 + 4) = 0;
  *((_WORD *)v17 + 5) = 0;
  *((_WORD *)v17 + 6) = *(_WORD *)v8;
  v18 = v41;
  *((_WORD *)v17 + 7) = *(_WORD *)v47;
  v19 = v43;
  v20 = 0;
  v21 = 0;
  v22 = (char *)v43 + v18 + 4;
  v23 = *((unsigned __int16 *)v17 + 7) - 1;
  v17[16] = 32;
  v17[17] = 8;
  v40 = v22;
  v42 = 0;
  v44 = v23;
  if ( v23 >= 0 )
  {
    v24 = v38;
    do
    {
      v25 = 0;
      v26 = *((unsigned __int16 *)v17 + 6);
      if ( (_WORD)v26 )
      {
        do
        {
          if ( v21 <= 0 )
          {
            v27 = (unsigned __int8)v40[v20];
            v20 += 2;
            v21 = v27;
            v24 = (unsigned __int8)v40[v20 - 1];
            v42 = v20;
            --v25;
          }
          else
          {
            v20 = v42;
            --v21;
            v17[4 * v25 + 21 + 4 * v44 * v26] = v24;
          }
          ++v25;
          v26 = *((unsigned __int16 *)v17 + 6);
        }
        while ( v25 < (unsigned __int16)v26 );
      }
      --v44;
    }
    while ( v44 >= 0 );
    v38 = v24;
    v19 = v43;
  }
  if ( v19 )
    operator delete(v19);
  v46 = -1;
  grim_noop();
  return v17;
}

// sub_10004E90 @ 0x10004E90
void __cdecl __noreturn sub_10004E90(int *a1)
{
  int v1; // esi
  _BYTE v2[200]; // [esp+4h] [ebp-C8h] BYREF

  v1 = *a1;
  (*(void (__cdecl **)(int *, _BYTE *))(*a1 + 12))(a1, v2);
  longjmp((int *)(v1 + 132), 1);
}

// grim_texture_load_file @ 0x10004EC0
// loads texture data from file path
int grim_texture_load_file(void *texture, ushort *path)
{
  int result; // eax
  int v3; // ecx
  int v4; // ebp
  int v5; // eax
  _DWORD *v6; // ebx
  char *v7; // edi
  void **v8; // ebp
  FILE *v9; // esi
  int v10; // ecx
  int *v11; // eax
  int v12; // edx
  int v13; // ecx
  bool v14; // [esp+13h] [ebp-2Dh]
  int arg4; // [esp+14h] [ebp-2Ch] BYREF
  int v16; // [esp+18h] [ebp-28h]
  int v17; // [esp+1Ch] [ebp-24h]
  int arg3; // [esp+20h] [ebp-20h] BYREF
  int arg13; // [esp+24h] [ebp-1Ch] BYREF
  int v20; // [esp+28h] [ebp-18h]

  v4 = v3;
  v16 = v3;
  if ( !texture )
  {
    LOBYTE(result) = 0;
    return result;
  }
  v5 = *(_DWORD *)(v3 + 4);
  v6 = (_DWORD *)(v3 + 4);
  if ( v5 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(*(_DWORD *)(v3 + 4));
  *v6 = 0;
  v7 = 0;
  v14 = 0;
  if ( byte_1005BC14 )
  {
    v7 = sub_10005AE0((const char *)texture);
    v14 = v7 != 0;
  }
  if ( sub_10004B00((const char *)texture, aJaz) )
  {
    if ( byte_1005BC14 && v14 )
    {
      v8 = (void **)sub_10005B80((const char *)texture);
    }
    else
    {
      result = (int)fopen((const char *)texture, aRb);
      v9 = (FILE *)result;
      if ( !result )
      {
        LOBYTE(result) = 0;
        return result;
      }
      fseek((FILE *)result, 0, 2);
      v8 = (void **)ftell(v9);
      fseek(v9, 0, 0);
      v7 = (char *)operator new((unsigned int)v8);
      fread(v7, (size_t)v8, 1u, v9);
      fclose(v9);
    }
    result = (int)FUN_10004b70(v7, v8, &arg3, &arg4);
    if ( result
      && (v10 = v16,
          *(_DWORD *)(v16 + 12) = arg4,
          *(_DWORD *)(v10 + 16) = v17,
          result = FUN_1000cb5c(
                     (int **)grim_d3d_device,
                     (void *)result,
                     (int *)arg3,
                     -1,
                     -1,
                     1,
                     0,
                     grim_preferred_texture_format,
                     1,
                     -1,
                     (int **)0xFFFFFFFF,
                     0,
                     (int)&arg13,
                     0,
                     (int)v6),
          result < 0) )
    {
      LOBYTE(result) = 0;
      *v6 = 0;
    }
    else
    {
      LOBYTE(result) = 1;
    }
  }
  else if ( byte_1005BC14 && v14 )
  {
    v11 = (int *)sub_10005B80((const char *)texture);
    result = FUN_1000cb5c(
               (int **)grim_d3d_device,
               v7,
               v11,
               -1,
               -1,
               1,
               0,
               grim_preferred_texture_format,
               1,
               -1,
               (int **)0xFFFFFFFF,
               0,
               (int)&arg13,
               0,
               v4 + 4);
    if ( result >= 0 )
    {
      v12 = v20;
      *(_DWORD *)(v4 + 12) = arg13;
      *(_DWORD *)(v4 + 16) = v12;
      LOBYTE(result) = 1;
    }
    else
    {
      *v6 = 0;
      LOBYTE(result) = 0;
    }
  }
  else
  {
    result = FUN_1000cb9c(
               (int **)grim_d3d_device,
               (int *)texture,
               -1,
               -1,
               1,
               0,
               grim_preferred_texture_format,
               1,
               -1,
               (int **)0xFFFFFFFF,
               0,
               (int)&arg13,
               0,
               v4 + 4);
    if ( result >= 0 )
    {
      result = arg13;
      v13 = v20;
      *(_DWORD *)(v4 + 12) = arg13;
      *(_DWORD *)(v4 + 16) = v13;
      LOBYTE(result) = 1;
    }
    else
    {
      *v6 = 0;
      LOBYTE(result) = 0;
    }
  }
  return result;
}

// grim_texture_name_equals @ 0x10005110
// compares stored texture name
int grim_texture_name_equals(void *texture, char *name)
{
  int *v2; // ecx
  int result; // eax

  result = *v2;
  if ( *v2 && texture )
  {
    result = strcmp((const char *)result, (const char *)texture);
    if ( result )
      LOBYTE(result) = 0;
    else
      return 1;
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_find_texture_by_name @ 0x10005170
// returns texture handle index for name
int grim_find_texture_by_name(char *name)
{
  int v1; // esi
  void **i; // edi
  char *v4; // [esp+0h] [ebp-Ch]

  v1 = 0;
  if ( dword_1005305C + 1 <= 0 )
    return -1;
  for ( i = &grim_texture_slots; !*i || !(unsigned __int8)grim_texture_name_equals(name, v4); ++i )
  {
    if ( ++v1 >= dword_1005305C + 1 )
      return -1;
  }
  return v1;
}

// grim_find_free_texture_slot @ 0x100051C0
// finds the first free texture slot
int grim_find_free_texture_slot()
{
  int result; // eax
  void **v1; // ecx

  result = 0;
  v1 = &grim_texture_slots;
  while ( *v1 )
  {
    ++v1;
    ++result;
    if ( (int)v1 >= (int)&byte_1005D804 )
      return -1;
  }
  return result;
}

// grim_load_texture_internal @ 0x100051E0
// allocates texture slot and loads file
int grim_load_texture_internal(char *name, ushort *path)
{
  int result; // eax
  int v3; // edi
  void *v4; // esi
  char *v5; // [esp+0h] [ebp-14h]
  void *v6; // [esp+0h] [ebp-14h]

  result = grim_find_free_texture_slot();
  v3 = result;
  if ( result == -1 )
  {
    grim_error_text = (int)aAllTextureSlot;
    LOBYTE(result) = 0;
  }
  else
  {
    result = grim_find_texture_by_name(name);
    if ( result == -1 )
    {
      if ( operator new(0x18u) )
        v4 = grim_texture_init(name, v5);
      else
        v4 = 0;
      result = grim_texture_load_file(path, (ushort *)v5);
      if ( (_BYTE)result )
      {
        result = dword_1005305C;
        *(&grim_texture_slots + v3) = v4;
        if ( v3 > result )
          dword_1005305C = v3;
        LOBYTE(result) = 1;
      }
      else
      {
        grim_error_text = (int)aD3dCouldNotLoa;
        if ( v4 )
        {
          grim_texture_release(v6);
          operator delete(v4);
        }
        LOBYTE(result) = 0;
      }
    }
    else
    {
      grim_error_text = (int)aD3dTextureSlot;
      LOBYTE(result) = 0;
    }
  }
  return result;
}

// sub_100052F0 @ 0x100052F0
float *sub_100052F0()
{
  int v0; // edx
  int v1; // eax
  int v2; // esi
  int *v3; // edx
  int v4; // ecx
  int *v5; // eax
  double v6; // st6
  int v7; // eax
  int v8; // esi
  float *v9; // edx
  int v10; // ecx
  float *v11; // eax
  double v12; // st6
  int v13; // esi
  float *v14; // edx
  int v15; // ecx
  float *v16; // eax
  double v17; // st6
  int v18; // esi
  float *v19; // edx
  int v20; // ecx
  float *v21; // eax
  double v22; // st6
  int v23; // esi
  float *v24; // edx
  int v25; // ecx
  float *result; // eax
  double v27; // st6
  int v28; // [esp+Ch] [ebp-14h]
  int v29; // [esp+Ch] [ebp-14h]
  int v30; // [esp+Ch] [ebp-14h]
  int v31; // [esp+Ch] [ebp-14h]
  int v32; // [esp+Ch] [ebp-14h]
  int v33; // [esp+10h] [ebp-10h]
  int v34; // [esp+10h] [ebp-10h]
  int v35; // [esp+10h] [ebp-10h]
  int v36; // [esp+10h] [ebp-10h]
  int v37; // [esp+10h] [ebp-10h]
  int v38; // [esp+10h] [ebp-10h]
  int v39; // [esp+14h] [ebp-Ch]
  __int64 v40; // [esp+18h] [ebp-8h]

  dword_1005A47C = 0;
  grim_config_var1_table = 0;
  dword_1005A480 = 0;
  grim_config_var0_table = 0;
  grim_config_var2_table = 0;
  grim_config_var3_table = 0;
  qmemcpy(&unk_1005CB98, &grim_config_var0_table, 0x7F0u);
  dword_1005A484 = 0;
  dword_1005A478 = 0;
  dword_1005CE5C = v39;
  dword_1005CE58 = v33;
  dword_1005CE64 = (int)sub_10001140;
  dword_1005CBE8 = v33;
  dword_1005CE60 = v40;
  dword_1005CBF4 = (int)std::codecvt_base::do_always_noconv;
  dword_1005CBF0 = v40;
  dword_1005CBEC = v39;
  dword_1005CBE4 = (int)std::codecvt_base::do_always_noconv;
  dword_1005CBDC = v39;
  v0 = v33;
  dword_1005CBD8 = v33;
  dword_1005CC04 = (int)Caption;
  LOBYTE(v33) = 0;
  dword_1005CBE0 = v40;
  dword_1005CBF8 = v0;
  dword_1005CC08 = v33;
  dword_1005CBFC = v39;
  dword_1005CC00 = v40;
  dword_1005CC0C = v39;
  qword_1005CC10 = v40;
  dword_1005CE28 = 480;
  dword_1005CE2C = v39;
  qword_1005CE30 = v40;
  dword_1005CE18 = 16;
  dword_1005CE1C = v39;
  qword_1005CE20 = v40;
  dword_1005CC38 = v33;
  dword_1005CC3C = v39;
  LOBYTE(v33) = 0;
  dword_1005CC48 = v33;
  qword_1005CC50 = v40;
  qword_1005CC40 = v40;
  dword_1005CC6C = v39;
  qword_1005CC70 = v40;
  dword_1005CC4C = v39;
  v1 = v33;
  dword_1005CEBC = v39;
  qword_1005CEC0 = v40;
  LOBYTE(v33) = 0;
  grim_input_cached = v33;
  dword_1005CC5C = v39;
  dword_1005CC68 = v1;
  qword_1005CC60 = v40;
  dword_1005D0F8 = v33;
  dword_1005D0FC = v39;
  qword_1005D100 = v40;
  LOBYTE(v33) = 1;
  dword_1005D108 = v33;
  dword_1005D10C = v39;
  qword_1005D110 = v40;
  dword_1005D118 = 1065353216;
  dword_1005D11C = v39;
  qword_1005D120 = v40;
  grim_font_texture_bound = 1065353216;
  dword_1005CCFC = v39;
  qword_1005CD00 = v40;
  dword_1005CD08 = 1065353216;
  dword_1005CEB8 = 1;
  dword_1005CD0C = v39;
  qword_1005CD10 = v40;
  DWORD1(xmmword_1005D1C8) = v39;
  dword_1005CCAC = v39;
  LODWORD(xmmword_1005D1C8) = 1065353217;
  dword_1005CCB8 = 5;
  *((_QWORD *)&xmmword_1005D1C8 + 1) = v40;
  qword_1005CCB0 = v40;
  dword_1005CCBC = v39;
  dword_1005CCA8 = 1065353217;
  qword_1005CCC0 = v40;
  dword_1005CCC8 = 6;
  dword_1005CCCC = v39;
  qword_1005CCD0 = v40;
  dword_1005B288 = 1056964608;
  dword_1005B28C = 1065353216;
  grim_uv_v0 = 0;
  grim_uv_u1 = 1065353216;
  dword_1005D138 = 1120403456;
  dword_1005D148 = 0;
  dword_1005D158 = 0;
  grim_error_text = (int)String;
  byte_1005D3AC = 0;
  byte_1005BC14 = 0;
  dword_1005A670 = 0;
  ElementSize = 0;
  grim_backbuffer_width = 640;
  grim_backbuffer_height = 480;
  grim_texture_format = 23;
  grim_preferred_texture_format = 0;
  hwnd = 0;
  grim_color_slot0 = -1;
  grim_color_slot3 = -1;
  dword_1005BC0C = -1;
  dword_1005BC08 = -1;
  grim_uv_u0 = 0;
  grim_uv_v1 = 0;
  dword_1005B2A0 = 1065353216;
  dword_1005B2A4 = 1065353216;
  dword_1005B2A8 = 0;
  grim_mouse_button_latch = 0;
  dword_1005B2AC = 1065353216;
  dword_1005C8EC = 0;
  lpWindowName = strcpy((char *)operator new(strlen(aGrimNoTitle) + 1), aGrimNoTitle);
  memset(&flt_1005A058, 0, 0x400u);
  dword_1005977C = (int (*)(void))sub_10001140;
  dword_10059770 = (int (*)(void))std::codecvt_base::do_always_noconv;
  dword_1005D3A8 = (int (*)(void))std::codecvt_base::do_always_noconv;
  dword_1005CC94 = (int)strdup(String);
  v2 = 0;
  memset(&grim_font2_glyph_widths, 0, 0x100u);
  v28 = 0;
  v3 = &grim_font2_uv_v;
  do
  {
    v4 = 0;
    v5 = v3;
    v34 = 0;
    v3 += 32;
    do
    {
      v6 = (double)v34;
      v5 += 2;
      v34 = ++v4;
      *((float *)v5 - 3) = v6 * 0.0625;
      *((float *)v5 - 2) = (double)v28 * 0.0625;
    }
    while ( v4 < 16 );
    v28 = ++v2;
  }
  while ( v2 < 16 );
  v7 = 0;
  memset(&grim_subrect_ptr_table, 0, 0x40u);
  do
  {
    grim_font2_char_map[v7] = v7;
    ++v7;
  }
  while ( v7 < 256 );
  v8 = 0;
  byte_1005A654 = -28;
  byte_1005A666 = -10;
  byte_1005A634 = -60;
  byte_1005A646 = -42;
  byte_1005A635 = -59;
  byte_1005A655 = -27;
  grim_subrect_ptr0 = (int)&grim_subrect_table_0;
  grim_subrect_ptr1 = (int)&grim_subrect_table_1;
  grim_subrect_ptr2 = (int)&grim_subrect_table_2;
  grim_subrect_ptr3 = (int)&grim_subrect_table;
  v29 = 0;
  v9 = (float *)&unk_1005D38C;
  do
  {
    v10 = 0;
    v11 = v9;
    v35 = 0;
    v9 += 4;
    do
    {
      v12 = (double)v35;
      v11 += 2;
      v35 = ++v10;
      *(v11 - 3) = v12 * 0.5;
      *(v11 - 2) = (double)v29 * 0.5;
    }
    while ( v10 < 2 );
    v29 = ++v8;
  }
  while ( v8 < 2 );
  v13 = 0;
  v14 = (float *)&unk_1005CB0C;
  v30 = 0;
  do
  {
    v15 = 0;
    v16 = v14;
    v36 = 0;
    v14 += 8;
    do
    {
      v17 = (double)v36;
      v16 += 2;
      v36 = ++v15;
      *(v16 - 3) = v17 * 0.25;
      *(v16 - 2) = (double)v30 * 0.25;
    }
    while ( v15 < 4 );
    v30 = ++v13;
  }
  while ( v13 < 4 );
  v18 = 0;
  v19 = (float *)&unk_1005C90C;
  v31 = 0;
  do
  {
    v20 = 0;
    v21 = v19;
    v37 = 0;
    v19 += 16;
    do
    {
      v22 = (double)v37;
      v21 += 2;
      v37 = ++v20;
      *(v21 - 3) = v22 * 0.125;
      *(v21 - 2) = (double)v31 * 0.125;
    }
    while ( v20 < 8 );
    v31 = ++v18;
  }
  while ( v18 < 8 );
  v23 = 0;
  v24 = (float *)&unk_1005A67C;
  v32 = 0;
  do
  {
    v25 = 0;
    result = v24;
    v38 = 0;
    v24 += 32;
    do
    {
      v27 = (double)v38;
      result += 2;
      v38 = ++v25;
      *(result - 3) = v27 * 0.0625;
      *(result - 2) = (double)v32 * 0.0625;
    }
    while ( v25 < 16 );
    v32 = ++v23;
  }
  while ( v23 < 16 );
  return result;
}

// sub_10005A40 @ 0x10005A40
char __cdecl sub_10005A40(char *FileName)
{
  FILE *v1; // eax
  FILE *v2; // esi

  v1 = fopen(FileName, aRb);
  v2 = v1;
  if ( v1 )
  {
    fseek(v1, 0, 2);
    ElementSize = ftell(v2);
    fseek(v2, 0, 0);
    dword_1005A670 = operator new(ElementSize + 1);
    fread(dword_1005A670, ElementSize, 1u, v2);
    fclose(v2);
    return 1;
  }
  else
  {
    byte_1005BC14 = 0;
    if ( dword_1005A670 )
      operator delete(dword_1005A670);
    dword_1005A670 = 0;
    return 0;
  }
}

// sub_10005AE0 @ 0x10005AE0
char *__cdecl sub_10005AE0(const char *a1)
{
  signed int v1; // ebp
  unsigned int v2; // kr08_4

  v1 = strlen(off_10053040) + 1;
  if ( v1 >= (int)ElementSize )
    return 0;
  while ( 1 )
  {
    v2 = strlen((const char *)dword_1005A670 + v1) + 1;
    if ( !strcmp((const char *)dword_1005A670 + v1, a1) )
      break;
    v1 += v2 - 1 + *(_DWORD *)((char *)dword_1005A670 + v2 + v1) + 5;
    if ( v1 >= (int)ElementSize )
      return 0;
  }
  return (char *)dword_1005A670 + v2 + v1 + 4;
}

// sub_10005B80 @ 0x10005B80
int __cdecl sub_10005B80(const char *a1)
{
  signed int v1; // ebp
  unsigned int v2; // kr08_4

  v1 = strlen(off_10053040) + 1;
  if ( v1 >= (int)ElementSize )
    return 0;
  while ( 1 )
  {
    v2 = strlen((const char *)dword_1005A670 + v1) + 1;
    if ( !strcmp((const char *)dword_1005A670 + v1, a1) )
      break;
    v1 += v2 - 1 + *(_DWORD *)((char *)dword_1005A670 + v2 + v1) + 5;
    if ( v1 >= (int)ElementSize )
      return 0;
  }
  return *(_DWORD *)((char *)dword_1005A670 + v2 + v1);
}

// grim_set_key_char_buffer @ 0x10005C20
// Grim2D vtable 0x54 (provisional): set input character ring buffer
void grim_set_key_char_buffer(unsigned __int8 *buffer, int *count, int size)
{
  off_10053048 = buffer;
  off_1005304C = count;
  dword_10053050 = size;
}

// grim_get_key_char @ 0x10005C40
// Grim2D vtable 0x50 (provisional)
int grim_get_key_char()
{
  int v0; // edx
  int result; // eax
  int *v2; // ecx
  int v3; // esi

  v0 = dword_1005D3E4;
  if ( !dword_1005D3E4 )
    return 0;
  result = dword_1005D3C4[0];
  if ( dword_1005D3E4 > 0 )
  {
    v2 = dword_1005D3C4;
    v3 = dword_1005D3E4;
    do
    {
      *v2 = v2[1];
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  dword_1005D3E4 = v0 - 1;
  return result;
}

// grim_release @ 0x10005C80
// Grim2D vtable 0x0: delete interface
void grim_release()
{
  void *v0; // ecx

  operator delete(v0);
}

// grim_set_paused @ 0x10005C90
// Grim2D vtable 0x4 (provisional): pause game tick update
void grim_set_paused(int paused)
{
  grim_paused_flag = paused;
}

// grim_get_version @ 0x10005CA0
// Grim2D vtable 0x8 (provisional): engine version constant
float grim_get_version()
{
  return 1.21;
}

// grim_check_device @ 0x10005CB0
// Grim2D vtable 0xc: device creation test
int grim_check_device()
{
  int result; // eax
  int v1; // [esp+1Ch] [ebp-4h] BYREF
  int *retaddr; // [esp+20h] [ebp+0h]
  LPCWCH lpWideCharStr; // [esp+28h] [ebp+8h]

  v1 = 0;
  result = (*(int (__stdcall **)(void *, int, int, int, int *))(*(_DWORD *)grim_d3d_device + 108))(
             grim_d3d_device,
             grim_present_width,
             grim_present_height,
             21,
             &v1);
  if ( result >= 0 )
  {
    if ( (*(int (__stdcall **)(void *, int, int))(*(_DWORD *)grim_d3d_device + 120))(grim_d3d_device, v1, v1) < 0
      || FUN_1000ae52((int)lpWideCharStr, 0, retaddr, 0, 0) < 0 )
    {
      result = (*(int (__cdecl **)(int *))(*retaddr + 8))(retaddr);
      LOBYTE(result) = 0;
    }
    else
    {
      result = (*(int (__cdecl **)(int *))(*retaddr + 8))(retaddr);
      LOBYTE(result) = 1;
    }
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_apply_config @ 0x10005D40
// Grim2D vtable 0x10: opens D3D config dialog and applies settings
int grim_apply_config()
{
  int v0; // ecx
  int v1; // esi
  void *v2; // eax
  int result; // eax
  int v4; // [esp-10h] [ebp-14h]
  int v5; // [esp-10h] [ebp-14h]
  int v6; // [esp-10h] [ebp-14h]
  int v7; // [esp-10h] [ebp-14h]
  int v8; // [esp-10h] [ebp-14h]
  int v9; // [esp-Ch] [ebp-10h]
  int v10; // [esp-Ch] [ebp-10h]
  int v11; // [esp-Ch] [ebp-10h]
  int v12; // [esp-Ch] [ebp-10h]
  int v13; // [esp-Ch] [ebp-10h]
  int v14; // [esp-Ch] [ebp-10h]
  int v15; // [esp-Ch] [ebp-10h]
  int v16; // [esp-Ch] [ebp-10h]
  int v17; // [esp-8h] [ebp-Ch]
  int v18; // [esp-8h] [ebp-Ch]
  int v19; // [esp-8h] [ebp-Ch]
  int v20; // [esp-8h] [ebp-Ch]
  int v21; // [esp-8h] [ebp-Ch]
  int v22; // [esp-8h] [ebp-Ch]
  int v23; // [esp-8h] [ebp-Ch]
  int v24; // [esp-8h] [ebp-Ch]
  int v25; // [esp-4h] [ebp-8h]
  int v26; // [esp-4h] [ebp-8h]
  int v27; // [esp-4h] [ebp-8h]
  int v28; // [esp-4h] [ebp-8h]
  int v29; // [esp-4h] [ebp-8h]
  int v30; // [esp-4h] [ebp-8h]
  int v31; // [esp-4h] [ebp-8h]
  int v32; // [esp-4h] [ebp-8h]

  v1 = v0;
  if ( !lParam )
    lParam = (LPARAM)LoadIconA(grim_module_handle, (LPCSTR)0x72);
  grim_config_dialog_canceled = 0;
  v2 = (void *)Direct3DCreate8(220);
  grim_d3d8_probe = v2;
  if ( v2 )
  {
    (*(void (__stdcall **)(void *, _DWORD, int, void *))(*(_DWORD *)v2 + 52))(v2, 0, 1, &unk_1005A498);
    DialogBoxParamA(grim_module_handle, (LPCSTR)0x74, 0, (DLGPROC)grim_config_dialog_proc, 0);
    (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d8_probe + 8))(grim_d3d8_probe);
    if ( !grim_config_dialog_canceled )
    {
      LOBYTE(v4) = byte_1005D400;
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 84, v4, v9, v17, v25);
      if ( (_BYTE)dword_1005B2B8 )
        (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 43, 16, v10, v18, v26);
      else
        (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 43, 32, v10, v18, v26);
      LOBYTE(v5) = byte_1005D400;
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 84, v5, v11, v19, v27);
      LOBYTE(v6) = byte_1005B280;
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 8, v6, v12, v20, v28);
      LOBYTE(v7) = 0;
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 52, v7, v13, v21, v29);
      LOBYTE(v8) = byte_1005B280;
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 8, v8, v14, v22, v30);
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 41, dword_10053054, v15, v23, v31);
      (*(void (__thiscall **)(int, int, int, int, int, int))(*(_DWORD *)v1 + 32))(v1, 42, dword_10053058, v16, v24, v32);
    }
    return grim_config_dialog_canceled == 0;
  }
  else
  {
    grim_error_text = (int)Text;
    result = MessageBoxA(0, Text, Caption, 0);
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_init_system @ 0x10005EB0
// Grim2D vtable 0x14: Grim2D init; returns success
int grim_init_system()
{
  int v0; // ecx
  int v1; // esi
  char *v2; // edi
  int result; // eax
  int v4; // [esp-10h] [ebp-18h]
  int v5; // [esp-Ch] [ebp-14h]
  int v6; // [esp-8h] [ebp-10h]
  HWND v7; // [esp-4h] [ebp-Ch]

  v1 = v0;
  memset(DstBuf, 0, 0x104u);
  v2 = &DstBuf[260];
  getcwd(DstBuf, 260);
  result = grim_d3d_init();
  if ( (_BYTE)result )
  {
    if ( (_BYTE)dword_1005CC48 != 1 || (_BYTE)grim_input_cached || (v7 = hwnd, (unsigned __int8)grim_mouse_init()) )
    {
      if ( (_BYTE)dword_1005CC38 != 1 || (unsigned __int8)grim_keyboard_init((int)hwnd) )
      {
        if ( (_BYTE)dword_1005CC68 == 1 && !(unsigned __int8)grim_joystick_init((int)hwnd) )
        {
          grim_error_text = (int)aDi8CouldNotIni_1;
          LOBYTE(dword_1005CC68) = 0;
        }
        sub_10004920();
        sub_10004970();
        (*(void (__thiscall **)(int, int, int, int, int, HWND))(*(_DWORD *)v1 + 32))(v1, 21, 2, v5, v6, v7);
        dword_1005D0B4 = (int)&hwnd;
        (*(void (__thiscall **)(int, int, int, int, int, char *))(*(_DWORD *)v1 + 32))(v1, 16, v4, v5, v6, aCrimsonPaq);
        result = (int)sub_10005AE0(aLoadSmallfntDa);
        if ( result )
          qmemcpy(grim_font2_glyph_widths, (const void *)result, sizeof(grim_font2_glyph_widths));
        LOBYTE(result) = 1;
      }
      else
      {
        grim_error_text = (int)aDi8CouldNotIni_0;
        grim_mouse_shutdown();
        grim_keyboard_shutdown();
        sub_10004280(v2);
        result = grim_window_destroy();
        LOBYTE(result) = 0;
      }
    }
    else
    {
      grim_error_text = (int)aDi8CouldNotIni;
      grim_mouse_shutdown();
      sub_10004280(v2);
      result = grim_window_destroy();
      LOBYTE(result) = 0;
    }
  }
  return result;
}

// grim_shutdown @ 0x10005FF0
// Grim2D vtable 0x18 (provisional): Grim2D shutdown
void grim_shutdown()
{
  void *v0; // edi

  sub_10005A40(String);
  grim_mouse_shutdown();
  grim_keyboard_shutdown();
  sub_1000A330();
  sub_10004280(v0);
  grim_window_destroy();
}

// grim_apply_settings @ 0x10006020
// Grim2D vtable 0x1c: apply Grim2D settings after config load
void grim_apply_settings()
{
  char *v0; // edi

  sub_10003C00(v0);
}

// grim_set_texture_stage_ops @ 0x10006030
// sets D3D texture stage states for a small set of blend modes (mode 0..3)
uint grim_set_texture_stage_ops(uint mode)
{
  uint result; // eax

  result = mode;
  switch ( mode )
  {
    case 0u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 1,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 1u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 1,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 2u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 4);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 4);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 5, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 6, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 2,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 3u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 7);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 7);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 4);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 4);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 5, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 6, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 2,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 4u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 24);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 3);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 1,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 5u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 24);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 1,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    case 6u:
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 24);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      (*(void (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      result = (*(int (__stdcall **)(void *, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                 grim_d3d_device,
                 2,
                 4,
                 1);
      LOBYTE(result) = 1;
      break;
    default:
      LOBYTE(result) = 0;
      break;
  }
  return result;
}

// grim_set_config_var @ 0x10006580
// Grim2D vtable 0x20: config/state dispatcher; updates config tables, some IDs map to D3D render/texture state; extra args for some IDs
void grim_set_config_var(unsigned int id, unsigned int value)
{
  int *v2; // ebx
  int *v3; // ebx
  int v4; // edi
  char *v5; // esi
  __int64 v6; // rax
  int *v7; // ebx
  int *v8; // ebx
  int v9; // [esp+Ch] [ebp-604h]
  int v10; // [esp+Ch] [ebp-604h]
  _BYTE v11[512]; // [esp+10h] [ebp-600h] BYREF
  char v12; // [esp+210h] [ebp-400h] BYREF
  float v13; // [esp+61Ch] [ebp+Ch]
  float v14; // [esp+620h] [ebp+10h]
  char *String; // [esp+624h] [ebp+14h]

  switch ( id )
  {
    case 5u:
      dword_1005D3A8 = (int (*)(void))String;
      return;
    case 6u:
      dword_10059770 = (int (*)(void))String;
      return;
    case 7u:
      if ( lpWindowName )
        operator delete((void *)lpWindowName);
      lpWindowName = (LPCSTR)operator new(strlen(String) + 1);
      strcpy((char *)lpWindowName, String);
      grim_config_var3_table[4 * id] = (int)lpWindowName;
      return;
    case 0xBu:
    case 0xCu:
    case 0xEu:
    case 0x42u:
      LOBYTE(grim_config_var0_table[4 * id]) = value;
      return;
    case 0xDu:
      LOBYTE(grim_config_var0_table[4 * id]) = value;
      if ( (_BYTE)grim_input_cached )
        LOBYTE(dword_1005CC48) = 1;
      return;
    case 0x10u:
      if ( !strcmp(String, ::String) )
      {
        if ( grim_config_var3_table[4 * id] )
          operator delete((void *)grim_config_var3_table[4 * id]);
        dword_1005CC94 = (int)strdup(::String);
        byte_1005BC14 = 0;
      }
      byte_1005BC14 = sub_10005A40(String);
      if ( grim_config_var3_table[4 * id] )
        operator delete((void *)grim_config_var3_table[4 * id]);
      grim_config_var3_table[4 * id] = (int)strdup(String);
      LOBYTE(grim_config_var0_table[4 * id]) = byte_1005BC14;
      return;
    case 0x12u:
      if ( LOBYTE(grim_config_var0_table[4 * id]) != (_BYTE)value )
      {
        (*(void (__stdcall **)(void *, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
          grim_d3d_device,
          27,
          (unsigned __int8)value);
        LOBYTE(grim_config_var0_table[4 * id]) = value;
      }
      return;
    case 0x13u:
      if ( grim_config_var0_table[4 * id] != value )
      {
        (*(void (__stdcall **)(void *, int, unsigned int))(*(_DWORD *)grim_d3d_device + 200))(
          grim_d3d_device,
          19,
          value);
        grim_config_var0_table[4 * id] = value;
      }
      return;
    case 0x14u:
      if ( grim_config_var0_table[4 * id] != value )
      {
        (*(void (__stdcall **)(void *, int, unsigned int))(*(_DWORD *)grim_d3d_device + 200))(
          grim_d3d_device,
          20,
          value);
        grim_config_var0_table[4 * id] = value;
      }
      return;
    case 0x15u:
      if ( (int)value <= 0 )
        return;
      if ( (int)value <= 2 )
        goto LABEL_44;
      if ( value == 3 )
      {
        if ( grim_config_var0_table[4 * id] != 3 )
          (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(
            grim_d3d_device,
            0,
            21,
            3);
LABEL_44:
        if ( grim_config_var0_table[4 * id] == 3 )
          (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(
            grim_d3d_device,
            0,
            21,
            1);
        (*(void (__stdcall **)(void *, _DWORD, int, unsigned int))(*(_DWORD *)grim_d3d_device + 252))(
          grim_d3d_device,
          0,
          17,
          value);
        (*(void (__stdcall **)(void *, _DWORD, int, unsigned int))(*(_DWORD *)grim_d3d_device + 252))(
          grim_d3d_device,
          0,
          16,
          value);
        grim_config_var0_table[4 * id] = value;
      }
      return;
    case 0x1Au:
      if ( (unsigned __int8)grim_set_texture_stage_ops(value) )
      {
        v2 = &grim_config_var0_table[4 * id];
        *v2 = value;
        goto LABEL_50;
      }
      return;
    case 0x1Bu:
      v3 = &grim_config_var0_table[4 * id];
      *v3 = value;
      *((float *)v3 + 1) = v13;
      *((float *)v3 + 2) = v14;
      v3[3] = (int)String;
      HIWORD(v9) = (unsigned __int8)(__int64)(*(float *)&value * 127.0 + 128.0);
      BYTE1(v9) = (__int64)(v13 * 127.0 + 128.0);
      LOBYTE(v9) = (__int64)(v14 * 127.0 + 128.0);
      (*(void (__stdcall **)(void *, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 60, v9);
      return;
    case 0x1Cu:
      v4 = 0;
      v5 = &v12;
      v10 = 0;
      do
      {
        v6 = (__int64)((double)v10 * *(float *)&value * 257.0);
        if ( (int)v6 <= 0xFFFF )
        {
          if ( (int)v6 < 0 )
            LOWORD(v6) = 0;
        }
        else
        {
          LOWORD(v6) = -1;
        }
        *((_WORD *)v5 - 256) = v6;
        *(_WORD *)v5 = v6;
        *((_WORD *)v5 + 256) = v6;
        ++v4;
        v5 += 2;
        v10 = v4;
      }
      while ( v4 < 256 );
      (*(void (__stdcall **)(void *, int, _BYTE *))(*(_DWORD *)grim_d3d_device + 72))(grim_d3d_device, 1, v11);
      v7 = &grim_config_var0_table[4 * id];
      *v7 = value;
      *((float *)v7 + 1) = v13;
      *((float *)v7 + 2) = v14;
      v7[3] = (int)String;
      return;
    case 0x29u:
      grim_backbuffer_width = value;
      grim_config_var0_table[4 * id] = value;
      return;
    case 0x2Au:
      grim_backbuffer_height = value;
      grim_config_var0_table[4 * id] = value;
      return;
    case 0x2Bu:
      grim_config_var0_table[4 * id] = value;
      grim_texture_format = (value != 32) + 22;
      return;
    case 0x2Du:
      dword_1005977C = (int (*)(void))String;
      return;
    case 0x34u:
      LOBYTE(grim_config_var0_table[4 * id]) = value;
      return;
    case 0x36u:
      (*(void (__stdcall **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 60))(
        grim_d3d_device,
        0,
        0,
        0,
        0);
      return;
    case 0x52u:
      v8 = &grim_config_var0_table[4 * id];
      *v8 = value;
      *((float *)v8 + 1) = v13;
      *((float *)v8 + 2) = v14;
      v8[3] = (int)String;
      dword_1005D3FC = *(_DWORD *)String;
      return;
    case 0x55u:
      grim_render_disabled = value;
      return;
    default:
      v2 = &grim_config_var0_table[4 * id];
      *v2 = value;
LABEL_50:
      *((float *)v2 + 1) = v13;
      *((float *)v2 + 2) = v14;
      v2[3] = (int)String;
      return;
  }
}

// grim_get_config_var @ 0x10006C30
// Grim2D vtable 0x24 (provisional): fills 4 dwords for config entry (id 0..0x7f)
void grim_get_config_var(unsigned int *out, int id)
{
  unsigned int *v2; // ecx

  if ( (unsigned int)id >= 0x80 )
  {
    *out = dword_1005A478;
    out[1] = dword_1005A47C;
    out[2] = dword_1005A480;
    out[3] = dword_1005A484;
  }
  else
  {
    v2 = (unsigned int *)&grim_config_var0_table[4 * id];
    *out = *v2;
    out[1] = v2[1];
    out[2] = v2[2];
    out[3] = v2[3];
  }
}

// grim_get_error_text @ 0x10006CA0
// Grim2D vtable 0x28: error string for MessageBox
char *grim_get_error_text()
{
  return (char *)grim_error_text;
}

// grim_clear_color @ 0x10006CB0
// Grim2D vtable 0x2c: packs RGBA into device clear color
void grim_clear_color(float r, float g, float b, float a)
{
  if ( !grim_render_disabled )
  {
    if ( byte_1005C898 )
      (*(void (__stdcall **)(void *, _DWORD, _DWORD, int, unsigned int, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 144))(
        grim_d3d_device,
        0,
        0,
        1,
        (unsigned __int8)(__int64)(b * 255.0)
      | (((unsigned __int8)(__int64)(g * 255.0)
        | ((((unsigned int)(__int64)(a * 255.0) << 8) | (unsigned __int8)(__int64)(r * 255.0)) << 8)) << 8),
        0,
        0);
  }
}

// grim_set_render_target @ 0x10006D50
// Grim2D vtable 0x30 (provisional): set render target; -1 resets
int grim_set_render_target(int target_index)
{
  int result; // eax
  int v2; // [esp-Ch] [ebp-14h]

  if ( grim_render_disabled )
    goto LABEL_11;
  if ( target_index < 0 )
  {
    if ( grim_backbuffer_surface )
    {
      if ( grim_render_target_surface )
        (*(void (__stdcall **)(void *))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
      grim_render_target_surface = 0;
      result = (*(int (__stdcall **)(void *, void *, _DWORD))(*(_DWORD *)grim_d3d_device + 124))(
                 grim_d3d_device,
                 grim_backbuffer_surface,
                 0);
      if ( result < 0 )
      {
        LOBYTE(result) = 0;
        return result;
      }
      result = (int)grim_backbuffer_surface;
      if ( grim_backbuffer_surface )
        result = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface);
      grim_backbuffer_surface = 0;
    }
    goto LABEL_11;
  }
  if ( grim_render_target_surface )
  {
    (*(void (__stdcall **)(void *))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
    grim_render_target_surface = 0;
  }
  if ( !grim_backbuffer_surface )
    (*(void (__stdcall **)(void *, void **))(*(_DWORD *)grim_d3d_device + 128))(
      grim_d3d_device,
      &grim_backbuffer_surface);
  v2 = *((_DWORD *)*(&grim_texture_slots + target_index) + 1);
  result = (*(int (__stdcall **)(int, _DWORD, void **))(*(_DWORD *)v2 + 60))(v2, 0, &grim_render_target_surface);
  if ( result < 0 )
  {
    LOBYTE(result) = 0;
    return result;
  }
  result = (*(int (__stdcall **)(void *, void *, _DWORD))(*(_DWORD *)grim_d3d_device + 124))(
             grim_d3d_device,
             grim_render_target_surface,
             0);
  if ( result >= 0 )
  {
LABEL_11:
    LOBYTE(result) = 1;
    return result;
  }
  result = (int)grim_render_target_surface;
  if ( grim_render_target_surface )
    result = (*(int (__stdcall **)(void *))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
  grim_render_target_surface = 0;
  LOBYTE(result) = 0;
  return result;
}

// grim_get_time_ms @ 0x10006E40
// Grim2D vtable 0x34: accumulated time (ms)
int grim_get_time_ms()
{
  return grim_time_ms;
}

// grim_set_time_ms @ 0x10006E50
// Grim2D vtable 0x38: set accumulated time
void grim_set_time_ms(int ms)
{
  grim_time_ms = ms;
}

// grim_get_frame_dt @ 0x10006E60
// Grim2D vtable 0x3c: clamped frame delta
float grim_get_frame_dt()
{
  if ( grim_frame_dt <= 0.1 )
    return grim_frame_dt;
  else
    return 0.1;
}

// grim_get_fps @ 0x10006E90
// Grim2D vtable 0x40: frames per second
float grim_get_fps()
{
  return *(float *)&grim_fps;
}

// sub_10006EA0 @ 0x10006EA0
BOOL sub_10006EA0()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D158;
  v2 = *(float *)&dword_1005D138;
  return -v2 > (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 156))(grim_interface_instance)
             - v1;
}

// sub_10006EF0 @ 0x10006EF0
BOOL sub_10006EF0()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D158;
  v2 = *(float *)&dword_1005D138;
  return (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 156))(grim_interface_instance) - v1 > v2;
}

// sub_10006F40 @ 0x10006F40
BOOL sub_10006F40()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D148;
  v2 = *(float *)&dword_1005D138;
  return -v2 > (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 152))(grim_interface_instance)
             - v1;
}

// sub_10006F90 @ 0x10006F90
BOOL sub_10006F90()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D148;
  v2 = *(float *)&dword_1005D138;
  return (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 152))(grim_interface_instance) - v1 > v2;
}

// grim_is_key_active @ 0x10006FE0
// Grim2D vtable 0x80: routes key/mouse/joystick IDs
int grim_is_key_active(int key)
{
  int v1; // ecx
  int result; // eax
  double lX; // st7
  int v4; // ebx
  int v5; // esi
  int v6; // edx

  if ( key <= 255 )
    return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 68))(v1, key);
  switch ( key )
  {
    case 256:
      return (*(int (__thiscall **)(int, _DWORD))(*(_DWORD *)v1 + 88))(v1, 0);
    case 257:
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 88))(v1, 1);
    case 258:
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 88))(v1, 2);
    case 259:
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 88))(v1, 3);
    case 260:
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 88))(v1, 4);
  }
  for ( result = 1; result <= 12; ++result )
  {
    if ( key == result + 286 )
      return (*(int (__thiscall **)(int, int))(*(_DWORD *)v1 + 168))(v1, result - 1);
  }
  switch ( key )
  {
    case 305:
      return sub_10006EA0();
    case 306:
      return sub_10006EF0();
    case 307:
      return sub_10006F40();
    case 308:
      return sub_10006F90();
    case 319:
      lX = (double)grim_joystick_state.lX;
      return fabs(lX * 0.001) > 0.5;
    case 320:
      lX = (double)grim_joystick_state.lY;
      return fabs(lX * 0.001) > 0.5;
    case 321:
      lX = (double)grim_joystick_state.lZ;
      return fabs(lX * 0.001) > 0.5;
    case 339:
      lX = (double)grim_joystick_state.lRx;
      return fabs(lX * 0.001) > 0.5;
    case 340:
      lX = (double)grim_joystick_state.lRy;
      return fabs(lX * 0.001) > 0.5;
    case 341:
      lX = (double)grim_joystick_state.lRz;
      return fabs(lX * 0.001) > 0.5;
  }
  if ( dword_1005D3B4 )
  {
    v4 = 0;
    v5 = 365;
    while ( 2 )
    {
      result = 0;
      v6 = v5;
      do
      {
        if ( key == v6 )
          return (*(int (__stdcall **)(int, int))(*(_DWORD *)dword_1005D3B4 + 12))(v4, result);
        ++result;
        ++v6;
      }
      while ( result < 5 );
      v5 += 5;
      ++v4;
      if ( v5 < 380 )
        continue;
      break;
    }
    LOBYTE(result) = 0;
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_get_config_float @ 0x100071B0
// Grim2D vtable 0x84: config float lookup (scaled)
float grim_get_config_float(int id)
{
  int v1; // ecx
  int v3; // esi
  int v4; // eax

  if ( id <= 255 )
  {
    return 0.0;
  }
  else
  {
    switch ( id )
    {
      case 319:
        return (double)grim_joystick_state.lX * 0.001;
      case 320:
        return (double)grim_joystick_state.lY * 0.001;
      case 321:
        return (double)grim_joystick_state.lZ * 0.001;
      case 339:
        return (double)grim_joystick_state.lRx * 0.001;
      case 340:
        return (double)grim_joystick_state.lRy * 0.001;
      case 341:
        return (double)grim_joystick_state.lRz * 0.001;
      case 351:
        return (*(float (**)(void))(*(_DWORD *)v1 + 112))();
      case 352:
        return (*(float (**)(void))(*(_DWORD *)v1 + 116))();
      default:
        v3 = 0;
        v4 = 360;
        while ( 1 )
        {
          if ( id == v4 - 5 )
            return (*(float (__thiscall **)(int, int))(*(_DWORD *)v1 + 120))(v1, v3);
          if ( id == v4 )
            break;
          ++v3;
          if ( ++v4 >= 363 )
            return 0.0;
        }
        return (*(float (__thiscall **)(int, int))(*(_DWORD *)v1 + 124))(v1, v3);
    }
  }
}

// grim_get_slot_float @ 0x100072C0
// Grim2D vtable 0x88 (provisional): float slot accessor
float grim_get_slot_float(int index)
{
  return *(float *)&byte_1005BDFC[4 * index + 772];
}

// grim_get_slot_int @ 0x100072D0
// Grim2D vtable 0x8c (provisional): int slot accessor
int grim_get_slot_int(int index)
{
  return *(_DWORD *)&byte_1005BDFC[4 * index + 260];
}

// grim_set_slot_float @ 0x100072E0
// Grim2D vtable 0x90 (provisional): float slot setter
void grim_set_slot_float(int index, float value)
{
  *(float *)&byte_1005BDFC[4 * index + 772] = value;
}

// grim_set_slot_int @ 0x10007300
// Grim2D vtable 0x94 (provisional): int slot setter
void grim_set_slot_int(int index, int value)
{
  *(_DWORD *)&byte_1005BDFC[4 * index + 260] = value;
}

// grim_is_key_down @ 0x10007320
// Grim2D vtable 0x44 (provisional)
int grim_is_key_down(unsigned int key)
{
  return grim_keyboard_key_down(key);
}

// grim_flush_input @ 0x10007330
// Grim2D vtable 0x4c (provisional): clear buffered input/device state
void grim_flush_input()
{
  int v0; // esi
  int v1; // eax
  int v2; // [esp+14h] [ebp-4h] BYREF

  v2 = 10;
  memset(grim_keyboard_state, 0, sizeof(grim_keyboard_state));
  v0 = 0;
  do
  {
    grim_keyboard_device->lpVtbl->GetDeviceData(
      grim_keyboard_device,
      20,
      (LPDIDEVICEOBJECTDATA)&grim_keyboard_event_buffer,
      (LPDWORD)&v2,
      0);
    v1 = v0++;
  }
  while ( v1 < 100 && v2 );
  dword_1005D3E4 = 0;
  memset(grim_keyboard_state, 0, sizeof(grim_keyboard_state));
}

// grim_was_key_pressed @ 0x10007390
// Grim2D vtable 0x48 (provisional)
int grim_was_key_pressed(unsigned int key)
{
  int result; // eax
  char v2; // fps^1
  double v3; // st7
  bool v4; // c0
  char v5; // c2
  bool v6; // c3
  double v7; // st7

  result = grim_keyboard_key_down(key);
  if ( !(_BYTE)result )
  {
    result = (unsigned __int8)key;
    flt_1005A058[(unsigned __int8)key] = 0.0;
    DstBuf[(unsigned __int8)key + 264] = 1;
    goto LABEL_7;
  }
  v3 = flt_1005A058[(unsigned __int8)key];
  v4 = v3 < 0.0;
  v5 = 0;
  v6 = v3 == 0.0;
  BYTE1(result) = v2;
  if ( v3 != 0.0 )
  {
LABEL_7:
    LOBYTE(result) = 0;
    return result;
  }
  v7 = flt_10053044;
  if ( !DstBuf[(unsigned __int8)key + 264] )
    v7 = v7 * 0.2;
  flt_1005A058[(unsigned __int8)key] = v7;
  DstBuf[(unsigned __int8)key + 264] = 0;
  LOBYTE(result) = 1;
  return result;
}

// grim_is_mouse_button_down @ 0x10007410
// Grim2D vtable 0x58: cached mouse button state or poll
int grim_is_mouse_button_down(int button)
{
  int result; // eax

  if ( !(_BYTE)grim_input_cached )
    return grim_mouse_button_down(button);
  result = button;
  LOBYTE(result) = grim_mouse_button_cache[button];
  return result;
}

// grim_was_mouse_button_pressed @ 0x10007440
// Grim2D vtable 0x5c (provisional): edge-triggered mouse button
int grim_was_mouse_button_pressed(int button)
{
  int v1; // ecx
  int v2; // esi
  char v3; // dl
  int result; // eax
  bool v5; // bl

  v2 = v1;
  if ( (_BYTE)grim_input_cached )
  {
    v3 = grim_mouse_button_cache[button];
    if ( v3 && *((_BYTE *)&grim_mouse_button_latch + button) )
    {
      LOBYTE(result) = 1;
      *((_BYTE *)&grim_mouse_button_latch + button) = v3 == 0;
    }
    else
    {
      LOBYTE(result) = 0;
      *((_BYTE *)&grim_mouse_button_latch + button) = v3 == 0;
    }
  }
  else
  {
    v5 = (*(unsigned __int8 (__thiscall **)(int, int))(*(_DWORD *)v1 + 88))(v1, button)
      && *((_BYTE *)&grim_mouse_button_latch + button);
    result = (*(int (__thiscall **)(int))(*(_DWORD *)v2 + 88))(v2);
    *((_BYTE *)&grim_mouse_button_latch + button) = (_BYTE)result == 0;
    LOBYTE(result) = v5;
  }
  return result;
}

// grim_get_mouse_dx @ 0x100074D0
// Grim2D vtable 0x70: cached mouse delta X
float grim_get_mouse_dx()
{
  return grim_mouse_dx;
}

// grim_get_mouse_dy @ 0x100074E0
// Grim2D vtable 0x74: cached mouse delta Y
float grim_get_mouse_dy()
{
  return grim_mouse_dy;
}

// grim_get_mouse_dx_indexed @ 0x100074F0
// Grim2D vtable 0x78: alias of get_mouse_dx
float grim_get_mouse_dx_indexed(int index)
{
  int v1; // ecx

  return (*(float (**)(void))(*(_DWORD *)v1 + 112))();
}

// grim_get_mouse_dy_indexed @ 0x10007500
// Grim2D vtable 0x7c: alias of get_mouse_dy
float grim_get_mouse_dy_indexed(int index)
{
  int v1; // ecx

  return (*(float (**)(void))(*(_DWORD *)v1 + 116))();
}

// grim_get_mouse_x @ 0x10007510
// Grim2D vtable 0x68: cached mouse X position
float grim_get_mouse_x()
{
  return grim_mouse_x_cached;
}

// grim_get_mouse_y @ 0x10007520
// Grim2D vtable 0x6c: cached mouse Y position
float grim_get_mouse_y()
{
  return grim_mouse_y_cached;
}

// grim_set_mouse_pos @ 0x10007530
// Grim2D vtable 0x64: set cached mouse position
void grim_set_mouse_pos(float x, float y)
{
  grim_mouse_x = LODWORD(x);
  grim_mouse_y = LODWORD(y);
  grim_mouse_x_cached = x;
  grim_mouse_y_cached = y;
}

// grim_get_mouse_wheel_delta @ 0x10007560
// Grim2D vtable 0x60 (provisional)
float grim_get_mouse_wheel_delta()
{
  if ( (_BYTE)grim_input_cached )
    return flt_1005D3B8;
  else
    return flt_1005DB58;
}

// grim_get_joystick_x @ 0x10007580
// Grim2D vtable 0x98 (provisional): joystick axis X
int grim_get_joystick_x()
{
  return grim_joystick_state.lX;
}

// grim_get_joystick_y @ 0x10007590
// Grim2D vtable 0x9c (provisional): joystick axis Y
int grim_get_joystick_y()
{
  return grim_joystick_state.lY;
}

// grim_get_joystick_z @ 0x100075A0
// Grim2D vtable 0xa0 (provisional): joystick axis Z
int grim_get_joystick_z()
{
  return grim_joystick_state.lZ;
}

// grim_get_joystick_pov @ 0x100075B0
// Grim2D vtable 0xa4 (provisional): joystick POV hat value
int grim_get_joystick_pov(int index)
{
  return grim_joystick_state.rgdwPOV[index];
}

// grim_is_joystick_button_down @ 0x100075C0
// Grim2D vtable 0xa8 (provisional): joystick button state
int grim_is_joystick_button_down(int button)
{
  int result; // eax

  LOBYTE(result) = sub_1000A310(button);
  return result;
}

// grim_create_texture @ 0x100075D0
// Grim2D vtable 0xac: create blank texture in a free slot
int grim_create_texture(char *name, int width, int height)
{
  int result; // eax
  int v4; // esi
  _DWORD *v6; // eax
  int v7; // edx
  char *v8; // [esp+14h] [ebp-1Ch]
  _DWORD v9[4]; // [esp+20h] [ebp-10h] BYREF
  void *heighta; // [esp+3Ch] [ebp+Ch]

  result = grim_find_free_texture_slot();
  v4 = result;
  if ( result >= 0 )
  {
    result = (*(int (__stdcall **)(void *, int, int, int, int, int, _DWORD, _DWORD *))(*(_DWORD *)grim_d3d_device + 80))(
               grim_d3d_device,
               width,
               height,
               1,
               1,
               grim_texture_format,
               0,
               v9);
    if ( result >= 0 )
    {
      heighta = operator new(0x18u);
      v9[3] = 0;
      if ( heighta )
        v6 = grim_texture_init(name, v8);
      else
        v6 = 0;
      v7 = v9[0];
      *(&grim_texture_slots + v4) = v6;
      v6[1] = v7;
      *((_BYTE *)*(&grim_texture_slots + v4) + 8) = 1;
      *((_DWORD *)*(&grim_texture_slots + v4) + 3) = width;
      *((_DWORD *)*(&grim_texture_slots + v4) + 4) = height;
      result = dword_1005305C;
      if ( v4 > dword_1005305C )
        dword_1005305C = v4;
      LOBYTE(result) = 1;
    }
    else
    {
      grim_error_text = (int)aD3dCouldNotCre;
      LOBYTE(result) = 0;
    }
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_load_texture @ 0x100076E0
// Grim2D vtable 0xb4 (provisional)
int grim_load_texture(char *name, char *path)
{
  return grim_load_texture_internal(name, (ushort *)path);
}

// grim_destroy_texture @ 0x10007700
// Grim2D vtable 0xbc (provisional): release texture handle
void grim_destroy_texture(int handle)
{
  void *v1; // esi
  int v2; // eax
  bool v3; // zf
  void *v4; // [esp+0h] [ebp-8h]

  v1 = *(&grim_texture_slots + handle);
  if ( v1 )
  {
    grim_texture_release(v4);
    operator delete(v1);
    v2 = dword_1005305C;
    v3 = handle == dword_1005305C;
    *(&grim_texture_slots + handle) = 0;
    if ( v3 )
      dword_1005305C = v2 - 1;
  }
}

// grim_get_texture_handle @ 0x10007740
// Grim2D vtable 0xc0: lookup texture handle by name
int grim_get_texture_handle(char *name)
{
  return grim_find_texture_by_name(name);
}

// grim_validate_texture @ 0x10007750
// Grim2D vtable 0xb8: validate texture handle/device
int grim_validate_texture(int handle)
{
  int result; // eax
  LPCWCH lpWideCharStr; // [esp+8h] [ebp+8h]

  result = (int)*(&grim_texture_slots + handle);
  if ( result )
  {
    result = (int)FUN_1000c1e8((int)lpWideCharStr, 2, *(int **)(result + 4), 0);
    LOBYTE(result) = result >= 0;
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_recreate_texture @ 0x10007790
// Grim2D vtable 0xb0: recreate D3D texture surface
int grim_recreate_texture(int handle)
{
  int result; // eax
  int v2; // [esp-4h] [ebp-8h]

  result = (int)*(&grim_texture_slots + handle);
  if ( result )
  {
    result = FUN_1000b297((int **)grim_d3d_device, *(_DWORD *)(result + 12), *(_DWORD *)(result + 16), 1);
    if ( result >= 0 )
    {
      if ( FUN_1000b3fe((int *)handle, *((int **)*(&grim_texture_slots + handle) + 1), 0, 0, COERCE_FLOAT(16)) >= 0 )
      {
        v2 = *((_DWORD *)*(&grim_texture_slots + handle) + 1);
        (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
        result = handle;
        *((_DWORD *)*(&grim_texture_slots + handle) + 1) = handle;
        LOBYTE(result) = 1;
      }
      else
      {
        result = (*(int (__stdcall **)(int))(*(_DWORD *)handle + 8))(handle);
        LOBYTE(result) = 0;
      }
    }
    else
    {
      LOBYTE(result) = 0;
    }
  }
  else
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_bind_texture @ 0x10007830
// Grim2D vtable 0xc4: bind texture handle to stage
void grim_bind_texture(int handle, int stage)
{
  int v2; // eax
  int v3; // eax

  if ( handle >= 0 )
  {
    v2 = (int)*(&grim_texture_slots + handle);
    if ( v2 )
    {
      v3 = *(_DWORD *)(v2 + 4);
      if ( v3 )
      {
        (*(void (__stdcall **)(void *, int, int))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, stage, v3);
        grim_bound_texture_handle = handle;
      }
    }
  }
}

// grim_draw_fullscreen_quad @ 0x10007870
// Grim2D vtable 0xc8: full-screen quad with current texture
void grim_draw_fullscreen_quad()
{
  int v0; // ecx
  int v1; // esi
  float v2; // [esp+4h] [ebp-14h]
  float v3; // [esp+8h] [ebp-10h]

  v1 = v0;
  (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v0 + 252))(v0, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 232))(v1);
  v3 = (float)(unsigned int)grim_backbuffer_height;
  v2 = (float)(unsigned int)grim_backbuffer_width;
  (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v1 + 284))(
    v1,
    0,
    0,
    LODWORD(v2),
    LODWORD(v3));
  (*(void (__thiscall **)(int))(*(_DWORD *)v1 + 240))(v1);
}

// grim_draw_rect_filled @ 0x100078E0
// Grim2D vtable 0xd0: UI panel fill/quad
void grim_draw_rect_filled(float *xy, float w, float h)
{
  int v3; // ecx
  int v4; // esi
  int v5; // [esp+40h] [ebp+10h]

  v4 = v3;
  if ( *(float *)(v5 + 12) > 0.0 )
  {
    (*(void (__stdcall **)(void *, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
    (*(void (__thiscall **)(int, int))(*(_DWORD *)v4 + 272))(v4, v5);
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v4 + 252))(v4, 0);
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 232))(v4);
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      *((_DWORD *)xy + 1),
      LODWORD(w),
      LODWORD(h));
    (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 240))(v4);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  }
}

// grim_draw_fullscreen_color @ 0x100079B0
// Grim2D vtable 0xcc: fullscreen color/fade overlay
void grim_draw_fullscreen_color(float r, float g, float b, float a)
{
  int v4; // ecx
  int v5; // esi
  float v6; // [esp+40h] [ebp-14h]
  float v7; // [esp+44h] [ebp-10h]

  v5 = v4;
  if ( a > 0.0 )
  {
    (*(void (__stdcall **)(void *, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v5 + 276))(
      v5,
      LODWORD(r),
      LODWORD(g),
      LODWORD(b),
      LODWORD(a));
    (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v5 + 252))(v5, 0);
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 232))(v5);
    v7 = (float)(unsigned int)grim_backbuffer_height;
    v6 = (float)(unsigned int)grim_backbuffer_width;
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v5 + 284))(
      v5,
      0,
      0,
      LODWORD(v6),
      LODWORD(v7));
    (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 240))(v5);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
    (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  }
}

// grim_begin_batch @ 0x10007AC0
// Grim2D vtable 0xe8 (provisional): begin draw batch
void grim_begin_batch()
{
  if ( !grim_render_disabled && !grim_batch_active )
  {
    grim_batch_active = 1;
    if ( byte_1005C898 )
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240) < 0 )
        byte_1005C898 = 0;
      LOWORD(grim_vertex_count) = 0;
    }
  }
}

// grim_end_batch @ 0x10007B20
// Grim2D vtable 0xf0 (provisional): end draw batch/flush
void grim_end_batch()
{
  if ( !grim_render_disabled )
  {
    if ( grim_batch_active )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      if ( byte_1005C898 )
      {
        if ( (_WORD)grim_vertex_count )
          (*(void (__stdcall **)(void *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)grim_d3d_device + 284))(
            grim_d3d_device,
            4,
            0,
            (unsigned __int16)grim_vertex_count,
            0,
            (unsigned __int16)grim_vertex_count >> 1);
        (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
}

// grim_draw_circle_filled @ 0x10007B90
// Grim2D vtable 0xd8 (provisional): triangle fan circle fill
void grim_draw_circle_filled(float x, float y, float radius)
{
  int v3; // edi
  int v4; // edx
  double v5; // st7
  __int64 v6; // rax
  long double v7; // st6
  int v8; // [esp+28h] [ebp-20h]
  _BYTE v9[24]; // [esp+30h] [ebp-18h] BYREF
  float v10; // [esp+58h] [ebp+10h]

  if ( !grim_batch_active )
  {
    grim_batch_active = 1;
    if ( byte_1005C898 )
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240) < 0 )
        byte_1005C898 = 0;
      *(_DWORD *)&v9[4] = dword_1005B288;
      *(_DWORD *)&v9[16] = grim_uv_u0[0];
      LOWORD(grim_vertex_count) = 0;
      *(_DWORD *)&v9[8] = dword_1005B28C;
      *(_DWORD *)&v9[12] = grim_color_slot0[0];
      v4 = *(_DWORD *)grim_d3d_device;
      *(_DWORD *)&v9[20] = grim_uv_v0[0];
      (*(void (__stdcall **)(void *, _DWORD, _DWORD, int))(v4 + 244))(grim_d3d_device, 0, 0, v3);
      *(float *)&v9[4] = radius;
      *(float *)v9 = y;
      v5 = v10 * 0.125 + 12.0;
      qmemcpy((void *)grim_vertex_write_ptr, v9, 0x1Cu);
      LOWORD(grim_vertex_count) = grim_vertex_count + 1;
      grim_vertex_write_ptr += 28;
      v6 = (__int64)v5;
      HIDWORD(v6) = 0;
      v8 = 0;
      if ( (int)(__int64)v5 >= 0 )
      {
        do
        {
          v7 = (double)v8 * 6.2831855 / (double)(int)(__int64)v5;
          *(float *)v9 = cos(v7) * v10 + y;
          *(float *)&v9[4] = sin(v7) * v10 + radius;
          qmemcpy((void *)grim_vertex_write_ptr, v9, 0x1Cu);
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          ++HIDWORD(v6);
          grim_vertex_write_ptr += 28;
          v8 = HIDWORD(v6);
        }
        while ( SHIDWORD(v6) <= (int)v6 );
      }
      (*(void (__cdecl **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      if ( byte_1005C898 )
      {
        (*(void (__stdcall **)(void *, int, _DWORD, int))(*(_DWORD *)grim_d3d_device + 280))(
          grim_d3d_device,
          6,
          0,
          (unsigned __int16)grim_vertex_count - 2);
        (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
}

// grim_draw_circle_outline @ 0x10007D40
// Grim2D vtable 0xdc (provisional): triangle strip ring/outline
void grim_draw_circle_outline(float x, float y, float radius)
{
  __int64 v3; // rax
  double v4; // st6
  long double v5; // st5
  long double v6; // st4
  long double v7; // st5
  int v8; // [esp+18h] [ebp-24h]
  float v9; // [esp+18h] [ebp-24h]
  float v10[7]; // [esp+20h] [ebp-1Ch] BYREF

  if ( !grim_batch_active )
  {
    grim_batch_active = 1;
    if ( byte_1005C898 )
    {
      (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240) < 0 )
        byte_1005C898 = 0;
      LODWORD(v10[2]) = dword_1005B288;
      LODWORD(v10[3]) = dword_1005B28C;
      LOWORD(grim_vertex_count) = 0;
      v10[4] = *(float *)grim_color_slot0;
      v10[5] = *(float *)grim_uv_u0;
      v10[6] = *(float *)grim_uv_v0;
      v3 = (__int64)(radius * 0.2 + 14.0);
      HIDWORD(v3) = 0;
      v8 = 0;
      if ( (int)v3 >= 0 )
      {
        v4 = radius + 2.0;
        do
        {
          v10[6] = 0.0;
          v5 = (double)v8 * 6.2831855 / (double)(int)(__int64)(radius * 0.2 + 14.0);
          v6 = cos(v5);
          v9 = v6;
          v10[0] = v6 * radius + x;
          v7 = sin(v5);
          v10[1] = v7 * radius + y;
          qmemcpy((void *)grim_vertex_write_ptr, v10, 0x1Cu);
          v10[0] = v4 * v9 + x;
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          v10[1] = v4 * v7 + y;
          grim_vertex_write_ptr += 28;
          v10[6] = 1.0;
          qmemcpy((void *)grim_vertex_write_ptr, v10, 0x1Cu);
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          ++HIDWORD(v3);
          grim_vertex_write_ptr += 28;
          v8 = HIDWORD(v3);
        }
        while ( SHIDWORD(v3) <= (int)v3 );
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      if ( byte_1005C898 )
      {
        (*(void (__stdcall **)(void *, int, _DWORD, int))(*(_DWORD *)grim_d3d_device + 280))(
          grim_d3d_device,
          5,
          0,
          (unsigned __int16)grim_vertex_count - 2);
        (*(void (__stdcall **)(void *))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
}

// nullsub_20 @ 0x10007F20
void nullsub_20()
{
  ;
}

// grim_set_rotation @ 0x10007F30
// Grim2D vtable 0xfc: precompute sin/cos (+45deg) for rotation matrix
void grim_set_rotation(float radians)
{
  long double v1; // st7

  v1 = radians + 0.78539819;
  grim_rotation_radians = LODWORD(radians);
  grim_rotation_cos = cos(v1);
  dword_1005A460 = LODWORD(grim_rotation_cos);
  dword_1005A46C = LODWORD(grim_rotation_cos);
  *(float *)&DstBuf[260] = sin(v1);
  flt_1005A468 = -*(float *)&DstBuf[260];
  dword_1005A464 = *(_DWORD *)&DstBuf[260];
}

// grim_set_color @ 0x10007F90
// Grim2D vtable 0x114 (provisional)
void grim_set_color(float r, float g, float b, float a)
{
  double v4; // st7

  v4 = a;
  if ( a <= 1.0 )
  {
    if ( v4 < 0.0 )
      v4 = 0.0;
  }
  else
  {
    v4 = 1.0;
  }
  grim_color_slot0[0] = (unsigned __int8)(__int64)(b * 255.0)
                      | (((unsigned __int8)(__int64)(g * 255.0)
                        | ((((unsigned int)(__int64)(v4 * 255.0) << 8) | (unsigned __int8)(__int64)(r * 255.0)) << 8)) << 8);
  grim_color_slot3 = grim_color_slot0[0];
  dword_1005BC0C = grim_color_slot0[0];
  dword_1005BC08 = grim_color_slot0[0];
}

// grim_set_color_ptr @ 0x10008040
// Grim2D vtable 0x110: set color from float[4]
void grim_set_color_ptr(float *rgba)
{
  double v2; // st7
  float *rgbaa; // [esp+8h] [ebp+4h]

  v2 = *rgba * 255.0;
  HIBYTE(rgbaa) = (__int64)(rgba[3] * 255.0);
  BYTE2(rgbaa) = (__int64)v2;
  BYTE1(rgbaa) = (__int64)(rgba[1] * 255.0);
  LOBYTE(rgbaa) = (__int64)(rgba[2] * 255.0);
  grim_color_slot0[0] = (int)rgbaa;
  grim_color_slot3 = (int)rgbaa;
  dword_1005BC0C = (int)rgbaa;
  dword_1005BC08 = (int)rgbaa;
}

// grim_draw_line @ 0x100080B0
// Grim2D vtable 0xe0 (provisional): builds line quad from endpoints
void grim_draw_line(float *p0, float *p1, float thickness)
{
  int v3; // ecx
  int v4; // ebx
  double v5; // st7

  v4 = v3;
  if ( (byte_10059BB4 & 1) == 0 )
  {
    byte_10059BB4 |= 1u;
    atexit(nullsub_5);
  }
  grim_line_dx = *p1 - *p0;
  grim_line_dy = p1[1] - p0[1];
  sub_1000CC39(&grim_line_dx, &grim_line_dx);
  v5 = grim_line_dy * thickness;
  grim_line_dx = v5;
  grim_line_dy = v5 * thickness;
  (*(void (__thiscall **)(int, float *, float *, float *))(*(_DWORD *)v4 + 228))(v4, p0, p1, &grim_line_dx);
}

// nullsub_5 @ 0x10008140
void __cdecl nullsub_5()
{
  ;
}

// grim_draw_line_quad @ 0x10008150
// Grim2D vtable 0xe4 (provisional): line quad from endpoints + half-width vector
void grim_draw_line_quad(float *p0, float *p1, float *half_vec)
{
  int v3; // ecx
  float v4; // [esp+0h] [ebp-28h]
  float v5; // [esp+4h] [ebp-24h]
  float v6; // [esp+8h] [ebp-20h]
  float v7; // [esp+Ch] [ebp-1Ch]
  float v8; // [esp+10h] [ebp-18h]
  float v9; // [esp+14h] [ebp-14h]
  float v10; // [esp+18h] [ebp-10h]
  float v11; // [esp+1Ch] [ebp-Ch]

  v11 = p1[1] - half_vec[1];
  v10 = *p1 - *half_vec;
  v9 = p1[1] + half_vec[1];
  v8 = *p1 + *half_vec;
  v7 = p0[1] + half_vec[1];
  v6 = *p0 + *half_vec;
  v5 = p0[1] - half_vec[1];
  v4 = *p0 - *half_vec;
  (*(void (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v3 + 312))(
    LODWORD(v4),
    LODWORD(v5),
    LODWORD(v6),
    LODWORD(v7),
    LODWORD(v8),
    LODWORD(v9),
    LODWORD(v10),
    LODWORD(v11));
}

// grim_set_color_slot @ 0x100081C0
// Grim2D vtable 0x118 (provisional): set color slot
void grim_set_color_slot(int index, float r, float g, float b, float a)
{
  grim_color_slot0[index] = (unsigned __int8)(__int64)(b * 255.0)
                          | (((unsigned __int8)(__int64)(g * 255.0)
                            | ((((unsigned int)(__int64)(a * 255.0) << 8) | (unsigned __int8)(__int64)(r * 255.0)) << 8)) << 8);
}

// grim_set_atlas_frame @ 0x10008230
// Grim2D vtable 0x104 (provisional)
void grim_set_atlas_frame(int atlas_size, int frame)
{
  double v2; // st7
  int v3; // edx
  int v4; // [esp+4h] [ebp-4h]

  v2 = 1.0 / (double)atlas_size;
  v3 = grim_subrect_ptr_table[atlas_size];
  v4 = *(int *)(v3 + 8 * frame + 4);
  dword_1005B2A8 = *(_DWORD *)(v3 + 8 * frame);
  grim_uv_v1 = v4;
  grim_uv_u0[0] = dword_1005B2A8;
  grim_uv_v0[0] = v4;
  *(float *)&grim_uv_u1 = *(float *)&dword_1005B2A8 + v2;
  dword_1005B2A0 = grim_uv_u1;
  *(float *)&dword_1005B2A4 = *(float *)&v4 + v2;
  *(float *)&dword_1005B2AC = *(float *)&v4 + v2;
}

// grim_set_sub_rect @ 0x100082C0
// Grim2D vtable 0x108: atlas sub-rect from grid table
void grim_set_sub_rect(int atlas_size, int width, int height, int frame)
{
  double v4; // st7
  int v5; // edx
  int v6; // [esp+4h] [ebp-4h]

  v4 = 1.0 / (double)atlas_size;
  v5 = grim_subrect_ptr_table[atlas_size];
  v6 = *(int *)(v5 + 8 * frame + 4);
  dword_1005B2A8 = *(_DWORD *)(v5 + 8 * frame);
  grim_uv_v1 = v6;
  grim_uv_u0[0] = dword_1005B2A8;
  grim_uv_v0[0] = v6;
  *(float *)&grim_uv_u1 = (double)width * v4 + *(float *)&dword_1005B2A8;
  dword_1005B2A0 = grim_uv_u1;
  *(float *)&dword_1005B2A4 = v4 * (double)height + *(float *)&v6;
  dword_1005B2AC = dword_1005B2A4;
}

// grim_set_uv @ 0x10008350
// Grim2D vtable 0x100 (provisional)
void grim_set_uv(float u0, float v0, float u1, float v1)
{
  *(float *)grim_uv_u0 = u0;
  *(float *)grim_uv_v0 = v0;
  grim_uv_u1 = LODWORD(u1);
  grim_uv_v1 = LODWORD(v0);
  dword_1005B2A0 = LODWORD(u1);
  dword_1005B2A4 = LODWORD(v1);
  dword_1005B2A8 = LODWORD(u0);
  dword_1005B2AC = LODWORD(v1);
}

// grim_set_uv_point @ 0x100083A0
// Grim2D vtable 0x10c: set UV point
void grim_set_uv_point(int index, float u, float v)
{
  *(float *)&grim_uv_u0[2 * index] = u;
  *(float *)&grim_uv_v0[2 * index] = v;
}

// grim_flush_batch @ 0x100083C0
// Grim2D vtable 0xec: flush batch when vertex buffer fills
void grim_flush_batch()
{
  if ( !grim_render_disabled && grim_batch_active )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
    (*(void (__stdcall **)(void *, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)grim_d3d_device + 284))(
      grim_d3d_device,
      4,
      0,
      (unsigned __int16)grim_vertex_count,
      0,
      (unsigned __int16)grim_vertex_count >> 1);
    if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
           grim_vertex_buffer,
           0,
           0,
           &grim_vertex_write_ptr,
           10240) >= 0 )
      LOWORD(grim_vertex_count) = 0;
  }
}

// grim_submit_vertices_offset_color @ 0x10008430
// Grim2D vtable 0x130: translate + apply color
void grim_submit_vertices_offset_color(float *verts, int count, float *offset, float *color)
{
  int v4; // ecx
  int v5; // edx
  int v6; // eax

  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, verts, 4 * ((unsigned int)(28 * count) >> 2));
    if ( count > 0 )
    {
      v5 = count;
      do
      {
        v6 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *offset + *(float *)grim_vertex_write_ptr;
        *(float *)(v6 + 4) = offset[1] + *(float *)(v6 + 4);
        *(float *)(grim_vertex_write_ptr + 16) = *color;
        --v5;
        grim_vertex_write_ptr += 28;
      }
      while ( v5 );
    }
    LOWORD(grim_vertex_count) = count + grim_vertex_count;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (**)(void))(*(_DWORD *)v4 + 236))();
  }
}

// grim_submit_vertices_transform_color @ 0x100084E0
// Grim2D vtable 0x134: rotate + translate + apply color
void grim_submit_vertices_transform_color(float *verts, int count, float *offset, float *matrix, float *color)
{
  int v5; // ecx
  int v6; // eax
  int v7; // esi
  float *v8; // eax
  double v9; // st7
  int v10; // eax

  v6 = v5;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, verts, 4 * ((unsigned int)(28 * count) >> 2));
    if ( count > 0 )
    {
      v7 = count;
      do
      {
        v8 = (float *)grim_vertex_write_ptr;
        v9 = *(float *)(grim_vertex_write_ptr + 4) * matrix[1] + *(float *)grim_vertex_write_ptr * *matrix;
        *(float *)(grim_vertex_write_ptr + 4) = *(float *)(grim_vertex_write_ptr + 4) * matrix[3]
                                              + *(float *)grim_vertex_write_ptr * matrix[2];
        *v8 = v9;
        v10 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *offset + *(float *)grim_vertex_write_ptr;
        *(float *)(v10 + 4) = offset[1] + *(float *)(v10 + 4);
        *(float *)(grim_vertex_write_ptr + 16) = *color;
        --v7;
        grim_vertex_write_ptr += 28;
      }
      while ( v7 );
      v6 = v5;
    }
    LOWORD(grim_vertex_count) = count + grim_vertex_count;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (__thiscall **)(int))(*(_DWORD *)v6 + 236))(v6);
  }
}

// grim_submit_vertices_transform @ 0x100085C0
// Grim2D vtable 0x128: copy verts, rotate, translate
void grim_submit_vertices_transform(float *verts, int count, float *offset, float *matrix)
{
  int v4; // ecx
  int v5; // esi
  float *v6; // eax
  double v7; // st7
  int v8; // eax

  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, verts, 4 * ((unsigned int)(28 * count) >> 2));
    if ( count > 0 )
    {
      v5 = count;
      do
      {
        v6 = (float *)grim_vertex_write_ptr;
        v7 = *(float *)(grim_vertex_write_ptr + 4) * matrix[1] + *matrix * *(float *)grim_vertex_write_ptr;
        *(float *)(grim_vertex_write_ptr + 4) = *(float *)(grim_vertex_write_ptr + 4) * matrix[3]
                                              + *(float *)grim_vertex_write_ptr * matrix[2];
        *v6 = v7;
        v8 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *offset + *(float *)grim_vertex_write_ptr;
        *(float *)(v8 + 4) = offset[1] + *(float *)(v8 + 4);
        --v5;
        grim_vertex_write_ptr += 28;
      }
      while ( v5 );
    }
    LOWORD(grim_vertex_count) = count + grim_vertex_count;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (**)(void))(*(_DWORD *)v4 + 236))();
  }
}

// grim_submit_vertices_offset @ 0x10008680
// Grim2D vtable 0x12c: copy verts, translate
void grim_submit_vertices_offset(float *verts, int count, float *offset)
{
  int v3; // ecx
  int v4; // edx
  int v5; // eax

  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, verts, 4 * ((unsigned int)(28 * count) >> 2));
    if ( count > 0 )
    {
      v4 = count;
      do
      {
        v5 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *(float *)grim_vertex_write_ptr + *offset;
        *(float *)(v5 + 4) = offset[1] + *(float *)(v5 + 4);
        --v4;
        grim_vertex_write_ptr += 28;
      }
      while ( v4 );
    }
    LOWORD(grim_vertex_count) = count + grim_vertex_count;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (**)(void))(*(_DWORD *)v3 + 236))();
  }
}

// grim_draw_quad_xy @ 0x10008720
// Grim2D vtable 0x120: draw quad from xy pointer
void grim_draw_quad_xy(float *xy, float w, float h)
{
  int v3; // ecx

  (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v3 + 284))(
    v3,
    *(_DWORD *)xy,
    *((_DWORD *)xy + 1),
    LODWORD(w),
    LODWORD(h));
}

// grim_draw_quad_rotated_matrix @ 0x10008750
// Grim2D vtable 0x124 (provisional): quad with rotation matrix
void grim_draw_quad_rotated_matrix(float x, float y, float w, float h)
{
  int v4; // ecx
  int v5; // esi
  double v6; // st7
  double v7; // st6
  double v8; // st6
  double v9; // st6
  double v10; // st6
  float v11; // [esp+4h] [ebp-28h]
  float v12; // [esp+8h] [ebp-24h]
  float v13; // [esp+Ch] [ebp-20h]
  float v14; // [esp+10h] [ebp-1Ch]
  float v15; // [esp+14h] [ebp-18h]
  float v16; // [esp+14h] [ebp-18h]
  float v17; // [esp+18h] [ebp-14h]
  float v18; // [esp+1Ch] [ebp-10h]
  float v19; // [esp+20h] [ebp-Ch]
  float v20; // [esp+24h] [ebp-8h]
  float v21; // [esp+28h] [ebp-4h]
  float xa; // [esp+30h] [ebp+4h]
  float xb; // [esp+30h] [ebp+4h]
  float ya; // [esp+34h] [ebp+8h]
  float yb; // [esp+34h] [ebp+8h]
  float yc; // [esp+34h] [ebp+8h]
  float wa; // [esp+38h] [ebp+Ch]

  v5 = v4;
  if ( !grim_render_disabled && byte_1005C898 )
  {
    if ( !grim_batch_active )
      (*(void (**)(void))(*(_DWORD *)v4 + 232))();
    if ( *(float *)&grim_rotation_radians == 0.0 )
    {
      v13 = x;
      v14 = y;
      v17 = y;
      v15 = x + w;
      v18 = v15;
      v20 = x;
      v19 = y + h;
      v21 = v19;
    }
    else
    {
      v6 = w * 0.5;
      v11 = v6 + x;
      v7 = h * 0.5;
      xa = v7;
      v12 = v7 + y;
      wa = w * -0.5;
      v8 = h * -0.5;
      ya = *(float *)&dword_1005A464 * v8 + *(float *)&dword_1005A460 * wa;
      v13 = ya + v11;
      v14 = v12 + v8 * *(float *)&dword_1005A46C + flt_1005A468 * wa;
      v16 = v6;
      yb = *(float *)&dword_1005A464 * v8 + *(float *)&dword_1005A460 * v16;
      v9 = v8 * *(float *)&dword_1005A46C + flt_1005A468 * v16;
      v15 = yb + v11;
      v17 = v12 + v9;
      yc = *(float *)&dword_1005A464 * xa + *(float *)&dword_1005A460 * v6;
      v18 = yc + v11;
      v19 = v12 + *(float *)&dword_1005A46C * xa + flt_1005A468 * v6;
      v10 = xa;
      xb = *(float *)&dword_1005A464 * xa + *(float *)&dword_1005A460 * wa;
      v20 = xb + v11;
      v21 = v12 + *(float *)&dword_1005A46C * v10 + flt_1005A468 * wa;
    }
    *(float *)grim_vertex_write_ptr = v13;
    *(float *)(grim_vertex_write_ptr + 4) = v14;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v15;
    *(float *)(grim_vertex_write_ptr + 4) = v17;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v18;
    *(float *)(grim_vertex_write_ptr + 4) = v19;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v20;
    *(float *)(grim_vertex_write_ptr + 4) = v21;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
    LOWORD(grim_vertex_count) = grim_vertex_count + 4;
    grim_vertex_write_ptr += 28;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 236))(v5);
  }
}

// grim_draw_quad @ 0x10008B10
// Grim2D vtable 0x11c (provisional)
void grim_draw_quad(float x, float y, float w, float h)
{
  int v4; // ecx
  int v5; // esi
  double v6; // st7
  double v7; // st7
  double v8; // st6
  double v9; // st6
  double v10; // st6
  float v11; // [esp+4h] [ebp-28h]
  float v12; // [esp+8h] [ebp-24h]
  float v13; // [esp+Ch] [ebp-20h]
  float v14; // [esp+10h] [ebp-1Ch]
  float v15; // [esp+14h] [ebp-18h]
  float v16; // [esp+18h] [ebp-14h]
  float v17; // [esp+1Ch] [ebp-10h]
  float v18; // [esp+20h] [ebp-Ch]
  float v19; // [esp+28h] [ebp-4h]
  int xa; // [esp+30h] [ebp+4h]
  float xb; // [esp+30h] [ebp+4h]

  v5 = v4;
  if ( !grim_render_disabled && byte_1005C898 )
  {
    if ( !grim_batch_active )
      (*(void (**)(void))(*(_DWORD *)v4 + 232))();
    if ( *(float *)&grim_rotation_radians == 0.0 )
    {
      v11 = x;
      v12 = y;
      v14 = y;
      v13 = x + w;
      v15 = v13;
      v6 = y + h;
      v17 = x;
      v16 = v6;
    }
    else
    {
      v7 = w * 0.5 + x;
      v19 = h * 0.5 + y;
      v8 = w * w + h * h;
      *(float *)&xa = v8;
      v9 = v8
         * ((1.5 - v8 * 0.5 * COERCE_FLOAT(1597463007 - (xa >> 1)) * COERCE_FLOAT(1597463007 - (xa >> 1)))
          * COERCE_FLOAT(1597463007 - (xa >> 1)))
         * 0.5;
      xb = grim_rotation_cos * v9;
      v10 = v9 * *(float *)&DstBuf[260];
      v11 = v7 - xb;
      v12 = v19 - v10;
      v13 = v7 + v10;
      v14 = v19 - xb;
      v15 = v7 + xb;
      v16 = v19 + v10;
      v17 = v7 - v10;
      v6 = v19 + xb;
    }
    *(float *)grim_vertex_write_ptr = v11;
    v18 = v6;
    *(float *)(grim_vertex_write_ptr + 4) = v12;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v13;
    *(float *)(grim_vertex_write_ptr + 4) = v14;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v15;
    *(float *)(grim_vertex_write_ptr + 4) = v16;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = v17;
    *(float *)(grim_vertex_write_ptr + 4) = v18;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
    LOWORD(grim_vertex_count) = grim_vertex_count + 4;
    grim_vertex_write_ptr += 28;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (__thiscall **)(int))(*(_DWORD *)v5 + 236))(v5);
  }
}

// grim_submit_vertex_raw @ 0x10008E30
// Grim2D vtable 0xf4: push 1 raw vertex (7 floats)
void grim_submit_vertex_raw(float *vertex)
{
  int v1; // ecx
  int v2; // ebx

  v2 = v1;
  if ( !grim_render_disabled && byte_1005C898 )
  {
    if ( !grim_batch_active )
      (*(void (**)(void))(*(_DWORD *)v1 + 232))();
    qmemcpy((void *)grim_vertex_write_ptr, vertex, 0x1Cu);
    LOWORD(grim_vertex_count) = grim_vertex_count + 1;
    grim_vertex_write_ptr += 28;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (__thiscall **)(int))(*(_DWORD *)v2 + 236))(v2);
  }
}

// grim_submit_quad_raw @ 0x10008EB0
// Grim2D vtable 0xf8: push 4 raw vertices (28 floats)
void grim_submit_quad_raw(float *verts)
{
  int v1; // ecx

  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, verts, 0x70u);
    LOWORD(grim_vertex_count) = grim_vertex_count + 4;
    grim_vertex_write_ptr += 112;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (**)(void))(*(_DWORD *)v1 + 236))();
  }
}

// grim_draw_rect_outline @ 0x10008F10
// Grim2D vtable 0xd4: UI panel outline/frame (4 edge quads)
void grim_draw_rect_outline(float *xy, float w, float h)
{
  int v3; // ecx
  int v4; // esi
  float v5; // [esp+60h] [ebp-1Ch]
  float v6; // [esp+64h] [ebp-18h]
  float v7; // [esp+68h] [ebp-14h]

  v4 = v3;
  (*(void (__stdcall **)(void *, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
  (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
  (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
  (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v4 + 252))(v4, 0);
  (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 232))(v4);
  if ( h == 1.0 )
  {
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      *((_DWORD *)xy + 1),
      LODWORD(w),
      1065353216);
  }
  else if ( w == 1.0 )
  {
    (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      *((_DWORD *)xy + 1),
      1065353216,
      LODWORD(h));
  }
  else
  {
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      *((_DWORD *)xy + 1),
      LODWORD(w),
      1065353216);
    (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      *((_DWORD *)xy + 1),
      1065353216,
      LODWORD(h));
    v7 = w + 1.0;
    v6 = h + xy[1];
    (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)v4 + 284))(
      v4,
      *(_DWORD *)xy,
      LODWORD(v6),
      LODWORD(v7),
      1065353216);
    v5 = w + *xy;
    (*(void (__thiscall **)(int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v4 + 284))(
      v4,
      LODWORD(v5),
      *((_DWORD *)xy + 1),
      1065353216,
      LODWORD(h));
  }
  (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 240))(v4);
  (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
  (*(void (__stdcall **)(void *, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
}

// grim_draw_quad_points @ 0x10009080
// Grim2D vtable 0x138 (provisional): push quad using 4 points
void grim_draw_quad_points(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3)
{
  int v8; // ecx
  int v9; // esi

  v9 = v8;
  if ( !grim_render_disabled && byte_1005C898 )
  {
    if ( !grim_batch_active )
      (*(void (**)(void))(*(_DWORD *)v8 + 232))();
    *(float *)grim_vertex_write_ptr = x0;
    *(float *)(grim_vertex_write_ptr + 4) = y0;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = x1;
    *(float *)(grim_vertex_write_ptr + 4) = y1;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = x2;
    *(float *)(grim_vertex_write_ptr + 4) = y2;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
    grim_vertex_write_ptr += 28;
    *(float *)grim_vertex_write_ptr = x3;
    *(float *)(grim_vertex_write_ptr + 4) = y3;
    *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
    *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
    *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
    *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
    *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
    LOWORD(grim_vertex_count) = grim_vertex_count + 4;
    grim_vertex_write_ptr += 28;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      (*(void (__thiscall **)(int))(*(_DWORD *)v9 + 236))(v9);
  }
}

// grim_draw_text_mono @ 0x100092B0
// Grim2D vtable 0x13c: fixed 16px mono text
void grim_draw_text_mono(float x, float y, char *text)
{
  int *v3; // ecx
  float v4; // ebp
  float v5; // edi
  int *v6; // esi
  char *v7; // ebx
  float v8; // ebp
  signed int v9; // eax
  unsigned int v10; // kr04_4
  char v11; // al
  int v12; // eax
  double v13; // st7
  float v14; // [esp+2Ch] [ebp-6Ch]
  float v15; // [esp+30h] [ebp-68h]
  float v16; // [esp+34h] [ebp-64h]
  float v17; // [esp+38h] [ebp-60h]
  float v18; // [esp+3Ch] [ebp-5Ch]
  float v19; // [esp+40h] [ebp-58h]
  signed int v20; // [esp+44h] [ebp-54h]
  int v21; // [esp+58h] [ebp-40h]
  float v23; // [esp+60h] [ebp-38h]
  float v24; // [esp+64h] [ebp-34h]
  float v25; // [esp+68h] [ebp-30h]
  float v26; // [esp+6Ch] [ebp-2Ch]
  float v27; // [esp+70h] [ebp-28h]
  float v28; // [esp+74h] [ebp-24h]
  float v29; // [esp+78h] [ebp-20h]
  float v30; // [esp+7Ch] [ebp-1Ch]
  float v31; // [esp+80h] [ebp-18h]
  float v32; // [esp+84h] [ebp-14h]
  float v33; // [esp+88h] [ebp-10h]
  float v34; // [esp+8Ch] [ebp-Ch]
  float v35; // [esp+90h] [ebp-8h]
  float v36; // [esp+94h] [ebp-4h]
  float retaddr; // [esp+98h] [ebp+0h]
  char ya; // [esp+A0h] [ebp+8h]

  v6 = v3;
  if ( !grim_render_disabled )
  {
    v7 = text;
    if ( text )
    {
      if ( !(_BYTE)grim_font_texture_bound )
        (*(void (__stdcall **)(void *, _DWORD, int))(*(_DWORD *)grim_d3d_device + 244))(
          grim_d3d_device,
          0,
          grim_font_texture);
      v19 = *(float *)&dword_1005CD08;
      v15 = v4;
      v14 = v5;
      v8 = x;
      *(float *)&v21 = x;
      (*(void (__thiscall **)(int *, _DWORD))(*v6 + 252))(v6, 0);
      (*(void (__thiscall **)(int *))(*v6 + 232))(v6);
      v9 = 0;
      v10 = strlen(text) + 1;
      ya = 0;
      v20 = 0;
      if ( (int)(v10 - 1) > 0 )
      {
        while ( 1 )
        {
          v11 = v7[v9];
          if ( v11 == 10 )
          {
            *(float *)&v21 = x;
            v8 = x;
            y = v19 * 28.0 + y;
            goto LABEL_24;
          }
          if ( v11 == -89 )
          {
            ya = 1;
            goto LABEL_24;
          }
          if ( v11 == -27 )
            break;
          if ( v11 == -28 )
          {
            v27 = *(float *)&dword_1005B5D0 + 0.0625;
            v28 = *(float *)&dword_1005B5D4 + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*v6 + 256))(
              v6,
              dword_1005B5D0,
              dword_1005B5D4,
              LODWORD(v27),
              LODWORD(v28),
              COERCE_FLOAT(LODWORD(v14)),
              COERCE_FLOAT(LODWORD(v15)),
              COERCE_FLOAT(LODWORD(v16)),
              COERCE_FLOAT(LODWORD(v17)));
            v8 = v25;
            (*(void (__thiscall **)(int *))(*v6 + 284))(v6);
            v21 = dword_1005B3D8;
            y = *(float *)&dword_1005B3DC;
            v33 = *(float *)&dword_1005B3D8 + 0.0625;
            v34 = *(float *)&dword_1005B3DC + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD))(*v6 + 256))(
              v6,
              dword_1005B3D8,
              dword_1005B3DC,
              LODWORD(v33),
              LODWORD(v34));
            v12 = *v6;
            v17 = v19 * 32.0;
            v16 = v17;
            v15 = v26;
          }
          else
          {
            if ( v11 != -10 )
            {
              if ( ya )
              {
                ya = 0;
              }
              else
              {
                v18 = v19 * 16.0;
                *(float *)&v21 = *(float *)&v21 + v18;
                v8 = *(float *)&v21;
              }
              v35 = *(float *)&grim_font2_uv_u[2 * v11] + 0.0625;
              v36 = grim_font2_uv_v[2 * v11] + 0.0625;
              (*(void (__thiscall **)(int *, int, _DWORD, _DWORD, _DWORD, float, float, float, float))(*v6 + 256))(
                v6,
                grim_font2_uv_u[2 * v11],
                LODWORD(grim_font2_uv_v[2 * v11]),
                LODWORD(v35),
                LODWORD(v36),
                COERCE_FLOAT(LODWORD(v14)),
                COERCE_FLOAT(LODWORD(v15)),
                COERCE_FLOAT(LODWORD(v16)),
                COERCE_FLOAT(LODWORD(v17)));
              v12 = *v6;
              v17 = v19 * 32.0;
              v13 = v26 + 1.0;
              v16 = v17;
              goto LABEL_22;
            }
            v31 = *(float *)&dword_1005B640 + 0.0625;
            v32 = *(float *)&dword_1005B644 + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*v6 + 256))(
              v6,
              dword_1005B640,
              dword_1005B644,
              LODWORD(v31),
              LODWORD(v32),
              COERCE_FLOAT(LODWORD(v14)),
              COERCE_FLOAT(LODWORD(v15)),
              COERCE_FLOAT(LODWORD(v16)),
              COERCE_FLOAT(LODWORD(v17)));
            v8 = v25;
            (*(void (__thiscall **)(int *))(*v6 + 284))(v6);
            v21 = dword_1005B3D8;
            y = *(float *)&dword_1005B3DC;
            retaddr = *(float *)&dword_1005B3D8 + 0.0625;
            x = *(float *)&dword_1005B3DC + 0.0625;
            (*(void (__thiscall **)(int *, int, int, float, _DWORD))(*v6 + 256))(
              v6,
              dword_1005B3D8,
              dword_1005B3DC,
              COERCE_FLOAT(LODWORD(retaddr)),
              LODWORD(x));
            v12 = *v6;
            v17 = v19 * 32.0;
            v16 = v17;
            v15 = v26;
          }
LABEL_23:
          v14 = v8;
          (*(void (__thiscall **)(int *))(v12 + 284))(v6);
LABEL_24:
          v9 = ++v20;
          if ( v20 >= (int)(v10 - 1) )
            goto LABEL_25;
          v7 = text;
        }
        v23 = *(float *)&dword_1005B5D0 + 0.0625;
        v24 = *(float *)&dword_1005B5D4 + 0.0625;
        (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*v6 + 256))(
          v6,
          dword_1005B5D0,
          dword_1005B5D4,
          LODWORD(v23),
          LODWORD(v24),
          COERCE_FLOAT(LODWORD(v14)),
          COERCE_FLOAT(LODWORD(v15)),
          COERCE_FLOAT(LODWORD(v16)),
          COERCE_FLOAT(LODWORD(v17)));
        v8 = v25;
        (*(void (__thiscall **)(int *))(*v6 + 284))(v6);
        v21 = dword_1005B438;
        y = *(float *)&dword_1005B43C;
        v29 = *(float *)&dword_1005B438 + 0.0625;
        v30 = *(float *)&dword_1005B43C + 0.0625;
        (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD))(*v6 + 256))(
          v6,
          dword_1005B438,
          dword_1005B43C,
          LODWORD(v29),
          LODWORD(v30));
        v12 = *v6;
        v17 = v19 * 32.0;
        v13 = v26 - 6.0;
        v16 = v17;
LABEL_22:
        v15 = v13;
        goto LABEL_23;
      }
LABEL_25:
      (*(void (__thiscall **)(int *))(*v6 + 240))(v6);
    }
  }
}

// grim_measure_text_width @ 0x100096C0
// Grim2D vtable 0x14c: small font width metric (handles newlines)
int grim_measure_text_width(char *text)
{
  int result; // eax
  int v2; // esi
  unsigned int v3; // kr04_4
  signed int v4; // edi

  if ( !text )
    return 0;
  result = 0;
  v2 = 0;
  v3 = strlen(text) + 1;
  v4 = 0;
  if ( (int)(v3 - 1) > 0 )
  {
    do
    {
      if ( text[v4] == 10 )
      {
        if ( v2 > result )
          result = v2;
        v2 = 0;
      }
      else
      {
        v2 += (unsigned __int8)grim_font2_glyph_widths[(unsigned __int8)grim_font2_char_map[(unsigned __int8)text[v4]]];
      }
      ++v4;
    }
    while ( v4 < (int)(v3 - 1) );
    if ( v2 > result )
      return v2;
  }
  return result;
}

// grim_draw_text_small @ 0x10009730
// Grim2D vtable 0x144: small font draw (GRIM_Font2)
void grim_draw_text_small(float x, float y, char *text)
{
  int v3; // ecx
  int v4; // esi
  int v6; // eax
  unsigned int v7; // kr04_4
  signed int i; // edi
  int v9; // eax
  int v10; // [esp+28h] [ebp-3Ch]
  int v11; // [esp+2Ch] [ebp-38h]
  int v12; // [esp+30h] [ebp-34h]
  float v13; // [esp+44h] [ebp-20h]
  float v14; // [esp+48h] [ebp-1Ch]
  float v15; // [esp+4Ch] [ebp-18h]
  float v16; // [esp+50h] [ebp-14h]
  float v17; // [esp+54h] [ebp-10h]
  float v18; // [esp+58h] [ebp-Ch]
  float v19; // [esp+60h] [ebp-4h]
  float xa; // [esp+68h] [ebp+4h]
  float ya; // [esp+6Ch] [ebp+8h]
  float yb; // [esp+6Ch] [ebp+8h]
  char *texta; // [esp+70h] [ebp+Ch]

  v4 = v3;
  if ( !grim_render_disabled )
  {
    if ( text )
    {
      xa = (float)(__int64)x;
      v6 = grim_font2_texture_handle;
      ya = (float)(__int64)y;
      if ( grim_font2_texture_handle != -1
        || (v6 = (*(int (__thiscall **)(int, char *))(*(_DWORD *)v3 + 192))(v3, aGrimFont2),
            grim_font2_texture_handle = v6,
            v6 != -1) )
      {
        (*(void (__thiscall **)(int, int, _DWORD))(*(_DWORD *)v4 + 196))(v4, v6, 0);
        v14 = ya;
        v13 = xa;
        texta = (char *)dword_1005CCD8;
        if ( dword_1005CCD8 != 1 )
          (*(void (__thiscall **)(int, int, int))(*(_DWORD *)v4 + 32))(v4, 21, 1);
        (*(void (__thiscall **)(int, _DWORD))(*(_DWORD *)v4 + 252))(v4, 0);
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 232))(v4);
        v7 = strlen(text) + 1;
        for ( i = 0; i < (int)(v7 - 1); ++i )
        {
          v9 = (unsigned __int8)grim_font2_char_map[(unsigned __int8)text[i]];
          if ( text[i] == 10 )
          {
            v13 = xa;
            v14 = v14 + 16.0;
          }
          else
          {
            yb = (float)(unsigned __int8)grim_font2_glyph_widths[v9];
            v15 = *(float *)&grim_font2_uv_u[2 * v9] + 0.001953125;
            v16 = grim_font2_uv_v[2 * v9] + 0.001953125;
            v19 = v16 + 0.0625;
            v17 = yb * 0.00390625 + v15 - 0.001953125;
            v18 = v19 - 0.001953125;
            (*(void (__thiscall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)v4 + 256))(
              v4,
              LODWORD(v15),
              LODWORD(v16),
              LODWORD(v17),
              LODWORD(v18));
            (*(void (__thiscall **)(int, float, float, _DWORD, int))(*(_DWORD *)v4 + 284))(
              v4,
              COERCE_FLOAT(LODWORD(v13)),
              COERCE_FLOAT(LODWORD(v14)),
              LODWORD(yb),
              1098907648);
            v13 = yb + v13;
          }
        }
        (*(void (__thiscall **)(int))(*(_DWORD *)v4 + 240))(v4);
        (*(void (__thiscall **)(int, int, char *, int, int, int))(*(_DWORD *)v4 + 32))(v4, 21, texta, v10, v11, v12);
      }
    }
  }
}

// grim_draw_text_mono_fmt @ 0x10009940
// Grim2D vtable 0x140: printf-style wrapper around draw_text_mono (cdecl varargs, explicit self)
void grim_draw_text_mono_fmt(void *self, float x, float y, char *fmt, ...)
{
  va_list ArgList; // [esp+14h] [ebp+14h] BYREF

  va_start(ArgList, fmt);
  vsprintf(grim_printf_buffer, fmt, ArgList);
  (*(void (__thiscall **)(void *, _DWORD, _DWORD, char *))(*(_DWORD *)self + 316))(
    self,
    LODWORD(x),
    LODWORD(y),
    grim_printf_buffer);
}

// grim_draw_text_small_fmt @ 0x10009980
// Grim2D vtable 0x148: formatted small-font text (cdecl varargs, explicit self; vsprintf + vtable 0x144)
void grim_draw_text_small_fmt(void *self, float x, float y, char *fmt, ...)
{
  va_list ArgList; // [esp+14h] [ebp+14h] BYREF

  va_start(ArgList, fmt);
  vsprintf(grim_printf_buffer_alt, fmt, ArgList);
  (*(void (__thiscall **)(void *, _DWORD, _DWORD, char *))(*(_DWORD *)self + 324))(
    self,
    LODWORD(x),
    LODWORD(y),
    grim_printf_buffer_alt);
}

// GRIM__GetInterface @ 0x100099C0
// export: constructs (singleton) Grim2D interface instance backed by grim_interface_vtable
void *GRIM__GetInterface()
{
  void *v0; // eax
  void *result; // eax

  v0 = (void *)Direct3DCreate8(220);
  grim_d3d8_probe = v0;
  if ( v0 )
  {
    (*(void (__stdcall **)(void *))(*(_DWORD *)v0 + 8))(v0);
    sub_100052F0();
    result = operator new(4u);
    if ( result )
    {
      *(_DWORD *)result = &grim_interface_vtable;
      grim_interface_instance = result;
    }
    else
    {
      grim_interface_instance = 0;
      return 0;
    }
  }
  else
  {
    grim_error_text = (int)Text;
    MessageBoxA(0, Text, Caption, 0);
    return 0;
  }
  return result;
}

// DllMain @ 0x10009A20
// DLL entrypoint (process attach): caches module handle and loads dialog icon
BOOL DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    grim_module_handle = hinstDLL;
    lParam = (LPARAM)LoadIconA(hinstDLL, (LPCSTR)0x72);
  }
  return 1;
}

// sub_10009A50 @ 0x10009A50
int __cdecl sub_10009A50(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax

  a1[1] = 0;
  if ( a2 != 61 )
  {
    *(_DWORD *)(*a1 + 20) = 10;
    *(_DWORD *)(*a1 + 24) = 61;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 424 )
  {
    *(_DWORD *)(*a1 + 20) = 19;
    *(_DWORD *)(*a1 + 24) = 424;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  memset(a1, 0, 0x1A8u);
  *a1 = v3;
  *((_BYTE *)a1 + 12) = 1;
  FUN_1003d0d0(a1);
  a1[2] = 0;
  a1[5] = 0;
  a1[36] = 0;
  v4 = 4;
  a1[37] = 0;
  a1[38] = 0;
  a1[39] = 0;
  v5 = a1 + 44;
  do
  {
    *(v5 - 4) = 0;
    *v5++ = 0;
    --v4;
  }
  while ( v4 );
  sub_1003B770(a1);
  result = sub_1003ACD0(a1);
  a1[4] = 200;
  return result;
}

// sub_10009B20 @ 0x10009B20
int __cdecl sub_10009B20(int a1)
{
  return sub_1003DD30(a1);
}

// sub_10009B30 @ 0x10009B30
int __cdecl sub_10009B30(_DWORD *a1, char a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[4];
  if ( v2 != 200 && v2 != 201 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*a1 + 24) = a1[4];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_10009BA0(a1);
  if ( result == 1 )
    return 1;
  if ( result == 2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(*a1 + 20) = 50;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_1003DD00(a1);
    return 2;
  }
  return result;
}

// sub_10009BA0 @ 0x10009BA0
int __cdecl sub_10009BA0(_DWORD *a1)
{
  int v1; // edi
  int result; // eax

  v1 = 0;
  switch ( a1[4] )
  {
    case 0xC8:
      (*(void (__cdecl **)(_DWORD *))(a1[99] + 4))(a1);
      (*(void (__cdecl **)(_DWORD *))(a1[5] + 8))(a1);
      a1[4] = 201;
      goto LABEL_3;
    case 0xC9:
LABEL_3:
      v1 = (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
      if ( v1 != 1 )
        goto LABEL_8;
      sub_10009C60(a1);
      a1[4] = 202;
      result = 1;
      break;
    case 0xCA:
      return 1;
    case 0xCB:
    case 0xCC:
    case 0xCD:
    case 0xCE:
    case 0xCF:
    case 0xD0:
    case 0xD2:
      return (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
    default:
      *(_DWORD *)(*a1 + 20) = 18;
      *(_DWORD *)(*a1 + 24) = a1[4];
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
LABEL_8:
      result = v1;
      break;
  }
  return result;
}

// sub_10009C60 @ 0x10009C60
int __cdecl sub_10009C60(int a1)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax

  switch ( *(_DWORD *)(a1 + 32) )
  {
    case 1:
      *(_DWORD *)(a1 + 36) = 1;
      *(_DWORD *)(a1 + 40) = 1;
      break;
    case 3:
      if ( !*(_BYTE *)(a1 + 256) )
      {
        if ( *(_BYTE *)(a1 + 262) )
        {
          if ( *(_BYTE *)(a1 + 263) )
          {
            if ( *(_BYTE *)(a1 + 263) != 1 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
              (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
            }
            goto LABEL_25;
          }
LABEL_23:
          *(_DWORD *)(a1 + 36) = 2;
          *(_DWORD *)(a1 + 40) = 2;
          break;
        }
        v1 = *(int **)(a1 + 196);
        v2 = *v1;
        v3 = v1[21];
        v4 = v1[42];
        if ( *v1 == 1 )
        {
          if ( v3 == 2 && v4 == 3 )
          {
            *(_DWORD *)(a1 + 36) = 3;
            *(_DWORD *)(a1 + 40) = 2;
            break;
          }
        }
        else if ( v2 == 82 && v3 == 71 && v4 == 66 )
        {
          goto LABEL_23;
        }
        v5 = *(_DWORD **)a1;
        v5[6] = v2;
        v5 += 6;
        v5[1] = v3;
        v5[2] = v4;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 107;
        (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      }
LABEL_25:
      *(_DWORD *)(a1 + 36) = 3;
      *(_DWORD *)(a1 + 40) = 2;
      break;
    case 4:
      if ( *(_BYTE *)(a1 + 262) && *(_BYTE *)(a1 + 263) )
      {
        if ( *(_BYTE *)(a1 + 263) != 2 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 36) = 5;
        *(_DWORD *)(a1 + 40) = 4;
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 4;
        *(_DWORD *)(a1 + 40) = 4;
      }
      break;
    default:
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 40) = 0;
      break;
  }
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 44) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 60) = 1072693248;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 73) = 1;
  *(_BYTE *)(a1 + 74) = 0;
  *(_DWORD *)(a1 + 76) = 2;
  *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 256;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 89) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  return 1;
}

// sub_10009E00 @ 0x10009E00
char __cdecl sub_10009E00(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( (v1 == 205 || v1 == 206) && !*(_BYTE *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 120) < *(_DWORD *)(a1 + 96) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 66;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 == 207 )
  {
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 != 210 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 396);
  if ( *(_BYTE *)(v2 + 17) )
  {
LABEL_14:
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 20) + 24))(a1);
    sub_1003DD00(a1);
    return 1;
  }
  else
  {
    while ( (*(int (__cdecl **)(int))v2)(a1) )
    {
      v2 = *(_DWORD *)(a1 + 396);
      if ( *(_BYTE *)(v2 + 17) )
        goto LABEL_14;
    }
    return 0;
  }
}

// sub_10009EC0 @ 0x10009EC0
char __cdecl sub_10009EC0(int a1)
{
  int v2; // eax
  void (__cdecl **v3)(int); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx

  if ( *(_DWORD *)(a1 + 16) == 202 )
  {
    sub_1003E040(a1);
    if ( *(_BYTE *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 16) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 16) = 203;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 == 203 )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) )
    {
      while ( 1 )
      {
        v3 = *(void (__cdecl ***)(int))(a1 + 8);
        if ( v3 )
          (*v3)(a1);
        v4 = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
        if ( !v4 )
          return 0;
        if ( v4 == 2 )
          goto LABEL_17;
        v5 = *(_DWORD *)(a1 + 8);
        if ( v5 && (v4 == 3 || v4 == 1) )
        {
          ++*(_DWORD *)(v5 + 4);
          v6 = *(_DWORD *)(a1 + 8);
          v7 = *(_DWORD *)(v6 + 8);
          if ( *(_DWORD *)(v6 + 4) >= v7 )
            *(_DWORD *)(v6 + 8) = v7 + *(_DWORD *)(a1 + 280);
        }
      }
    }
    else
    {
LABEL_17:
      *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 124);
      return sub_10009FA0(a1);
    }
  }
  else
  {
    if ( v2 != 204 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    return sub_10009FA0(a1);
  }
}

// sub_10009FA0 @ 0x10009FA0
char __cdecl sub_10009FA0(int a1)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // edx

  if ( *(_DWORD *)(a1 + 16) != 204 )
  {
    (**(void (__cdecl ***)(int))(a1 + 380))(a1);
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 16) = 204;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
  {
    v1 = (unsigned int *)(a1 + 120);
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 < *(_DWORD *)(a1 + 96) )
        break;
LABEL_10:
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
      (**(void (__cdecl ***)(int))(a1 + 380))(a1);
      v5 = *(_DWORD *)(a1 + 380);
      *v1 = 0;
      if ( !*(_BYTE *)(v5 + 8) )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = v2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 96);
        (**(void (__cdecl ***)(int))(a1 + 8))(a1);
      }
      v4 = *v1;
      (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(*(_DWORD *)(a1 + 384) + 4))(a1, 0, a1 + 120, 0);
      v2 = *v1;
      if ( *v1 == v4 )
        return 0;
      if ( v2 >= *(_DWORD *)(a1 + 96) )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_11:
    *(_DWORD *)(a1 + 16) = (*(_BYTE *)(a1 + 65) != 0) + 205;
    return 1;
  }
}

// sub_1000A070 @ 0x1000A070
_DWORD *__cdecl sub_1000A070(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // [esp-4h] [ebp-8h]

  v3 = a1;
  if ( a1[4] != 205 )
  {
    v8 = a1;
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*v3 + 24) = v3[4];
    (*(void (__cdecl **)(_DWORD *))*v3)(v8);
  }
  v4 = v3[30];
  if ( v4 < v3[24] )
  {
    v6 = v3[2];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = v4;
      *(_DWORD *)(v3[2] + 8) = v3[24];
      (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
    }
    v7 = v3[96];
    a1 = 0;
    (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, a3);
    result = a1;
    v3[30] += a1;
  }
  else
  {
    *(_DWORD *)(*v3 + 20) = 119;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
    return 0;
  }
  return result;
}

// sub_1000A110 @ 0x1000A110
int __stdcall sub_1000A110(int a1, int a2)
{
  if ( (*(int (__stdcall **)(_DWORD, int, char *, _DWORD))(**(_DWORD **)&String[280] + 12))(
         *(_DWORD *)&String[280],
         a1 + 4,
         &String[284],
         0) < 0 )
    return 1;
  String[288] = 1;
  return 0;
}

// sub_1000A150 @ 0x1000A150
BOOL __stdcall sub_1000A150(int a1, int a2)
{
  BOOL result; // eax
  _DWORD v3[6]; // [esp+0h] [ebp-18h] BYREF

  result = 1;
  if ( (*(_DWORD *)(a1 + 24) & 3) != 0 )
  {
    v3[2] = *(_DWORD *)(a1 + 24);
    v3[0] = 24;
    v3[1] = 16;
    v3[3] = 2;
    v3[4] = -1000;
    v3[5] = 1000;
    if ( (*(int (__stdcall **)(_DWORD, int, _DWORD *))(**(_DWORD **)&String[284] + 24))(*(_DWORD *)&String[284], 4, v3) < 0 )
      return 0;
  }
  return result;
}

// grim_joystick_init @ 0x1000A1C0
// initializes DirectInput joystick device and acquires it
int grim_joystick_init(int hwnd)
{
  LPDIRECTINPUT8A v1; // eax
  HMODULE ModuleHandleA; // eax
  int result; // eax

  if ( !hwnd && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = grim_dinput_joystick;
  if ( !grim_dinput_joystick )
  {
    ModuleHandleA = GetModuleHandleA(0);
    result = DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&grim_dinput_joystick, 0);
    if ( result < 0 )
    {
      grim_dinput_joystick = 0;
      LOBYTE(result) = 0;
      return result;
    }
    v1 = grim_dinput_joystick;
  }
  if ( !grim_joystick_device )
  {
    result = v1->lpVtbl->EnumDevices(v1, 4, (LPDIENUMDEVICESCALLBACKA)sub_1000A110, 0, 1);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    if ( !unk_1005D948 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_joystick_device->lpVtbl->SetDataFormat(grim_joystick_device, (LPCDIDATAFORMAT)&unk_1004FE74);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_joystick_device->lpVtbl->SetCooperativeLevel(grim_joystick_device, (HWND)hwnd, 5);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_joystick_device->lpVtbl->EnumObjects(
               grim_joystick_device,
               (LPDIENUMDEVICEOBJECTSCALLBACKA)sub_1000A150,
               (LPVOID)hwnd,
               0);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    if ( grim_joystick_device )
      grim_joystick_device->lpVtbl->Acquire(grim_joystick_device);
  }
  result = grim_joystick_poll();
  LOBYTE(result) = 1;
  return result;
}

// grim_joystick_poll @ 0x1000A2B0
// polls the joystick device and updates cached state
int grim_joystick_poll()
{
  int result; // eax
  bool v1; // sf
  struct IDirectInputDevice8AVtbl *lpVtbl; // edx

  result = (int)grim_dinput_joystick;
  if ( !grim_dinput_joystick || (result = (int)grim_joystick_device) == 0 )
  {
LABEL_6:
    LOBYTE(result) = 0;
    return result;
  }
  v1 = grim_joystick_device->lpVtbl->Poll(grim_joystick_device) < 0;
  lpVtbl = grim_joystick_device->lpVtbl;
  if ( v1 )
  {
    for ( result = lpVtbl->Acquire(grim_joystick_device);
          result == -2147024866;
          result = grim_joystick_device->lpVtbl->Acquire(grim_joystick_device) )
    {
      ;
    }
    goto LABEL_6;
  }
  result = lpVtbl->GetDeviceState(grim_joystick_device, 272, &grim_joystick_state);
  LOBYTE(result) = result >= 0;
  return result;
}

// sub_1000A310 @ 0x1000A310
char __cdecl sub_1000A310(unsigned __int8 a1)
{
  return (unsigned __int8)String[a1 + 56] >> 7;
}

// sub_1000A330 @ 0x1000A330
int sub_1000A330()
{
  int result; // eax

  if ( *(_DWORD *)&String[284] )
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 32))(*(_DWORD *)&String[284]);
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 8))(*(_DWORD *)&String[284]);
    *(_DWORD *)&String[284] = 0;
  }
  result = *(_DWORD *)&String[280];
  if ( *(_DWORD *)&String[280] )
  {
    result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[280] + 8))(*(_DWORD *)&String[280]);
    *(_DWORD *)&String[280] = 0;
  }
  return result;
}

// grim_keyboard_key_down @ 0x1000A370
// reads the cached key state array
int grim_keyboard_key_down(unsigned int key)
{
  int result; // eax

  result = (unsigned __int8)key;
  LOBYTE(result) = grim_keyboard_state[(unsigned __int8)key] >> 7;
  return result;
}

// grim_keyboard_init @ 0x1000A390
// initializes DirectInput keyboard device and acquires it
int grim_keyboard_init(int hwnd)
{
  LPDIRECTINPUT8A v1; // eax
  HMODULE ModuleHandleA; // eax
  int result; // eax
  _DWORD v4[5]; // [esp+24h] [ebp-14h] BYREF

  if ( !hwnd && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = grim_dinput_keyboard;
  if ( !grim_dinput_keyboard )
  {
    ModuleHandleA = GetModuleHandleA(0);
    result = DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&grim_dinput_keyboard, 0);
    if ( result < 0 )
    {
      grim_dinput_keyboard = 0;
      LOBYTE(result) = 0;
      return result;
    }
    v1 = grim_dinput_keyboard;
  }
  if ( !grim_keyboard_device )
  {
    result = v1->lpVtbl->CreateDevice(v1, &stru_1005029C, &grim_keyboard_device, 0);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_keyboard_device->lpVtbl->SetDataFormat(grim_keyboard_device, (LPCDIDATAFORMAT)&unk_1005007C);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_keyboard_device->lpVtbl->SetCooperativeLevel(grim_keyboard_device, (HWND)hwnd, 22);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    v4[0] = 20;
    v4[1] = 16;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 10;
    grim_keyboard_device->lpVtbl->SetProperty(grim_keyboard_device, (const GUID *const)1, (LPCDIPROPHEADER)v4);
    if ( grim_keyboard_device )
      grim_keyboard_device->lpVtbl->Acquire(grim_keyboard_device);
  }
  result = grim_keyboard_poll();
  LOBYTE(result) = 1;
  return result;
}

// grim_keyboard_poll @ 0x1000A4A0
// polls the keyboard device and updates cached key state
int grim_keyboard_poll()
{
  int v0; // ecx
  int result; // eax
  int v2; // ecx
  int v3; // edx
  char v4; // bl
  int v5; // [esp+24h] [ebp-4h] BYREF

  v5 = v0;
  result = (int)grim_keyboard_device;
  if ( !grim_keyboard_device )
    goto LABEL_11;
  do
  {
    do
      result = grim_keyboard_device->lpVtbl->Acquire(grim_keyboard_device);
    while ( result == -2147024866 );
  }
  while ( result == -2147024891 );
  if ( result >= 0 )
  {
    memset(grim_keyboard_state, 0, sizeof(grim_keyboard_state));
    grim_keyboard_device->lpVtbl->GetDeviceState(grim_keyboard_device, 256, grim_keyboard_state);
    v5 = 10;
    result = grim_keyboard_device->lpVtbl->GetDeviceData(
               grim_keyboard_device,
               20,
               (LPDIDEVICEOBJECTDATA)&grim_keyboard_event_buffer,
               (LPDWORD)&v5,
               0);
    if ( result >= 0 )
    {
      v2 = v5;
      if ( v5 > 0 )
      {
        result = (int)&grim_keyboard_event_buffer;
        do
        {
          v3 = *(_DWORD *)result;
          v4 = *(_BYTE *)(result + 4);
          result += 20;
          --v2;
          grim_keyboard_state[v3] = v4;
        }
        while ( v2 );
      }
    }
    LOBYTE(result) = 1;
  }
  else
  {
LABEL_11:
    LOBYTE(result) = 0;
  }
  return result;
}

// grim_keyboard_shutdown @ 0x1000A550
// releases DirectInput keyboard objects
void grim_keyboard_shutdown()
{
  if ( grim_keyboard_device )
  {
    grim_keyboard_device->lpVtbl->Unacquire(grim_keyboard_device);
    grim_keyboard_device->lpVtbl->Release(grim_keyboard_device);
    grim_keyboard_device = 0;
  }
  if ( grim_dinput_keyboard )
  {
    grim_dinput_keyboard->lpVtbl->Release(grim_dinput_keyboard);
    grim_dinput_keyboard = 0;
  }
}

// grim_mouse_button_down @ 0x1000A590
// reads the cached mouse button state
int grim_mouse_button_down(int button)
{
  int result; // eax

  result = button;
  LOBYTE(result) = grim_mouse_state.rgbButtons[button] >> 7;
  return result;
}

// grim_mouse_init @ 0x1000A5A0
// initializes DirectInput mouse device and acquires it
int grim_mouse_init()
{
  HWND v0; // esi
  LPDIRECTINPUT8A v1; // eax
  HMODULE ModuleHandleA; // eax
  int result; // eax

  v0 = hwnd;
  if ( !hwnd && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = grim_dinput_mouse;
  if ( !grim_dinput_mouse )
  {
    ModuleHandleA = GetModuleHandleA(0);
    result = DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&grim_dinput_mouse, 0);
    if ( result < 0 )
    {
      grim_dinput_mouse = 0;
      LOBYTE(result) = 0;
      return result;
    }
    v1 = grim_dinput_mouse;
  }
  if ( !grim_mouse_device )
  {
    result = v1->lpVtbl->CreateDevice(v1, &stru_100502AC, &grim_mouse_device, 0);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_mouse_device->lpVtbl->SetDataFormat(grim_mouse_device, (LPCDIDATAFORMAT)&unk_10050284);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    result = grim_mouse_device->lpVtbl->SetCooperativeLevel(grim_mouse_device, v0, 5);
    if ( result < 0 )
    {
      LOBYTE(result) = 0;
      return result;
    }
    if ( grim_mouse_device )
      grim_mouse_device->lpVtbl->Acquire(grim_mouse_device);
  }
  result = grim_mouse_poll();
  LOBYTE(result) = 1;
  return result;
}

// grim_mouse_poll @ 0x1000A670
// polls the mouse device and updates cached position/delta
int grim_mouse_poll()
{
  int result; // eax
  int v1; // esi

  result = (int)grim_mouse_device;
  if ( !grim_mouse_device )
    goto LABEL_14;
  v1 = 0;
  grim_mouse_state.lX = 0;
  flt_1005DB58 = 0.0;
  grim_mouse_state.lY = 0;
  grim_mouse_dy = 0.0;
  grim_mouse_state.lZ = 0;
  grim_mouse_dx = 0.0;
  *(_DWORD *)grim_mouse_state.rgbButtons = 0;
  *(_DWORD *)&grim_mouse_state.rgbButtons[4] = 0;
  if ( grim_mouse_device->lpVtbl->GetDeviceState(grim_mouse_device, 20, &grim_mouse_state) >= 0 )
  {
    while ( 1 )
    {
      result = v1++;
      grim_mouse_dx = (double)grim_mouse_state.lX + grim_mouse_dx;
      grim_mouse_dy = (double)grim_mouse_state.lY + grim_mouse_dy;
      flt_1005DB58 = (double)grim_mouse_state.lZ + flt_1005DB58;
      if ( result >= 100 )
        break;
      if ( !grim_mouse_state.lX && !grim_mouse_state.lY )
      {
        result = grim_mouse_state.lZ;
        if ( !grim_mouse_state.lZ )
          break;
      }
      grim_mouse_state.lX = 0;
      grim_mouse_state.lY = 0;
      grim_mouse_state.lZ = 0;
      *(_DWORD *)grim_mouse_state.rgbButtons = 0;
      *(_DWORD *)&grim_mouse_state.rgbButtons[4] = 0;
      if ( grim_mouse_device->lpVtbl->GetDeviceState(grim_mouse_device, 20, &grim_mouse_state) < 0 )
        goto LABEL_8;
    }
    if ( v1 > 2 )
      grim_noop();
    grim_mouse_x = grim_mouse_x + grim_mouse_dx;
    grim_mouse_y = grim_mouse_y + grim_mouse_dy;
    unk_1005DB4C = unk_1005DB4C + flt_1005DB58;
    goto LABEL_14;
  }
LABEL_8:
  result = grim_mouse_device->lpVtbl->Acquire(grim_mouse_device);
  if ( result != -2147024866 )
  {
LABEL_14:
    LOBYTE(result) = 1;
    return result;
  }
  do
    result = grim_mouse_device->lpVtbl->Acquire(grim_mouse_device);
  while ( result == -2147024866 );
  LOBYTE(result) = 1;
  return result;
}

// grim_mouse_shutdown @ 0x1000A7D0
// releases DirectInput mouse objects
void grim_mouse_shutdown()
{
  if ( grim_mouse_device )
  {
    grim_mouse_device->lpVtbl->Unacquire(grim_mouse_device);
    grim_mouse_device->lpVtbl->Release(grim_mouse_device);
    grim_mouse_device = 0;
  }
  if ( grim_dinput_mouse )
  {
    grim_dinput_mouse->lpVtbl->Release(grim_dinput_mouse);
    grim_dinput_mouse = 0;
  }
}

// sub_1000A820 @ 0x1000A820
bool __cdecl sub_1000A820(unsigned int a1)
{
  return a1 > 2;
}

// FUN_1000a840 @ 0x1000A840
// [binja] bool __stdcall sub_1000a840(int32_t* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
bool FUN_1000a840(int *arg1, uint arg2, int arg3, int arg4)
{
  uint v4; // esi
  void *v5; // eax
  unsigned int v6; // eax
  int v8; // [esp-8h] [ebp-Ch]

  v4 = arg2;
  v5 = operator new(arg2);
  v8 = arg4;
  *arg1 = (int)v5;
  arg2 = v4;
  v6 = sub_10046400((int)v5, (int *)&arg2, arg3, v8);
  return !sub_1000A820(v6);
}

// FUN_1000a880 @ 0x1000A880
// [binja] char* __stdcall sub_1000a880(char* arg1, uint32_t* arg2)
char *FUN_1000a880(char *arg1, uint *arg2)
{
  int v3; // esi
  uint v4; // [esp-14h] [ebp-14h]
  char *v5; // [esp-10h] [ebp-10h]

  if ( *arg1 != 1 )
    return 0;
  v3 = *(_DWORD *)(arg1 + 1);
  v5 = arg1 + 9;
  v4 = *(_DWORD *)(arg1 + 5);
  *arg2 = v4;
  arg1 = 0;
  FUN_1000a840((int *)&arg1, v4, (int)v5, v3);
  return arg1;
}

// grim_format_info_lookup @ 0x1000AAA6
// returns pointer to the D3D format descriptor entry (fallbacks to default)
int *grim_format_info_lookup(int format)
{
  int *result; // eax

  result = (int *)&unk_1004C3B0;
  if ( off_10053C50 <= &unk_1004C3B0 )
    return (int *)&unk_1004C388;
  while ( format != *result )
  {
    result += 9;
    if ( result >= (int *)off_10053C50 )
      return (int *)&unk_1004C388;
  }
  return result;
}

// FUN_1000aaca @ 0x1000AACA
// [binja] int32_t __fastcall sub_1000aaca(void* arg1, int32_t arg2)
int FUN_1000aaca(void *arg1, int arg2)
{
  int v2; // edx
  int v3; // ecx
  int result; // eax
  unsigned int *v5; // esi
  int v6; // edi
  int v7; // ebx
  unsigned int v8; // ecx
  unsigned int v9; // edx
  int v10; // [esp+4h] [ebp-4h]

  result = 0;
  if ( !dword_1004C9C0[5 * *(_DWORD *)(v3 + 4) + *(_DWORD *)(v2 + 4)] )
    return -1;
  v10 = 0;
  v5 = (unsigned int *)(v3 + 12);
  v6 = v2 - v3;
  v7 = 5;
  do
  {
    v8 = *v5;
    if ( *v5 )
      ++v10;
    v9 = *(unsigned int *)((char *)v5 + v6);
    if ( v8 >= v9 )
    {
      if ( v8 > v9 )
      {
        if ( v9 )
          result += (v8 - v9) << 16;
        else
          result += 0x1000000;
      }
    }
    else if ( v8 )
    {
      result += v9 - v8;
    }
    else
    {
      result += 256;
    }
    ++v5;
    --v7;
  }
  while ( v7 );
  if ( v10 == HIBYTE(result) )
    return -1;
  return result;
}

// sub_1000AB3F @ 0x1000AB3F
int __cdecl sub_1000AB3F(int *a1, int a2, int a3)
{
  int *v3; // eax
  unsigned int v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // esi
  unsigned int v7; // eax
  int v8; // eax

  v3 = a1;
  v4 = -1;
  v5 = &unk_1004C388;
  while ( 1 )
  {
    v8 = *v3;
    if ( !v8 )
      return *v5;
    v6 = grim_format_info_lookup(v8);
    if ( *v6 )
    {
      if ( v6[1] != 1 || a2 )
        break;
    }
LABEL_11:
    v3 = ++a1;
  }
  if ( *(_DWORD *)a3 != *v6 )
  {
    v7 = FUN_1000aaca(a3, (int)v6);
    if ( v7 != -1 && v7 <= v4 && (v7 != v4 || v6[2] < v5[2]) )
    {
      v4 = v7;
      v5 = v6;
    }
    goto LABEL_11;
  }
  return *(_DWORD *)a3;
}

// sub_1000ABAD @ 0x1000ABAD
int __cdecl sub_1000ABAD(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // esi
  unsigned int v7; // eax
  void *v9; // [esp+0h] [ebp-F4h]
  int v10; // [esp+4h] [ebp-F0h]
  _DWORD v11[53]; // [esp+Ch] [ebp-E8h] BYREF
  _BYTE v12[12]; // [esp+E0h] [ebp-14h] BYREF
  int v13; // [esp+ECh] [ebp-8h]
  int v14; // [esp+F0h] [ebp-4h] BYREF

  v14 = 0;
  grim_d3d_debug_set_mute(1);
  if ( a1 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)a1 + 24))(a1, &v14);
    (*(void (__stdcall **)(int, _DWORD *))(*(_DWORD *)a1 + 28))(a1, v11);
    (*(void (__stdcall **)(int, _BYTE *))(*(_DWORD *)a1 + 32))(a1, v12);
  }
  v4 = -1;
  v5 = &unk_1004C388;
  v6 = &unk_1004C3B0;
  if ( off_10053C50 > &unk_1004C3B0 )
  {
    do
    {
      if ( *v6
        && (!a1
         || (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD))(*(_DWORD *)v14 + 40))(
              v14,
              v11[1],
              v11[0],
              v13,
              a2,
              a3,
              *v6) >= 0) )
      {
        if ( *a4 == *v6 )
        {
          v5 = v6;
          break;
        }
        if ( v6[8] )
        {
          v7 = FUN_1000aaca(v9, v10);
          if ( v7 != -1 && v7 <= v4 && (v7 != v4 || v6[2] < v5[2]) )
          {
            v4 = v7;
            v5 = v6;
          }
        }
      }
      v6 += 9;
    }
    while ( v6 < (_DWORD *)off_10053C50 );
  }
  if ( v14 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v14 + 8))(v14);
    v14 = 0;
  }
  grim_d3d_debug_set_mute(0);
  return *v5;
}

// sub_1000AC8F @ 0x1000AC8F
int __cdecl sub_1000AC8F(int a1)
{
  switch ( a1 )
  {
    case 909200416:
      return 50;
    case 909200449:
      return 51;
    case 909201952:
      return 20;
    case 909201985:
      return 21;
  }
  return a1;
}

// FUN_1000acc0 @ 0x1000ACC0
// [binja] int32_t __stdcall sub_1000acc0(int32_t* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t* arg8, int32_t arg9, int32_t arg10)
int FUN_1000acc0(
        int *arg1,
        int arg2,
        int *arg3,
        int arg4,
        int arg5,
        int arg6,
        int arg7,
        int *arg8,
        int arg9,
        int arg10)
{
  int v10; // edi
  int v11; // esi
  int v12; // ebx
  int v13; // eax
  int *v15; // [esp+0h] [ebp-68h]
  int *v16; // [esp+0h] [ebp-68h]
  char *v17; // [esp+0h] [ebp-68h]
  int *v18; // [esp+0h] [ebp-68h]
  char v19[76]; // [esp+4h] [ebp-64h] BYREF
  void **v20[4]; // [esp+50h] [ebp-18h] BYREF
  _DWORD v21[6]; // [esp+60h] [ebp-8h] BYREF
  _BYTE v22[24]; // [esp+78h] [ebp+10h] BYREF
  int v23; // [esp+94h] [ebp+2Ch]
  int v24; // [esp+98h] [ebp+30h]

  FUN_1001284c(v15);
  FUN_10016121(v16);
  v12 = 0;
  if ( arg1 )
  {
    if ( arg4 && arg8 )
    {
      if ( arg9 == -1 )
        arg9 = 524292;
      v13 = FUN_100161bb(v19, arg1, (int *)arg2, (int)arg3, 0, 0, v11);
      if ( v13 < 0 )
        goto LABEL_10;
      v20[1] = (void **)arg5;
      v20[0] = (void **)arg4;
      v20[2] = (void **)arg6;
      v20[3] = 0;
      v21[0] = *arg8;
      v21[1] = arg8[1];
      v21[2] = arg8[2];
      v21[3] = arg8[3];
      v21[4] = 0;
      v21[5] = 1;
      qmemcpy(v22, v21, sizeof(v22));
      v23 = arg10;
      v24 = arg7;
      v13 = FUN_10016007((int *)v19, v20, (void ***)arg9, v10);
      if ( v13 < 0 )
LABEL_10:
        v12 = v13;
    }
    else
    {
      v12 = -2005530516;
    }
  }
  else
  {
    v12 = -2005530516;
  }
  FUN_100161b6(v17);
  FUN_10012856(v18);
  return v12;
}

// FUN_1000ad9f @ 0x1000AD9F
// [binja] int32_t sub_1000ad9f(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t* arg6)
int FUN_1000ad9f(int arg1, int arg2, int *arg3, int arg4, int *arg5, int *arg6)
{
  int v6; // esi
  int v7; // eax
  int *v9; // [esp+0h] [ebp-C4h]
  int *v10; // [esp+0h] [ebp-C4h]
  int *v11; // [esp+0h] [ebp-C4h]
  void *v12; // [esp+0h] [ebp-C4h]
  int arg1a[19]; // [esp+8h] [ebp-BCh] BYREF
  int v14; // [esp+C0h] [ebp-4h]

  FUN_10010285(v9);
  v14 = 1;
  FUN_10016121(v10);
  if ( arg1 && arg3 )
  {
    v7 = FUN_100161bb((char *)arg1a, arg3, (int *)arg4, (int)arg5, 0, 1, (int)v11);
    if ( v7 < 0
      || (v7 = FUN_10010313(arg1a, v11), v7 < 0)
      || (v7 = FUN_1001237e((int *)arg1, arg2, (int)arg6, v11), v7 < 0) )
    {
      v6 = v7;
    }
    else
    {
      v6 = 0;
    }
  }
  else
  {
    v6 = -2005530516;
  }
  LOBYTE(v14) = 0;
  FUN_100161b6((char *)v11);
  v14 = -1;
  FUN_1001029e(v12);
  return v6;
}

// sub_1000AE4F @ 0x1000AE4F
void *__thiscall sub_1000AE4F(void *this)
{
  return this;
}

// FUN_1000ae52 @ 0x1000AE52
// [binja] int32_t __stdcall sub_1000ae52(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5)
int FUN_1000ae52(int arg1, int arg2, int *arg3, int arg4, int *arg5)
{
  return FUN_1000ad9f(arg1, arg2, arg3, arg4, arg5, 0);
}

// FUN_1000ae72 @ 0x1000AE72
// [binja] int32_t __stdcall sub_1000ae72(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11)
int FUN_1000ae72(
        int *arg1,
        int arg2,
        int arg3,
        int arg4,
        int arg5,
        int arg6,
        int arg7,
        int arg8,
        int arg9,
        int arg10,
        int arg11)
{
  int v11; // edi
  int v12; // esi
  int v13; // eax
  int *v15; // [esp+0h] [ebp-60h]
  int *v16; // [esp+0h] [ebp-60h]
  int *v17; // [esp+0h] [ebp-60h]
  int v18[19]; // [esp+4h] [ebp-5Ch] BYREF
  void **v19[4]; // [esp+50h] [ebp-10h] BYREF
  _BYTE v20[24]; // [esp+60h] [ebp+0h] BYREF
  _BYTE v21[24]; // [esp+78h] [ebp+18h] BYREF
  int v22; // [esp+94h] [ebp+34h]
  int v23; // [esp+98h] [ebp+38h]
  _BYTE v24[4]; // [esp+A8h] [ebp+48h] BYREF

  FUN_1001284c(v15);
  FUN_1001619a(v16);
  if ( arg1 && arg4 && arg9 )
  {
    if ( arg10 == -1 )
      arg10 = 524292;
    v13 = FUN_100165d3(v18, arg1, (int *)arg2, arg3, 0, 0, (int)v17);
    if ( v13 < 0 )
      goto LABEL_8;
    v19[1] = (void **)arg5;
    v19[2] = (void **)arg6;
    v19[0] = (void **)arg4;
    v19[3] = (void **)arg7;
    qmemcpy(v20, (const void *)arg9, sizeof(v20));
    qmemcpy(v21, (const void *)arg9, sizeof(v21));
    v22 = arg11;
    v23 = arg8;
    v13 = FUN_10016007(v18, v19, (void ***)arg10, v11);
    if ( v13 < 0 )
LABEL_8:
      v12 = v13;
    else
      v12 = 0;
  }
  else
  {
    v12 = -2005530516;
  }
  j_FUN_100161a0(v24);
  FUN_10012856(v17);
  return v12;
}

// sub_1000AF45 @ 0x1000AF45
int __usercall sub_1000AF45@<eax>(
        int a1@<edx>,
        int a2,
        unsigned int *a3,
        unsigned int *a4,
        unsigned int *a5,
        unsigned int *a6,
        int *a7,
        unsigned int a8,
        int a9)
{
  int v10; // esi
  _DWORD *v12; // eax
  unsigned int v13; // ebx
  unsigned int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  bool v18; // cc
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // edx
  int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // eax
  unsigned int v25; // esi
  unsigned int v26; // ecx
  unsigned int i; // eax
  unsigned int v28; // eax
  unsigned int j; // edx
  unsigned int v30; // eax
  char v31[60]; // [esp+Ch] [ebp-DCh] BYREF
  int v32; // [esp+48h] [ebp-A0h]
  unsigned int v33; // [esp+64h] [ebp-84h]
  unsigned int v34; // [esp+68h] [ebp-80h]
  unsigned int v35; // [esp+6Ch] [ebp-7Ch]
  int v36; // [esp+74h] [ebp-74h]
  int v37; // [esp+E0h] [ebp-8h]
  unsigned int v38; // [esp+E4h] [ebp-4h]
  unsigned int v39; // [esp+F0h] [ebp+8h]

  v10 = a1;
  if ( !a2 )
    return -2005530516;
  if ( a1 == -1 )
    v10 = 0;
  if ( v10 != (v10 & 0x20B) || a8 >= 4 )
    return -2005530516;
  if ( a7 )
    v37 = *a7;
  else
    v37 = 0;
  if ( a8 == 3 )
  {
    if ( !v37 )
      v37 = 21;
  }
  else
  {
    v12 = grim_format_info_lookup(v37);
    v37 = sub_1000ABAD(a2, v10, a9, v12);
    if ( !v37 )
      return -2005530518;
  }
  if ( a3 )
    v39 = *a3;
  else
    v39 = -1;
  if ( a4 )
    v13 = *a4;
  else
    v13 = -1;
  if ( a5 )
    v38 = *a5;
  else
    v38 = -1;
  if ( v39 == -1 )
  {
    if ( v13 == -1 )
    {
      v13 = 256;
      v39 = 256;
      goto LABEL_34;
    }
    v39 = v13;
  }
  else if ( v13 == -1 )
  {
    v13 = v39;
  }
  if ( !v39 )
    v39 = 1;
  if ( !v13 )
    v13 = 1;
LABEL_34:
  if ( a9 == 5 )
  {
    if ( v39 > v13 )
      v13 = v39;
    v39 = v13;
  }
  if ( v38 == -1 || !v38 )
    v38 = 1;
  if ( a8 == 3 )
    goto LABEL_75;
  (*(void (__stdcall **)(int, char *))(*(_DWORD *)a2 + 28))(a2, v31);
  if ( a9 == 4 )
  {
    v14 = v35;
    if ( v38 > v35 )
      v38 = v35;
    if ( v39 > v35 )
      v39 = v35;
  }
  else
  {
    if ( v39 > v33 )
      v39 = v33;
    if ( v13 > v34 )
      v13 = v34;
    if ( a9 != 3 )
      goto LABEL_61;
    v15 = (v32 & 0x20) != 0 ? 1 : v36;
    if ( !v15 )
      goto LABEL_61;
    if ( v39 > v13 * v15 )
      v39 = v13 * v15;
    v14 = v39 * v15;
  }
  if ( v13 > v14 )
    v13 = v14;
LABEL_61:
  switch ( a9 )
  {
    case 3:
      v16 = 2;
      break;
    case 4:
      v16 = 0x40000;
      break;
    case 5:
      v16 = 0x20000;
      break;
    default:
      v16 = v39;
      break;
  }
  if ( (v16 & v32) != 0 )
  {
    v17 = v39;
    v18 = v39 <= 1;
    v39 = 1;
    if ( !v18 )
    {
      do
        v39 *= 2;
      while ( v39 < v17 );
    }
    v19 = v13;
    v18 = v13 <= 1;
    v13 = 1;
    if ( !v18 )
    {
      do
        v13 *= 2;
      while ( v13 < v19 );
    }
    v20 = v38;
    v18 = v38 <= 1;
    v38 = 1;
    if ( !v18 )
    {
      do
        v38 *= 2;
      while ( v38 < v20 );
    }
  }
LABEL_75:
  if ( v37 == 827611204 || v37 == 844388420 || v37 == 861165636 || v37 == 877942852 || v37 == 894720068 )
  {
    v21 = (v39 + 3) & 0xFFFFFFFC;
    v39 = v21;
    v13 = (v13 + 3) & 0xFFFFFFFC;
  }
  else
  {
    v21 = v39;
  }
  switch ( a9 )
  {
    case 3:
      v22 = 0x4000;
      break;
    case 4:
      v22 = 0x8000;
      break;
    case 5:
      v22 = 0x10000;
      break;
    default:
      v22 = v39;
      break;
  }
  if ( a6 )
    v23 = *a6;
  else
    v23 = -1;
  if ( a8 != 3
    && ((v22 & v32) == 0
     || (v32 & 0x100) != 0 && (((v21 - 1) & v21) != 0 || ((v13 - 1) & v13) != 0 || ((v38 - 1) & v38) != 0)) )
  {
    v23 = 1;
  }
  else
  {
    v24 = v39;
    v25 = 0;
    while ( v24 )
    {
      v24 >>= 1;
      ++v25;
    }
    v26 = 0;
    for ( i = v13; i; ++v26 )
      i >>= 1;
    v28 = v38;
    for ( j = 0; v28; ++j )
      v28 >>= 1;
    v30 = v25;
    if ( v25 <= v26 )
      v30 = v26;
    if ( a9 == 4 && j > v30 )
      v30 = j;
    if ( v23 > v30 || !v23 )
      v23 = v30;
  }
  if ( a3 )
    *a3 = v39;
  if ( a4 )
    *a4 = v13;
  if ( a5 )
    *a5 = v38;
  if ( a6 )
    *a6 = v23;
  if ( a7 )
    *a7 = v37;
  return 0;
}

// FUN_1000b26f @ 0x1000B26F
// [binja] int32_t __stdcall sub_1000b26f(int32_t** arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, int32_t arg5, int32_t arg6, int32_t arg7)
int FUN_1000b26f(int **arg1, int *arg2, int *arg3, int *arg4, int arg5, int arg6, int arg7)
{
  return sub_1000AF45(
           arg5,
           (int)arg1,
           (unsigned int *)arg2,
           (unsigned int *)arg3,
           0,
           (unsigned int *)arg4,
           (int *)arg6,
           arg7,
           3);
}

// FUN_1000b297 @ 0x1000B297
// [binja] int32_t __stdcall sub_1000b297(int32_t** arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int FUN_1000b297(int **arg1, int arg2, int arg3, int arg4)
{
  int result; // eax
  int v5; // edi
  int arg5; // [esp+1Ch] [ebp+18h]
  int arg6; // [esp+20h] [ebp+1Ch] BYREF
  int arg7; // [esp+24h] [ebp+20h]
  int v9; // [esp+28h] [ebp+24h]

  if ( !arg1 || !v9 )
    return -2005530516;
  v5 = arg5;
  if ( arg5 == -1 )
    v5 = 0;
  result = FUN_1000b26f(arg1, &arg2, &arg3, &arg4, v5, (int)&arg6, arg7);
  if ( result >= 0 )
  {
    result = ((int (__stdcall *)(int **, int, int, int, int, int, int, int))(*arg1)[20])(
               arg1,
               arg2,
               arg3,
               arg4,
               v5,
               arg6,
               arg7,
               v9);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// sub_1000B2FD @ 0x1000B2FD
char *__thiscall sub_1000B2FD(char *this, char a2)
{
  char *v4; // [esp+0h] [ebp-8h]

  if ( (a2 & 2) != 0 )
  {
    FUN_1004b5cf((int)this, 16, *((_DWORD *)this - 1), (int)FUN_100161b6);
    if ( (a2 & 1) != 0 )
      operator delete(this - 4);
    return this - 4;
  }
  else
  {
    FUN_100161b6(v4);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

// sub_1000B348 @ 0x1000B348
char *__thiscall sub_1000B348(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    FUN_1004b5cf((int)this, 4, *((_DWORD *)this - 1), (int)j_FUN_100161a0);
    if ( (a2 & 1) != 0 )
      operator delete(this - 4);
    return this - 4;
  }
  else
  {
    j_FUN_100161a0(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

// sub_1000B393 @ 0x1000B393
int __stdcall sub_1000B393(int a1, int a2, int a3, int (__thiscall *a4)(int))
{
  int result; // eax
  int v6; // edi

  result = a3 - 1;
  if ( a3 - 1 >= 0 )
  {
    v6 = a3;
    do
    {
      result = a4(a1);
      a1 += a2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

// sub_1000B3B5 @ 0x1000B3B5
double __usercall sub_1000B3B5@<st0>(float *a1@<eax>, int a2@<ecx>)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx

  v2 = a2 - 1;
  if ( !v2 )
    return *a1;
  v3 = v2 - 1;
  if ( !v3 )
    return a1[2];
  v4 = v3 - 2;
  if ( !v4 )
    return a1[1];
  v5 = v4 - 4;
  if ( !v5 )
    return a1[3];
  if ( v5 == 8 )
    return a1[2] * 0.072099999 + a1[1] * 0.71539998 + *a1 * 0.21250001;
  return 0.0;
}

// FUN_1000b3fe @ 0x1000B3FE
// [binja] int32_t __stdcall sub_1000b3fe(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, float arg5)
int FUN_1000b3fe(int *arg1, int *arg2, int arg3, int arg4, float arg5)
{
  int v5; // esi
  int v6; // ebx
  unsigned int v7; // eax
  int *v8; // esi
  int *v9; // eax
  unsigned int v10; // esi
  int v11; // esi
  int v12; // eax
  int v13; // edi
  void *v14; // eax
  void *v15; // ebx
  int v16; // edi
  void *v17; // eax
  void *v18; // ebx
  int v19; // edi
  void *v20; // eax
  void *v21; // ebx
  int v22; // edi
  void *v23; // eax
  void *v24; // ebx
  void *v25; // eax
  int v26; // eax
  int v27; // eax
  int *v28; // ebx
  void (__thiscall ***v29)(_DWORD, int); // eax
  void (__thiscall ***v30)(_DWORD, int); // edi
  float *v31; // edi
  int v32; // eax
  float *v33; // ebx
  double v34; // st7
  float *v35; // edi
  double v36; // st7
  double v37; // st7
  int v38; // edx
  double v39; // st7
  float *v40; // esi
  char *v41; // edi
  char *v42; // edx
  float *v43; // esi
  double v44; // st7
  double v45; // st7
  int v46; // ebx
  int v47; // edx
  int v48; // edi
  double v49; // st7
  float *v50; // edx
  double v51; // st7
  int v52; // ecx
  double v53; // st6
  float *v54; // eax
  double v55; // st6
  int v56; // ecx
  double v57; // st7
  int v58; // eax
  float *v59; // ecx
  int v60; // esi
  int v61; // esi
  double v62; // st7
  double v63; // st6
  int i; // edx
  float *v65; // ecx
  double v66; // st5
  double v67; // st5
  double v68; // st7
  long double v69; // st6
  double v70; // st6
  float *v71; // eax
  float v72; // ecx
  double v73; // st6
  void *v74; // eax
  void *v75; // ecx
  int v77; // [esp-4h] [ebp-148h]
  int v78; // [esp-4h] [ebp-148h]
  int v79; // [esp-4h] [ebp-148h]
  int *v80; // [esp+0h] [ebp-144h]
  int *v81; // [esp+0h] [ebp-144h]
  char *v82; // [esp+0h] [ebp-144h]
  char *v83; // [esp+0h] [ebp-144h]
  uint v84[19]; // [esp+8h] [ebp-13Ch] BYREF
  uint desc[19]; // [esp+54h] [ebp-F0h] BYREF
  int v86[8]; // [esp+A0h] [ebp-A4h] BYREF
  char v87[24]; // [esp+E0h] [ebp-64h] BYREF
  int v88; // [esp+F8h] [ebp-4Ch]
  _DWORD v89[8]; // [esp+100h] [ebp-44h] BYREF
  float v90; // [esp+120h] [ebp-24h]
  float v91; // [esp+124h] [ebp-20h]
  float v92; // [esp+128h] [ebp-1Ch]
  int v93; // [esp+12Ch] [ebp-18h]
  int v94; // [esp+130h] [ebp-14h]
  int v95; // [esp+134h] [ebp-10h]
  int format[6]; // [esp+138h] [ebp-Ch] BYREF
  int v97; // [esp+150h] [ebp+Ch]
  int v98; // [esp+154h] [ebp+10h]
  float v99; // [esp+158h] [ebp+14h] BYREF
  float v100; // [esp+15Ch] [ebp+18h]
  float v101; // [esp+160h] [ebp+1Ch]
  unsigned int v102; // [esp+164h] [ebp+20h]
  void *v103; // [esp+168h] [ebp+24h]
  void *v104; // [esp+16Ch] [ebp+28h]
  void *v105; // [esp+170h] [ebp+2Ch]
  float v106; // [esp+174h] [ebp+30h]
  int *v107; // [esp+178h] [ebp+34h]
  void *v108; // [esp+17Ch] [ebp+38h]
  void *v109; // [esp+180h] [ebp+3Ch]
  void *v110; // [esp+184h] [ebp+40h]
  void *v111; // [esp+188h] [ebp+44h]
  int *v112; // [esp+18Ch] [ebp+48h] BYREF
  int *v113; // [esp+190h] [ebp+4Ch] BYREF
  float v114; // [esp+194h] [ebp+50h]
  int v115; // [esp+198h] [ebp+54h]
  void *v116; // [esp+19Ch] [ebp+58h]
  int v117; // [esp+1A0h] [ebp+5Ch]
  float v118; // [esp+1C0h] [ebp+7Ch]

  v107 = 0;
  v105 = 0;
  v113 = 0;
  v112 = 0;
  FUN_10016121(v80);
  FUN_10016121(v81);
  if ( arg1 )
  {
    v77 = v5;
    if ( !arg2 )
      goto LABEL_118;
    if ( arg4 == -1 )
      arg4 = 0;
    if ( (arg4 & 0xFFE4FFFF) != 0 )
      goto LABEL_118;
    v7 = LODWORD(arg5);
    if ( arg5 == NAN )
    {
      v7 = 1;
      LODWORD(arg5) = 1;
    }
    if ( !v7 || v7 > 2 && v7 != 4 && v7 != 8 && v7 != 16 )
      goto LABEL_118;
    if ( (*(int (__stdcall **)(int *, _DWORD, int *))(*arg1 + 56))(arg1, 0, v86) < 0
      || (*(int (__stdcall **)(int *, _DWORD, int *))(*arg2 + 56))(arg2, 0, format) < 0 )
    {
      v6 = -2147467259;
      goto LABEL_119;
    }
    if ( (v8 = grim_format_info_lookup(format[0]), v9 = grim_format_info_lookup(v86[0]), !*v8)
      || !*v9
      || (v10 = v8[1], v10 > 2) && v10 != 4
      || v9[1]
      || (unsigned int)v9[5] < 2
      || (unsigned int)v9[6] < 2
      || (unsigned int)v9[7] < 2
      || v97 != v86[6]
      || v98 != v86[7]
      || (v11 = (*(int (__stdcall **)(int *))(*arg2 + 52))(arg2),
          v102 = (*(int (__stdcall **)(int *))(*arg1 + 52))(arg1),
          v11 != v102) )
    {
LABEL_118:
      v6 = -2005530516;
      goto LABEL_119;
    }
    v12 = (*(int (__stdcall **)(int *, _DWORD, char *))(*arg1 + 56))(arg1, 0, v87);
    if ( v12 >= 0 )
    {
      v13 = v88;
      v14 = operator new(16 * v88);
      v15 = v14;
      if ( v14 )
      {
        sub_1000B393((int)v14, 16, v13, (int (__thiscall *)(int))sub_1000AE4F);
        v109 = v15;
      }
      else
      {
        v109 = 0;
      }
      v16 = v88;
      v17 = operator new(16 * v88);
      v18 = v17;
      if ( v17 )
      {
        sub_1000B393((int)v17, 16, v16, (int (__thiscall *)(int))sub_1000AE4F);
        v104 = v18;
      }
      else
      {
        v104 = 0;
      }
      v19 = v88;
      v20 = operator new(16 * v88);
      v21 = v20;
      if ( v20 )
      {
        sub_1000B393((int)v20, 16, v19, (int (__thiscall *)(int))sub_1000AE4F);
        v103 = v21;
      }
      else
      {
        v103 = 0;
      }
      v22 = v88;
      v23 = operator new(16 * v88);
      v24 = v23;
      if ( v23 )
      {
        sub_1000B393((int)v23, 16, v22, (int (__thiscall *)(int))sub_1000AE4F);
        v108 = v24;
        v6 = 0;
      }
      else
      {
        v6 = 0;
        v108 = 0;
      }
      v111 = operator new(4 * v88 + 8);
      v116 = operator new(4 * v88 + 8);
      v25 = operator new(4 * v88 + 8);
      v110 = v25;
      if ( v104 && v103 && v108 && v109 && v111 && v116 && v25 )
      {
        v115 = 0;
        if ( v102 )
        {
          while ( 1 )
          {
            (*(void (__stdcall **)(int *, int, int **))(*arg1 + 60))(arg1, v115, &v112);
            (*(void (__stdcall **)(int *, int, int **))(*arg2 + 60))(arg2, v115, &v113);
            v26 = v115
                ? FUN_100161bb((char *)v84, v112, 0, 0, 0, 0, v77)
                : FUN_100161bb((char *)v84, v112, 0, 0, 0, 0x20000, v77);
            v6 = v26;
            if ( v26 < 0 )
              break;
            v27 = arg1 == arg2
                ? FUN_100161bb((char *)desc, v113, 0, 0, 0, 65537, v78)
                : FUN_100161bb((char *)desc, v113, 0, 0, 0, 1, v78);
            v6 = v27;
            if ( v27 < 0 )
              break;
            v6 = (*(int (__stdcall **)(int *, int, int *))(*arg1 + 56))(arg1, v115, v86);
            if ( v6 < 0 )
              break;
            v6 = (*(int (__stdcall **)(int *, int, int *))(*arg2 + 56))(arg2, v115, format);
            if ( v6 < 0 )
              break;
            v28 = (int *)grim_pixel_format_create(desc);
            v107 = v28;
            v29 = (void (__thiscall ***)(_DWORD, int))grim_pixel_format_create(v84);
            v30 = v29;
            v105 = v29;
            if ( !v28 || !v29 )
            {
              v6 = -2147467259;
              goto LABEL_109;
            }
            v31 = (float *)v109;
            (*(void (__thiscall **)(int *, int, _DWORD, void *, int))(*v28 + 4))(v28, v98 - 1, 0, v109, v79);
            v32 = *v28;
            v33 = (float *)v104;
            (*(void (__thiscall **)(int *, _DWORD, _DWORD, void *))(v32 + 4))(v107, 0, 0, v104);
            v34 = sub_1000B3B5(&v31[4 * v97 - 4], SLODWORD(arg5));
            v35 = (float *)v111;
            *(float *)v111 = v34;
            v36 = sub_1000B3B5(&v33[4 * v97 - 4], SLODWORD(arg5));
            *(float *)v116 = v36;
            v37 = sub_1000B3B5((float *)v109, SLODWORD(arg5));
            v35[v97 + 1] = v37;
            v39 = sub_1000B3B5(v33, SLODWORD(arg5));
            *(float *)(v38 + 4 * v97 + 4) = v39;
            v117 = 0;
            if ( v97 > 0 )
            {
              v40 = (float *)(v38 + 4);
              v41 = (char *)v35 - v38;
              v42 = (char *)((_BYTE *)v109 - (_BYTE *)v33);
              do
              {
                *(float *)((char *)v40 + (_DWORD)v41) = sub_1000B3B5(
                                                          (float *)((char *)v33 + (_DWORD)v42),
                                                          SLODWORD(arg5));
                *v40 = sub_1000B3B5(v33, SLODWORD(arg5));
                ++v117;
                v33 += 4;
                ++v40;
              }
              while ( v117 < v97 );
            }
            v117 = 0;
            if ( v98 > 0 )
            {
              do
              {
                v94 = v117 + 1;
                v43 = (float *)v103;
                (*(void (__thiscall **)(int *, unsigned int, _DWORD, void *))(*v107 + 4))(
                  v107,
                  (v117 + 1) % (unsigned int)v98,
                  0,
                  v103);
                v44 = sub_1000B3B5(&v43[4 * v97 - 4], SLODWORD(arg5));
                *(float *)v110 = v44;
                v45 = sub_1000B3B5(v43, SLODWORD(arg5));
                v46 = 0;
                *(float *)(v47 + 4 * v97 + 4) = v45;
                v48 = 0;
                if ( v97 > 0 )
                {
                  do
                  {
                    v49 = sub_1000B3B5(v43, SLODWORD(arg5));
                    *v50 = v49;
                    ++v48;
                    v43 += 4;
                  }
                  while ( v48 < v97 );
                  if ( v97 > 0 )
                  {
                    v92 = 1.0;
                    v51 = 0.5;
                    v95 = arg4 & 0x100000;
                    v93 = arg4 & 0x80000;
                    do
                    {
                      v52 = 0;
                      v53 = 0.0;
                      if ( !v46 && (arg4 & 0x10000) != 0 )
                      {
                        v54 = (float *)v116;
                      }
                      else
                      {
                        v54 = (float *)v116;
                        v53 = *((float *)v116 + v46 + 1) + *((float *)v116 + v46);
                        v52 = 1;
                      }
                      if ( v46 < v97 - 1 || (arg4 & 0x10000) == 0 )
                      {
                        ++v52;
                        v53 = v53 - (v54[v46 + 2] + v54[v46 + 1]);
                      }
                      v55 = v53 * v118;
                      if ( v52 != 1 )
                        v55 = v55 * v51;
                      v114 = v55;
                      v56 = 0;
                      v106 = 0.0;
                      if ( v117 || (arg4 & 0x20000) == 0 )
                      {
                        v56 = 1;
                        v106 = v54[v46 + 1] + *((float *)v111 + v46 + 1);
                      }
                      if ( v117 < v98 - 1 || (arg4 & 0x20000) == 0 )
                      {
                        ++v56;
                        v106 = v106 - (*((float *)v110 + v46 + 1) + v54[v46 + 1]);
                      }
                      if ( v56 == 1 )
                        v57 = v106 * v118;
                      else
                        v57 = v51 * (v106 * v118);
                      v90 = 0.0 * v57 - v114 * -1.0;
                      v91 = v114 * 0.0 - v57 * -1.0;
                      v99 = v90;
                      v100 = v91;
                      v101 = v92;
                      sub_1000CE76(&v99, &v99);
                      v114 = 1.0;
                      if ( v95 )
                      {
                        v89[0] = *((_DWORD *)v111 + v46);
                        v89[1] = *((_DWORD *)v111 + v46 + 1);
                        v58 = 4 * v46 + 8;
                        v59 = (float *)((char *)v116 + 4 * v46);
                        v60 = *(_DWORD *)v59;
                        *(float *)&v89[2] = *(float *)((char *)v111 + v58);
                        *(float *)&v89[4] = *(float *)((char *)v116 + v58);
                        v89[3] = v60;
                        v61 = *((_DWORD *)v110 + v46);
                        *(float *)&v89[7] = *(float *)((char *)v110 + v58);
                        v89[5] = v61;
                        v62 = 0.0;
                        v63 = v59[1];
                        v89[6] = *((_DWORD *)v110 + v46 + 1);
                        for ( i = 0; i < 8; ++i )
                        {
                          v65 = (float *)&v89[i];
                          v66 = *v65 - v63;
                          *v65 = v66;
                          if ( v66 < 0.0 )
                            *v65 = 0.0;
                          v67 = v62 + *v65;
                          v62 = v67;
                        }
                        v68 = v67 * v118 * 0.125;
                        if ( v68 > 0.0 )
                        {
                          v69 = sqrt(v68 * v68 + 1.0);
                          v114 = (v69 - v68) / v69;
                        }
                      }
                      v51 = 0.5;
                      v70 = v99;
                      v71 = (float *)((char *)v108 + 16 * v46);
                      v72 = v114;
                      if ( v93 )
                      {
                        *v71 = 0.5 - v70 * 0.5;
                        v71[1] = 0.5 - v100 * 0.5;
                        v73 = 0.5 - v101 * 0.5;
                      }
                      else
                      {
                        *v71 = (v70 + 1.0) * 0.5;
                        v71[1] = (v100 + 1.0) * 0.5;
                        v73 = (v101 + 1.0) * 0.5;
                      }
                      ++v46;
                      v71[2] = v73;
                      v71[3] = v72;
                    }
                    while ( v46 < v97 );
                  }
                }
                (*(void (__thiscall **)(void *, int, _DWORD, void *))(*(_DWORD *)v105 + 8))(v105, v117, 0, v108);
                v74 = v111;
                v111 = v116;
                v75 = v110;
                v110 = v74;
                v116 = v75;
                v117 = v94;
              }
              while ( v94 < v98 );
            }
            v77 = 1;
            (*(void (__thiscall **)(int *))*v107)(v107);
            (**(void (__thiscall ***)(void *, int))v105)(v105, 1);
            if ( v113 )
            {
              (*(void (__stdcall **)(int *))(*v113 + 8))(v113);
              v113 = 0;
            }
            if ( v112 )
            {
              (*(void (__stdcall **)(int *))(*v112 + 8))(v112);
              v112 = 0;
            }
            if ( ++v115 >= v102 )
            {
              v6 = 0;
              break;
            }
          }
        }
      }
      else
      {
        v30 = (void (__thiscall ***)(_DWORD, int))v105;
        v6 = -2147024882;
LABEL_109:
        if ( v107 )
          (*(void (__thiscall **)(int *, int))*v107)(v107, 1);
        if ( v30 )
          (**v30)(v30, 1);
      }
      if ( v113 )
      {
        (*(void (__stdcall **)(int *))(*v113 + 8))(v113);
        v113 = 0;
      }
      if ( v112 )
      {
        (*(void (__stdcall **)(int *))(*v112 + 8))(v112);
        v112 = 0;
      }
      operator delete(v109);
      operator delete(v104);
      operator delete(v103);
      operator delete(v108);
      operator delete(v111);
      operator delete(v116);
      operator delete(v110);
    }
    else
    {
      v6 = v12;
    }
  }
  else
  {
    v6 = -2005530516;
  }
LABEL_119:
  FUN_100161b6(v82);
  FUN_100161b6(v83);
  return v6;
}

// FUN_1000bbfc @ 0x1000BBFC
// [binja] int32_t __stdcall sub_1000bbfc(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5, int32_t arg6, int32_t arg7)
int FUN_1000bbfc(int *arg1, int *arg2, int *arg3, int *arg4, int *arg5, int arg6, int arg7)
{
  int v7; // edi
  int v8; // esi
  int *v9; // ebx
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // eax
  int v17; // [esp-8h] [ebp-50h]
  int *v18; // [esp+0h] [ebp-48h]
  char *v19; // [esp+0h] [ebp-48h]
  char v20[4]; // [esp+4h] [ebp-44h] BYREF
  int v21; // [esp+8h] [ebp-40h]
  int v22; // [esp+Ch] [ebp-3Ch]
  int arg8[9]; // [esp+2Ch] [ebp-1Ch] BYREF
  _BYTE v24[24]; // [esp+50h] [ebp+8h] BYREF
  int v25; // [esp+68h] [ebp+20h]
  int v26; // [esp+6Ch] [ebp+24h]
  int v27; // [esp+80h] [ebp+38h] BYREF
  int v28; // [esp+84h] [ebp+3Ch]
  int v29; // [esp+88h] [ebp+40h]
  int v30; // [esp+8Ch] [ebp+44h]
  int v31; // [esp+90h] [ebp+48h] BYREF
  int v32; // [esp+94h] [ebp+4Ch]
  int v33; // [esp+98h] [ebp+50h]
  int v34; // [esp+9Ch] [ebp+54h]
  int arg10; // [esp+C4h] [ebp+7Ch]

  FUN_10016121(v18);
  if ( arg1 )
  {
    v9 = arg4;
    v17 = v7;
    if ( arg4 )
    {
      if ( (unsigned __int16)arg7 != 5 && !arg10 && (arg2 == arg5 || arg2 && arg5 && !memcmp(arg2, arg5, 0x400u)) )
      {
        if ( arg3 )
        {
          v31 = *arg3;
          v32 = arg3[1];
          v33 = arg3[2];
          v34 = arg3[3];
          v10 = v33;
        }
        else
        {
          (*(void (__stdcall **)(int *, _BYTE *))(*arg1 + 32))(arg1, v24);
          v10 = v25;
          v31 = 0;
          v32 = 0;
          v33 = v25;
          v34 = v26;
        }
        if ( arg6 )
        {
          v27 = *(_DWORD *)arg6;
          v28 = *(_DWORD *)(arg6 + 4);
          v29 = *(_DWORD *)(arg6 + 8);
          v30 = *(_DWORD *)(arg6 + 12);
          v11 = v30;
          v12 = v29;
        }
        else
        {
          (*(void (__stdcall **)(int *, _BYTE *))(*v9 + 32))(v9, v24);
          v12 = v25;
          v11 = v26;
          v27 = 0;
          v28 = 0;
          v10 = v33;
          v29 = v25;
          v30 = v26;
        }
        if ( v10 - v31 == v12 - v27 && v34 - v32 == v11 - v28 )
        {
          (*(void (__stdcall **)(int *, int **))(*v9 + 12))(v9, &arg4);
          grim_d3d_debug_set_mute(1);
          v13 = (*(int (__stdcall **)(int *, int *, int *, int, int *, int *))(*arg4 + 112))(
                  arg4,
                  v9,
                  &v27,
                  1,
                  arg1,
                  &v31);
          grim_d3d_debug_set_mute(0);
          (*(void (__stdcall **)(int *))(*arg4 + 8))(arg4);
          if ( v13 >= 0 )
            goto LABEL_25;
        }
      }
      v14 = 1;
      if ( arg1 == v9 )
        v14 = 65537;
      v15 = FUN_100161bb(v20, v9, arg5, arg6, 0, v14, v17);
      if ( v15 >= 0
        && (v15 = FUN_1000acc0(arg1, (int)arg2, arg3, *(int *)v20, v21, v22, (int)arg5, arg8, arg7, arg10), v15 >= 0) )
      {
LABEL_25:
        v8 = 0;
      }
      else
      {
        v8 = v15;
      }
    }
    else
    {
      v8 = -2005530516;
    }
  }
  else
  {
    v8 = -2005530516;
  }
  FUN_100161b6(v19);
  return v8;
}

// FUN_1000bda2 @ 0x1000BDA2
// [binja] int32_t __stdcall sub_1000bda2(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8)
int FUN_1000bda2(int *arg1, int arg2, int arg3, int *arg4, int arg5, int arg6, int arg7, int arg8)
{
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int *v12; // [esp+0h] [ebp-54h]
  int v13; // [esp+0h] [ebp-54h]
  int v14[10]; // [esp+4h] [ebp-50h] BYREF
  int arg9[9]; // [esp+2Ch] [ebp-28h] BYREF
  _BYTE v16[4]; // [esp+50h] [ebp-4h] BYREF

  FUN_1001619a(v12);
  v8 = 0;
  if ( arg1 && arg4 )
  {
    v9 = 1;
    if ( arg1 == arg4 )
      v9 = 65537;
    v10 = FUN_100165d3(v14, arg4, (int *)arg5, arg6, 0, v9, v13);
    if ( v10 < 0
      || (v10 = FUN_1000ae72(arg1, arg2, arg3, v14[0], v14[1], v14[2], v14[3], arg5, (int)arg9, arg7, arg8), v10 < 0) )
    {
      v8 = v10;
    }
  }
  else
  {
    v8 = -2005530516;
  }
  j_FUN_100161a0(v16);
  return v8;
}

// sub_1000BE28 @ 0x1000BE28
int __usercall sub_1000BE28@<eax>(
        int a1@<ecx>,
        int *a2@<ebx>,
        int *lpWideCharStr,
        int arg2,
        int *arg3,
        LPSTR lpMultiByteStr)
{
  int v7; // esi
  int v8; // edi
  int v9; // eax
  unsigned int v10; // ebx
  void *v11; // esi
  unsigned int *v12; // eax
  void *v13; // eax
  unsigned int v14; // ecx
  void *v15; // edi
  int v16; // edi
  int *v17; // eax
  unsigned int *v18; // eax
  void *v19; // esi
  void *v20; // eax
  int *v21; // eax
  int v22; // esi
  int v23; // eax
  void *v24; // edx
  int v25; // eax
  unsigned int v26; // esi
  _DWORD *v27; // edi
  unsigned int v28; // esi
  _DWORD *v29; // edi
  int *v31; // [esp-8h] [ebp-F0h]
  int *v32; // [esp+0h] [ebp-E8h]
  void *v33; // [esp+0h] [ebp-E8h]
  int arg1[19]; // [esp+4h] [ebp-E4h] BYREF
  char v35; // [esp+50h] [ebp-98h] BYREF
  void *v36; // [esp+A4h] [ebp-44h]
  int v37; // [esp+A8h] [ebp-40h]
  int v38; // [esp+ACh] [ebp-3Ch]
  int *v39; // [esp+B0h] [ebp-38h]
  void *v40; // [esp+B4h] [ebp-34h]
  unsigned int v41; // [esp+B8h] [ebp-30h]
  void *v42; // [esp+BCh] [ebp-2Ch]
  void *v43; // [esp+C0h] [ebp-28h]
  int v44; // [esp+C4h] [ebp-24h]
  unsigned int v45; // [esp+C8h] [ebp-20h]
  unsigned int v46; // [esp+CCh] [ebp-1Ch]
  void *v47; // [esp+D0h] [ebp-18h]
  void *v48; // [esp+D4h] [ebp-14h]
  int v49; // [esp+D8h] [ebp-10h]
  int v50; // [esp+E4h] [ebp-4h]

  FUN_10010285(v32);
  v50 = 0;
  if ( !lpWideCharStr || !a1 )
  {
    v7 = -2005530516;
    goto LABEL_77;
  }
  v8 = (*(int (__stdcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  v37 = v8;
  if ( v8 != 3 && (unsigned int)(v8 - 4) >= 2 )
  {
    v7 = -2005530516;
    goto LABEL_77;
  }
  v44 = a1;
  if ( arg2 == 4 )
  {
    v41 = v8 != 5 ? 1 : 6;
    v9 = (*(int (__stdcall **)(int))(*(_DWORD *)a1 + 52))(a1);
  }
  else
  {
    v9 = 1;
    v41 = 1;
  }
  v31 = a2;
  v10 = v41 * v9;
  v11 = 0;
  v45 = v9;
  v48 = 0;
  v47 = 0;
  v42 = 0;
  v40 = 0;
  if ( v8 == 3 )
    goto LABEL_13;
  if ( v8 != 4 )
  {
    if ( v8 != 5 )
    {
LABEL_19:
      v39 = (int *)&v35;
      v46 = 0;
      if ( v41 )
      {
        v38 = 0;
        do
        {
          v16 = 0;
          if ( v46 )
          {
            v43 = operator new(0x54u);
            LOBYTE(v50) = 3;
            if ( v43 )
              v17 = FUN_10010285(v31);
            else
              v17 = 0;
            LOBYTE(v50) = 0;
            if ( !v17 )
              goto LABEL_79;
            v39[20] = (int)v17;
            v39 = v17;
          }
          v43 = v39;
          if ( v45 )
          {
            while ( 1 )
            {
              if ( v16 )
              {
                v36 = operator new(0x54u);
                LOBYTE(v50) = 4;
                if ( v36 )
                  v21 = FUN_10010285(v31);
                else
                  v21 = 0;
                LOBYTE(v50) = 0;
                if ( !v21 )
                  goto LABEL_79;
                *((_DWORD *)v43 + 19) = v21;
                v43 = v21;
              }
              v22 = v38 + v16;
              if ( v37 == 3 )
                break;
              if ( v37 == 4 )
              {
                v24 = v47;
LABEL_46:
                v23 = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)v44 + 60))(v44, v16, (int)v24 + 4 * v22);
                goto LABEL_47;
              }
              if ( v37 != 5 )
                goto LABEL_48;
              v23 = (*(int (__stdcall **)(int, unsigned int, int, char *))(*(_DWORD *)v44 + 60))(
                      v44,
                      v46,
                      v16,
                      (char *)v48 + 4 * v22);
LABEL_47:
              v49 = v23;
LABEL_48:
              if ( v49 < 0 )
                goto LABEL_60;
              switch ( v37 )
              {
                case 3:
LABEL_52:
                  v25 = FUN_100161bb((char *)arg1, *((int **)v48 + v22), arg3, 0, 0, 1, (int)v31);
LABEL_53:
                  v49 = v25;
                  break;
                case 4:
                  v25 = FUN_100165d3(arg1, *((int **)v47 + v22), arg3, 0, 0, 1, (int)v31);
                  goto LABEL_53;
                case 5:
                  goto LABEL_52;
              }
              if ( v49 < 0 )
                goto LABEL_60;
              v49 = FUN_10010313(arg1, v31);
              if ( v49 < 0 )
                goto LABEL_60;
              if ( ++v16 >= v45 )
                goto LABEL_57;
            }
            v24 = v48;
            goto LABEL_46;
          }
LABEL_57:
          ++v46;
          v38 += v45;
        }
        while ( v46 < v41 );
      }
      v49 = FUN_1001237e(lpWideCharStr, arg2, (int)lpMultiByteStr, v31);
      if ( v49 >= 0 )
        v49 = 0;
      goto LABEL_60;
    }
LABEL_13:
    v12 = (unsigned int *)operator new(16 * v10 + 4);
    v42 = v12;
    LOBYTE(v50) = 1;
    if ( v12 )
    {
      v11 = v12 + 1;
      *v12 = v10;
      FUN_1004b6c3((int)(v12 + 1), 16, v10, (int)FUN_10016121);
    }
    LOBYTE(v50) = 0;
    v42 = v11;
    if ( v11 )
    {
      v13 = operator new(4 * v10);
      v48 = v13;
      if ( v13 )
      {
        v14 = 4 * v10;
        v15 = v13;
LABEL_18:
        memset(v15, 0, v14);
        goto LABEL_19;
      }
    }
    goto LABEL_79;
  }
  v18 = (unsigned int *)operator new(4 * v10 + 4);
  v40 = v18;
  LOBYTE(v50) = 2;
  if ( v18 )
  {
    v19 = v18 + 1;
    *v18 = v10;
    FUN_1004b6c3((int)(v18 + 1), 4, v10, (int)FUN_1001619a);
  }
  else
  {
    v19 = 0;
  }
  LOBYTE(v50) = 0;
  v40 = v19;
  if ( v19 )
  {
    v20 = operator new(4 * v10);
    v47 = v20;
    if ( v20 )
    {
      v14 = 4 * v10;
      v15 = v20;
      goto LABEL_18;
    }
  }
LABEL_79:
  v49 = -2147024882;
LABEL_60:
  v26 = 0;
  if ( v42 )
    sub_1000B2FD((char *)v42, 3);
  if ( v40 )
    sub_1000B348((char *)v40, 3);
  if ( v48 )
  {
    if ( v10 )
    {
      do
      {
        v27 = (char *)v48 + 4 * v26;
        if ( *v27 )
        {
          (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v27 + 8))(*v27);
          *v27 = 0;
        }
        ++v26;
      }
      while ( v26 < v10 );
    }
    operator delete(v48);
  }
  v28 = 0;
  if ( v47 )
  {
    if ( v10 )
    {
      do
      {
        v29 = (char *)v47 + 4 * v28;
        if ( *v29 )
        {
          (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v29 + 8))(*v29);
          *v29 = 0;
        }
        ++v28;
      }
      while ( v28 < v10 );
    }
    operator delete(v47);
  }
  v7 = v49;
LABEL_77:
  v50 = -1;
  FUN_1001029e(v33);
  return v7;
}

// FUN_1000c1e8 @ 0x1000C1E8
// [binja] void* __stdcall sub_1000c1e8(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
void *FUN_1000c1e8(int arg1, int arg2, int *arg3, int arg4)
{
  int *v4; // ebx

  return (void *)sub_1000BE28((int)arg3, v4, (int *)arg1, arg2, (int *)arg4, 0);
}

// FUN_1000c205 @ 0x1000C205
// [binja] int32_t __stdcall sub_1000c205(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
int FUN_1000c205(int *arg1, int *arg2, int arg3, int arg4)
{
  int *v4; // esi
  int v6; // eax
  unsigned int v7; // eax
  int v8; // esi
  int v9; // eax
  int **v10; // edx
  int v11; // edi
  int v12; // eax
  int **v13; // edx
  int v14; // eax
  char v15[20]; // [esp+8h] [ebp-64h] BYREF
  int v16; // [esp+1Ch] [ebp-50h]
  int v17; // [esp+20h] [ebp-4Ch]
  int v18; // [esp+24h] [ebp-48h]
  _BYTE v19[24]; // [esp+28h] [ebp-44h] BYREF
  int v20; // [esp+40h] [ebp-2Ch]
  int v21; // [esp+44h] [ebp-28h]
  unsigned int v22; // [esp+48h] [ebp-24h]
  unsigned int v23; // [esp+4Ch] [ebp-20h]
  int v24; // [esp+50h] [ebp-1Ch]
  int *v25; // [esp+54h] [ebp-18h]
  unsigned int v26; // [esp+58h] [ebp-14h]
  int v27; // [esp+5Ch] [ebp-10h]
  int *v28; // [esp+60h] [ebp-Ch] BYREF
  int *v29; // [esp+64h] [ebp-8h] BYREF
  int *v30; // [esp+68h] [ebp-4h] BYREF

  v4 = arg1;
  if ( !arg1 )
    return -2005530516;
  v27 = (*(int (__stdcall **)(int *))(*arg1 + 40))(arg1);
  if ( v27 != 3 && (unsigned int)(v27 - 4) >= 2 )
    return -2005530516;
  v25 = v4;
  if ( arg4 != -1 )
    goto LABEL_16;
  if ( v27 == 3 )
  {
    (*(void (__stdcall **)(int *, _DWORD, _BYTE *))(*v25 + 56))(v25, 0, v19);
    if ( ((v20 - 1) & v20) == 0 && ((v21 - 1) & v21) == 0 )
      goto LABEL_26;
    arg4 = 0;
    goto LABEL_25;
  }
  if ( v27 == 4 )
  {
    (*(void (__stdcall **)(int *, _DWORD, char *))(*v25 + 56))(v25, 0, v15);
    if ( ((v16 - 1) & v16) != 0 || ((v17 - 1) & v17) != 0 )
      goto LABEL_15;
    v6 = v18;
LABEL_14:
    if ( ((v6 - 1) & v6) != 0 )
      goto LABEL_15;
LABEL_26:
    arg4 = 5;
    goto LABEL_16;
  }
  if ( v27 != 5 )
  {
LABEL_25:
    if ( !arg4 )
      goto LABEL_15;
    goto LABEL_26;
  }
  (*(void (__stdcall **)(int *, _DWORD, _BYTE *))(*v25 + 56))(v25, 0, v19);
  if ( ((v20 - 1) & v20) == 0 )
  {
    v6 = v21;
    goto LABEL_14;
  }
LABEL_15:
  arg4 = 524292;
LABEL_16:
  if ( v27 == 5 )
    BYTE2(arg4) |= 7u;
  v7 = (*(int (__stdcall **)(int *))(*v4 + 52))(v4);
  v23 = v7;
  if ( arg3 == -1 )
    arg3 = 0;
  if ( arg3 >= v7 )
    return -2005530516;
  arg1 = 0;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v22 = v27 != 5 ? 1 : 6;
  if ( (unsigned __int8)arg4 == 2 || (v24 = 0, (unsigned __int8)arg4 == 5) )
    v24 = 1;
  v26 = 0;
  v8 = arg4;
  do
  {
    switch ( v27 )
    {
      case 3:
        v10 = &arg1;
        goto LABEL_37;
      case 4:
        v10 = &v29;
LABEL_37:
        v9 = (*(int (__stdcall **)(int *, int, int **))(*v25 + 60))(v25, arg3, v10);
        goto LABEL_38;
      case 5:
        v9 = (*(int (__stdcall **)(int *, unsigned int, int, int **))(*v25 + 60))(v25, v26, arg3, &arg1);
LABEL_38:
        v8 = v9;
        break;
    }
    if ( v8 < 0 )
      goto LABEL_75;
    v11 = arg3;
    while ( ++v11 < v23 )
    {
      if ( v27 == 3 )
      {
        v13 = &v30;
        goto LABEL_47;
      }
      if ( v27 == 4 )
      {
        v13 = &v28;
LABEL_47:
        v12 = (*(int (__stdcall **)(int *, int, int **))(*v25 + 60))(v25, v11, v13);
        goto LABEL_48;
      }
      if ( v27 != 5 )
        goto LABEL_49;
      v12 = (*(int (__stdcall **)(int *, unsigned int, int, int **))(*v25 + 60))(v25, v26, v11, &v30);
LABEL_48:
      v8 = v12;
LABEL_49:
      if ( v8 < 0 )
        goto LABEL_75;
      switch ( v27 )
      {
        case 3:
LABEL_53:
          v14 = FUN_1000bbfc(v30, arg2, 0, arg1, arg2, 0, arg4);
LABEL_54:
          v8 = v14;
          break;
        case 4:
          v14 = FUN_1000bda2(v28, (int)arg2, 0, v29, (int)arg2, 0, arg4, 0);
          goto LABEL_54;
        case 5:
          goto LABEL_53;
      }
      if ( v8 < 0 )
        goto LABEL_75;
      if ( v24 )
      {
        if ( arg1 )
        {
          (*(void (__stdcall **)(int *))(*arg1 + 8))(arg1);
          arg1 = 0;
        }
        if ( v29 )
          (*(void (__stdcall **)(int *))(*v29 + 8))(v29);
        arg1 = v30;
        v30 = 0;
        v29 = v28;
LABEL_67:
        v28 = 0;
      }
      else
      {
        if ( v30 )
        {
          (*(void (__stdcall **)(int *))(*v30 + 8))(v30);
          v30 = 0;
        }
        if ( v28 )
        {
          (*(void (__stdcall **)(int *))(*v28 + 8))(v28);
          goto LABEL_67;
        }
      }
    }
    if ( arg1 )
    {
      (*(void (__stdcall **)(int *))(*arg1 + 8))(arg1);
      arg1 = 0;
    }
    if ( v29 )
    {
      (*(void (__stdcall **)(int *))(*v29 + 8))(v29);
      v29 = 0;
    }
    ++v26;
  }
  while ( v26 < v22 );
  v8 = 0;
LABEL_75:
  if ( arg1 )
  {
    (*(void (__stdcall **)(int *))(*arg1 + 8))(arg1);
    arg1 = 0;
  }
  if ( v29 )
  {
    (*(void (__stdcall **)(int *))(*v29 + 8))(v29);
    v29 = 0;
  }
  if ( v30 )
  {
    (*(void (__stdcall **)(int *))(*v30 + 8))(v30);
    v30 = 0;
  }
  if ( v28 )
    (*(void (__stdcall **)(int *))(*v28 + 8))(v28);
  return v8;
}

// FUN_1000c4e9 @ 0x1000C4E9
// [binja] int32_t sub_1000c4e9(int32_t** arg1, void* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, void* arg9, int32_t arg10, int32_t arg11, int32_t** arg12)
int FUN_1000c4e9(
        int **arg1,
        void *arg2,
        int *arg3,
        int arg4,
        int arg5,
        int arg6,
        int arg7,
        int arg8,
        void *arg9,
        int arg10,
        int arg11,
        int **arg12)
{
  int *v12; // esi
  int v13; // edi
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // esi
  int *v18; // eax
  void *v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // ecx
  int v22; // esi
  int v23; // eax
  void *v24; // esi
  int v25; // ebx
  int v26; // eax
  int v27; // eax
  int *v28; // ebx
  int *v29; // esi
  int v30; // eax
  int **v31; // ecx
  int v32; // eax
  int v33; // eax
  int **v34; // ecx
  int v35; // eax
  int *v36; // ecx
  int *v38; // [esp+0h] [ebp-4D8h]
  void *v39; // [esp+0h] [ebp-4D8h]
  int v40[256]; // [esp+Ch] [ebp-4CCh] BYREF
  char v41; // [esp+40Ch] [ebp-CCh] BYREF
  _DWORD v42[9]; // [esp+428h] [ebp-B0h] BYREF
  int format[2]; // [esp+44Ch] [ebp-8Ch] BYREF
  int v44; // [esp+454h] [ebp-84h]
  int v45; // [esp+458h] [ebp-80h]
  int v46; // [esp+45Ch] [ebp-7Ch]
  int v47; // [esp+460h] [ebp-78h]
  int v48; // [esp+498h] [ebp-40h]
  int v49; // [esp+49Ch] [ebp-3Ch]
  int *v50; // [esp+4A0h] [ebp-38h]
  int v51; // [esp+4A4h] [ebp-34h]
  int v52; // [esp+4A8h] [ebp-30h]
  unsigned int v53; // [esp+4ACh] [ebp-2Ch]
  unsigned int v54; // [esp+4B0h] [ebp-28h]
  unsigned int v55; // [esp+4B4h] [ebp-24h]
  int *v56; // [esp+4B8h] [ebp-20h] BYREF
  int *v57; // [esp+4BCh] [ebp-1Ch] BYREF
  int *v58; // [esp+4C0h] [ebp-18h] BYREF
  int *v59; // [esp+4C4h] [ebp-14h] BYREF
  unsigned int v60; // [esp+4C8h] [ebp-10h]
  int v61; // [esp+4D4h] [ebp-4h]
  int v62; // [esp+510h] [ebp+38h]
  int *v63; // [esp+514h] [ebp+3Ch]
  int v64; // [esp+518h] [ebp+40h]
  int v65; // [esp+51Ch] [ebp+44h]
  int **v66; // [esp+520h] [ebp+48h]

  v12 = v63;
  FUN_10010285(v38);
  v61 = 0;
  v58 = 0;
  v59 = 0;
  v57 = 0;
  v56 = 0;
  if ( !arg1 || !arg2 || !arg3 || !v66 )
  {
    v13 = -2005530516;
    goto LABEL_148;
  }
  if ( !v12 && v65 == -1 )
    v12 = (int *)&v41;
  v14 = FUN_10012677((int *)arg2, arg3, v12, (int *)1, (int)v39);
  if ( v14 < 0 )
  {
    v13 = v14;
    goto LABEL_148;
  }
  if ( v65 == -1 )
    v65 = v12[5];
  v15 = v48;
  v55 = 1;
  while ( v15 )
  {
    ++v55;
    v15 = *(_DWORD *)(v15 + 76);
  }
  v54 = 1;
  if ( v65 == 5 )
  {
    v16 = v49;
    if ( !v49 )
      goto LABEL_20;
    do
    {
      v16 = *(_DWORD *)(v16 + 80);
      ++v54;
    }
    while ( v16 );
    if ( v54 != 6 )
    {
LABEL_20:
      v13 = -2147467259;
      goto LABEL_148;
    }
  }
  if ( !arg4 || arg4 == -1 )
    arg4 = v45;
  if ( !arg5 || arg5 == -1 )
    arg5 = v46;
  if ( !arg6 || arg6 == -1 )
    arg6 = v47;
  if ( arg11 == -1 )
    arg11 = 524292;
  if ( arg12 == (int **)-1 )
    arg12 = (int **)5;
  if ( v65 == 5 )
  {
    arg11 |= 0x70000u;
    arg12 = (int **)((unsigned int)arg12 | 0x70000);
  }
  if ( (_BYTE)arg11 == 1 || (unsigned __int8)arg12 == 2 || (v52 = 0, (unsigned __int8)arg12 == 5) )
    v52 = 1;
  if ( !arg9 )
  {
    v17 = format[0];
    if ( v62 )
    {
      v18 = grim_format_info_lookup(format[0]);
      if ( (unsigned int)v18[1] <= 2 && !v18[4] )
      {
        qmemcpy(v42, v18, sizeof(v42));
        v42[0] = 0;
        v42[4] = 1;
        v17 = sub_1000ABAD(0, arg8, v65, v42);
        if ( !v17 )
          v17 = format[0];
      }
    }
    v19 = (void *)sub_1000AC8F(v17);
    arg9 = v19;
    if ( arg10 != 3 && v19 == (void *)20 )
      arg9 = (void *)22;
  }
  if ( v44 )
  {
    v20 = v62 & 0xFF00FF00 | ((unsigned __int8)v62 << 16) | BYTE2(v62);
    v21 = 0;
    v22 = v44 - (_DWORD)v40;
    do
    {
      v40[v21] = v20 != *(int *)((char *)&v40[v21] + v22) ? *(int *)((char *)&v40[v21] + v22) : 0;
      ++v21;
    }
    while ( v21 < 0x100 );
    v62 = 0;
  }
  else
  {
    memset(v40, 0xFFu, sizeof(v40));
  }
  if ( !v64 )
  {
    if ( arg9 != (void *)40 )
    {
      if ( arg9 != (void *)41 )
        goto LABEL_63;
      arg9 = (void *)22;
      v23 = 0;
      while ( HIBYTE(v40[v23]) == 0xFF )
      {
        if ( (unsigned int)++v23 >= 0x100 )
          goto LABEL_63;
      }
    }
    arg9 = (void *)21;
    goto LABEL_63;
  }
  qmemcpy((void *)v64, v40, 0x400u);
LABEL_63:
  if ( arg10 || (v51 = 1, (arg8 & 0x200) != 0) )
    v51 = 0;
  v13 = sub_1000AF45(
          arg8,
          (int)arg1,
          (unsigned int *)&arg4,
          (unsigned int *)&arg5,
          (unsigned int *)&arg6,
          (unsigned int *)&arg7,
          (int *)&arg9,
          arg10,
          v65);
  if ( v13 < 0 )
    goto LABEL_140;
  v24 = arg9;
  v25 = arg4;
  switch ( v65 )
  {
    case 3:
      v26 = ((int (__stdcall *)(int **, int, int, int, int, void *, int, int **))(*arg1)[20])(
              arg1,
              arg4,
              arg5,
              arg7,
              arg8,
              arg9,
              arg10,
              &v57);
      break;
    case 4:
      v26 = ((int (__stdcall *)(int **, int, int, int, int, int, void *, int, int **))(*arg1)[21])(
              arg1,
              arg4,
              arg5,
              arg6,
              arg7,
              arg8,
              arg9,
              arg10,
              &v57);
      break;
    case 5:
      v26 = ((int (__stdcall *)(int **, int, int, int, void *, int, int **))(*arg1)[22])(
              arg1,
              arg4,
              arg7,
              arg8,
              arg9,
              arg10,
              &v57);
      break;
    default:
      goto LABEL_74;
  }
  v13 = v26;
LABEL_74:
  if ( v13 < 0 )
    goto LABEL_140;
  if ( !v51 )
  {
    v28 = v57;
    goto LABEL_86;
  }
  switch ( v65 )
  {
    case 3:
      v27 = ((int (__stdcall *)(int **, int, int, int, _DWORD, void *, int, int **))(*arg1)[20])(
              arg1,
              v25,
              arg5,
              arg7,
              0,
              v24,
              2,
              &v56);
      break;
    case 4:
      v27 = ((int (__stdcall *)(int **, int, int, int, int, _DWORD, void *, int, int **))(*arg1)[21])(
              arg1,
              v25,
              arg5,
              arg6,
              arg7,
              0,
              v24,
              2,
              &v56);
      break;
    case 5:
      v27 = ((int (__stdcall *)(int **, int, int, _DWORD, void *, int, int **))(*arg1)[22])(
              arg1,
              v25,
              arg7,
              0,
              v24,
              2,
              &v56);
      break;
    default:
      goto LABEL_83;
  }
  v13 = v27;
LABEL_83:
  if ( v13 >= 0 )
  {
    v28 = v56;
LABEL_86:
    v53 = 0;
    v29 = format;
    v50 = format;
    if ( v54 )
    {
      while ( 1 )
      {
        v60 = 0;
        if ( v55 )
        {
          while ( 1 )
          {
            if ( v60 >= arg7 )
              goto LABEL_111;
            if ( v65 == 3 )
              break;
            if ( v65 == 4 )
            {
              v31 = &v58;
LABEL_95:
              v30 = (*(int (__stdcall **)(int *, unsigned int, int **))(*v28 + 60))(v28, v60, v31);
              goto LABEL_96;
            }
            if ( v65 != 5 )
              goto LABEL_97;
            v30 = (*(int (__stdcall **)(int *, unsigned int, unsigned int, int **))(*v28 + 60))(v28, v53, v60, &v59);
LABEL_96:
            v13 = v30;
LABEL_97:
            if ( v13 < 0 )
              goto LABEL_140;
            if ( v65 != 3 )
            {
              if ( v65 == 4 )
              {
                v32 = FUN_1000ae72(v58, v64, 0, v29[1], *v29, v29[12], v29[13], (int)v40, (int)(v29 + 6), arg11, v62);
                goto LABEL_102;
              }
              if ( v65 != 5 )
                goto LABEL_103;
            }
            v32 = FUN_1000acc0(v59, v64, 0, v29[1], *v29, v29[12], (int)v40, v29 + 6, arg11, v62);
LABEL_102:
            v13 = v32;
LABEL_103:
            if ( v13 < 0 )
              goto LABEL_140;
            if ( v58 )
            {
              (*(void (__stdcall **)(int *))(*v58 + 8))(v58);
              v58 = 0;
            }
            if ( v59 )
            {
              (*(void (__stdcall **)(int *))(*v59 + 8))(v59);
              v59 = 0;
            }
            if ( ++v60 >= v55 )
              goto LABEL_111;
            v29 = (int *)v29[19];
          }
          v31 = &v59;
          goto LABEL_95;
        }
LABEL_111:
        if ( !v52 && v60 < arg7 )
          break;
LABEL_133:
        ++v53;
        v29 = (int *)v50[20];
        v50 = v29;
        if ( v53 >= v54 )
          goto LABEL_134;
      }
      while ( v65 != 3 )
      {
        if ( v65 == 4 )
        {
          v34 = &v58;
LABEL_119:
          v33 = (*(int (__stdcall **)(int *, unsigned int, int **))(*v28 + 60))(v28, v60, v34);
          goto LABEL_120;
        }
        if ( v65 != 5 )
          goto LABEL_121;
        v33 = (*(int (__stdcall **)(int *, unsigned int, unsigned int, int **))(*v28 + 60))(v28, v53, v60, &v59);
LABEL_120:
        v13 = v33;
LABEL_121:
        if ( v13 < 0 )
          goto LABEL_140;
        switch ( v65 )
        {
          case 3:
LABEL_125:
            v35 = FUN_1000acc0(v59, v64, 0, v29[1], *v29, v29[12], (int)v40, v29 + 6, arg11, v62);
LABEL_126:
            v13 = v35;
            break;
          case 4:
            v35 = FUN_1000ae72(v58, v64, 0, v29[1], *v29, v29[12], v29[13], (int)v40, (int)(v29 + 6), arg11, v62);
            goto LABEL_126;
          case 5:
            goto LABEL_125;
        }
        if ( v13 < 0 )
          goto LABEL_140;
        if ( v58 )
        {
          (*(void (__stdcall **)(int *))(*v58 + 8))(v58);
          v58 = 0;
        }
        if ( v59 )
        {
          (*(void (__stdcall **)(int *))(*v59 + 8))(v59);
          v59 = 0;
        }
        if ( ++v60 >= arg7 )
          goto LABEL_133;
      }
      v34 = &v59;
      goto LABEL_119;
    }
LABEL_134:
    if ( !v52 || v55 >= arg7 || (v13 = FUN_1000c205(v28, v40, v55 - 1, (int)arg12), v13 >= 0) )
    {
      if ( !v51 || (v13 = ((int (__stdcall *)(int **, int *, int *))(*arg1)[29])(arg1, v56, v57), v13 >= 0) )
      {
        v36 = v57;
        v57 = 0;
        *v66 = v36;
        v13 = 0;
      }
    }
  }
LABEL_140:
  if ( v58 )
  {
    (*(void (__stdcall **)(int *))(*v58 + 8))(v58);
    v58 = 0;
  }
  if ( v59 )
  {
    (*(void (__stdcall **)(int *))(*v59 + 8))(v59);
    v59 = 0;
  }
  if ( v57 )
  {
    (*(void (__stdcall **)(int *))(*v57 + 8))(v57);
    v57 = 0;
  }
  if ( v56 )
  {
    (*(void (__stdcall **)(int *))(*v56 + 8))(v56);
    v56 = 0;
  }
LABEL_148:
  v61 = -1;
  FUN_1001029e(v39);
  return v13;
}

// FUN_1000cb5c @ 0x1000CB5C
// [binja] int32_t __stdcall sub_1000cb5c(int32_t** arg1, void* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, void* arg8, int32_t arg9, int32_t arg10, int32_t** arg11, int32_t arg12, int32_t arg13, int32_t arg14, int32_t arg15)
int FUN_1000cb5c(
        int **arg1,
        void *arg2,
        int *arg3,
        int arg4,
        int arg5,
        int arg6,
        int arg7,
        void *arg8,
        int arg9,
        int arg10,
        int **arg11,
        int arg12,
        int arg13,
        int arg14,
        int arg15)
{
  return FUN_1000c4e9(arg1, arg2, arg3, arg4, arg5, 1, arg6, arg7, arg8, arg9, arg10, arg11);
}

// FUN_1000cb9c @ 0x1000CB9C
// [binja] int32_t __stdcall sub_1000cb9c(int32_t** arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, void* arg7, int32_t arg8, int32_t arg9, int32_t** arg10, int32_t arg11, int32_t arg12, int32_t arg13, int32_t arg14)
int FUN_1000cb9c(
        int **arg1,
        int *arg2,
        int arg3,
        int arg4,
        int arg5,
        int arg6,
        void *arg7,
        int arg8,
        int arg9,
        int **arg10,
        int arg11,
        int arg12,
        int arg13,
        int arg14)
{
  int v14; // eax
  int v15; // esi
  int *v17; // [esp+0h] [ebp-14h]
  int *v18; // [esp+0h] [ebp-14h]
  int *v19; // [esp+0h] [ebp-14h]
  void *arg2a; // [esp+Ch] [ebp-8h]
  int *v21; // [esp+10h] [ebp-4h]

  FUN_1001bca5(v17);
  v14 = FUN_1001bcb7(arg2, 0, v18);
  if ( v14 >= 0 )
    v14 = FUN_1000cb5c(arg1, arg2a, v21, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13, arg14);
  v15 = v14;
  FUN_1001bed2(v19);
  return v15;
}

// float_near_equal @ 0x1000CBFF
// returns 1 when |a-b| < 1.1920929e-07 (FLT_EPSILON)
int float_near_equal(float a, float b)
{
  double v2; // st7

  v2 = a - b;
  return v2 >= -0.00000011920929 && v2 <= 0.00000011920929;
}

// sub_1000CC2C @ 0x1000CC2C
int sub_1000CC2C()
{
  grim_select_renderer_backend(1u);
  return off_10053D10();
}

// FUN_1000cc3f @ 0x1000CC3F
// [binja] int32_t __stdcall sub_1000cc3f(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000cc3f(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053C9C(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000cc69 @ 0x1000CC69
// [binja] float* __stdcall sub_1000cc69(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000cc69(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float arg6a; // [esp+24h] [ebp+1Ch]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v10 = v8 + v8 - v6 * 3.0 + 1.0;
  v11 = v8 - (v6 + v6) + arg6;
  arg6a = v6 * 3.0 - (v8 + v8);
  v9 = v8 - v6;
  *arg1 = v10 * *arg2 + v11 * *arg3 + arg6a * *arg4 + v9 * *arg5;
  arg1[1] = v9 * arg5[1] + arg6a * arg4[1] + v11 * arg3[1] + v10 * arg2[1];
  return arg1;
}

// FUN_1000ccf7 @ 0x1000CCF7
// [binja] int32_t __stdcall sub_1000ccf7(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000ccf7(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D14(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000cd21 @ 0x1000CD21
// [binja] float* __stdcall sub_1000cd21(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000cd21(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float arg6a; // [esp+24h] [ebp+1Ch]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v10 = v6 * 2.0 - v8 - arg6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  arg6a = v6 * 4.0 - v8 * 3.0 + arg6;
  v9 = v8 - v6;
  *arg1 = (v10 * *arg2 + v11 * *arg3 + arg6a * *arg4 + v9 * *arg5) * 0.5;
  arg1[1] = (v9 * arg5[1] + arg6a * arg4[1] + v11 * arg3[1] + v10 * arg2[1]) * 0.5;
  return arg1;
}

// FUN_1000cdd0 @ 0x1000CDD0
// [binja] int32_t __stdcall sub_1000cdd0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int FUN_1000cdd0(int arg1, int arg2, int arg3, int arg4, float arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D18(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000cdff @ 0x1000CDFF
// [binja] float* __stdcall sub_1000cdff(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *FUN_1000cdff(float *arg1, float *arg2, float *arg3, float *arg4, float arg5, float arg6)
{
  *arg1 = (*arg3 - *arg2) * arg5 + (*arg4 - *arg2) * arg6 + *arg2;
  arg1[1] = (arg3[1] - arg2[1]) * arg5 + (arg4[1] - arg2[1]) * arg6 + arg2[1];
  return arg1;
}

// sub_1000CE42 @ 0x1000CE42
int sub_1000CE42()
{
  grim_select_renderer_backend(1u);
  return table();
}

// sub_1000CE69 @ 0x1000CE69
int sub_1000CE69()
{
  grim_select_renderer_backend(1u);
  return off_10053C74();
}

// sub_1000CE7C @ 0x1000CE7C
int __stdcall sub_1000CE7C(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D1C(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cea6 @ 0x1000CEA6
// [binja] float* __stdcall sub_1000cea6(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000cea6(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float arg6a; // [esp+24h] [ebp+1Ch]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v10 = v8 + v8 - v6 * 3.0 + 1.0;
  v11 = v8 - (v6 + v6) + arg6;
  arg6a = v6 * 3.0 - (v8 + v8);
  v9 = v8 - v6;
  *arg1 = v10 * *arg2 + v11 * *arg3 + arg6a * *arg4 + v9 * *arg5;
  arg1[1] = v9 * arg5[1] + arg6a * arg4[1] + v11 * arg3[1] + v10 * arg2[1];
  arg1[2] = v9 * arg5[2] + arg6a * arg4[2] + v11 * arg3[2] + v10 * arg2[2];
  return arg1;
}

// FUN_1000cf54 @ 0x1000CF54
// [binja] int32_t __stdcall sub_1000cf54(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000cf54(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D20(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000cf7e @ 0x1000CF7E
// [binja] float* __stdcall sub_1000cf7e(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000cf7e(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float arg6a; // [esp+24h] [ebp+1Ch]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v10 = v6 * 2.0 - v8 - arg6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  arg6a = v6 * 4.0 - v8 * 3.0 + arg6;
  v9 = v8 - v6;
  *arg1 = (v10 * *arg2 + v11 * *arg3 + arg6a * *arg4 + v9 * *arg5) * 0.5;
  arg1[1] = (v9 * arg5[1] + arg6a * arg4[1] + v11 * arg3[1] + v10 * arg2[1]) * 0.5;
  arg1[2] = (v9 * arg5[2] + arg6a * arg4[2] + v11 * arg3[2] + v10 * arg2[2]) * 0.5;
  return arg1;
}

// FUN_1000d04f @ 0x1000D04F
// [binja] int32_t __stdcall sub_1000d04f(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int FUN_1000d04f(int arg1, int arg2, int arg3, int arg4, float arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D24(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000d07e @ 0x1000D07E
// [binja] float* __stdcall sub_1000d07e(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *FUN_1000d07e(float *arg1, float *arg2, float *arg3, float *arg4, float arg5, float arg6)
{
  *arg1 = (*arg3 - *arg2) * arg5 + (*arg4 - *arg2) * arg6 + *arg2;
  arg1[1] = (arg3[1] - arg2[1]) * arg5 + (arg4[1] - arg2[1]) * arg6 + arg2[1];
  arg1[2] = (arg3[2] - arg2[2]) * arg5 + (arg4[2] - arg2[2]) * arg6 + arg2[2];
  return arg1;
}

// sub_1000D0E8 @ 0x1000D0E8
float *__stdcall sub_1000D0E8(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[4] * a2[1] + *a2 * *a3 + a3[12];
  v5 = a3[9] * a2[2] + a3[5] * a2[1] + a3[1] * *a2 + a3[13];
  v6 = a3[10] * a2[2] + a3[6] * a2[1] + a3[2] * *a2 + a3[14];
  v7 = a3[11] * a2[2] + a3[7] * a2[1] + a3[3] * *a2 + a3[15];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// sub_1000D173 @ 0x1000D173
int sub_1000D173()
{
  grim_select_renderer_backend(1u);
  return off_10053C80();
}

// sub_1000D193 @ 0x1000D193
float *__stdcall sub_1000D193(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-Ch]
  float v5; // [esp+Ch] [ebp-8h]
  float v6; // [esp+10h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[4] * a2[1] + *a2 * *a3;
  v5 = a3[9] * a2[2] + a3[5] * a2[1] + a3[1] * *a2;
  v6 = a3[10] * a2[2] + a3[6] * a2[1] + a3[2] * *a2;
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  return a1;
}

// sub_1000D1F9 @ 0x1000D1F9
int sub_1000D1F9()
{
  grim_select_renderer_backend(1u);
  return off_10053C90();
}

// sub_1000D20A @ 0x1000D20A
int sub_1000D20A()
{
  grim_select_renderer_backend(1u);
  return off_10053C94();
}

// sub_1000D228 @ 0x1000D228
float *__stdcall sub_1000D228(float *a1, float *a2, float *a3, float *a4)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  double v10; // st6
  float v12; // [esp+8h] [ebp-1Ch]
  float v13; // [esp+Ch] [ebp-18h]
  float v14; // [esp+10h] [ebp-14h]
  float v15; // [esp+14h] [ebp-10h]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  float v18; // [esp+20h] [ebp-4h]
  float v19; // [esp+30h] [ebp+Ch]
  float v20; // [esp+34h] [ebp+10h]
  float v21; // [esp+38h] [ebp+14h]

  v6 = a4[3] * a3[2];
  v8 = a3[3] * a4[2];
  v20 = a4[3] * a3[1] - a3[3] * a4[1];
  v17 = a3[1] * a4[2];
  v18 = a3[2] * a4[1];
  v12 = (v6 - v8) * a2[1] - v20 * a2[2] + (v17 - v18) * a2[3];
  v19 = a3[3] * *a4;
  v21 = a4[3] * *a3;
  v16 = *a4 * a3[2] - *a3 * a4[2];
  v13 = (v8 - v6) * *a2 - (v19 - v21) * a2[2] + v16 * a2[3];
  v9 = *a3 * a4[1];
  v10 = *a4 * a3[1];
  v14 = v20 * *a2 - (v21 - v19) * a2[1] + (v9 - v10) * a2[3];
  v15 = (v18 - v17) * *a2 - v16 * a2[1] + (v10 - v9) * a2[2];
  *a1 = v12;
  a1[1] = v13;
  a1[2] = v14;
  a1[3] = v15;
  return a1;
}

// sub_1000D325 @ 0x1000D325
int __stdcall sub_1000D325(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D28(a1, a2, a3, a4, a5, a6);
}

// FUN_1000d34f @ 0x1000D34F
// [binja] float* __stdcall sub_1000d34f(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000d34f(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st6
  double v10; // st5
  double v11; // st4
  double v12; // st3
  float v13; // [esp+0h] [ebp-Ch]
  float v14; // [esp+4h] [ebp-8h]
  float v15; // [esp+8h] [ebp-4h]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v15 = v8;
  v13 = v8 + v8;
  v14 = 3.0 * v6;
  v9 = v13 - v14 + 1.0;
  v10 = v15 - (v6 + v6) + arg6;
  v11 = v14 - v13;
  v12 = v15 - v6;
  *arg1 = v9 * *arg2 + v10 * *arg3 + v11 * *arg4 + v12 * *arg5;
  arg1[1] = v12 * arg5[1] + v11 * arg4[1] + v10 * arg3[1] + v9 * arg2[1];
  arg1[2] = v12 * arg5[2] + v11 * arg4[2] + v10 * arg3[2] + v9 * arg2[2];
  arg1[3] = v12 * arg5[3] + v11 * arg4[3] + v10 * arg3[3] + v9 * arg2[3];
  return arg1;
}

// FUN_1000d420 @ 0x1000D420
// [binja] int32_t __stdcall sub_1000d420(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000d420(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D2C(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000d44a @ 0x1000D44A
// [binja] float* __stdcall sub_1000d44a(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *FUN_1000d44a(float *arg1, float *arg2, float *arg3, float *arg4, float *arg5, float arg6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float arg6a; // [esp+24h] [ebp+1Ch]

  v6 = arg6 * arg6;
  v8 = arg6 * v6;
  v10 = v6 * 2.0 - v8 - arg6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  arg6a = v6 * 4.0 - v8 * 3.0 + arg6;
  v9 = v8 - v6;
  *arg1 = (v10 * *arg2 + v11 * *arg3 + arg6a * *arg4 + v9 * *arg5) * 0.5;
  arg1[1] = (v9 * arg5[1] + arg6a * arg4[1] + v11 * arg3[1] + v10 * arg2[1]) * 0.5;
  arg1[2] = (v9 * arg5[2] + arg6a * arg4[2] + v11 * arg3[2] + v10 * arg2[2]) * 0.5;
  arg1[3] = (v9 * arg5[3] + arg6a * arg4[3] + v11 * arg3[3] + v10 * arg2[3]) * 0.5;
  return arg1;
}

// FUN_1000d53d @ 0x1000D53D
// [binja] int32_t __stdcall sub_1000d53d(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int FUN_1000d53d(int arg1, int arg2, int arg3, int arg4, float arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D30(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000d56c @ 0x1000D56C
// [binja] float* __stdcall sub_1000d56c(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *FUN_1000d56c(float *arg1, float *arg2, float *arg3, float *arg4, float arg5, float arg6)
{
  *arg1 = (*arg3 - *arg2) * arg5 + (*arg4 - *arg2) * arg6 + *arg2;
  arg1[1] = (arg3[1] - arg2[1]) * arg5 + (arg4[1] - arg2[1]) * arg6 + arg2[1];
  arg1[2] = (arg3[2] - arg2[2]) * arg5 + (arg4[2] - arg2[2]) * arg6 + arg2[2];
  arg1[3] = (arg3[3] - arg2[3]) * arg5 + (arg4[3] - arg2[3]) * arg6 + arg2[3];
  return arg1;
}

// sub_1000D5F0 @ 0x1000D5F0
float *__stdcall sub_1000D5F0(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[12] * a2[3] + a3[4] * a2[1] + a3[8] * a2[2] + *a2 * *a3;
  v5 = a3[13] * a2[3] + a3[5] * a2[1] + a3[1] * *a2 + a3[9] * a2[2];
  v6 = a3[14] * a2[3] + a3[6] * a2[1] + a3[2] * *a2 + a3[10] * a2[2];
  v7 = a3[15] * a2[3] + a3[7] * a2[1] + a3[3] * *a2 + a3[11] * a2[2];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// sub_1000D69C @ 0x1000D69C
double __stdcall sub_1000D69C(float *a1)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5
  double v5; // st4
  double v6; // st3
  float v8; // [esp+8h] [ebp+8h]

  v2 = a1[10] * a1[15] - a1[14] * a1[11];
  v3 = a1[15] * a1[9] - a1[13] * a1[11];
  v4 = a1[14] * a1[9] - a1[10] * a1[13];
  v5 = a1[8] * a1[15] - a1[12] * a1[11];
  v6 = a1[14] * a1[8] - a1[12] * a1[10];
  v8 = a1[8] * a1[13] - a1[12] * a1[9];
  return (v2 * a1[5] - v3 * a1[6] + v4 * a1[7]) * *a1
       - (v2 * a1[4] - v5 * a1[6] + v6 * a1[7]) * a1[1]
       + (v3 * a1[4] - v5 * a1[5] + v8 * a1[7]) * a1[2]
       - (v4 * a1[4] - v6 * a1[5] + v8 * a1[6]) * a1[3];
}

// sub_1000D766 @ 0x1000D766
int sub_1000D766()
{
  grim_select_renderer_backend(1u);
  return off_10053C64();
}

// sub_1000D779 @ 0x1000D779
float *__stdcall sub_1000D779(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // esi
  char v5; // [esp+4h] [ebp-40h] BYREF

  result = a1;
  if ( a1 == a2 || (v4 = a1, a1 == a3) )
    v4 = (float *)&v5;
  *v4 = a2[3] * a3[12] + *a2 * *a3 + a2[2] * a3[8] + a3[4] * a2[1];
  v4[1] = a2[1] * a3[5] + a2[3] * a3[13] + a2[2] * a3[9] + a3[1] * *a2;
  v4[2] = a2[3] * a3[14] + a3[2] * *a2 + a2[2] * a3[10] + a3[6] * a2[1];
  v4[3] = a2[3] * a3[15] + a3[11] * a2[2] + *a2 * a3[3] + a3[7] * a2[1];
  v4[4] = a2[7] * a3[12] + a2[4] * *a3 + a3[4] * a2[5] + a2[6] * a3[8];
  v4[5] = a2[6] * a3[9] + a2[7] * a3[13] + a3[5] * a2[5] + a3[1] * a2[4];
  v4[6] = a3[6] * a2[5] + a2[7] * a3[14] + a3[2] * a2[4] + a2[6] * a3[10];
  v4[7] = a3[7] * a2[5] + a2[7] * a3[15] + a2[6] * a3[11] + a2[4] * a3[3];
  v4[8] = a2[11] * a3[12] + a2[8] * *a3 + a3[4] * a2[9] + a2[10] * a3[8];
  v4[9] = a2[11] * a3[13] + a2[10] * a3[9] + a3[5] * a2[9] + a3[1] * a2[8];
  v4[10] = a3[6] * a2[9] + a3[2] * a2[8] + a2[11] * a3[14] + a2[10] * a3[10];
  v4[11] = a2[11] * a3[15] + a2[10] * a3[11] + a3[7] * a2[9] + a2[8] * a3[3];
  v4[12] = a2[15] * a3[12] + a2[12] * *a3 + a3[4] * a2[13] + a2[14] * a3[8];
  v4[13] = a2[15] * a3[13] + a2[14] * a3[9] + a3[5] * a2[13] + a3[1] * a2[12];
  v4[14] = a3[6] * a2[13] + a3[2] * a2[12] + a2[15] * a3[14] + a2[14] * a3[10];
  v4[15] = a2[15] * a3[15] + a2[14] * a3[11] + a3[7] * a2[13] + a2[12] * a3[3];
  if ( v4 != a1 )
    qmemcpy(a1, v4, 0x40u);
  return result;
}

// sub_1000D9AF @ 0x1000D9AF
int sub_1000D9AF()
{
  grim_select_renderer_backend(1u);
  return off_10053CEC();
}

// sub_1000D9C2 @ 0x1000D9C2
int __stdcall sub_1000D9C2(int a1, int a2)
{
  double v2; // st7
  int result; // eax
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  double v8; // st7

  v2 = *(float *)(a2 + 4);
  result = a1;
  *(float *)(a1 + 4) = *(float *)(a2 + 16);
  *(float *)(a1 + 16) = v2;
  v4 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 32);
  *(float *)(a1 + 32) = v4;
  v5 = *(float *)(a2 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 48);
  *(float *)(a1 + 48) = v5;
  v6 = *(float *)(a2 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 36);
  *(float *)(a1 + 36) = v6;
  v7 = *(float *)(a2 + 28);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 52);
  *(float *)(a1 + 52) = v7;
  v8 = *(float *)(a2 + 44);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 56);
  *(float *)(a1 + 56) = v8;
  if ( a1 != a2 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  }
  return result;
}

// sub_1000DA3C @ 0x1000DA3C
float *__stdcall sub_1000DA3C(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // esi
  char v5; // [esp+4h] [ebp-40h] BYREF

  result = a1;
  if ( a1 == a2 || (v4 = a1, a1 == a3) )
    v4 = (float *)&v5;
  *v4 = a2[3] * a3[12] + *a2 * *a3 + a2[2] * a3[8] + a3[4] * a2[1];
  v4[1] = a2[4] * *a3 + a3[12] * a2[7] + a3[8] * a2[6] + a3[4] * a2[5];
  v4[2] = a2[10] * a3[8] + a2[9] * a3[4] + a3[12] * a2[11] + a2[8] * *a3;
  v4[3] = a2[13] * a3[4] + a2[15] * a3[12] + *a3 * a2[12] + a2[14] * a3[8];
  v4[4] = a3[9] * a2[2] + a3[1] * *a2 + a3[13] * a2[3] + a2[1] * a3[5];
  v4[5] = a3[13] * a2[7] + a3[9] * a2[6] + a2[5] * a3[5] + a2[4] * a3[1];
  v4[6] = a2[9] * a3[5] + a3[13] * a2[11] + a3[9] * a2[10] + a2[8] * a3[1];
  v4[7] = a2[13] * a3[5] + a3[13] * a2[15] + a3[9] * a2[14] + a3[1] * a2[12];
  v4[8] = a3[10] * a2[2] + a3[2] * *a2 + a2[1] * a3[6] + a3[14] * a2[3];
  v4[9] = a3[14] * a2[7] + a3[10] * a2[6] + a2[5] * a3[6] + a2[4] * a3[2];
  v4[10] = a2[9] * a3[6] + a3[14] * a2[11] + a3[10] * a2[10] + a2[8] * a3[2];
  v4[11] = a2[13] * a3[6] + a3[14] * a2[15] + a3[10] * a2[14] + a3[2] * a2[12];
  v4[12] = a3[11] * a2[2] + a3[3] * *a2 + a2[1] * a3[7] + a3[15] * a2[3];
  v4[13] = a3[15] * a2[7] + a3[11] * a2[6] + a2[5] * a3[7] + a2[4] * a3[3];
  v4[14] = a2[9] * a3[7] + a3[15] * a2[11] + a3[11] * a2[10] + a2[8] * a3[3];
  v4[15] = a2[13] * a3[7] + a3[15] * a2[15] + a3[11] * a2[14] + a3[3] * a2[12];
  if ( v4 != a1 )
    qmemcpy(a1, v4, 0x40u);
  return result;
}

// sub_1000DC72 @ 0x1000DC72
int sub_1000DC72()
{
  grim_select_renderer_backend(1u);
  return off_10053CA0();
}

// sub_1000DC85 @ 0x1000DC85
int __stdcall sub_1000DC85(float *a1, float *a2, float *a3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st7
  double v7; // st7
  double v8; // st6
  double v9; // st5
  double v10; // st4
  double v11; // st3
  double v12; // st2
  double v13; // st7
  double v14; // st6
  double v15; // st5
  double v16; // st3
  double v17; // st4
  double v18; // st3
  double v19; // st2
  double v20; // st7
  int result; // eax
  float v22; // [esp+8h] [ebp-54h]
  float v23; // [esp+Ch] [ebp-50h]
  float v24; // [esp+10h] [ebp-4Ch]
  float v25; // [esp+14h] [ebp-48h]
  float v26; // [esp+18h] [ebp-44h]
  float v27; // [esp+1Ch] [ebp-40h]
  float v28; // [esp+20h] [ebp-3Ch]
  float v29; // [esp+24h] [ebp-38h]
  float v30; // [esp+28h] [ebp-34h]
  float v31; // [esp+28h] [ebp-34h]
  float v32; // [esp+2Ch] [ebp-30h]
  float v33; // [esp+2Ch] [ebp-30h]
  float v34; // [esp+30h] [ebp-2Ch]
  float v35; // [esp+30h] [ebp-2Ch]
  float v36; // [esp+34h] [ebp-28h]
  float v37; // [esp+34h] [ebp-28h]
  float v38; // [esp+38h] [ebp-24h]
  float v39; // [esp+38h] [ebp-24h]
  float v40; // [esp+3Ch] [ebp-20h]
  float v41; // [esp+3Ch] [ebp-20h]
  float v42; // [esp+3Ch] [ebp-20h]
  float v43; // [esp+40h] [ebp-1Ch]
  float v44; // [esp+40h] [ebp-1Ch]
  float v45; // [esp+44h] [ebp-18h]
  float v46; // [esp+44h] [ebp-18h]
  float v47; // [esp+48h] [ebp-14h]
  float v48; // [esp+48h] [ebp-14h]
  float v49; // [esp+4Ch] [ebp-10h]
  float v50; // [esp+4Ch] [ebp-10h]
  float v51; // [esp+50h] [ebp-Ch]
  float v52; // [esp+50h] [ebp-Ch]
  float v53; // [esp+54h] [ebp-8h]
  float v54; // [esp+54h] [ebp-8h]
  float v55; // [esp+54h] [ebp-8h]
  float v56; // [esp+58h] [ebp-4h]
  float v57; // [esp+58h] [ebp-4h]
  float v58; // [esp+58h] [ebp-4h]
  float v59; // [esp+58h] [ebp-4h]
  float v60; // [esp+6Ch] [ebp+10h]
  float v61; // [esp+6Ch] [ebp+10h]
  float v62; // [esp+6Ch] [ebp+10h]
  float v63; // [esp+6Ch] [ebp+10h]

  v4 = *a3;
  v5 = a3[1];
  v43 = a3[4];
  v40 = a3[5];
  v45 = a3[8];
  v56 = a3[9];
  v47 = a3[12];
  v60 = a3[13];
  v51 = v40 * v4 - v43 * v5;
  v49 = a3[14];
  v53 = v56 * v4 - v45 * v5;
  v34 = v60 * v4 - v47 * v5;
  v29 = v56 * v43 - v45 * v40;
  v30 = v60 * v43 - v47 * v40;
  v6 = v60;
  v61 = a3[15];
  v32 = v6 * v45 - v47 * v56;
  v7 = a3[2];
  v8 = a3[3];
  v9 = a3[6];
  v36 = a3[6];
  v10 = a3[7];
  v41 = a3[7];
  v11 = a3[10];
  v38 = a3[10];
  v12 = a3[11];
  v57 = a3[11];
  v22 = v7 * v29 - v9 * v53 + v11 * v51;
  v23 = v9 * v34 - v49 * v51 - v7 * v30;
  v24 = v7 * v32 - v11 * v34 + v49 * v53;
  v25 = v11 * v30 - v49 * v29 - v9 * v32;
  v26 = v53 * v10 - v51 * v12 - v29 * v8;
  v27 = v30 * v8 - v34 * v10 + v51 * v61;
  v28 = v34 * v12 - v53 * v61 - v32 * v8;
  v35 = v32 * v10 - v30 * v12 + v29 * v61;
  v52 = v7 * v10 - v9 * v8;
  v54 = v7 * v57 - v38 * v8;
  v13 = v7 * v61 - v49 * v8;
  v44 = a3[4];
  v46 = a3[8];
  v14 = v36 * v57 - v38 * v41;
  v15 = v36 * v61 - v49 * v41;
  v16 = v49 * v57;
  v58 = a3[9];
  v48 = a3[12];
  v17 = v38 * v61 - v16;
  v18 = a3[1];
  v19 = a3[5];
  v62 = a3[13];
  v50 = v54 * v19 - v52 * v58 - v14 * v18;
  v39 = v15 * v18 - v13 * v19 + v52 * v62;
  v37 = v13 * v58 - v54 * v62 - v17 * v18;
  v31 = v17 * v19 - v15 * v58 + v14 * v62;
  v63 = v14 * *a3 - v54 * v44 + v52 * v46;
  v59 = v13 * v44 - v52 * v48 - v15 * *a3;
  v42 = *a3 * v17 - v13 * v46 + v54 * v48;
  v20 = v50 * v48 + v39 * v46 + v37 * v44 + v31 * *a3;
  if ( a2 )
    *a2 = v20;
  v55 = 1.0 / v20;
  result = finite(v55);
  if ( result )
  {
    *a1 = v31 * v55;
    a1[1] = v37 * v55;
    a1[2] = v39 * v55;
    a1[3] = v50 * v55;
    v33 = v15 * v46 - v14 * v48 - v17 * v44;
    a1[4] = v33 * v55;
    a1[5] = v42 * v55;
    a1[6] = v59 * v55;
    a1[7] = v63 * v55;
    a1[8] = v35 * v55;
    a1[9] = v28 * v55;
    a1[10] = v27 * v55;
    a1[11] = v26 * v55;
    a1[12] = v25 * v55;
    a1[13] = v24 * v55;
    a1[14] = v23 * v55;
    a1[15] = v22 * v55;
    return (int)a1;
  }
  return result;
}

// FUN_1000e012 @ 0x1000E012
// [binja] int32_t __stdcall sub_1000e012(float arg1, float arg2, float arg3)
int FUN_1000e012(float arg1, float arg2, float arg3)
{
  float v4; // [esp+1Ch] [ebp+10h]

  grim_select_renderer_backend(1);
  return off_10053CDC(SLODWORD(arg1), arg2, arg3, v4);
}

// sub_1000E040 @ 0x1000E040
int __stdcall sub_1000E040(int a1, int a2, int a3, int a4)
{
  *(float *)(a1 + 56) = 0.0;
  *(_DWORD *)a1 = a2;
  *(float *)(a1 + 52) = 0.0;
  *(_DWORD *)(a1 + 20) = a3;
  *(float *)(a1 + 48) = 0.0;
  *(_DWORD *)(a1 + 40) = a4;
  *(float *)(a1 + 44) = 0.0;
  *(float *)(a1 + 36) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 16) = 0.0;
  *(float *)(a1 + 12) = 0.0;
  *(float *)(a1 + 8) = 0.0;
  *(float *)(a1 + 4) = 0.0;
  *(float *)(a1 + 60) = 1.0;
  return a1;
}

// FUN_1000e09c @ 0x1000E09C
// [binja] int32_t __stdcall sub_1000e09c(float arg1, float arg2, float arg3)
int FUN_1000e09c(float arg1, float arg2, float arg3)
{
  float v4; // [esp+1Ch] [ebp+10h]

  grim_select_renderer_backend(1);
  return off_10053CC0(SLODWORD(arg1), arg2, arg3, v4);
}

// sub_1000E0CA @ 0x1000E0CA
int __stdcall sub_1000E0CA(int a1, int a2, int a3, int a4)
{
  *(float *)(a1 + 44) = 0.0;
  *(_DWORD *)(a1 + 48) = a2;
  *(float *)(a1 + 36) = 0.0;
  *(_DWORD *)(a1 + 52) = a3;
  *(float *)(a1 + 32) = 0.0;
  *(_DWORD *)(a1 + 56) = a4;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 16) = 0.0;
  *(float *)(a1 + 12) = 0.0;
  *(float *)(a1 + 8) = 0.0;
  *(float *)(a1 + 4) = 0.0;
  *(float *)(a1 + 60) = 1.0;
  *(float *)(a1 + 40) = 1.0;
  *(float *)(a1 + 20) = 1.0;
  *(float *)a1 = 1.0;
  return a1;
}

// FUN_1000e126 @ 0x1000E126
// [binja] int32_t __stdcall sub_1000e126(float arg1)
int FUN_1000e126(float arg1)
{
  float v2; // [esp+Ch] [ebp+8h]

  grim_select_renderer_backend(1);
  return off_10053CD0(SLODWORD(arg1), v2);
}

// FUN_1000e142 @ 0x1000E142
// [binja] float* __stdcall sub_1000e142(float* arg1, float arg2)
float *FUN_1000e142(float *arg1, float arg2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v3 = cos(arg2);
  v4 = sin(arg2);
  *arg1 = 1.0;
  arg1[1] = 0.0;
  arg1[6] = v4;
  arg1[2] = 0.0;
  arg1[3] = 0.0;
  arg1[4] = 0.0;
  arg1[5] = v3;
  arg1[7] = 0.0;
  arg1[8] = 0.0;
  arg1[9] = -v4;
  arg1[10] = v3;
  arg1[11] = 0.0;
  arg1[12] = 0.0;
  arg1[13] = 0.0;
  arg1[14] = 0.0;
  arg1[15] = 1.0;
  return arg1;
}

// FUN_1000e1bc @ 0x1000E1BC
// [binja] int32_t __stdcall sub_1000e1bc(float arg1)
int FUN_1000e1bc(float arg1)
{
  float v2; // [esp+Ch] [ebp+8h]

  grim_select_renderer_backend(1);
  return off_10053CD4(SLODWORD(arg1), v2);
}

// FUN_1000e1d8 @ 0x1000E1D8
// [binja] float* __stdcall sub_1000e1d8(float* arg1, float arg2)
float *FUN_1000e1d8(float *arg1, float arg2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v4 = cos(arg2);
  v3 = sin(arg2);
  *arg1 = v4;
  arg1[1] = 0.0;
  arg1[2] = -v3;
  arg1[3] = 0.0;
  arg1[4] = 0.0;
  arg1[5] = 1.0;
  arg1[6] = 0.0;
  arg1[7] = 0.0;
  arg1[8] = v3;
  arg1[9] = 0.0;
  arg1[10] = v4;
  arg1[11] = 0.0;
  arg1[12] = 0.0;
  arg1[13] = 0.0;
  arg1[14] = 0.0;
  arg1[15] = 1.0;
  return arg1;
}

// FUN_1000e253 @ 0x1000E253
// [binja] int32_t __stdcall sub_1000e253(float arg1)
int FUN_1000e253(float arg1)
{
  float v2; // [esp+Ch] [ebp+8h]

  grim_select_renderer_backend(1);
  return off_10053CD8(SLODWORD(arg1), v2);
}

// FUN_1000e26f @ 0x1000E26F
// [binja] float* __stdcall sub_1000e26f(float* arg1, float arg2)
float *FUN_1000e26f(float *arg1, float arg2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v3 = cos(arg2);
  v4 = sin(arg2);
  *arg1 = v3;
  arg1[1] = v4;
  arg1[2] = 0.0;
  arg1[3] = 0.0;
  arg1[4] = -v4;
  arg1[5] = v3;
  arg1[6] = 0.0;
  arg1[7] = 0.0;
  arg1[8] = 0.0;
  arg1[9] = 0.0;
  arg1[10] = 1.0;
  arg1[11] = 0.0;
  arg1[12] = 0.0;
  arg1[13] = 0.0;
  arg1[14] = 0.0;
  arg1[15] = 1.0;
  return arg1;
}

// FUN_1000e2eb @ 0x1000E2EB
// [binja] int32_t __stdcall sub_1000e2eb(int32_t arg1, float arg2)
int FUN_1000e2eb(int arg1, float arg2)
{
  float v3; // [esp+10h] [ebp+Ch]

  grim_select_renderer_backend(1);
  return off_10053D00(arg1, SLODWORD(arg2), v3);
}

// FUN_1000e30b @ 0x1000E30B
// [binja] float* __stdcall sub_1000e30b(float* arg1, float arg2, float arg3)
float *FUN_1000e30b(float *arg1, float arg2, float arg3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  double v8; // st3
  double v9; // st2
  double v10; // st3
  float v11; // [esp+8h] [ebp-1Ch] BYREF
  float v12; // [esp+Ch] [ebp-18h]
  float v13; // [esp+10h] [ebp-14h]
  float *v14; // [esp+14h] [ebp-10h]
  float *v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+1Ch] [ebp-8h] BYREF
  float v17; // [esp+20h] [ebp-4h] BYREF
  float arg2a; // [esp+30h] [ebp+Ch]
  float arg3a; // [esp+34h] [ebp+10h]
  float arg3b; // [esp+34h] [ebp+10h]

  v15 = &v17;
  v14 = &v16;
  v17 = cos(arg3);
  v16 = sin(arg3);
  v11 = *(float *)LODWORD(arg2);
  arg3a = 1.0 - v17;
  v12 = *(float *)(LODWORD(arg2) + 4);
  v13 = *(float *)(LODWORD(arg2) + 8);
  sub_1000CE76(&v11, &v11);
  v4 = arg3a;
  arg3b = v12 * v11 * arg3a;
  v5 = v13;
  v6 = v12 * v13 * v4;
  v7 = v13 * v11 * v4;
  *arg1 = v11 * v11 * v4 + v17;
  v8 = v5 * v16;
  arg1[1] = arg3b + v8;
  v9 = v12 * v16;
  arg2a = v9;
  arg1[2] = v7 - v9;
  arg1[3] = 0.0;
  arg1[4] = arg3b - v8;
  arg1[5] = v12 * v12 * v4 + v17;
  v10 = v11 * v16;
  arg1[6] = v10 + v6;
  arg1[7] = 0.0;
  arg1[8] = arg2a + v7;
  arg1[9] = v6 - v10;
  arg1[10] = v5 * v5 * v4 + v17;
  arg1[11] = 0.0;
  arg1[12] = 0.0;
  arg1[13] = 0.0;
  arg1[14] = 0.0;
  arg1[15] = 1.0;
  return arg1;
}

// sub_1000E40D @ 0x1000E40D
int sub_1000E40D()
{
  grim_select_renderer_backend(1u);
  return off_10053CF0();
}

// sub_1000E420 @ 0x1000E420
float *__stdcall sub_1000E420(float *a1, float *a2)
{
  double v3; // st7
  double v4; // st6
  double v5; // st5
  double v6; // st4
  double v7; // st3
  float *result; // eax
  double v9; // st2
  float v10; // [esp+0h] [ebp-10h]
  float v11; // [esp+4h] [ebp-Ch]
  float v12; // [esp+8h] [ebp-8h]
  float v13; // [esp+Ch] [ebp-4h]
  float v14; // [esp+Ch] [ebp-4h]
  float v15; // [esp+18h] [ebp+8h]
  float v16; // [esp+1Ch] [ebp+Ch]
  float v17; // [esp+1Ch] [ebp+Ch]

  v13 = *a2 * 2.0;
  v16 = a2[1] * 2.0;
  v3 = 2.0 * a2[2];
  v4 = v13 * a2[3];
  v5 = v16 * a2[3];
  v6 = v3 * a2[3];
  v10 = v13 * *a2;
  v14 = v16 * *a2;
  v12 = v3 * *a2;
  v11 = v16 * a2[1];
  v17 = v3 * a2[1];
  v7 = v3 * a2[2];
  result = a1;
  *a1 = 1.0 - v11 - v7;
  a1[1] = v14 + v6;
  a1[2] = v12 - v5;
  a1[3] = 0.0;
  a1[4] = v14 - v6;
  v9 = 1.0 - v10;
  v15 = v9;
  result[5] = v9 - v7;
  result[6] = v17 + v4;
  result[7] = 0.0;
  result[8] = v12 + v5;
  result[9] = v17 - v4;
  result[10] = v15 - v11;
  result[11] = 0.0;
  result[12] = 0.0;
  result[13] = 0.0;
  result[14] = 0.0;
  result[15] = 1.0;
  return result;
}

// FUN_1000e502 @ 0x1000E502
// [binja] int32_t __stdcall sub_1000e502(float arg1, float arg2, float arg3)
int FUN_1000e502(float arg1, float arg2, float arg3)
{
  float v4; // [esp+1Ch] [ebp+10h]

  grim_select_renderer_backend(1);
  return off_10053CF8(SLODWORD(arg1), arg2, arg3, v4);
}

// sub_1000E530 @ 0x1000E530
int sub_1000E530()
{
  grim_select_renderer_backend(1u);
  return off_10053CF4();
}

// FUN_1000e541 @ 0x1000E541
// [binja] int32_t __stdcall sub_1000e541(int32_t arg1, float arg2, int32_t arg3, int32_t arg4, int32_t arg5)
int FUN_1000e541(int arg1, float arg2, int arg3, int arg4, int arg5)
{
  grim_select_renderer_backend(1);
  return off_10053CFC(arg1, arg2, arg3, arg4, arg5);
}

// FUN_1000e568 @ 0x1000E568
// [binja] float* __stdcall sub_1000e568(float* arg1, float arg2, float* arg3, int32_t arg4, float* arg5)
float *FUN_1000e568(float *arg1, float arg2, float *arg3, int arg4, float *arg5)
{
  int v6; // [esp+0h] [ebp-50h]
  int v7; // [esp+4h] [ebp-4Ch]
  int v8; // [esp+8h] [ebp-48h]
  _BYTE v9[12]; // [esp+10h] [ebp-40h] BYREF
  _BYTE v10[52]; // [esp+1Ch] [ebp-34h] BYREF

  arg1[14] = 0.0;
  arg1[13] = 0.0;
  arg1[12] = 0.0;
  arg1[11] = 0.0;
  arg1[9] = 0.0;
  arg1[8] = 0.0;
  arg1[7] = 0.0;
  arg1[6] = 0.0;
  arg1[4] = 0.0;
  arg1[3] = 0.0;
  arg1[2] = 0.0;
  arg1[1] = 0.0;
  *arg1 = arg2;
  arg1[5] = arg2;
  arg1[10] = arg2;
  arg1[15] = 1.0;
  if ( arg4 )
  {
    sub_1000E41A(v9, arg4, v6, v7, v8);
    if ( arg3 )
    {
      arg1[12] = arg1[12] - *arg3;
      arg1[13] = arg1[13] - arg3[1];
      arg1[14] = arg1[14] - arg3[2];
      sub_1000D773(arg1, arg1, v10);
      arg1[12] = *arg3 + arg1[12];
      arg1[13] = arg1[13] + arg3[1];
      arg1[14] = arg3[2] + arg1[14];
    }
    else
    {
      sub_1000D773(arg1, arg1, v10);
    }
  }
  if ( arg5 )
  {
    arg1[12] = *arg5 + arg1[12];
    arg1[13] = arg5[1] + arg1[13];
    arg1[14] = arg5[2] + arg1[14];
  }
  return arg1;
}

// sub_1000E675 @ 0x1000E675
float *__stdcall sub_1000E675(float *a1, float *a2, float *a3)
{
  long double v3; // st7
  float *result; // eax
  long double v5; // st7
  long double v6; // st7

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  result = a2;
  if ( v3 <= 1.1754944e-38 )
  {
    if ( a2 )
    {
      *a2 = 1.0;
      a2[1] = 0.0;
      a2[2] = 0.0;
    }
    result = a3;
    if ( a3 )
      *a3 = 0.0;
  }
  else
  {
    if ( a2 )
    {
      v5 = 1.0 / sqrt(v3);
      *a2 = v5 * *a1;
      a2[1] = v5 * a1[1];
      a2[2] = v5 * a1[2];
    }
    if ( a3 )
    {
      v6 = acos(a1[3]);
      *a3 = v6 + v6;
    }
  }
  return result;
}

// sub_1000E71F @ 0x1000E71F
float *__stdcall sub_1000E71F(float *a1, float *a2)
{
  double v3; // st7
  float *result; // eax
  long double v5; // st6
  double v6; // st7
  double v7; // st6
  int v8; // ebx
  int v9; // edx
  int v10; // edi
  int v11; // esi
  long double v12; // st7
  long double v13; // st6
  long double v14; // st7
  double v15; // st6
  int v16; // ebx
  int v17; // edi
  int v18; // esi
  double v19; // st6
  int v20; // edi
  _DWORD v21[3]; // [esp+0h] [ebp-1Ch]
  float v22; // [esp+Ch] [ebp-10h]
  float v23; // [esp+10h] [ebp-Ch]
  float v24; // [esp+14h] [ebp-8h]
  int v25; // [esp+18h] [ebp-4h]
  int v26; // [esp+24h] [ebp+8h]
  int v27; // [esp+28h] [ebp+Ch]

  v3 = a2[5] + *a2 + a2[10];
  if ( v3 <= 0.0 )
  {
    v21[2] = 0;
    v6 = *a2 - a2[5] - a2[10];
    v22 = v6;
    v21[0] = 1;
    v7 = a2[5];
    v21[1] = 2;
    v23 = v7 - *a2 - a2[10];
    v24 = a2[10] - (a2[5] + *a2);
    v8 = v6 < v23;
    v27 = v8;
    if ( *(&v22 + v8) < (double)v24 )
    {
      v8 = 2;
      v27 = 2;
    }
    v9 = v8;
    result = a1;
    v11 = v21[v8];
    v12 = sqrt(*(&v22 + v8) + 1.0);
    v25 = v21[v8];
    v10 = v25;
    v13 = v12 * 0.5;
    a1[v9] = v13;
    v14 = 0.25 / v13;
    v15 = a2[v11 * 4 + v8] + a2[4 * v8 + v10];
    v16 = 4 * v21[v11] + v27;
    v26 = v21[v11];
    v17 = v21[v11];
    result[v11] = v15 * v14;
    v18 = v17 + v11 * 4;
    v19 = a2[v16] + a2[v17 + v9 * 4];
    v20 = v25;
    result[v26] = v19 * v14;
    result[3] = (a2[v18] - a2[v20 + v26 * 4]) * v14;
  }
  else
  {
    v5 = sqrt(v3 + 1.0) * 0.5;
    a1[3] = v5;
    *a1 = (a2[6] - a2[9]) * (0.25 / v5);
    a1[1] = (a2[8] - a2[2]) * (0.25 / v5);
    a1[2] = (a2[1] - a2[4]) * (0.25 / v5);
    return a1;
  }
  return result;
}

// FUN_1000e853 @ 0x1000E853
// [binja] int32_t __stdcall sub_1000e853(int32_t arg1, float arg2)
int FUN_1000e853(int arg1, float arg2)
{
  float v3; // [esp+10h] [ebp+Ch]

  grim_select_renderer_backend(1);
  return off_10053CCC(arg1, SLODWORD(arg2), v3);
}

// FUN_1000e873 @ 0x1000E873
// [binja] float* __stdcall sub_1000e873(float arg1, float arg2, float arg3)
float *FUN_1000e873(float arg1, float arg2, float arg3)
{
  float v5[3]; // [esp+0h] [ebp-14h] BYREF
  float *v6; // [esp+10h] [ebp-4h]
  float arg1a; // [esp+1Ch] [ebp+8h]
  float arg2a; // [esp+20h] [ebp+Ch]

  sub_1000CE76(v5, LODWORD(arg2));
  v6 = (float *)(LODWORD(arg1) + 12);
  arg1a = arg3 * 0.5;
  *v6 = cos(arg1a);
  arg2a = sin(arg1a);
  *(float *)LODWORD(arg1) = v5[0] * arg2a;
  *(float *)(LODWORD(arg1) + 4) = v5[1] * arg2a;
  *(float *)(LODWORD(arg1) + 8) = v5[2] * arg2a;
  return (float *)LODWORD(arg1);
}

// FUN_1000e8cf @ 0x1000E8CF
// [binja] int32_t __stdcall sub_1000e8cf(float arg1, float arg2, float arg3)
int FUN_1000e8cf(float arg1, float arg2, float arg3)
{
  float v4; // [esp+1Ch] [ebp+10h]

  grim_select_renderer_backend(1);
  return off_10053CBC(SLODWORD(arg1), arg2, arg3, v4);
}

// sub_1000E903 @ 0x1000E903
float *__stdcall sub_1000E903(float *a1, float a2, float a3, float a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6
  float v9; // [esp+8h] [ebp-18h]
  float v10; // [esp+Ch] [ebp-14h]
  float v11; // [esp+10h] [ebp-10h]
  float v12; // [esp+14h] [ebp-Ch]
  float v13; // [esp+18h] [ebp-8h]
  float v14; // [esp+1Ch] [ebp-4h]
  float v15; // [esp+30h] [ebp+10h]
  float v16; // [esp+30h] [ebp+10h]
  float v17; // [esp+34h] [ebp+14h]

  v9 = a4 * 0.5;
  v14 = cos(v9);
  v17 = sin(v9);
  v15 = a3 * 0.5;
  v12 = cos(v15);
  v10 = sin(v15);
  v16 = a2 * 0.5;
  v13 = cos(v16);
  v11 = sin(v16);
  v5 = v11 * v12;
  v6 = v13 * v10;
  *a1 = v14 * v6 + v5 * v17;
  a1[1] = v5 * v14 - v6 * v17;
  v7 = v13 * v12;
  v8 = v11 * v10;
  a1[2] = v7 * v17 - v8 * v14;
  a1[3] = v8 * v17 + v7 * v14;
  return a1;
}

// sub_1000E9DC @ 0x1000E9DC
int sub_1000E9DC()
{
  grim_select_renderer_backend(1u);
  return off_10053CA4();
}

// sub_1000E9EF @ 0x1000E9EF
float *__stdcall sub_1000E9EF(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = a3[3] * a2[1] - *a3 * a2[2] + a3[1] * a2[3] + a3[2] * *a2;
  v4 = a3[3] * a2[2] + *a3 * a2[1] - a3[1] * *a2 + a3[2] * a2[3];
  v5 = a3[3] * a2[3] - *a3 * *a2 - a3[1] * a2[1] - a3[2] * a2[2];
  *a1 = a3[3] * *a2 + *a3 * a2[3] + a3[1] * a2[2] - a3[2] * a2[1];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_1000EA92 @ 0x1000EA92
float *__stdcall sub_1000EA92(float *a1, float *a2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[4]; // [esp+10h] [ebp-10h] BYREF
  float v8; // [esp+2Ch] [ebp+Ch]

  v2 = a2;
  v8 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3];
  if ( float_near_equal(v8, 1.0) )
  {
    result = a1;
    if ( a1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = a1;
  if ( v8 > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(v8);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v7[2] = v5 * v2[2];
    v6 = v5 * v2[3];
    v2 = v7;
    v7[3] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4++;
    result[2] = *v4;
    result[3] = v4[1];
    return result;
  }
  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  a1[3] = 0.0;
  return result;
}

// sub_1000EB4B @ 0x1000EB4B
int sub_1000EB4B()
{
  grim_select_renderer_backend(1u);
  return off_10053D08();
}

// sub_1000EB5E @ 0x1000EB5E
float *__stdcall sub_1000EB5E(float *a1, float *a2)
{
  float *v3; // ecx
  double v4; // st7
  double v5; // st7
  float v7; // [esp+14h] [ebp+Ch]

  v3 = a1;
  v7 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3];
  if ( v7 <= 1.0842022e-19 )
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    v5 = 0.0;
    goto LABEL_5;
  }
  *a1 = -*a2;
  a1[1] = -a2[1];
  a1[2] = -a2[2];
  a1[3] = a2[3];
  if ( !float_near_equal(v7, 1.0) )
  {
    v4 = 1.0 / v7;
    *v3 = v4 * *v3;
    v3[1] = v4 * v3[1];
    v3[2] = v4 * v3[2];
    v5 = v4 * v3[3];
LABEL_5:
    v3[3] = v5;
  }
  return v3;
}

// sub_1000EC18 @ 0x1000EC18
float *__stdcall sub_1000EC18(float *a1, float *a2)
{
  long double v3; // st7
  bool v4; // zf
  float *result; // eax
  double v6; // st7
  float v7; // [esp+Ch] [ebp-4h]
  float v8; // [esp+1Ch] [ebp+Ch]

  if ( a2[3] >= 1.0 )
  {
    result = a1;
    goto LABEL_5;
  }
  v3 = acos(a2[3]);
  v7 = sin(v3);
  v4 = !float_near_equal(v7, 0.0);
  result = a1;
  if ( !v4 )
  {
LABEL_5:
    *result = *a2;
    result[1] = a2[1];
    result[2] = a2[2];
    goto LABEL_6;
  }
  v8 = v3;
  v6 = v8 / v7;
  *a1 = v6 * *a2;
  a1[1] = v6 * a2[1];
  a1[2] = v6 * a2[2];
LABEL_6:
  result[3] = 0.0;
  return result;
}

// sub_1000EC9C @ 0x1000EC9C
float *__stdcall sub_1000EC9C(float *a1, float *a2)
{
  float *v2; // ecx
  double v3; // st7
  float v5; // [esp+10h] [ebp-4h]
  float v6; // [esp+20h] [ebp+Ch]

  v5 = sqrt(*a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2]);
  a1[3] = cos(v5);
  v6 = sin(v5);
  if ( float_near_equal(v6, 0.0) )
  {
    if ( a1 != v2 )
    {
      *a1 = *v2;
      a1[1] = v2[1];
      a1[2] = v2[2];
    }
  }
  else
  {
    v3 = v6 / v5;
    *a1 = v3 * *v2;
    a1[1] = v3 * v2[1];
    a1[2] = v3 * v2[2];
  }
  return a1;
}

// FUN_1000ed37 @ 0x1000ED37
// [binja] int32_t __stdcall sub_1000ed37(int32_t arg1, int32_t arg2, float arg3)
int FUN_1000ed37(int arg1, int arg2, float arg3)
{
  float v4; // [esp+14h] [ebp+10h]

  grim_select_renderer_backend(1);
  return off_10053CE4(arg1, arg2, SLODWORD(arg3), v4);
}

// sub_1000ED61 @ 0x1000ED61
float *__stdcall sub_1000ED61(float *a1, float *a2, float *a3, float a4)
{
  double v5; // st7
  double v7; // st6
  double v8; // st5
  long double v9; // st6
  long double v10; // st6
  long double v11; // st6
  float v13; // [esp+0h] [ebp-4h]
  float v14; // [esp+10h] [ebp+Ch]
  float v15; // [esp+14h] [ebp+10h]
  float v16; // [esp+14h] [ebp+10h]

  v5 = 1.0 - a4;
  v7 = *a2 * *a3 + a3[2] * a2[2] + a3[1] * a2[1] + a3[3] * a2[3];
  if ( v7 < 0.0 )
    v14 = -1.0;
  else
    v14 = 1.0;
  v8 = v14 * v7;
  if ( 1.0 - v8 <= 0.00000011920929 )
  {
    v10 = a4;
  }
  else
  {
    v9 = sqrt(1.0 - v8 * v8);
    v15 = v8;
    v16 = atan2(v9, v15);
    v13 = 1.0 / v9;
    v5 = sin(v16 * v5) * v13;
    v10 = sin(v16 * a4) * v13;
  }
  v11 = v10 * v14;
  *a1 = v5 * *a2 + v11 * *a3;
  a1[1] = v11 * a3[1] + v5 * a2[1];
  a1[2] = v11 * a3[2] + v5 * a2[2];
  a1[3] = v11 * a3[3] + v5 * a2[3];
  return a1;
}

// FUN_1000ee44 @ 0x1000EE44
// [binja] int32_t __stdcall sub_1000ee44(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000ee44(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  grim_select_renderer_backend(1);
  return off_10053D04(arg1, arg2, arg3, arg4, arg5, arg6);
}

// FUN_1000ee6e @ 0x1000EE6E
// [binja] int32_t __stdcall sub_1000ee6e(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int FUN_1000ee6e(int arg1, int arg2, int arg3, int arg4, int arg5, float arg6)
{
  float v7; // [esp+0h] [ebp-24h]
  int v8[4]; // [esp+4h] [ebp-20h] BYREF
  int v9[4]; // [esp+14h] [ebp-10h] BYREF

  j_FUN_1000ed37((int)v8, arg2, arg5, arg6);
  j_FUN_1000ed37((int)v9, arg3, arg4, arg6);
  v7 = (1.0 - arg6) * arg6 + (1.0 - arg6) * arg6;
  j_FUN_1000ed37(arg1, (int)v8, (int)v9, v7);
  return arg1;
}

// sub_1000EEC5 @ 0x1000EEC5
int sub_1000EEC5()
{
  grim_select_renderer_backend(1u);
  return off_10053D0C();
}

// sub_1000EED6 @ 0x1000EED6
int __stdcall sub_1000EED6(int a1, int a2, int a3, int a4, float a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053CE8(a1, a2, a3, a4, a5, a6);
}

// FUN_1000ef05 @ 0x1000EF05
// [binja] int32_t* __stdcall sub_1000ef05(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int *FUN_1000ef05(int *arg1, int *arg2, int arg3, int arg4, float arg5, float arg6)
{
  float b; // [esp+4h] [ebp-28h]
  int v8[4]; // [esp+Ch] [ebp-20h] BYREF
  int v9[4]; // [esp+1Ch] [ebp-10h] BYREF
  float arg5a; // [esp+44h] [ebp+18h]

  arg5a = arg5 + arg6;
  if ( float_near_equal(arg5a, 0.0) )
  {
    if ( arg1 != arg2 )
    {
      *arg1 = *arg2;
      arg1[1] = arg2[1];
      arg1[2] = arg2[2];
      arg1[3] = arg2[3];
    }
  }
  else
  {
    j_FUN_1000ed37((int)v8, (int)arg2, arg3, arg5a);
    j_FUN_1000ed37((int)v9, (int)arg2, arg4, arg5a);
    b = arg6 / arg5a;
    j_FUN_1000ed37((int)arg1, (int)v8, (int)v9, b);
  }
  return arg1;
}

// sub_1000EF90 @ 0x1000EF90
int sub_1000EF90()
{
  grim_select_renderer_backend(1u);
  return off_10053CAC();
}

// sub_1000EFA3 @ 0x1000EFA3
float *__stdcall sub_1000EFA3(float *a1, float *a2)
{
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7; // [esp+18h] [ebp+Ch]

  v7 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2];
  if ( float_near_equal(v7, 1.0) )
  {
    result = a1;
    if ( a1 != a2 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      a1[1] = *v4++;
      a1[2] = *v4;
      a1[3] = v4[1];
    }
  }
  else
  {
    result = a1;
    if ( v7 <= 1.1754944e-38 )
    {
      *a1 = 0.0;
      a1[1] = 0.0;
      a1[2] = 0.0;
      v6 = 0.0;
    }
    else
    {
      v5 = 1.0 / sqrt(v7);
      *a1 = v5 * *a2;
      a1[1] = v5 * a2[1];
      a1[2] = v5 * a2[2];
      v6 = v5 * a2[3];
    }
    a1[3] = v6;
  }
  return result;
}

// sub_1000F054 @ 0x1000F054
float *__stdcall sub_1000F054(float *a1, float *a2, float *a3, float *a4)
{
  double v4; // st7
  double v5; // st6
  float v7; // [esp+1Ch] [ebp+Ch]

  v4 = *a2 * *a3 + a2[1] * a3[1] + a3[2] * a2[2];
  v5 = v4 - (*a2 * *a4 + a4[2] * a2[2] + a2[1] * a4[1]);
  if ( v5 == 0.0 )
    return 0;
  v7 = (v4 + a2[3]) / v5;
  if ( !finite(v7) )
    return 0;
  *a1 = (*a4 - *a3) * v7 + *a3;
  a1[1] = (a4[1] - a3[1]) * v7 + a3[1];
  a1[2] = (a4[2] - a3[2]) * v7 + a3[2];
  return a1;
}

// sub_1000F103 @ 0x1000F103
int __stdcall sub_1000F103(int a1, float *a2, int a3)
{
  *(float *)a1 = *(float *)a3;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
  *(float *)(a1 + 12) = -(a2[1] * *(float *)(a3 + 4) + a2[2] * *(float *)(a3 + 8) + *a2 * *(float *)a3);
  return a1;
}

// sub_1000F148 @ 0x1000F148
float *__stdcall sub_1000F148(float *a1, float *a2, float *a3, float *a4)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  float v9; // [esp+Ch] [ebp-18h]
  float v10; // [esp+10h] [ebp-14h]
  float v11; // [esp+14h] [ebp-10h]
  float v12; // [esp+18h] [ebp-Ch]
  float v13; // [esp+1Ch] [ebp-8h]

  v4 = *a2 - *a3;
  v5 = a2[1] - a3[1];
  v6 = a2[2] - a3[2];
  v12 = *a2 - *a4;
  v13 = a2[1] - a4[1];
  v7 = a2[2] - a4[2];
  v9 = v7 * v5 - v13 * v6;
  v10 = v6 * v12 - v7 * v4;
  v11 = v13 * v4 - v12 * v5;
  *a1 = v9;
  a1[1] = v10;
  a1[2] = v11;
  sub_1000CE76(a1, a1);
  a1[3] = -(a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2);
  return a1;
}

// sub_1000F1F7 @ 0x1000F1F7
float *__stdcall sub_1000F1F7(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[12] * a2[3] + a3[4] * a2[1] + *a2 * *a3;
  v5 = a3[9] * a2[2] + a3[1] * *a2 + a3[13] * a2[3] + a3[5] * a2[1];
  v6 = a3[10] * a2[2] + a3[2] * *a2 + a3[14] * a2[3] + a3[6] * a2[1];
  v7 = a3[11] * a2[2] + a3[3] * *a2 + a3[15] * a2[3] + a3[7] * a2[1];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// FUN_1000f296 @ 0x1000F296
// [binja] int32_t* __stdcall sub_1000f296(int32_t* arg1, float arg2)
int *FUN_1000f296(int *arg1, float arg2)
{
  int *v2; // ecx
  int *result; // eax
  int v4; // ecx
  long double v5; // st7
  long double v6; // st7
  float v7; // [esp+8h] [ebp-8h]
  int v8; // [esp+Ch] [ebp-4h]
  float arg2a; // [esp+1Ch] [ebp+Ch]

  arg2a = *(float *)LODWORD(arg2) * *(float *)LODWORD(arg2)
        + *(float *)(LODWORD(arg2) + 4) * *(float *)(LODWORD(arg2) + 4);
  if ( float_near_equal(arg2a, 1.0) )
  {
    result = arg1;
    if ( arg1 == v2 )
      return result;
    *arg1 = *v2;
    v4 = v2[1];
    goto LABEL_4;
  }
  result = arg1;
  if ( arg2a > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(arg2a);
    v7 = v5 * *(float *)v2;
    v6 = v5 * *((float *)v2 + 1);
    *(float *)arg1 = v7;
    *(float *)&v8 = v6;
    v4 = v8;
LABEL_4:
    result[1] = v4;
    return result;
  }
  *(float *)arg1 = 0.0;
  *((float *)arg1 + 1) = 0.0;
  return result;
}

// FUN_1000f323 @ 0x1000F323
// [binja] float* __stdcall sub_1000f323(float* arg1, float* arg2, float* arg3)
float *FUN_1000f323(float *arg1, float *arg2, float *arg3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = arg3[4] * arg2[1] + *arg2 * *arg3 + arg3[12];
  v5 = arg3[1] * *arg2 + arg3[5] * arg2[1] + arg3[13];
  v6 = arg3[2] * *arg2 + arg3[6] * arg2[1] + arg3[14];
  v7 = arg3[3] * *arg2 + arg3[7] * arg2[1] + arg3[15];
  *arg1 = v4;
  arg1[1] = v5;
  arg1[2] = v6;
  arg1[3] = v7;
  return arg1;
}

// FUN_1000f38e @ 0x1000F38E
// [binja] float* __stdcall sub_1000f38e(float* arg1, float* arg2, float* arg3)
float *FUN_1000f38e(float *arg1, float *arg2, float *arg3)
{
  double v3; // st6
  double v4; // st7
  bool v5; // zf
  float *result; // eax
  double v7; // st7
  float a; // [esp+8h] [ebp-4h]

  v3 = *arg2 * arg3[1] + arg2[1] * arg3[5] + arg3[13];
  v4 = *arg2 * arg3[3] + arg2[1] * arg3[7] + arg3[15];
  *arg1 = *arg2 * *arg3 + arg2[1] * arg3[4] + arg3[12];
  arg1[1] = v3;
  a = v4;
  v5 = float_near_equal(a, 1.0) == 0;
  result = arg1;
  if ( v5 )
  {
    v7 = 1.0 / a;
    *arg1 = v7 * *arg1;
    arg1[1] = v7 * arg1[1];
  }
  return result;
}

// FUN_1000f40e @ 0x1000F40E
// [binja] float* __stdcall sub_1000f40e(float* arg1, float* arg2, float* arg3)
float *FUN_1000f40e(float *arg1, float *arg2, float *arg3)
{
  double v3; // st7
  double v4; // st6
  float v6; // [esp+0h] [ebp-8h]
  float v7; // [esp+4h] [ebp-4h]

  v6 = arg3[4] * arg2[1] + *arg2 * *arg3;
  v3 = arg3[1] * *arg2;
  v4 = arg3[5] * arg2[1];
  *arg1 = v6;
  v7 = v3 + v4;
  arg1[1] = v7;
  return arg1;
}

// FUN_1000f44a @ 0x1000F44A
// [binja] float* __stdcall sub_1000f44a(float* arg1, float arg2)
float *FUN_1000f44a(float *arg1, float arg2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[3]; // [esp+10h] [ebp-Ch] BYREF
  float arg2a; // [esp+28h] [ebp+Ch]

  v2 = (float *)LODWORD(arg2);
  arg2a = *(float *)LODWORD(arg2) * *(float *)LODWORD(arg2)
        + *(float *)(LODWORD(arg2) + 4) * *(float *)(LODWORD(arg2) + 4)
        + *(float *)(LODWORD(arg2) + 8) * *(float *)(LODWORD(arg2) + 8);
  if ( float_near_equal(arg2a, 1.0) )
  {
    result = arg1;
    if ( arg1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = arg1;
  if ( arg2a > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(arg2a);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v6 = v5 * v2[2];
    v2 = v7;
    v7[2] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4;
    result[2] = v4[1];
    return result;
  }
  *arg1 = 0.0;
  arg1[1] = 0.0;
  arg1[2] = 0.0;
  return result;
}

// FUN_1000f4ea @ 0x1000F4EA
// [binja] float* __stdcall sub_1000f4ea(float* arg1, float* arg2, float* arg3)
float *FUN_1000f4ea(float *arg1, float *arg2, float *arg3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7
  bool v6; // zf
  float *result; // eax
  double v8; // st7
  float a; // [esp+8h] [ebp-4h]

  v3 = *arg2 * arg3[1] + arg2[1] * arg3[5] + arg2[2] * arg3[9] + arg3[13];
  v4 = *arg2 * arg3[2] + arg2[1] * arg3[6] + arg2[2] * arg3[10] + arg3[14];
  v5 = *arg2 * arg3[3] + arg2[1] * arg3[7] + arg2[2] * arg3[11] + arg3[15];
  *arg1 = *arg2 * *arg3 + arg2[1] * arg3[4] + arg2[2] * arg3[8] + arg3[12];
  arg1[1] = v3;
  arg1[2] = v4;
  a = v5;
  v6 = float_near_equal(a, 1.0) == 0;
  result = arg1;
  if ( v6 )
  {
    v8 = 1.0 / a;
    *arg1 = v8 * *arg1;
    arg1[1] = v8 * arg1[1];
    arg1[2] = v8 * arg1[2];
  }
  return result;
}

// FUN_1000f5a9 @ 0x1000F5A9
// [binja] float* __stdcall sub_1000f5a9(float* arg1, int32_t arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5, int32_t* arg6)
float *FUN_1000f5a9(float *arg1, int arg2, int *arg3, int *arg4, int *arg5, int *arg6)
{
  int *v6; // esi
  int *v8; // [esp-4h] [ebp-54h]
  float v9[16]; // [esp+10h] [ebp-40h] BYREF

  v6 = (int *)v9;
  switch ( (arg4 != 0) | (2 * ((arg5 != 0) | (2 * (arg6 != 0)))) )
  {
    case 0:
      v9[14] = 0.0;
      v9[13] = 0.0;
      v9[12] = 0.0;
      v9[11] = 0.0;
      v9[9] = 0.0;
      v9[8] = 0.0;
      v9[7] = 0.0;
      v9[6] = 0.0;
      v9[4] = 0.0;
      v9[3] = 0.0;
      v9[2] = 0.0;
      v9[1] = 0.0;
      v9[15] = 1.0;
      v9[10] = 1.0;
      v9[5] = 1.0;
      v9[0] = 1.0;
      break;
    case 1:
      v6 = arg4;
      break;
    case 2:
      v6 = arg5;
      break;
    case 3:
      sub_1000D773(v9, arg5, arg4);
      break;
    case 4:
      v6 = arg6;
      break;
    case 5:
      v8 = arg4;
      goto LABEL_9;
    case 6:
      v8 = arg5;
LABEL_9:
      sub_1000D773(v9, arg6, v8);
      break;
    case 7:
      sub_1000D773(v9, arg6, arg5);
      sub_1000D773(v9, v9, arg4);
      break;
    default:
      break;
  }
  sub_1000D180(arg1, arg2, v6);
  if ( arg3 )
  {
    *arg1 = (*arg1 + 1.0) * (double)(unsigned int)arg3[2] * 0.5 + (double)(unsigned int)*arg3;
    arg1[1] = (1.0 - arg1[1]) * (double)(unsigned int)arg3[3] * 0.5 + (double)(unsigned int)arg3[1];
    arg1[2] = (*((float *)arg3 + 5) - *((float *)arg3 + 4)) * arg1[2] + *((float *)arg3 + 4);
  }
  return arg1;
}

// sub_1000F736 @ 0x1000F736
float *__stdcall sub_1000F736(float *a1, float *a2, int a3, int a4, int a5, int a6)
{
  double v6; // st7
  double v7; // st7
  int v9; // [esp+10h] [ebp-54h]
  float v10[16]; // [esp+24h] [ebp-40h] BYREF

  switch ( (a4 != 0) | (2 * ((a5 != 0) | (2 * (a6 != 0)))) )
  {
    case 0:
      v10[14] = 0.0;
      v10[13] = 0.0;
      v10[12] = 0.0;
      v10[11] = 0.0;
      v10[9] = 0.0;
      v10[8] = 0.0;
      v10[7] = 0.0;
      v10[6] = 0.0;
      v10[4] = 0.0;
      v10[3] = 0.0;
      v10[2] = 0.0;
      v10[1] = 0.0;
      v10[15] = 1.0;
      v10[10] = 1.0;
      v10[5] = 1.0;
      v10[0] = 1.0;
      break;
    case 1:
      sub_1000DC7F(v10, 0, a4);
      break;
    case 2:
      sub_1000DC7F(v10, 0, a5);
      break;
    case 3:
      sub_1000D773(v10, a5, a4);
      goto LABEL_11;
    case 4:
      sub_1000DC7F(v10, 0, a6);
      break;
    case 5:
      v9 = a4;
      goto LABEL_9;
    case 6:
      v9 = a5;
LABEL_9:
      sub_1000D773(v10, a6, v9);
      goto LABEL_11;
    case 7:
      sub_1000D773(v10, a6, a5);
      sub_1000D773(v10, v10, a4);
LABEL_11:
      sub_1000DC7F(v10, 0, v10);
      break;
    default:
      break;
  }
  if ( a3 )
  {
    v6 = *a2 - (double)*(unsigned int *)a3;
    *a1 = v6 / (double)*(unsigned int *)(a3 + 8) + v6 / (double)*(unsigned int *)(a3 + 8) - 1.0;
    v7 = a2[1] - (double)*(unsigned int *)(a3 + 4);
    a1[1] = -(v7 / (double)*(unsigned int *)(a3 + 12) + v7 / (double)*(unsigned int *)(a3 + 12) - 1.0);
    a1[2] = (a2[2] - *(float *)(a3 + 16)) / (*(float *)(a3 + 20) - *(float *)(a3 + 16));
    sub_1000D180(a1, a1, v10);
  }
  else
  {
    sub_1000D180(a1, a2, v10);
  }
  return a1;
}

// FUN_1000f8dc @ 0x1000F8DC
// [binja] float* __stdcall sub_1000f8dc(float* arg1, float arg2)
float *FUN_1000f8dc(float *arg1, float arg2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[4]; // [esp+10h] [ebp-10h] BYREF
  float arg2a; // [esp+2Ch] [ebp+Ch]

  v2 = (float *)LODWORD(arg2);
  arg2a = *(float *)LODWORD(arg2) * *(float *)LODWORD(arg2)
        + *(float *)(LODWORD(arg2) + 4) * *(float *)(LODWORD(arg2) + 4)
        + *(float *)(LODWORD(arg2) + 8) * *(float *)(LODWORD(arg2) + 8)
        + *(float *)(LODWORD(arg2) + 12) * *(float *)(LODWORD(arg2) + 12);
  if ( float_near_equal(arg2a, 1.0) )
  {
    result = arg1;
    if ( arg1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = arg1;
  if ( arg2a > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(arg2a);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v7[2] = v5 * v2[2];
    v6 = v5 * v2[3];
    v2 = v7;
    v7[3] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4++;
    result[2] = *v4;
    result[3] = v4[1];
    return result;
  }
  *arg1 = 0.0;
  arg1[1] = 0.0;
  arg1[2] = 0.0;
  arg1[3] = 0.0;
  return result;
}

// FUN_1000f995 @ 0x1000F995
// [binja] int32_t __stdcall sub_1000f995(int32_t arg1, float arg2, float arg3, float arg4)
int FUN_1000f995(int arg1, float arg2, float arg3, float arg4)
{
  int v5[4]; // [esp+Ch] [ebp-10h] BYREF

  j_FUN_1000e8cf((int)v5, arg2, arg3, arg4);
  ((void (__stdcall *)(int, int *))sub_1000E41A)(arg1, v5);
  return arg1;
}

// FUN_1000f9ce @ 0x1000F9CE
// [binja] float* __stdcall sub_1000f9ce(float* arg1, float* arg2, void* arg3, int32_t* arg4, float* arg5, int32_t arg6, float* arg7)
float *FUN_1000f9ce(float *arg1, float *arg2, void *arg3, int *arg4, float *arg5, int arg6, float *arg7)
{
  int v7; // ecx
  int v8; // ecx
  float *v9; // esi
  int v10; // eax
  char *v12; // [esp+Ch] [ebp-D0h]
  int v13; // [esp+10h] [ebp-CCh]
  int v14; // [esp+14h] [ebp-C8h]
  _DWORD v15[16]; // [esp+1Ch] [ebp-C0h] BYREF
  _BYTE v16[4]; // [esp+5Ch] [ebp-80h] BYREF
  char v17; // [esp+60h] [ebp-7Ch] BYREF
  _BYTE v18[52]; // [esp+68h] [ebp-74h] BYREF
  _BYTE v19[4]; // [esp+9Ch] [ebp-40h] BYREF
  _BYTE v20[60]; // [esp+A0h] [ebp-3Ch] BYREF

  if ( arg4 )
  {
    if ( arg3 )
    {
      *(float *)&v15[14] = 0.0;
      v7 = *arg4;
      *(float *)&v15[13] = 0.0;
      v15[0] = v7;
      v8 = arg4[1];
      *(float *)&v15[12] = 0.0;
      v15[10] = arg4[2];
      *(float *)&v15[11] = 0.0;
      v15[5] = v8;
      *(float *)&v15[9] = 0.0;
      *(float *)&v15[8] = 0.0;
      *(float *)&v15[7] = 0.0;
      *(float *)&v15[6] = 0.0;
      *(float *)&v15[4] = 0.0;
      *(float *)&v15[3] = 0.0;
      *(float *)&v15[2] = 0.0;
      *(float *)&v15[1] = 0.0;
      *(float *)&v15[15] = 1.0;
      sub_1000E41A(v16, arg3, v12, v13, v14);
      v12 = &v17;
      if ( arg2 )
      {
        sub_1000D9BC(v20);
        v9 = arg1;
        arg1[14] = 0.0;
        arg1[13] = 0.0;
        arg1[12] = 0.0;
        arg1[11] = 0.0;
        arg1[9] = 0.0;
        arg1[8] = 0.0;
        arg1[7] = 0.0;
        arg1[6] = 0.0;
        arg1[4] = 0.0;
        arg1[3] = 0.0;
        arg1[2] = 0.0;
        arg1[1] = 0.0;
        arg1[15] = 1.0;
        arg1[10] = 1.0;
        arg1[5] = 1.0;
        *arg1 = 1.0;
        arg1[12] = -*arg2;
        arg1[13] = -arg2[1];
        arg1[14] = -arg2[2];
        sub_1000D773(arg1, arg1, v19);
        sub_1000D773(v9, v9, v15);
        sub_1000D773(v9, v9, v16);
        arg1[12] = arg1[12] + *arg2;
        arg1[13] = arg2[1] + arg1[13];
        arg1[14] = arg1[14] + arg2[2];
      }
      else
      {
        v9 = arg1;
        sub_1000D9BC(arg1);
        sub_1000D773(v9, v9, v15);
        sub_1000D773(v9, v9, v16);
      }
    }
    else
    {
      v9 = arg1;
      arg1[14] = 0.0;
      arg1[13] = 0.0;
      arg1[12] = 0.0;
      arg1[11] = 0.0;
      arg1[9] = 0.0;
      arg1[8] = 0.0;
      arg1[7] = 0.0;
      arg1[6] = 0.0;
      arg1[4] = 0.0;
      arg1[3] = 0.0;
      arg1[2] = 0.0;
      arg1[1] = 0.0;
      *(_DWORD *)arg1 = *arg4;
      *((_DWORD *)arg1 + 5) = arg4[1];
      v10 = arg4[2];
      arg1[15] = 1.0;
      *((_DWORD *)arg1 + 10) = v10;
    }
  }
  else
  {
    v9 = arg1;
    arg1[14] = 0.0;
    arg1[13] = 0.0;
    arg1[12] = 0.0;
    arg1[11] = 0.0;
    arg1[9] = 0.0;
    arg1[8] = 0.0;
    arg1[7] = 0.0;
    arg1[6] = 0.0;
    arg1[4] = 0.0;
    arg1[3] = 0.0;
    arg1[2] = 0.0;
    arg1[1] = 0.0;
    arg1[15] = 1.0;
    arg1[10] = 1.0;
    arg1[5] = 1.0;
    *arg1 = 1.0;
  }
  if ( arg6 )
  {
    sub_1000E41A(v16, arg6, v12, v13, v14);
    if ( arg5 )
    {
      v9[12] = v9[12] - *arg5;
      v9[13] = v9[13] - arg5[1];
      v9[14] = v9[14] - arg5[2];
      sub_1000D773(v9, v9, v18);
      v9[12] = v9[12] + *arg5;
      v9[13] = v9[13] + arg5[1];
      v9[14] = v9[14] + arg5[2];
    }
    else
    {
      sub_1000D773(v9, v9, v18);
    }
  }
  if ( arg7 )
  {
    v9[12] = v9[12] + *arg7;
    v9[13] = arg7[1] + v9[13];
    v9[14] = arg7[2] + v9[14];
  }
  return v9;
}

// FUN_1000fc82 @ 0x1000FC82
// [binja] float* __stdcall sub_1000fc82(float* arg1, float* arg2, int32_t arg3)
float *FUN_1000fc82(float *arg1, float *arg2, int arg3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  double v8; // st3
  float v9; // [esp+8h] [ebp-18h]
  float v10; // [esp+Ch] [ebp-14h]
  float v11; // [esp+10h] [ebp-10h] BYREF
  float v12; // [esp+14h] [ebp-Ch]
  float v13; // [esp+18h] [ebp-8h]
  float v14; // [esp+1Ch] [ebp-4h]

  sub_1000EF9D(&v11, arg3);
  v4 = v12 * arg2[1] + v11 * *arg2 + v14 * arg2[3] + v13 * arg2[2];
  v5 = -v11;
  v6 = -v12;
  v7 = -v13;
  v9 = v7;
  v8 = -v14;
  v10 = v8;
  *arg1 = v5 * *arg2 + v4;
  arg1[4] = v6 * *arg2;
  arg1[8] = v7 * *arg2;
  arg1[12] = v8 * *arg2;
  arg1[1] = v5 * arg2[1];
  arg1[5] = v6 * arg2[1] + v4;
  arg1[9] = v7 * arg2[1];
  arg1[13] = v8 * arg2[1];
  arg1[2] = v5 * arg2[2];
  arg1[6] = v6 * arg2[2];
  arg1[10] = v7 * arg2[2] + v4;
  arg1[14] = v8 * arg2[2];
  arg1[3] = v5 * arg2[3];
  arg1[7] = v6 * arg2[3];
  arg1[11] = v9 * arg2[3];
  arg1[15] = v10 * arg2[3] + v4;
  return arg1;
}

// FUN_1000fd5c @ 0x1000FD5C
// [binja] float* __stdcall sub_1000fd5c(float* arg1, float arg2)
float *FUN_1000fd5c(float *arg1, float arg2)
{
  double v2; // st7
  double v4; // st6
  double v5; // st5
  float v6; // [esp+0h] [ebp-10h] BYREF
  float v7; // [esp+4h] [ebp-Ch]
  float v8; // [esp+8h] [ebp-8h]
  float v9; // [esp+Ch] [ebp-4h]
  float arg2a; // [esp+1Ch] [ebp+Ch]

  sub_1000EF9D(&v6, LODWORD(arg2));
  v2 = v6 * -2.0;
  v4 = v7 * -2.0;
  v5 = v8 * -2.0;
  arg2a = v5;
  *arg1 = v6 * v2 + 1.0;
  arg1[1] = v4 * v6;
  arg1[2] = v5 * v6;
  arg1[3] = 0.0;
  arg1[4] = v7 * v2;
  arg1[5] = v7 * v4 + 1.0;
  arg1[6] = v5 * v7;
  arg1[7] = 0.0;
  arg1[8] = v8 * v2;
  arg1[9] = v8 * v4;
  arg1[10] = v8 * v5 + 1.0;
  arg1[11] = 0.0;
  arg1[12] = v9 * v2;
  arg1[13] = v9 * v4;
  arg1[14] = v9 * arg2a;
  arg1[15] = 1.0;
  return arg1;
}

// sub_1000FE1B @ 0x1000FE1B
int __stdcall sub_1000FE1B(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7)
{
  unsigned __int8 v8; // c0
  unsigned __int8 v9; // c3
  unsigned __int8 v11; // c0
  unsigned __int8 v12; // c3
  unsigned __int8 v14; // c0
  unsigned __int8 v15; // c3
  int result; // eax
  _BYTE v17[16]; // [esp+8h] [ebp-44h] BYREF
  float v18; // [esp+18h] [ebp-34h] BYREF
  float v19; // [esp+1Ch] [ebp-30h]
  float v20; // [esp+20h] [ebp-2Ch]
  float v21; // [esp+24h] [ebp-28h]
  float v22; // [esp+28h] [ebp-24h] BYREF
  float v23; // [esp+2Ch] [ebp-20h]
  float v24; // [esp+30h] [ebp-1Ch]
  float v25; // [esp+34h] [ebp-18h]
  float v26; // [esp+38h] [ebp-14h] BYREF
  float v27; // [esp+3Ch] [ebp-10h]
  float v28; // [esp+40h] [ebp-Ch]
  float v29; // [esp+44h] [ebp-8h]
  float v30; // [esp+48h] [ebp-4h] BYREF
  float v31; // [esp+4Ch] [ebp+0h]
  float v32; // [esp+50h] [ebp+4h]
  float v33; // [esp+54h] [ebp+8h]
  float v34; // [esp+58h] [ebp+Ch] BYREF
  float v35; // [esp+5Ch] [ebp+10h]
  float v36; // [esp+60h] [ebp+14h]
  float v37; // [esp+64h] [ebp+18h]
  float v38; // [esp+68h] [ebp+1Ch] BYREF
  float v39; // [esp+6Ch] [ebp+20h]
  float v40; // [esp+70h] [ebp+24h]
  float v41; // [esp+74h] [ebp+28h]
  float v42; // [esp+78h] [ebp+2Ch] BYREF
  float v43; // [esp+7Ch] [ebp+30h]
  float v44; // [esp+80h] [ebp+34h]
  float v45; // [esp+84h] [ebp+38h]
  float v46; // [esp+88h] [ebp+3Ch] BYREF
  float v47; // [esp+8Ch] [ebp+40h]
  float v48; // [esp+90h] [ebp+44h]
  float v49; // [esp+94h] [ebp+48h]
  float v50; // [esp+98h] [ebp+4Ch] BYREF
  float v51; // [esp+9Ch] [ebp+50h]
  float v52; // [esp+A0h] [ebp+54h]
  float v53; // [esp+A4h] [ebp+58h]

  v22 = *a4;
  v23 = a4[1];
  v24 = a4[2];
  v25 = a4[3];
  v34 = *a5;
  v35 = a5[1];
  v36 = a5[2];
  v37 = a5[3];
  v46 = *a6;
  v47 = a6[1];
  v48 = a6[2];
  v51 = v23 - v35;
  v49 = a6[3];
  v52 = v24 - v36;
  v26 = *a7;
  v27 = a7[1];
  v53 = v25 - v37;
  v28 = a7[2];
  v29 = a7[3];
  if ( !(v8 | v9) )
  {
    v42 = -v22;
    v43 = -v23;
    v44 = -v24;
    v45 = -v25;
    v22 = v42;
    v23 = v43;
    v24 = v44;
    v25 = v45;
  }
  v51 = v35 - v47;
  v52 = v36 - v48;
  v53 = v37 - v49;
  if ( !(v11 | v12) )
  {
    v42 = -v46;
    v43 = -v47;
    v44 = -v48;
    v45 = -v49;
    v46 = v42;
    v47 = v43;
    v48 = v44;
    v49 = v45;
  }
  v51 = v47 - v27;
  v52 = v48 - v28;
  v53 = v49 - v29;
  if ( !(v14 | v15) )
  {
    v42 = -v26;
    v43 = -v27;
    v44 = -v28;
    v45 = -v29;
    v26 = v42;
    v27 = v43;
    v28 = v44;
    v29 = v45;
  }
  sub_1000EB58(&v42, &v34);
  sub_1000E9E9(&v38, &v42, &v22);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v18, &v30);
  sub_1000E9E9(&v38, &v42, &v46);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v50, &v30);
  v39 = v19 + v51;
  v40 = v20 + v52;
  v30 = (v18 + v50) * -0.25;
  v31 = v39 * -0.25;
  v32 = v40 * -0.25;
  v33 = (v21 + v53) * -0.25;
  sub_1000EC96(v17, &v30);
  sub_1000E9E9(&v38, &v34, v17);
  *a1 = v38;
  a1[1] = v39;
  a1[2] = v40;
  a1[3] = v41;
  sub_1000EB58(&v42, &v46);
  sub_1000E9E9(&v38, &v42, &v34);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v18, &v30);
  sub_1000E9E9(&v38, &v42, &v26);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v50, &v30);
  v39 = v19 + v51;
  v40 = v20 + v52;
  v30 = (v18 + v50) * -0.25;
  v31 = v39 * -0.25;
  v32 = v40 * -0.25;
  v33 = (v21 + v53) * -0.25;
  sub_1000EC96(v17, &v30);
  result = sub_1000E9E9(&v38, &v46, v17);
  *a2 = v38;
  a2[1] = v39;
  a2[2] = v40;
  a2[3] = v41;
  *a3 = v46;
  a3[1] = v47;
  a3[2] = v48;
  a3[3] = v49;
  return result;
}

// grim_d3d_debug_set_mute @ 0x100101F5
// loads DebugSetMute from d3d8/d3d8d and toggles D3D debug output
void grim_d3d_debug_set_mute(int mute)
{
  HMODULE LibraryA; // eax
  HMODULE v2; // eax

  if ( DebugSetMute )
    goto LABEL_10;
  if ( !DebugSetMute_0 )
  {
    if ( GetModuleHandleA("d3d8.dll") )
    {
      LibraryA = LoadLibraryA("d3d8.dll");
      if ( LibraryA )
        DebugSetMute = (int (__cdecl *)(_DWORD))GetProcAddress(LibraryA, "DebugSetMute");
    }
    if ( GetModuleHandleA("d3d8d.dll") )
    {
      v2 = LoadLibraryA("d3d8d.dll");
      if ( v2 )
        DebugSetMute_0 = GetProcAddress(v2, "DebugSetMute");
    }
    if ( !DebugSetMute )
    {
LABEL_11:
      if ( !DebugSetMute_0 )
        return;
      goto LABEL_12;
    }
LABEL_10:
    DebugSetMute(mute);
    goto LABEL_11;
  }
LABEL_12:
  DebugSetMute_0();
}

// FUN_10010285 @ 0x10010285
// [binja] int32_t* __fastcall sub_10010285(int32_t* arg1)
int *FUN_10010285(int *arg1)
{
  int *v1; // ecx

  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[14] = 0;
  v1[15] = 0;
  v1[19] = 0;
  v1[20] = 0;
  return v1;
}

// FUN_1001029e @ 0x1001029E
// [binja] int32_t __fastcall sub_1001029e(void* arg1)
int FUN_1001029e(void *arg1)
{
  int v1; // ecx
  void *v2; // edi
  int v3; // esi
  int result; // eax
  void *v5; // edi
  void *v6; // esi
  void *v7; // [esp-4h] [ebp-8h]
  void *v8; // [esp+0h] [ebp-4h]

  v3 = v1;
  if ( *(_DWORD *)(v1 + 4) && *(_DWORD *)(v1 + 56) )
    operator delete(*(void **)(v1 + 4));
  result = *(_DWORD *)(v3 + 8);
  if ( result && *(_DWORD *)(v3 + 60) )
    operator delete(*(void **)(v3 + 8));
  v7 = v2;
  v5 = *(void **)(v3 + 76);
  if ( v5 )
  {
    FUN_1001029e(v7);
    operator delete(v5);
  }
  v6 = *(void **)(v3 + 80);
  if ( v6 )
  {
    FUN_1001029e(v8);
    operator delete(v6);
  }
  return result;
}

// FUN_100102f7 @ 0x100102F7
// [binja] void* __thiscall sub_100102f7(void* arg1, char arg2)
void *FUN_100102f7(void *arg1, char arg2)
{
  void *v2; // ecx
  void *v3; // esi
  void *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  FUN_1001029e(v5);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return v3;
}

// FUN_10010313 @ 0x10010313
// [binja] int32_t __thiscall sub_10010313(int32_t* arg1, int32_t* arg2)
int FUN_10010313(int *arg1, int *arg2)
{
  int *v2; // ecx
  int *v3; // ebx
  _DWORD *v4; // edx
  int v5; // eax
  int v6; // eax

  v3 = v2;
  if ( v2[1] && v2[14] )
    operator delete((void *)v2[1]);
  if ( v3[2] && v3[15] )
    operator delete((void *)v3[2]);
  *v3 = arg1[1];
  v3[1] = *arg1;
  v3[2] = arg1[18];
  v4 = v3 + 6;
  qmemcpy(v3 + 6, arg1 + 10, 0x18u);
  v3[12] = arg1[2];
  v3[13] = arg1[3];
  v5 = *v3;
  if ( *v3 == 827611204 || v5 == 844388420 )
    goto LABEL_15;
  switch ( v5 )
  {
    case 844715353:
LABEL_14:
      *v4 &= ~1u;
      break;
    case 861165636:
    case 877942852:
    case 894720068:
LABEL_15:
      *v4 &= 0xFFFFFFFC;
      v3[7] &= 0xFFFFFFFC;
      break;
    case 1498831189:
      goto LABEL_14;
  }
  v6 = v3[8] - *v4;
  v3[14] = 0;
  v3[15] = 0;
  v3[3] = v6;
  v3[4] = v3[9] - v3[7];
  v3[5] = v3[11] - v3[10];
  return 0;
}

// FUN_100103d6 @ 0x100103D6
// [binja] int32_t __thiscall sub_100103d6(int32_t* arg1, void* arg2, void* arg3)
int FUN_100103d6(int *arg1, void *arg2, void *arg3)
{
  int *v3; // ecx
  int *v4; // esi
  int *v6; // edi
  unsigned int v7; // ebx
  int v8; // eax
  unsigned __int16 v9; // dx
  int v10; // eax
  int v11; // eax
  unsigned int v12; // eax
  int v13; // edx
  int v14; // ecx
  int v15; // eax
  int v16; // ebx
  void *v17; // eax
  _BYTE *v18; // eax
  int v19; // ecx
  unsigned int i; // edx
  int v21; // eax
  int v22; // eax
  int v23; // ecx
  unsigned int v24; // ecx
  unsigned int v25; // eax
  bool v26; // zf
  char *v27; // ecx
  char *v28; // edx
  int v29; // eax
  unsigned int v30; // ebx
  int v31; // eax
  int v32; // ecx
  unsigned int v33; // eax
  unsigned int v34; // eax
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  char *v38; // edi
  char v39; // si
  unsigned int v40; // ecx
  int v41; // eax
  __int16 v42; // di
  unsigned int j; // ecx
  unsigned int v44; // eax
  char *v45; // esi
  char *v46; // edi
  unsigned int v47; // [esp+4h] [ebp-1Ch]
  unsigned int v48; // [esp+4h] [ebp-1Ch]
  unsigned int v49; // [esp+8h] [ebp-18h]
  int v50; // [esp+8h] [ebp-18h]
  int *v51; // [esp+Ch] [ebp-14h]
  unsigned int v52; // [esp+10h] [ebp-10h]
  unsigned int v53; // [esp+14h] [ebp-Ch]
  int v54; // [esp+18h] [ebp-8h]
  char *v55; // [esp+18h] [ebp-8h]
  unsigned int v56; // [esp+1Ch] [ebp-4h]
  int *arg1a; // [esp+28h] [ebp+8h]
  int *arg1b; // [esp+28h] [ebp+8h]
  int *arg1c; // [esp+28h] [ebp+8h]
  void *arg2a; // [esp+2Ch] [ebp+Ch]
  int arg2b; // [esp+2Ch] [ebp+Ch]
  char *arg2c; // [esp+2Ch] [ebp+Ch]

  v4 = v3;
  v51 = v3;
  if ( (unsigned int)arg2 < 0x28 )
    return -2147467259;
  v6 = arg1;
  v7 = *arg1;
  if ( (unsigned int)*arg1 < 0x28 )
    return -2147467259;
  v56 = arg1[1];
  v8 = arg1[2];
  if ( v8 <= 0 )
    v8 = -v8;
  v9 = *((_WORD *)arg1 + 7);
  v54 = v8;
  v10 = arg1[8];
  if ( v9 <= 8u && !v10 )
    v10 = 1 << v9;
  v49 = v7 + 4 * v10;
  if ( v49 > (unsigned int)arg2 )
    return -2147467259;
  if ( *((_WORD *)arg1 + 6) != 1 )
    return -2147467259;
  if ( arg1[2] < 0 )
  {
    v11 = arg1[4];
    if ( v11 )
    {
      if ( v11 != 3 )
        return -2147467259;
    }
  }
  v12 = arg1[4];
  if ( v12 <= 2 )
  {
    LOBYTE(arg1) = *((_WORD *)arg1 + 7);
    if ( v9 == 1 || v9 == 4 || v9 == 8 )
    {
      arg2b = 41;
      goto LABEL_80;
    }
    if ( v9 != 16 )
    {
      if ( v9 != 24 )
      {
        if ( v9 != 32 )
          return -2147467259;
        goto LABEL_77;
      }
LABEL_43:
      arg2b = 20;
      goto LABEL_80;
    }
LABEL_78:
    arg2b = 24;
    goto LABEL_80;
  }
  if ( v12 == 3 )
  {
    if ( v7 >= 0x6C )
    {
      v13 = arg1[12];
      v14 = arg1[11];
      v15 = arg1[10];
      arg2a = (void *)arg1[13];
    }
    else
    {
      arg2a = 0;
      v13 = *(int *)((char *)arg1 + v7 + 8);
      v14 = *(int *)((char *)arg1 + v7 + 4);
      v15 = *(int *)((char *)arg1 + v7);
    }
    LOWORD(arg1) = *((_WORD *)arg1 + 7);
    if ( (unsigned __int16)arg1 != 16 )
    {
      if ( (unsigned __int16)arg1 != 24 )
      {
        if ( (unsigned __int16)arg1 != 32 )
          return -2147467259;
        if ( v13 != 255 )
        {
          if ( v13 == 1072693248 )
          {
            if ( v14 == 1047552 && v15 == 1023 && arg2a == (void *)-1073741824 )
            {
              arg2b = 31;
              goto LABEL_80;
            }
          }
          else if ( !v13 && v14 == -65536 && v15 == 0xFFFF && !arg2a )
          {
            arg2b = 34;
            goto LABEL_80;
          }
          return -2147467259;
        }
        if ( v14 != 65280 || v15 != 16711680 )
          return -2147467259;
        if ( arg2a )
        {
          if ( arg2a == (void *)-16777216 )
          {
            arg2b = 21;
LABEL_80:
            if ( v4[16] && arg2b == 41 )
            {
              v16 = v6[8];
              v47 = v16;
              if ( !v16 )
              {
                v16 = 1 << (char)arg1;
                v47 = 1 << (char)arg1;
              }
              v4[15] = 1;
              v17 = operator new(0x400u);
              v4[2] = (int)v17;
              if ( !v17 )
                return -2147024882;
              arg1a = 0;
              v18 = (char *)v6 + *v6;
              if ( v16 )
              {
                do
                {
                  v19 = 4 * (_DWORD)arg1a;
                  *(_BYTE *)(v19 + v4[2]) = v18[2];
                  *(_BYTE *)(v19 + v4[2] + 1) = v18[1];
                  *(_BYTE *)(v19 + v4[2] + 2) = *v18;
                  *(_BYTE *)(v19 + v4[2] + 3) = -1;
                  arg1a = (int *)((char *)arg1a + 1);
                  v16 = v47;
                  v18 += 4;
                }
                while ( (unsigned int)arg1a < v47 );
              }
              for ( i = v16; i < 0x100; ++i )
              {
                v21 = 4 * i;
                *(_BYTE *)(v21 + v4[2]) = -1;
                *(_BYTE *)(v21 + v4[2] + 1) = -1;
                *(_BYTE *)(v21 + v4[2] + 2) = -1;
                *(_BYTE *)(v21 + v4[2] + 3) = -1;
              }
            }
            if ( *((_WORD *)v6 + 7) == 1 )
            {
              v24 = (v56 + 7) >> 3;
            }
            else
            {
              if ( *((_WORD *)v6 + 7) != 4 )
              {
                v22 = v56 * (*((unsigned __int16 *)v6 + 7) >> 3);
                v23 = v22 + 3;
LABEL_96:
                v53 = v23 & 0xFFFFFFFC;
                v48 = v22;
                *v4 = arg2b;
                v25 = (v22 + 3) & 0xFFFFFFFC;
                v26 = v4[16] == 0;
                v4[3] = v56;
                v4[12] = v25;
                v4[13] = 0;
                v4[4] = v54;
                v4[5] = 1;
                if ( v26 )
                  return 0;
                if ( v6[2] < 0 && *((_WORD *)v6 + 7) >= 8u )
                {
                  v4[14] = 0;
                  v4[1] = (int)v6 + v49;
                  return 0;
                }
                v4[14] = 1;
                v27 = (char *)operator new(v54 * v25);
                arg2c = v27;
                v4[1] = (int)v27;
                if ( !v27 )
                  return -2147024882;
                v28 = (char *)v6 + v49;
                v29 = v4[12];
                if ( v6[2] >= 0 )
                {
                  v50 = -v29;
                  v30 = (unsigned int)&v27[v29 * (v54 - 1)];
                }
                else
                {
                  v50 = v4[12];
                  v30 = (unsigned int)v27;
                }
                v55 = &v27[v54 * v29];
                v31 = v6[4];
                arg1b = (int *)v30;
                v52 = v30;
                if ( v31 == 2 )
                {
                  if ( v30 >= (unsigned int)v27 )
                  {
                    do
                    {
                      if ( *v28 )
                      {
                        v35 = 0;
                        do
                        {
                          if ( (v35 & 1) != 0 )
                            LOBYTE(v36) = v28[1] & 0xF;
                          else
                            v36 = (unsigned __int8)v28[1] >> 4;
                          *(_BYTE *)(v35 + v30) = v36;
                          ++v35;
                        }
                        while ( v35 < (unsigned __int8)*v28 );
                        v4 = v51;
                        v30 += (unsigned __int8)*v28;
                      }
                      else if ( v28[1] )
                      {
                        if ( v28[1] == 1 )
                        {
                          v30 = (unsigned int)&arg2c[-v4[12]];
                        }
                        else if ( v28[1] == 2 )
                        {
                          v30 += (unsigned __int8)v28[2] - v4[12] * (unsigned __int8)v28[3];
                          v28 += 2;
                        }
                        else
                        {
                          v32 = 0;
                          if ( v28[1] )
                          {
                            do
                            {
                              v33 = (unsigned __int8)v28[(v32 >> 1) + 2];
                              if ( (v32 & 1) != 0 )
                                LOBYTE(v33) = v33 & 0xF;
                              else
                                v33 >>= 4;
                              *(_BYTE *)(v32 + v30) = v33;
                              ++v32;
                            }
                            while ( v32 < (unsigned __int8)v28[1] );
                            v4 = v51;
                          }
                          v34 = (unsigned __int8)v28[1];
                          v30 += v34;
                          v28 += ((v34 >> 1) + 1) & 0xFFFFFFFE;
                        }
                      }
                      else
                      {
                        v30 = v52 - v4[12];
                        v52 = v30;
                      }
                      v28 += 2;
                    }
                    while ( v30 >= (unsigned int)arg2c );
                  }
                  return 0;
                }
                if ( v31 != 1 )
                {
                  v42 = *((_WORD *)v6 + 7);
                  if ( v42 == 1 )
                  {
                    while ( v30 >= (unsigned int)v27 && v30 < (unsigned int)v55 )
                    {
                      arg1c = 0;
                      if ( v56 )
                      {
                        do
                        {
                          *((_BYTE *)arg1c + v30) = ((unsigned __int8)v28[(unsigned int)arg1c >> 3] >> (7 - ((unsigned __int8)arg1c & 7)))
                                                  & 1;
                          arg1c = (int *)((char *)arg1c + 1);
                        }
                        while ( (unsigned int)arg1c < v56 );
                        v27 = arg2c;
                      }
                      v30 += v50;
                      v28 += v53;
                    }
                  }
                  else if ( v42 == 4 )
                  {
                    if ( v30 >= (unsigned int)v27 )
                    {
                      do
                      {
                        if ( v30 >= (unsigned int)v55 )
                          break;
                        for ( j = 0; j < v56; ++j )
                        {
                          v44 = (unsigned __int8)v28[j >> 1];
                          if ( (j & 1) != 0 )
                            LOBYTE(v44) = v44 & 0xF;
                          else
                            v44 >>= 4;
                          *(_BYTE *)(j + v30) = v44;
                        }
                        v30 += v50;
                        v28 += v53;
                      }
                      while ( v30 >= (unsigned int)arg2c );
                    }
                  }
                  else
                  {
                    while ( v30 >= (unsigned int)v27 )
                    {
                      if ( v30 >= (unsigned int)v55 )
                        break;
                      v45 = v28;
                      v28 += v53;
                      v46 = (char *)v30;
                      v30 += v50;
                      qmemcpy(v46, v45, v48);
                    }
                  }
                  return 0;
                }
                if ( v30 < (unsigned int)v27 )
                  return 0;
                while ( !*v28 )
                {
                  if ( v28[1] )
                  {
                    if ( v28[1] == 1 )
                    {
                      v30 = (unsigned int)&arg2c[-v4[12]];
                    }
                    else
                    {
                      if ( v28[1] != 2 )
                      {
                        qmemcpy((void *)v30, v28 + 2, (unsigned __int8)v28[1]);
                        v37 = (unsigned __int8)v28[1];
                        v30 += v37;
                        v28 += (v37 + 1) & 0xFFFFFFFE;
LABEL_140:
                        v4 = v51;
                        goto LABEL_141;
                      }
                      v30 += (unsigned __int8)v28[2] - v4[12] * (unsigned __int8)v28[3];
                      v28 += 2;
                    }
                  }
                  else
                  {
                    v30 = v52 - v4[12];
                    v52 = v30;
                  }
LABEL_141:
                  v28 += 2;
                  arg1b = (int *)v30;
                  if ( v30 < (unsigned int)arg2c )
                    return 0;
                }
                v38 = (char *)v30;
                LOBYTE(v30) = v28[1];
                BYTE1(v30) = v30;
                v39 = *v28;
                v40 = (unsigned __int8)*v28 >> 2;
                v41 = v30 << 16;
                LOWORD(v41) = v30;
                memset32(v38, v41, v40);
                memset(&v38[4 * v40], v30, v39 & 3);
                v30 = (unsigned int)arg1b + (unsigned __int8)*v28;
                goto LABEL_140;
              }
              v24 = (v56 + 1) >> 1;
            }
            v22 = v56;
            v23 = v24 + 3;
            goto LABEL_96;
          }
          return -2147467259;
        }
LABEL_77:
        arg2b = 22;
        goto LABEL_80;
      }
      if ( v13 != 255 || v14 != 65280 || v15 != 16711680 || arg2a )
        return -2147467259;
      goto LABEL_43;
    }
    if ( v13 == 255 )
    {
      if ( v14 == 255 && v15 == 255 && arg2a == (void *)65280 )
      {
        arg2b = 51;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v13 != 31 )
    {
      if ( v13 == 15 )
      {
        if ( v14 == 240 && v15 == 3840 )
        {
          if ( arg2a == (void *)61440 )
          {
            arg2b = 26;
            goto LABEL_80;
          }
          if ( !arg2a )
          {
            arg2b = 30;
            goto LABEL_80;
          }
        }
      }
      else if ( v13 == 3 && v14 == 28 && v15 == 224 && arg2a == (void *)65280 )
      {
        arg2b = 29;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v14 == 2016 )
    {
      if ( v15 == 63488 && !arg2a )
      {
        arg2b = 23;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v14 != 992 || v15 != 31744 )
      return -2147467259;
    if ( arg2a )
    {
      if ( arg2a == (void *)0x8000 )
      {
        arg2b = 25;
        goto LABEL_80;
      }
      return -2147467259;
    }
    goto LABEL_78;
  }
  return -2147467263;
}

// FUN_10010aec @ 0x10010AEC
// [binja] int32_t __thiscall sub_10010aec(int32_t* arg1, HANDLE arg2)
int FUN_10010aec(int *arg1, HANDLE arg2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ebx
  int v4; // eax
  bool v5; // zf
  unsigned int j; // ecx
  int v8; // eax
  int v9; // ecx
  char *v10; // esi
  unsigned int v11; // edi
  int v12; // ecx
  int v13; // eax
  char v14; // dl
  unsigned int i; // esi
  char v16; // cl
  int v17; // eax
  char v18; // cl
  int v19; // ecx
  int v20; // eax
  DWORD v21; // esi
  int v22; // ecx
  int v23; // eax
  char *v24; // edi
  char v25; // [esp+Ch] [ebp-424h] BYREF
  _BYTE v26[1023]; // [esp+Dh] [ebp-423h] BYREF
  _DWORD v27[27]; // [esp+40Ch] [ebp-24h] BYREF
  __int16 Buffer; // [esp+478h] [ebp+48h] BYREF
  DWORD v29; // [esp+47Ah] [ebp+4Ah]
  __int16 v30; // [esp+47Eh] [ebp+4Eh]
  __int16 v31; // [esp+480h] [ebp+50h]
  DWORD v32; // [esp+482h] [ebp+52h]
  unsigned int k; // [esp+488h] [ebp+58h]
  _BYTE v34[4]; // [esp+48Ch] [ebp+5Ch]
  DWORD v35; // [esp+490h] [ebp+60h]
  _BYTE v36[4]; // [esp+494h] [ebp+64h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+498h] [ebp+68h]
  DWORD v38; // [esp+49Ch] [ebp+6Ch]

  v36[0] = 0;
  v36[1] = 0;
  v36[2] = 0;
  v36[3] = 0;
  LOBYTE(v38) = 0;
  HIBYTE(v38) = -1;
  v34[0] = 0;
  v3 = v2;
  memset(v27, 0, sizeof(v27));
  v4 = *v2;
  v5 = *v2 == 20;
  *(_WORD *)((char *)&v38 + 1) = -21931;
  v34[1] = 36;
  v34[2] = 73;
  v34[3] = 109;
  v35 = -2378094;
  nNumberOfBytesToWrite = 0;
  if ( v5 )
  {
    v27[0] = 40;
    v27[4] = 0;
    HIWORD(v27[3]) = 24;
  }
  else
  {
    switch ( v4 )
    {
      case 27:
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        for ( i = 0; i < 0x100; ++i )
        {
          v16 = v34[i >> 5];
          v17 = 4 * i;
          v26[v17 + 2] = 0;
          v26[v17 + 1] = v16;
          v26[v17] = v34[(i >> 2) & 7];
          v18 = *((_BYTE *)&v38 + (i & 3));
          v26[v17 - 1] = v18;
        }
        break;
      case 41:
        v9 = v2[2];
        v10 = (char *)(v9 + 2);
        v11 = 0;
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        v12 = v9 - (_DWORD)v26;
        do
        {
          v13 = 4 * v11;
          v26[v13 + 1] = v26[4 * v11 + v12];
          v26[v13] = *(v10 - 1);
          v14 = *v10;
          v26[v13 + 2] = 0;
          ++v11;
          v10 += 4;
          v26[v13 - 1] = v14;
        }
        while ( v11 < 0x100 );
        break;
      case 50:
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        for ( j = 0; j < 0x100; ++j )
        {
          v8 = 4 * j;
          v26[v8 + 2] = 0;
          v26[v8 + 1] = j;
          v26[v8] = j;
          v26[v8 - 1] = j;
        }
        break;
      default:
        return -2147467259;
    }
  }
  v19 = v3[3];
  v20 = v3[4];
  v27[6] = 2834;
  v27[7] = 2834;
  v27[1] = v19;
  v27[2] = v20;
  v38 = (HIWORD(v27[3]) >> 3) * v19;
  v35 = (v38 + 3) & 0xFFFFFFFC;
  Buffer = 19778;
  v30 = 0;
  v31 = 0;
  k = HIWORD(v27[3]) >> 3;
  v21 = ((v35 * v20 + nNumberOfBytesToWrite + 57) & 0xFFFFFFFC) - (v35 * v20 + nNumberOfBytesToWrite + 54);
  v29 = (v35 * v20 + nNumberOfBytesToWrite + 57) & 0xFFFFFFFC;
  LOWORD(v27[3]) = 1;
  v32 = nNumberOfBytesToWrite + 54;
  if ( arg2 )
    WriteFile(arg1, &Buffer, 0xEu, (LPDWORD)&arg2, 0);
  WriteFile(arg1, v27, 0x28u, (LPDWORD)&arg2, 0);
  if ( nNumberOfBytesToWrite )
    WriteFile(arg1, &v25, nNumberOfBytesToWrite, (LPDWORD)&arg2, 0);
  v22 = v3[12];
  v23 = v3[1] + k * v3[6] + v22 * v3[7];
  v24 = (char *)(v23 + v22 * (v3[4] - 1));
  for ( k = v23; (unsigned int)v24 >= k; v24 -= v3[12] )
  {
    WriteFile(arg1, v24, v38, (LPDWORD)&arg2, 0);
    if ( v38 < v35 )
      WriteFile(arg1, v36, v35 - v38, (LPDWORD)&arg2, 0);
  }
  if ( v21 )
    WriteFile(arg1, v36, v21, (LPDWORD)&arg2, 0);
  return 0;
}

// sub_10010DD0 @ 0x10010DD0
void __cdecl __noreturn sub_10010DD0(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  longjmp((int *)(*(_DWORD *)a1 + 132), 1);
}

// warn_fn @ 0x10010DEC
void nullsub_2()
{
  ;
}

// sub_10010DED @ 0x10010DED
char __cdecl sub_10010DED(int a1)
{
  _DWORD *v1; // eax

  v1 = *(_DWORD **)(a1 + 20);
  *v1 = v1[7];
  v1[1] = v1[8];
  return 1;
}

// sub_10010E02 @ 0x10010E02
_DWORD *__cdecl sub_10010E02(int a1, int a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 20);
  *result += a2;
  result[1] -= a2;
  return result;
}

// grim_load_image_jpg @ 0x10010E13
// [binja] int32_t __thiscall sub_10010e13(int32_t* arg1, int32_t arg2, int32_t arg3)
int grim_load_image_jpg(int *arg1, int arg2, int arg3)
{
  _DWORD *v3; // ecx
  int v4; // esi
  _DWORD *v5; // eax
  unsigned int v6; // eax
  _DWORD *v7; // esi
  unsigned int v8; // ecx
  bool v9; // zf
  unsigned int v10; // eax
  void *v11; // eax
  char *i; // ebx
  int *v13; // esi
  _BYTE *v14; // eax
  int *v15; // ecx
  unsigned __int16 v16; // dx
  int v18; // [esp-4h] [ebp-284h]
  unsigned int v19; // [esp-4h] [ebp-284h]
  void (__cdecl __noreturn *v20[2])(int); // [esp+Ch] [ebp-274h] BYREF
  void (*v21)(); // [esp+14h] [ebp-26Ch]
  char v22[64]; // [esp+90h] [ebp-1F0h] BYREF
  void (__cdecl __noreturn **v23)(int); // [esp+D0h] [ebp-1B0h] BYREF
  int v24; // [esp+D4h] [ebp-1ACh]
  _DWORD *v25; // [esp+E4h] [ebp-19Ch]
  int v26; // [esp+114h] [ebp-16Ch]
  unsigned int v27; // [esp+12Ch] [ebp-154h]
  unsigned int v28; // [esp+130h] [ebp-150h]
  int v29; // [esp+138h] [ebp-148h]
  unsigned int v30; // [esp+148h] [ebp-138h]
  _DWORD *v31; // [esp+278h] [ebp-8h]
  const void **v32; // [esp+27Ch] [ebp-4h]

  v31 = v3;
  v23 = sub_1001E027(v20);
  v20[0] = sub_10010DD0;
  v21 = warn_fn;
  if ( setjmp3(v22, 0, v18) )
    goto LABEL_2;
  sub_1001C265(&v23, 61, 424);
  v5 = (_DWORD *)(*(int (__cdecl **)(void (__cdecl __noreturn ***)(int), _DWORD, int))v24)(&v23, 0, 36);
  v25 = v5;
  v5[8] = arg2;
  v5[2] = warn_fn;
  v5[3] = sub_10010DED;
  v5[4] = sub_10010E02;
  v5[5] = sub_1001DD80;
  v5[6] = warn_fn;
  v5[1] = 0;
  *v5 = 0;
  v5[7] = arg1;
  sub_1001C5DE(&v23, 1);
  if ( !sub_1001BF5E() )
    v26 = 1;
  v21 = (void (*)())sub_1001DF31;
  sub_1001C76E((int)&v23);
  if ( v29 == 1 )
  {
    v7 = v31;
    v6 = v27;
    *v31 = 50;
    v7[12] = v6;
LABEL_9:
    v7[13] = 0;
    v9 = v7[16] == 0;
    v7[3] = v6;
    v10 = v28;
    v7[4] = v28;
    v7[5] = 1;
    if ( !v9 )
    {
      v19 = v10 * v7[12];
      v7[14] = 1;
      v11 = operator new(v19);
      v7[1] = v11;
      if ( !v11
        || (v32 = (const void **)(*(int (__cdecl **)(void (__cdecl __noreturn ***)(int), int, unsigned int, int))(v24 + 8))(
                                   &v23,
                                   1,
                                   v29 * v27,
                                   1)) == 0 )
      {
        v4 = -2147024882;
        goto LABEL_25;
      }
      if ( *v7 == 50 )
      {
        for ( i = (char *)v7[1]; v30 < v28; i += v27 )
        {
          sub_1001C6EA(&v23, (int)v32, 1);
          qmemcpy(i, *v32, v27);
        }
      }
      else if ( *v7 == 22 )
      {
        v13 = (int *)v7[1];
        while ( v30 < v28 )
        {
          sub_1001C6EA(&v23, (int)v32, 1);
          v14 = *v32;
          v15 = &v13[v27];
          while ( v13 < v15 )
          {
            HIBYTE(v16) = *v14;
            LOBYTE(v16) = v14[1];
            *v13++ = (unsigned __int8)v14[2] | (v16 << 8);
            v14 += 3;
          }
        }
      }
      sub_1001C537((int)&v23);
    }
    v4 = 0;
    goto LABEL_25;
  }
  if ( v29 == 3 )
  {
    v6 = v27;
    v7 = v31;
    v8 = 4 * v27;
    *v31 = 22;
    v7[12] = v8;
    goto LABEL_9;
  }
LABEL_2:
  v4 = -2147467259;
LABEL_25:
  sub_1001C325((int)&v23);
  return v4;
}

// FUN_10011083 @ 0x10011083
// [binja] int32_t __thiscall sub_10011083(int32_t* arg1, void* arg2, int32_t arg3)
int FUN_10011083(int *arg1, void *arg2, int arg3)
{
  int *v3; // ecx
  int *v4; // esi
  char v7; // cl
  int v8; // edx
  int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  unsigned int v18; // eax
  void *v19; // edx
  unsigned int v20; // eax
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // edx
  unsigned int v24; // eax
  unsigned int v25; // edi
  unsigned int v26; // edx
  unsigned int v27; // edx
  _BYTE *v28; // edi
  char *v29; // ecx
  unsigned int v30; // eax
  bool v31; // zf
  char *v32; // eax
  char *v33; // edx
  unsigned int v34; // eax
  int v35; // ecx
  int *v36; // [esp+8h] [ebp-34h]
  unsigned int v37; // [esp+Ch] [ebp-30h]
  unsigned int v38; // [esp+Ch] [ebp-30h]
  unsigned int v39; // [esp+10h] [ebp-2Ch]
  int v40; // [esp+14h] [ebp-28h]
  BOOL v41; // [esp+18h] [ebp-24h]
  BOOL v42; // [esp+1Ch] [ebp-20h]
  int v43; // [esp+20h] [ebp-1Ch]
  int v44; // [esp+20h] [ebp-1Ch]
  char v45; // [esp+24h] [ebp-18h]
  unsigned int v46; // [esp+24h] [ebp-18h]
  int v47; // [esp+28h] [ebp-14h]
  int v48; // [esp+28h] [ebp-14h]
  _BYTE *v49; // [esp+2Ch] [ebp-10h]
  int v50; // [esp+30h] [ebp-Ch]
  unsigned int v51; // [esp+34h] [ebp-8h]
  int *v52; // [esp+38h] [ebp-4h]
  char *v53; // [esp+38h] [ebp-4h]
  int *arg1a; // [esp+44h] [ebp+8h]
  int *arg1b; // [esp+44h] [ebp+8h]
  char *arg2a; // [esp+48h] [ebp+Ch]
  char *arg2b; // [esp+48h] [ebp+Ch]
  char *arg2c; // [esp+48h] [ebp+Ch]

  v4 = v3;
  v36 = v3;
  if ( (unsigned int)arg2 < 0x12 )
    return -2147467259;
  v7 = *((_BYTE *)arg1 + 1);
  if ( (v7 & 0xFE) != 0 )
    return -2147467259;
  v8 = *((unsigned __int8 *)arg1 + 2);
  if ( (v8 & 0xFFFFFFF4) != 0 || !*((_WORD *)arg1 + 6) || !*((_WORD *)arg1 + 7) )
    return -2147467259;
  v9 = *((unsigned __int8 *)arg1 + 7);
  v47 = 0;
  v10 = (unsigned int)(v9 + 7) >> 3;
  if ( v7 )
  {
    v11 = v9 - 15;
    if ( v11 )
    {
      v12 = v11 - 1;
      if ( v12 )
      {
        v13 = v12 - 8;
        if ( v13 )
        {
          if ( v13 != 8 )
            return -2147467259;
          v47 = 21;
        }
        else
        {
          v47 = 20;
        }
      }
      else
      {
        v47 = 25;
      }
    }
    else
    {
      v47 = 24;
    }
  }
  v14 = *((unsigned __int8 *)arg1 + 16);
  v51 = (unsigned int)(v14 + 7) >> 3;
  if ( (v8 & 3) == 1 )
  {
    if ( !*((_BYTE *)arg1 + 1) || *((_BYTE *)arg1 + 16) != 8 )
      return -2147467259;
    v50 = 41;
  }
  else if ( (v8 & 3) == 2 )
  {
    v15 = v14 - 15;
    if ( v15 )
    {
      v16 = v15 - 1;
      if ( v16 )
      {
        v17 = v16 - 8;
        if ( v17 )
        {
          if ( v17 != 8 )
            return -2147467259;
          v50 = 21;
        }
        else
        {
          v50 = 20;
        }
      }
      else
      {
        v50 = 25;
      }
    }
    else
    {
      v50 = 24;
    }
  }
  else
  {
    if ( (v8 & 3) != 3 || *((_BYTE *)arg1 + 16) != 8 )
      return -2147467259;
    v50 = 50;
  }
  v40 = v8 & 8;
  v41 = (*((_BYTE *)arg1 + 17) & 0x20) == 32;
  v18 = *(unsigned __int8 *)arg1;
  arg2a = (char *)arg2 - 18;
  v42 = (*((_BYTE *)arg1 + 17) & 0x10) != 16;
  if ( (unsigned int)arg2a < v18 )
    return -2147467259;
  arg2b = &arg2a[-v18];
  v52 = (int *)((char *)arg1 + v18 + 18);
  v37 = v10 * *(unsigned __int16 *)((char *)arg1 + 5);
  if ( (unsigned int)arg2b < v37 )
    return -2147467259;
  if ( v4[16] && v50 == 41 )
  {
    if ( *(unsigned __int16 *)((char *)arg1 + 5) + *(unsigned __int16 *)((char *)arg1 + 3) > 256 )
      return -2147467259;
    v19 = operator new(0x400u);
    v4[2] = (int)v19;
    if ( !v19 )
      return -2147024882;
    v4[15] = 1;
    memset(v19, 0xFFu, 0x400u);
    arg1a = v52;
    v20 = v4[2] + 4 * *(unsigned __int16 *)((char *)arg1 + 3);
    v49 = (_BYTE *)v20;
    v39 = v20 + 4 * *(unsigned __int16 *)((char *)arg1 + 5);
    if ( v20 < v39 )
    {
      LOBYTE(v21) = (_BYTE)arg2b;
      LOBYTE(v22) = (_BYTE)arg2b;
      while ( 1 )
      {
        LOBYTE(v23) = v45;
        if ( v47 == 20 )
          break;
        switch ( v47 )
        {
          case 21:
            LOBYTE(v22) = BYTE1(*arg1a);
            v43 = HIBYTE(*arg1a);
            LOBYTE(v21) = BYTE2(*arg1a);
            LOBYTE(v23) = *arg1a++;
            goto LABEL_50;
          case 24:
            v27 = *(unsigned __int16 *)arg1a;
            v21 = (8 * ((v27 >> 10) & 0x1F)) | (((v27 >> 10) & 0x1F) >> 2);
            v22 = (8 * ((v27 >> 5) & 0x1F)) | (((v27 >> 5) & 0x1F) >> 2);
            v23 = (8 * (v27 & 0x1F)) | ((unsigned __int8)(v27 & 0x1F) >> 2);
            arg1a = (int *)((char *)arg1a + 2);
LABEL_49:
            LOBYTE(v43) = -1;
            goto LABEL_50;
          case 25:
            v24 = *(unsigned __int16 *)arg1a;
            v43 = 255 * (v24 >> 15);
            v25 = v24 & 0x1F;
            v26 = v24 >> 5;
            v21 = (8 * ((v24 >> 10) & 0x1F)) | (((v24 >> 10) & 0x1F) >> 2);
            v22 = (8 * (v26 & 0x1F)) | ((unsigned __int8)(v26 & 0x1F) >> 2);
            v23 = (8 * v25) | (v25 >> 2);
            arg1a = (int *)((char *)arg1a + 2);
LABEL_50:
            v45 = v23;
            break;
        }
        v28 = v49;
        v49 += 4;
        v28[2] = v23;
        v28[3] = v43;
        *v28 = v21;
        v28[1] = v22;
        if ( (unsigned int)v49 >= v39 )
          goto LABEL_52;
      }
      LOBYTE(v21) = *((_BYTE *)arg1a + 2);
      LOBYTE(v22) = *((_BYTE *)arg1a + 1);
      LOBYTE(v23) = *(_BYTE *)arg1a;
      arg1a = (int *)((char *)arg1a + 3);
      goto LABEL_49;
    }
  }
LABEL_52:
  arg2c = &arg2b[-v37];
  v29 = (char *)v52 + v37;
  v30 = v51 * *((unsigned __int16 *)arg1 + 6) * *((unsigned __int16 *)arg1 + 7);
  *v4 = v50;
  v4[1] = (int)v52 + v37;
  v31 = v4[16] == 0;
  v4[12] = v51 * *((unsigned __int16 *)arg1 + 6);
  v4[13] = 0;
  v4[3] = *((unsigned __int16 *)arg1 + 6);
  v53 = (char *)v52 + v37;
  v4[4] = *((unsigned __int16 *)arg1 + 7);
  v4[5] = 1;
  if ( v31 )
    return 0;
  if ( !v40 && v41 && v42 )
  {
    if ( (unsigned int)arg2c >= v30 )
    {
      v4[1] = (int)v29;
      v4[14] = 0;
      return 0;
    }
  }
  else
  {
    v32 = (char *)operator new(v30);
    v4[1] = (int)v32;
    if ( !v32 )
      return -2147024882;
    v4[14] = 1;
    if ( v41 )
      v33 = v32;
    else
      v33 = &v32[v4[12] * (*((unsigned __int16 *)arg1 + 7) - 1)];
    v48 = 0;
    if ( !*((_WORD *)arg1 + 7) )
      return 0;
    while ( 1 )
    {
      arg1b = (int *)(v42 ? v33 : &v33[v4[12] - v51]);
      v34 = *((unsigned __int16 *)arg1 + 6);
      v46 = 0;
      if ( *((_WORD *)arg1 + 6) )
        break;
LABEL_83:
      if ( v41 )
        v33 += v4[12];
      else
        v33 -= v4[12];
      if ( ++v48 >= (unsigned int)*((unsigned __int16 *)arg1 + 7) )
        return 0;
    }
    while ( 1 )
    {
      if ( v40 )
      {
        if ( !arg2c )
          return -2147467259;
        v35 = *v53 & 0x80;
        v34 = (*v53++ & 0x7F) + 1;
        --arg2c;
        v44 = v35;
      }
      else
      {
        v44 = 0;
      }
      v46 += v34;
      if ( v34 )
        break;
LABEL_80:
      if ( v44 )
      {
        v53 += v51;
        arg2c -= v51;
      }
      v34 = *((unsigned __int16 *)arg1 + 6);
      if ( v46 >= v34 )
        goto LABEL_83;
    }
    while ( 1 )
    {
      v38 = v34 - 1;
      if ( (unsigned int)arg2c < v51 )
        break;
      qmemcpy(arg1b, v53, v51);
      if ( !v44 )
      {
        v53 += v51;
        arg2c -= v51;
      }
      if ( v42 )
        arg1b = (int *)((char *)arg1b + v51);
      else
        arg1b = (int *)((char *)arg1b - v51);
      --v34;
      if ( !v38 )
      {
        v4 = v36;
        goto LABEL_80;
      }
    }
  }
  return -2147467259;
}

// grim_load_image_pnm @ 0x1001152A
// [binja] int32_t __thiscall sub_1001152a(int32_t* arg1, char* arg2, int32_t arg3)
int grim_load_image_pnm(int *arg1, char *arg2, int arg3)
{
  _DWORD *v3; // ecx
  _DWORD *v4; // esi
  _BYTE *v6; // edi
  bool v7; // zf
  int v8; // ebx
  int v9; // ecx
  int *v10; // eax
  unsigned __int8 *v11; // edi
  unsigned __int8 v12; // al
  int v13; // [esp+8h] [ebp-18h]
  int v14; // [esp+Ch] [ebp-14h]
  int *v15; // [esp+10h] [ebp-10h]
  char *v16; // [esp+14h] [ebp-Ch]
  unsigned int v17; // [esp+18h] [ebp-8h]
  int v18; // [esp+1Ch] [ebp-4h]
  char *arg2a; // [esp+2Ch] [ebp+Ch]
  char *arg2b; // [esp+2Ch] [ebp+Ch]

  v4 = v3;
  if ( (unsigned int)arg2 < 2 )
    return -2147467259;
  if ( *(_BYTE *)arg1 != 80 )
    return -2147467259;
  if ( *((_BYTE *)arg1 + 1) == 51 )
  {
    v13 = 1;
  }
  else
  {
    if ( *((_BYTE *)arg1 + 1) != 54 )
      return -2147467259;
    v13 = 0;
  }
  v6 = (char *)arg1 + 2;
  v7 = arg2 == (char *)2;
  arg2a = arg2 - 2;
  v8 = 0;
  v16 = (char *)arg1 + 2;
  v18 = 0;
  v14 = 0;
  v17 = 255;
  if ( v7 )
    return -2147467259;
  while ( v13 || v18 != 3 )
  {
    if ( !isspace((unsigned __int8)*v6) )
    {
      if ( *v6 != 35 )
      {
        if ( arg2a )
        {
          do
          {
            if ( isspace((unsigned __int8)*v6) )
              break;
            if ( !isdigit((unsigned __int8)*v6) )
              return -2147467259;
            v9 = (unsigned __int8)*v6++;
            v7 = arg2a-- == (char *)1;
            v8 = v9 + 10 * v8 - 48;
            v16 = v6;
          }
          while ( !v7 );
        }
        if ( v18 )
        {
          if ( v18 == 1 )
          {
            if ( !v8 )
              return -2147467259;
            v10 = (int *)operator new(4 * v14 * v8);
            v4[1] = v10;
            if ( !v10 )
              return -2147024882;
            arg1 = v10;
            v4[13] = 0;
            v15 = &v10[v14 * v8];
            v6 = v16;
            v4[14] = 1;
            *v4 = 22;
            v4[12] = 4 * v14;
            v4[3] = v14;
            v4[4] = v8;
            v4[5] = 1;
            goto LABEL_39;
          }
          if ( v18 != 2 )
          {
            switch ( v18 )
            {
              case 3:
                if ( arg1 >= v15 )
                  return -2147467259;
                *arg1 = ((255 * v8 / v17) | 0xFFFFFF00) << 16;
                break;
              case 4:
                *arg1 |= (255 * v8 / v17) << 8;
                break;
              case 5:
                *arg1++ |= 255 * v8 / v17;
                if ( arg1 == v15 )
                  return 0;
                v18 = 2;
                break;
            }
            goto LABEL_39;
          }
          v17 = v8;
        }
        else
        {
          v14 = v8;
        }
        if ( !v8 )
          return -2147467259;
LABEL_39:
        ++v18;
        goto LABEL_40;
      }
      for ( ; arg2a; --arg2a )
      {
        if ( *v6 == 10 )
          break;
        ++v6;
      }
    }
    ++v6;
    --arg2a;
    v16 = v6;
LABEL_40:
    v8 = 0;
    if ( !arg2a )
      return -2147467259;
  }
  if ( v17 > 0xFF )
    return -2147467259;
  if ( (unsigned int)arg2a > 1 && *v6 == 13 )
  {
    ++v6;
    --arg2a;
  }
  v11 = v6 + 1;
  arg2b = arg2a - 1;
  if ( arg2b )
  {
    do
    {
      if ( arg1 >= v15 )
        break;
      v12 = 255 * (unsigned int)*v11 / v17;
      v11 += 3;
      *arg1 = (255 * (unsigned int)*(v11 - 1) / v17)
            | (((255 * (unsigned int)*(v11 - 2) / v17) | ((v12 | 0xFFFFFF00) << 8)) << 8);
      v7 = arg2b == (char *)3;
      arg2b -= 3;
      ++arg1;
    }
    while ( !v7 );
  }
  return v15 != arg1 ? 0x80004005 : 0;
}

// sub_100117B0 @ 0x100117B0
unsigned int __cdecl sub_100117B0(jmp_buf Buf, void *a2, unsigned int a3)
{
  int v3; // ebx

  v3 = Buf[21];
  if ( a3 > *(_DWORD *)(v3 + 4) )
    png_error(Buf, "read error");
  qmemcpy(a2, *(const void **)v3, a3);
  *(_DWORD *)v3 += a3;
  *(_DWORD *)(v3 + 4) -= a3;
  return a3;
}

// error_fn @ 0x100117F3
void __cdecl __noreturn sub_100117F3(jmp_buf Buf)
{
  longjmp(Buf, 1);
}

// grim_load_image_png @ 0x100117FF
// [binja] int32_t __thiscall sub_100117ff(int32_t* arg1, void* arg2, void* arg3)
int grim_load_image_png(int *arg1, void *arg2, void *arg3)
{
  int *v3; // ecx
  int *v4; // eax
  int *v5; // esi
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  unsigned __int8 v14; // al
  int v15; // esi
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  bool v20; // zf
  void *v21; // eax
  unsigned int i; // eax
  double v23; // st7
  __int64 v24; // rax
  int v25; // ecx
  bool v26; // cc
  int j; // eax
  void *v28; // eax
  int v29; // eax
  int v30; // edi
  int v31; // ecx
  char v32; // bl
  int v33; // edi
  int v34; // ecx
  int v35; // eax
  int *__attribute__((__org_typedef(jmp_buf))) v36; // [esp+8h] [ebp-168h]
  unsigned int *v37; // [esp+Ch] [ebp-164h]
  unsigned int v38; // [esp+Ch] [ebp-164h]
  int v39; // [esp+10h] [ebp-160h]
  _BYTE v40[256]; // [esp+1Ch] [ebp-154h]
  double v41; // [esp+11Ch] [ebp-54h] BYREF
  long double v42; // [esp+124h] [ebp-4Ch]
  unsigned int param_2[2]; // [esp+12Ch] [ebp-44h] BYREF
  int v44; // [esp+134h] [ebp-3Ch] BYREF
  int v45; // [esp+138h] [ebp-38h] BYREF
  int *v46; // [esp+13Ch] [ebp-34h]
  unsigned int param_3; // [esp+140h] [ebp-30h] BYREF
  unsigned int param_6; // [esp+144h] [ebp-2Ch] BYREF
  int v49; // [esp+148h] [ebp-28h] BYREF
  unsigned int param_5; // [esp+14Ch] [ebp-24h] BYREF
  int v51; // [esp+150h] [ebp-20h] BYREF
  void *v52; // [esp+154h] [ebp-1Ch]
  unsigned int param_4; // [esp+158h] [ebp-18h] BYREF
  int v54; // [esp+15Ch] [ebp-14h]
  int v55; // [esp+160h] [ebp-10h] BYREF
  int v56; // [esp+164h] [ebp-Ch]
  unsigned int *v57; // [esp+168h] [ebp-8h] BYREF
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+16Ch] [ebp-4h] BYREF

  v46 = v3;
  Buf = 0;
  v57 = 0;
  v52 = 0;
  if ( sub_100204E3((int)arg1, 0, (unsigned int)arg2) )
    return -2147467259;
  v4 = (int *)png_create_read_struct("1.0.5", 0, error_fn, warn_fn);
  Buf = v4;
  if ( !v4 )
    goto LABEL_86;
  v57 = (unsigned int *)sub_100205E8((int)v4);
  if ( !v57 )
    goto LABEL_86;
  if ( !setjmp3(Buf, 0, v39) )
  {
    param_2[0] = (unsigned int)arg1;
    param_2[1] = (unsigned int)arg2;
    FUN_100204a4(Buf, (unsigned int)param_2, (unsigned int)sub_100117B0);
    FUN_1001e294(Buf, v57);
    FUN_1001ea59(Buf, v57, &param_3, &param_4, &param_5, &param_6, 0, 0, 0);
    v5 = v46;
    if ( param_6 )
    {
      switch ( param_6 )
      {
        case 2u:
          *v46 = 20;
          break;
        case 3u:
          *v46 = 41;
          break;
        case 4u:
          *v46 = 51;
          break;
        case 6u:
          *v46 = 21;
          break;
      }
    }
    else
    {
      *v46 = 50;
    }
    if ( param_5 == 16 )
    {
      sub_1001EBCD((int)Buf);
      switch ( *v5 )
      {
        case 20:
          *v5 = 909201952;
          break;
        case 21:
          *v5 = 909201985;
          break;
        case 50:
          *v5 = 909200416;
          break;
        case 51:
          *v5 = 909200449;
          break;
        default:
          return -2147467259;
      }
    }
    if ( (int)param_5 < 8 )
      sub_1001EBDF((int)Buf);
    if ( !param_6 && (int)param_5 < 8 )
      sub_1001ED80((int)Buf);
    if ( sub_1001EA2E((int)Buf, (int)v57, &v45) )
    {
      sub_100203E1((int)Buf, (int)v57, v45);
    }
    else if ( sub_1001EA05((int)Buf, (int)v57, &v41) )
    {
      sub_1001ED4A((int)Buf, 2.2, v41);
    }
    if ( *v5 != 41 && sub_1001E9BF((int)Buf, (int)v57, 16) )
    {
      sub_1001ED80((int)Buf);
      v7 = *v5;
      if ( *v5 == 20 )
      {
        *v5 = 21;
      }
      else
      {
        switch ( v7 )
        {
          case 50:
            *v5 = 51;
            break;
          case 909200416:
            *v5 = 909200449;
            break;
          case 909201952:
            *v5 = 909201985;
            break;
        }
      }
    }
    v8 = *v5;
    if ( *v5 == 20 || v8 == 909201952 || v8 == 21 || v8 == 909201985 )
      sub_1001EBC4((int)Buf);
    if ( *v5 == 20 )
    {
      sub_1001EC11((int)Buf, 0xFFu, 1);
      *v5 = 22;
    }
    FUN_1001e407(Buf, (int *)v57);
    v9 = *v5;
    if ( *v5 > 51 )
    {
      v16 = v9 - 909200416;
      if ( !v16 )
      {
LABEL_58:
        v56 = 1;
        goto LABEL_59;
      }
      v17 = v16 - 33;
      if ( v17 )
      {
        v18 = v17 - 1503;
        if ( v18 )
        {
          if ( v18 != 33 )
            goto LABEL_59;
          goto LABEL_65;
        }
LABEL_66:
        v56 = 3;
        goto LABEL_59;
      }
    }
    else if ( *v5 != 51 )
    {
      v10 = v9 - 20;
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( v11 )
        {
          v12 = v11 - 1;
          if ( v12 )
          {
            v13 = v12 - 19;
            if ( !v13 || v13 == 9 )
              goto LABEL_58;
LABEL_59:
            v14 = sub_1001E9EF((int)Buf, (int)v57);
            if ( v56 != v14 )
              goto LABEL_60;
            v37 = v57;
            v5[3] = param_3;
            v36 = Buf;
            v5[4] = param_4;
            v5[5] = 1;
            v19 = sub_1001E9D9((int)v36, (int)v37);
            v20 = v5[16] == 0;
            v5[12] = v19;
            v5[13] = 0;
            if ( !v20 )
            {
              v21 = operator new(param_4 * v19);
              v5[1] = (int)v21;
              if ( !v21 || (v38 = 4 * param_4, v5[14] = 1, (v52 = operator new(v38)) == 0) )
              {
LABEL_86:
                v15 = -2147024882;
                goto LABEL_97;
              }
              for ( i = 0; i < param_4; ++i )
                *((_DWORD *)v52 + i) = v5[1] + i * v5[12];
              FUN_1001e7ce(Buf, (unsigned int *)v52);
              if ( *v5 == 41 )
              {
                v49 = 0;
                v51 = 0;
                if ( sub_1001E9BF((int)Buf, (int)v57, 8) )
                  sub_1001EB2A((int)Buf, (int)v57, &v55, &v51);
                if ( sub_1001E9BF((int)Buf, (int)v57, 16) )
                  sub_1001EB5D((int)Buf, (int)v57, &v44, &v49, 0);
                if ( *((float *)Buf + 76) <= 0.000001 || *((float *)Buf + 77) <= 0.000001 )
                {
                  for ( j = 0; j < 256; ++j )
                    v40[j] = j;
                }
                else
                {
                  v23 = *((float *)Buf + 77);
                  v54 = 0;
                  v42 = 1.0 / (v23 * *((float *)Buf + 76));
                  do
                  {
                    v24 = (__int64)(pow((double)v54 * 0.00392156862745098, v42) * 255.0 + 0.5);
                    v25 = v54++;
                    v26 = v54 < 256;
                    v40[v25] = v24;
                  }
                  while ( v26 );
                }
                v28 = operator new(0x400u);
                v5[2] = (int)v28;
                if ( !v28 )
                  goto LABEL_86;
                v29 = 0;
                v26 = v49 <= 0;
                v5[15] = 1;
                if ( !v26 )
                {
                  v30 = 0;
                  do
                  {
                    v31 = 4 * v29;
                    *(_BYTE *)(v31 + v5[2]) = v40[*(unsigned __int8 *)(v30 + v55)];
                    *(_BYTE *)(v5[2] + v31 + 1) = v40[*(unsigned __int8 *)(v30 + v55 + 1)];
                    *(_BYTE *)(v5[2] + v31 + 2) = v40[*(unsigned __int8 *)(v30 + v55 + 2)];
                    v32 = *(_BYTE *)(v29 + v44);
                    ++v29;
                    *(_BYTE *)(v5[2] + v31 + 3) = v32;
                    v30 += 3;
                  }
                  while ( v29 < v49 );
                }
                if ( v29 < v51 )
                {
                  v33 = 3 * v29;
                  do
                  {
                    v34 = 4 * v29;
                    *(_BYTE *)(v34 + v5[2]) = v40[*(unsigned __int8 *)(v33 + v55)];
                    *(_BYTE *)(v5[2] + v34 + 1) = v40[*(unsigned __int8 *)(v33 + v55 + 1)];
                    *(_BYTE *)(v5[2] + v34 + 2) = v40[*(unsigned __int8 *)(v33 + v55 + 2)];
                    *(_BYTE *)(v5[2] + v34 + 3) = -1;
                    ++v29;
                    v33 += 3;
                  }
                  while ( v29 < v51 );
                }
                if ( v29 < 256 )
                {
                  v35 = 4 * v29;
                  do
                  {
                    *(_BYTE *)(v35 + v5[2]) = -1;
                    *(_BYTE *)(v35 + v5[2] + 1) = -1;
                    *(_BYTE *)(v35 + v5[2] + 2) = -1;
                    *(_BYTE *)(v35 + v5[2] + 3) = -1;
                    v35 += 4;
                  }
                  while ( v35 < 1024 );
                }
              }
            }
            v15 = 0;
            goto LABEL_97;
          }
        }
LABEL_65:
        v56 = 4;
        goto LABEL_59;
      }
      goto LABEL_66;
    }
    v56 = 2;
    goto LABEL_59;
  }
LABEL_60:
  v15 = -2147467259;
LABEL_97:
  if ( Buf )
    sub_1001E93E((int *)&Buf, (int *)&v57, 0);
  if ( v52 )
    operator delete(v52);
  return v15;
}

// grim_load_image_dds @ 0x10011D95
// [binja] int32_t __thiscall sub_10011d95(int32_t* arg1, uint32_t arg2, int32_t* arg3)
int grim_load_image_dds(int *arg1, uint arg2, int *arg3)
{
  int *v3; // ecx
  int *v4; // esi
  int *v5; // ebx
  int v7; // eax
  int v8; // eax
  int *v9; // edi
  int v10; // eax
  int v11; // edi
  int *v12; // eax
  _DWORD *v13; // esi
  int *v14; // eax
  unsigned int v15; // edi
  int v16; // ebx
  int *v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // edx
  int *v21; // [esp-4h] [ebp-38h]
  int *v22; // [esp+8h] [ebp-2Ch]
  int *v23; // [esp+Ch] [ebp-28h]
  int v24; // [esp+10h] [ebp-24h]
  unsigned int v25; // [esp+14h] [ebp-20h]
  unsigned int v26; // [esp+18h] [ebp-1Ch]
  int *v27; // [esp+1Ch] [ebp-18h]
  unsigned int v28; // [esp+20h] [ebp-14h]
  int v29; // [esp+24h] [ebp-10h]
  int v30; // [esp+28h] [ebp-Ch]
  int *v31; // [esp+2Ch] [ebp-8h]
  int *v32; // [esp+30h] [ebp-4h]
  unsigned int arg1a; // [esp+3Ch] [ebp+8h]
  uint arg2a; // [esp+40h] [ebp+Ch]
  uint arg2b; // [esp+40h] [ebp+Ch]

  v5 = v3;
  v31 = v3;
  if ( arg2 < 4 )
    return -2147467259;
  if ( *arg1 != 542327876 )
    return -2147467259;
  arg2a = arg2 - 4;
  if ( arg2a < 0x7C )
    return -2147467259;
  arg2b = arg2a - 124;
  v21 = v4;
  v32 = arg1 + 32;
  v3[3] = arg1[4];
  v3[4] = arg1[3];
  if ( *((char *)arg1 + 10) >= 0 )
    v7 = 1;
  else
    v7 = arg1[6];
  v3[5] = v7;
  if ( !v7 )
    v3[5] = 1;
  v8 = arg1[28] & 0xFC00;
  if ( v8 == 64512 )
  {
    v28 = 6;
  }
  else
  {
    if ( v8 )
      return -2147467259;
    v28 = 1;
  }
  v25 = arg1[7];
  if ( !v25 )
    v25 = 1;
  v9 = &dword_10053EC8;
  if ( dword_10053EC8 )
  {
    do
    {
      if ( arg1[19] == 32 )
      {
        v10 = v9[2];
        if ( arg1[20] == v10 )
        {
          if ( ((v10 & 4) == 0 || arg1[21] == v9[3])
            && ((v10 & 0xC4462) == 0 || arg1[22] == v9[4])
            && ((v10 & 0xE4040) == 0 || arg1[23] == v9[5])
            && ((v10 & 0xC4440) == 0 || arg1[24] == v9[6])
            && ((v10 & 0xC4040) == 0 || arg1[25] == v9[7])
            && ((v10 & 0x80003) == 0 || arg1[26] == v9[8]) )
          {
            v5 = v3;
            break;
          }
          v5 = v3;
        }
      }
      v9 += 9;
    }
    while ( *v9 );
  }
  v11 = *v9;
  v24 = v11;
  if ( v11 )
  {
    v12 = grim_format_info_lookup(v11);
    v22 = v12;
    if ( *((char *)arg1 + 10) >= 0 )
      v5[17] = 2 * (v28 == 6) + 3;
    else
      v5[17] = 4;
    if ( v12[1] != 1 )
    {
      v23 = 0;
      goto LABEL_43;
    }
    if ( arg2b >= 0x400 )
    {
      v32 = arg1 + 288;
      arg2b -= 1024;
      v23 = arg1 + 32;
LABEL_43:
      v29 = 0;
      v13 = (_DWORD *)arg2b;
      while ( 1 )
      {
        v14 = v31;
        v15 = v5[3];
        v16 = v5[4];
        v26 = v16;
        arg1a = v31[5];
        if ( v29 )
        {
          if ( operator new(0x54u) )
            v14 = FUN_10010285(v21);
          else
            v14 = 0;
          if ( !v14 )
            return -2147024882;
          v27[20] = (int)v14;
        }
        v30 = 0;
        v27 = v14;
        if ( v25 )
        {
          while ( 1 )
          {
            if ( v30 )
            {
              if ( operator new(0x54u) )
                v17 = FUN_10010285(v21);
              else
                v17 = 0;
              if ( !v17 )
                return -2147024882;
              v13[19] = v17;
              v13 = v17;
            }
            else
            {
              v13 = v27;
            }
            if ( v24 == 827611204 )
              break;
            switch ( v24 )
            {
              case 844388420:
                goto LABEL_69;
              case 844715353:
                goto LABEL_67;
              case 861165636:
              case 877942852:
              case 894720068:
LABEL_69:
                v18 = 16 * ((v15 + 3) >> 2);
LABEL_71:
                v19 = v18 * ((unsigned int)(v16 + 3) >> 2);
                goto LABEL_72;
              case 1498831189:
LABEL_67:
                v18 = 4 * ((v15 + 1) >> 1);
                break;
              default:
                v18 = v15 * ((unsigned int)v22[2] >> 3);
                break;
            }
            v19 = v16 * v18;
LABEL_72:
            v13[14] = 0;
            v13[15] = 0;
            v20 = arg1a * v19;
            *v13 = v24;
            v13[12] = v18;
            v13[1] = v32;
            v13[5] = arg1a;
            v13[13] = v19;
            v13[3] = v15;
            v13[4] = v26;
            v13[2] = v23;
            if ( arg2b < arg1a * v19 )
              return -2147467259;
            v32 = (int *)((char *)v32 + v20);
            arg2b -= v20;
            if ( v15 == 1 )
              v15 = 1;
            else
              v15 >>= 1;
            if ( v26 == 1 )
              v16 = 1;
            else
              v16 = v26 >> 1;
            v26 = v16;
            if ( arg1a == 1 )
              arg1a = 1;
            else
              arg1a >>= 1;
            if ( ++v30 >= v25 )
              goto LABEL_83;
          }
          v18 = 8 * ((v15 + 3) >> 2);
          goto LABEL_71;
        }
LABEL_83:
        if ( ++v29 >= v28 )
          return 0;
        v5 = v31;
      }
    }
  }
  return -2147467259;
}

// FUN_100120d6 @ 0x100120D6
// [binja] int32_t __thiscall sub_100120d6(int32_t* arg1, HANDLE arg2)
int FUN_100120d6(int *arg1, HANDLE arg2)
{
  int *v2; // ecx
  int *v3; // esi
  int *i; // eax
  int v5; // eax
  int *v6; // ebx
  int v7; // ecx
  int v9; // eax
  int *v10; // esi
  unsigned int v11; // eax
  int *j; // esi
  bool v13; // zf
  unsigned int v14; // eax
  int v15; // edi
  int v16; // eax
  const void *v17; // eax
  DWORD v18; // ecx
  unsigned int v19; // eax
  _DWORD v20[31]; // [esp+Ch] [ebp-20h] BYREF
  int Buffer; // [esp+88h] [ebp+5Ch] BYREF
  int *v22; // [esp+8Ch] [ebp+60h]
  unsigned int v23; // [esp+90h] [ebp+64h]
  DWORD NumberOfBytesWritten; // [esp+94h] [ebp+68h] BYREF
  int *v25; // [esp+98h] [ebp+6Ch]
  int v26; // [esp+9Ch] [ebp+70h]

  v3 = v2;
  v22 = v2;
  v26 = 0;
  for ( i = v2; i; ++v26 )
    i = (int *)i[19];
  v5 = dword_10053EC8;
  v6 = &dword_10053EC8;
  if ( dword_10053EC8 )
  {
    v7 = *v2;
    do
    {
      if ( v5 == v7 )
        break;
      v6 += 9;
      v5 = *v6;
    }
    while ( *v6 );
  }
  if ( !*v6 )
    return -2147467259;
  v25 = grim_format_info_lookup(*v3);
  v23 = (unsigned int)v25[2] >> 3;
  Buffer = 542327876;
  WriteFile(arg1, &Buffer, 4u, &NumberOfBytesWritten, 0);
  memset(v20, 0, sizeof(v20));
  v20[2] = v3[4];
  v20[3] = v3[3];
  v9 = v6[2];
  v20[0] = 124;
  v20[1] = 4103;
  qmemcpy(&v20[18], v6 + 1, 0x20u);
  v20[26] = 4096;
  if ( (v9 & 3) != 0 )
    v20[26] = 4098;
  if ( (v9 & 0x20) != 0 )
    BYTE1(v20[26]) |= 1u;
  v10 = v22;
  if ( v22[19] )
  {
    v20[26] |= 0x400008u;
    v20[1] = 135175;
    v20[6] = v26;
  }
  if ( v22[20] )
  {
    v20[26] |= 8u;
    BYTE1(v20[27]) |= 0xFEu;
  }
  v11 = v22[5];
  if ( v11 > 1 )
  {
    BYTE2(v20[1]) |= 0x80u;
    BYTE2(v20[27]) |= 0x20u;
    v20[5] = v11;
  }
  WriteFile(arg1, v20, 0x7Cu, &NumberOfBytesWritten, 0);
  if ( v25[1] == 1 )
    WriteFile(arg1, (LPCVOID)v10[2], 0x400u, &NumberOfBytesWritten, 0);
  v25 = v10;
  do
  {
    for ( j = v25; j; j = (int *)j[19] )
    {
      v13 = j[5] == 0;
      v26 = 0;
      if ( !v13 )
      {
        v14 = j[4];
        while ( 1 )
        {
          v15 = 0;
          if ( v14 )
            break;
LABEL_39:
          if ( ++v26 >= (unsigned int)j[5] )
            goto LABEL_40;
        }
        while ( 2 )
        {
          v16 = *v22;
          if ( *v22 == 827611204 )
          {
            v19 = j[13] * (v26 + j[10]) + j[12] * ((unsigned int)(v15 + j[7]) >> 2) + 8 * ((unsigned int)j[6] >> 2);
            v18 = 8 * ((unsigned int)(j[3] + 3) >> 2);
          }
          else
          {
            if ( v16 != 844388420 )
            {
              if ( v16 == 844715353 )
                goto LABEL_34;
              if ( v16 != 861165636 && v16 != 877942852 && v16 != 894720068 )
              {
                if ( v16 != 1498831189 )
                {
                  v17 = (const void *)(j[1] + v23 * j[6] + j[13] * (v26 + j[10]) + j[12] * (v15 + j[7]));
                  v18 = v23 * j[3];
                  goto LABEL_38;
                }
LABEL_34:
                v17 = (const void *)(j[1] + v23 * j[6] + j[13] * (v26 + j[10]) + j[12] * (v15 + j[7]));
                v18 = 4 * ((unsigned int)(j[3] + 1) >> 1);
LABEL_38:
                WriteFile(arg1, v17, v18, &NumberOfBytesWritten, 0);
                v14 = j[4];
                if ( ++v15 >= v14 )
                  goto LABEL_39;
                continue;
              }
            }
            v19 = 16 * ((unsigned int)j[6] >> 2) + j[13] * (v26 + j[10]) + j[12] * ((unsigned int)(v15 + j[7]) >> 2);
            v18 = 16 * ((unsigned int)(j[3] + 3) >> 2);
          }
          break;
        }
        v17 = (const void *)(j[1] + v19);
        v15 += 3;
        goto LABEL_38;
      }
LABEL_40:
      ;
    }
    v25 = (int *)v25[20];
  }
  while ( v25 );
  return 0;
}

// FUN_1001237e @ 0x1001237E
// [binja] int32_t __thiscall sub_1001237e(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4)
int FUN_1001237e(int *arg1, int arg2, int arg3, int *arg4)
{
  int *v4; // ecx
  int *v5; // esi
  int v6; // edi
  int *v7; // ebx
  int *v8; // eax
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // eax
  int *v12; // ebx
  int v13; // esi
  int v14; // eax
  int *v16; // [esp+0h] [ebp-E0h]
  int *v17; // [esp+0h] [ebp-E0h]
  int *v18; // [esp+0h] [ebp-E0h]
  void **v19[4]; // [esp+Ch] [ebp-D4h] BYREF
  _BYTE v20[24]; // [esp+1Ch] [ebp-C4h] BYREF
  _BYTE v21[24]; // [esp+34h] [ebp-ACh] BYREF
  int v22; // [esp+4Ch] [ebp-94h]
  int v23; // [esp+50h] [ebp-90h]
  int v24; // [esp+54h] [ebp-8Ch]
  int arg1a[2]; // [esp+58h] [ebp-88h] BYREF
  int v26; // [esp+60h] [ebp-80h]
  int v27; // [esp+64h] [ebp-7Ch]
  _DWORD v28[6]; // [esp+68h] [ebp-78h] BYREF
  _BYTE v29[24]; // [esp+80h] [ebp-60h] BYREF
  int v30; // [esp+98h] [ebp-48h]
  int v31; // [esp+9Ch] [ebp-44h]
  int v32; // [esp+A0h] [ebp-40h]
  HANDLE hFile; // [esp+A4h] [ebp-3Ch]
  int *v34; // [esp+C0h] [ebp-20h]
  int v35; // [esp+C4h] [ebp-1Ch]
  void *v36; // [esp+C8h] [ebp-18h]
  int *v37; // [esp+CCh] [ebp-14h]
  unsigned int v38; // [esp+D0h] [ebp-10h]
  int v39; // [esp+DCh] [ebp-4h]

  v5 = v4;
  v34 = v4;
  FUN_1001bca5(v16);
  v6 = arg2;
  v39 = 0;
  if ( !arg2 )
    goto LABEL_7;
  if ( arg2 <= 0 )
  {
LABEL_25:
    v13 = -2005530516;
    goto LABEL_37;
  }
  if ( arg2 <= 3 )
  {
LABEL_24:
    v13 = -2005529767;
    goto LABEL_37;
  }
  if ( arg2 != 4 )
  {
    if ( arg2 != 5 )
    {
      if ( arg2 == 6 )
      {
LABEL_7:
        v7 = (int *)&unk_10053E28;
        goto LABEL_8;
      }
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  v7 = (int *)&unk_10053E40;
LABEL_8:
  v8 = grim_format_info_lookup(*v5);
  v9 = sub_1000AB3F(v7, v5[2], (int)v8);
  v10 = v9;
  v35 = v9;
  if ( !v9 )
    goto LABEL_24;
  if ( v9 == *v5 )
  {
LABEL_21:
    v14 = FUN_1001bdc7((void **)arg1, arg3, v17);
    if ( v14 < 0 )
    {
LABEL_22:
      v13 = v14;
      goto LABEL_37;
    }
    if ( v6 )
    {
      if ( v6 == 4 )
      {
        v14 = FUN_100120d6((int *)hFile, v17);
      }
      else
      {
        if ( v6 != 6 )
        {
          v14 = -2147467263;
          goto LABEL_22;
        }
        v14 = FUN_10010aec((int *)hFile, 0);
      }
    }
    else
    {
      v14 = FUN_10010aec((int *)hFile, HANDLE_FLAG_INHERIT);
    }
    if ( v14 >= 0 )
    {
      v13 = 0;
      goto LABEL_37;
    }
    goto LABEL_22;
  }
  FUN_1001284c(v17);
  LOBYTE(v39) = 1;
  v11 = (unsigned int)grim_format_info_lookup(v10)[2] >> 3;
  v38 = v11;
  v37 = v5;
  while ( 1 )
  {
    v12 = v37;
    if ( v37 )
      break;
LABEL_19:
    v37 = (int *)v37[20];
    if ( !v37 )
    {
      LOBYTE(v39) = 0;
      FUN_10012856(v18);
      goto LABEL_21;
    }
  }
  while ( 1 )
  {
    v36 = operator new(v12[4] * v11 * v12[3] * v12[5]);
    if ( !v36 )
    {
      LOBYTE(v39) = 0;
      FUN_10012856(v18);
      v13 = -2147024882;
      goto LABEL_37;
    }
    v19[0] = (void **)v12[1];
    v19[1] = (void **)*v12;
    v19[2] = (void **)v12[12];
    v19[3] = (void **)v12[13];
    qmemcpy(v20, v12 + 6, sizeof(v20));
    qmemcpy(v21, v12 + 6, sizeof(v21));
    v23 = 0;
    v22 = 1;
    v24 = v12[2];
    arg1a[0] = (int)v36;
    arg1a[1] = v35;
    v26 = v38 * v12[3];
    v27 = v12[4] * v38 * v12[3];
    v28[0] = 0;
    v28[1] = 0;
    v28[2] = v12[3];
    v28[3] = v12[4];
    v28[4] = 0;
    v28[5] = v12[5];
    qmemcpy(v29, v28, sizeof(v29));
    v31 = 0;
    v30 = 1;
    v32 = v12[2];
    v13 = FUN_10016007(arg1a, v19, (void ***)0x80001, (int)v18);
    if ( v13 < 0 )
      break;
    if ( v12[1] && v12[14] )
    {
      operator delete((void *)v12[1]);
      v12[1] = 0;
    }
    *v12 = v35;
    v12[1] = (int)v36;
    qmemcpy(v12 + 6, v29, 0x18u);
    v12[12] = v26;
    v12[13] = v27;
    v11 = v38;
    v12[14] = 1;
    v12 = (int *)v12[19];
    if ( !v12 )
    {
      v6 = arg2;
      goto LABEL_19;
    }
  }
  operator delete(v36);
  LOBYTE(v39) = 0;
  FUN_10012856(v18);
LABEL_37:
  v39 = -1;
  FUN_1001bed2(v17);
  return v13;
}

// FUN_10012677 @ 0x10012677
// [binja] int32_t __thiscall sub_10012677(int32_t* arg1, void* arg2, int32_t* arg3, int32_t* arg4, int32_t arg5)
int FUN_10012677(int *arg1, void *arg2, int *arg3, int *arg4, int arg5)
{
  int v5; // ecx
  void *v6; // ebx
  int v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int image_bmp; // eax
  bool v15; // cf
  _DWORD *i; // eax
  _DWORD *v18; // eax
  int v19; // ecx
  void *v20; // [esp+0h] [ebp-2Ch]
  _DWORD v21[7]; // [esp+Ch] [ebp-20h]
  int v22; // [esp+28h] [ebp-4h]

  v6 = arg2;
  v7 = v5;
  v21[0] = 0;
  v21[1] = 5;
  v21[2] = 4;
  v21[3] = 1;
  v21[4] = 3;
  v21[5] = 2;
  v21[6] = 6;
  v22 = 0;
  do
  {
    *(_DWORD *)(v7 + 64) = arg4;
    v8 = v21[v22];
    *(_DWORD *)(v7 + 72) = v8;
    *(_DWORD *)(v7 + 68) = 3;
    if ( !v8 )
    {
      image_bmp = grim_load_image_bmp((__int16 *)arg1, arg2);
      goto LABEL_16;
    }
    v9 = v8 - 1;
    if ( !v9 )
    {
      image_bmp = grim_load_image_jpg(arg1, (int)arg2, (int)v20);
      goto LABEL_16;
    }
    v10 = v9 - 1;
    if ( !v10 )
    {
      image_bmp = FUN_10011083(arg1, arg2, (int)v20);
      goto LABEL_16;
    }
    v11 = v10 - 1;
    if ( !v11 )
    {
      image_bmp = grim_load_image_png(arg1, arg2, v20);
      goto LABEL_16;
    }
    v12 = v11 - 1;
    if ( !v12 )
    {
      image_bmp = grim_load_image_dds(arg1, (uint)arg2, (int *)v20);
      goto LABEL_16;
    }
    v13 = v12 - 1;
    if ( !v13 )
    {
      image_bmp = grim_load_image_pnm(arg1, (char *)arg2, (int)v20);
      goto LABEL_16;
    }
    if ( v13 == 1 )
    {
      image_bmp = FUN_100103d6(arg1, arg2, v20);
LABEL_16:
      v6 = (void *)image_bmp;
    }
    if ( (int)v6 >= 0 )
      break;
    if ( *(_DWORD *)(v7 + 4) && *(_DWORD *)(v7 + 56) )
      operator delete(*(void **)(v7 + 4));
    if ( *(_DWORD *)(v7 + 8) && *(_DWORD *)(v7 + 60) )
      operator delete(*(void **)(v7 + 8));
    if ( *(_DWORD *)(v7 + 76) )
      FUN_100102f7((void *)1, (char)v20);
    if ( *(_DWORD *)(v7 + 80) )
      FUN_100102f7((void *)1, (char)v20);
    v15 = (unsigned int)++v22 < 7;
    *(_DWORD *)(v7 + 4) = 0;
    *(_DWORD *)(v7 + 8) = 0;
    *(_DWORD *)(v7 + 56) = 0;
    *(_DWORD *)(v7 + 60) = 0;
    *(_DWORD *)(v7 + 76) = 0;
    *(_DWORD *)(v7 + 80) = 0;
  }
  while ( v15 );
  if ( v22 == 7 )
    return -2005529767;
  if ( arg3 )
  {
    memset(arg3, 0, 0x1Cu);
    *arg3 = *(_DWORD *)(v7 + 12);
    arg3[1] = *(_DWORD *)(v7 + 16);
    arg3[2] = *(_DWORD *)(v7 + 20);
    arg3[3] = 1;
    arg3[4] = sub_1000AC8F(*(_DWORD *)v7);
    arg3[5] = *(_DWORD *)(v7 + 68);
    arg3[6] = *(_DWORD *)(v7 + 72);
    for ( i = (_DWORD *)(v7 + 76); *i; i = (_DWORD *)(*i + 76) )
      ++arg3[3];
  }
  do
  {
    v18 = (_DWORD *)v7;
    if ( v7 )
    {
      do
      {
        v18[8] = v18[3];
        v18[9] = v18[4];
        v19 = v18[5];
        v18[6] = 0;
        v18[7] = 0;
        v18[10] = 0;
        v18[11] = v19;
        v18 = (_DWORD *)v18[19];
      }
      while ( v18 );
    }
    v7 = *(_DWORD *)(v7 + 80);
  }
  while ( v7 );
  return 0;
}

// FUN_1001284c @ 0x1001284C
// [binja] int32_t* __fastcall sub_1001284c(int32_t* arg1)
int *FUN_1001284c(int *arg1)
{
  int *v1; // ecx

  v1[1] = 0;
  *v1 = 0;
  return v1;
}

// FUN_10012856 @ 0x10012856
// [binja] void __fastcall sub_10012856(int32_t* arg1)
void FUN_10012856(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  void (__thiscall ***v3)(_DWORD, int); // ecx

  v2 = v1;
  v3 = (void (__thiscall ***)(_DWORD, int))v1[1];
  if ( v3 )
    (**v3)(v3, 1);
  if ( *v2 )
    (**(void (__thiscall ***)(_DWORD, int))*v2)(*v2, 1);
}

// sub_1001288A @ 0x1001288A
_DWORD *__cdecl sub_1001288A(unsigned int a1, signed int a2, int a3)
{
  unsigned int v3; // edi
  double v4; // st7
  double v5; // st6
  unsigned int v6; // esi
  __int64 v7; // rax
  _DWORD *v8; // edi
  int v9; // ebx
  int v10; // esi
  double v11; // st7
  double X; // st7
  int v13; // edx
  double v14; // st7
  int v15; // ecx
  float *v16; // eax
  double v17; // st6
  float *v18; // eax
  _DWORD *v20; // [esp+14h] [ebp-3Ch]
  int v21; // [esp+18h] [ebp-38h]
  float v22; // [esp+1Ch] [ebp-34h]
  float v23; // [esp+20h] [ebp-30h]
  float v24; // [esp+24h] [ebp-2Ch]
  float v25; // [esp+28h] [ebp-28h]
  int i; // [esp+2Ch] [ebp-24h]
  float v27; // [esp+30h] [ebp-20h]
  float v28; // [esp+34h] [ebp-1Ch]
  unsigned int v29; // [esp+38h] [ebp-18h]
  float v30; // [esp+3Ch] [ebp-14h]
  float v31; // [esp+40h] [ebp-10h]
  unsigned int v32; // [esp+44h] [ebp-Ch]
  float v33; // [esp+48h] [ebp-8h]
  float v34; // [esp+4Ch] [ebp-4h]

  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v28 = (float)(unsigned int)a2;
      v4 = (double)a1;
      v23 = v4;
      v5 = v28 / v4;
      v6 = 16;
      v25 = v5;
      v22 = 0.5 / v5;
      do
      {
        v7 = (__int64)(((double)v3 - 0.5) * v5 + v5 - ((double)v3 - 0.5) * v5 + (double)(a3 != 0) + 1.0);
        ++v3;
        v6 += 16 * v7 + 12;
      }
      while ( v3 < a1 );
      v8 = operator new(v6);
      if ( v8 )
      {
        v9 = 0;
        v29 = 0;
        v34 = 0.0;
        v10 = 1;
        while ( 1 )
        {
          v32 = 0;
          v20 = &v8[v10];
          v21 = v10 * 4;
          ++v10;
          do
          {
            v24 = (float)v29;
            v11 = (double)v32 + v24 - 0.5;
            v31 = v11;
            X = v11 * v25;
            v27 = X;
            v33 = v25 + X;
            if ( !a3 )
            {
              if ( X < 0.0 )
              {
                X = 0.0;
                v27 = 0.0;
              }
              if ( v33 > (double)v28 )
                v33 = (float)(unsigned int)a2;
            }
            v13 = (__int64)floor(X);
            v14 = (double)v13;
            if ( v14 < v33 )
            {
              v15 = v13 - a2;
              for ( i = v13 - a2; ; v15 = i )
              {
                v30 = v14 + 1.0;
                if ( v13 >= 0 )
                {
                  if ( v13 < a2 )
                    v15 = v13;
                }
                else
                {
                  v15 = v13 + a2;
                }
                if ( v15 != v9 )
                {
                  if ( v34 > 0.0000099999997 )
                  {
                    v16 = (float *)&v8[v10];
                    *(_DWORD *)v16 = v9;
                    v10 += 2;
                    v16[1] = v34;
                  }
                  v9 = v15;
                  v34 = 0.0;
                }
                if ( v14 < v27 )
                  v14 = v27;
                if ( v30 > (double)v33 )
                  v30 = v33;
                if ( a3 )
                  goto LABEL_33;
                if ( v31 < 0.0 )
                {
                  v17 = 1.0;
                  goto LABEL_34;
                }
                if ( v31 + 1.0 < v23 )
LABEL_33:
                  v17 = (v30 + v14) * v22 - v31;
                else
                  v17 = 0.0;
LABEL_34:
                if ( v32 )
                  v17 = 1.0 - v17;
                ++v13;
                ++i;
                v34 = (v30 - v14) * v17 + v34;
                v14 = (double)v13;
                if ( v14 >= v33 )
                  break;
              }
            }
            ++v32;
          }
          while ( v32 < 2 );
          if ( v34 > 0.0000099999997 )
          {
            v18 = (float *)&v8[v10];
            v10 += 2;
            *(_DWORD *)v18 = v9;
            v18[1] = v34;
          }
          v34 = 0.0;
          ++v29;
          *v20 = v10 * 4 - v21;
          if ( v29 >= a1 )
          {
            *v8 = v10 * 4;
            return v8;
          }
        }
      }
    }
  }
  return 0;
}

// FUN_10012b47 @ 0x10012B47
// [binja] int32_t* __thiscall sub_10012b47(int32_t* arg1, char arg2)
int *FUN_10012b47(int *arg1, char arg2)
{
  void **v2; // ecx
  void **v3; // esi

  v3 = v2;
  if ( ((unsigned __int8)arg1 & 2) != 0 )
  {
    FUN_1004b5cf((int)v2, 12, (int)*(v2 - 1), (int)Concurrency::SchedulerPolicy::~SchedulerPolicy);
    if ( ((unsigned __int8)arg1 & 1) != 0 )
      operator delete(v3 - 1);
    return (int *)(v3 - 1);
  }
  else
  {
    operator delete(*v2);
    if ( ((unsigned __int8)arg1 & 1) != 0 )
      operator delete(v3);
    return (int *)v3;
  }
}

// FUN_10012b93 @ 0x10012B93
// [binja] int32_t __fastcall sub_10012b93(int32_t* arg1)
int FUN_10012b93(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  unsigned int v3; // edi
  BOOL v4; // edi
  int v5; // edi
  int *v6; // eax
  void *v7; // eax
  int v8; // edi
  char *v9; // eax
  void *v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // edx
  _DWORD *i; // ecx
  float *v14; // eax
  float *v15; // edx
  void **v16; // ebx
  int v17; // edi
  void *v18; // eax
  void *v19; // eax
  unsigned int v20; // edi
  float *v21; // edx
  float *v22; // eax
  float *v23; // ecx
  float *v24; // ebx
  int v25; // eax
  float *k; // ecx
  double v27; // st7
  float *v28; // edi
  float *m; // ebx
  void **v30; // edi
  bool v31; // zf
  _DWORD *v32; // ecx
  int v33; // esi
  BOOL v35; // [esp-4h] [ebp-6Ch]
  char v36; // [esp+0h] [ebp-68h]
  void *v37; // [esp+Ch] [ebp-5Ch]
  char *v38; // [esp+Ch] [ebp-5Ch]
  void *v39; // [esp+10h] [ebp-58h]
  void *v40; // [esp+10h] [ebp-58h]
  BOOL v41; // [esp+14h] [ebp-54h]
  float *v42; // [esp+14h] [ebp-54h]
  unsigned int v43; // [esp+18h] [ebp-50h]
  unsigned int v44; // [esp+1Ch] [ebp-4Ch]
  void *v45; // [esp+20h] [ebp-48h]
  float *v46; // [esp+20h] [ebp-48h]
  float *v47; // [esp+24h] [ebp-44h]
  int v48; // [esp+28h] [ebp-40h]
  _DWORD *v49; // [esp+2Ch] [ebp-3Ch]
  int v50; // [esp+30h] [ebp-38h]
  float *v51; // [esp+34h] [ebp-34h]
  float *v52; // [esp+38h] [ebp-30h]
  _DWORD *v53; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v54; // [esp+40h] [ebp-28h]
  unsigned int v55; // [esp+44h] [ebp-24h]
  void **v56; // [esp+48h] [ebp-20h]
  char *v57; // [esp+4Ch] [ebp-1Ch]
  unsigned int v58; // [esp+50h] [ebp-18h]
  _DWORD *v59; // [esp+54h] [ebp-14h]
  float *j; // [esp+58h] [ebp-10h]
  float *v61; // [esp+58h] [ebp-10h]
  unsigned int v62; // [esp+58h] [ebp-10h]

  v2 = v1;
  v53 = 0;
  v54 = 0;
  v39 = 0;
  v56 = 0;
  v37 = 0;
  v3 = v1[2];
  v41 = ((v3 >> 18) & 1) == 0;
  v35 = (v3 & 0x10000) == 0;
  v4 = ((v3 >> 17) & 1) == 0;
  v47 = (float *)sub_1001288A(*(_DWORD *)(*v1 + 4184), *(_DWORD *)(v1[1] + 4184), v35);
  if ( v47
    && (v53 = sub_1001288A(*(_DWORD *)(*v2 + 4188), *(_DWORD *)(v2[1] + 4188), v4)) != 0
    && (v54 = sub_1001288A(*(_DWORD *)(*v2 + 4192), *(_DWORD *)(v2[1] + 4192), v41)) != 0 )
  {
    v44 = (unsigned int)v47 + *(_DWORD *)v47;
    v43 = (unsigned int)v53 + *v53;
    v55 = (unsigned int)v54 + *v54;
    v5 = *(_DWORD *)(v2[1] + 4192);
    v6 = (int *)operator new(12 * v5 + 4);
    if ( v6 )
    {
      *v6 = v5;
      v40 = v6 + 1;
      FUN_1004b6c3((int)(v6 + 1), 12, v5, (int)unknown_libname_2);
      v7 = v40;
      v59 = v40;
    }
    else
    {
      v59 = 0;
      v7 = 0;
    }
    v39 = v7;
    if ( !v7 )
      goto LABEL_54;
    v8 = *(_DWORD *)(*v2 + 4184);
    v9 = (char *)operator new(16 * v8);
    v38 = v9;
    if ( v9 )
    {
      sub_1000B393((int)v9, 16, v8, (int (__thiscall *)(int))sub_1000AE4F);
      v10 = v38;
      v57 = v38;
    }
    else
    {
      v57 = 0;
      v10 = 0;
    }
    v37 = v10;
    if ( v10 )
    {
      v11 = v54 + 1;
      if ( (unsigned int)(v54 + 1) < v55 )
      {
        do
        {
          v12 = (_DWORD *)((char *)v11 + *v11);
          for ( i = v11 + 1; i < v12; i += 2 )
            ++v59[3 * *i + 2];
          v11 = v12;
        }
        while ( (unsigned int)v12 < v55 );
      }
      v48 = 0;
      v14 = (float *)(v54 + 1);
      if ( (unsigned int)(v54 + 1) < v55 )
      {
        do
        {
          v15 = (float *)((char *)v14 + *(_DWORD *)v14);
          v58 = (unsigned int)v15;
          v42 = v14 + 1;
          for ( j = v14 + 1; j < v15; j += 2 )
          {
            v16 = (void **)&v59[3 * *(_DWORD *)j];
            if ( !*v16 )
            {
              if ( v56 )
              {
                *v16 = *v56;
                *v56 = 0;
                v56 = (void **)v56[1];
              }
              else
              {
                v17 = *(_DWORD *)(v2[1] + 4184) * *(_DWORD *)(v2[1] + 4188);
                v18 = operator new(16 * v17);
                v45 = v18;
                if ( v18 )
                {
                  sub_1000B393((int)v18, 16, v17, (int (__thiscall *)(int))sub_1000AE4F);
                  v19 = v45;
                }
                else
                {
                  v19 = 0;
                }
                *v16 = v19;
                if ( !v19 )
                  goto LABEL_54;
                v15 = (float *)v58;
              }
              memset(*v16, 0, 16 * *(_DWORD *)(v2[1] + 4184) * *(_DWORD *)(v2[1] + 4188));
            }
          }
          v50 = 0;
          v49 = v53 + 1;
          if ( (unsigned int)(v53 + 1) < v43 )
          {
            do
            {
              v20 = (unsigned int)v49 + *v49;
              v46 = (float *)v20;
              (*(void (__stdcall **)(int, int, char *))(*(_DWORD *)*v2 + 4))(v50, v48, v57);
              v51 = v47 + 1;
              if ( (unsigned int)(v47 + 1) < v44 )
              {
                v21 = (float *)(v57 + 8);
                do
                {
                  v22 = (float *)((char *)v51 + *(_DWORD *)v51);
                  v23 = v42;
                  v52 = v22;
                  while ( 1 )
                  {
                    v61 = v23;
                    if ( (unsigned int)v23 >= v58 )
                      break;
                    v24 = (float *)(v49 + 1);
                    if ( (unsigned int)(v49 + 1) < v20 )
                    {
                      do
                      {
                        v25 = v59[3 * *(_DWORD *)v23] + 16 * *(_DWORD *)v24 * *(_DWORD *)(v2[1] + 4184);
                        for ( k = v51 + 1; k < v52; k += 2 )
                        {
                          v27 = k[1] * v24[1] * v61[1];
                          *(float *)(v25 + 16 * *(_DWORD *)k) = v27 * *(v21 - 2) + *(float *)(v25 + 16 * *(_DWORD *)k);
                          *(float *)(16 * *(_DWORD *)k + v25 + 4) = v27 * *(v21 - 1)
                                                                  + *(float *)(16 * *(_DWORD *)k + v25 + 4);
                          *(float *)(16 * *(_DWORD *)k + v25 + 8) = v27 * *v21 + *(float *)(16 * *(_DWORD *)k + v25 + 8);
                          v28 = (float *)(16 * *(_DWORD *)k + v25 + 12);
                          *v28 = v27 * v21[1] + *v28;
                        }
                        v23 = v61;
                        v24 += 2;
                      }
                      while ( v24 < v46 );
                      v20 = (unsigned int)v46;
                      v22 = v52;
                    }
                    v23 += 2;
                  }
                  v21 += 4;
                  v51 = v22;
                }
                while ( (unsigned int)v22 < v44 );
              }
              ++v50;
              v49 = (_DWORD *)v20;
            }
            while ( v20 < v43 );
            v15 = (float *)v58;
          }
          for ( m = v42; m < v15; m += 2 )
          {
            v30 = (void **)&v59[3 * *(_DWORD *)m];
            v31 = v30[2] == (void *)1;
            v30[2] = (char *)v30[2] - 1;
            if ( v31 )
            {
              v32 = (_DWORD *)v2[1];
              v62 = 0;
              if ( v32[1047] )
              {
                do
                {
                  (*(void (__stdcall **)(unsigned int, _DWORD, unsigned int))(*v32 + 8))(
                    v62,
                    *(_DWORD *)m,
                    (unsigned int)*v30 + 16 * v62 * v32[1046]);
                  ++v62;
                  v32 = (_DWORD *)v2[1];
                }
                while ( v62 < v32[1047] );
                v15 = (float *)v58;
              }
              v30[1] = v56;
              v56 = v30;
            }
          }
          ++v48;
          v14 = v15;
        }
        while ( (unsigned int)v15 < v55 );
      }
      v33 = 0;
    }
    else
    {
LABEL_54:
      v33 = -2147024882;
    }
  }
  else
  {
    v33 = -2147467259;
  }
  if ( v39 )
    FUN_10012b47((int *)3, v36);
  operator delete(v54);
  operator delete(v53);
  operator delete(v47);
  operator delete(v37);
  operator delete(0);
  return v33;
}

// FUN_10013007 @ 0x10013007
// [binja] int32_t __fastcall sub_10013007(int32_t* arg1)
int FUN_10013007(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // edi
  unsigned int v3; // esi
  int v5; // eax
  unsigned int v6; // ecx
  int v7; // edx
  unsigned int v8; // ecx
  int v9; // esi
  unsigned int v10; // eax
  _DWORD *v11; // edx
  char *v12; // ebx
  int v13; // eax
  int v14; // ecx
  int v15; // [esp-8h] [ebp-28h]
  unsigned int v16; // [esp+8h] [ebp-18h]
  unsigned int v17; // [esp+Ch] [ebp-14h]
  int v18; // [esp+Ch] [ebp-14h]
  unsigned int v19; // [esp+10h] [ebp-10h]
  unsigned int v20; // [esp+10h] [ebp-10h]
  int v21; // [esp+14h] [ebp-Ch]
  _DWORD *v22; // [esp+18h] [ebp-8h]
  unsigned int v23; // [esp+18h] [ebp-8h]
  char *i; // [esp+1Ch] [ebp-4h]

  v2 = (_DWORD *)*v1;
  v3 = *(_DWORD *)(*v1 + 4148);
  v22 = v1;
  v19 = *(_DWORD *)(*v1 + 4144);
  if ( (((unsigned __int8)v3
       | (unsigned __int8)(*(_BYTE *)(*v1 + 4144) | *(_BYTE *)(*v1 + 4152) | *(_BYTE *)(*v1 + 4156)))
      & 3) != 0 )
    return -2147467259;
  v5 = v1[1];
  v6 = *(_DWORD *)(v5 + 4148);
  v17 = *(_DWORD *)(v5 + 4144);
  if ( (((unsigned __int8)v6 | (unsigned __int8)(v17 | *(_BYTE *)(v5 + 4152) | *(_BYTE *)(v5 + 4156))) & 3) != 0 )
    return -2147467259;
  v7 = *(_DWORD *)(v5 + 4);
  if ( v7 == 827611204 )
  {
    v15 = 8;
  }
  else
  {
    if ( v7 != 844388420 && v7 != 861165636 && v7 != 877942852 && v7 != 894720068 )
      return -2147467259;
    v15 = 16;
  }
  v16 = v15 * (*(_DWORD *)(v5 + 4184) >> 2);
  v21 = *(_DWORD *)(v5 + 24)
      + v15 * (v17 >> 2)
      + *(_DWORD *)(v5 + 4160) * *(_DWORD *)(v5 + 4180)
      + *(_DWORD *)(v5 + 4176) * (v6 >> 2);
  v8 = v19;
  v20 = 0;
  v9 = v2[6] + v15 * (v8 >> 2) + v2[1040] * v2[1045] + v2[1044] * (v3 >> 2);
  v18 = v9;
  if ( *(_DWORD *)(v5 + 4192) )
  {
    v10 = *(_DWORD *)(v5 + 4188);
    v11 = v22;
    do
    {
      v23 = 0;
      v12 = (char *)v21;
      for ( i = (char *)v9; v23 < v10; i += *(_DWORD *)(*v11 + 4176) )
      {
        v23 += 4;
        qmemcpy(v12, i, v16);
        v13 = v11[1];
        v12 += *(_DWORD *)(v13 + 4176);
        v10 = *(_DWORD *)(v13 + 4188);
      }
      v14 = v11[1];
      v21 += *(_DWORD *)(v14 + 4180);
      v9 = *(_DWORD *)(*v11 + 4180) + v18;
      ++v20;
      v18 = v9;
    }
    while ( v20 < *(_DWORD *)(v14 + 4192) );
  }
  return 0;
}

// sub_10013195 @ 0x10013195
int __cdecl sub_10013195(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // edx
  int v7; // edi
  unsigned int *v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  unsigned int *v11; // ecx
  bool v12; // zf
  unsigned int v14; // [esp+4h] [ebp-18h]
  unsigned int v15; // [esp+8h] [ebp-14h]
  unsigned int v16; // [esp+Ch] [ebp-10h]
  unsigned int v17; // [esp+10h] [ebp-Ch]
  unsigned int *v18; // [esp+14h] [ebp-8h]
  unsigned int v19; // [esp+18h] [ebp-4h]
  unsigned int v20; // [esp+30h] [ebp+14h]

  v6 = a2;
  v7 = a5;
  v14 = a2 + a5 * a4;
  if ( a2 < v14 )
  {
    v20 = a2 + 4 * a3;
    do
    {
      v18 = a1;
      if ( v6 < v20 )
      {
        v8 = (unsigned int *)(v6 + 4);
        v16 = v6 + 4;
        v15 = ((v20 - v6 - 1) >> 3) + 1;
        do
        {
          v17 = *(unsigned int *)((char *)v8 + v7 - 4);
          v19 = *(unsigned int *)((char *)v8 + v7);
          v9 = *v8;
          v7 = a5;
          v10 = (((v19 >> 2) & 0x3FC03FC0)
               + ((v17 >> 2) & 0x3FC03FC0)
               + ((*(v8 - 1) >> 2) & 0x3FC03FC0)
               + ((v9 >> 2) & 0x3FC03FC0)
               + 8388736)
              ^ ((((v19 & 0xFF00FF) + (v17 & 0xFF00FF) + (*(v8 - 1) & 0xFF00FF) + (v9 & 0xFF00FF) + 131074) >> 2)
               ^ (((v19 >> 2) & 0xFFC03FC0)
                + ((v17 >> 2) & 0xFFC03FC0)
                + ((*(v8 - 1) >> 2) & 0xFFC03FC0)
                + ((v9 >> 2) & 0xFFC03FC0)
                - 8388480))
              & 0xFF00FF;
          v11 = v18++;
          *v11 = v10;
          v8 = (unsigned int *)(v16 + 8);
          v12 = v15-- == 1;
          v16 += 8;
        }
        while ( !v12 );
        v6 = a2;
      }
      a1 = (unsigned int *)((char *)a1 + a6);
      v20 += 2 * v7;
      v6 += 2 * v7;
      a2 = v6;
    }
    while ( v6 < v14 );
  }
  return 0;
}

// FUN_100132bb @ 0x100132BB
// [binja] int32_t __fastcall sub_100132bb(int32_t* arg1)
int FUN_100132bb(int *arg1)
{
  return off_10054390();
}

// sub_100132EC @ 0x100132EC
int __cdecl sub_100132EC(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  unsigned int v7; // edi
  _DWORD *v8; // esi
  unsigned int v9; // ebx
  unsigned int *v10; // eax
  bool v11; // zf
  unsigned int v13; // [esp+4h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-10h]
  unsigned int *v15; // [esp+18h] [ebp-4h]
  unsigned int v16; // [esp+30h] [ebp+14h]

  v6 = a5;
  v7 = a2;
  v13 = a2 + a5 * a4;
  if ( a2 < v13 )
  {
    v16 = a2 + 4 * a3;
    do
    {
      v15 = a1;
      if ( v7 < v16 )
      {
        v8 = (_DWORD *)(v7 + 4);
        v14 = ((v16 - v7 - 1) >> 3) + 1;
        do
        {
          v9 = ((*(_DWORD *)((char *)v8 + v6) & 0xFF00)
              + (*(_DWORD *)((char *)v8 + v6 - 4) & 0xFF00)
              + (*(v8 - 1) & 0xFF00)
              + (*v8 & 0xFF00)
              + 512)
             & 0x3FC00
             | ((*(_DWORD *)((char *)v8 + v6) & 0xFF00FF)
              + (*(_DWORD *)((char *)v8 + v6 - 4) & 0xFF00FF)
              + (*(v8 - 1) & 0xFF00FF)
              + (*v8 & 0xFF00FF)
              + 131074)
             & 0x3FC03FC;
          v10 = v15++;
          v8 += 2;
          v11 = v14-- == 1;
          *v10 = v9 >> 2;
          v6 = a5;
        }
        while ( !v11 );
        v7 = a2;
      }
      a1 = (unsigned int *)((char *)a1 + a6);
      v16 += 2 * v6;
      v7 += 2 * v6;
      a2 = v7;
    }
    while ( v7 < v13 );
  }
  return 0;
}

// sub_100133D4 @ 0x100133D4
int __cdecl sub_100133D4(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  __m64 *v7; // eax
  unsigned int *v8; // edx
  __m64 *v9; // edi
  __m64 *v10; // esi
  int v11; // ebx
  __m64 *i; // eax
  __m64 v13; // mm5
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 *v17; // ecx
  __m64 v18; // mm0
  __m64 *v19; // [esp+10h] [ebp-Ch]
  signed int v20; // [esp+18h] [ebp-4h]
  int v21; // [esp+2Ch] [ebp+10h]

  if ( (a3 & 3) != 0 )
    return sub_10013195(a1, a2, a3, a4, a5, a6);
  v20 = a2 + a5 * a4;
  _m_empty();
  v21 = 4 * a3;
  v7 = (__m64 *)a2;
  v8 = a1;
  if ( (int)a2 < v20 )
  {
    do
    {
      v9 = v7;
      v10 = (__m64 *)((char *)v7 + a5);
      v11 = (int)v7 + v21;
      v19 = v7;
      for ( i = (__m64 *)v8;
            (int)v9 < v11;
            v17->m64_u64 = (unsigned __int64)_m_packuswb(
                                               _m_psrawi(
                                                 _m_paddw(_m_paddw(_m_paddw(v18, v15), v16), (__m64)0x2000200020002LL),
                                                 2u),
                                               _m_psrawi(
                                                 _m_paddw(
                                                   _m_paddw(
                                                     _m_paddw(
                                                       _m_paddw(_m_punpcklbw(v13, 0), _m_punpckhbw(v13, 0)),
                                                       _m_punpcklbw(v14, 0)),
                                                     _m_punpckhbw(v14, 0)),
                                                   (__m64)0x2000200020002LL),
                                                 2u)) )
      {
        v13 = v9[1];
        v14 = v10[1];
        v15 = _m_punpcklbw((__m64)v10->m64_u64, 0);
        v16 = _m_punpckhbw((__m64)v10->m64_u64, 0);
        v17 = i;
        v18 = _m_paddw(_m_punpcklbw((__m64)v9->m64_u64, 0), _m_punpckhbw((__m64)v9->m64_u64, 0));
        v9 += 2;
        v10 += 2;
        ++i;
      }
      v7 = (__m64 *)((char *)v19 + a5 + a5);
      v8 = (unsigned int *)((char *)v8 + a6);
    }
    while ( (int)v7 < v20 );
  }
  _m_empty();
  return 0;
}

// sub_100134EA @ 0x100134EA
int sub_100134EA()
{
  if ( sub_1001BF5E() )
  {
    off_10054390 = (_DWORD (*)())sub_100133D4;
    off_10054394 = (int (*)())sub_100133D4;
  }
  else
  {
    off_10054390 = (_DWORD (*)())sub_10013195;
    off_10054394 = (int (*)())sub_100132EC;
  }
  return off_10054390();
}

// sub_10013522 @ 0x10013522
int sub_10013522()
{
  int (*v0)(); // eax

  if ( sub_1001BF5E() )
  {
    v0 = (int (*)())sub_100133D4;
    off_10054390 = (_DWORD (*)())sub_100133D4;
  }
  else
  {
    off_10054390 = (_DWORD (*)())sub_10013195;
    v0 = (int (*)())sub_100132EC;
  }
  off_10054394 = v0;
  return v0();
}

// FUN_10013551 @ 0x10013551
// [binja] int32_t __fastcall sub_10013551(int32_t* arg1)
int FUN_10013551(int *arg1)
{
  return off_10054394();
}

// FUN_10013582 @ 0x10013582
// [binja] int32_t __fastcall sub_10013582(int32_t* arg1)
int FUN_10013582(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // esi
  int v3; // edi
  unsigned __int16 *v4; // eax
  unsigned __int16 *v5; // ebp
  _WORD *v6; // edi
  unsigned __int16 *v7; // ebx
  int v8; // ecx
  int v9; // esi
  int v10; // eax
  __int16 v11; // bx
  _WORD *v12; // eax
  bool v13; // cf
  _WORD *v15; // [esp+Ch] [ebp-24h]
  _WORD *v16; // [esp+10h] [ebp-20h]
  unsigned __int16 *v17; // [esp+14h] [ebp-1Ch]
  _WORD *v18; // [esp+18h] [ebp-18h]
  unsigned __int16 *v19; // [esp+1Ch] [ebp-14h]
  unsigned int v20; // [esp+24h] [ebp-Ch]
  _DWORD *v21; // [esp+28h] [ebp-8h]
  unsigned __int16 *i; // [esp+2Ch] [ebp-4h]

  v2 = *v1;
  v3 = *(_DWORD *)(*v1 + 4176);
  v16 = *(_WORD **)(v1[1] + 24);
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = (unsigned __int16 *)((char *)v4 + v3 * *(_DWORD *)(*v1 + 4188));
  v21 = v1;
  v19 = v4;
  for ( i = v5; v4 < v5; v19 = v4 )
  {
    v15 = v16;
    v6 = (unsigned __int16 *)((char *)v4 + v3);
    v7 = v4;
    v17 = v4;
    v18 = v6;
    v20 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v20 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = (unsigned __int16)v6[1];
        v11 = (((*v6 & 0xF81F) + (v8 & 0xF81F) + (v10 & 0xF81F) + (v9 & 0xF81Fu) + 4098) >> 2)
            ^ ((((v9 & 0xFFFF07E0) + (*v6 & 0x7E0) + (v8 & 0xFFFF07E0) + (v10 & 0xFFFF07E0) + 64) >> 2)
             ^ (((*v6 & 0xF81F) + (v8 & 0xFFFFF81F) + (v10 & 0xFFFFF81F) + (v9 & 0xFFFFF81F) + 4098) >> 2))
            & 0x7E0;
        v12 = v15++;
        *v12 = v11;
        v7 = v17 + 2;
        v6 = v18 + 2;
        v13 = (unsigned int)(v17 + 2) < v20;
        v17 += 2;
        v18 += 2;
      }
      while ( v13 );
      v1 = v21;
      v4 = v19;
      v5 = i;
    }
    v16 = (_WORD *)((char *)v16 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v3 = *(_DWORD *)(*v1 + 4176);
    v4 += v3;
  }
  return 0;
}

// FUN_100136d2 @ 0x100136D2
// [binja] int32_t __fastcall sub_100136d2(int32_t* arg1)
int FUN_100136d2(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // eax
  int v3; // ebx
  unsigned __int16 *v4; // esi
  unsigned __int16 *v5; // edx
  unsigned __int16 *v6; // ebx
  unsigned __int16 *v7; // ebp
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // ebp
  int v12; // eax
  _WORD *v13; // eax
  _WORD *v15; // [esp+8h] [ebp-20h]
  _WORD *v16; // [esp+Ch] [ebp-1Ch]
  unsigned __int16 *v17; // [esp+10h] [ebp-18h]
  unsigned __int16 *v18; // [esp+14h] [ebp-14h]
  int v19; // [esp+18h] [ebp-10h]
  unsigned __int16 *v20; // [esp+1Ch] [ebp-Ch]
  _DWORD *v21; // [esp+20h] [ebp-8h]
  unsigned __int16 *i; // [esp+24h] [ebp-4h]

  v16 = *(_WORD **)(v1[1] + 24);
  v2 = *v1;
  v3 = *(_DWORD *)(*v1 + 4176);
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = (unsigned __int16 *)((char *)v4 + v3 * *(_DWORD *)(*v1 + 4188));
  v21 = v1;
  for ( i = v5; v4 < v5; v4 += v3 )
  {
    v15 = v16;
    v6 = (unsigned __int16 *)((char *)v4 + v3);
    v7 = v4;
    v17 = v4;
    v18 = v6;
    v20 = &v4[*(_DWORD *)(v2 + 4184)];
    if ( v4 < v20 )
    {
      do
      {
        v8 = v7[1];
        v9 = v6[1];
        v10 = *v6;
        v19 = *v7;
        v11 = (v8 & 0xFFFF03E0) + (v10 & 0xFFFF03E0) + (v19 & 0xFFFF03E0) + (v9 & 0xFFFF03E0) + 64;
        v12 = (v10 & 0x7C1F) + (v19 & 0x7C1F) + (v9 & 0x7C1F);
        v6 = v18 + 2;
        v18 += 2;
        LOWORD(v11) = ((v12 + (v8 & 0x7C1Fu) + 2050) >> 2) & 0x7C1F | (v11 >> 2) & 0x3E0;
        v13 = v15++;
        *v13 = v11;
        v7 = v17 + 2;
        v17 += 2;
      }
      while ( v17 < v20 );
      v1 = v21;
      v5 = i;
    }
    v16 = (_WORD *)((char *)v16 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v3 = *(_DWORD *)(*v1 + 4176);
  }
  return 0;
}

// FUN_100137f6 @ 0x100137F6
// [binja] int32_t __fastcall sub_100137f6(int32_t* arg1)
int FUN_100137f6(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // esi
  char *v3; // edx
  int v4; // edi
  char *v5; // ebp
  char *v6; // edi
  char *v7; // ebx
  __int16 v8; // si
  __int16 v9; // dx
  __int16 v10; // di
  _WORD *v11; // ecx
  bool v12; // cf
  _WORD *v14; // [esp+Ch] [ebp-24h]
  _WORD *v15; // [esp+10h] [ebp-20h]
  char *v16; // [esp+14h] [ebp-1Ch]
  char *v17; // [esp+18h] [ebp-18h]
  char *v18; // [esp+1Ch] [ebp-14h]
  unsigned int v19; // [esp+24h] [ebp-Ch]
  _DWORD *v20; // [esp+28h] [ebp-8h]
  char *i; // [esp+2Ch] [ebp-4h]

  v2 = *v1;
  v3 = *(char **)(*v1 + 24);
  v4 = *(_DWORD *)(*v1 + 4176);
  v5 = &v3[v4 * *(_DWORD *)(*v1 + 4188)];
  v20 = v1;
  v15 = *(_WORD **)(v1[1] + 24);
  v18 = v3;
  for ( i = v5; v3 < v5; v18 = v3 )
  {
    v14 = v15;
    v6 = &v3[v4];
    v7 = v3;
    v16 = v3;
    v17 = v6;
    v19 = (unsigned int)&v3[2 * *(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v3 < v19 )
    {
      do
      {
        v8 = *((_WORD *)v7 + 1);
        v9 = *((_WORD *)v6 + 1);
        v10 = *(_WORD *)v6;
        v11 = v14++;
        *v11 = (((v10 & 0x83E0) + (*(_WORD *)v7 & 0x83E0) + (v9 & 0x83E0) + (v8 & 0x83E0u) + 65600) >> 2)
             ^ ((((v8 & 0x7C1F) + (v10 & 0x7C1F) + (*(_WORD *)v7 & 0x7C1F) + (v9 & 0x7C1Fu) + 2050) >> 2)
              ^ (((v10 & 0x83E0) + (*(_WORD *)v7 & 0x83E0) + (v9 & 0x83E0) + (v8 & 0x83E0u) + 65600) >> 2))
             & 0x7C1F;
        v7 = v16 + 4;
        v6 = v17 + 4;
        v12 = (unsigned int)(v16 + 4) < v19;
        v16 += 4;
        v17 += 4;
      }
      while ( v12 );
      v1 = v20;
      v3 = v18;
      v5 = i;
    }
    v15 = (_WORD *)((char *)v15 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v4 = *(_DWORD *)(*v1 + 4176);
    v3 += 2 * v4;
  }
  return 0;
}

// FUN_10013945 @ 0x10013945
// [binja] int32_t __fastcall sub_10013945(int32_t* arg1)
int FUN_10013945(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // esi
  int v3; // edi
  unsigned __int16 *v4; // eax
  unsigned __int16 *v5; // ebp
  _WORD *v6; // edi
  unsigned __int16 *v7; // ebx
  int v8; // ecx
  int v9; // esi
  int v10; // eax
  __int16 v11; // bx
  _WORD *v12; // eax
  bool v13; // cf
  _WORD *v15; // [esp+Ch] [ebp-24h]
  _WORD *v16; // [esp+10h] [ebp-20h]
  unsigned __int16 *v17; // [esp+14h] [ebp-1Ch]
  _WORD *v18; // [esp+18h] [ebp-18h]
  unsigned __int16 *v19; // [esp+1Ch] [ebp-14h]
  unsigned int v20; // [esp+24h] [ebp-Ch]
  _DWORD *v21; // [esp+28h] [ebp-8h]
  unsigned __int16 *i; // [esp+2Ch] [ebp-4h]

  v2 = *v1;
  v3 = *(_DWORD *)(*v1 + 4176);
  v16 = *(_WORD **)(v1[1] + 24);
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = (unsigned __int16 *)((char *)v4 + v3 * *(_DWORD *)(*v1 + 4188));
  v21 = v1;
  v19 = v4;
  for ( i = v5; v4 < v5; v19 = v4 )
  {
    v15 = v16;
    v6 = (unsigned __int16 *)((char *)v4 + v3);
    v7 = v4;
    v17 = v4;
    v18 = v6;
    v20 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v20 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = (unsigned __int16)v6[1];
        v11 = (((*v6 & 0xF0F0) + (v8 & 0xF0F0) + (v10 & 0xF0F0) + (v9 & 0xF0F0u) + 8224) >> 2)
            ^ ((((v9 & 0xFFFF0F0F) + (*v6 & 0xF0F) + (v8 & 0xFFFF0F0F) + (v10 & 0xFFFF0F0F) + 514) >> 2)
             ^ (((*v6 & 0xF0F0) + (v8 & 0xFFFFF0F0) + (v10 & 0xFFFFF0F0) + (v9 & 0xFFFFF0F0) + 8224) >> 2))
            & 0xF0F;
        v12 = v15++;
        *v12 = v11;
        v7 = v17 + 2;
        v6 = v18 + 2;
        v13 = (unsigned int)(v17 + 2) < v20;
        v17 += 2;
        v18 += 2;
      }
      while ( v13 );
      v1 = v21;
      v4 = v19;
      v5 = i;
    }
    v16 = (_WORD *)((char *)v16 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v3 = *(_DWORD *)(*v1 + 4176);
    v4 += v3;
  }
  return 0;
}

// FUN_10013a98 @ 0x10013A98
// [binja] int32_t __fastcall sub_10013a98(int32_t* arg1)
int FUN_10013a98(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  _BYTE *v3; // ebp
  unsigned __int8 *v4; // eax
  int v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  int v9; // ebp
  int v10; // esi
  int v11; // eax
  int v12; // edi
  char v13; // dl
  _BYTE *v14; // eax
  bool v15; // cf
  _BYTE *v17; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v18; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v19; // [esp+14h] [ebp-18h]
  _BYTE *v20; // [esp+18h] [ebp-14h]
  unsigned __int8 *v21; // [esp+1Ch] [ebp-10h]
  unsigned int v22; // [esp+20h] [ebp-Ch]
  _DWORD *v23; // [esp+24h] [ebp-8h]
  unsigned __int8 *i; // [esp+28h] [ebp-4h]

  v2 = *v1;
  v3 = *(_BYTE **)(v1[1] + 24);
  v4 = *(unsigned __int8 **)(*v1 + 24);
  v5 = *(_DWORD *)(*v1 + 4176);
  v6 = &v4[v5 * *(_DWORD *)(*v1 + 4188)];
  v23 = v1;
  v20 = v3;
  v21 = v4;
  for ( i = v6; v4 < v6; v21 = v4 )
  {
    v7 = &v4[v5];
    v8 = v4;
    v17 = v3;
    v18 = v4;
    v19 = v7;
    v22 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v22 )
    {
      do
      {
        v9 = *v8;
        v10 = v8[1];
        v11 = v7[1];
        v12 = *v7;
        LOWORD(v9) = v9 & 0xE3;
        LOWORD(v10) = v10 & 0xE3;
        v13 = (((v12 & 0xE3) + v9 + (v11 & 0xE3u) + v10 + 66) >> 2)
            ^ ((((v12 & 0xFFFF00E3) + (*v8 & 0xE3) + (v11 & 0xFFFF00E3) + (v8[1] & 0xE3) + 66) >> 2)
             ^ (((v12 & 0x1C) + (*v8 & 0x1C) + (v11 & 0x1C) + (v8[1] & 0x1Cu) + 8) >> 2))
            & 0x1C;
        v14 = v17++;
        v8 = v18 + 2;
        v7 = v19 + 2;
        v15 = (unsigned int)(v18 + 2) < v22;
        *v14 = v13;
        v18 += 2;
        v19 += 2;
      }
      while ( v15 );
      v1 = v23;
      v3 = v20;
      v4 = v21;
      v6 = i;
    }
    v3 += *(_DWORD *)(v1[1] + 4176);
    v2 = *v1;
    v5 = *(_DWORD *)(*v1 + 4176);
    v4 += 2 * v5;
    v20 = v3;
  }
  return 0;
}

// FUN_10013bd7 @ 0x10013BD7
// [binja] int32_t __fastcall sub_10013bd7(int32_t* arg1)
int FUN_10013bd7(int *arg1)
{
  _DWORD *v1; // ecx
  _BYTE *v2; // ebx
  int v3; // eax
  unsigned __int8 *v4; // edx
  int v5; // edi
  unsigned __int8 *v6; // esi
  unsigned int v7; // eax
  unsigned __int8 *v8; // edi
  bool i; // cf
  int v10; // edi
  int v11; // ebx
  unsigned int v12; // ebx
  _BYTE *v13; // edi
  _BYTE *v15; // [esp+Ch] [ebp-10h]
  unsigned __int8 *v16; // [esp+10h] [ebp-Ch]
  _BYTE *v17; // [esp+14h] [ebp-8h]
  unsigned __int8 *v18; // [esp+18h] [ebp-4h]

  v2 = *(_BYTE **)(v1[1] + 24);
  v3 = *v1;
  v4 = *(unsigned __int8 **)(*v1 + 24);
  v5 = *(_DWORD *)(*v1 + 4176);
  v6 = &v4[v5 * *(_DWORD *)(*v1 + 4188)];
  while ( 1 )
  {
    v15 = v2;
    if ( v4 >= v6 )
      break;
    v7 = (unsigned int)&v4[*(_DWORD *)(v3 + 4184)];
    v8 = &v4[v5];
    v17 = v2;
    v18 = v4;
    for ( i = (unsigned int)v4 < v7; ; i = (unsigned int)v18 < v7 )
    {
      v16 = v8;
      if ( !i )
        break;
      v10 = *v8 + v18[1] + v8[1];
      v11 = *v18;
      v18 += 2;
      v12 = v10 + v11 + 2;
      v13 = v17++;
      *v13 = v12 >> 2;
      v8 = v16 + 2;
    }
    v2 = &v15[*(_DWORD *)(v1[1] + 4176)];
    v3 = *v1;
    v5 = *(_DWORD *)(*v1 + 4176);
    v4 += 2 * v5;
  }
  return 0;
}

// FUN_10013c72 @ 0x10013C72
// [binja] int32_t __fastcall sub_10013c72(int32_t* arg1)
int FUN_10013c72(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  int v3; // ebp
  unsigned __int16 *v4; // eax
  unsigned __int16 *v5; // edi
  unsigned __int16 *v6; // ebp
  unsigned __int16 *v7; // ebx
  int v8; // edx
  int v9; // edi
  int v10; // eax
  int v11; // ebp
  unsigned int v12; // ebx
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // edx
  int v16; // ebp
  unsigned int v17; // ecx
  int v18; // edi
  unsigned int v19; // edx
  _WORD *v20; // eax
  bool v21; // cf
  _WORD *v23; // [esp+8h] [ebp-24h]
  _WORD *v24; // [esp+Ch] [ebp-20h]
  int v25; // [esp+10h] [ebp-1Ch]
  unsigned __int16 *v26; // [esp+14h] [ebp-18h]
  unsigned __int16 *v27; // [esp+18h] [ebp-14h]
  unsigned __int16 *v28; // [esp+1Ch] [ebp-10h]
  unsigned int v29; // [esp+20h] [ebp-Ch]
  _DWORD *v30; // [esp+24h] [ebp-8h]
  unsigned __int16 *i; // [esp+28h] [ebp-4h]

  v2 = *v1;
  v3 = *(_DWORD *)(*v1 + 4176);
  v24 = *(_WORD **)(v1[1] + 24);
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = (unsigned __int16 *)((char *)v4 + v3 * *(_DWORD *)(*v1 + 4188));
  v30 = v1;
  v28 = v4;
  for ( i = v5; v4 < v5; v28 = v4 )
  {
    v23 = v24;
    v6 = (unsigned __int16 *)((char *)v4 + v3);
    v7 = v4;
    v26 = v4;
    v27 = v6;
    v29 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v29 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = v6[1];
        v11 = *v6;
        v25 = v8;
        LOWORD(v8) = *v7 & 0xE3;
        v12 = (v11 & 0xFFFF00E3) + v8 + (v10 & 0xFFFF00E3);
        HIWORD(v13) = HIWORD(v10);
        v14 = v10 & 0xFF1C;
        LOWORD(v13) = v14;
        v15 = (v12 + (v9 & 0xFFFF00E3) + 66) >> 2;
        HIWORD(v12) = HIWORD(v11);
        v16 = v11 & 0xFF1C;
        LOWORD(v12) = v16;
        v17 = v12 + (v25 & 0xFFFFFF1C) + v13;
        HIWORD(v12) = HIWORD(v9);
        v18 = v9 & 0xFF1C;
        LOWORD(v12) = v18;
        LOBYTE(v15) = ((v17 + v12 + 520) >> 2) ^ v15;
        v19 = ((v16 + (v25 & 0xFF1Cu) + v14 + v18 + 520) >> 2) ^ v15 & 0xFFFF00E3;
        v20 = v23++;
        v7 = v26 + 2;
        v6 = v27 + 2;
        v21 = (unsigned int)(v26 + 2) < v29;
        *v20 = v19;
        v26 += 2;
        v27 += 2;
      }
      while ( v21 );
      v1 = v30;
      v4 = v28;
      v5 = i;
    }
    v24 = (_WORD *)((char *)v24 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v3 = *(_DWORD *)(*v1 + 4176);
    v4 += v3;
  }
  return 0;
}

// FUN_10013dbe @ 0x10013DBE
// [binja] int32_t __fastcall sub_10013dbe(int32_t* arg1)
int FUN_10013dbe(int *arg1)
{
  _DWORD *v1; // ecx
  _WORD *v2; // ebp
  int v3; // eax
  unsigned __int16 *v4; // esi
  int v5; // edi
  unsigned __int16 *v6; // edx
  unsigned __int16 *v7; // edi
  unsigned __int16 *v8; // ebx
  int v9; // edx
  int v10; // eax
  int v11; // ebx
  int v12; // edi
  unsigned int v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // ebp
  _WORD *v16; // eax
  _WORD *v18; // [esp+Ch] [ebp-1Ch]
  unsigned __int16 *v19; // [esp+10h] [ebp-18h]
  unsigned __int16 *v20; // [esp+14h] [ebp-14h]
  _WORD *v21; // [esp+18h] [ebp-10h]
  unsigned int v22; // [esp+1Ch] [ebp-Ch]
  _DWORD *v23; // [esp+20h] [ebp-8h]
  unsigned __int16 *i; // [esp+24h] [ebp-4h]

  v2 = *(_WORD **)(v1[1] + 24);
  v3 = *v1;
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = *(_DWORD *)(*v1 + 4176);
  v6 = (unsigned __int16 *)((char *)v4 + v5 * *(_DWORD *)(*v1 + 4188));
  v23 = v1;
  v21 = v2;
  for ( i = v6; v4 < v6; v21 = v2 )
  {
    v7 = (unsigned __int16 *)((char *)v4 + v5);
    v8 = v4;
    v18 = v2;
    v19 = v4;
    v20 = v7;
    v22 = (unsigned int)&v4[*(_DWORD *)(v3 + 4184)];
    if ( (unsigned int)v4 < v22 )
    {
      do
      {
        v9 = v8[1];
        v10 = v7[1];
        v11 = *v8;
        v12 = *v7;
        v13 = (v12 & 0xFFFF00F0) + (v11 & 0xFFFF00F0) + (v10 & 0xFFFF00F0) + (v9 & 0xFFFF00F0) + 32;
        LOWORD(v10) = v10 & 0xF0F;
        LOWORD(v11) = v11 & 0xF0F;
        LOWORD(v12) = v12 & 0xF0F;
        LOWORD(v9) = v9 & 0xF0F;
        v14 = (unsigned int)(v12 + v11 + v10 + v9 + 514) >> 2;
        LOWORD(v14) = v14 & 0xF0F;
        v8 = v19 + 2;
        v7 = v20 + 2;
        v19 = v8;
        v20 += 2;
        v15 = v14 | (v13 >> 2) & 0xFFFF00F0;
        v16 = v18++;
        *v16 = v15;
      }
      while ( (unsigned int)v8 < v22 );
      v1 = v23;
      v2 = v21;
      v6 = i;
    }
    v2 = (_WORD *)((char *)v2 + *(_DWORD *)(v1[1] + 4176));
    v3 = *v1;
    v5 = *(_DWORD *)(*v1 + 4176);
    v4 += v5;
  }
  return 0;
}

// FUN_10013edf @ 0x10013EDF
// [binja] int32_t __fastcall sub_10013edf(int32_t* arg1)
int FUN_10013edf(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  int v3; // ebp
  unsigned __int16 *v4; // eax
  unsigned __int16 *v5; // edi
  unsigned __int16 *v6; // ebp
  unsigned __int16 *v7; // ebx
  int v8; // edx
  int v9; // edi
  int v10; // eax
  int v11; // ebp
  unsigned int v12; // ebx
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // edx
  int v16; // ebp
  unsigned int v17; // ecx
  int v18; // edi
  unsigned int v19; // edx
  _WORD *v20; // eax
  bool v21; // cf
  _WORD *v23; // [esp+8h] [ebp-24h]
  _WORD *v24; // [esp+Ch] [ebp-20h]
  int v25; // [esp+10h] [ebp-1Ch]
  unsigned __int16 *v26; // [esp+14h] [ebp-18h]
  unsigned __int16 *v27; // [esp+18h] [ebp-14h]
  unsigned __int16 *v28; // [esp+1Ch] [ebp-10h]
  unsigned int v29; // [esp+20h] [ebp-Ch]
  _DWORD *v30; // [esp+24h] [ebp-8h]
  unsigned __int16 *i; // [esp+28h] [ebp-4h]

  v2 = *v1;
  v3 = *(_DWORD *)(*v1 + 4176);
  v24 = *(_WORD **)(v1[1] + 24);
  v4 = *(unsigned __int16 **)(*v1 + 24);
  v5 = (unsigned __int16 *)((char *)v4 + v3 * *(_DWORD *)(*v1 + 4188));
  v30 = v1;
  v28 = v4;
  for ( i = v5; v4 < v5; v28 = v4 )
  {
    v23 = v24;
    v6 = (unsigned __int16 *)((char *)v4 + v3);
    v7 = v4;
    v26 = v4;
    v27 = v6;
    v29 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v29 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = v6[1];
        v11 = *v6;
        v25 = v8;
        LOWORD(v8) = (unsigned __int8)*v7;
        v12 = (v11 & 0xFFFF00FF) + v8 + (v10 & 0xFFFF00FF);
        HIWORD(v13) = HIWORD(v10);
        v14 = v10 & 0xFF00;
        LOWORD(v13) = v14;
        v15 = (v12 + (v9 & 0xFFFF00FF) + 2) >> 2;
        HIWORD(v12) = HIWORD(v11);
        v16 = v11 & 0xFF00;
        LOWORD(v12) = v16;
        v17 = v12 + (v25 & 0xFFFFFF00) + v13;
        HIWORD(v12) = HIWORD(v9);
        v18 = v9 & 0xFF00;
        LOWORD(v12) = v18;
        LOBYTE(v15) = ((v17 + v12 + 512) >> 2) ^ v15;
        v19 = ((v16 + (v25 & 0xFF00u) + v14 + v18 + 512) >> 2) ^ v15 & 0xFFFF00FF;
        v20 = v23++;
        v7 = v26 + 2;
        v6 = v27 + 2;
        v21 = (unsigned int)(v26 + 2) < v29;
        *v20 = v19;
        v26 += 2;
        v27 += 2;
      }
      while ( v21 );
      v1 = v30;
      v4 = v28;
      v5 = i;
    }
    v24 = (_WORD *)((char *)v24 + *(_DWORD *)(v1[1] + 4176));
    v2 = *v1;
    v3 = *(_DWORD *)(*v1 + 4176);
    v4 += v3;
  }
  return 0;
}

// FUN_1001402b @ 0x1001402B
// [binja] int32_t __fastcall sub_1001402b(int32_t* arg1)
int FUN_1001402b(int *arg1)
{
  _DWORD *v1; // ecx
  int v2; // edx
  _BYTE *v3; // ebp
  unsigned __int8 *v4; // eax
  int v5; // edi
  unsigned __int8 *v6; // esi
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  int v9; // ebp
  int v10; // esi
  int v11; // eax
  int v12; // edi
  char v13; // dl
  _BYTE *v14; // eax
  bool v15; // cf
  _BYTE *v17; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v18; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v19; // [esp+14h] [ebp-18h]
  _BYTE *v20; // [esp+18h] [ebp-14h]
  unsigned __int8 *v21; // [esp+1Ch] [ebp-10h]
  unsigned int v22; // [esp+20h] [ebp-Ch]
  _DWORD *v23; // [esp+24h] [ebp-8h]
  unsigned __int8 *i; // [esp+28h] [ebp-4h]

  v2 = *v1;
  v3 = *(_BYTE **)(v1[1] + 24);
  v4 = *(unsigned __int8 **)(*v1 + 24);
  v5 = *(_DWORD *)(*v1 + 4176);
  v6 = &v4[v5 * *(_DWORD *)(*v1 + 4188)];
  v23 = v1;
  v20 = v3;
  v21 = v4;
  for ( i = v6; v4 < v6; v21 = v4 )
  {
    v7 = &v4[v5];
    v8 = v4;
    v17 = v3;
    v18 = v4;
    v19 = v7;
    v22 = (unsigned int)&v4[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v4 < v22 )
    {
      do
      {
        v9 = *v8;
        v10 = v8[1];
        v11 = v7[1];
        v12 = *v7;
        LOWORD(v9) = v9 & 0xF0;
        LOWORD(v10) = v10 & 0xF0;
        v13 = (((v12 & 0xF0) + v9 + (v11 & 0xF0u) + v10 + 32) >> 2)
            ^ ((((v12 & 0xFFFF00F0) + (*v8 & 0xF0) + (v11 & 0xFFFF00F0) + (v8[1] & 0xF0) + 32) >> 2)
             ^ (((v12 & 0xF) + (*v8 & 0xF) + (v11 & 0xF) + (v8[1] & 0xFu) + 2) >> 2))
            & 0xF;
        v14 = v17++;
        v8 = v18 + 2;
        v7 = v19 + 2;
        v15 = (unsigned int)(v18 + 2) < v22;
        *v14 = v13;
        v18 += 2;
        v19 += 2;
      }
      while ( v15 );
      v1 = v23;
      v3 = v20;
      v4 = v21;
      v6 = i;
    }
    v3 += *(_DWORD *)(v1[1] + 4176);
    v2 = *v1;
    v5 = *(_DWORD *)(*v1 + 4176);
    v4 += 2 * v5;
    v20 = v3;
  }
  return 0;
}

// FUN_1001416a @ 0x1001416A
// [binja] int32_t __fastcall sub_1001416a(int32_t* arg1)
int FUN_1001416a(int *arg1)
{
  _DWORD *v1; // ecx
  int *v2; // esi
  _DWORD *v3; // ebx
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  char *v7; // edx
  char *v8; // ebx
  unsigned int v9; // [esp+8h] [ebp-10h]
  unsigned int i; // [esp+Ch] [ebp-Ch]
  _DWORD *v11; // [esp+10h] [ebp-8h]
  unsigned int v12; // [esp+14h] [ebp-4h]

  v3 = v1;
  v4 = (_DWORD *)v1[1];
  v5 = (_DWORD *)*v1;
  v11 = v3;
  if ( v4[1] != v5[1] )
    return -2147467259;
  if ( v5[4] )
    return -2147467259;
  if ( v4[1046] != v5[1046] )
    return -2147467259;
  v9 = v4[1047];
  if ( v9 != v5[1047] || v4[1048] != v5[1048] )
    return -2147467259;
  if ( !v4[3] )
    return FUN_10013007(v2);
  if ( v4[5] && v4 + 12 != v5 + 12 && memcmp(v4 + 12, v5 + 12, 0x400u) )
    return -2147467259;
  v12 = 0;
  if ( v4[1048] )
  {
    while ( 1 )
    {
      v7 = (char *)(v4[6] + v12 * v4[1045]);
      v8 = (char *)(*(_DWORD *)(*v11 + 24) + v12 * *(_DWORD *)(*v3 + 4180));
      for ( i = 0; i < v9; v9 = v4[1047] )
      {
        qmemcpy(v7, v8, v4[1049]);
        v4 = (_DWORD *)v11[1];
        v8 += *(_DWORD *)(*v11 + 4176);
        v7 += v4[1044];
        ++i;
      }
      ++v12;
      v4 = (_DWORD *)v11[1];
      if ( v12 >= v4[1048] )
        break;
      v3 = v11;
    }
  }
  return 0;
}

// FUN_100142a2 @ 0x100142A2
// [binja] int32_t __fastcall sub_100142a2(int32_t* arg1)
int FUN_100142a2(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  int v5; // edi
  void *v6; // eax
  void *v7; // ebx
  unsigned int v8; // ebx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int i; // edi
  void *v13; // [esp+Ch] [ebp-10h]

  v2 = v1;
  v3 = (_DWORD *)v1[1];
  v4 = (_DWORD *)*v1;
  v5 = v3[1046];
  if ( v5 != v4[1046] || v3[1047] != v4[1047] || v3[1048] != v4[1048] )
    return -2147467259;
  v6 = operator new(16 * v5);
  v7 = v6;
  if ( v6 )
  {
    sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    v13 = v7;
  }
  else
  {
    v13 = 0;
  }
  v8 = 0;
  if ( !v13 )
    return -2147467259;
  v9 = v2[1];
  if ( *(_DWORD *)(v9 + 4192) )
  {
    v10 = *(_DWORD *)(v9 + 4188);
    do
    {
      for ( i = 0; i < v10; ++i )
      {
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, void *))(*(_DWORD *)*v2 + 4))(*v2, i, v8, v13);
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, void *))(*(_DWORD *)v2[1] + 8))(v2[1], i, v8, v13);
        v10 = *(_DWORD *)(v2[1] + 4188);
      }
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v2[1] + 4192) );
  }
  operator delete(v13);
  return 0;
}

// FUN_10014393 @ 0x10014393
// [binja] int32_t __fastcall sub_10014393(int32_t* arg1)
int FUN_10014393(int *arg1)
{
  int v1; // ecx
  _DWORD *v2; // esi
  _DWORD *v4; // eax
  _DWORD *v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // edi
  void *v8; // eax
  void *v9; // eax
  unsigned int v10; // ebx
  unsigned int i; // edi
  _DWORD *v12; // ecx
  unsigned int j; // edi
  _DWORD *v14; // ecx
  unsigned int v15; // eax
  unsigned int k; // edi
  unsigned int v17; // [esp+4h] [ebp-20h]
  unsigned int v18; // [esp+8h] [ebp-1Ch]
  unsigned int v19; // [esp+Ch] [ebp-18h]
  int v20; // [esp+Ch] [ebp-18h]
  void *v21; // [esp+Ch] [ebp-18h]
  void *v22; // [esp+10h] [ebp-14h]
  void *v23; // [esp+10h] [ebp-14h]
  char *v24; // [esp+10h] [ebp-14h]
  void *v25; // [esp+14h] [ebp-10h]

  v2 = (_DWORD *)v1;
  if ( *(_BYTE *)(v1 + 8) != 1 )
    return -2147467259;
  v4 = *(_DWORD **)(v1 + 4);
  v5 = *(_DWORD **)v1;
  v19 = v4[1046];
  if ( v19 <= v5[1046] )
    v19 = v5[1046];
  v17 = v4[1047];
  if ( v17 >= v5[1047] )
    v17 = v5[1047];
  v6 = v5[1048];
  v18 = v4[1048];
  if ( v18 >= v6 )
    v18 = v6;
  v7 = 16 * v19;
  v8 = operator new(16 * v19);
  v22 = v8;
  if ( v8 )
  {
    sub_1000B393((int)v8, 16, v19, (int (__thiscall *)(int))sub_1000AE4F);
    v25 = v22;
  }
  else
  {
    v25 = 0;
  }
  if ( !v25 )
    return -2147467259;
  v20 = *(_DWORD *)(v2[1] + 4184);
  v9 = operator new(16 * v20);
  v23 = v9;
  if ( v9 )
  {
    sub_1000B393((int)v9, 16, v20, (int (__thiscall *)(int))sub_1000AE4F);
    v21 = v23;
  }
  else
  {
    v21 = 0;
  }
  if ( v21 )
  {
    v10 = v18;
    v24 = 0;
    memset(v25, 0, v7);
    memset(v21, 0, 16 * *(_DWORD *)(v2[1] + 4184));
    if ( v18 )
    {
      do
      {
        for ( i = 0; i < v17; ++i )
        {
          (*(void (__thiscall **)(_DWORD, unsigned int, char *, void *))(*(_DWORD *)*v2 + 4))(*v2, i, v24, v25);
          (*(void (__thiscall **)(_DWORD, unsigned int, char *, void *))(*(_DWORD *)v2[1] + 8))(v2[1], i, v24, v25);
        }
        v12 = (_DWORD *)v2[1];
        for ( j = v17; j < v12[1047]; ++j )
        {
          (*(void (__thiscall **)(_DWORD *, unsigned int, char *, void *))(*v12 + 8))(v12, j, v24, v21);
          v12 = (_DWORD *)v2[1];
        }
        v10 = v18;
        ++v24;
      }
      while ( (unsigned int)v24 < v18 );
    }
    v14 = (_DWORD *)v2[1];
    if ( v10 < v14[1048] )
    {
      v15 = v14[1047];
      do
      {
        for ( k = 0; k < v15; ++k )
        {
          (*(void (__thiscall **)(_DWORD *, unsigned int, unsigned int, void *))(*v14 + 8))(v14, k, v10, v21);
          v14 = (_DWORD *)v2[1];
          v15 = v14[1047];
        }
        v14 = (_DWORD *)v2[1];
        ++v10;
      }
      while ( v10 < v14[1048] );
    }
    operator delete(v25);
    operator delete(v21);
    return 0;
  }
  else
  {
    operator delete(v25);
    return -2147467259;
  }
}

// FUN_10014595 @ 0x10014595
// [binja] int32_t __fastcall sub_10014595(int32_t* arg1)
int FUN_10014595(int *arg1)
{
  _BYTE *v1; // ecx
  _DWORD *v2; // ebx
  int v4; // edi
  char *v5; // eax
  int v6; // edi
  _DWORD *v7; // eax
  _DWORD *v8; // esi
  unsigned int v9; // edi
  unsigned int v10; // esi
  _DWORD *v11; // eax
  unsigned int v12; // esi
  char *v13; // esi
  int v14; // [esp+4h] [ebp-3Ch]
  int v15; // [esp+8h] [ebp-38h]
  int v16; // [esp+Ch] [ebp-34h]
  char *v17; // [esp+10h] [ebp-30h]
  _DWORD *v18; // [esp+10h] [ebp-30h]
  char *v19; // [esp+10h] [ebp-30h]
  int v20; // [esp+14h] [ebp-2Ch]
  unsigned int v21; // [esp+18h] [ebp-28h]
  unsigned int v22; // [esp+1Ch] [ebp-24h]
  unsigned int v23; // [esp+20h] [ebp-20h]
  unsigned int v24; // [esp+24h] [ebp-1Ch]
  unsigned int i; // [esp+28h] [ebp-18h]
  _DWORD *v26; // [esp+2Ch] [ebp-14h]
  char *v27; // [esp+30h] [ebp-10h]

  v2 = v1;
  if ( v1[8] != 2 )
    return -2147467259;
  v4 = *(_DWORD *)(*(_DWORD *)v1 + 4184);
  v5 = (char *)operator new(16 * v4);
  v17 = v5;
  if ( v5 )
  {
    sub_1000B393((int)v5, 16, v4, (int (__thiscall *)(int))sub_1000AE4F);
    v27 = v17;
  }
  else
  {
    v27 = 0;
  }
  if ( !v27 )
    return -2147024882;
  v6 = *(_DWORD *)(v2[1] + 4184);
  v7 = operator new(16 * v6);
  v18 = v7;
  if ( v7 )
  {
    sub_1000B393((int)v7, 16, v6, (int (__thiscall *)(int))sub_1000AE4F);
    v26 = v18;
  }
  else
  {
    v26 = 0;
  }
  if ( v26 )
  {
    v8 = (_DWORD *)v2[1];
    v9 = v8[1047];
    v21 = 0;
    v24 = 0;
    v16 = (*(_DWORD *)(*v2 + 4184) << 16) / v8[1046];
    v15 = (*(_DWORD *)(*v2 + 4188) << 16) / v9;
    v14 = (*(_DWORD *)(*v2 + 4192) << 16) / v8[1048];
    do
    {
      v20 = -1;
      v10 = 0;
      v19 = 0;
      for ( i = 0; i < v9; v19 += v15 )
      {
        v23 = 0;
        v22 = 0;
        if ( ((v10 ^ v20) & 0xFFFF0000) != 0 )
        {
          (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, char *))(*(_DWORD *)*v2 + 4))(
            *v2,
            HIWORD(v10),
            HIWORD(v21),
            v27);
          v20 = v10;
        }
        if ( *(_DWORD *)(v2[1] + 4184) )
        {
          v11 = v26;
          do
          {
            v12 = v23;
            v23 += v16;
            v13 = &v27[16 * HIWORD(v12)];
            ++v22;
            *v11 = *(_DWORD *)v13;
            v13 += 4;
            v11[1] = *(_DWORD *)v13;
            v13 += 4;
            v11[2] = *(_DWORD *)v13;
            v11[3] = *((_DWORD *)v13 + 1);
            v11 += 4;
          }
          while ( v22 < *(_DWORD *)(v2[1] + 4184) );
        }
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, _DWORD *))(*(_DWORD *)v2[1] + 8))(
          v2[1],
          i,
          v24,
          v26);
        v10 = (unsigned int)&v19[v15];
        ++i;
        v9 = *(_DWORD *)(v2[1] + 4188);
      }
      v21 += v14;
      ++v24;
    }
    while ( v24 < *(_DWORD *)(v2[1] + 4192) );
    operator delete(v27);
    operator delete(v26);
    return 0;
  }
  else
  {
    operator delete(v27);
    return -2147024882;
  }
}

// FUN_10014799 @ 0x10014799
// [binja] int32_t __fastcall sub_10014799(int32_t* arg1)
int FUN_10014799(int *arg1)
{
  int v1; // ecx
  int *v2; // edi
  float *v3; // esi
  _DWORD *v4; // ebx
  _DWORD *v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // edx
  int v9; // esi
  int v10; // esi
  _DWORD *v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // esi
  float *v22; // eax
  int v23; // esi
  char *v24; // eax
  char *v25; // eax
  int v26; // esi
  char *v27; // eax
  char *v28; // ecx
  int v29; // esi
  char *v30; // ecx
  unsigned int v31; // edx
  float *v32; // eax
  float *v33; // ecx
  double v34; // st6
  float *v35; // edi
  double v36; // st5
  double v37; // st4
  float *v38; // eax
  double v39; // st6
  double v40; // st5
  double v41; // st4
  float *v42; // eax
  int *v43; // [esp-8h] [ebp-78h]
  float *v44; // [esp-4h] [ebp-74h]
  float v45; // [esp+4h] [ebp-6Ch]
  float v46; // [esp+8h] [ebp-68h]
  float v47; // [esp+14h] [ebp-5Ch]
  float v48; // [esp+20h] [ebp-50h]
  float v49; // [esp+2Ch] [ebp-44h]
  float v50; // [esp+30h] [ebp-40h]
  float v51; // [esp+34h] [ebp-3Ch]
  float v52; // [esp+38h] [ebp-38h]
  float v53; // [esp+3Ch] [ebp-34h]
  float v54; // [esp+40h] [ebp-30h]
  float *v55; // [esp+44h] [ebp-2Ch]
  char *v56; // [esp+44h] [ebp-2Ch]
  char *v57; // [esp+44h] [ebp-2Ch]
  char *v58; // [esp+44h] [ebp-2Ch]
  char *v59; // [esp+48h] [ebp-28h]
  char *v60; // [esp+4Ch] [ebp-24h]
  float *v61; // [esp+50h] [ebp-20h]
  float *v62; // [esp+54h] [ebp-1Ch]
  unsigned int i; // [esp+58h] [ebp-18h]
  char *v64; // [esp+5Ch] [ebp-14h]
  char *v65; // [esp+60h] [ebp-10h]

  v4 = (_DWORD *)v1;
  if ( *(_BYTE *)(v1 + 8) != 5 )
    return -2147467259;
  v6 = *(_DWORD **)v1;
  v7 = *(_DWORD *)(*v4 + 4184);
  v8 = (_DWORD *)v4[1];
  v44 = v3;
  v9 = v8[1046];
  v43 = v2;
  if ( v9 != v7 >> 1 && (v9 != 1 || v7 != 1) )
    return -2147467259;
  v10 = v8[1047];
  if ( v10 != v6[1047] >> 1 && (v10 != 1 || v6[1047] != 1) )
    return -2147467259;
  if ( v8[1048] != 1 || v6[1048] != 1 )
    return -2147467259;
  if ( v7 > 1 && (v7 & 1) != 0 )
  {
    v6[1046] = v7 & 0xFFFFFFFE;
    *(_DWORD *)(*v4 + 4196) -= *(_DWORD *)(*v4 + 4200);
  }
  v11 = (_DWORD *)(*v4 + 4188);
  if ( *v11 > 1u )
    *v11 &= ~1u;
  if ( (*((_BYTE *)v4 + 10) & 8) != 0 )
    goto LABEL_44;
  v12 = *v4;
  v13 = *(_DWORD *)(*v4 + 4);
  if ( v13 != *(_DWORD *)(v4[1] + 4) || *(_DWORD *)(v12 + 4184) < 2u || *(_DWORD *)(v12 + 4188) < 2u )
    goto LABEL_44;
  if ( v13 <= 28 )
  {
    if ( v13 != 28 )
    {
      switch ( v13 )
      {
        case 21:
          v14 = FUN_100132bb(v2);
          goto LABEL_42;
        case 22:
          v14 = FUN_10013551(v2);
          goto LABEL_42;
        case 23:
          v14 = FUN_10013582(v2);
          goto LABEL_42;
        case 24:
          v14 = FUN_100136d2(v2);
          goto LABEL_42;
        case 25:
          v14 = FUN_100137f6(v2);
          goto LABEL_42;
        case 26:
          v14 = FUN_10013945(v2);
          goto LABEL_42;
        case 27:
          v14 = FUN_10013a98(v2);
          goto LABEL_42;
        default:
          goto LABEL_44;
      }
    }
    goto LABEL_39;
  }
  v15 = v13 - 29;
  if ( !v15 )
  {
    v14 = FUN_10013c72(v2);
LABEL_42:
    if ( v14 >= 0 )
      return 0;
    goto LABEL_44;
  }
  v16 = v15 - 1;
  if ( !v16 )
  {
    v14 = FUN_10013dbe(v2);
    goto LABEL_42;
  }
  v17 = v16 - 10;
  if ( v17 )
  {
    v18 = v17 - 1;
    if ( v18 )
    {
      v19 = v18 - 9;
      if ( !v19 )
      {
LABEL_39:
        v14 = FUN_10013bd7(v2);
        goto LABEL_42;
      }
      v20 = v19 - 1;
      if ( !v20 )
      {
        v14 = FUN_10013edf(v2);
        goto LABEL_42;
      }
      if ( v20 == 1 )
      {
        v14 = FUN_1001402b(v2);
        goto LABEL_42;
      }
    }
  }
LABEL_44:
  v21 = *(_DWORD *)(v4[1] + 4184);
  v22 = (float *)operator new(16 * v21);
  v55 = v22;
  if ( v22 )
  {
    sub_1000B393((int)v22, 16, v21, (int (__thiscall *)(int))sub_1000AE4F);
    v62 = v55;
  }
  else
  {
    v62 = 0;
  }
  if ( !v62 )
    return -2147024882;
  v23 = *(_DWORD *)(*v4 + 4184);
  if ( *(_DWORD *)(*v4 + 4188) == 1 )
  {
    v24 = (char *)operator new(16 * v23);
    v56 = v24;
    if ( v24 )
    {
      sub_1000B393((int)v24, 16, v23, (int (__thiscall *)(int))sub_1000AE4F);
      v25 = v56;
    }
    else
    {
      v25 = 0;
    }
    v60 = v25;
    v64 = v25;
  }
  else
  {
    v26 = 2 * v23;
    v27 = (char *)operator new(16 * v26);
    v57 = v27;
    if ( v27 )
    {
      sub_1000B393((int)v27, 16, v26, (int (__thiscall *)(int))sub_1000AE4F);
      v28 = v57;
    }
    else
    {
      v28 = 0;
    }
    v60 = v28;
    v64 = v28;
    v25 = &v28[16 * *(_DWORD *)(*v4 + 4184)];
  }
  v65 = v25;
  if ( v60 )
  {
    if ( *(_DWORD *)(*v4 + 4184) == 1 )
    {
      v59 = v64;
      v30 = v25;
    }
    else
    {
      v59 = v64 + 16;
      v30 = v25 + 16;
    }
    v58 = v30;
    for ( i = 0; i < *(_DWORD *)(v4[1] + 4188); ++i )
    {
      (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, char *, int *, float *))(*(_DWORD *)*v4 + 4))(
        *v4,
        2 * i,
        0,
        v64,
        v43,
        v44);
      if ( v65 != v64 )
        (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, char *))(*(_DWORD *)*v4 + 4))(*v4, 2 * i + 1, 0, v65);
      v31 = 0;
      if ( *(_DWORD *)(v4[1] + 4184) )
      {
        v61 = v62;
        do
        {
          v32 = (float *)&v59[32 * v31];
          v33 = (float *)&v64[32 * v31];
          v34 = *v32 + *v33;
          v35 = v61;
          v36 = v32[1];
          v61 += 4;
          v49 = v32[2] + v33[2];
          v37 = v32[3];
          v38 = (float *)&v65[32 * v31];
          v50 = v37 + v33[3];
          v47 = v34 + *v38;
          v39 = v36 + v33[1] + v38[1];
          v40 = v49 + v38[2];
          v41 = v50 + v38[3];
          v42 = (float *)&v58[32 * v31];
          v48 = v41;
          ++v31;
          v45 = v47 + *v42;
          v46 = v39 + v42[1];
          v51 = v45 * 0.25;
          v52 = v46 * 0.25;
          v53 = (v40 + v42[2]) * 0.25;
          v54 = (v48 + v42[3]) * 0.25;
          *v35++ = v51;
          *v35++ = v52;
          *v35 = v53;
          v35[1] = v54;
        }
        while ( v31 < *(_DWORD *)(v4[1] + 4184) );
      }
      v44 = v62;
      v43 = 0;
      (*(void (__thiscall **)(_DWORD, unsigned int))(*(_DWORD *)v4[1] + 8))(v4[1], i);
    }
    operator delete(v60);
    v29 = 0;
  }
  else
  {
    v29 = -2147024882;
  }
  operator delete(v62);
  return v29;
}

// FUN_10014bbc @ 0x10014BBC
// [binja] int32_t __fastcall sub_10014bbc(int32_t* arg1)
int FUN_10014bbc(int *arg1)
{
  int v1; // ecx
  unsigned int v2; // edi
  float *v3; // esi
  _DWORD *v4; // ebx
  _DWORD *v6; // ecx
  unsigned int v7; // eax
  _DWORD *v8; // edx
  int v9; // esi
  int v10; // esi
  _DWORD *v11; // ecx
  _DWORD *v12; // ecx
  int v13; // esi
  float *v14; // eax
  int v15; // esi
  int v16; // esi
  char *v17; // eax
  char *v18; // ecx
  int v19; // eax
  char *v20; // esi
  char *v21; // edx
  int v22; // esi
  char *v23; // eax
  char *v24; // edx
  int v25; // esi
  int v26; // eax
  int v27; // edi
  float *v28; // ecx
  float *v29; // edx
  double v30; // st6
  double v31; // st5
  double v32; // st4
  float *v33; // ecx
  double v34; // st6
  double v35; // st5
  double v36; // st4
  float *v37; // ecx
  double v38; // st6
  double v39; // st5
  float *v40; // ecx
  double v41; // st5
  float *v42; // ecx
  double v43; // st6
  double v44; // st5
  float *v45; // ecx
  float *v46; // edi
  float *v47; // eax
  unsigned int v48; // [esp-8h] [ebp-D0h]
  float *v49; // [esp-4h] [ebp-CCh]
  float v50; // [esp+4h] [ebp-C4h]
  float v51; // [esp+10h] [ebp-B8h]
  float v52; // [esp+14h] [ebp-B4h]
  float v53; // [esp+20h] [ebp-A8h]
  float v54; // [esp+2Ch] [ebp-9Ch]
  float v55; // [esp+30h] [ebp-98h]
  float v56; // [esp+3Ch] [ebp-8Ch]
  float v57; // [esp+40h] [ebp-88h]
  float v58; // [esp+44h] [ebp-84h]
  float v59; // [esp+48h] [ebp-80h]
  float v60; // [esp+54h] [ebp-74h]
  float v61; // [esp+58h] [ebp-70h]
  float v62; // [esp+5Ch] [ebp-6Ch]
  float v63; // [esp+60h] [ebp-68h]
  float v64; // [esp+68h] [ebp-60h]
  float v65; // [esp+6Ch] [ebp-5Ch]
  float v66; // [esp+70h] [ebp-58h]
  float v67; // [esp+74h] [ebp-54h]
  float v68; // [esp+78h] [ebp-50h]
  float v69; // [esp+7Ch] [ebp-4Ch]
  char *v70; // [esp+84h] [ebp-44h]
  char *v71; // [esp+88h] [ebp-40h]
  char *v72; // [esp+8Ch] [ebp-3Ch]
  void *v73; // [esp+90h] [ebp-38h]
  float *v74; // [esp+94h] [ebp-34h]
  char *v75; // [esp+98h] [ebp-30h]
  unsigned int v76; // [esp+9Ch] [ebp-2Ch]
  char *v77; // [esp+A0h] [ebp-28h]
  unsigned int v78; // [esp+A4h] [ebp-24h]
  float *v79; // [esp+A8h] [ebp-20h]
  char *v80; // [esp+ACh] [ebp-1Ch]
  char *v81; // [esp+B0h] [ebp-18h]
  float *v82; // [esp+B4h] [ebp-14h]
  char *v83; // [esp+B4h] [ebp-14h]
  char *v84; // [esp+B4h] [ebp-14h]
  char *i; // [esp+B4h] [ebp-14h]
  unsigned int v86; // [esp+B8h] [ebp-10h]

  v4 = (_DWORD *)v1;
  if ( *(_BYTE *)(v1 + 8) != 5 )
    return -2147467259;
  v6 = *(_DWORD **)v1;
  v7 = *(_DWORD *)(*v4 + 4184);
  v8 = (_DWORD *)v4[1];
  v49 = v3;
  v9 = v8[1046];
  v48 = v2;
  if ( v9 != v7 >> 1 && (v9 != 1 || v7 != 1) )
    return -2147467259;
  v10 = v8[1047];
  if ( v10 != v6[1047] >> 1 && (v10 != 1 || v6[1047] != 1) )
    return -2147467259;
  if ( v8[1048] != v6[1048] >> 1 )
    return -2147467259;
  if ( v7 > 1 && (v7 & 1) != 0 )
  {
    v6[1046] = v7 & 0xFFFFFFFE;
    *(_DWORD *)(*v4 + 4196) -= *(_DWORD *)(*v4 + 4200);
  }
  v11 = (_DWORD *)(*v4 + 4188);
  if ( *v11 > 1u )
    *v11 &= ~1u;
  v12 = (_DWORD *)(*v4 + 4192);
  if ( *v12 > 1u )
    *v12 &= ~1u;
  v13 = *(_DWORD *)(v4[1] + 4184);
  v14 = (float *)operator new(16 * v13);
  v82 = v14;
  if ( v14 )
  {
    sub_1000B393((int)v14, 16, v13, (int (__thiscall *)(int))sub_1000AE4F);
    v79 = v82;
  }
  else
  {
    v79 = 0;
  }
  if ( !v79 )
    return -2147024882;
  v15 = *(_DWORD *)(*v4 + 4184);
  if ( *(_DWORD *)(*v4 + 4188) == 1 )
  {
    v16 = 2 * v15;
    v17 = (char *)operator new(16 * v16);
    v83 = v17;
    if ( v17 )
    {
      sub_1000B393((int)v17, 16, v16, (int (__thiscall *)(int))sub_1000AE4F);
      v18 = v83;
    }
    else
    {
      v18 = 0;
    }
    v19 = *(_DWORD *)(*v4 + 4184);
    v20 = &v18[16 * v19];
    v21 = v20;
    v73 = v18;
    v81 = v18;
    v75 = v20;
    v80 = v18;
    v77 = v20;
  }
  else
  {
    v22 = 4 * v15;
    v23 = (char *)operator new(16 * v22);
    v84 = v23;
    if ( v23 )
    {
      sub_1000B393((int)v23, 16, v22, (int (__thiscall *)(int))sub_1000AE4F);
      v24 = v84;
    }
    else
    {
      v24 = 0;
    }
    v19 = *(_DWORD *)(*v4 + 4184);
    v75 = &v24[16 * v19];
    v20 = v75;
    v80 = &v24[32 * v19];
    v77 = &v24[48 * v19];
    v18 = v80;
    v73 = v24;
    v81 = v24;
    v21 = v77;
  }
  if ( v73 )
  {
    if ( v19 == 1 )
    {
      v72 = v81;
      v71 = v20;
    }
    else
    {
      v72 = v81 + 16;
      v18 += 16;
      v71 = v20 + 16;
      v21 += 16;
    }
    v26 = v4[1];
    v78 = 0;
    v70 = v18;
    for ( i = v21; v78 < *(_DWORD *)(v26 + 4192); v26 = v4[1] )
    {
      v86 = 0;
      if ( *(_DWORD *)(v26 + 4188) )
      {
        do
        {
          v27 = 2 * v78;
          (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, char *, unsigned int, float *))(*(_DWORD *)*v4 + 4))(
            *v4,
            2 * v86,
            2 * v78,
            v81,
            v48,
            v49);
          if ( v20 != v81 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*v4 + 4))(*v4, 2 * v86, v27 + 1, v20);
          if ( v80 != v81 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*v4 + 4))(*v4, 2 * v86 + 1, v27, v80);
          if ( v77 != v20 && v77 != v80 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*v4 + 4))(
              *v4,
              2 * v86 + 1,
              v27 + 1,
              v77);
          v76 = 0;
          if ( *(_DWORD *)(v4[1] + 4184) )
          {
            v74 = v79;
            do
            {
              v28 = (float *)&v72[32 * v76];
              v29 = (float *)&v81[32 * v76];
              v30 = *v28 + *v29;
              v31 = v28[1] + v29[1];
              v56 = v28[2] + v29[2];
              v32 = v28[3];
              v33 = (float *)&v20[32 * v76];
              v57 = v32 + v29[3];
              v52 = v30 + *v33;
              v34 = v31 + v33[1];
              v35 = v56 + v33[2];
              v36 = v57 + v33[3];
              v37 = (float *)&v71[32 * v76];
              v53 = v36;
              v58 = v52 + *v37;
              v59 = v34 + v37[1];
              v38 = v35 + v37[2];
              v39 = v53 + v37[3];
              v40 = (float *)&v80[32 * v76];
              v67 = v58 + *v40;
              v68 = v59 + v40[1];
              v69 = v38 + v40[2];
              v41 = v39 + v40[3];
              v42 = (float *)&v70[32 * v76];
              v43 = v41;
              v44 = v67 + *v42;
              v64 = v68 + v42[1];
              v65 = v69 + v42[2];
              v66 = v43 + v42[3];
              v45 = (float *)&v77[32 * v76];
              v46 = v74;
              v74 += 4;
              v54 = v65 + v45[2];
              v47 = (float *)&i[32 * v76++];
              v55 = v66 + v45[3];
              v50 = v44 + *v45 + *v47;
              v51 = v55 + v47[3];
              v60 = v50 * 0.125;
              v61 = (v64 + v45[1] + v47[1]) * 0.125;
              v62 = (v54 + v47[2]) * 0.125;
              v63 = v51 * 0.125;
              *v46++ = v60;
              *v46++ = v61;
              *v46 = v62;
              v46[1] = v63;
              v20 = v75;
            }
            while ( v76 < *(_DWORD *)(v4[1] + 4184) );
          }
          v49 = v79;
          v48 = v78;
          (*(void (__thiscall **)(_DWORD, unsigned int))(*(_DWORD *)v4[1] + 8))(v4[1], v86++);
        }
        while ( v86 < *(_DWORD *)(v4[1] + 4188) );
      }
      ++v78;
    }
    operator delete(v73);
    v25 = 0;
  }
  else
  {
    v25 = -2147024882;
  }
  operator delete(v79);
  return v25;
}

// sub_1001504E @ 0x1001504E
int *__usercall sub_1001504E@<eax>(unsigned int a1@<ebx>, unsigned int a2@<edi>, int a3)
{
  int *result; // eax
  int *v4; // esi
  int v5; // eax
  double X; // st7
  int v7; // eax
  unsigned int v8; // ecx
  double v9; // st7
  int *v10; // [esp+Ch] [ebp-18h]
  float v11; // [esp+14h] [ebp-10h]
  float v12; // [esp+18h] [ebp-Ch]
  float v13; // [esp+1Ch] [ebp-8h]
  int v14; // [esp+20h] [ebp-4h]
  unsigned int v15; // [esp+20h] [ebp-4h]

  result = (int *)operator new(16 * a1);
  v4 = result;
  if ( result )
  {
    v10 = result;
    v5 = v14;
    v15 = 0;
    for ( dword_1005DB68 = v5; v15 < a1; *((float *)v4 - 1) = 1.0 - v9 )
    {
      v11 = (double)a2 / (double)a1;
      X = (double)v15 * v11 - 0.5;
      v13 = X;
      v12 = floor(X);
      v7 = (int)v12;
      v8 = v7 + 1;
      if ( v7 < 0 )
        v7 = a3 != 0 ? a2 - 1 : 0;
      if ( v8 >= a2 )
        v8 = a3 == 0 ? a2 - 1 : 0;
      *v4 = v7;
      v4[2] = v8;
      v4 += 4;
      ++v15;
      v9 = 1.0 - (v13 - v12);
      *((float *)v4 - 3) = v9;
    }
    return v10;
  }
  return result;
}

// FUN_1001514e @ 0x1001514E
// [binja] int32_t __fastcall sub_1001514e(int32_t* arg1)
int FUN_1001514e(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int v3; // eax
  int *v5; // eax
  int v6; // ebx
  void *v7; // eax
  void *v8; // eax
  int v9; // ebx
  char *v10; // eax
  char *v11; // eax
  char *v12; // ebx
  int *v13; // edi
  int v14; // eax
  int v15; // ecx
  char *v16; // eax
  int *v17; // eax
  double v18; // st7
  int v19; // ecx
  double v20; // st7
  double v21; // st6
  int v22; // edx
  float *v23; // ecx
  double v24; // st6
  double v25; // st7
  double v26; // st6
  double v27; // st5
  double v28; // st5
  float *v29; // edi
  int v30; // esi
  float v31; // [esp+4h] [ebp-D0h]
  float v32; // [esp+8h] [ebp-CCh]
  float v33; // [esp+Ch] [ebp-C8h]
  float v34; // [esp+10h] [ebp-C4h]
  float v35; // [esp+14h] [ebp-C0h]
  float v36; // [esp+18h] [ebp-BCh]
  float v37; // [esp+1Ch] [ebp-B8h]
  float v38; // [esp+24h] [ebp-B0h]
  float v39; // [esp+28h] [ebp-ACh]
  float v40; // [esp+2Ch] [ebp-A8h]
  float v41; // [esp+38h] [ebp-9Ch]
  float v42; // [esp+3Ch] [ebp-98h]
  float v43; // [esp+40h] [ebp-94h]
  float v44; // [esp+44h] [ebp-90h]
  float v45; // [esp+48h] [ebp-8Ch]
  float v46; // [esp+4Ch] [ebp-88h]
  float v47; // [esp+54h] [ebp-80h]
  float v48; // [esp+58h] [ebp-7Ch]
  float v49; // [esp+5Ch] [ebp-78h]
  float v50; // [esp+64h] [ebp-70h]
  float v51; // [esp+68h] [ebp-6Ch]
  float v52; // [esp+6Ch] [ebp-68h]
  float v53; // [esp+78h] [ebp-5Ch]
  float v54; // [esp+7Ch] [ebp-58h]
  float v55; // [esp+80h] [ebp-54h]
  float v56; // [esp+84h] [ebp-50h]
  float v57; // [esp+88h] [ebp-4Ch]
  float v58; // [esp+8Ch] [ebp-48h]
  _DWORD *v59; // [esp+94h] [ebp-40h]
  float *v60; // [esp+98h] [ebp-3Ch]
  char *v61; // [esp+9Ch] [ebp-38h]
  unsigned int v62; // [esp+A0h] [ebp-34h]
  int *v63; // [esp+A4h] [ebp-30h]
  char *v64; // [esp+A8h] [ebp-2Ch]
  unsigned int v65; // [esp+ACh] [ebp-28h]
  int v66; // [esp+B0h] [ebp-24h]
  float *v67; // [esp+B4h] [ebp-20h]
  void *v68; // [esp+B8h] [ebp-1Ch]
  char *v69; // [esp+B8h] [ebp-1Ch]
  int v70; // [esp+BCh] [ebp-18h]
  void *v71; // [esp+C0h] [ebp-14h]
  void *v72; // [esp+C0h] [ebp-14h]
  BOOL v73; // [esp+C4h] [ebp-10h]
  int *v74; // [esp+C4h] [ebp-10h]

  v71 = 0;
  v68 = 0;
  v2 = v1;
  v3 = v1[2];
  v59 = v1;
  if ( (_BYTE)v3 != 3 )
    return -2147467259;
  v73 = (v3 & 0x20000) == 0;
  v63 = sub_1001504E(*(_DWORD *)(v1[1] + 4184), *(_DWORD *)(*v1 + 4184), (v3 & 0x10000) == 0);
  v5 = sub_1001504E(*(_DWORD *)(v2[1] + 4188), *(_DWORD *)(*v2 + 4188), v73);
  v74 = v5;
  if ( !v63 || !v5 )
    goto LABEL_27;
  v6 = *(_DWORD *)(v2[1] + 4184);
  v7 = operator new(16 * v6);
  v72 = v7;
  if ( v7 )
  {
    sub_1000B393((int)v7, 16, v6, (int (__thiscall *)(int))sub_1000AE4F);
    v8 = v72;
    v67 = (float *)v72;
  }
  else
  {
    v67 = 0;
    v8 = 0;
  }
  v71 = v8;
  if ( v8
    && ((v9 = 2 * *(_DWORD *)(*v2 + 4184), v10 = (char *)operator new(32 * *(_DWORD *)(*v2 + 4184)), (v69 = v10) == 0)
      ? (v11 = 0)
      : (sub_1000B393((int)v10, 16, v9, (int (__thiscall *)(int))sub_1000AE4F), v11 = v69),
        (v68 = v11) != 0) )
  {
    v65 = 0;
    v66 = -1;
    v70 = -1;
    v12 = &v11[16 * *(_DWORD *)(*v2 + 4184)];
    v64 = v11;
    if ( *(_DWORD *)(v2[1] + 4188) )
    {
      v13 = v74 + 2;
      v61 = (char *)(v74 + 2);
      do
      {
        v14 = *(v13 - 2);
        v62 = 0;
        if ( v14 != v66 )
        {
          v15 = v70;
          if ( v14 == v70 )
          {
            v16 = v64;
            v70 = -1;
            v64 = v12;
            v66 = v15;
            v12 = v16;
          }
          else
          {
            v66 = *(v13 - 2);
            (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(*v2, v14, 0, v64);
          }
        }
        if ( *v13 != v70 )
        {
          v70 = *v13;
          (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(*v2, *v13, 0, v12);
        }
        if ( *(_DWORD *)(v2[1] + 4184) )
        {
          v17 = v63 + 2;
          v60 = v67;
          do
          {
            v18 = *((float *)v17 + 1);
            v19 = 16 * *v17;
            v56 = v18 * *(float *)&v12[v19];
            v57 = v18 * *(float *)&v12[v19 + 4];
            v58 = v18 * *(float *)&v12[v19 + 8];
            v20 = v18 * *(float *)&v12[v19 + 12];
            v21 = *((float *)v17 - 1);
            v22 = 16 * *(v17 - 2);
            v41 = v21 * *(float *)&v12[v22 + 4];
            v42 = v21 * *(float *)&v12[v22 + 8];
            v23 = (float *)&v64[v19];
            v43 = v21 * *(float *)&v12[v22 + 12];
            v47 = v21 * *(float *)&v12[v22] + v56;
            v48 = v41 + v57;
            v49 = v42 + v58;
            v24 = *((float *)v13 + 1);
            v38 = v47 * v24;
            v39 = v48 * v24;
            v40 = v49 * v24;
            v25 = (v43 + v20) * v24;
            v26 = *((float *)v17 + 1);
            v35 = v26 * *v23;
            v36 = v26 * v23[1];
            v37 = v26 * v23[2];
            v27 = *((float *)v17 - 1);
            v17 += 4;
            ++v62;
            v53 = v27 * *(float *)&v64[v22 + 4];
            v54 = v27 * *(float *)&v64[v22 + 8];
            v55 = v27 * *(float *)&v64[v22 + 12];
            v50 = v27 * *(float *)&v64[v22] + v35;
            v51 = v53 + v36;
            v52 = v54 + v37;
            v28 = *((float *)v13 - 1);
            v29 = v60;
            v60 += 4;
            v44 = v50 * v28;
            v45 = v51 * v28;
            v46 = v52 * v28;
            v31 = v44 + v38;
            v32 = v45 + v39;
            v33 = v46 + v40;
            v34 = (v55 + v26 * v23[3]) * v28 + v25;
            *v29++ = v31;
            *v29++ = v32;
            *v29 = v33;
            v29[1] = v34;
            v13 = (int *)v61;
          }
          while ( v62 < *(_DWORD *)(v59[1] + 4184) );
          v2 = v59;
        }
        (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, float *))(*(_DWORD *)v2[1] + 8))(v2[1], v65, 0, v67);
        v13 += 4;
        ++v65;
        v61 = (char *)v13;
      }
      while ( v65 < *(_DWORD *)(v2[1] + 4188) );
    }
    v30 = 0;
  }
  else
  {
LABEL_27:
    v30 = -2147024882;
  }
  operator delete(v63);
  operator delete(v74);
  operator delete(v71);
  operator delete(v68);
  return v30;
}

// FUN_10015534 @ 0x10015534
// [binja] int32_t __fastcall sub_10015534(int32_t* arg1)
int FUN_10015534(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int v3; // eax
  int *v5; // eax
  int v6; // edi
  void *v7; // eax
  void *v8; // eax
  int v9; // edi
  char *v10; // eax
  char *v11; // eax
  int v12; // edi
  char *v13; // ecx
  char *v14; // edi
  int v15; // eax
  int *v16; // ebx
  int v17; // eax
  int v18; // ecx
  char *v19; // ecx
  char *v20; // eax
  int *v21; // eax
  double v22; // st7
  int v23; // ecx
  double v24; // st6
  int v25; // edx
  double v26; // st6
  double v27; // st7
  double v28; // st6
  double v29; // st5
  double v30; // st5
  double v31; // st7
  double v32; // st6
  double v33; // st7
  double v34; // st6
  double v35; // st6
  double v36; // st5
  float *v37; // ecx
  double v38; // st5
  double v39; // st6
  double v40; // st5
  double v41; // st4
  double v42; // st4
  double v43; // st3
  double v44; // st5
  float *v45; // edi
  int v46; // esi
  float v47; // [esp+4h] [ebp-1A4h]
  float v48; // [esp+8h] [ebp-1A0h]
  float v49; // [esp+Ch] [ebp-19Ch]
  float v50; // [esp+10h] [ebp-198h]
  float v51; // [esp+14h] [ebp-194h]
  float v52; // [esp+18h] [ebp-190h]
  float v53; // [esp+1Ch] [ebp-18Ch]
  float v54; // [esp+24h] [ebp-184h]
  float v55; // [esp+28h] [ebp-180h]
  float v56; // [esp+2Ch] [ebp-17Ch]
  float v57; // [esp+34h] [ebp-174h]
  float v58; // [esp+38h] [ebp-170h]
  float v59; // [esp+3Ch] [ebp-16Ch]
  float v60; // [esp+44h] [ebp-164h]
  float v61; // [esp+48h] [ebp-160h]
  float v62; // [esp+4Ch] [ebp-15Ch]
  float v63; // [esp+54h] [ebp-154h]
  float v64; // [esp+58h] [ebp-150h]
  float v65; // [esp+5Ch] [ebp-14Ch]
  float v66; // [esp+64h] [ebp-144h]
  float v67; // [esp+68h] [ebp-140h]
  float v68; // [esp+6Ch] [ebp-13Ch]
  float v69; // [esp+74h] [ebp-134h]
  float v70; // [esp+78h] [ebp-130h]
  float v71; // [esp+7Ch] [ebp-12Ch]
  float v72; // [esp+84h] [ebp-124h]
  float v73; // [esp+88h] [ebp-120h]
  float v74; // [esp+8Ch] [ebp-11Ch]
  float v75; // [esp+94h] [ebp-114h]
  float v76; // [esp+98h] [ebp-110h]
  float v77; // [esp+9Ch] [ebp-10Ch]
  float v78; // [esp+A4h] [ebp-104h]
  float v79; // [esp+A8h] [ebp-100h]
  float v80; // [esp+ACh] [ebp-FCh]
  float v81; // [esp+B4h] [ebp-F4h]
  float v82; // [esp+B8h] [ebp-F0h]
  float v83; // [esp+BCh] [ebp-ECh]
  float v84; // [esp+C4h] [ebp-E4h]
  float v85; // [esp+C8h] [ebp-E0h]
  float v86; // [esp+CCh] [ebp-DCh]
  float v87; // [esp+D4h] [ebp-D4h]
  float v88; // [esp+D8h] [ebp-D0h]
  float v89; // [esp+DCh] [ebp-CCh]
  float v90; // [esp+E8h] [ebp-C0h]
  float v91; // [esp+ECh] [ebp-BCh]
  float v92; // [esp+F0h] [ebp-B8h]
  float v93; // [esp+F8h] [ebp-B0h]
  float v94; // [esp+FCh] [ebp-ACh]
  float v95; // [esp+100h] [ebp-A8h]
  float v96; // [esp+104h] [ebp-A4h]
  float v97; // [esp+108h] [ebp-A0h]
  float v98; // [esp+10Ch] [ebp-9Ch]
  float v99; // [esp+114h] [ebp-94h]
  float v100; // [esp+118h] [ebp-90h]
  float v101; // [esp+11Ch] [ebp-8Ch]
  float v102; // [esp+124h] [ebp-84h]
  float v103; // [esp+128h] [ebp-80h]
  float v104; // [esp+12Ch] [ebp-7Ch]
  float v105; // [esp+138h] [ebp-70h]
  float v106; // [esp+13Ch] [ebp-6Ch]
  float v107; // [esp+140h] [ebp-68h]
  float v108; // [esp+148h] [ebp-60h]
  float v109; // [esp+14Ch] [ebp-5Ch]
  float v110; // [esp+150h] [ebp-58h]
  _DWORD *v111; // [esp+154h] [ebp-54h]
  float *v112; // [esp+158h] [ebp-50h]
  int *v113; // [esp+15Ch] [ebp-4Ch]
  int *v114; // [esp+160h] [ebp-48h]
  void *v115; // [esp+164h] [ebp-44h]
  void *v116; // [esp+164h] [ebp-44h]
  char *v117; // [esp+168h] [ebp-40h]
  BOOL v118; // [esp+16Ch] [ebp-3Ch]
  int *v119; // [esp+16Ch] [ebp-3Ch]
  unsigned int v120; // [esp+170h] [ebp-38h]
  float *v121; // [esp+174h] [ebp-34h]
  void *v122; // [esp+178h] [ebp-30h]
  char *v123; // [esp+178h] [ebp-30h]
  char *v124; // [esp+17Ch] [ebp-2Ch]
  char *v125; // [esp+180h] [ebp-28h]
  unsigned int v126; // [esp+184h] [ebp-24h]
  BOOL v127; // [esp+188h] [ebp-20h]
  unsigned int v128; // [esp+188h] [ebp-20h]
  char *v129; // [esp+18Ch] [ebp-1Ch]
  int v130; // [esp+190h] [ebp-18h]
  int v131; // [esp+194h] [ebp-14h]
  float *v132; // [esp+198h] [ebp-10h]

  v115 = 0;
  v122 = 0;
  v2 = v1;
  v3 = v1[2];
  v111 = v1;
  if ( (_BYTE)v3 != 3 )
    return -2147467259;
  v127 = (v3 & 0x40000) == 0;
  v118 = (v3 & 0x20000) == 0;
  v114 = sub_1001504E(*(_DWORD *)(v1[1] + 4184), *(_DWORD *)(*v1 + 4184), (v3 & 0x10000) == 0);
  v113 = sub_1001504E(*(_DWORD *)(v2[1] + 4188), *(_DWORD *)(*v2 + 4188), v118);
  v5 = sub_1001504E(*(_DWORD *)(v2[1] + 4192), *(_DWORD *)(*v2 + 4192), v127);
  v119 = v5;
  if ( !v114 || !v113 || !v5 )
    goto LABEL_31;
  v6 = *(_DWORD *)(v2[1] + 4184);
  v7 = operator new(16 * v6);
  v116 = v7;
  if ( v7 )
  {
    sub_1000B393((int)v7, 16, v6, (int (__thiscall *)(int))sub_1000AE4F);
    v8 = v116;
    v121 = (float *)v116;
  }
  else
  {
    v121 = 0;
    v8 = 0;
  }
  v115 = v8;
  if ( v8
    && ((v9 = 4 * *(_DWORD *)(*v2 + 4184), v10 = (char *)operator new(*(_DWORD *)(*v2 + 4184) << 6), (v123 = v10) == 0)
      ? (v11 = 0)
      : (sub_1000B393((int)v10, 16, v9, (int (__thiscall *)(int))sub_1000AE4F), v11 = v123),
        (v122 = v11) != 0) )
  {
    v12 = *(_DWORD *)(*v2 + 4184);
    v120 = 0;
    v129 = &v11[16 * v12];
    v13 = &v11[32 * v12];
    v14 = &v11[48 * v12];
    v125 = v11;
    v15 = v2[1];
    v117 = v13;
    v124 = v14;
    if ( *(_DWORD *)(v15 + 4192) )
    {
      v132 = (float *)(v119 + 2);
      do
      {
        v126 = 0;
        v130 = -1;
        v131 = -1;
        if ( *(_DWORD *)(v15 + 4188) )
        {
          v16 = v113 + 2;
          do
          {
            v17 = *(v16 - 2);
            v128 = 0;
            if ( v17 != v130 )
            {
              v18 = v131;
              if ( v17 == v131 )
              {
                v131 = -1;
                v130 = v18;
                v19 = v129;
                v129 = v125;
                v20 = v117;
                v117 = v14;
                v125 = v19;
                v124 = v20;
                v14 = v20;
              }
              else
              {
                v130 = *(v16 - 2);
                (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(
                  *v2,
                  v17,
                  *((_DWORD *)v132 - 2),
                  v125);
                (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(
                  *v2,
                  v130,
                  *(_DWORD *)v132,
                  v117);
              }
            }
            if ( *v16 != v131 )
            {
              v131 = *v16;
              (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(
                *v2,
                *v16,
                *((_DWORD *)v132 - 2),
                v129);
              (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(
                *v2,
                v131,
                *(_DWORD *)v132,
                v14);
            }
            if ( *(_DWORD *)(v2[1] + 4184) )
            {
              v21 = v114 + 2;
              v112 = v121;
              do
              {
                v22 = *((float *)v21 + 1);
                v23 = 16 * *v21;
                v75 = v22 * *(float *)&v14[v23];
                v76 = v22 * *(float *)&v14[v23 + 4];
                v77 = v22 * *(float *)&v14[v23 + 8];
                v24 = *((float *)v21 - 1);
                v25 = 16 * *(v21 - 2);
                v108 = v24 * *(float *)&v14[v25 + 4];
                v109 = v24 * *(float *)&v14[v25 + 8];
                v110 = v24 * *(float *)&v14[v25 + 12];
                v99 = v24 * *(float *)&v14[v25] + v75;
                v100 = v108 + v76;
                v101 = v109 + v77;
                v26 = *((float *)v16 + 1);
                v57 = v99 * v26;
                v58 = v100 * v26;
                v59 = v101 * v26;
                v27 = (v110 + v22 * *(float *)&v14[v23 + 12]) * v26;
                v28 = *((float *)v21 + 1);
                v51 = v28 * *(float *)&v117[v23];
                v52 = v28 * *(float *)&v117[v23 + 4];
                v53 = v28 * *(float *)&v117[v23 + 8];
                v29 = *((float *)v21 - 1);
                v93 = v29 * *(float *)&v117[v25 + 4];
                v94 = v29 * *(float *)&v117[v25 + 8];
                v95 = v29 * *(float *)&v117[v25 + 12];
                v69 = v29 * *(float *)&v117[v25] + v51;
                v70 = v93 + v52;
                v71 = v94 + v53;
                v30 = *((float *)v16 - 1);
                v87 = v69 * v30;
                v88 = v70 * v30;
                v89 = v71 * v30;
                v81 = v87 + v57;
                v82 = v88 + v58;
                v83 = v89 + v59;
                v31 = (v95 + v28 * *(float *)&v117[v23 + 12]) * v30 + v27;
                v32 = v132[1];
                v54 = v81 * v32;
                v55 = v82 * v32;
                v56 = v83 * v32;
                v33 = v31 * v32;
                v34 = *((float *)v21 + 1);
                v63 = v34 * *(float *)&v129[v23];
                v64 = v34 * *(float *)&v129[v23 + 4];
                v65 = v34 * *(float *)&v129[v23 + 8];
                v35 = v34 * *(float *)&v129[v23 + 12];
                v36 = *((float *)v21 - 1);
                v105 = v36 * *(float *)&v129[v25 + 4];
                v106 = v36 * *(float *)&v129[v25 + 8];
                v37 = (float *)&v125[v23];
                v107 = v36 * *(float *)&v129[v25 + 12];
                v102 = v36 * *(float *)&v129[v25] + v63;
                v103 = v105 + v64;
                v104 = v106 + v65;
                v38 = *((float *)v16 + 1);
                v72 = v102 * v38;
                v73 = v103 * v38;
                v74 = v104 * v38;
                v39 = (v107 + v35) * v38;
                v40 = *((float *)v21 + 1);
                v96 = v40 * *v37;
                v97 = v40 * v37[1];
                v98 = v40 * v37[2];
                v41 = *((float *)v21 - 1);
                v90 = v41 * *(float *)&v125[v25 + 4];
                v91 = v41 * *(float *)&v125[v25 + 8];
                v92 = v41 * *(float *)&v125[v25 + 12];
                v84 = v41 * *(float *)&v125[v25] + v96;
                v85 = v90 + v97;
                v86 = v91 + v98;
                v42 = *((float *)v16 - 1);
                v78 = v84 * v42;
                v79 = v85 * v42;
                v80 = v86 * v42;
                v43 = (v92 + v40 * v37[3]) * v42;
                v66 = v78 + v72;
                v67 = v79 + v73;
                v68 = v80 + v74;
                v44 = *(v132 - 1);
                v60 = v66 * v44;
                v61 = v67 * v44;
                v62 = v68 * v44;
                v45 = v112;
                v112 += 4;
                v47 = v60 + v54;
                v21 += 4;
                ++v128;
                v48 = v61 + v55;
                v49 = v62 + v56;
                v50 = (v43 + v39) * v44 + v33;
                *v45++ = v47;
                *v45++ = v48;
                *v45 = v49;
                v45[1] = v50;
                v14 = v124;
              }
              while ( v128 < *(_DWORD *)(v111[1] + 4184) );
              v2 = v111;
            }
            (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, float *))(*(_DWORD *)v2[1] + 8))(
              v2[1],
              v126,
              v120,
              v121);
            v16 += 4;
            ++v126;
          }
          while ( v126 < *(_DWORD *)(v2[1] + 4188) );
        }
        v132 += 4;
        ++v120;
        v15 = v2[1];
      }
      while ( v120 < *(_DWORD *)(v15 + 4192) );
    }
    v46 = 0;
  }
  else
  {
LABEL_31:
    v46 = -2147024882;
  }
  operator delete(v114);
  operator delete(v113);
  operator delete(v119);
  operator delete(v115);
  operator delete(v122);
  return v46;
}

// FUN_10015c65 @ 0x10015C65
// [binja] int32_t __fastcall sub_10015c65(int32_t* arg1)
int FUN_10015c65(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // ebx
  int v3; // edx
  BOOL v4; // edi
  float *v5; // esi
  unsigned int v6; // edi
  int v7; // esi
  int *v8; // eax
  void *v9; // eax
  int v10; // esi
  char *v11; // eax
  void *v12; // eax
  _DWORD *v13; // ecx
  _DWORD *v14; // edx
  _DWORD *i; // ecx
  float *v16; // eax
  float *v17; // esi
  float *v18; // eax
  void **v19; // edi
  int v20; // esi
  void *v21; // eax
  void *v22; // eax
  float *v23; // eax
  float *v24; // edx
  float *v25; // ecx
  float *v26; // edi
  int v27; // ecx
  float *v28; // eax
  double v29; // st7
  float *v30; // esi
  float *v31; // edi
  void **v32; // esi
  bool v33; // zf
  int v34; // esi
  char v36; // [esp+0h] [ebp-50h]
  unsigned int v37; // [esp+Ch] [ebp-44h]
  void *v38; // [esp+10h] [ebp-40h]
  float *v39; // [esp+10h] [ebp-40h]
  void *v40; // [esp+14h] [ebp-3Ch]
  char *v41; // [esp+14h] [ebp-3Ch]
  float *v42; // [esp+18h] [ebp-38h]
  void *v43; // [esp+1Ch] [ebp-34h]
  void *v44; // [esp+1Ch] [ebp-34h]
  float *v45; // [esp+20h] [ebp-30h]
  unsigned int v46; // [esp+24h] [ebp-2Ch]
  int v47; // [esp+28h] [ebp-28h]
  char *v48; // [esp+2Ch] [ebp-24h]
  _DWORD *v49; // [esp+30h] [ebp-20h]
  unsigned int v50; // [esp+34h] [ebp-1Ch]
  void **v51; // [esp+38h] [ebp-18h]
  _DWORD *v52; // [esp+3Ch] [ebp-14h]
  float *v53; // [esp+40h] [ebp-10h]
  float *v54; // [esp+40h] [ebp-10h]

  v2 = v1;
  v3 = v1[1];
  v49 = 0;
  v43 = 0;
  v51 = 0;
  v40 = 0;
  if ( *(_DWORD *)(v3 + 4192) != 1 || *(_DWORD *)(*v1 + 4192) != 1 )
    return -2147467259;
  v4 = ((v1[2] >> 17) & 1) == 0;
  v5 = (float *)sub_1001288A(*(_DWORD *)(*v1 + 4184), *(_DWORD *)(v3 + 4184), (v1[2] & 0x10000) == 0);
  v42 = v5;
  if ( v5 && (v49 = sub_1001288A(*(_DWORD *)(*v2 + 4188), *(_DWORD *)(v2[1] + 4188), v4)) != 0 )
  {
    v46 = (unsigned int)v5 + *(_DWORD *)v5;
    v6 = (unsigned int)v49 + *v49;
    v7 = *(_DWORD *)(v2[1] + 4188);
    v37 = v6;
    v8 = (int *)operator new(12 * v7 + 4);
    if ( v8 )
    {
      *v8 = v7;
      v44 = v8 + 1;
      FUN_1004b6c3((int)(v8 + 1), 12, v7, (int)unknown_libname_2);
      v9 = v44;
      v52 = v44;
    }
    else
    {
      v52 = 0;
      v9 = 0;
    }
    v43 = v9;
    if ( !v9 )
      goto LABEL_47;
    v10 = *(_DWORD *)(*v2 + 4184);
    v11 = (char *)operator new(16 * v10);
    v41 = v11;
    if ( v11 )
    {
      sub_1000B393((int)v11, 16, v10, (int (__thiscall *)(int))sub_1000AE4F);
      v12 = v41;
      v48 = v41;
    }
    else
    {
      v48 = 0;
      v12 = 0;
    }
    v40 = v12;
    if ( v12 )
    {
      v13 = v49 + 1;
      if ( (unsigned int)(v49 + 1) < v6 )
      {
        do
        {
          v14 = (_DWORD *)((char *)v13 + *v13);
          for ( i = v13 + 1; i < v14; i += 2 )
            ++v52[3 * *i + 2];
          v13 = v14;
        }
        while ( (unsigned int)v14 < v6 );
      }
      v16 = (float *)(v49 + 1);
      v47 = 0;
      if ( (unsigned int)(v49 + 1) < v6 )
      {
        do
        {
          v17 = (float *)((char *)v16 + *(_DWORD *)v16);
          v18 = v16 + 1;
          v50 = (unsigned int)v17;
          v45 = v18;
          while ( 1 )
          {
            v53 = v18;
            if ( v18 >= v17 )
              break;
            v19 = (void **)&v52[3 * *(_DWORD *)v18];
            if ( !*v19 )
            {
              if ( v51 )
              {
                *v19 = *v51;
                *v51 = 0;
                v51 = (void **)v51[1];
              }
              else
              {
                v20 = *(_DWORD *)(v2[1] + 4184);
                v21 = operator new(16 * v20);
                v38 = v21;
                if ( v21 )
                {
                  sub_1000B393((int)v21, 16, v20, (int (__thiscall *)(int))sub_1000AE4F);
                  v22 = v38;
                }
                else
                {
                  v22 = 0;
                }
                *v19 = v22;
                if ( !v22 )
                  goto LABEL_47;
              }
              v17 = (float *)v50;
              memset(*v19, 0, 16 * *(_DWORD *)(v2[1] + 4184));
            }
            v18 = v53 + 2;
          }
          (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v2 + 4))(*v2, v47, 0, v48);
          v23 = v42 + 1;
          if ( (unsigned int)(v42 + 1) < v46 )
          {
            v24 = (float *)(v48 + 8);
            do
            {
              v25 = v45;
              v26 = (float *)((char *)v23 + *(_DWORD *)v23);
              v54 = v45;
              if ( v45 < v17 )
              {
                v39 = v23 + 1;
                while ( 1 )
                {
                  v27 = v52[3 * *(_DWORD *)v25];
                  v28 = v39;
                  if ( v39 < v26 )
                  {
                    do
                    {
                      v29 = v28[1] * v54[1];
                      *(float *)(v27 + 16 * *(_DWORD *)v28) = v29 * *(v24 - 2) + *(float *)(v27 + 16 * *(_DWORD *)v28);
                      *(float *)(16 * *(_DWORD *)v28 + v27 + 4) = v29 * *(v24 - 1)
                                                                + *(float *)(16 * *(_DWORD *)v28 + v27 + 4);
                      *(float *)(16 * *(_DWORD *)v28 + v27 + 8) = v29 * *v24 + *(float *)(16 * *(_DWORD *)v28 + v27 + 8);
                      v30 = (float *)(16 * *(_DWORD *)v28 + v27 + 12);
                      v28 += 2;
                      *v30 = v29 * v24[1] + *v30;
                    }
                    while ( v28 < v26 );
                    v17 = (float *)v50;
                  }
                  v54 += 2;
                  if ( v54 >= v17 )
                    break;
                  v25 = v54;
                }
              }
              v24 += 4;
              v23 = v26;
            }
            while ( (unsigned int)v26 < v46 );
          }
          v31 = v45;
          if ( v45 < v17 )
          {
            do
            {
              v32 = (void **)&v52[3 * *(_DWORD *)v31];
              v33 = v32[2] == (void *)1;
              v32[2] = (char *)v32[2] - 1;
              if ( v33 )
              {
                (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, void *))(*(_DWORD *)v2[1] + 8))(
                  v2[1],
                  *(_DWORD *)v31,
                  0,
                  *v32);
                v32[1] = v51;
                v51 = v32;
              }
              v31 += 2;
            }
            while ( (unsigned int)v31 < v50 );
            v17 = (float *)v50;
          }
          ++v47;
          v16 = v17;
        }
        while ( (unsigned int)v17 < v37 );
      }
      v34 = 0;
    }
    else
    {
LABEL_47:
      v34 = -2147024882;
    }
  }
  else
  {
    v34 = -2147467259;
  }
  if ( v43 )
    FUN_10012b47((int *)3, v36);
  operator delete(v49);
  operator delete(v42);
  operator delete(v40);
  operator delete(0);
  return v34;
}

// FUN_10016007 @ 0x10016007
// [binja] int32_t __thiscall sub_10016007(int32_t* arg1, void*** arg2, void*** arg3, int32_t arg4)
int FUN_10016007(int *arg1, void ***arg2, void ***arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *v5; // ebx
  _DWORD *v6; // esi
  void *v7; // eax
  void *v8; // eax
  int v9; // ebx
  void (__thiscall ***v10)(_DWORD, int); // ecx
  int *v12; // [esp-4h] [ebp-8h]
  int *v13; // [esp-4h] [ebp-8h]
  int *v14; // [esp-4h] [ebp-8h]
  int *v15; // [esp-4h] [ebp-8h]
  int *v16; // [esp-4h] [ebp-8h]
  int *v17; // [esp-4h] [ebp-8h]
  int *v18; // [esp-4h] [ebp-8h]
  int *v19; // [esp-4h] [ebp-8h]
  int *v20; // [esp-4h] [ebp-8h]
  int *v21; // [esp-4h] [ebp-8h]

  v6 = v4;
  v4[1] = 0;
  *v4 = 0;
  v4[2] = arg3;
  if ( !(_WORD)arg3 || (unsigned __int16)arg3 > 5u || ((unsigned int)arg3 & 0xFFF00000) != 0 )
    return -2005530516;
  arg1[16] = (unsigned int)arg3 & 0x80000;
  v7 = grim_pixel_format_create((uint *)arg1);
  v6[1] = v7;
  if ( !v7 )
    goto LABEL_18;
  v8 = grim_pixel_format_create((uint *)arg2);
  *v6 = v8;
  if ( !v8 )
    goto LABEL_18;
  v9 = FUN_10017361(v8, v5);
  if ( v9 >= 0 )
  {
    if ( FUN_1001416a(v12) >= 0
      || FUN_100142a2(v13) >= 0
      || FUN_10014393(v14) >= 0
      || FUN_10014595(v15) >= 0
      || FUN_10014799(v16) >= 0
      || FUN_10014bbc(v17) >= 0
      || FUN_1001514e(v18) >= 0
      || FUN_10015534(v19) >= 0
      || FUN_10015c65(v20) >= 0
      || FUN_10012b93(v21) >= 0 )
    {
      v9 = 0;
      goto LABEL_19;
    }
LABEL_18:
    v9 = -2147467259;
  }
LABEL_19:
  v10 = (void (__thiscall ***)(_DWORD, int))v6[1];
  if ( v10 )
  {
    (**v10)(v10, 1);
    v6[1] = 0;
  }
  if ( *v6 )
  {
    (**(void (__thiscall ***)(_DWORD, int))*v6)(*v6, 1);
    *v6 = 0;
  }
  return v9;
}

// FUN_10016121 @ 0x10016121
// [binja] int32_t* __fastcall sub_10016121(int32_t* arg1)
int *FUN_10016121(int *arg1)
{
  int *v1; // ecx

  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  return v1;
}

// FUN_10016131 @ 0x10016131
// [binja] int32_t __fastcall sub_10016131(char* arg1)
int FUN_10016131(char *arg1)
{
  int v1; // ecx
  int v2; // esi
  int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  int v7; // eax
  int v8; // eax

  v2 = v1;
  v3 = *(_DWORD *)(v1 + 8);
  if ( v3 || (v3 = *(_DWORD *)(v1 + 4)) != 0 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 40))(v3);
  v4 = *(_DWORD *)(v2 + 4);
  if ( v4 )
  {
    v5 = *(_DWORD *)(v2 + 8);
    if ( v5 )
    {
      v6 = *(_DWORD *)(v2 + 12);
      if ( v6 )
      {
        if ( (*(_BYTE *)v2 & 1) == 0 )
          (*(void (__stdcall **)(int, int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v6 + 112))(v6, v5, 0, 0, v4, 0);
      }
    }
  }
  v7 = *(_DWORD *)(v2 + 8);
  if ( v7 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(_DWORD *)(v2 + 8));
    *(_DWORD *)(v2 + 8) = 0;
  }
  v8 = *(_DWORD *)(v2 + 12);
  if ( v8 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 8))(*(_DWORD *)(v2 + 12));
    *(_DWORD *)(v2 + 12) = 0;
  }
  *(_DWORD *)(v2 + 4) = 0;
  return 0;
}

// FUN_1001619a @ 0x1001619A
// [binja] int32_t* __fastcall sub_1001619a(int32_t* arg1)
int *FUN_1001619a(int *arg1)
{
  int *v1; // ecx

  *v1 = 0;
  return v1;
}

// FUN_100161a0 @ 0x100161A0
// [binja] int32_t __fastcall sub_100161a0(int32_t* arg1)
int FUN_100161a0(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi

  v2 = v1;
  if ( *v1 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v1 + 40))(*v1);
  *v2 = 0;
  return 0;
}

// FUN_100161bb @ 0x100161BB
// [binja] int32_t __thiscall sub_100161bb(char* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t arg6, int32_t arg7)
int FUN_100161bb(char *arg1, int *arg2, int *arg3, int arg4, int *arg5, int arg6, int arg7)
{
  int *v7; // ecx
  int result; // eax
  unsigned int v9; // ebx
  unsigned int v10; // eax
  int *v11; // edi
  _DWORD *v12; // esi
  int **v13; // edi
  int v14; // ebx
  unsigned int v15; // eax
  bool v16; // zf
  unsigned int v17; // edx
  unsigned int v18; // eax
  unsigned int v19; // esi
  unsigned int v20; // ecx
  int v21; // edx
  int v22; // edx
  unsigned int v23; // edx
  unsigned int v24; // edx
  int *v25; // eax
  char *v26; // [esp+0h] [ebp-6Ch]
  int v27; // [esp+Ch] [ebp-60h] BYREF
  unsigned int v28; // [esp+14h] [ebp-58h]
  int v29; // [esp+18h] [ebp-54h]
  unsigned int v30; // [esp+24h] [ebp-48h]
  unsigned int v31; // [esp+28h] [ebp-44h]
  unsigned int v32; // [esp+2Ch] [ebp-40h] BYREF
  unsigned int v33; // [esp+30h] [ebp-3Ch]
  unsigned int v34; // [esp+34h] [ebp-38h]
  unsigned int v35; // [esp+38h] [ebp-34h]
  int v36; // [esp+3Ch] [ebp-30h]
  int v37; // [esp+40h] [ebp-2Ch]
  int v38; // [esp+44h] [ebp-28h]
  int v39; // [esp+48h] [ebp-24h]
  _DWORD v40[2]; // [esp+4Ch] [ebp-20h] BYREF
  int *v41; // [esp+54h] [ebp-18h]
  int v42; // [esp+58h] [ebp-14h] BYREF
  int *v43; // [esp+5Ch] [ebp-10h]
  int v44; // [esp+60h] [ebp-Ch] BYREF
  BOOL v45; // [esp+64h] [ebp-8h]
  int v46; // [esp+68h] [ebp-4h]
  int arg4a; // [esp+80h] [ebp+14h]

  v41 = v7;
  FUN_10016131(v26);
  (*(void (__stdcall **)(int *, int *))(*arg2 + 32))(arg2, &v27);
  if ( arg4 )
  {
    v36 = *(_DWORD *)arg4;
    v37 = *(_DWORD *)(arg4 + 4);
    v38 = *(_DWORD *)(arg4 + 8);
    v39 = *(_DWORD *)(arg4 + 12);
    if ( v36 < 0 || v38 > v30 || v36 > v38 || v37 < 0 || v39 > v31 || v37 > v39 )
      return -2005530516;
    if ( v36 || v38 != v30 || v37 || (arg4a = 0, v39 != v31) )
      arg4a = 1;
    v45 = (arg6 & 1) == 0 && !arg4a;
  }
  else
  {
    v38 = v30;
    v39 = v31;
    v36 = 0;
    v37 = 0;
    arg4a = 0;
    v45 = (arg6 & 1) == 0;
  }
  v46 = arg6 & 0x10000;
  if ( (arg6 & 0x10000) == 0 )
  {
    if ( v29 || (v28 & 0x200) != 0 )
      goto LABEL_38;
    grim_d3d_debug_set_mute(1);
    if ( (*(int (__stdcall **)(int *, void *, int *))(*arg2 + 28))(arg2, &unk_1004E544, &v42) < 0 )
    {
      v28 = arg2[4];
      v46 = ((v28 >> 26) & 1) == 0;
    }
    else
    {
      v46 = 1;
      if ( v42 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v42 + 8))(v42);
        v42 = 0;
      }
    }
    grim_d3d_debug_set_mute(0);
    if ( !v46 )
    {
LABEL_38:
      v43 = arg2;
      goto LABEL_39;
    }
  }
  if ( v27 == 827611204 || v27 == 844388420 || v27 == 861165636 || v27 == 877942852 || v27 == 894720068 )
  {
    v9 = (v30 + 3) & 0xFFFFFFFC;
    v10 = (v31 + 3) & 0xFFFFFFFC;
  }
  else
  {
    v9 = v30;
    v10 = v31;
  }
  v11 = v41;
  v43 = (int *)v10;
  v12 = v41 + 3;
  (*(void (__stdcall **)(int *, int *))(*arg2 + 12))(arg2, v41 + 3);
  v13 = (int **)(v11 + 2);
  result = (*(int (__stdcall **)(_DWORD, unsigned int, int *, int, int **))(*(_DWORD *)*v12 + 108))(
             *v12,
             v9,
             v43,
             v27,
             v13);
  if ( result >= 0 )
  {
    if ( v45
      || (result = (*(int (__stdcall **)(_DWORD, int *, _DWORD, _DWORD, int *, _DWORD))(*(_DWORD *)*v12 + 112))(
                     *v12,
                     arg2,
                     0,
                     0,
                     *v13,
                     0),
          result >= 0) )
    {
      v43 = *v13;
LABEL_39:
      v14 = 16 * (arg6 & 1 | 0x80);
      if ( v45 && !v46 && (v28 & 0x200) != 0 )
      {
        if ( (arg6 & 0x20000) != 0 )
        {
          v14 |= 0x2000u;
          goto LABEL_84;
        }
        grim_d3d_debug_set_mute(1);
        if ( (*(int (__stdcall **)(int *, void *, int *))(*arg2 + 28))(arg2, &unk_1004E534, &v44) >= 0 )
        {
          if ( (*(int (__stdcall **)(int))(*(_DWORD *)v44 + 52))(v44) == 1 )
          {
            v14 |= 0x2000u;
            arg4a = 0;
          }
          if ( v44 )
          {
            (*(void (__stdcall **)(int))(*(_DWORD *)v44 + 8))(v44);
            v44 = 0;
          }
        }
        grim_d3d_debug_set_mute(0);
      }
      if ( !arg4a )
        goto LABEL_84;
      if ( v27 != 827611204 && v27 != 844388420 )
      {
        if ( v27 == 844715353 )
        {
LABEL_59:
          v15 = (v38 + 1) & 0xFFFFFFFE;
          v32 = v36 & 0xFFFFFFFE;
          v34 = v15;
          v33 = v37;
          v35 = v39;
          if ( v15 > v30 )
          {
            v15 = v30;
            v34 = v30;
          }
          if ( (v36 & 0xFFFFFFFE) != 0 || v15 != v30 || v37 )
            goto LABEL_75;
          v16 = v39 == v31;
          goto LABEL_74;
        }
        if ( v27 != 861165636 && v27 != 877942852 && v27 != 894720068 )
        {
          if ( v27 != 1498831189 )
          {
            v32 = v36;
            v33 = v37;
            v34 = v38;
            v35 = v39;
LABEL_75:
            result = (*(int (__stdcall **)(int *, _DWORD *, unsigned int *, int))(*v43 + 36))(v43, v40, &v32, v14);
            if ( result < 0 )
              return result;
            v36 -= v32;
            v38 -= v32;
            v37 -= v33;
            v39 -= v33;
            goto LABEL_77;
          }
          goto LABEL_59;
        }
      }
      v17 = v36 & 0xFFFFFFFC;
      v18 = (v38 + 3) & 0xFFFFFFFC;
      v19 = v37 & 0xFFFFFFFC;
      v20 = (v39 + 3) & 0xFFFFFFFC;
      v32 = v36 & 0xFFFFFFFC;
      v34 = v18;
      v33 = v37 & 0xFFFFFFFC;
      v35 = v20;
      if ( v46 )
      {
        if ( v17 || v18 != ((v30 + 3) & 0xFFFFFFFC) || v19 || v20 != ((v31 + 3) & 0xFFFFFFFC) )
          goto LABEL_75;
        goto LABEL_84;
      }
      if ( v18 > v30 )
      {
        v18 = v30;
        v34 = v30;
      }
      if ( v20 > v31 )
      {
        v20 = v31;
        v35 = v31;
      }
      if ( v17 || v18 != v30 || v19 )
        goto LABEL_75;
      v16 = v20 == v31;
LABEL_74:
      if ( !v16 )
        goto LABEL_75;
LABEL_84:
      result = (*(int (__stdcall **)(int *, _DWORD *, _DWORD, int))(*v43 + 36))(v43, v40, 0, v14);
      if ( result < 0 )
        return result;
LABEL_77:
      v21 = v40[1];
      *((_DWORD *)arg1 + 3) = 0;
      *((_DWORD *)arg1 + 4) = 0;
      *((_DWORD *)arg1 + 5) = 0;
      *((_DWORD *)arg1 + 8) = 0;
      *((_DWORD *)arg1 + 14) = 0;
      *(_DWORD *)arg1 = v21;
      *((_DWORD *)arg1 + 1) = v27;
      v22 = v40[0];
      *((_DWORD *)arg1 + 10) = v36;
      *((_DWORD *)arg1 + 15) = 1;
      *((_DWORD *)arg1 + 16) = 1;
      *((_DWORD *)arg1 + 2) = v22;
      v23 = v30;
      *((_DWORD *)arg1 + 11) = v37;
      *((_DWORD *)arg1 + 17) = arg5;
      *((_DWORD *)arg1 + 6) = v23;
      v24 = v31;
      *((_DWORD *)arg1 + 12) = v38;
      *((_DWORD *)arg1 + 18) = arg3;
      *((_DWORD *)arg1 + 7) = v24;
      *((_DWORD *)arg1 + 9) = 1;
      v25 = v41;
      *((_DWORD *)arg1 + 13) = v39;
      v25[1] = (int)arg2;
      *v25 = arg6;
      return 0;
    }
  }
  return result;
}

// FUN_100165d3 @ 0x100165D3
// [binja] int32_t __thiscall sub_100165d3(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)
int FUN_100165d3(int *arg1, int *arg2, int *arg3, int arg4, int arg5, int arg6, int arg7)
{
  int **v7; // ecx
  bool v8; // zf
  unsigned int v9; // ebx
  BOOL v10; // eax
  int result; // eax
  int v12; // esi
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // ecx
  int v16; // edx
  int v17; // edx
  int **v18; // ecx
  int *v19; // [esp+0h] [ebp-74h]
  int v20; // [esp+Ch] [ebp-68h] BYREF
  int v21; // [esp+14h] [ebp-60h]
  int v22; // [esp+18h] [ebp-5Ch]
  unsigned int v23; // [esp+20h] [ebp-54h]
  unsigned int v24; // [esp+24h] [ebp-50h]
  unsigned int v25; // [esp+28h] [ebp-4Ch]
  _DWORD v26[6]; // [esp+2Ch] [ebp-48h] BYREF
  _DWORD v27[6]; // [esp+44h] [ebp-30h] BYREF
  _DWORD v28[3]; // [esp+5Ch] [ebp-18h] BYREF
  int **v29; // [esp+68h] [ebp-Ch]
  int v30; // [esp+6Ch] [ebp-8h]
  int v31; // [esp+70h] [ebp-4h] BYREF
  int arg4a; // [esp+88h] [ebp+14h]

  v8 = *v7 == 0;
  v29 = v7;
  if ( !v8 )
    FUN_100161a0(v19);
  (*(void (__stdcall **)(int *, int *))(*arg2 + 32))(arg2, &v20);
  if ( arg4 )
  {
    qmemcpy(v27, (const void *)arg4, sizeof(v27));
    if ( v27[2] > v23 )
      return -2005530516;
    if ( v27[0] > v27[2] )
      return -2005530516;
    if ( v27[3] > v24 )
      return -2005530516;
    if ( v27[1] > v27[3] )
      return -2005530516;
    v9 = v27[5];
    if ( v27[5] > v25 || v27[4] > v27[5] )
      return -2005530516;
    if ( v27[0] || v27[2] != v23 || v27[1] || v27[3] != v24 || v27[4] || (arg4a = 0, v27[5] != v25) )
      arg4a = 1;
    v10 = (arg6 & 1) == 0 && !arg4a;
  }
  else
  {
    v9 = v25;
    arg4a = 0;
    v27[2] = v23;
    v27[3] = v24;
    v10 = (arg6 & 1) == 0;
    v27[0] = 0;
    v27[1] = 0;
    v27[4] = 0;
    v27[5] = v25;
  }
  if ( !v22 && (v21 & 0x200) == 0 )
    return -2005530516;
  v12 = 16 * (arg6 & 1 | 0x80);
  v30 = v12;
  if ( v10 && (v21 & 0x200) != 0 )
  {
    if ( (arg6 & 0x20000) != 0 )
    {
      v12 |= 0x2000u;
      goto LABEL_65;
    }
    grim_d3d_debug_set_mute(1);
    if ( (*(int (__stdcall **)(int *, void *, int *))(*arg2 + 28))(arg2, &unk_1004E524, &v31) >= 0 )
    {
      if ( (*(int (__stdcall **)(int))(*(_DWORD *)v31 + 52))(v31) == 1 )
      {
        v12 |= 0x2000u;
        v30 = v12;
        arg4a = 0;
      }
      if ( v31 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v31 + 8))(v31);
        v31 = 0;
      }
    }
    grim_d3d_debug_set_mute(0);
  }
  if ( !arg4a )
    goto LABEL_65;
  if ( v20 != 827611204 && v20 != 844388420 )
  {
    if ( v20 == 844715353 )
    {
LABEL_44:
      v13 = (v27[2] + 1) & 0xFFFFFFFE;
      v26[3] = v27[3];
      v26[0] = v27[0] & 0xFFFFFFFE;
      v26[2] = v13;
      v26[1] = v27[1];
      v26[4] = v27[4];
      v26[5] = v9;
      if ( v13 > v23 )
      {
        v13 = v23;
        v26[2] = v23;
      }
      if ( (v27[0] & 0xFFFFFFFE) != 0 || v13 != v23 || v27[1] || v27[3] != v24 || v27[4] || v9 != v25 )
        goto LABEL_68;
      goto LABEL_65;
    }
    if ( v20 != 861165636 && v20 != 877942852 && v20 != 894720068 )
    {
      if ( v20 != 1498831189 )
      {
        qmemcpy(v26, v27, sizeof(v26));
LABEL_67:
        v12 = v30;
LABEL_68:
        result = (*(int (__stdcall **)(int *, _DWORD *, _DWORD *, int))(*arg2 + 36))(arg2, v28, v26, v12);
        if ( result < 0 )
          return result;
        v27[0] -= v26[0];
        v27[2] -= v26[0];
        v27[1] -= v26[1];
        v27[3] -= v26[1];
        v27[4] -= v26[4];
        v27[5] = v9 - v26[4];
        goto LABEL_70;
      }
      goto LABEL_44;
    }
  }
  v14 = (v27[2] + 3) & 0xFFFFFFFC;
  v15 = (v27[3] + 3) & 0xFFFFFFFC;
  v26[0] = v27[0] & 0xFFFFFFFC;
  v26[2] = v14;
  v26[1] = v27[1] & 0xFFFFFFFC;
  v26[3] = v15;
  v26[4] = v27[4];
  v26[5] = v9;
  if ( v14 > v23 )
  {
    v14 = v23;
    v26[2] = v23;
  }
  if ( v15 > v24 )
  {
    v15 = v24;
    v26[3] = v24;
  }
  if ( (v27[0] & 0xFFFFFFFC) != 0 || v14 != v23 || (v27[1] & 0xFFFFFFFC) != 0 || v15 != v24 || v27[4] || v9 != v25 )
    goto LABEL_67;
  v12 = v30;
LABEL_65:
  result = (*(int (__stdcall **)(int *, _DWORD *, _DWORD, int))(*arg2 + 36))(arg2, v28, 0, v12);
  if ( result >= 0 )
  {
LABEL_70:
    v16 = v23;
    *arg1 = v28[2];
    arg1[1] = v20;
    arg1[2] = v28[0];
    arg1[3] = v28[1];
    arg1[4] = 0;
    arg1[5] = 0;
    arg1[8] = 0;
    arg1[9] = v25;
    qmemcpy(arg1 + 10, v27, 0x18u);
    arg1[17] = arg5;
    arg1[6] = v16;
    v17 = v24;
    arg1[18] = (int)arg3;
    v18 = v29;
    arg1[7] = v17;
    arg1[16] = 1;
    *v18 = arg2;
    return 0;
  }
  return result;
}

// grim_vertex_space_converter_destroy @ 0x1001692E
// frees the converted vertex buffer at this+0x104c
void grim_vertex_space_converter_destroy(void *this)
{
  _DWORD *v1; // ecx
  void *v2; // [esp-4h] [ebp-4h]

  v2 = (void *)v1[1043];
  *v1 = &off_1004CAE4;
  operator delete(v2);
}

// nullsub_6 @ 0x10016941
void __stdcall nullsub_6(int a1, int a2, int a3)
{
  ;
}

// grim_convert_vertex_space @ 0x10016944
// converts vec4 coordinates between space modes (1/2/3), writes to this+0x104c, returns the output buffer
float *grim_convert_vertex_space(void *this, float *src)
{
  int v2; // ecx
  unsigned int v3; // esi
  int v4; // edx
  float *v5; // eax
  double v6; // st7
  unsigned int v7; // esi
  int v8; // edx
  float *v9; // eax
  double v10; // st5
  unsigned int v11; // esi
  int v12; // edx
  float *v13; // eax
  double v14; // st7
  unsigned int v15; // esi
  int v16; // edx
  float *v17; // eax
  double v18; // st5
  unsigned int v19; // esi
  int v20; // edx
  float *v21; // eax
  double v22; // st5
  unsigned int v23; // esi
  int v24; // edx
  float *v25; // eax
  double v26; // st5

  switch ( *(_DWORD *)(v2 + 8) )
  {
    case 1:
      if ( *(_DWORD *)(v2 + 4168) == 2 )
      {
        v23 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v24 = 0;
          v25 = (float *)((char *)this + 8);
          do
          {
            ++v23;
            *(float *)(v24 + *(_DWORD *)(v2 + 4172)) = (*(v25 - 2) + 1.0) * 0.5;
            v24 += 16;
            *(float *)(v24 + *(_DWORD *)(v2 + 4172) - 12) = (*(v25 - 1) + 1.0) * 0.5;
            v26 = *v25;
            v25 += 4;
            *(float *)(v24 + *(_DWORD *)(v2 + 4172) - 8) = (v26 + 1.0) * 0.5;
            *(float *)(v24 + *(_DWORD *)(v2 + 4172) - 4) = *(v25 - 3);
          }
          while ( v23 < *(_DWORD *)(v2 + 4184) );
        }
      }
      else if ( *(_DWORD *)(v2 + 4168) == 3 )
      {
        v19 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v20 = 0;
          v21 = (float *)((char *)this + 8);
          do
          {
            ++v19;
            *(float *)(v20 + *(_DWORD *)(v2 + 4172)) = (*(v21 - 2) + 1.0) * 0.5;
            v20 += 16;
            *(float *)(v20 + *(_DWORD *)(v2 + 4172) - 12) = (*(v21 - 1) + 1.0) * 0.5;
            v22 = *v21;
            v21 += 4;
            *(float *)(v20 + *(_DWORD *)(v2 + 4172) - 8) = (v22 + 1.0) * 0.5;
            *(float *)(v20 + *(_DWORD *)(v2 + 4172) - 4) = (*(v21 - 3) + 1.0) * 0.5;
          }
          while ( v19 < *(_DWORD *)(v2 + 4184) );
        }
      }
      break;
    case 2:
      if ( *(_DWORD *)(v2 + 4168) == 1 )
      {
        v15 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v16 = 0;
          v17 = (float *)((char *)this + 8);
          do
          {
            ++v15;
            *(float *)(v16 + *(_DWORD *)(v2 + 4172)) = *(v17 - 2) * 2.0 - 1.0;
            v16 += 16;
            *(float *)(v16 + *(_DWORD *)(v2 + 4172) - 12) = *(v17 - 1) * 2.0 - 1.0;
            v18 = *v17;
            v17 += 4;
            *(float *)(v16 + *(_DWORD *)(v2 + 4172) - 8) = v18 * 2.0 - 1.0;
            *(float *)(v16 + *(_DWORD *)(v2 + 4172) - 4) = *(v17 - 3);
          }
          while ( v15 < *(_DWORD *)(v2 + 4184) );
        }
      }
      else if ( *(_DWORD *)(v2 + 4168) == 3 )
      {
        v11 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v12 = 0;
          v13 = (float *)((char *)this + 8);
          do
          {
            *(float *)(v12 + *(_DWORD *)(v2 + 4172)) = *(v13 - 2);
            ++v11;
            *(float *)(v12 + *(_DWORD *)(v2 + 4172) + 4) = *(v13 - 1);
            v12 += 16;
            *(float *)(v12 + *(_DWORD *)(v2 + 4172) - 8) = *v13;
            v14 = v13[1];
            v13 += 4;
            *(float *)(v12 + *(_DWORD *)(v2 + 4172) - 4) = (v14 + 1.0) * 0.5;
          }
          while ( v11 < *(_DWORD *)(v2 + 4184) );
        }
      }
      break;
    case 3:
      if ( *(_DWORD *)(v2 + 4168) == 1 )
      {
        v7 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v8 = 0;
          v9 = (float *)((char *)this + 8);
          do
          {
            ++v7;
            *(float *)(v8 + *(_DWORD *)(v2 + 4172)) = *(v9 - 2) * 2.0 - 1.0;
            v8 += 16;
            *(float *)(v8 + *(_DWORD *)(v2 + 4172) - 12) = *(v9 - 1) * 2.0 - 1.0;
            v10 = *v9;
            v9 += 4;
            *(float *)(v8 + *(_DWORD *)(v2 + 4172) - 8) = v10 * 2.0 - 1.0;
            *(float *)(v8 + *(_DWORD *)(v2 + 4172) - 4) = *(v9 - 3) * 2.0 - 1.0;
          }
          while ( v7 < *(_DWORD *)(v2 + 4184) );
        }
      }
      else if ( *(_DWORD *)(v2 + 4168) == 2 )
      {
        v3 = 0;
        if ( *(_DWORD *)(v2 + 4184) )
        {
          v4 = 0;
          v5 = (float *)((char *)this + 8);
          do
          {
            *(float *)(v4 + *(_DWORD *)(v2 + 4172)) = *(v5 - 2);
            ++v3;
            *(float *)(v4 + *(_DWORD *)(v2 + 4172) + 4) = *(v5 - 1);
            v4 += 16;
            *(float *)(v4 + *(_DWORD *)(v2 + 4172) - 8) = *v5;
            v6 = v5[1];
            v5 += 4;
            *(float *)(v4 + *(_DWORD *)(v2 + 4172) - 4) = v6 + v6 - 1.0;
          }
          while ( v3 < *(_DWORD *)(v2 + 4184) );
        }
      }
      break;
  }
  return *(float **)(v2 + 4172);
}

// nullsub_3 @ 0x10016C3B
void nullsub_3()
{
  ;
}

// FUN_10016c3c @ 0x10016C3C
// [binja] int32_t __fastcall sub_10016c3c(void*** arg1)
int FUN_10016c3c(void ***arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  unsigned int v3; // ebx
  unsigned int i; // edi
  int result; // eax
  void *v6; // [esp+0h] [ebp-18h]
  int v7; // [esp+8h] [ebp-10h]

  v2 = v1;
  *v1 = &off_1004CAF8;
  if ( v1[1071] )
  {
    if ( v1[1072] )
    {
      v3 = v1[1063];
      v7 = v1[1072];
      if ( v3 < v1[1064] )
      {
        do
        {
          for ( i = v2[1060]; i < v2[1062]; i += 4 )
          {
            operator delete(*(void **)(v7 + 4));
            v7 += 8;
          }
          ++v3;
        }
        while ( v3 < v2[1064] );
      }
    }
  }
  operator delete((void *)v2[1070]);
  operator delete((void *)v2[1072]);
  grim_vertex_space_converter_destroy(v6);
  return result;
}

// grim_pixel_format_write_dxt_cache @ 0x10016CDC
// writes RGBA floats into the DXT block cache and encodes when block data is complete
void grim_pixel_format_write_dxt_cache(void *this, uint x, uint y, float *pixels)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // ebx
  unsigned int v6; // esi
  void *v7; // edi
  unsigned int v8; // edi
  void *v9; // eax
  void *v10; // eax
  unsigned int v11; // ecx
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  unsigned int v15; // eax
  int v16; // edi
  unsigned int v17; // eax
  unsigned int v18; // edx
  int v19; // ecx
  _DWORD *v20; // edi
  _DWORD *v21; // esi
  int v22; // eax
  unsigned int v23; // eax
  int v24; // esi
  unsigned int v25; // eax
  _DWORD *v26; // edx
  int v27; // ecx
  int v28; // esi
  _DWORD *v29; // esi
  float *v30; // [esp+0h] [ebp-24h]
  int v31; // [esp+Ch] [ebp-18h]
  unsigned int v32; // [esp+Ch] [ebp-18h]
  unsigned int v33; // [esp+Ch] [ebp-18h]
  unsigned int i; // [esp+Ch] [ebp-18h]
  void *v35; // [esp+10h] [ebp-14h]
  char *v36; // [esp+10h] [ebp-14h]
  void *v37; // [esp+10h] [ebp-14h]
  unsigned int v38; // [esp+14h] [ebp-10h]
  char *thisa; // [esp+2Ch] [ebp+8h]
  _DWORD *thisb; // [esp+2Ch] [ebp+8h]
  uint xa; // [esp+30h] [ebp+Ch]
  uint xb; // [esp+30h] [ebp+Ch]
  uint ya; // [esp+34h] [ebp+10h]
  uint yb; // [esp+34h] [ebp+10h]

  v5 = v4;
  v6 = (unsigned int)this + v4[1037];
  xa = v4[1040] + x;
  thisa = (char *)v6;
  if ( !v4[1072] )
  {
    v7 = operator new(8 * v4[1067] * v4[1066]);
    v5[1072] = v7;
    if ( !v7 )
      return;
    memset(v7, 0, 8 * v5[1067] * v5[1066]);
  }
  v8 = v5[1072] + 8 * (((v6 - v5[1060]) >> 2) + v5[1066] * (xa - v5[1063]));
  v38 = v8;
  if ( !*(_DWORD *)(v8 + 4) )
  {
    v31 = 16 * v5[1065];
    v9 = operator new(v5[1065] << 8);
    v35 = v9;
    if ( v9 )
    {
      sub_1000B393((int)v9, 16, v31, (int (__thiscall *)(int))sub_1000AE4F);
      v10 = v35;
    }
    else
    {
      v10 = 0;
    }
    *(_DWORD *)(v8 + 4) = v10;
    if ( !v10 )
      return;
    *(_DWORD *)v8 = 0;
    ++v5[1071];
  }
  if ( !*(_DWORD *)v8 )
  {
    v11 = 4;
    if ( v5[1039] >= 4u )
      v11 = v5[1039];
    v12 = v6 & 3;
    if ( v12 < v5[1037] || v12 + 4 > v11 )
    {
      v15 = v5[1059];
      v16 = v5[6] + xa * v5[1045] + v5[1056] * (v15 >> 2) + v5[1044] * (v6 >> 2);
      v36 = *(char **)(v38 + 4);
      v33 = v15;
      while ( v15 < v5[1061] )
      {
        ((void (__cdecl *)(char *, int))v5[1057])(v36, v16);
        v16 += v5[1056];
        v36 += 256;
        v33 += 4;
        v15 = v33;
      }
      v8 = v38;
    }
    else
    {
      v32 = 4;
      if ( v5[1038] >= 4u )
        v32 = v5[1038];
      v13 = v5[1059];
      if ( v13 < v5[1036] )
        ((void (__cdecl *)(_DWORD, uint))v5[1057])(
          *(_DWORD *)(v8 + 4),
          v5[6] + xa * v5[1045] + v5[1044] * (v6 >> 2) + v5[1056] * (v13 >> 2));
      v14 = v5[1061];
      if ( v14 > v32 )
        ((void (__cdecl *)(_DWORD, uint))v5[1057])(
          *(_DWORD *)(v8 + 4),
          v5[6] + xa * v5[1045] + v5[1044] * (v6 >> 2) + v5[1056] * ((v14 - 4) >> 2));
    }
  }
  if ( v5[1042] )
    y = (uint)grim_convert_vertex_space((void *)y, v30);
  v17 = v5[1036] - v5[1059];
  v18 = v17 + v5[1046];
  v19 = (v6 - v5[1060]) & 3;
  if ( v17 < v18 )
  {
    do
    {
      v20 = (_DWORD *)(*(_DWORD *)(v38 + 4) + 16 * (v17 & 3 | (4 * (v19 | v17 & 0xFFFFFFFC))));
      v21 = (_DWORD *)y;
      y += 16;
      *v20 = *v21++;
      *++v20 = *v21++;
      *++v20 = *v21;
      ++v17;
      v20[1] = v21[1];
    }
    while ( v17 < v18 );
    v6 = (unsigned int)thisa;
    v8 = v38;
  }
  v22 = (v6 - v5[1060]) & 3;
  if ( v5[1053] )
  {
    for ( ya = 0; ya < 4; ++ya )
    {
      if ( (ya & v5[1055]) == v22 )
        *(_DWORD *)v8 |= 1 << ya;
    }
  }
  else
  {
    *(_DWORD *)v8 |= 1 << v22;
  }
  if ( *(_DWORD *)v8 == 15 )
  {
    v23 = v5[1059];
    v24 = v5[6] + xa * v5[1045] + v5[1056] * (v23 >> 2) + v5[1044] * (v6 >> 2);
    xb = *(_DWORD *)(v8 + 4);
    for ( i = v23; ; v23 = i )
    {
      v37 = (void *)v24;
      if ( v23 >= v5[1061] )
        break;
      v25 = 0;
      if ( v5[1053] )
      {
        v26 = (_DWORD *)xb;
        do
        {
          yb = 0;
          v27 = 4 * v25;
          thisb = v26;
          do
          {
            v28 = (v5[1054] & yb) + 4 * (v25 & v5[1055]);
            if ( v27 != v28 )
            {
              v29 = (_DWORD *)(xb + 16 * v28);
              *thisb = *v29++;
              thisb[1] = *v29++;
              thisb[2] = *v29;
              thisb[3] = v29[1];
              v8 = v38;
            }
            ++yb;
            thisb += 4;
            ++v27;
          }
          while ( yb < 4 );
          v26 = thisb;
          ++v25;
        }
        while ( v25 < 4 );
      }
      ((void (__cdecl *)(void *, uint))v5[1058])(v37, xb);
      v24 = (int)v37 + v5[1056];
      xb += 256;
      i += 4;
    }
    if ( v8 + 8 >= v5[1072] + 8 * v5[1066] * v5[1067] || *(_DWORD *)(v8 + 8) || *(_DWORD *)(v8 + 12) )
    {
      operator delete(*(void **)(v8 + 4));
      --v5[1071];
    }
    else
    {
      *(_DWORD *)(v8 + 12) = *(_DWORD *)(v8 + 4);
      *(_DWORD *)(v8 + 4) = 0;
    }
    *(_DWORD *)(v8 + 4) = 0;
  }
}

// fpu_set_round_trunc @ 0x100170D6
// sets x87 rounding mode to truncate; saves control word in DAT_1005db6c
void fpu_set_round_trunc()
{
  int v0; // [esp+0h] [ebp-8h]

  dword_1005DB6C = v0;
}

// grim_pixel_format_init @ 0x100170F9
// initializes format descriptor, bytes-per-pixel, palette expansion, and coordinate mode
void *grim_pixel_format_init(void *this, unsigned int *desc, unsigned int bits_per_pixel, unsigned int coord_mode)
{
  float *v4; // ecx
  float *v5; // ebx
  unsigned int v6; // esi
  void *v7; // ecx
  int v8; // ecx
  unsigned int v9; // ecx
  int v10; // ecx
  float *v11; // ecx
  float *v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // esi
  int v19; // ecx
  bool v20; // zf
  int v21; // eax
  float v23; // [esp+Ch] [ebp-10h]
  float v24; // [esp+10h] [ebp-Ch]
  float v25; // [esp+14h] [ebp-8h]
  float v26; // [esp+18h] [ebp-4h]
  unsigned int *desca; // [esp+28h] [ebp+Ch]

  v5 = v4;
  *(_DWORD *)v4 = &off_1004CAE4;
  sub_1000B393((int)(v4 + 12), 16, 256, (int (__thiscall *)(int))sub_1000AE4F);
  v5[6] = *(float *)this;
  v5[1] = *((float *)this + 1);
  v5[1044] = *((float *)this + 2);
  v5[1045] = *((float *)this + 3);
  qmemcpy(v5 + 1036, (char *)this + 40, 0x18u);
  v6 = 0;
  v7 = &unk_10054418;
  if ( !*((_DWORD *)this + 16) )
    v7 = &unk_10054398;
  *((_DWORD *)v5 + 11) = v7;
  *((_DWORD *)v5 + 1050) = (unsigned int)desc >> 3;
  v5[1042] = 0.0;
  v5[1043] = 0.0;
  *((_DWORD *)v5 + 3) = desc != 0;
  *((_DWORD *)v5 + 2) = bits_per_pixel;
  v8 = *((_DWORD *)this + 17);
  *((_DWORD *)v5 + 4) = v8;
  if ( v8 )
  {
    v9 = *((_DWORD *)this + 17);
    v23 = (double)BYTE2(v9) * 0.0039215689;
    v24 = (double)BYTE1(v9) * 0.0039215689;
    v25 = (double)(unsigned __int8)v9 * 0.0039215689;
    v26 = (double)HIBYTE(v9) * 0.0039215689;
    v5[7] = v23;
    v5[8] = v24;
    v5[9] = v25;
    v5[10] = v26;
    v6 = 0;
  }
  v10 = *((_DWORD *)v5 + 1);
  if ( v10 == 41 || v10 == 40 )
  {
    *((_DWORD *)v5 + 5) = 1;
    if ( *((_DWORD *)this + 18) )
    {
      v11 = v5 + 13;
      do
      {
        desca = (unsigned int *)*(unsigned __int8 *)(v6 + *((_DWORD *)this + 18));
        v6 += 4;
        *(v11 - 1) = (double)(int)desca * 0.0039215689;
        *v11 = (double)*(unsigned __int8 *)(v6 + *((_DWORD *)this + 18) - 3) * 0.0039215689;
        v11 += 4;
        *(v11 - 3) = (double)*(unsigned __int8 *)(v6 + *((_DWORD *)this + 18) - 2) * 0.0039215689;
        *(v11 - 2) = (double)*(unsigned __int8 *)(v6 + *((_DWORD *)this + 18) - 1) * 0.0039215689;
      }
      while ( v6 < 0x400 );
    }
    else
    {
      v12 = v5 + 14;
      v13 = 256;
      do
      {
        v12[1] = 1.0;
        *v12 = 1.0;
        v12 += 4;
        --v13;
        *(v12 - 5) = 1.0;
        *(v12 - 6) = 1.0;
      }
      while ( v13 );
    }
  }
  else
  {
    v5[5] = 0.0;
  }
  v14 = *((_DWORD *)v5 + 1038);
  v15 = *((_DWORD *)v5 + 1040);
  *((_DWORD *)v5 + 1047) = *((_DWORD *)v5 + 1039) - *((_DWORD *)v5 + 1037);
  v16 = *((_DWORD *)v5 + 1041) - v15;
  v17 = *((_DWORD *)v5 + 1050);
  v18 = *((_DWORD *)v5 + 1036);
  v19 = v14 - v18;
  *((_DWORD *)v5 + 1048) = v16;
  *((_DWORD *)v5 + 1046) = v19;
  v20 = *((_DWORD *)v5 + 3) == 0;
  *((_DWORD *)v5 + 1049) = v19 * v17;
  if ( !v20 )
  {
    *((_DWORD *)v5 + 6) += *((_DWORD *)v5 + 1040) * *((_DWORD *)v5 + 1045)
                         + *((_DWORD *)v5 + 1037) * *((_DWORD *)v5 + 1044)
                         + v18 * v17;
    v5[1038] = v5[1046];
    v5[1039] = v5[1047];
    v21 = *((_DWORD *)v5 + 1048);
    v5[1036] = 0.0;
    v5[1037] = 0.0;
    v5[1040] = 0.0;
    *((_DWORD *)v5 + 1041) = v21;
  }
  return v5;
}

// FUN_10017345 @ 0x10017345
// [binja] void*** __thiscall sub_10017345(void*** arg1, char arg2)
void ***FUN_10017345(void ***arg1, char arg2)
{
  void *v2; // ecx
  void *v3; // esi
  void *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_vertex_space_converter_destroy(v5);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return (void ***)v3;
}

// FUN_10017361 @ 0x10017361
// [binja] int32_t __thiscall sub_10017361(void* arg1, void* arg2)
int FUN_10017361(void *arg1, void *arg2)
{
  int v2; // ecx
  int v3; // esi
  int v4; // edi
  void *v5; // ebx
  void *v6; // eax

  v3 = v2;
  if ( *(_DWORD *)(v2 + 8) != *((_DWORD *)arg1 + 2) )
  {
    v4 = *(_DWORD *)(v2 + 4184);
    v5 = operator new(16 * v4);
    v6 = 0;
    if ( v5 )
    {
      sub_1000B393((int)v5, 16, v4, (int (__thiscall *)(int))sub_1000AE4F);
      v6 = v5;
    }
    *(_DWORD *)(v3 + 4172) = v6;
    if ( !v6 )
      return -2147024882;
    *(_DWORD *)(v3 + 4168) = *((_DWORD *)arg1 + 2);
  }
  return 0;
}

// FUN_100173dc @ 0x100173DC
// [binja] int32_t __fastcall sub_100173dc(int32_t* arg1)
int FUN_100173dc(int *arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // ecx
  bool v5; // zf
  int v6; // ecx
  int result; // eax
  float *v8; // [esp+0h] [ebp-30h]
  char v9; // [esp+Ch] [ebp-24h] BYREF
  int v10; // [esp+14h] [ebp-1Ch]
  int v11; // [esp+18h] [ebp-18h]
  int v12; // [esp+1Ch] [ebp-14h]
  int v13; // [esp+20h] [ebp-10h]
  int v14; // [esp+24h] [ebp-Ch]
  int v15; // [esp+28h] [ebp-8h]
  int v16; // [esp+2Ch] [ebp-4h]

  v2 = v1;
  v3 = v1[1046];
  v4 = v1[1050];
  v14 = v3;
  v13 = v2[1049];
  v12 = v2[6];
  v11 = v2[11];
  v10 = v2[4];
  v2[1049] = v4;
  v5 = v2[2] == 1;
  v2[1046] = 1;
  v2[6] = &v9;
  v2[11] = &unk_10054398;
  v2[4] = 0;
  if ( !v5 )
  {
    v16 = v2[1042];
    v6 = v2[1043];
    v2[1042] = 1;
    v15 = v6;
    v2[1043] = v2 + 7;
    grim_convert_vertex_space(v2 + 7, v8);
    v2[1042] = v16;
    v2[1043] = v15;
  }
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD *))(*v2 + 8))(v2, 0, 0, v2 + 7);
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD *))(*v2 + 4))(v2, 0, 0, v2 + 7);
  v2[1046] = v14;
  v2[1049] = v13;
  v2[6] = v12;
  v2[11] = v11;
  result = v10;
  v2[4] = v10;
  return result;
}

// grim_apply_color_key @ 0x100174A8
// zeroes RGBA pixels that match the current color key
void grim_apply_color_key(float *pixels)
{
  int v1; // ecx
  float *v2; // edx
  unsigned int v3; // esi

  if ( pixels < &pixels[4 * *(_DWORD *)(v1 + 4184)] )
  {
    v2 = pixels + 2;
    v3 = ((unsigned int)(16 * *(_DWORD *)(v1 + 4184) - 1) >> 4) + 1;
    do
    {
      if ( *(v2 - 2) == *(float *)(v1 + 28)
        && *(v2 - 1) == *(float *)(v1 + 32)
        && *v2 == *(float *)(v1 + 36)
        && v2[1] == *(float *)(v1 + 40) )
      {
        v2[1] = 0.0;
        *v2 = 0.0;
        *(v2 - 1) = 0.0;
        *(v2 - 2) = 0.0;
      }
      v2 += 4;
      --v3;
    }
    while ( v3 );
  }
}

// FUN_10017518 @ 0x10017518
// [binja] int16_t __thiscall sub_10017518(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017518(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _BYTE *v7; // edx
  int v8; // eax
  unsigned int i; // esi
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+Ch] [ebp-Ch]
  float v13; // [esp+Ch] [ebp-Ch]
  float v14; // [esp+Ch] [ebp-Ch]
  float v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]

  v16 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v16;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  for ( i = 0; i < *(_DWORD *)(v16 + 4184); v8 += 16 )
  {
    v15 = *(float *)(v6 + 4 * (i & 3));
    v12 = *(float *)(v8 + arg3 + 8) * 255.0 + v15;
    *v7 = (int)v12;
    v13 = *(float *)(v8 + arg3 + 4) * 255.0 + v15;
    v7[1] = (int)v13;
    v14 = *(float *)(v8 + arg3) * 255.0 + v15;
    v7[2] = (int)v14;
    v7 += 3;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10017604 @ 0x10017604
// [binja] int16_t __thiscall sub_10017604(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017604(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  int *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // ebx
  float *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+18h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v20;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v9 = 0;
    do
    {
      v19 = *(float *)(v6 + 4 * (v8 & 3));
      v15 = *(float *)(v9 + arg3) * 255.0 + v19;
      v10 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 4) * 255.0 + v19;
      v14 = (int)v16;
      v17 = *(float *)(v9 + arg3 + 8) * 255.0 + v19;
      v13 = (int)v17;
      v18 = *(float *)(v9 + arg3 + 12) * 255.0 + v19;
      v9 += 16;
      *v7++ = v13 | ((v14 | ((v10 | ((int)v18 << 8)) << 8)) << 8);
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017727 @ 0x10017727
// [binja] int16_t __thiscall sub_10017727(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017727(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  int *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // eax
  float *v12; // [esp+0h] [ebp-1Ch]
  int v13; // [esp+0h] [ebp-1Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+10h] [ebp-Ch]
  float v16; // [esp+10h] [ebp-Ch]
  float v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v9 = 0;
    do
    {
      v17 = *(float *)(v6 + 4 * (v8 & 3));
      v14 = *(float *)(v9 + arg3) * 255.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v9 + arg3 + 4) * 255.0 + v17;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 8) * 255.0 + v17;
      v9 += 16;
      *v7++ = (int)v16 | ((v13 | (v10 << 8)) << 8);
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017828 @ 0x10017828
// [binja] int16_t __thiscall sub_10017828(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017828(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  __int16 v10; // ax
  float *v12; // [esp+0h] [ebp-1Ch]
  int v13; // [esp+0h] [ebp-1Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+10h] [ebp-Ch]
  float v16; // [esp+10h] [ebp-Ch]
  float v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v9 = 0;
    do
    {
      v17 = *(float *)(v6 + 4 * (v8 & 3));
      v14 = *(float *)(v9 + arg3) * 31.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v9 + arg3 + 4) * 63.0 + v17;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 8) * 31.0 + v17;
      v9 += 16;
      *v7++ = (int)v16 | (32 * (v13 | (v10 << 6)));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017929 @ 0x10017929
// [binja] int16_t __thiscall sub_10017929(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017929(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  __int16 v10; // ax
  float *v12; // [esp+0h] [ebp-1Ch]
  int v13; // [esp+0h] [ebp-1Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+10h] [ebp-Ch]
  float v16; // [esp+10h] [ebp-Ch]
  float v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v9 = 0;
    do
    {
      v17 = *(float *)(v6 + 4 * (v8 & 3));
      v14 = *(float *)(v9 + arg3) * 31.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v9 + arg3 + 4) * 31.0 + v17;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 8) * 31.0 + v17;
      v9 += 16;
      *v7++ = (int)v16 | (32 * (v13 | (32 * v10)));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017a2a @ 0x10017A2A
// [binja] int16_t __thiscall sub_10017a2a(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017a2a(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // ebx
  float *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+18h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v20;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v9 = 0;
    do
    {
      v19 = *(float *)(v6 + 4 * (v8 & 3));
      v15 = *(float *)(v9 + arg3) * 31.0 + v19;
      v10 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 4) * 31.0 + v19;
      v14 = (int)v16;
      v17 = *(float *)(v9 + arg3 + 8) * 31.0 + v19;
      v13 = (int)v17;
      v18 = v19 + *(float *)(v9 + arg3 + 12);
      v9 += 16;
      *v7++ = v13 | (32 * (v14 | (32 * (v10 | (32 * (int)v18)))));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017b47 @ 0x10017B47
// [binja] int16_t __thiscall sub_10017b47(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017b47(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // ebx
  float *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+18h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v20;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v9 = 0;
    do
    {
      v19 = *(float *)(v6 + 4 * (v8 & 3));
      v15 = *(float *)(v9 + arg3) * 15.0 + v19;
      v10 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 4) * 15.0 + v19;
      v14 = (int)v16;
      v17 = *(float *)(v9 + arg3 + 8) * 15.0 + v19;
      v13 = (int)v17;
      v18 = *(float *)(v9 + arg3 + 12) * 15.0 + v19;
      v9 += 16;
      *v7++ = v13 | (16 * (v14 | (16 * (v10 | (16 * (int)v18)))));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017c6a @ 0x10017C6A
// [binja] int16_t __thiscall sub_10017c6a(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017c6a(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // edi
  float *v6; // eax
  int v7; // ebx
  _BYTE *v8; // edx
  int v9; // esi
  char v10; // al
  float *v12; // [esp+0h] [ebp-28h]
  int v13; // [esp+Ch] [ebp-1Ch]
  float v14; // [esp+1Ch] [ebp-Ch]
  float v15; // [esp+1Ch] [ebp-Ch]
  float v16; // [esp+1Ch] [ebp-Ch]
  float v17; // [esp+20h] [ebp-8h]
  int v18; // [esp+24h] [ebp-4h]

  v5 = 0;
  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v9 = 0;
    do
    {
      v17 = *(float *)(v7 + 4 * (v5 & 3));
      v14 = *(float *)(v9 + arg3) * 7.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v9 + arg3 + 4) * 7.0 + v17;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 8) * 3.0 + v17;
      v9 += 16;
      *v8++ = (int)v16 | (4 * (v13 | (8 * v10)));
      ++v5;
    }
    while ( v5 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017d68 @ 0x10017D68
// [binja] int16_t __thiscall sub_10017d68(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017d68(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  int v5; // edi
  float *v6; // eax
  int v7; // esi
  _BYTE *v8; // edx
  unsigned int i; // ecx
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]

  v5 = 0;
  v13 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v13;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < *(_DWORD *)(v13 + 4184); v5 += 16 )
  {
    v12 = *(float *)(v7 + 4 * (i & 3)) + *(float *)(v5 + arg3 + 12) * 255.0;
    *v8++ = (int)v12;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10017e11 @ 0x10017E11
// [binja] int16_t __thiscall sub_10017e11(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017e11(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // eax
  int v10; // ebx
  float *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+18h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v20;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v9 = 0;
    do
    {
      v19 = *(float *)(v6 + 4 * (v8 & 3));
      v15 = *(float *)(v9 + arg3) * 7.0 + v19;
      v10 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 4) * 7.0 + v19;
      v14 = (int)v16;
      v17 = *(float *)(v9 + arg3 + 8) * 3.0 + v19;
      v13 = (int)v17;
      v18 = *(float *)(v9 + arg3 + 12) * 255.0 + v19;
      v9 += 16;
      *v7++ = v13 | (4 * (v14 | (8 * (v10 | (8 * (int)v18)))));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10017f34 @ 0x10017F34
// [binja] int16_t __thiscall sub_10017f34(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10017f34(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  __int16 v10; // ax
  float *v12; // [esp+0h] [ebp-1Ch]
  int v13; // [esp+0h] [ebp-1Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+10h] [ebp-Ch]
  float v16; // [esp+10h] [ebp-Ch]
  float v17; // [esp+14h] [ebp-8h]
  int v18; // [esp+18h] [ebp-4h]

  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v9 = 0;
    do
    {
      v17 = *(float *)(v6 + 4 * (v8 & 3));
      v14 = *(float *)(v9 + arg3) * 15.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v9 + arg3 + 4) * 15.0 + v17;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 8) * 15.0 + v17;
      v9 += 16;
      *v7++ = (int)v16 | (16 * (v13 | (16 * v10)));
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018035 @ 0x10018035
// [binja] int16_t __thiscall sub_10018035(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018035(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  int *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  int v10; // ebx
  float *v12; // [esp+0h] [ebp-24h]
  int v13; // [esp+0h] [ebp-24h]
  int v14; // [esp+4h] [ebp-20h]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+18h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-Ch]
  float v19; // [esp+1Ch] [ebp-8h]
  int v20; // [esp+20h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v20;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v9 = 0;
    do
    {
      v19 = *(float *)(v6 + 4 * (v8 & 3));
      v15 = *(float *)(v9 + arg3) * 1023.0 + v19;
      v13 = (int)v15;
      v16 = *(float *)(v9 + arg3 + 4) * 1023.0 + v19;
      v14 = (int)v16;
      v17 = *(float *)(v9 + arg3 + 8) * 1023.0 + v19;
      v10 = (int)v17;
      v18 = *(float *)(v9 + arg3 + 12) * 3.0 + v19;
      v9 += 16;
      *v7++ = v13 | ((v14 | ((v10 | ((int)v18 << 10)) << 10)) << 10);
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018158 @ 0x10018158
// [binja] int16_t __thiscall sub_10018158(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018158(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // edi
  float *v6; // eax
  int v7; // esi
  int *v8; // edx
  int v9; // ecx
  float *v11; // [esp+0h] [ebp-20h]
  float v12; // [esp+10h] [ebp-10h]
  float v13; // [esp+18h] [ebp-8h]
  int v14; // [esp+1Ch] [ebp-4h]

  v5 = 0;
  v14 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v14;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v14 + 4184) )
  {
    v9 = 0;
    do
    {
      v13 = *(float *)(v9 + arg3) * 65535.0 + *(float *)(v7 + 4 * (v5 & 3));
      v12 = *(float *)(v9 + arg3 + 4) * 65535.0 + *(float *)(v7 + 4 * (v5 & 3));
      *v8++ = (int)v13 | ((int)v12 << 16);
      ++v5;
      v9 += 16;
    }
    while ( v5 < *(_DWORD *)(v14 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018228 @ 0x10018228
// [binja] int16_t __thiscall sub_10018228(void* arg1, int32_t arg2, int32_t arg3, float* arg4)
__int16 FUN_10018228(void *arg1, int arg2, int arg3, float *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // ebx
  _WORD *v7; // edx
  int v8; // eax
  unsigned int v9; // esi
  int v10; // ecx
  unsigned __int8 v12; // c0
  unsigned __int8 v13; // c2
  __int16 v14; // cx
  float *v16; // [esp+0h] [ebp-20h]
  __int16 v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  unsigned int v19; // [esp+18h] [ebp-8h]
  float v20; // [esp+18h] [ebp-8h]
  int v21; // [esp+1Ch] [ebp-4h]

  v21 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v16);
    v4 = v21;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = v21;
  v9 = 0;
  if ( *(_DWORD *)(v21 + 4184) )
  {
    v18 = 0;
    do
    {
      v17 = 0;
      v19 = 0;
      v10 = v8 + 56;
      do
      {
        if ( v12 | v13 )
          v17 = v19;
        ++v19;
        v10 += 16;
      }
      while ( v19 < 0x100 );
      v20 = *(float *)(v18 + arg3 + 12) * 255.0 + *(float *)(v6 + 4 * (v9 & 3));
      v18 += 16;
      LOBYTE(v14) = 0;
      HIBYTE(v14) = (int)v20;
      *v7 = v17 | v14;
      v8 = v21;
      ++v7;
      ++v9;
    }
    while ( v9 < *(_DWORD *)(v21 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018340 @ 0x10018340
// [binja] void* __thiscall sub_10018340(void* arg1, void* arg2, float arg3, void* arg4)
void *FUN_10018340(void *arg1, void *arg2, float arg3, void *arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  _BYTE *v6; // edx
  float *v7; // esi
  char v8; // bl
  float *v9; // edi
  double v10; // st6
  double v11; // st5
  double v12; // st4
  double v13; // st2
  double v14; // st3
  float *v15; // [esp+0h] [ebp-8h]
  char *arg1a; // [esp+10h] [ebp+8h]
  float arg2a; // [esp+14h] [ebp+Ch]
  unsigned int arg3a; // [esp+18h] [ebp+10h]

  if ( v4[1042] )
    result = grim_convert_vertex_space((void *)LODWORD(arg3), v15);
  else
    result = (void *)LODWORD(arg3);
  v6 = (_BYTE *)(v4[6] + (_DWORD)arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  arg1a = 0;
  if ( v4[1046] )
  {
    v7 = (float *)((char *)result + 8);
    do
    {
      v8 = 0;
      arg2a = 3.4028235e38;
      arg3a = 0;
      v9 = (float *)(v4 + 14);
      do
      {
        v10 = *(v7 - 1) - *(v9 - 1);
        v11 = *v7 - *v9;
        v12 = v7[1] - v9[1];
        v13 = *(v7 - 2) - *(v9 - 2);
        v14 = v12 * v12 + v11 * v11 + v10 * v10 + v13 * v13;
        if ( v14 < arg2a )
        {
          v8 = arg3a;
          arg2a = v14;
        }
        ++arg3a;
        v9 += 4;
      }
      while ( arg3a < 0x100 );
      *v6++ = v8;
      result = ++arg1a;
      v7 += 4;
    }
    while ( (unsigned int)arg1a < v4[1046] );
  }
  return result;
}

// FUN_10018405 @ 0x10018405
// [binja] int16_t __thiscall sub_10018405(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018405(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  int v5; // edi
  float *v6; // eax
  int v7; // esi
  _BYTE *v8; // edx
  unsigned int i; // ecx
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]

  v5 = 0;
  v13 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v13;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < *(_DWORD *)(v13 + 4184); v5 += 16 )
  {
    v12 = (*(float *)(v5 + arg3 + 8) * 0.072099999
         + *(float *)(v5 + arg3 + 4) * 0.71539998
         + *(float *)(v5 + arg3) * 0.21250001)
        * 255.0
        + *(float *)(v7 + 4 * (i & 3));
    *v8++ = (int)v12;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_100184ca @ 0x100184CA
// [binja] int16_t __thiscall sub_100184ca(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_100184ca(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // edi
  float *v6; // eax
  int v7; // ebx
  _WORD *v8; // edx
  int v9; // esi
  __int16 v10; // cx
  float *v12; // [esp+0h] [ebp-20h]
  float v13; // [esp+10h] [ebp-10h]
  float v14; // [esp+18h] [ebp-8h]
  int v15; // [esp+1Ch] [ebp-4h]

  v5 = 0;
  v15 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v15;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v15 + 4184) )
  {
    v9 = 0;
    do
    {
      v14 = (*(float *)(v9 + arg3 + 8) * 0.072099999
           + *(float *)(v9 + arg3 + 4) * 0.71539998
           + *(float *)(v9 + arg3) * 0.21250001)
          * 255.0
          + *(float *)(v7 + 4 * (v5 & 3));
      v13 = *(float *)(v9 + arg3 + 12) * 255.0 + *(float *)(v7 + 4 * (v5 & 3));
      LOBYTE(v10) = 0;
      HIBYTE(v10) = (int)v13;
      v9 += 16;
      *v8++ = (int)v14 | v10;
      ++v5;
    }
    while ( v5 < *(_DWORD *)(v15 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_100185c0 @ 0x100185C0
// [binja] int16_t __thiscall sub_100185c0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_100185c0(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // edi
  float *v6; // eax
  int v7; // ebx
  _BYTE *v8; // edx
  int v9; // esi
  float *v11; // [esp+0h] [ebp-20h]
  float v12; // [esp+10h] [ebp-10h]
  float v13; // [esp+18h] [ebp-8h]
  int v14; // [esp+1Ch] [ebp-4h]

  v5 = 0;
  v14 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v14;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v14 + 4184) )
  {
    v9 = 0;
    do
    {
      v13 = (*(float *)(v9 + arg3 + 8) * 0.072099999
           + *(float *)(v9 + arg3 + 4) * 0.71539998
           + *(float *)(v9 + arg3) * 0.21250001)
          * 15.0
          + *(float *)(v7 + 4 * (v5 & 3));
      v12 = *(float *)(v9 + arg3 + 12) * 15.0 + *(float *)(v7 + 4 * (v5 & 3));
      *v8++ = (int)v13 | (16 * (int)v12);
      ++v5;
      v9 += 16;
    }
    while ( v5 < *(_DWORD *)(v14 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_100186ab @ 0x100186AB
// [binja] int16_t __thiscall sub_100186ab(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_100186ab(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // eax
  int v9; // esi
  __int16 v10; // cx
  float *v12; // [esp+0h] [ebp-14h]
  float v13; // [esp+4h] [ebp-10h]
  float v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v15 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v15;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v15 + 4184) )
  {
    v9 = 0;
    do
    {
      v14 = *(float *)(v9 + arg3) * 128.0 + *(float *)(v6 + 4 * (v8 & 3));
      LOBYTE(v10) = (int)v14;
      v13 = *(float *)(v9 + arg3 + 4) * 128.0 + *(float *)(v6 + 4 * (v8 & 3));
      v9 += 16;
      HIBYTE(v10) = (int)v13;
      *v7++ = v10;
      ++v8;
    }
    while ( v8 < *(_DWORD *)(v15 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018780 @ 0x10018780
// [binja] int16_t __thiscall sub_10018780(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018780(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // ebx
  float *v6; // eax
  _WORD *v7; // edx
  int v8; // esi
  char v9; // cl
  char v10; // al
  float *v12; // [esp+0h] [ebp-28h]
  float v13; // [esp+18h] [ebp-10h]
  float v14; // [esp+18h] [ebp-10h]
  float v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  float v17; // [esp+20h] [ebp-8h]
  int v18; // [esp+24h] [ebp-4h]

  v5 = 0;
  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v6;
  }
  v16 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v16 + 4 * (v5 & 3));
      v13 = *(float *)(v8 + arg3) * 16.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + arg3 + 4) * 16.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v8 + arg3 + 12) * 63.0 + v17;
      *v7++ = v9 & 0x1F | (32 * ((32 * (int)v15) | v10 & 0x1F));
      ++v5;
      v8 += 16;
    }
    while ( v5 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018885 @ 0x10018885
// [binja] int16_t __thiscall sub_10018885(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018885(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int *v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  unsigned __int8 v9; // di
  unsigned __int16 v10; // bx
  float *v12; // [esp+0h] [ebp-20h]
  int v13; // [esp+0h] [ebp-20h]
  float v14; // [esp+10h] [ebp-10h]
  float v15; // [esp+10h] [ebp-10h]
  float v16; // [esp+10h] [ebp-10h]
  int v17; // [esp+14h] [ebp-Ch]
  float v18; // [esp+18h] [ebp-8h]
  int v19; // [esp+1Ch] [ebp-4h]

  v19 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v19;
    arg3 = (int)v5;
  }
  v17 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( *(_DWORD *)(v19 + 4184) )
  {
    v8 = 0;
    do
    {
      v18 = *(float *)(v17 + 4 * (v7 & 3));
      v14 = *(float *)(v8 + arg3) * 128.0 + v18;
      v9 = (int)v14;
      v15 = *(float *)(v8 + arg3 + 4) * 128.0 + v18;
      v13 = (int)v15;
      v16 = *(float *)(v8 + arg3 + 12) * 255.0 + v18;
      HIBYTE(v10) = (int)v16;
      v8 += 16;
      LOBYTE(v10) = v13;
      *v6++ = v9 | (v10 << 8);
      ++v7;
    }
    while ( v7 < *(_DWORD *)(v19 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018990 @ 0x10018990
// [binja] int16_t __thiscall sub_10018990(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018990(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int *v6; // edx
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  float *v11; // [esp+0h] [ebp-34h]
  int v12; // [esp+Ch] [ebp-28h]
  float v13; // [esp+20h] [ebp-14h]
  float v14; // [esp+20h] [ebp-14h]
  float v15; // [esp+20h] [ebp-14h]
  float v16; // [esp+20h] [ebp-14h]
  int v17; // [esp+24h] [ebp-10h]
  float v18; // [esp+28h] [ebp-Ch]
  unsigned int v19; // [esp+2Ch] [ebp-8h]
  int v20; // [esp+30h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v20;
    arg3 = (int)v5;
  }
  v17 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v19 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v7 = 0;
    do
    {
      v18 = *(float *)(v17 + 4 * (v19 & 3));
      v13 = *(float *)(v7 + arg3) * 128.0 + v18;
      v8 = (int)v13;
      v14 = *(float *)(v7 + arg3 + 4) * 128.0 + v18;
      v12 = (int)v14;
      v15 = *(float *)(v7 + arg3 + 8) * 128.0 + v18;
      v9 = (int)v15;
      v16 = *(float *)(v7 + arg3 + 12) * 128.0 + v18;
      *v6++ = (unsigned __int8)v8 | (((unsigned __int8)v12 | ((((int)v16 << 8) | (unsigned __int8)v9) << 8)) << 8);
      ++v19;
      v7 += 16;
    }
    while ( v19 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018aca @ 0x10018ACA
// [binja] int16_t __thiscall sub_10018aca(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018aca(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // ebx
  float *v6; // eax
  int v7; // edi
  int *v8; // edx
  int v9; // esi
  float *v11; // [esp+0h] [ebp-20h]
  float v12; // [esp+10h] [ebp-10h]
  float v13; // [esp+18h] [ebp-8h]
  int v14; // [esp+1Ch] [ebp-4h]

  v5 = 0;
  v14 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v14;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v14 + 4184) )
  {
    v9 = 0;
    do
    {
      v13 = *(float *)(v9 + arg3) * 32768.0 + *(float *)(v7 + 4 * (v5 & 3));
      v12 = *(float *)(v9 + arg3 + 4) * 32768.0 + *(float *)(v7 + 4 * (v5 & 3));
      *v8++ = (unsigned __int16)(int)v13 | ((int)v12 << 16);
      ++v5;
      v9 += 16;
    }
    while ( v5 < *(_DWORD *)(v14 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018ba0 @ 0x10018BA0
// [binja] int16_t __thiscall sub_10018ba0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018ba0(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  unsigned int v5; // ebx
  float *v6; // eax
  int *v7; // edx
  int v8; // ecx
  __int16 v9; // si
  __int16 v10; // ax
  float *v12; // [esp+0h] [ebp-28h]
  float v13; // [esp+18h] [ebp-10h]
  float v14; // [esp+18h] [ebp-10h]
  float v15; // [esp+18h] [ebp-10h]
  int v16; // [esp+1Ch] [ebp-Ch]
  float v17; // [esp+20h] [ebp-8h]
  int v18; // [esp+24h] [ebp-4h]

  v5 = 0;
  v18 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v12);
    v4 = v18;
    arg3 = (int)v6;
  }
  v16 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  if ( *(_DWORD *)(v18 + 4184) )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v16 + 4 * (v5 & 3));
      v13 = *(float *)(v8 + arg3) * 512.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + arg3 + 4) * 1024.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v8 + arg3 + 8) * 1024.0 + v17;
      *v7++ = v9 & 0x3FF | ((((int)v15 << 11) | v10 & 0x7FF) << 10);
      ++v5;
      v8 += 16;
    }
    while ( v5 < *(_DWORD *)(v18 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018caa @ 0x10018CAA
// [binja] int16_t __thiscall sub_10018caa(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018caa(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int *v6; // edx
  int v7; // ecx
  int v8; // edi
  int v9; // eax
  float *v11; // [esp+0h] [ebp-34h]
  int v12; // [esp+Ch] [ebp-28h]
  float v13; // [esp+20h] [ebp-14h]
  float v14; // [esp+20h] [ebp-14h]
  float v15; // [esp+20h] [ebp-14h]
  float v16; // [esp+20h] [ebp-14h]
  int v17; // [esp+24h] [ebp-10h]
  float v18; // [esp+28h] [ebp-Ch]
  unsigned int v19; // [esp+2Ch] [ebp-8h]
  int v20; // [esp+30h] [ebp-4h]

  v20 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v20;
    arg3 = (int)v5;
  }
  v17 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v19 = 0;
  if ( *(_DWORD *)(v20 + 4184) )
  {
    v7 = 0;
    do
    {
      v18 = *(float *)(v17 + 4 * (v19 & 3));
      v13 = *(float *)(v7 + arg3) * 512.0 + v18;
      v8 = (int)v13;
      v14 = *(float *)(v7 + arg3 + 4) * 512.0 + v18;
      v12 = (int)v14;
      v15 = *(float *)(v7 + arg3 + 8) * 512.0 + v18;
      v9 = (int)v15;
      v16 = *(float *)(v7 + arg3 + 12) + *(float *)(v7 + arg3 + 12) + v18;
      *v6++ = v8 & 0x3FF | ((v12 & 0x3FF | ((((int)v16 << 10) | v9 & 0x3FF) << 10)) << 10);
      ++v19;
      v7 += 16;
    }
    while ( v19 < *(_DWORD *)(v20 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_10018de0 @ 0x10018DE0
// [binja] int16_t __thiscall sub_10018de0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018de0(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  int v5; // edi
  float *v6; // eax
  int v7; // esi
  _WORD *v8; // edx
  unsigned int i; // ecx
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]

  v5 = 0;
  v13 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v13;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < *(_DWORD *)(v13 + 4184); v5 += 16 )
  {
    v12 = (*(float *)(v5 + arg3 + 8) * 0.072099999
         + *(float *)(v5 + arg3 + 4) * 0.71539998
         + *(float *)(v5 + arg3) * 0.21250001)
        * 65535.0
        + *(float *)(v7 + 4 * (i & 3));
    *v8++ = (int)v12;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10018ea7 @ 0x10018EA7
// [binja] int16_t __thiscall sub_10018ea7(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018ea7(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  int v5; // edi
  float *v6; // eax
  int v7; // esi
  _WORD *v8; // edx
  unsigned int i; // ecx
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+10h] [ebp-8h]
  int v13; // [esp+14h] [ebp-4h]

  v5 = 0;
  v13 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v6 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v13;
    arg3 = (int)v6;
  }
  v7 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < *(_DWORD *)(v13 + 4184); v5 += 16 )
  {
    v12 = (*(float *)(v5 + arg3 + 8) * 0.072099999
         + *(float *)(v5 + arg3 + 4) * 0.71539998
         + *(float *)(v5 + arg3) * 0.21250001)
        * 65535.0
        + *(float *)(v7 + 4 * (i & 3));
    *v8++ = (int)v12;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10018f6e @ 0x10018F6E
// [binja] int16_t __thiscall sub_10018f6e(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_10018f6e(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  int *v7; // edx
  unsigned int v8; // esi
  int v9; // ecx
  float *v11; // [esp+0h] [ebp-14h]
  float v12; // [esp+4h] [ebp-10h]
  float v13; // [esp+Ch] [ebp-8h]
  int v14; // [esp+10h] [ebp-4h]

  v14 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v14;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v14 + 4184) )
  {
    v9 = 0;
    do
    {
      v13 = (*(float *)(v9 + arg3 + 8) * 0.072099999
           + *(float *)(v9 + arg3 + 4) * 0.71539998
           + *(float *)(v9 + arg3) * 0.21250001)
          * 65535.0
          + *(float *)(v6 + 4 * (v8 & 3));
      v12 = *(float *)(v9 + arg3 + 12) * 65535.0 + *(float *)(v6 + 4 * (v8 & 3));
      *v7++ = (int)v13 | ((int)v12 << 16);
      ++v8;
      v9 += 16;
    }
    while ( v8 < *(_DWORD *)(v14 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_1001905c @ 0x1001905C
// [binja] int16_t __thiscall sub_1001905c(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_1001905c(void *arg1, int arg2, int arg3, void *arg4)
{
  int v4; // ecx
  float *v5; // eax
  int v6; // edi
  _WORD *v7; // edx
  unsigned int v8; // esi
  int v9; // eax
  float *v11; // [esp+0h] [ebp-18h]
  float v12; // [esp+Ch] [ebp-Ch]
  float v13; // [esp+Ch] [ebp-Ch]
  float v14; // [esp+Ch] [ebp-Ch]
  float v15; // [esp+10h] [ebp-8h]
  int v16; // [esp+14h] [ebp-4h]

  v16 = v4;
  if ( *(_DWORD *)(v4 + 4168) )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v16;
    arg3 = (int)v5;
  }
  v6 = *(_DWORD *)(v4 + 44) + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v8 = 0;
  if ( *(_DWORD *)(v16 + 4184) )
  {
    v9 = 0;
    do
    {
      v15 = *(float *)(v6 + 4 * (v8 & 3));
      v12 = *(float *)(v9 + arg3 + 8) * 65535.0 + v15;
      *v7 = (int)v12;
      v13 = *(float *)(v9 + arg3 + 4) * 65535.0 + v15;
      v7[1] = (int)v13;
      v14 = *(float *)(v9 + arg3) * 65535.0 + v15;
      v7[2] = (int)v14;
      v7 += 3;
      ++v8;
      v9 += 16;
    }
    while ( v8 < *(_DWORD *)(v16 + 4184) );
  }
  return dword_1005DB6C;
}

// FUN_1001914b @ 0x1001914B
// [binja] int16_t __thiscall sub_1001914b(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
__int16 FUN_1001914b(void *arg1, int arg2, int arg3, void *arg4)
{
  _DWORD *v4; // ecx
  float *v5; // eax
  _QWORD *v6; // esi
  int v7; // ecx
  int v8; // edi
  unsigned __int64 v9; // rt0
  float *v11; // [esp+0h] [ebp-38h]
  int v12; // [esp+Ch] [ebp-2Ch]
  int v13; // [esp+10h] [ebp-28h]
  float v14; // [esp+24h] [ebp-14h]
  float v15; // [esp+24h] [ebp-14h]
  float v16; // [esp+24h] [ebp-14h]
  float v17; // [esp+24h] [ebp-14h]
  int v18; // [esp+28h] [ebp-10h]
  float v19; // [esp+2Ch] [ebp-Ch]
  unsigned int v20; // [esp+30h] [ebp-8h]
  _DWORD *v21; // [esp+34h] [ebp-4h]

  v21 = v4;
  if ( v4[1042] )
  {
    v5 = grim_convert_vertex_space((void *)arg3, v11);
    v4 = v21;
    arg3 = (int)v5;
  }
  v6 = (_QWORD *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  v18 = v4[11] + 4 * ((arg2 & 3) + 8 * ((unsigned __int8)arg1 & 3));
  fpu_set_round_trunc();
  v20 = 0;
  if ( v21[1046] )
  {
    v7 = 0;
    do
    {
      v19 = *(float *)(v18 + 4 * (v20 & 3));
      v14 = *(float *)(v7 + arg3) * 65535.0 + v19;
      v8 = (int)v14;
      v15 = *(float *)(v7 + arg3 + 4) * 65535.0 + v19;
      v13 = (int)v15;
      v16 = *(float *)(v7 + arg3 + 8) * 65535.0 + v19;
      v12 = (int)v16;
      v17 = *(float *)(v7 + arg3 + 12) * 65535.0 + v19;
      v9 = v13 | ((v8 | (unsigned __int64)((__int64)(int)v17 << 16)) << 16);
      *v6++ = __PAIR64__((v12 >> 31) | (unsigned int)(v9 >> 16), (unsigned int)v12 | ((_DWORD)v9 << 16));
      ++v20;
      v7 += 16;
    }
    while ( v20 < v21[1046] );
  }
  return dword_1005DB6C;
}

// FUN_100192a7 @ 0x100192A7
// [binja] void* __thiscall sub_100192a7(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void *FUN_100192a7(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (void *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = (char *)result + v4[1049]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)*((unsigned __int8 *)result + 2) * 0.0039215689;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*((unsigned __int8 *)result + 1) * 0.0039215689;
    arg3a = *(unsigned __int8 *)result;
    result = (char *)result + 3;
    *(float *)(arg3 - 8) = (double)arg3a * 0.0039215689;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019333 @ 0x10019333
// [binja] int32_t* __thiscall sub_10019333(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_10019333(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // esi
  double v8; // st6

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)*((unsigned __int8 *)result - 1)
                                                                * 0.0039215689 )
  {
    *(float *)arg3 = (double)*((unsigned __int8 *)result + 2) * 0.0039215689;
    *(float *)(arg3 + 4) = (double)*((unsigned __int8 *)result + 1) * 0.0039215689;
    v8 = (double)(unsigned __int8)*result++;
    arg3 += 16;
    *(float *)(arg3 - 8) = v8 * 0.0039215689;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_100193d9 @ 0x100193D9
// [binja] void* __thiscall sub_100193d9(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void *FUN_100193d9(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  char *i; // esi
  double v8; // st6

  result = (void *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = (char *)result + 4 * v4[1046]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)*((unsigned __int8 *)result + 2) * 0.0039215689;
    *(float *)(arg3 + 4) = (double)*((unsigned __int8 *)result + 1) * 0.0039215689;
    v8 = (double)(unsigned __int8)*(_DWORD *)result;
    result = (char *)result + 4;
    arg3 += 16;
    *(float *)(arg3 - 8) = v8 * 0.0039215689;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019475 @ 0x10019475
// [binja] int16_t* __thiscall sub_10019475(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
__int16 *FUN_10019475(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  __int16 *result; // eax
  __int16 *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (__int16 *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)((unsigned __int16)*result >> 11) * 0.032258064;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)(((unsigned __int16)*result >> 5) & 0x3F) * 0.015873017;
    arg3a = *(_BYTE *)result++ & 0x1F;
    *(float *)(arg3 - 8) = (double)arg3a * 0.032258064;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001951a @ 0x1001951A
// [binja] int16_t* __thiscall sub_1001951a(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
__int16 *FUN_1001951a(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  __int16 *result; // eax
  __int16 *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (__int16 *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)(((unsigned __int16)*result >> 10) & 0x1F) * 0.032258064;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)(((unsigned __int16)*result >> 5) & 0x1F) * 0.032258064;
    arg3a = *(_BYTE *)result++ & 0x1F;
    *(float *)(arg3 - 8) = (double)arg3a * 0.032258064;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_100195bc @ 0x100195BC
// [binja] int16_t* __thiscall sub_100195bc(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
__int16 *FUN_100195bc(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  __int16 *result; // eax
  __int16 *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (__int16 *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = (float)arg3a )
  {
    *(float *)arg3 = (double)(((unsigned __int16)*result >> 10) & 0x1F) * 0.032258064;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)(((unsigned __int16)*result >> 5) & 0x1F) * 0.032258064;
    *(float *)(arg3 - 8) = (double)(*(_BYTE *)result & 0x1F) * 0.032258064;
    arg3a = (unsigned __int16)*result++ >> 15;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001966c @ 0x1001966C
// [binja] void* __thiscall sub_1001966c(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void *FUN_1001966c(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  char *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (void *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = (char *)result + 2 * v4[1046]; result < i; *(float *)(arg3 - 4) = (double)arg3a * 0.06666667 )
  {
    *(float *)arg3 = (double)(*((_BYTE *)result + 1) & 0xF) * 0.06666667;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)((*(_BYTE *)result >> 4) & 0xF) * 0.06666667;
    *(float *)(arg3 - 8) = (double)(*(_BYTE *)result & 0xF) * 0.06666667;
    arg3a = *(_WORD *)result >> 12;
    result = (char *)result + 2;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001971b @ 0x1001971B
// [binja] int32_t* __thiscall sub_1001971b(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_1001971b(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // edi
  double v8; // st6

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = v8 * 0.33333334 )
  {
    *(float *)arg3 = (double)(*result & 0x3FF) * 0.00097751711;
    *(float *)(arg3 + 4) = (double)(((unsigned int)*result >> 10) & 0x3FF) * 0.00097751711;
    *(float *)(arg3 + 8) = (double)(((unsigned int)*result >> 20) & 0x3FF) * 0.00097751711;
    v8 = (double)((unsigned int)*result++ >> 30);
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_100197f1 @ 0x100197F1
// [binja] int32_t* __thiscall sub_100197f1(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_100197f1(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // esi
  double v8; // st6

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    v8 = (double)(unsigned __int16)*result++;
    *(float *)arg3 = v8 * 0.000015259022;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*((unsigned __int16 *)result - 1) * 0.000015259022;
    *(float *)(arg3 - 8) = 1.0;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019883 @ 0x10019883
// [binja] char* __thiscall sub_10019883(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019883(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)((unsigned __int8)*result >> 5) * 0.14285715;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)(((unsigned __int8)*result >> 2) & 7) * 0.14285715;
    arg3a = *result++ & 3;
    *(float *)(arg3 - 8) = (double)arg3a * 0.33333334;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019925 @ 0x10019925
// [binja] char* __thiscall sub_10019925(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019925(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)arg3a * 0.0039215689 )
  {
    *(float *)arg3 = 0.0;
    arg3 += 16;
    *(float *)(arg3 - 12) = 0.0;
    *(float *)(arg3 - 8) = 0.0;
    arg3a = (unsigned __int8)*result++;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019997 @ 0x10019997
// [binja] char* __thiscall sub_10019997(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019997(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[2 * v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)(unsigned __int8)*(result - 1)
                                                                    * 0.0039215689 )
  {
    *(float *)arg3 = (double)(((unsigned __int8)*result >> 5) & 7) * 0.14285715;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)(((unsigned __int8)*result >> 2) & 7) * 0.14285715;
    arg3a = *result & 3;
    result += 2;
    *(float *)(arg3 - 8) = (double)arg3a * 0.33333334;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019a49 @ 0x10019A49
// [binja] void* __thiscall sub_10019a49(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void *FUN_10019a49(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  char *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]

  result = (void *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = (char *)result + 2 * v4[1046]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)(*((_BYTE *)result + 1) & 0xF) * 0.06666667;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)((*(_BYTE *)result >> 4) & 0xF) * 0.06666667;
    arg3a = *(_BYTE *)result & 0xF;
    result = (char *)result + 2;
    *(float *)(arg3 - 8) = (double)arg3a * 0.06666667;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019ae8 @ 0x10019AE8
// [binja] char* __thiscall sub_10019ae8(void* arg1, void* arg2, int32_t arg3, uint32_t arg4)
char *FUN_10019ae8(void *arg1, void *arg2, int arg3, uint arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  _DWORD *v7; // edi
  _DWORD *v8; // esi
  char *arg1a; // [esp+8h] [ebp+8h]
  int arg3a; // [esp+10h] [ebp+10h]

  result = (char *)(v4[6] + (_DWORD)arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( arg1a = &result[2 * v4[1046]]; result < arg1a; *(float *)(arg3 - 4) = (double)arg3a * 0.0039215689 )
  {
    v7 = (_DWORD *)arg3;
    arg3 += 16;
    v8 = &v4[4 * (unsigned __int8)*result + 12];
    *v7 = *v8++;
    *++v7 = *v8++;
    *++v7 = *v8;
    v7[1] = v8[1];
    arg3a = (unsigned __int8)result[1];
    result += 2;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// sub_10019B6F @ 0x10019B6F
void __thiscall sub_10019B6F(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *i; // edx
  _DWORD *v7; // esi
  _DWORD *v8; // edi

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *v8 = v7[1] )
  {
    v7 = this + 4 * *v4 + 12;
    *a4 = *v7++;
    a4[1] = *v7++;
    a4[2] = *v7;
    v8 = a4 + 3;
    ++v4;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019bd3 @ 0x10019BD3
// [binja] char* __thiscall sub_10019bd3(void* arg1, int32_t arg2, int32_t arg3, uint32_t arg4)
char *FUN_10019bd3(void *arg1, int arg2, int arg3, uint arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // esi
  double v8; // st7
  int arg3a; // [esp+14h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    arg3a = (unsigned __int8)*result++;
    v8 = (double)arg3a * 0.0039215689;
    *(float *)(arg3 + 8) = v8;
    *(float *)(arg3 + 4) = v8;
    *(float *)arg3 = v8;
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019c41 @ 0x10019C41
// [binja] char* __thiscall sub_10019c41(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019c41(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // edi
  double v8; // st6
  int arg3a; // [esp+18h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[2 * v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)(unsigned __int8)*(result - 1)
                                                                    * 0.0039215689 )
  {
    arg3a = (unsigned __int8)*result;
    result += 2;
    v8 = (double)arg3a * 0.0039215689;
    *(float *)(arg3 + 8) = v8;
    *(float *)(arg3 + 4) = v8;
    *(float *)arg3 = v8;
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019cca @ 0x10019CCA
// [binja] char* __thiscall sub_10019cca(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019cca(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // edi
  double v8; // st6
  int arg3a; // [esp+18h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)arg3a * 0.06666667 )
  {
    v8 = (double)(*result & 0xF) * 0.06666667;
    *(float *)(arg3 + 8) = v8;
    *(float *)(arg3 + 4) = v8;
    *(float *)arg3 = v8;
    arg3a = (unsigned __int8)*result++ >> 4;
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019d53 @ 0x10019D53
// [binja] char* __thiscall sub_10019d53(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019d53(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[2 * v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    arg3a = *result;
    result += 2;
    *(float *)arg3 = (double)arg3a * 0.0078125;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*(result - 1) * 0.0078125;
    *(float *)(arg3 - 8) = 0.0;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019dd5 @ 0x10019DD5
// [binja] char* __thiscall sub_10019dd5(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019dd5(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // edi
  int arg3a; // [esp+18h] [ebp+10h]
  int arg3b; // [esp+18h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[2 * v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)arg3b * 0.015873017 )
  {
    arg3a = (char)(8 * (*(unsigned __int16 *)result >> 5)) >> 3;
    *(float *)arg3 = (double)((char)(8 * *result) >> 3) * 0.0625;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)arg3a * 0.0625;
    *(float *)(arg3 - 8) = 0.0;
    arg3b = *(_WORD *)result >> 10;
    result += 2;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019e86 @ 0x10019E86
// [binja] char* __thiscall sub_10019e86(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019e86(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[4 * v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)(unsigned __int8)*(result - 2)
                                                                    * 0.0039215689 )
  {
    arg3a = *result;
    result += 4;
    *(float *)arg3 = (double)arg3a * 0.0078125;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*(result - 3) * 0.0078125;
    *(float *)(arg3 - 8) = 0.0;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019f17 @ 0x10019F17
// [binja] char* __thiscall sub_10019f17(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
char *FUN_10019f17(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  char *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (char *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[4 * v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)*(result - 1) * 0.0078125 )
  {
    arg3a = *result;
    result += 4;
    *(float *)arg3 = (double)arg3a * 0.0078125;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*(result - 3) * 0.0078125;
    *(float *)(arg3 - 8) = (double)*(result - 2) * 0.0078125;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_10019fae @ 0x10019FAE
// [binja] int16_t* __thiscall sub_10019fae(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
__int16 *FUN_10019fae(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  __int16 *result; // eax
  __int16 *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (__int16 *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[2 * v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    arg3a = *result;
    result += 2;
    *(float *)arg3 = (double)arg3a * 0.000030517578;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*(result - 1) * 0.000030517578;
    *(float *)(arg3 - 8) = 0.0;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a031 @ 0x1001A031
// [binja] int32_t* __thiscall sub_1001a031(void* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_1001a031(void *arg1, uint arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // ebx
  __int16 v8; // si
  double v9; // st6
  int arg3a; // [esp+14h] [ebp+10h]

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    v8 = (__int16)(32 * ((unsigned int)*result >> 21)) >> 5;
    v9 = (double)((__int16)(*(_WORD *)result << 6) >> 6);
    arg3a = (__int16)(32 * ((unsigned int)*result++ >> 10)) >> 5;
    *(float *)arg3 = v9 * 0.001953125;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)arg3a * 0.0009765625;
    *(float *)(arg3 - 8) = (double)v8 * 0.0009765625;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a0eb @ 0x1001A0EB
// [binja] int32_t* __thiscall sub_1001a0eb(void* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_1001a0eb(void *arg1, uint arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // ebx
  __int16 v8; // si
  double v9; // st6
  int arg3a; // [esp+14h] [ebp+10h]

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = v9 * 0.33333334 )
  {
    v8 = (__int16)((unsigned int)*result >> 20 << 6) >> 6;
    arg3a = (__int16)((unsigned __int16)((unsigned int)*result >> 10) << 6) >> 6;
    *(float *)arg3 = (double)((__int16)(*(_WORD *)result << 6) >> 6) * 0.001953125;
    *(float *)(arg3 + 4) = (double)arg3a * 0.001953125;
    *(float *)(arg3 + 8) = (double)v8 * 0.001953125;
    v9 = (double)((unsigned int)*result++ >> 30);
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a1be @ 0x1001A1BE
// [binja] int16_t* __thiscall sub_1001a1be(void* arg1, int32_t arg2, int32_t arg3, uint32_t arg4)
__int16 *FUN_1001a1be(void *arg1, int arg2, int arg3, uint arg4)
{
  _DWORD *v4; // ecx
  __int16 *result; // eax
  __int16 *i; // esi
  double v8; // st7
  int arg3a; // [esp+14h] [ebp+10h]

  result = (__int16 *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    arg3a = (unsigned __int16)*result++;
    v8 = (double)arg3a * 0.000015259022;
    *(float *)(arg3 + 8) = v8;
    *(float *)(arg3 + 4) = v8;
    *(float *)arg3 = v8;
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a22e @ 0x1001A22E
// [binja] int32_t* __thiscall sub_1001a22e(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int *FUN_1001a22e(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  int *result; // eax
  int *i; // esi
  double v8; // st6

  result = (int *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = &result[v4[1046]]; result < i; *(float *)(arg3 - 4) = (double)*((unsigned __int16 *)result - 1)
                                                                * 0.000015259022 )
  {
    v8 = (double)(unsigned __int16)*result++ * 0.000015259022;
    *(float *)(arg3 + 8) = v8;
    *(float *)(arg3 + 4) = v8;
    *(float *)arg3 = v8;
    arg3 += 16;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a2bc @ 0x1001A2BC
// [binja] void* __thiscall sub_1001a2bc(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void *FUN_1001a2bc(void *arg1, int arg2, int arg3, int arg4)
{
  _DWORD *v4; // ecx
  void *result; // eax
  char *i; // esi
  int arg3a; // [esp+14h] [ebp+10h]

  result = (void *)(v4[6] + arg2 * v4[1045] + (_DWORD)arg1 * v4[1044]);
  for ( i = (char *)result + v4[1049]; result < i; *(float *)(arg3 - 4) = 1.0 )
  {
    *(float *)arg3 = (double)*((unsigned __int16 *)result + 2) * 0.000015259022;
    arg3 += 16;
    *(float *)(arg3 - 12) = (double)*((unsigned __int16 *)result + 1) * 0.000015259022;
    arg3a = *(unsigned __int16 *)result;
    result = (char *)result + 6;
    *(float *)(arg3 - 8) = (double)arg3a * 0.000015259022;
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// FUN_1001a348 @ 0x1001A348
// [binja] uint32_t __thiscall sub_1001a348(uint32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4)
uint FUN_1001a348(uint arg1, uint arg2, int arg3, uint arg4)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // esi
  uint result; // eax
  uint arg1a; // [esp+14h] [ebp+8h]
  int arg3a; // [esp+1Ch] [ebp+10h]

  v5 = (_DWORD *)(v4[6] + arg2 * v4[1045] + arg1 * v4[1044]);
  result = (uint)&v5[2 * v4[1046]];
  for ( arg1a = result; (unsigned int)v5 < arg1a; *(float *)(arg3 - 4) = (double)(int)result * 0.000015259022 )
  {
    *(float *)arg3 = (double)(unsigned __int16)v5[1] * 0.000015259022;
    *(float *)(arg3 + 4) = (double)(unsigned __int16)HIWORD(*v5) * 0.000015259022;
    arg3a = (unsigned __int16)*v5;
    v5 += 2;
    arg3 += 16;
    *(float *)(arg3 - 8) = (double)(unsigned int)arg3a * 0.000015259022;
    result = *((unsigned __int16 *)v5 - 1);
  }
  if ( v4[4] )
    grim_apply_color_key((float *)(arg3 - 16 * v4[1046]));
  return result;
}

// grim_pixel_format_ctor_r8g8b8 @ 0x1001A428
// pixel format ctor for D3DFMT_R8G8B8
void *grim_pixel_format_ctor_r8g8b8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x18, 1u, v5);
  *v3 = &off_1004CB6C;
  return v3;
}

// grim_pixel_format_init_yuv @ 0x1001A444
// initializes packed YUV (UYVY/YUY2) cache state and allocates RGB float cache
void *grim_pixel_format_init_yuv(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  int v5; // ebx
  void *v6; // eax
  void *v7; // eax
  unsigned int v9; // [esp+0h] [ebp-20h]
  void *v10; // [esp+10h] [ebp-10h]

  v3 = v2;
  grim_pixel_format_init(this, 0, 1u, v9);
  v4 = v3[1036] & 0xFFFFFFFE;
  v5 = ((v3[1038] + 1) & 0xFFFFFFFE) - v4;
  v3[1054] = (v3[1038] + 1) & 0xFFFFFFFE;
  *v3 = &off_1004CB7C;
  v3[1052] = v4;
  v3[1053] = 0;
  v3[1056] = 0;
  v3[1055] = 0;
  v3[1057] = 0;
  v3[1058] = v5;
  v3[1059] = 0;
  v3[1060] = 1;
  v6 = operator new(16 * v5);
  v10 = v6;
  if ( v6 )
  {
    sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    v7 = v10;
  }
  else
  {
    v7 = 0;
  }
  v3[1051] = v7;
  if ( !v7 )
    v3[1060] = 0;
  if ( *((_DWORD *)this + 1) == 1498831189 )
  {
    v3[1061] = 8;
    v3[1062] = 0;
  }
  else
  {
    v3[1061] = 0;
    v3[1062] = 8;
  }
  return v3;
}

// grim_pixel_format_ctor_a8r8g8b8 @ 0x1001A53C
// pixel format ctor for D3DFMT_A8R8G8B8
void *grim_pixel_format_ctor_a8r8g8b8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 1u, v5);
  *v3 = &off_1004CB8C;
  return v3;
}

// grim_pixel_format_ctor_x8r8g8b8 @ 0x1001A558
// pixel format ctor for D3DFMT_X8R8G8B8
void *grim_pixel_format_ctor_x8r8g8b8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 1u, v5);
  *v3 = &off_1004CB9C;
  return v3;
}

// grim_pixel_format_ctor_r5g6b5 @ 0x1001A579
// pixel format ctor for D3DFMT_R5G6B5
void *grim_pixel_format_ctor_r5g6b5(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CBAC;
  return v3;
}

// grim_pixel_format_flush_yuv_cache @ 0x1001A595
// flushes cached YUV<->RGB conversions back into packed 16-bit storage
int grim_pixel_format_flush_yuv_cache(void *this)
{
  _DWORD *v1; // ecx
  unsigned int v2; // edx
  float *v3; // eax
  int v4; // edx
  int v5; // esi
  int v6; // ebx
  int v7; // edi
  float v9; // [esp+4h] [ebp-28h]
  float v10; // [esp+4h] [ebp-28h]
  float v11; // [esp+Ch] [ebp-20h]
  float v12; // [esp+Ch] [ebp-20h]
  float v13; // [esp+14h] [ebp-18h]
  float v14; // [esp+14h] [ebp-18h]
  float v15; // [esp+1Ch] [ebp-10h]
  _WORD *v16; // [esp+20h] [ebp-Ch]
  unsigned int v17; // [esp+24h] [ebp-8h]
  _DWORD *v18; // [esp+28h] [ebp-4h]

  v18 = v1;
  if ( v1[1059] && v1[1060] )
  {
    v2 = v1[1052];
    v16 = (_WORD *)(v1[6] + v1[1044] * v1[1053] + v1[1045] * v1[1056] + 2 * v2);
    v3 = (float *)v1[1051];
    v17 = v2;
    if ( v2 < v1[1054] )
    {
      do
      {
        v13 = v3[4] * 65.481003 + v3[6] * 24.966 + v3[5] * 128.55299;
        v11 = v3[2] * 112.0 - v3[1] * 74.203003 - *v3 * 37.797001;
        v9 = *v3 * 112.0 - (v3[1] * 93.786003 + v3[2] * 18.214001);
        v15 = *v3 * 65.481003 + v3[1] * 128.55299 + v3[2] * 24.966 + 0.5;
        v4 = (int)v15 + 16;
        v14 = v13 + 0.5;
        v5 = (int)v14 + 16;
        v12 = v11 + 0.5;
        v6 = (int)v12 + 128;
        v10 = v9 + 0.5;
        v7 = (int)v10 + 128;
        if ( v4 >= 0 )
        {
          if ( v4 > 255 )
            v4 = 255;
        }
        else
        {
          v4 = 0;
        }
        if ( v5 >= 0 )
        {
          if ( v5 > 255 )
            LOWORD(v5) = 255;
        }
        else
        {
          LOWORD(v5) = 0;
        }
        if ( v6 >= 0 )
        {
          if ( v6 > 255 )
            v6 = 255;
        }
        else
        {
          v6 = 0;
        }
        if ( v7 >= 0 )
        {
          if ( v7 > 255 )
            LOWORD(v7) = 255;
        }
        else
        {
          LOWORD(v7) = 0;
        }
        v17 += 2;
        v3 += 8;
        *v16 = (v6 << v18[1062]) | (v4 << v18[1061]);
        v16 += 2;
        *(v16 - 1) = ((_WORD)v7 << v18[1062]) | ((_WORD)v5 << v18[1061]);
        v1 = v18;
      }
      while ( v17 < v18[1054] );
    }
    v1[1059] = 0;
  }
  return 0;
}

// grim_pixel_format_ctor_x1r5g5b5 @ 0x1001A781
// pixel format ctor for D3DFMT_X1R5G5B5
void *grim_pixel_format_ctor_x1r5g5b5(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CBDC;
  return v3;
}

// grim_pixel_format_ctor_a1r5g5b5 @ 0x1001A79D
// pixel format ctor for D3DFMT_A1R5G5B5
void *grim_pixel_format_ctor_a1r5g5b5(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CBEC;
  return v3;
}

// grim_pixel_format_load_yuv_cache @ 0x1001A7B9
// loads packed YUV pixels into float cache and converts to RGB
int grim_pixel_format_load_yuv_cache(void *this, uint x, uint y, int load_from_surface)
{
  _DWORD *v4; // ecx
  void *v5; // edi
  _DWORD *v6; // esi
  int result; // eax
  uint v8; // eax
  float *v9; // edx
  _WORD *v10; // ebx
  unsigned __int16 v11; // ax
  double v12; // st4
  _WORD *v13; // ebx
  unsigned __int16 v14; // ax
  double v15; // st4
  double v16; // st3
  double v17; // st3
  double v18; // st2
  double v19; // st2
  double v20; // st1
  double v21; // st1
  double v22; // st2
  double v23; // st2
  double v24; // st2
  double v25; // st4
  double v26; // st4
  double v27; // st4
  float v28; // [esp+4h] [ebp-Ch]
  float v29; // [esp+8h] [ebp-8h]
  float v30; // [esp+8h] [ebp-8h]
  float v31; // [esp+Ch] [ebp-4h]
  float v32; // [esp+Ch] [ebp-4h]
  _WORD *thisa; // [esp+18h] [ebp+8h]
  float thisd; // [esp+18h] [ebp+8h]
  float thisb; // [esp+18h] [ebp+8h]
  float thise; // [esp+18h] [ebp+8h]
  float thisc; // [esp+18h] [ebp+8h]
  signed int xc; // [esp+1Ch] [ebp+Ch]
  float xd; // [esp+1Ch] [ebp+Ch]
  float xa; // [esp+1Ch] [ebp+Ch]
  float xb; // [esp+1Ch] [ebp+Ch]
  uint ya; // [esp+20h] [ebp+10h]

  v6 = v4;
  if ( !v4[1060] )
    return -2147024882;
  if ( (unsigned int)this < v4[1053] || (unsigned int)this >= v4[1055] || x < v4[1056] || x >= v4[1057] )
  {
    result = grim_pixel_format_flush_yuv_cache(v5);
    if ( result < 0 )
      return result;
    v6[1055] = (char *)this + 1;
    v6[1053] = this;
    v6[1056] = x;
    v6[1057] = x + 1;
    if ( y )
    {
      v8 = v6[1052];
      v9 = (float *)v6[1051];
      v10 = (_WORD *)(v6[6] + x * v6[1045] + (_DWORD)this * v6[1044] + 2 * v8);
      thisa = v10;
      for ( ya = v8; ya < v6[1054]; thisa = v10 )
      {
        v11 = *v10;
        v12 = (double)(unsigned __int8)(*v10 >> *((_WORD *)v6 + 2122));
        v13 = thisa;
        xc = (unsigned __int8)(v11 >> *((_WORD *)v6 + 2124));
        v14 = thisa[1];
        v29 = v12 - 16.0;
        v31 = (double)xc - 128.0;
        v15 = (double)(unsigned __int8)(v14 >> *((_WORD *)v6 + 2122)) - 16.0;
        v16 = (double)(unsigned __int8)(v14 >> *((_WORD *)v6 + 2124)) - 128.0;
        xd = v16;
        v17 = v16 * 0.0062589301;
        v18 = v29 * 0.0045662099;
        thisd = v18;
        v19 = v18 + v17;
        *v9 = v19;
        v30 = v31 * 0.00153632;
        v20 = xd * 0.00318811;
        v28 = v20;
        xa = thisd - v30 - v20;
        v9[1] = xa;
        v21 = v31 * 0.0079107098;
        thisb = v21 + thisd;
        v9[2] = thisb;
        v9[3] = 1.0;
        if ( v19 >= 0.0 )
        {
          if ( v19 > 1.0 )
            v19 = 1.0;
        }
        else
        {
          v19 = 0.0;
        }
        *v9 = v19;
        if ( xa >= 0.0 )
        {
          if ( xa <= 1.0 )
            v22 = xa;
          else
            v22 = 1.0;
        }
        else
        {
          v22 = 0.0;
        }
        v9[1] = v22;
        if ( thisb >= 0.0 )
        {
          if ( thisb <= 1.0 )
            v23 = thisb;
          else
            v23 = 1.0;
        }
        else
        {
          v23 = 0.0;
        }
        v9[2] = v23;
        thise = v15 * 0.0045662099;
        v24 = v15 * 0.0045662099 + v17;
        v25 = v24;
        v9[4] = v24;
        xb = thise - v30 - v28;
        v9[5] = xb;
        v32 = v21;
        thisc = thise + v32;
        v9[6] = thisc;
        v9[7] = 1.0;
        if ( v24 >= 0.0 )
        {
          if ( v24 > 1.0 )
            v25 = 1.0;
        }
        else
        {
          v25 = 0.0;
        }
        v9[4] = v25;
        if ( xb >= 0.0 )
        {
          if ( xb <= 1.0 )
            v26 = xb;
          else
            v26 = 1.0;
        }
        else
        {
          v26 = 0.0;
        }
        v9[5] = v26;
        if ( thisc >= 0.0 )
        {
          if ( thisc <= 1.0 )
            v27 = thisc;
          else
            v27 = 1.0;
        }
        else
        {
          v27 = 0.0;
        }
        ya += 2;
        v9[6] = v27;
        v10 = v13 + 2;
        v9 += 8;
      }
    }
  }
  return 0;
}

// grim_pixel_format_ctor_a4r4g4b4 @ 0x1001AA8A
// pixel format ctor for D3DFMT_A4R4G4B4
void *grim_pixel_format_ctor_a4r4g4b4(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CC10;
  return v3;
}

// grim_pixel_format_ctor_r3g3b2 @ 0x1001AAA6
// pixel format ctor for D3DFMT_R3G3B2
void *grim_pixel_format_ctor_r3g3b2(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)8, 1u, v5);
  *v3 = &off_1004CC20;
  return v3;
}

// grim_pixel_format_ctor_a8 @ 0x1001AAC2
// pixel format ctor for D3DFMT_A8
void *grim_pixel_format_ctor_a8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)8, 1u, v5);
  *v3 = &off_1004CC30;
  return v3;
}

// grim_pixel_format_ctor_a8r3g3b2 @ 0x1001AADE
// pixel format ctor for D3DFMT_A8R3G3B2
void *grim_pixel_format_ctor_a8r3g3b2(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CC40;
  return v3;
}

// grim_pixel_format_ctor_x4r4g4b4 @ 0x1001AAFA
// pixel format ctor for D3DFMT_X4R4G4B4
void *grim_pixel_format_ctor_x4r4g4b4(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CC50;
  return v3;
}

// grim_pixel_format_write_yuv_cache @ 0x1001AB16
// loads YUV cache for coords, copies RGBA floats into cache, marks dirty for flush
void grim_pixel_format_write_yuv_cache(void *this, int x, int y, float *pixels)
{
  _DWORD *v4; // ecx
  _DWORD *v5; // ebx
  float *v6; // [esp+0h] [ebp-8h]

  v5 = v4;
  if ( v4[1042] )
    y = (int)grim_convert_vertex_space((void *)y, v6);
  if ( grim_pixel_format_load_yuv_cache((char *)this + v5[1037], v5[1040] + x, v5[1058] != v5[1046], (int)v6) >= 0 )
  {
    qmemcpy((void *)(v5[1051] + 16 * (v5[1036] - v5[1052])), (const void *)y, 16 * v5[1046]);
    v5[1059] = 1;
  }
}

// grim_pixel_format_ctor_a2b10g10r10 @ 0x1001ABA3
// pixel format ctor for D3DFMT_A2B10G10R10
void *grim_pixel_format_ctor_a2b10g10r10(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 1u, v5);
  *v3 = &off_1004CC60;
  return v3;
}

// sub_1001ABBF @ 0x1001ABBF
void __thiscall sub_1001ABBF(_DWORD *this, int a2, int a3, float *pixels)
{
  int v5; // [esp+0h] [ebp-4h]

  if ( grim_pixel_format_load_yuv_cache((void *)(*(this + 1037) + a2), *(this + 1040) + a3, 1u, v5) >= 0 )
  {
    qmemcpy(pixels, (const void *)(*(this + 1051) + 16 * (*(this + 1036) - *(this + 1052))), 16 * *(this + 1046));
    if ( *(this + 4) )
      grim_apply_color_key(pixels);
  }
}

// grim_pixel_format_ctor_g16r16 @ 0x1001AC2E
// pixel format ctor for D3DFMT_G16R16
void *grim_pixel_format_ctor_g16r16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 1u, v5);
  *v3 = &off_1004CC70;
  return v3;
}

// grim_pixel_format_init_dxt @ 0x1001AC4A
// initializes DXT block-compressed pixel format (DXT1..DXT5)
void *grim_pixel_format_init_dxt(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  BOOL v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // edi
  int v8; // ecx
  int v9; // ebx
  unsigned int v10; // eax
  unsigned int v11; // ecx
  int v12; // edx
  int v13; // edx
  unsigned int v15; // [esp+0h] [ebp-Ch]

  v3 = v2;
  grim_pixel_format_init(this, 0, 1u, v15);
  *v3 = &off_1004CAF8;
  if ( *((_DWORD *)this + 6) == 1 )
  {
    v3[1054] = 0;
  }
  else if ( *((_DWORD *)this + 6) == 2 )
  {
    v3[1054] = 1;
  }
  else
  {
    v3[1054] = 3;
  }
  if ( *((_DWORD *)this + 7) == 1 )
  {
    v3[1055] = 0;
  }
  else if ( *((_DWORD *)this + 7) == 2 )
  {
    v3[1055] = 1;
  }
  else
  {
    v3[1055] = 3;
  }
  v4 = v3[1054] != 3 || v3[1055] != 3;
  v3[1053] = v4;
  v5 = v3[1];
  switch ( v5 )
  {
    case 827611204:
      v3[1056] = 8;
      v3[1058] = sub_10021B96;
      v3[1057] = grim_dxt1_decode_color_block;
      break;
    case 844388420:
      v3[1056] = 16;
      v3[1058] = grim_dxt2_encode_block;
      v3[1057] = grim_dxt2_decode_block;
      break;
    case 861165636:
      v3[1056] = 16;
      v3[1058] = grim_dxt3_encode_block;
      v3[1057] = grim_dxt3_decode_block;
      break;
    case 877942852:
      v3[1056] = 16;
      v3[1058] = grim_dxt4_encode_block;
      v3[1057] = grim_dxt4_decode_block;
      break;
    case 894720068:
      v3[1056] = 16;
      v3[1058] = grim_dxt5_encode_block;
      v3[1057] = grim_dxt5_decode_block;
      break;
  }
  v6 = v3[1040];
  v7 = v3[1036];
  v8 = v3[1039];
  v9 = v3[1037];
  v3[1068] = -1;
  v3[1069] = -1;
  v3[1063] = v6;
  v10 = (v3[1038] + 3) & 0xFFFFFFFC;
  v7 &= 0xFFFFFFFC;
  v3[1061] = v10;
  v9 &= 0xFFFFFFFC;
  v11 = (v8 + 3) & 0xFFFFFFFC;
  v12 = v3[1041];
  v3[1062] = v11;
  v3[1065] = (v10 - v7) >> 2;
  v3[1064] = v12;
  v13 = v12 - v3[1040];
  v3[1059] = v7;
  v3[1070] = 0;
  v3[1071] = 0;
  v3[1072] = 0;
  v3[1060] = v9;
  v3[1066] = (v11 - v9) >> 2;
  v3[1067] = v13;
  return v3;
}

// grim_pixel_format_ctor_a8p8 @ 0x1001AE3C
// pixel format ctor for D3DFMT_A8P8
void *grim_pixel_format_ctor_a8p8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CC80;
  return v3;
}

// FUN_1001ae58 @ 0x1001AE58
// [binja] void*** __thiscall sub_1001ae58(void*** arg1, char arg2)
void ***FUN_1001ae58(void ***arg1, char arg2)
{
  _DWORD *v2; // ecx
  void *v3; // esi

  v3 = v2;
  j_grim_vertex_space_converter_destroy(v2);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return (void ***)v3;
}

// grim_pixel_format_ctor_p8 @ 0x1001AE74
// pixel format ctor for D3DFMT_P8
void *grim_pixel_format_ctor_p8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)8, 1u, v5);
  *v3 = &off_1004CC90;
  return v3;
}

// grim_pixel_format_ctor_l8 @ 0x1001AE90
// pixel format ctor for D3DFMT_L8
void *grim_pixel_format_ctor_l8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)8, 1u, v5);
  *v3 = &off_1004CCA0;
  return v3;
}

// grim_pixel_format_ctor_a8l8 @ 0x1001AEAC
// pixel format ctor for D3DFMT_A8L8
void *grim_pixel_format_ctor_a8l8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CCB0;
  return v3;
}

// FUN_1001aec8 @ 0x1001AEC8
// [binja] void*** __thiscall sub_1001aec8(void*** arg1, char arg2)
void ***FUN_1001aec8(void ***arg1, char arg2)
{
  void *v2; // ecx
  void *v3; // esi
  void ***v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  FUN_10016c3c(v5);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return (void ***)v3;
}

// grim_pixel_format_ctor_a4l4 @ 0x1001AEE4
// pixel format ctor for D3DFMT_A4L4
void *grim_pixel_format_ctor_a4l4(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)8, 1u, v5);
  *v3 = &off_1004CCC0;
  return v3;
}

// FUN_1001af00 @ 0x1001AF00
// [binja] void* __fastcall sub_1001af00(void* arg1)
void *FUN_1001af00(void *arg1)
{
  int v1; // ecx
  int v2; // eax
  double v3; // st7
  float v5; // [esp+0h] [ebp-Ch]
  float v6; // [esp+0h] [ebp-Ch]
  float v7; // [esp+0h] [ebp-Ch]
  float v8; // [esp+4h] [ebp-8h]

  v2 = *(_DWORD *)(v1 + 4);
  if ( v2 == 844388420 || v2 == 861165636 )
    v3 = 15.0;
  else
    v3 = 255.0;
  *(float *)(v1 + 4204) = v3;
  *(float *)(v1 + 4208) = 1.0 / *(float *)(v1 + 4204);
  v8 = *(float *)(v1 + 28) * 31.0 + 0.5;
  *(float *)(v1 + 28) = (double)(int)v8 * 0.032258064;
  v5 = *(float *)(v1 + 32) * 63.0 + 0.5;
  *(float *)(v1 + 32) = (double)(int)v5 * 0.015873017;
  v6 = *(float *)(v1 + 36) * 31.0 + 0.5;
  *(float *)(v1 + 36) = (double)(int)v6 * 0.032258064;
  v7 = *(float *)(v1 + 4204) * *(float *)(v1 + 40) + 0.5;
  *(float *)(v1 + 40) = (double)(int)v7 * *(float *)(v1 + 4208);
  return (void *)v1;
}

// grim_pixel_format_ctor_v8u8 @ 0x1001B001
// pixel format ctor for D3DFMT_V8U8
void *grim_pixel_format_ctor_v8u8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 2u, v5);
  *v3 = &off_1004CCD0;
  return v3;
}

// grim_pixel_format_ctor_l6v5u5 @ 0x1001B01D
// pixel format ctor for D3DFMT_L6V5U5
void *grim_pixel_format_ctor_l6v5u5(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 2u, v5);
  *v3 = &off_1004CCE0;
  return v3;
}

// grim_pixel_format_ctor_x8l8v8u8 @ 0x1001B039
// pixel format ctor for D3DFMT_X8L8V8U8
void *grim_pixel_format_ctor_x8l8v8u8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 2u, v5);
  *v3 = &off_1004CCF0;
  return v3;
}

// grim_pixel_format_ctor_q8w8v8u8 @ 0x1001B055
// pixel format ctor for D3DFMT_Q8W8V8U8
void *grim_pixel_format_ctor_q8w8v8u8(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 3u, v5);
  *v3 = &off_1004CD00;
  return v3;
}

// grim_pixel_format_ctor_v16u16 @ 0x1001B071
// pixel format ctor for D3DFMT_V16U16
void *grim_pixel_format_ctor_v16u16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 2u, v5);
  *v3 = &off_1004CD10;
  return v3;
}

// grim_pixel_format_ctor_w11v11u10 @ 0x1001B08D
// pixel format ctor for D3DFMT_W11V11U10
void *grim_pixel_format_ctor_w11v11u10(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 2u, v5);
  *v3 = &off_1004CD20;
  return v3;
}

// grim_pixel_format_ctor_a2w10v10u10 @ 0x1001B0A9
// pixel format ctor for D3DFMT_A2W10V10U10
void *grim_pixel_format_ctor_a2w10v10u10(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 2u, v5);
  *v3 = &off_1004CD30;
  return v3;
}

// grim_pixel_format_ctor_d16_lockable @ 0x1001B0C5
// pixel format ctor for D3DFMT_D16_LOCKABLE
void *grim_pixel_format_ctor_d16_lockable(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CD40;
  return v3;
}

// grim_pixel_format_ctor_l16 @ 0x1001B0E1
// pixel format ctor for FourCC L16 (16-bit luminance)
void *grim_pixel_format_ctor_l16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x10, 1u, v5);
  *v3 = &off_1004CD50;
  return v3;
}

// grim_pixel_format_read_dxt_cache @ 0x1001B0FD
// decodes DXT blocks into cache on demand and copies RGBA floats to output (color key aware)
void grim_pixel_format_read_dxt_cache(void *this, uint x, uint y, float *out)
{
  int v4; // ecx
  int v5; // esi
  void *v6; // eax
  void *v7; // edi
  unsigned int v8; // edi
  int v9; // ebx
  int v10; // esi
  unsigned int v11; // eax
  int v12; // ebx
  unsigned int v13; // edx
  _DWORD *v14; // esi
  uint v15; // edx
  float v16; // [esp+18h] [ebp-34h]
  float v17; // [esp+1Ch] [ebp-30h]
  float v18; // [esp+20h] [ebp-2Ch]
  float v19; // [esp+38h] [ebp-14h]
  float v20; // [esp+38h] [ebp-14h]
  float v21; // [esp+38h] [ebp-14h]
  float v22; // [esp+38h] [ebp-14h]
  int v23; // [esp+3Ch] [ebp-10h]
  unsigned int thisa; // [esp+54h] [ebp+8h]
  uint xa; // [esp+58h] [ebp+Ch]

  v23 = v4;
  thisa = (unsigned int)this + *(_DWORD *)(v4 + 4148);
  xa = *(_DWORD *)(v4 + 4160) + x;
  if ( !*(_DWORD *)(v4 + 4280) )
  {
    v5 = 16 * *(_DWORD *)(v4 + 4260);
    v6 = operator new(*(_DWORD *)(v4 + 4260) << 8);
    v7 = v6;
    if ( v6 )
      sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    else
      v7 = 0;
    *(_DWORD *)(v23 + 4280) = v7;
    if ( !v7 )
      return;
    v4 = v23;
  }
  if ( (thisa & 0xFFFFFFFC) != *(_DWORD *)(v4 + 4272) || xa != *(_DWORD *)(v4 + 4276) )
  {
    *(_DWORD *)(v4 + 4272) = thisa & 0xFFFFFFFC;
    *(_DWORD *)(v23 + 4276) = xa;
    v4 = v23;
    v8 = *(_DWORD *)(v23 + 4236);
    v9 = *(_DWORD *)(v23 + 4280);
    v10 = *(_DWORD *)(v23 + 24)
        + *(_DWORD *)(v23 + 4180) * *(_DWORD *)(v23 + 4276)
        + *(_DWORD *)(v23 + 4224) * (v8 >> 2)
        + *(_DWORD *)(v23 + 4176) * (*(_DWORD *)(v23 + 4272) >> 2);
    while ( v8 < *(_DWORD *)(v4 + 4244) )
    {
      (*(void (__cdecl **)(int, int))(v4 + 4228))(v9, v10);
      v4 = v23;
      v10 += *(_DWORD *)(v23 + 4224);
      v9 += 256;
      v8 += 4;
    }
  }
  v11 = *(_DWORD *)(v4 + 4144) - *(_DWORD *)(v4 + 4236);
  v12 = (thisa - *(_DWORD *)(v4 + 4240)) & 3;
  v13 = v11 + *(_DWORD *)(v4 + 4184);
  while ( v11 < v13 )
  {
    v14 = (_DWORD *)(*(_DWORD *)(v4 + 4280) + 16 * (v11 & 3 | (4 * (v12 | v11 & 0xFFFFFFFC))));
    *(_DWORD *)y = *v14++;
    *(_DWORD *)(y + 4) = *v14++;
    *(_DWORD *)(y + 8) = *v14;
    *(_DWORD *)(y + 12) = v14[1];
    y += 16;
    v4 = v23;
    ++v11;
  }
  if ( *(_DWORD *)(v4 + 16) )
  {
    fpu_set_round_trunc();
    while ( y < v15 )
    {
      v19 = *(float *)y * 31.0 + 0.5;
      v16 = (double)(int)v19 * 0.032258064;
      if ( v16 == *(float *)(v23 + 28) )
      {
        v20 = *(float *)(y + 4) * 63.0 + 0.5;
        v17 = (double)(int)v20 * 0.015873017;
        if ( v17 == *(float *)(v23 + 32) )
        {
          v21 = *(float *)(y + 8) * 31.0 + 0.5;
          v18 = (double)(int)v21 * 0.032258064;
          if ( v18 == *(float *)(v23 + 36) )
          {
            v22 = *(float *)(v23 + 4204) * *(float *)(y + 12) + 0.5;
            if ( (double)(int)v22 * *(float *)(v23 + 4208) == *(float *)(v23 + 40) )
            {
              *(float *)y = 0.0;
              *(float *)(y + 4) = 0.0;
              *(float *)(y + 8) = 0.0;
              *(float *)(y + 12) = 0.0;
            }
          }
        }
      }
      y += 16;
    }
  }
}

// grim_pixel_format_ctor_al16 @ 0x1001B3A6
// pixel format ctor for FourCC AL16
void *grim_pixel_format_ctor_al16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x20, 1u, v5);
  *v3 = &off_1004CD60;
  return v3;
}

// grim_pixel_format_ctor_r16 @ 0x1001B3C2
// pixel format ctor for FourCC R16
void *grim_pixel_format_ctor_r16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x30, 1u, v5);
  *v3 = &off_1004CD70;
  return v3;
}

// grim_pixel_format_ctor_ar16 @ 0x1001B3DE
// pixel format ctor for FourCC AR16
void *grim_pixel_format_ctor_ar16(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  unsigned int v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init(this, (unsigned int *)0x40, 1u, v5);
  *v3 = &off_1004CD80;
  return v3;
}

// grim_pixel_format_ctor_dxt1 @ 0x1001B3FA
// pixel format ctor for FourCC DXT1
void *grim_pixel_format_ctor_dxt1(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  uint *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init_dxt(this, v5);
  *v3 = &off_1004CD90;
  return v3;
}

// grim_pixel_format_ctor_dxt2 @ 0x1001B412
// pixel format ctor for FourCC DXT2
void *grim_pixel_format_ctor_dxt2(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  uint *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init_dxt(this, v5);
  *v3 = &off_1004CDA0;
  return v3;
}

// grim_pixel_format_ctor_dxt3 @ 0x1001B42A
// pixel format ctor for FourCC DXT3
void *grim_pixel_format_ctor_dxt3(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  uint *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init_dxt(this, v5);
  *v3 = &off_1004CDB0;
  return v3;
}

// grim_pixel_format_ctor_dxt4 @ 0x1001B442
// pixel format ctor for FourCC DXT4
void *grim_pixel_format_ctor_dxt4(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  uint *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init_dxt(this, v5);
  *v3 = &off_1004CDC0;
  return v3;
}

// grim_pixel_format_ctor_dxt5 @ 0x1001B45A
// pixel format ctor for FourCC DXT5
void *grim_pixel_format_ctor_dxt5(void *this, uint *desc)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // esi
  uint *v5; // [esp+0h] [ebp-4h]

  v3 = v2;
  grim_pixel_format_init_dxt(this, v5);
  *v3 = &off_1004CDD0;
  return v3;
}

// FUN_1001b472 @ 0x1001B472
// [binja] void*** __thiscall sub_1001b472(void*** arg1, char arg2)
void ***FUN_1001b472(void ***arg1, char arg2)
{
  int v2; // ecx
  void *v3; // esi

  v3 = (void *)v2;
  j_FUN_10016c3c(v2);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return (void ***)v3;
}

// FUN_1001b493 @ 0x1001B493
// [binja] int32_t __fastcall sub_1001b493(void*** arg1)
int FUN_1001b493(void ***arg1)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  int result; // eax
  void *v4; // [esp+0h] [ebp-14h]
  void *v5; // [esp+0h] [ebp-14h]

  v2 = v1;
  *v1 = &off_1004CB7C;
  grim_pixel_format_flush_yuv_cache(v4);
  if ( v2[1051] )
    operator delete((void *)v2[1051]);
  grim_vertex_space_converter_destroy(v5);
  return result;
}

// grim_pixel_format_ctor_uyvy @ 0x1001B4DC
// pixel format ctor for FourCC UYVY
void *grim_pixel_format_ctor_uyvy(void *this)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  uint *v4; // [esp+0h] [ebp-4h]

  v2 = v1;
  grim_pixel_format_init_yuv(this, v4);
  *v2 = &off_1004CDE0;
  return v2;
}

// grim_pixel_format_ctor_yuy2 @ 0x1001B4F4
// pixel format ctor for FourCC YUY2
void *grim_pixel_format_ctor_yuy2(void *this)
{
  _DWORD *v1; // ecx
  _DWORD *v2; // esi
  uint *v4; // [esp+0h] [ebp-4h]

  v2 = v1;
  grim_pixel_format_init_yuv(this, v4);
  *v2 = &off_1004CDF0;
  return v2;
}

// grim_pixel_format_create @ 0x1001B50C
// factory: picks pixel format implementation from FourCC/D3DFORMAT
void *grim_pixel_format_create(uint *desc)
{
  int v1; // eax
  void *v2; // esi
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  uint *v17; // [esp+0h] [ebp-14h]

  v1 = desc[1];
  v2 = 0;
  if ( v1 > 827611204 )
  {
    if ( v1 > 909200416 )
    {
      v13 = v1 - 909200449;
      if ( v13 )
      {
        v14 = v13 - 1503;
        if ( v14 )
        {
          v15 = v14 - 33;
          if ( v15 )
          {
            if ( v15 != 589629204 )
              return v2;
            if ( operator new(0x109Cu) )
            {
              v3 = grim_pixel_format_ctor_uyvy(desc);
              goto LABEL_105;
            }
          }
          else if ( operator new(0x106Cu) )
          {
            v3 = grim_pixel_format_ctor_ar16(desc, v17);
            goto LABEL_105;
          }
        }
        else if ( operator new(0x106Cu) )
        {
          v3 = grim_pixel_format_ctor_r16(desc, v17);
          goto LABEL_105;
        }
      }
      else if ( operator new(0x106Cu) )
      {
        v3 = grim_pixel_format_ctor_al16(desc, v17);
        goto LABEL_105;
      }
    }
    else
    {
      switch ( v1 )
      {
        case 909200416:
          if ( operator new(0x106Cu) )
          {
            v3 = grim_pixel_format_ctor_l16(desc, v17);
            goto LABEL_105;
          }
          break;
        case 844388420:
          if ( operator new(0x10C4u) )
          {
            v3 = grim_pixel_format_ctor_dxt2(desc, v17);
            goto LABEL_105;
          }
          break;
        case 844715353:
          if ( operator new(0x109Cu) )
          {
            v3 = grim_pixel_format_ctor_yuy2(desc);
            goto LABEL_105;
          }
          break;
        case 861165636:
          if ( operator new(0x10C4u) )
          {
            v3 = grim_pixel_format_ctor_dxt3(desc, v17);
            goto LABEL_105;
          }
          break;
        case 877942852:
          if ( operator new(0x10C4u) )
          {
            v3 = grim_pixel_format_ctor_dxt4(desc, v17);
            goto LABEL_105;
          }
          break;
        case 894720068:
          if ( operator new(0x10C4u) )
          {
            v3 = grim_pixel_format_ctor_dxt5(desc, v17);
            goto LABEL_105;
          }
          break;
        default:
          return v2;
      }
    }
    goto LABEL_104;
  }
  if ( v1 == 827611204 )
  {
    if ( operator new(0x10C4u) )
    {
      v3 = grim_pixel_format_ctor_dxt1(desc, v17);
      goto LABEL_105;
    }
    goto LABEL_104;
  }
  if ( v1 > 40 )
  {
    if ( v1 > 62 )
    {
      v9 = v1 - 63;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          v11 = v10 - 1;
          if ( v11 )
          {
            v12 = v11 - 2;
            if ( v12 )
            {
              if ( v12 != 3 )
                return v2;
              if ( operator new(0x106Cu) )
              {
                v3 = grim_pixel_format_ctor_d16_lockable(desc, v17);
                goto LABEL_105;
              }
            }
            else if ( operator new(0x106Cu) )
            {
              v3 = grim_pixel_format_ctor_a2w10v10u10(desc, v17);
              goto LABEL_105;
            }
          }
          else if ( operator new(0x106Cu) )
          {
            v3 = grim_pixel_format_ctor_w11v11u10(desc, v17);
            goto LABEL_105;
          }
        }
        else if ( operator new(0x106Cu) )
        {
          v3 = grim_pixel_format_ctor_v16u16(desc, v17);
          goto LABEL_105;
        }
      }
      else if ( operator new(0x106Cu) )
      {
        v3 = grim_pixel_format_ctor_q8w8v8u8(desc, v17);
        goto LABEL_105;
      }
    }
    else if ( v1 == 62 )
    {
      if ( operator new(0x106Cu) )
      {
        v3 = grim_pixel_format_ctor_x8l8v8u8(desc, v17);
        goto LABEL_105;
      }
    }
    else
    {
      v4 = v1 - 41;
      if ( v4 )
      {
        v5 = v4 - 9;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              v8 = v7 - 8;
              if ( v8 )
              {
                if ( v8 != 1 )
                  return v2;
                if ( operator new(0x106Cu) )
                {
                  v3 = grim_pixel_format_ctor_l6v5u5(desc, v17);
                  goto LABEL_105;
                }
              }
              else if ( operator new(0x106Cu) )
              {
                v3 = grim_pixel_format_ctor_v8u8(desc, v17);
                goto LABEL_105;
              }
            }
            else if ( operator new(0x106Cu) )
            {
              v3 = grim_pixel_format_ctor_a4l4(desc, v17);
              goto LABEL_105;
            }
          }
          else if ( operator new(0x106Cu) )
          {
            v3 = grim_pixel_format_ctor_a8l8(desc, v17);
            goto LABEL_105;
          }
        }
        else if ( operator new(0x106Cu) )
        {
          v3 = grim_pixel_format_ctor_l8(desc, v17);
          goto LABEL_105;
        }
      }
      else if ( operator new(0x106Cu) )
      {
        v3 = grim_pixel_format_ctor_p8(desc, v17);
        goto LABEL_105;
      }
    }
LABEL_104:
    v3 = 0;
    goto LABEL_105;
  }
  if ( v1 == 40 )
  {
    if ( operator new(0x106Cu) )
    {
      v3 = grim_pixel_format_ctor_a8p8(desc, v17);
LABEL_105:
      v2 = v3;
      if ( v3 && v3[4] )
        (*(void (__thiscall **)(_DWORD *))(*v3 + 12))(v3);
      return v2;
    }
    goto LABEL_104;
  }
  switch ( v1 )
  {
    case 20:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_r8g8b8(desc, v17);
      goto LABEL_105;
    case 21:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a8r8g8b8(desc, v17);
      goto LABEL_105;
    case 22:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_x8r8g8b8(desc, v17);
      goto LABEL_105;
    case 23:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_r5g6b5(desc, v17);
      goto LABEL_105;
    case 24:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_x1r5g5b5(desc, v17);
      goto LABEL_105;
    case 25:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a1r5g5b5(desc, v17);
      goto LABEL_105;
    case 26:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a4r4g4b4(desc, v17);
      goto LABEL_105;
    case 27:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_r3g3b2(desc, v17);
      goto LABEL_105;
    case 28:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a8(desc, v17);
      goto LABEL_105;
    case 29:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a8r3g3b2(desc, v17);
      goto LABEL_105;
    case 30:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_x4r4g4b4(desc, v17);
      goto LABEL_105;
    case 31:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_a2b10g10r10(desc, v17);
      goto LABEL_105;
    case 34:
      if ( !operator new(0x106Cu) )
        goto LABEL_104;
      v3 = grim_pixel_format_ctor_g16r16(desc, v17);
      goto LABEL_105;
    default:
      return v2;
  }
  return v2;
}

// FUN_1001bc84 @ 0x1001BC84
// [binja] void*** __thiscall sub_1001bc84(void*** arg1, char arg2)
void ***FUN_1001bc84(void ***arg1, char arg2)
{
  int v2; // ecx
  void *v3; // esi

  v3 = (void *)v2;
  j_FUN_1001b493(v2);
  if ( ((unsigned __int8)arg1 & 1) != 0 )
    operator delete(v3);
  return (void ***)v3;
}

// FUN_1001bca5 @ 0x1001BCA5
// [binja] int32_t* __fastcall sub_1001bca5(int32_t* arg1)
int *FUN_1001bca5(int *arg1)
{
  int *v1; // ecx

  *v1 = -1;
  v1[1] = -1;
  v1[2] = 0;
  v1[3] = 0;
  return v1;
}

// FUN_1001bcb7 @ 0x1001BCB7
// [binja] int32_t __thiscall sub_1001bcb7(int32_t* arg1, int32_t* arg2, int32_t* arg3)
int FUN_1001bcb7(int *arg1, int *arg2, int *arg3)
{
  int v3; // ecx
  int v4; // edi
  void *v6; // esp
  HANDLE FileW; // eax
  HANDLE FileMappingA; // eax
  LPVOID v9; // eax
  DWORD FileSize; // eax
  CHAR v11[12]; // [esp+0h] [ebp-34h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-28h] BYREF
  int cbMultiByte; // [esp+A0h] [ebp+6Ch]

  v4 = v3;
  if ( !arg1 )
    return -2005530516;
  if ( !arg2 )
    goto LABEL_8;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwPlatformId != 2 )
  {
    cbMultiByte = WideCharToMultiByte(0, 0, (LPCWCH)arg1, -1, 0, 0, 0, 0);
    v6 = alloca(cbMultiByte);
    WideCharToMultiByte(0, 0, (LPCWCH)arg1, -1, v11, cbMultiByte, 0, 0);
    arg1 = (int *)v11;
    arg2 = 0;
  }
  if ( arg2 )
    FileW = CreateFileW((LPCWSTR)arg1, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
  else
LABEL_8:
    FileW = CreateFileA((LPCSTR)arg1, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
  *(_DWORD *)v4 = FileW;
  if ( FileW != (HANDLE)-1 )
  {
    FileMappingA = CreateFileMappingA(FileW, 0, 2u, 0, 0, 0);
    *(_DWORD *)(v4 + 4) = FileMappingA;
    if ( FileMappingA != (HANDLE)-1 )
    {
      v9 = MapViewOfFile(FileMappingA, 4u, 0, 0, 0);
      *(_DWORD *)(v4 + 8) = v9;
      if ( v9 )
      {
        FileSize = GetFileSize(*(HANDLE *)v4, 0);
        *(_DWORD *)(v4 + 12) = FileSize;
        if ( FileSize != -1 )
          return 0;
      }
    }
  }
  GetLastError();
  return -2005529767;
}

// FUN_1001bdc7 @ 0x1001BDC7
// [binja] int32_t __thiscall sub_1001bdc7(void** arg1, int32_t arg2, int32_t* arg3)
int FUN_1001bdc7(void **arg1, int arg2, int *arg3)
{
  _DWORD *v3; // ecx
  void **v4; // ebx
  _DWORD *v5; // edi
  void *v7; // esp
  HANDLE FileW; // eax
  CHAR v9[12]; // [esp+0h] [ebp-34h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-28h] BYREF
  _DWORD *v11; // [esp+A0h] [ebp+6Ch]
  LPCWCH lpWideCharStr; // [esp+ACh] [ebp+78h]

  v4 = arg1;
  v5 = v3;
  v11 = v3;
  if ( !arg1 )
    return -2005530516;
  if ( !arg2 )
    goto LABEL_8;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwPlatformId != 2 )
  {
    lpWideCharStr = (LPCWCH)WideCharToMultiByte(0, 0, (LPCWCH)arg1, -1, 0, 0, 0, 0);
    v7 = alloca((int)lpWideCharStr);
    WideCharToMultiByte(0, 0, (LPCWCH)v4, -1, v9, (int)lpWideCharStr, 0, 0);
    v4 = (void **)v9;
    v5 = v11;
    arg2 = 0;
  }
  if ( arg2 )
    FileW = CreateFileW((LPCWSTR)v4, 0x40000000u, 0, 0, 2u, 0, 0);
  else
LABEL_8:
    FileW = CreateFileA((LPCSTR)v4, 0x40000000u, 0, 0, 2u, 0, 0);
  *v5 = FileW;
  if ( FileW != (HANDLE)-1 )
    return 0;
  GetLastError();
  return -2005529767;
}

// FUN_1001bed2 @ 0x1001BED2
// [binja] void __fastcall sub_1001bed2(int32_t* arg1)
void FUN_1001bed2(int *arg1)
{
  HANDLE *v1; // esi
  HANDLE v2; // eax
  HANDLE *v3; // ecx

  if ( *v3 != (HANDLE)-1 )
  {
    v1 = v3;
    v2 = v3[2];
    if ( v2 )
    {
      UnmapViewOfFile(v2);
      v1[2] = 0;
      v1[3] = 0;
    }
    if ( v1[1] != (HANDLE)-1 )
    {
      CloseHandle(v1[1]);
      v1[1] = (HANDLE)-1;
    }
    if ( *v1 != (HANDLE)-1 )
    {
      CloseHandle(*v1);
      *v1 = (HANDLE)-1;
    }
  }
}

// sub_1001BEDD @ 0x1001BEDD
BOOL __cdecl sub_1001BEDD(int a1, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData)
{
  LSTATUS v4; // esi
  BOOL result; // eax
  DWORD Type; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  phkResult = 0;
  result = 0;
  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Direct3D", &phkResult) )
  {
    v4 = RegQueryValueExA(phkResult, lpValueName, 0, &Type, lpData, &cbData);
    RegCloseKey(phkResult);
    if ( !v4 && Type == a1 )
      return 1;
  }
  return result;
}

// FUN_1001bf39 @ 0x1001BF39
// [binja] int32_t __fastcall sub_1001bf39(int32_t arg1)
int FUN_1001bf39(int arg1)
{
  _EAX = 1;
  __asm { cpuid }
  return (_EDX & 0x800000) != 0;
}

// sub_1001BF5E @ 0x1001BF5E
int sub_1001BF5E()
{
  int v1; // [esp+0h] [ebp-14h]
  BYTE Data[4]; // [esp+4h] [ebp-10h] BYREF
  DWORD Type; // [esp+8h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+Ch] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-4h] BYREF

  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Direct3D", &phkResult) )
  {
    cbData = 4;
    if ( !RegQueryValueExA(phkResult, "DisableMMX", 0, &Type, Data, &cbData) && Type == 4 && *(_DWORD *)Data )
    {
      RegCloseKey(phkResult);
      dword_10054498 = 0;
      return 0;
    }
    RegCloseKey(phkResult);
  }
  if ( dword_10054498 < 0 )
  {
    dword_10054498 = 0;
    if ( FUN_1001bf39(v1) )
    {
      _m_empty();
      dword_10054498 = 1;
    }
  }
  return dword_10054498;
}

// FUN_1001bff7 @ 0x1001BFF7
// [binja] int32_t __fastcall sub_1001bff7(int32_t arg1)
int FUN_1001bff7(int arg1)
{
  int v12; // [esp+Ch] [ebp-4h]

  v12 = 0;
  _EAX = 0x80000000;
  __asm { cpuid }
  if ( _EAX >= 0x80000001 )
  {
    _EAX = -2147483647;
    __asm { cpuid }
    return _EDX < 0;
  }
  return v12;
}

// FUN_1001c02f @ 0x1001C02F
// [binja] int32_t __fastcall sub_1001c02f(int32_t arg1)
int FUN_1001c02f(int arg1)
{
  _DWORD v12[7]; // [esp-Ch] [ebp-48h] BYREF
  int v13; // [esp+10h] [ebp-2Ch]
  int v14; // [esp+14h] [ebp-28h]
  char v15[16]; // [esp+18h] [ebp-24h] BYREF
  int v16; // [esp+28h] [ebp-14h]
  _DWORD *v17; // [esp+2Ch] [ebp-10h]
  int v18; // [esp+38h] [ebp-4h]

  v17 = v12;
  v16 = 0;
  strcpy(v15, "GenuineIntel");
  _EAX = 0;
  __asm { cpuid }
  v13 = _EAX;
  v12[4] = _EBX;
  v12[5] = _EDX;
  v12[6] = _ECX;
  v18 = -1;
  if ( !_EAX )
    return v16;
  _EAX = 1;
  __asm { cpuid }
  v13 = _EAX;
  v14 = _EDX;
  if ( (_EDX & 0x2000000) != 0 )
    v16 |= 4u;
  if ( (v14 & 0x4000000) != 0 )
    return v16 | 8;
  return v16;
}

// sub_1001C0D4 @ 0x1001C0D4
int __cdecl sub_1001C0D4(DWORD ProcessorFeature)
{
  char v1; // bl
  int v3; // [esp+0h] [ebp-2Ch]
  struct _OSVERSIONINFOA VersionInformation; // [esp+8h] [ebp-24h] BYREF
  char v5; // [esp+9Fh] [ebp+73h]

  memset(&VersionInformation, 0, sizeof(VersionInformation));
  v1 = 0;
  v5 = 0;
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
  {
    v1 = 1;
    v5 = 1;
  }
  if ( VersionInformation.dwPlatformId == 1 )
  {
    if ( VersionInformation.dwMajorVersion <= 4
      && (VersionInformation.dwMajorVersion != 4
       || VersionInformation.dwMinorVersion < 0xA
       || LOWORD(VersionInformation.dwBuildNumber) < 0x55Du) )
    {
      v5 = 1;
    }
    goto LABEL_11;
  }
  if ( VersionInformation.dwPlatformId != 2 )
    return 0;
  if ( v1 )
  {
LABEL_11:
    if ( ProcessorFeature != 6 )
    {
      if ( ProcessorFeature == 7 )
        return FUN_1001bff7(v3);
      if ( ProcessorFeature != 10 || v5 )
        return 0;
      return FUN_1001c02f(v3) & 8;
    }
    if ( !v5 )
      return FUN_1001c02f(v3) & 4;
    return 0;
  }
  if ( ProcessorFeature != 10 )
    return IsProcessorFeaturePresent(ProcessorFeature);
  return FUN_1001c02f(v3) & 8;
}

// grim_select_renderer_backend @ 0x1001C188
// copies the render backend vtable and selects D3DX/alt paths based on config
int grim_select_renderer_backend(int force)
{
  if ( force )
  {
    if ( dword_1005449C == 0xFFFF )
    {
      dword_1005449C = 0;
      qmemcpy(&table, &off_10053D40, 0xE4u);
      sub_10022B47((float *(__stdcall **)(float *, float *, float *))&table);
      if ( !sub_1001BEDD(4, "DisableD3DXPSGP", (LPBYTE)&force, 4u) )
        force = 0;
      if ( force != 1 )
      {
        if ( sub_1001C0D4(7u) )
        {
          grim_init_mmx_sse_functions((unsigned int *)&table);
          dword_1005449C = 1;
        }
        else if ( sub_1001C0D4(0xAu) )
        {
          sub_100222E0((__m128 *(__stdcall **)(__m128 *, unsigned int *, __m128 *))&table);
          dword_1005449C = 2;
        }
        else if ( sub_1001C0D4(6u) )
        {
          sub_100221D0((__m128 *(__stdcall **)(__m128 *, unsigned int *, __m128 *))&table);
          dword_1005449C = 3;
        }
      }
    }
  }
  else
  {
    dword_1005449C = 0xFFFF;
    qmemcpy(&table, &off_10053D40, 0xE4u);
  }
  return dword_1005449C;
}

// sub_1001C265 @ 0x1001C265
int __cdecl sub_1001C265(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax
  int v7; // [esp+0h] [ebp-8h]

  a1[1] = 0;
  if ( a2 != 61 )
  {
    *(_DWORD *)(*a1 + 20) = 10;
    *(_DWORD *)(*a1 + 24) = 61;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 424 )
  {
    *(_DWORD *)(*a1 + 20) = 19;
    *(_DWORD *)(*a1 + 24) = 424;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  memset(a1, 0, 0x1A8u);
  *a1 = v3;
  *((_BYTE *)a1 + 12) = 1;
  sub_10023AEF(a1);
  a1[2] = 0;
  a1[5] = 0;
  a1[36] = 0;
  a1[37] = 0;
  a1[38] = 0;
  a1[39] = 0;
  v4 = 4;
  v5 = a1 + 44;
  do
  {
    *(v5 - 4) = 0;
    *v5++ = 0;
    --v4;
  }
  while ( v4 );
  sub_1001DE99((int)a1);
  result = sub_10023139((int)a1);
  if ( byte_100554E8 == 2 )
  {
    result = FUN_10022c2f(v7);
    byte_100554E8 = result;
  }
  a1[4] = 200;
  return result;
}

// sub_1001C32A @ 0x1001C32A
int __usercall sub_1001C32A@<eax>(int a1@<esi>)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax

  switch ( *(_DWORD *)(a1 + 32) )
  {
    case 1:
      *(_DWORD *)(a1 + 36) = 1;
      *(_DWORD *)(a1 + 40) = 1;
      break;
    case 3:
      if ( *(_BYTE *)(a1 + 256) )
        goto LABEL_17;
      if ( *(_BYTE *)(a1 + 262) )
      {
        if ( !*(_BYTE *)(a1 + 263) )
        {
          *(_DWORD *)(a1 + 36) = 2;
          goto LABEL_24;
        }
        if ( *(_BYTE *)(a1 + 263) != 1 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
LABEL_17:
        *(_DWORD *)(a1 + 36) = 3;
LABEL_24:
        *(_DWORD *)(a1 + 40) = 2;
        break;
      }
      v1 = *(int **)(a1 + 196);
      v2 = *v1;
      v3 = v1[21];
      v4 = v1[42];
      if ( *v1 == 1 )
      {
        if ( v3 == 2 && v4 == 3 )
          goto LABEL_23;
      }
      else if ( v2 == 82 && v3 == 71 && v4 == 66 )
      {
        *(_DWORD *)(a1 + 36) = 2;
        goto LABEL_24;
      }
      v5 = (_DWORD *)(*(_DWORD *)a1 + 24);
      *v5 = v2;
      v5[1] = v3;
      v5[2] = v4;
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 107;
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
LABEL_23:
      *(_DWORD *)(a1 + 36) = 3;
      goto LABEL_24;
    case 4:
      if ( *(_BYTE *)(a1 + 262) && *(_BYTE *)(a1 + 263) )
      {
        if ( *(_BYTE *)(a1 + 263) != 2 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 36) = 5;
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 4;
      }
      *(_DWORD *)(a1 + 40) = 4;
      break;
    default:
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 40) = 0;
      break;
  }
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  *(double *)(a1 + 56) = 1.0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 74) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 89) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  *(_DWORD *)(a1 + 44) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 73) = 1;
  *(_DWORD *)(a1 + 76) = 2;
  *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 256;
  return 1;
}

// sub_1001C49D @ 0x1001C49D
int __cdecl sub_1001C49D(_DWORD *a1)
{
  int v1; // eax
  int v2; // edi

  v1 = a1[4];
  v2 = 0;
  switch ( v1 )
  {
    case 200:
      (*(void (__cdecl **)(_DWORD *))(a1[99] + 4))(a1);
      (*(void (__cdecl **)(_DWORD *))(a1[5] + 8))(a1);
      a1[4] = 201;
      break;
    case 201:
      break;
    case 202:
      return 1;
    default:
      if ( v1 > 202 && (v1 <= 208 || v1 == 210) )
        return (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
      *(_DWORD *)(*a1 + 20) = 18;
      *(_DWORD *)(*a1 + 24) = a1[4];
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      return v2;
  }
  v2 = (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
  if ( v2 == 1 )
  {
    sub_1001C32A((int)a1);
    a1[4] = 202;
  }
  return v2;
}

// sub_1001C537 @ 0x1001C537
char __cdecl sub_1001C537(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( (v1 == 205 || v1 == 206) && !*(_BYTE *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 120) < *(_DWORD *)(a1 + 96) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 66;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 == 207 )
  {
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 != 210 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  do
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 17) )
    {
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 20) + 24))(a1);
      sub_10023BA3(a1);
      return 1;
    }
  }
  while ( (**(int (__cdecl ***)(int))(a1 + 396))(a1) );
  return 0;
}

// sub_1001C5DE @ 0x1001C5DE
int __cdecl sub_1001C5DE(_DWORD *a1, char a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[4];
  if ( v2 != 200 && v2 != 201 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*a1 + 24) = a1[4];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1001C49D(a1);
  if ( result == 1 )
    return 1;
  if ( result == 2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(*a1 + 20) = 50;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_10023BA3(a1);
    return 2;
  }
  return result;
}

// sub_1001C641 @ 0x1001C641
char __usercall sub_1001C641@<al>(int a1@<esi>)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // ebp

  if ( *(_DWORD *)(a1 + 16) != 204 )
  {
    (**(void (__cdecl ***)(int))(a1 + 380))(a1);
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 16) = 204;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
  {
    v1 = (unsigned int *)(a1 + 120);
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 < *(_DWORD *)(a1 + 96) )
        break;
LABEL_10:
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
      (**(void (__cdecl ***)(int))(a1 + 380))(a1);
      *v1 = 0;
      if ( !*(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = v2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 96);
        (**(void (__cdecl ***)(int))(a1 + 8))(a1);
      }
      v4 = *v1;
      (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(*(_DWORD *)(a1 + 384) + 4))(a1, 0, a1 + 120, 0);
      v2 = *v1;
      if ( *v1 == v4 )
        return 0;
      if ( v2 >= *(_DWORD *)(a1 + 96) )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_11:
    *(_DWORD *)(a1 + 16) = (*(_BYTE *)(a1 + 65) != 0) + 205;
    return 1;
  }
}

// sub_1001C6EA @ 0x1001C6EA
_DWORD *__cdecl sub_1001C6EA(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // eax
  int v7; // eax

  v3 = a1;
  if ( a1[4] != 205 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*v3 + 24) = v3[4];
    (*(void (__cdecl **)(_DWORD *))*v3)(v3);
  }
  v4 = v3[30];
  if ( v4 < v3[24] )
  {
    v6 = v3[2];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = v4;
      *(_DWORD *)(v3[2] + 8) = v3[24];
      (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
    }
    v7 = v3[96];
    a1 = 0;
    (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, a3);
    result = a1;
    v3[30] += a1;
  }
  else
  {
    *(_DWORD *)(*v3 + 20) = 119;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
    return 0;
  }
  return result;
}

// sub_1001C76E @ 0x1001C76E
char __cdecl sub_1001C76E(int a1)
{
  int v2; // eax
  void (__cdecl **v3)(int); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx

  if ( *(_DWORD *)(a1 + 16) == 202 )
  {
    sub_100241E2(a1);
    if ( *(_BYTE *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 16) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 16) = 203;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 != 203 )
  {
    if ( v2 != 204 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    return sub_1001C641(a1);
  }
  if ( !*(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) )
  {
LABEL_17:
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 124);
    return sub_1001C641(a1);
  }
  while ( 1 )
  {
    v3 = *(void (__cdecl ***)(int))(a1 + 8);
    if ( v3 )
      (*v3)(a1);
    v4 = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
    if ( !v4 )
      return 0;
    if ( v4 == 2 )
      goto LABEL_17;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 && (v4 == 3 || v4 == 1) )
    {
      ++*(_DWORD *)(v5 + 4);
      v6 = *(_DWORD *)(a1 + 8);
      v7 = *(_DWORD *)(v6 + 8);
      if ( *(_DWORD *)(v6 + 4) >= v7 )
        *(_DWORD *)(v6 + 8) = v7 + *(_DWORD *)(a1 + 280);
    }
  }
}

// sub_1001C82F @ 0x1001C82F
char __usercall sub_1001C82F@<al>(int a1@<esi>)
{
  _BYTE *v1; // eax
  int v2; // ecx
  int v3; // eax

  *(_DWORD *)(*(_DWORD *)a1 + 20) = 101;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 80) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 60;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = (_BYTE *)(a1 + 218);
  v2 = 16;
  do
  {
    *(v1 - 16) = 0;
    *v1 = 1;
    v1[16] = 5;
    ++v1;
    --v2;
  }
  while ( v2 );
  v3 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 262) = 0;
  *(_BYTE *)(a1 + 263) = 0;
  *(_WORD *)(a1 + 258) = 1;
  *(_WORD *)(a1 + 260) = 1;
  *(_BYTE *)(v3 + 80) = 1;
  return 1;
}

// sub_1001C8BD @ 0x1001C8BD
char __usercall sub_1001C8BD@<al>(char a1@<cl>, int a2@<esi>, char a3)
{
  unsigned __int8 **v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int16 v6; // ax
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // edi
  unsigned __int16 v11; // ax
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // edi
  unsigned __int16 v14; // ax
  unsigned __int8 *v15; // edi
  unsigned __int8 *v16; // edi
  int v17; // ecx
  _DWORD *v18; // eax
  unsigned __int8 *v19; // edi
  _DWORD *v20; // eax
  int v22; // ecx
  unsigned __int8 *v23; // edi
  int v24; // ecx
  unsigned __int8 *v25; // edi
  int v26; // edx
  _DWORD *v27; // ecx
  int v28; // [esp+8h] [ebp-8h]
  unsigned __int8 *v29; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v30; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v31; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v32; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v33; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v34; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v35; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v36; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v37; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v38; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v39; // [esp+Ch] [ebp-4h]
  int v40; // [esp+18h] [ebp+8h]
  int v41; // [esp+18h] [ebp+8h]
  int v42; // [esp+18h] [ebp+8h]
  _DWORD *v43; // [esp+18h] [ebp+8h]

  v3 = *(unsigned __int8 ***)(a2 + 20);
  v4 = v3[1];
  v5 = *v3;
  *(_BYTE *)(a2 + 200) = a1;
  v29 = v4;
  *(_BYTE *)(a2 + 201) = a3;
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v5 = *v3;
    v29 = v3[1];
  }
  v30 = v29 - 1;
  LOBYTE(v6) = 0;
  HIBYTE(v6) = *v5;
  v7 = v5 + 1;
  v40 = v6;
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v7 = *v3;
    v30 = v3[1];
  }
  v31 = v30 - 1;
  v41 = *v7 + v40;
  v8 = v7 + 1;
  if ( !v31 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v8 = *v3;
    v31 = v3[1];
  }
  v9 = *v8;
  v32 = v31 - 1;
  v10 = v8 + 1;
  *(_DWORD *)(a2 + 192) = v9;
  if ( !v32 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v10 = *v3;
    v32 = v3[1];
  }
  v33 = v32 - 1;
  LOBYTE(v11) = 0;
  HIBYTE(v11) = *v10;
  v12 = v10 + 1;
  *(_DWORD *)(a2 + 28) = v11;
  if ( !v33 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v12 = *v3;
    v33 = v3[1];
  }
  v34 = v33 - 1;
  *(_DWORD *)(a2 + 28) += *v12;
  v13 = v12 + 1;
  if ( !v34 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v13 = *v3;
    v34 = v3[1];
  }
  v35 = v34 - 1;
  LOBYTE(v14) = 0;
  HIBYTE(v14) = *v13;
  v15 = v13 + 1;
  *(_DWORD *)(a2 + 24) = v14;
  if ( !v35 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v15 = *v3;
    v35 = v3[1];
  }
  v36 = v35 - 1;
  *(_DWORD *)(a2 + 24) += *v15;
  v16 = v15 + 1;
  if ( !v36 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
    {
      v16 = *v3;
      v36 = v3[1];
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v17 = *(_DWORD *)(a2 + 376);
  v37 = v36 - 1;
  v42 = v41 - 8;
  *(_DWORD *)(a2 + 32) = *v16;
  v18 = (_DWORD *)(*(_DWORD *)a2 + 24);
  *v18 = v17;
  v18[1] = *(_DWORD *)(a2 + 24);
  v18[2] = *(_DWORD *)(a2 + 28);
  v18[3] = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(*(_DWORD *)a2 + 20) = 99;
  v19 = v16 + 1;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 4))(a2, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 400) + 81) )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 57;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( !*(_DWORD *)(a2 + 28) || !*(_DWORD *)(a2 + 24) || *(int *)(a2 + 32) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 31;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( v42 != 3 * *(_DWORD *)(a2 + 32) )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 9;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( !*(_DWORD *)(a2 + 196) )
    *(_DWORD *)(a2 + 196) = (**(int (__cdecl ***)(int, int, int))(a2 + 4))(a2, 1, 84 * *(_DWORD *)(a2 + 32));
  v28 = 0;
  v20 = *(_DWORD **)(a2 + 196);
  v43 = v20;
  if ( *(int *)(a2 + 32) > 0 )
  {
    while ( 1 )
    {
      v20[1] = v28;
      if ( !v37 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v19 = *v3;
        v37 = v3[1];
        v20 = v43;
      }
      v22 = *v19;
      v38 = v37 - 1;
      v23 = v19 + 1;
      *v20 = v22;
      if ( !v38 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v23 = *v3;
        v38 = v3[1];
        v20 = v43;
      }
      v24 = *v23;
      v39 = v38 - 1;
      v25 = v23 + 1;
      v20[2] = (v24 >> 4) & 0xF;
      v20[3] = v24 & 0xF;
      if ( !v39 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v25 = *v3;
        v39 = v3[1];
        v20 = v43;
      }
      v26 = *v20;
      v37 = v39 - 1;
      v20[4] = *v25;
      v27 = (_DWORD *)(*(_DWORD *)a2 + 24);
      *v27 = v26;
      v27[1] = v20[2];
      v27[2] = v20[3];
      v27[3] = v20[4];
      *(_DWORD *)(*(_DWORD *)a2 + 20) = 100;
      v19 = v25 + 1;
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 4))(a2, 1);
      ++v28;
      v43 += 21;
      if ( v28 >= *(_DWORD *)(a2 + 32) )
        break;
      v20 = v43;
    }
  }
  *(_BYTE *)(*(_DWORD *)(a2 + 400) + 81) = 1;
  v3[1] = v37;
  *v3 = v19;
  return 1;
}

// sub_1001CBB8 @ 0x1001CBB8
char __usercall sub_1001CBB8@<al>(_DWORD *a1@<esi>)
{
  unsigned __int8 **v1; // ebx
  unsigned __int8 *v2; // edi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // edi
  unsigned __int8 *v5; // edi
  int v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  unsigned __int8 *v9; // edi
  int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  int v13; // eax
  unsigned __int8 *v14; // edi
  int v15; // eax
  unsigned __int8 *v16; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  int v20; // [esp+8h] [ebp-20h]
  _DWORD *v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  _DWORD *v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  int v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+20h] [ebp-8h]
  int v28; // [esp+20h] [ebp-8h]
  unsigned __int8 *v29; // [esp+24h] [ebp-4h]
  unsigned __int8 *v30; // [esp+24h] [ebp-4h]
  unsigned __int8 *v31; // [esp+24h] [ebp-4h]
  unsigned __int8 *v32; // [esp+24h] [ebp-4h]
  unsigned __int8 *v33; // [esp+24h] [ebp-4h]
  unsigned __int8 *v34; // [esp+24h] [ebp-4h]
  unsigned __int8 *v35; // [esp+24h] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v29 = v1[1];
  v2 = *v1;
  if ( !*(_BYTE *)(a1[100] + 81) )
  {
    *(_DWORD *)(*a1 + 20) = 61;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v29 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v29 = v1[1];
  }
  v30 = v29 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v26 = v3;
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v4 = *v1;
    v30 = v1[1];
  }
  v31 = v30 - 1;
  v27 = *v4 + v26;
  v5 = v4 + 1;
  if ( !v31 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v5 = *v1;
    v31 = v1[1];
  }
  v6 = *v5;
  v32 = v31 - 1;
  v7 = v5 + 1;
  v22 = v6;
  if ( v27 != 2 * v6 + 6 || v6 < 1 || v6 > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v6 = v22;
  }
  *(_DWORD *)(*a1 + 20) = 102;
  *(_DWORD *)(*a1 + 24) = v6;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v23 = 0;
  a1[72] = v22;
  if ( v22 > 0 )
  {
    v24 = a1 + 73;
    do
    {
      if ( !v32 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
          return 0;
        v7 = *v1;
        v32 = v1[1];
      }
      v8 = *v7;
      v33 = v32 - 1;
      v9 = v7 + 1;
      v25 = v8;
      if ( !v33 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
          return 0;
        v9 = *v1;
        v33 = v1[1];
      }
      v10 = *v9;
      v32 = v33 - 1;
      v28 = 0;
      v11 = (_DWORD *)a1[49];
      v7 = v9 + 1;
      v20 = v10;
      v21 = v11;
      if ( (int)a1[8] <= 0 )
      {
LABEL_27:
        *(_DWORD *)(*a1 + 20) = 5;
        *(_DWORD *)(*a1 + 24) = v25;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        v10 = v20;
        v11 = v21;
      }
      else
      {
        while ( v25 != *v11 )
        {
          ++v28;
          v11 += 21;
          v21 = v11;
          if ( v28 >= a1[8] )
            goto LABEL_27;
        }
      }
      *v24 = v11;
      v11[6] = v10 & 0xF;
      v11[5] = (v10 >> 4) & 0xF;
      v12 = (_DWORD *)(*a1 + 24);
      *v12 = v25;
      v12[1] = v11[5];
      v12[2] = v11[6];
      *(_DWORD *)(*a1 + 20) = 103;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      ++v23;
      ++v24;
    }
    while ( v23 < v22 );
  }
  if ( !v32 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v7 = *v1;
    v32 = v1[1];
  }
  v13 = *v7;
  v34 = v32 - 1;
  v14 = v7 + 1;
  a1[90] = v13;
  if ( v34 )
    goto LABEL_35;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v14 = *v1;
  v34 = v1[1];
LABEL_35:
  v15 = *v14;
  v35 = v34 - 1;
  v16 = v14 + 1;
  a1[91] = v15;
  if ( !v35 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v16 = *v1;
    v35 = v1[1];
  }
  v18 = (int)*v16 >> 4;
  a1[93] = *v16 & 0xF;
  v19 = (_DWORD *)*a1;
  a1[92] = v18 & 0xF;
  v19 += 6;
  *v19 = a1[90];
  v19[1] = a1[91];
  v19[2] = a1[92];
  v19[3] = a1[93];
  *(_DWORD *)(*a1 + 20) = 104;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *(_DWORD *)(a1[100] + 84) = 0;
  ++a1[31];
  v1[1] = v35 - 1;
  *v1 = v16 + 1;
  return 1;
}

// sub_1001CE6A @ 0x1001CE6A
char __cdecl sub_1001CE6A(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  int v8; // ecx
  bool v9; // cc
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 v13; // ax
  unsigned __int16 v14; // cx
  __int16 v15; // ax
  _DWORD *v16; // eax
  int v17; // eax
  int v18; // ecx
  _BYTE v19[5]; // [esp+Ch] [ebp-18h]
  unsigned __int8 v20; // [esp+11h] [ebp-13h]
  unsigned __int8 v21; // [esp+12h] [ebp-12h]
  char v22; // [esp+13h] [ebp-11h]
  unsigned __int8 v23; // [esp+14h] [ebp-10h]
  unsigned __int8 v24; // [esp+15h] [ebp-Fh]
  unsigned __int8 v25; // [esp+16h] [ebp-Eh]
  unsigned __int8 v26; // [esp+17h] [ebp-Dh]
  __int16 v27; // [esp+18h] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-8h]
  int v29; // [esp+20h] [ebp-4h]
  unsigned __int8 *v30; // [esp+2Ch] [ebp+8h]
  unsigned __int8 *v31; // [esp+2Ch] [ebp+8h]
  unsigned __int8 *v32; // [esp+2Ch] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v30 = v2[1];
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v30 = v2[1];
  }
  v31 = v30 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v29 = v4;
  if ( v31 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v5 = *v2;
  v31 = v2[1];
LABEL_7:
  v32 = v31 - 1;
  v29 = *v5 + v29 - 2;
  v6 = v5 + 1;
  if ( v29 < 14 )
  {
    v18 = v29;
    *(_DWORD *)(*a1 + 20) = 76;
    *(_DWORD *)(*a1 + 24) = v18;
  }
  else
  {
    v28 = 0;
    do
    {
      if ( !v32 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v6 = *v2;
        v32 = v2[1];
      }
      --v32;
      v7 = *v6;
      v8 = v28;
      ++v6;
      v9 = ++v28 < 14;
      v19[v8] = v7;
    }
    while ( v9 );
    v29 -= 14;
    if ( v19[0] == 74 && v19[1] == 70 && v19[2] == 73 && v19[3] == 70 && !v19[4] )
    {
      if ( v20 == 1 )
      {
        if ( v21 > 2u )
        {
          *(_DWORD *)(*a1 + 20) = 88;
          *(_DWORD *)(*a1 + 24) = 1;
          *(_DWORD *)(*a1 + 28) = v21;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 115;
        *(_DWORD *)(*a1 + 24) = v20;
        *(_DWORD *)(*a1 + 28) = v21;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
      }
      v11 = v24;
      v12 = v26;
      *((_BYTE *)a1 + 257) = v22;
      v13 = v23;
      *((_BYTE *)a1 + 256) = 1;
      v14 = (v13 << 8) + v11;
      v15 = v25;
      *((_WORD *)a1 + 129) = v14;
      *((_WORD *)a1 + 130) = v12 + (v15 << 8);
      v16 = (_DWORD *)(*a1 + 24);
      *v16 = v14;
      v16[1] = *((unsigned __int16 *)a1 + 130);
      v16[2] = *((unsigned __int8 *)a1 + 257);
      *(_DWORD *)(*a1 + 20) = 86;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      if ( v27 )
      {
        *(_DWORD *)(*a1 + 20) = 89;
        *(_DWORD *)(*a1 + 24) = (unsigned __int8)v27;
        *(_DWORD *)(*a1 + 28) = HIBYTE(v27);
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      }
      v17 = v29;
      if ( v29 == 3 * (unsigned __int8)v27 * HIBYTE(v27) )
        goto LABEL_31;
      *(_DWORD *)(*a1 + 20) = 87;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 76;
      v17 = v29 + 14;
    }
    *(_DWORD *)(*a1 + 24) = v17;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
LABEL_31:
  v9 = v29 <= 0;
  *v2 = v6;
  v2[1] = v32;
  if ( !v9 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v29);
  return 1;
}

// sub_1001D0A6 @ 0x1001D0A6
char __cdecl sub_1001D0A6(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  int v8; // ecx
  bool v9; // cc
  int v10; // edx
  _DWORD *v11; // eax
  int v12; // ecx
  int v13; // edx
  unsigned __int8 v14; // al
  int v16; // ecx
  _BYTE v17[11]; // [esp+Ch] [ebp-14h]
  unsigned __int8 v18; // [esp+17h] [ebp-9h]
  int v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v21; // [esp+28h] [ebp+8h]
  unsigned __int8 *v22; // [esp+28h] [ebp+8h]
  unsigned __int8 *v23; // [esp+28h] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v21 = v2[1];
  if ( !v21 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v21 = v2[1];
  }
  v22 = v21 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v20 = v4;
  if ( v22 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v5 = *v2;
  v22 = v2[1];
LABEL_7:
  v23 = v22 - 1;
  v20 = *v5 + v20 - 2;
  v6 = v5 + 1;
  if ( v20 < 12 )
  {
    v16 = v20;
    *(_DWORD *)(*a1 + 20) = 77;
    *(_DWORD *)(*a1 + 24) = v16;
    goto LABEL_22;
  }
  v19 = 0;
  do
  {
    if ( !v23 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v6 = *v2;
      v23 = v2[1];
    }
    --v23;
    v7 = *v6;
    v8 = v19;
    ++v6;
    v9 = ++v19 < 12;
    v17[v8] = v7;
  }
  while ( v9 );
  v20 -= 12;
  if ( v17[0] != 65 || v17[1] != 100 || v17[2] != 111 || v17[3] != 98 || v17[4] != 101 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    *(_DWORD *)(*a1 + 24) = v20 + 12;
LABEL_22:
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    goto LABEL_23;
  }
  v10 = v17[8];
  v11 = (_DWORD *)(*a1 + 24);
  *v11 = v17[6] + (v17[5] << 8);
  v12 = v10 + (v17[7] << 8);
  v13 = v17[10];
  v11[1] = v12;
  v11[2] = v13 + (v17[9] << 8);
  v11[3] = v18;
  *(_DWORD *)(*a1 + 20) = 75;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v14 = v18;
  *((_BYTE *)a1 + 262) = 1;
  *((_BYTE *)a1 + 263) = v14;
LABEL_23:
  v9 = v20 <= 0;
  *v2 = v6;
  v2[1] = v23;
  if ( !v9 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v20);
  return 1;
}

// sub_1001D220 @ 0x1001D220
char __usercall sub_1001D220@<al>(_DWORD *a1@<esi>)
{
  unsigned __int8 **v1; // ebx
  unsigned __int8 *v2; // edi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // edi
  unsigned __int8 *v5; // edi
  int v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  int v9; // eax
  int v11; // [esp+8h] [ebp-10h]
  int v12; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+10h] [ebp-8h]
  unsigned __int8 *v16; // [esp+14h] [ebp-4h]
  unsigned __int8 *v17; // [esp+14h] [ebp-4h]
  unsigned __int8 *v18; // [esp+14h] [ebp-4h]
  unsigned __int8 *v19; // [esp+14h] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v16 = v1[1];
  if ( !v16 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v16 = v1[1];
  }
  v17 = v16 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v13 = v3;
  if ( v17 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v4 = *v1;
  v17 = v1[1];
LABEL_7:
  v18 = v17 - 1;
  v14 = *v4 + v13;
  v5 = v4 + 1;
  v15 = v14 - 2;
  while ( v15 > 0 )
  {
    if ( !v18 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v5 = *v1;
      v18 = v1[1];
    }
    v6 = *v5;
    v19 = v18 - 1;
    v7 = v5 + 1;
    v12 = v6;
    if ( !v19 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v7 = *v1;
      v19 = v1[1];
    }
    v8 = *v7;
    v18 = v19 - 1;
    v15 -= 2;
    *(_DWORD *)(*a1 + 20) = 78;
    *(_DWORD *)(*a1 + 24) = v12;
    v11 = v8;
    *(_DWORD *)(*a1 + 28) = v8;
    v5 = v7 + 1;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    v9 = v12;
    if ( v12 >= 32 )
    {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = v12;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v9 = v12;
    }
    if ( v9 < 16 )
    {
      *((_BYTE *)a1 + v9 + 202) = v11 & 0xF;
      *((_BYTE *)a1 + v9 + 218) = v11 >> 4;
      if ( (unsigned __int8)(v11 & 0xF) > (unsigned __int8)(v11 >> 4) )
      {
        *(_DWORD *)(*a1 + 20) = 27;
        *(_DWORD *)(*a1 + 24) = v11;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      *((_BYTE *)a1 + v9 + 218) = v11;
    }
  }
  v1[1] = v18;
  *v1 = v5;
  return 1;
}

// sub_1001D377 @ 0x1001D377
char __usercall sub_1001D377@<al>(_DWORD *a1@<ebx>)
{
  int v1; // esi
  int v2; // eax
  char *v3; // edi
  unsigned __int16 v4; // ax
  char *v5; // edi
  int v6; // eax
  char *v7; // edi
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ecx
  unsigned __int8 *v11; // edi
  unsigned __int8 v12; // cl
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  int i; // edi
  char v16; // al
  unsigned int v17; // eax
  int *v18; // edi
  int v19; // edi
  int v20; // eax
  _BYTE v22[256]; // [esp+8h] [ebp-130h] BYREF
  unsigned int v23; // [esp+108h] [ebp-30h]
  int v24; // [esp+10Ch] [ebp-2Ch]
  int v25; // [esp+110h] [ebp-28h]
  int v26; // [esp+114h] [ebp-24h]
  int v27; // [esp+118h] [ebp-20h]
  int v28; // [esp+11Ch] [ebp-1Ch]
  unsigned __int8 v29; // [esp+120h] [ebp-18h]
  int v30; // [esp+124h] [ebp-14h]
  int v31; // [esp+128h] [ebp-10h]
  int v32; // [esp+12Ch] [ebp-Ch]
  char *v33; // [esp+130h] [ebp-8h]
  int v34; // [esp+134h] [ebp-4h]

  v1 = a1[5];
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(char **)v1;
  v24 = v1;
  v34 = v2;
  if ( !v2 )
  {
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
      return 0;
    v33 = *(char **)v1;
    v3 = v33;
    v34 = *(_DWORD *)(v1 + 4);
  }
  --v34;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v32 = v4;
  if ( v34 )
    goto LABEL_7;
  if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
    return 0;
  v33 = *(char **)v1;
  v5 = v33;
  v34 = *(_DWORD *)(v1 + 4);
LABEL_7:
  v6 = (unsigned __int8)*v5;
  --v34;
  v7 = v5 + 1;
  v32 = v6 + v32 - 2;
  while ( v32 > 0 )
  {
    if ( !v34 )
    {
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
        return 0;
      v33 = *(char **)v1;
      v7 = v33;
      v34 = *(_DWORD *)(v1 + 4);
    }
    v8 = (unsigned __int8)*v7;
    v9 = *a1;
    --v34;
    *(_DWORD *)(v9 + 20) = 79;
    v10 = *a1;
    v23 = v8;
    *(_DWORD *)(v10 + 24) = v8;
    v11 = (unsigned __int8 *)(v7 + 1);
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    LOBYTE(v25) = 0;
    v30 = 0;
    v31 = 1;
    do
    {
      if ( !v34 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
          return 0;
        v33 = *(char **)v1;
        v11 = (unsigned __int8 *)v33;
        v34 = *(_DWORD *)(v1 + 4);
      }
      v12 = *v11;
      --v34;
      *((_BYTE *)&v25 + v31) = v12;
      v30 += v12;
      ++v11;
      ++v31;
      v33 = (char *)v11;
    }
    while ( v31 <= 16 );
    v13 = (_DWORD *)(*a1 + 24);
    *v13 = BYTE1(v25);
    v13[1] = BYTE2(v25);
    v13[2] = HIBYTE(v25);
    v32 -= 17;
    v13[3] = (unsigned __int8)v26;
    v13[4] = BYTE1(v26);
    v13[5] = BYTE2(v26);
    v13[6] = HIBYTE(v26);
    v13[7] = (unsigned __int8)v27;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v14 = (_DWORD *)(*a1 + 24);
    *v14 = BYTE1(v27);
    v14[1] = BYTE2(v27);
    v14[2] = HIBYTE(v27);
    v14[3] = (unsigned __int8)v28;
    v14[4] = BYTE1(v28);
    v14[5] = BYTE2(v28);
    v14[6] = HIBYTE(v28);
    v14[7] = v29;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    if ( v30 > 256 || v30 > v32 )
    {
      *(_DWORD *)(*a1 + 20) = 28;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    for ( i = 0; i < v30; ++i )
    {
      if ( !v34 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
          return 0;
        v33 = *(char **)v1;
        v34 = *(_DWORD *)(v1 + 4);
      }
      --v34;
      v16 = *v33++;
      v22[i] = v16;
    }
    v32 -= v30;
    v17 = v23;
    if ( (v23 & 0x10) != 0 )
    {
      v17 = v23 - 16;
      v18 = &a1[v23 + 28];
      v31 = (int)v18;
    }
    else
    {
      v31 = (int)&a1[v23 + 40];
      v18 = (int *)v31;
    }
    if ( v17 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 29;
      *(_DWORD *)(*a1 + 24) = v17;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !*v18 )
      *v18 = sub_10023BFC(a1);
    v19 = *v18;
    v20 = v31;
    *(_DWORD *)v19 = v25;
    v19 += 4;
    *(_DWORD *)v19 = v26;
    v19 += 4;
    *(_DWORD *)v19 = v27;
    v19 += 4;
    *(_DWORD *)v19 = v28;
    *(_BYTE *)(v19 + 4) = v29;
    qmemcpy((void *)(*(_DWORD *)v20 + 17), v22, 0x100u);
    v7 = v33;
    v1 = v24;
  }
  *(_DWORD *)(v1 + 4) = v34;
  *(_DWORD *)v1 = v7;
  return 1;
}

// sub_1001D60B @ 0x1001D60B
char __usercall sub_1001D60B@<al>(_DWORD *a1@<ebx>)
{
  unsigned __int8 **v1; // edi
  unsigned __int8 *v2; // esi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // eax
  __int16 v11; // ax
  int *v12; // eax
  unsigned __int16 *v13; // ecx
  _DWORD *v14; // eax
  int v16; // [esp+8h] [ebp-18h]
  int v17; // [esp+Ch] [ebp-14h]
  int v18; // [esp+10h] [ebp-10h]
  _DWORD *v19; // [esp+10h] [ebp-10h]
  int *v20; // [esp+10h] [ebp-10h]
  unsigned __int16 *v21; // [esp+10h] [ebp-10h]
  __int16 v22; // [esp+14h] [ebp-Ch]
  __int16 v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-8h]
  int v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+18h] [ebp-8h]
  unsigned __int8 *v28; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v29; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v30; // [esp+1Ch] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v28 = v1[1];
  if ( !v28 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v28 = v1[1];
  }
  v29 = v28 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v25 = v3;
  if ( v29 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v4 = *v1;
  v29 = v1[1];
LABEL_7:
  v30 = v29 - 1;
  v26 = *v4 + v25;
  v5 = v4 + 1;
  v27 = v26 - 2;
  while ( v27 > 0 )
  {
    if ( !v30 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v5 = *v1;
      v30 = v1[1];
    }
    v6 = *v5;
    --v30;
    *(_DWORD *)(*a1 + 20) = 80;
    v7 = v6;
    v8 = v6 & 0xF;
    *(_DWORD *)(*a1 + 24) = v8;
    v18 = v8;
    v17 = v7 >> 4;
    *(_DWORD *)(*a1 + 28) = v7 >> 4;
    ++v5;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    v9 = v18;
    if ( v18 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 30;
      *(_DWORD *)(*a1 + 24) = v18;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v9 = v18;
    }
    v10 = &a1[v9 + 36];
    v19 = v10;
    if ( !*v10 )
    {
      *v10 = sub_10023BE0(a1);
      v10 = v19;
    }
    v16 = *v10;
    v20 = &dword_1004E8C0;
    do
    {
      if ( v17 )
      {
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        --v30;
        LOBYTE(v11) = 0;
        HIBYTE(v11) = *v5++;
        v22 = v11;
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        v23 = *v5 + v22;
      }
      else
      {
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        v23 = *v5;
      }
      v12 = v20;
      --v30;
      ++v20;
      ++v5;
      *(_WORD *)(v16 + 2 * *v12) = v23;
    }
    while ( (int)v20 < (int)dword_1004E9C0 );
    if ( *(int *)(*a1 + 104) >= 2 )
    {
      v13 = (unsigned __int16 *)(v16 + 4);
      v21 = (unsigned __int16 *)(v16 + 4);
      v24 = 8;
      while ( 1 )
      {
        v14 = (_DWORD *)(*a1 + 24);
        *v14 = *(v13 - 2);
        v14[1] = *(v13 - 1);
        v14[2] = *v13;
        v14[3] = v13[1];
        v14[4] = v13[2];
        v14[5] = v13[3];
        v14[6] = v13[4];
        v14[7] = v13[5];
        *(_DWORD *)(*a1 + 20) = 92;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
        v21 += 8;
        if ( !--v24 )
          break;
        v13 = v21;
      }
    }
    v27 -= 65;
    if ( v17 )
      v27 -= 64;
  }
  v1[1] = v30;
  *v1 = v5;
  return 1;
}

// sub_1001D834 @ 0x1001D834
char __cdecl sub_1001D834(int a1)
{
  int v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  unsigned __int16 v5; // cx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  unsigned __int16 v10; // cx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // edi
  int v14; // [esp+Ch] [ebp-4h]
  int v15; // [esp+Ch] [ebp-4h]
  int v16; // [esp+Ch] [ebp-4h]
  int v17; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = *(unsigned __int8 ***)(a1 + 20);
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
    v1 = a1;
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v14 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v1 = a1;
  }
  v15 = *v7 + v14;
  v8 = v6 - 1;
  v9 = v7 + 1;
  if ( v15 != 4 )
  {
    *(_DWORD *)(*(_DWORD *)v1 + 20) = 9;
    (**(void (__cdecl ***)(int))v1)(v1);
    v1 = a1;
  }
  if ( !v8 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
    {
      v9 = *v2;
      v8 = v2[1];
      v1 = a1;
      goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  LOBYTE(v10) = 0;
  HIBYTE(v10) = *v9;
  v11 = v8 - 1;
  v12 = v9 + 1;
  v16 = v10;
  if ( !v11 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
      return 0;
    v12 = *v2;
    v11 = v2[1];
    v1 = a1;
  }
  v17 = *v12 + v16;
  *(_DWORD *)(*(_DWORD *)v1 + 20) = 81;
  *(_DWORD *)(*(_DWORD *)v1 + 24) = v17;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)v1 + 4))(v1, 1);
  *(_DWORD *)(a1 + 252) = v17;
  *v2 = v12 + 1;
  v2[1] = v11 - 1;
  return 1;
}

// sub_1001D90B @ 0x1001D90B
char __cdecl sub_1001D90B(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  int v7; // [esp+Ch] [ebp-4h]
  int v8; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v9; // [esp+18h] [ebp+8h]
  unsigned __int8 *v10; // [esp+18h] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v9 = v2[1];
  if ( !v9 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v9 = v2[1];
  }
  v10 = v9 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v7 = v4;
  if ( !v10 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v5 = *v2;
    v10 = v2[1];
  }
  v8 = *v5 + v7;
  *(_DWORD *)(*a1 + 20) = 90;
  *(_DWORD *)(*a1 + 24) = a1[94];
  *(_DWORD *)(*a1 + 28) = v8;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *v2 = v5 + 1;
  v2[1] = v10 - 1;
  (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v8 - 2);
  return 1;
}

// sub_1001D9A7 @ 0x1001D9A7
char __cdecl sub_1001D9A7(_DWORD *a1)
{
  _DWORD *v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // ecx
  int v6; // ecx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  while ( 1 )
  {
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
        return 0;
      v1 = a1;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    --v3;
    ++v4;
    if ( v5 != 255 )
    {
      ++*(_DWORD *)(v1[100] + 88);
      goto LABEL_3;
    }
    do
    {
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
        v1 = a1;
      }
      v6 = *v4;
      --v3;
      ++v4;
      v8 = v6;
    }
    while ( v6 == 255 );
    if ( v6 )
      break;
    *(_DWORD *)(v1[100] + 88) += 2;
LABEL_3:
    *v2 = v4;
    v2[1] = v3;
  }
  if ( *(_DWORD *)(v1[100] + 88) )
  {
    *(_DWORD *)(*v1 + 20) = 112;
    *(_DWORD *)(*v1 + 24) = *(_DWORD *)(v1[100] + 88);
    *(_DWORD *)(*v1 + 28) = v6;
    (*(void (__cdecl **)(_DWORD *, int))(*v1 + 4))(v1, -1);
    *(_DWORD *)(a1[100] + 88) = 0;
    v1 = a1;
    v6 = v8;
  }
  v1[94] = v6;
  *v2 = v4;
  v2[1] = v3;
  return 1;
}

// sub_1001DA7E @ 0x1001DA7E
char __cdecl sub_1001DA7E(_DWORD *a1)
{
  _DWORD *v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // edx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // edi
  int v12; // [esp+Ch] [ebp-4h]
  int v13; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
    v1 = a1;
  }
  v5 = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v12 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v1 = a1;
    v5 = v12;
  }
  v9 = *v7;
  v10 = v6 - 1;
  v11 = v7 + 1;
  v13 = v9;
  if ( v5 != 255 || v9 != 216 )
  {
    *(_DWORD *)(*v1 + 20) = 52;
    *(_DWORD *)(*v1 + 24) = v5;
    *(_DWORD *)(*v1 + 28) = v9;
    (*(void (__cdecl **)(_DWORD *))*v1)(v1);
    v1 = a1;
    v9 = v13;
  }
  v1[94] = v9;
  *v2 = v11;
  v2[1] = v10;
  return 1;
}

// sub_1001DB15 @ 0x1001DB15
int __cdecl sub_1001DB15(_DWORD *a1)
{
  int v2; // eax
  char v3; // al
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax
  char v8; // [esp-4h] [ebp-10h]

  while ( 1 )
  {
    if ( !a1[94] && !(*(_BYTE *)(a1[100] + 80) ? sub_1001D9A7(a1) : sub_1001DA7E(a1)) )
      return 0;
    v2 = a1[94];
    if ( v2 > 207 )
      break;
    if ( v2 >= 205 )
      goto LABEL_26;
    if ( v2 > 200 )
    {
      v4 = v2 - 201;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( !v6 )
          {
LABEL_26:
            *(_DWORD *)(*a1 + 20) = 59;
LABEL_34:
            *(_DWORD *)(*a1 + 24) = a1[94];
            (*(void (__cdecl **)(_DWORD *))*a1)(a1);
            goto LABEL_48;
          }
          if ( v6 != 1 )
            goto LABEL_33;
          v3 = sub_1001D220(a1);
        }
        else
        {
          v3 = sub_1001C8BD(1, (int)a1, 1);
        }
        goto LABEL_47;
      }
      v8 = 1;
    }
    else
    {
      if ( v2 >= 197 )
        goto LABEL_26;
      if ( v2 == 1 )
      {
LABEL_36:
        *(_DWORD *)(*a1 + 20) = 91;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        goto LABEL_48;
      }
      if ( v2 <= 191 )
        goto LABEL_33;
      if ( v2 > 193 )
      {
        if ( v2 == 194 )
        {
          v3 = sub_1001C8BD(1, (int)a1, 0);
        }
        else
        {
          if ( v2 == 195 )
            goto LABEL_26;
          v3 = sub_1001D377(a1);
        }
        goto LABEL_47;
      }
      v8 = 0;
    }
    v3 = sub_1001C8BD(0, (int)a1, v8);
LABEL_47:
    if ( !v3 )
      return 0;
LABEL_48:
    a1[94] = 0;
  }
  if ( v2 > 219 )
  {
    if ( v2 == 220 )
    {
      v3 = sub_1001D90B(a1);
    }
    else if ( v2 == 221 )
    {
      v3 = sub_1001D834((int)a1);
    }
    else
    {
      if ( v2 <= 223 )
        goto LABEL_33;
      if ( v2 <= 239 )
      {
        v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 4 * v2 - 880))(a1);
      }
      else
      {
        if ( v2 != 254 )
        {
LABEL_33:
          *(_DWORD *)(*a1 + 20) = 67;
          goto LABEL_34;
        }
        v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 12))(a1);
      }
    }
    goto LABEL_47;
  }
  if ( v2 == 219 )
  {
    v3 = sub_1001D60B(a1);
    goto LABEL_47;
  }
  if ( v2 <= 215 )
    goto LABEL_36;
  if ( v2 == 216 )
  {
    v3 = sub_1001C82F((int)a1);
    goto LABEL_47;
  }
  if ( v2 == 217 )
  {
    *(_DWORD *)(*a1 + 20) = 84;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    result = 2;
    goto LABEL_51;
  }
  if ( sub_1001CBB8(a1) )
  {
    result = 1;
LABEL_51:
    a1[94] = 0;
    return result;
  }
  return 0;
}

// sub_1001DD02 @ 0x1001DD02
char __cdecl sub_1001DD02(_DWORD *a1)
{
  if ( a1[94] || sub_1001D9A7(a1) )
  {
    if ( a1[94] == *(_DWORD *)(a1[100] + 84) + 208 )
    {
      *(_DWORD *)(*a1 + 20) = 97;
      *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 84);
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
      a1[94] = 0;
LABEL_5:
      *(_DWORD *)(a1[100] + 84) = ((unsigned __int8)*(_DWORD *)(a1[100] + 84) + 1) & 7;
      return 1;
    }
    if ( (*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD))(a1[5] + 20))(a1, *(_DWORD *)(a1[100] + 84)) )
      goto LABEL_5;
  }
  return 0;
}

// sub_1001DD80 @ 0x1001DD80
char __cdecl sub_1001DD80(_DWORD *a1, int a2)
{
  int v3; // edi
  int v5; // [esp+14h] [ebp+4h]

  v3 = a1[94];
  *(_DWORD *)(*a1 + 20) = 117;
  *(_DWORD *)(*a1 + 24) = v3;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while ( 1 )
  {
    if ( v3 < 192 )
    {
LABEL_3:
      v5 = 2;
      goto LABEL_12;
    }
    if ( v3 < 208 || v3 > 215 || v3 == ((a2 + 1) & 7) + 208 || v3 == ((a2 + 2) & 7) + 208 )
    {
      v5 = 3;
    }
    else
    {
      if ( v3 == ((a2 - 1) & 7) + 208 || v3 == ((a2 - 2) & 7) + 208 )
        goto LABEL_3;
      v5 = 1;
    }
LABEL_12:
    *(_DWORD *)(*a1 + 20) = 96;
    *(_DWORD *)(*a1 + 24) = v3;
    *(_DWORD *)(*a1 + 28) = v5;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    if ( v5 == 1 )
      break;
    if ( v5 != 2 )
      return 1;
    if ( !sub_1001D9A7(a1) )
      return 0;
    v3 = a1[94];
  }
  a1[94] = 0;
  return 1;
}

// sub_1001DE6F @ 0x1001DE6F
int __cdecl sub_1001DE6F(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  a1[49] = 0;
  a1[31] = 0;
  a1[94] = 0;
  v1 = a1 + 100;
  *(_BYTE *)(*v1 + 80) = 0;
  *(_BYTE *)(*v1 + 81) = 0;
  result = a1[100];
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// sub_1001DE99 @ 0x1001DE99
int __cdecl sub_1001DE99(int a1)
{
  _DWORD *v1; // eax
  int i; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
  *(_DWORD *)(a1 + 400) = v1;
  *v1 = sub_1001DE6F;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 4) = sub_1001DB15;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 8) = sub_1001DD02;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 12) = sub_1001D90B;
  for ( i = 16; i < 80; i += 4 )
    *(_DWORD *)(i + *(_DWORD *)(a1 + 400)) = sub_1001D90B;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 16) = sub_1001CE6A;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 72) = sub_1001D0A6;
  return sub_1001DE6F((_DWORD *)a1);
}

// sub_1001DF16 @ 0x1001DF16
void __cdecl __noreturn sub_1001DF16(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  sub_10023BC5(a1);
  exit(1);
}

// sub_1001DF31 @ 0x1001DF31
int __cdecl sub_1001DF31(int a1)
{
  _BYTE v2[200]; // [esp+0h] [ebp-C8h] BYREF

  return (*(int (__cdecl **)(int, _BYTE *))(*(_DWORD *)a1 + 12))(a1, v2);
}

// sub_1001DF4E @ 0x1001DF4E
int __cdecl sub_1001DF4E(int *a1, int a2)
{
  int result; // eax
  int v3; // esi

  result = (int)a1;
  v3 = *a1;
  if ( a2 >= 0 )
  {
    if ( *(_DWORD *)(v3 + 104) >= a2 )
      return (*(int (__cdecl **)(int *))(v3 + 8))(a1);
  }
  else
  {
    if ( !*(_DWORD *)(v3 + 108) || *(int *)(v3 + 104) >= 3 )
      result = (*(int (__cdecl **)(int *))(v3 + 8))(a1);
    ++*(_DWORD *)(v3 + 108);
  }
  return result;
}

// sub_1001DF7F @ 0x1001DF7F
int __cdecl sub_1001DF7F(int a1, char *Buffer)
{
  _DWORD *v2; // eax
  int v3; // edx
  const char *v4; // ecx
  int v5; // ecx
  int v6; // esi
  const char **v7; // ecx
  char v8; // dl
  char *i; // esi

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( v3 <= 0 || v3 > v2[29] )
  {
    v5 = v2[30];
    if ( !v5 )
      goto LABEL_9;
    v6 = v2[31];
    if ( v3 < v6 || v3 > v2[32] )
      goto LABEL_9;
    v4 = *(const char **)(v5 + 4 * (v3 - v6));
  }
  else
  {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if ( !v4 )
  {
LABEL_9:
    v7 = (const char **)v2[28];
    v2[6] = v3;
    v4 = *v7;
  }
  v8 = *v4;
  for ( i = (char *)v4; ; v8 = *i )
  {
    if ( !v8 )
      return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
    ++i;
    if ( v8 == 37 )
      break;
  }
  if ( *i != 115 )
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  return sprintf(Buffer, v4, v2 + 6);
}

// sub_1001E016 @ 0x1001E016
int __cdecl sub_1001E016(int *a1)
{
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

// sub_1001E027 @ 0x1001E027
void (__cdecl __noreturn **__cdecl sub_1001E027(void (__cdecl __noreturn **a1)(int a1)))(int a1)
{
  *a1 = sub_1001DF16;
  a1[1] = (void (__cdecl __noreturn *)(int))sub_1001DF4E;
  a1[2] = (void (__cdecl __noreturn *)(int))sub_1001DF31;
  a1[3] = (void (__cdecl __noreturn *)(int))sub_1001DF7F;
  a1[4] = (void (__cdecl __noreturn *)(int))sub_1001E016;
  a1[26] = 0;
  a1[27] = 0;
  a1[5] = 0;
  a1[28] = (void (__cdecl __noreturn *)(int))off_1004CE48;
  a1[29] = (void (__cdecl __noreturn *)(int))119;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  return a1;
}

// sub_1001E073 @ 0x1001E073
_BYTE *__cdecl sub_1001E073(int a1, const void *a2)
{
  int v2; // ecx
  _BYTE *result; // eax
  int i; // esi
  int v5; // edx
  _BYTE *v6; // eax
  _BYTE *v7; // eax

  result = 0;
  for ( i = 0; i < 4; ++i )
  {
    v5 = *(unsigned __int8 *)(a1 + i + 268);
    if ( v5 < 41 || v5 > 122 || v5 > 90 && v5 < 97 )
    {
      result[v2] = 91;
      v6 = result + 1;
      v6[v2] = byte_1004E1C0[(v5 >> 4) & 0xF];
      (++v6)[v2] = byte_1004E1C0[v5 & 0xF];
      result = v6 + 1;
      result[v2] = 93;
    }
    else
    {
      result[v2] = v5;
    }
    ++result;
  }
  if ( a2 )
  {
    result[v2] = 58;
    v7 = result + 1;
    v7[v2] = 32;
    result = &v7[v2 + 1];
    qmemcpy(result, a2, 0x40u);
    result[63] = 0;
  }
  else
  {
    result[v2] = 0;
  }
  return result;
}

// sub_1001E0FA @ 0x1001E0FA
_DWORD *__cdecl sub_1001E0FA(_DWORD *a1, int a2, int a3, int a4)
{
  a1[18] = a2;
  a1[16] = a3;
  a1[17] = a4;
  return a1;
}

// png_error @ 0x1001E114
// png error handler: call error_fn then longjmp
void __noreturn png_error(void *png_ptr, char *msg)
{
  void (__cdecl *v2)(void *, char *); // eax

  v2 = (void (__cdecl *)(void *, char *))*((_DWORD *)png_ptr + 16);
  if ( v2 )
    v2(png_ptr, msg);
  longjmp((int *)png_ptr, 1);
}

// png_warning @ 0x1001E132
// png warning handler: call warning_fn
void png_warning(void *png_ptr, char *msg)
{
  void (__cdecl *v2)(void *, char *); // eax

  v2 = (void (__cdecl *)(void *, char *))*((_DWORD *)png_ptr + 17);
  if ( v2 )
    v2(png_ptr, msg);
}

// FUN_1001e147 @ 0x1001E147
void __noreturn FUN_1001e147(void *png_ptr, unsigned int *param_2)
{
  char msg[80]; // [esp+0h] [ebp-50h] BYREF

  sub_1001E073((int)png_ptr, param_2);
  png_error(png_ptr, msg);
}

// FUN_1001e16c @ 0x1001E16C
void FUN_1001e16c(void *png_ptr, unsigned int *param_2)
{
  char msg[80]; // [esp+0h] [ebp-50h] BYREF

  sub_1001E073((int)png_ptr, param_2);
  png_warning(png_ptr, msg);
}

// png_create_read_struct @ 0x1001E191
// allocates png_struct, initializes zlib stream, checks version; error_fn/warn_fn are png_error_ptr callbacks
void *png_create_read_struct(char *user_png_ver, void *error_ptr, void *error_fn, void *warn_fn)
{
  int *v4; // eax
  int v6; // eax
  int v7; // [esp+0h] [ebp-8h]
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+4h] [ebp-4h]

  v4 = (int *)sub_100246F2(1);
  Buf = v4;
  if ( !v4 )
    return 0;
  if ( setjmp3(v4, 0, v7) )
  {
    png_free(Buf, (void *)Buf[39]);
    png_free_ptr(Buf);
    return 0;
  }
  sub_1001E0FA(Buf, (int)error_ptr, (int)error_fn, (int)warn_fn);
  if ( !user_png_ver || *user_png_ver != 49 )
    png_error(Buf, "Incompatible libpng version in application and library");
  Buf[40] = 0x2000;
  Buf[39] = (int)png_malloc(Buf, 0x2000u);
  Buf[33] = (int)FUN_1002052b;
  Buf[34] = (int)png_free_thunk;
  Buf[35] = (int)Buf;
  v6 = inflateInit_(Buf + 25, "1.1.3", 56);
  if ( v6 == -6 )
    png_error(Buf, "zlib version error");
  if ( v6 == -4 || v6 == -2 )
    png_error(Buf, "zlib memory error");
  if ( v6 )
    png_error(Buf, "Unknown zlib error");
  Buf[28] = Buf[39];
  Buf[29] = Buf[40];
  FUN_100204a4(Buf, 0, 0);
  return Buf;
}

// FUN_1001e294 @ 0x1001E294
void FUN_1001e294(void *png_ptr, unsigned int *param_2)
{
  char *v2; // esi
  unsigned __int8 v3; // al
  unsigned int v4; // ebx
  unsigned int v5; // edi
  _DWORD *v6; // ebx
  unsigned int uint_32; // edi
  int v8; // eax
  unsigned int *v9; // [esp-18h] [ebp-24h]
  unsigned int v10; // [esp+0h] [ebp-Ch]
  unsigned int v11; // [esp+4h] [ebp-8h]

  v2 = (char *)png_ptr;
  v3 = *((_BYTE *)png_ptr + 284);
  if ( v3 < 8u )
  {
    v4 = v3;
    v5 = 8 - v3;
    png_read_data(png_ptr, (unsigned __int8 *)param_2 + v3 + 32, v5);
    v9 = param_2 + 8;
    v2[284] = 8;
    if ( sub_100204E3((int)v9, v4, v5) )
    {
      if ( v4 < 4 )
      {
        if ( sub_100204E3((int)(param_2 + 8), v4, v5 - 4) )
          png_error(v2, "Not a PNG file");
      }
      png_error(v2, "PNG file corrupted by ASCII conversion");
    }
  }
  v6 = v2 + 268;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          png_read_data(v2, (unsigned __int8 *)&png_ptr, 4u);
          uint_32 = png_get_uint_32((unsigned __int8 *)&png_ptr);
          png_reset_crc(v2);
          png_crc_read(v2, (unsigned __int8 *)v2 + 268, 4u);
          if ( *v6 != *(_DWORD *)"IHDR" )
            break;
          grim_png_read_IHDR(v2, param_2, uint_32);
        }
        if ( *v6 != *(_DWORD *)"PLTE" )
          break;
        grim_png_read_PLTE(v2, param_2, uint_32, v10);
      }
      if ( *v6 != *(_DWORD *)"IEND" )
        break;
      FUN_10025483(v2, (unsigned int)param_2, uint_32, v10, v11);
    }
    if ( *v6 == *(_DWORD *)"IDAT" )
      break;
    if ( *v6 == *(_DWORD *)"gAMA" )
    {
      FUN_100254cd(v2, (int)param_2, uint_32);
    }
    else if ( *v6 == *(_DWORD *)"sRGB" )
    {
      FUN_100255d8(v2, (int)param_2, uint_32);
    }
    else if ( *v6 == *(_DWORD *)"tRNS" )
    {
      FUN_100256c7(v2, (int)param_2, uint_32);
    }
    else
    {
      grim_png_read_chunk_generic(v2, (int)param_2, uint_32);
    }
  }
  v8 = *((_DWORD *)v2 + 22);
  if ( (v8 & 1) == 0 )
    png_error(v2, "Missing IHDR before IDAT");
  if ( v2[278] == 3 && (v8 & 2) == 0 )
    png_error(v2, "Missing PLTE before IDAT");
  *((_DWORD *)v2 + 22) |= 4u;
  *((_DWORD *)v2 + 63) = uint_32;
}

// FUN_1001e407 @ 0x1001E407
void FUN_1001e407(void *png_ptr, int *param_2)
{
  if ( (*((_BYTE *)png_ptr + 92) & 0x40) == 0 )
    FUN_10024f3b(png_ptr);
  sub_1001ED89((int)png_ptr, (int)param_2);
}

// FUN_1001e427 @ 0x1001E427
void FUN_1001e427(void *this, void *png_ptr, unsigned __int8 *param_2, unsigned __int8 *param_3)
{
  char *v4; // esi
  int v5; // eax
  bool v6; // zf
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // edx
  unsigned __int8 *v10; // ecx
  int v11; // eax
  char *v12; // eax
  char v13; // al
  unsigned __int8 v14; // cl
  int v15; // eax
  unsigned int v16; // ecx
  unsigned __int8 *v17; // eax
  unsigned __int8 v18; // cl
  void (__cdecl *v19)(char *, _DWORD, _DWORD); // eax

  v4 = (char *)this;
  if ( (*((_BYTE *)this + 92) & 0x40) == 0 )
    FUN_10024f3b(this);
  if ( !v4[275] || (v4[96] & 2) == 0 )
    goto LABEL_36;
  switch ( v4[276] )
  {
    case 0:
      if ( (v4[212] & 7) == 0 )
        break;
      v6 = param_2 == 0;
      goto LABEL_34;
    case 1:
      if ( (v4[212] & 7) != 0 || *((_DWORD *)v4 + 46) < 5u )
      {
        if ( param_2 )
          sub_100248E1((int)v4, (char *)param_2, 15);
        goto LABEL_13;
      }
      break;
    case 2:
      v7 = *((_DWORD *)v4 + 53);
      if ( (v7 & 7) == 4 )
        break;
      if ( !param_2 )
        goto LABEL_13;
      v6 = (v7 & 4) == 0;
LABEL_34:
      if ( !v6 )
        sub_100248E1((int)v4, (char *)param_2, 255);
      goto LABEL_13;
    case 3:
      if ( (v4[212] & 3) != 0 || *((_DWORD *)v4 + 46) < 3u )
      {
        if ( param_2 )
          sub_100248E1((int)v4, (char *)param_2, 51);
        goto LABEL_13;
      }
      break;
    case 4:
      v5 = *((_DWORD *)v4 + 53);
      if ( (v5 & 3) == 2 )
        break;
      if ( param_2 )
      {
        v6 = (v5 & 2) == 0;
        goto LABEL_34;
      }
LABEL_13:
      sub_100258C8((int *)v4);
      return;
    case 5:
      if ( (v4[212] & 1) != 0 || *((_DWORD *)v4 + 46) < 2u )
      {
        if ( param_2 )
          sub_100248E1((int)v4, (char *)param_2, 85);
        goto LABEL_13;
      }
      break;
    default:
      if ( v4[276] == 6 && (v4[212] & 1) == 0 )
        goto LABEL_13;
      break;
  }
LABEL_36:
  if ( (v4[88] & 4) == 0 )
    png_error(v4, "Invalid attempt to read row data");
  *((_DWORD *)v4 + 28) = *((_DWORD *)v4 + 55);
  *((_DWORD *)v4 + 29) = *((_DWORD *)v4 + 51);
  while ( 1 )
  {
    if ( !*((_DWORD *)v4 + 26) )
    {
      while ( !*((_DWORD *)v4 + 63) )
      {
        png_crc_finish(v4, 0);
        png_read_data(v4, (unsigned __int8 *)&this, 4u);
        *((_DWORD *)v4 + 63) = png_get_uint_32((unsigned __int8 *)&this);
        png_reset_crc(v4);
        png_crc_read(v4, (unsigned __int8 *)v4 + 268, 4u);
        if ( *((_DWORD *)v4 + 67) != *(_DWORD *)"IDAT" )
          png_error(v4, "Not enough image data");
      }
      v8 = *((_DWORD *)v4 + 40);
      v9 = *((_DWORD *)v4 + 63);
      v10 = (unsigned __int8 *)*((_DWORD *)v4 + 39);
      *((_DWORD *)v4 + 26) = v8;
      *((_DWORD *)v4 + 25) = v10;
      if ( v8 > v9 )
        *((_DWORD *)v4 + 26) = v9;
      png_crc_read(v4, v10, *((_DWORD *)v4 + 26));
      *((_DWORD *)v4 + 63) -= *((_DWORD *)v4 + 26);
    }
    v11 = inflate(v4 + 100, 1);
    if ( v11 == 1 )
      break;
    if ( v11 )
    {
      v12 = (char *)*((_DWORD *)v4 + 31);
      if ( !v12 )
        v12 = "Decompression error";
      png_error(v4, v12);
    }
    if ( !*((_DWORD *)v4 + 29) )
      goto LABEL_59;
  }
  if ( *((_DWORD *)v4 + 29) || *((_DWORD *)v4 + 26) || *((_DWORD *)v4 + 63) )
    png_error(v4, "Extra compressed data");
  *((_DWORD *)v4 + 22) |= 8u;
  *((_DWORD *)v4 + 23) |= 0x20u;
LABEL_59:
  v13 = v4[278];
  v4[250] = v4[282];
  v4[249] = v4[279];
  v14 = v4[281];
  v4[251] = v14;
  v4[248] = v13;
  v15 = *((_DWORD *)v4 + 52);
  v16 = v15 * v14 + 7;
  *((_DWORD *)v4 + 60) = v15;
  v17 = (unsigned __int8 *)*((_DWORD *)v4 + 55);
  *((_DWORD *)v4 + 61) = v16 >> 3;
  FUN_10024dc0(v4, (int)(v4 + 240), v17 + 1, (unsigned __int8 *)(*((_DWORD *)v4 + 54) + 1), *v17);
  FUN_10024790((int)v4, *((_DWORD *)v4 + 54), *((_DWORD *)v4 + 55));
  if ( *((_DWORD *)v4 + 24) )
    FUN_10020149(v4);
  if ( v4[275] && (*((_DWORD *)v4 + 24) & 2) != 0 )
  {
    v18 = v4[276];
    if ( v18 < 6u )
      sub_10024AF7((int *)v4 + 60, *((_DWORD *)v4 + 55) + 1, v18);
    if ( param_2 )
      sub_100248E1((int)v4, (char *)param_2, dword_1004E1F8[(unsigned __int8)v4[276]]);
    if ( png_ptr )
      sub_100248E1((int)v4, (char *)png_ptr, dword_1004E1DC[(unsigned __int8)v4[276]]);
  }
  else
  {
    if ( png_ptr )
      sub_100248E1((int)v4, (char *)png_ptr, 255);
    if ( param_2 )
      sub_100248E1((int)v4, (char *)param_2, 255);
  }
  sub_100258C8((int *)v4);
  v19 = (void (__cdecl *)(char *, _DWORD, _DWORD))*((_DWORD *)v4 + 91);
  if ( v19 )
    v19(v4, *((_DWORD *)v4 + 53), (unsigned __int8)v4[276]);
}

// FUN_1001e7ce @ 0x1001E7CE
void FUN_1001e7ce(void *png_ptr, unsigned int *param_2)
{
  unsigned __int8 *v2; // ebx
  int v4; // eax
  int *v5; // edi
  unsigned int *v6; // ebx
  unsigned __int8 *v7; // [esp-4h] [ebp-10h]
  int v8; // [esp+8h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+14h] [ebp+8h]

  v4 = sub_1001EBF8((int)png_ptr);
  v5 = (int *)*((_DWORD *)png_ptr + 47);
  *((_DWORD *)png_ptr + 48) = v5;
  if ( v4 > 0 )
  {
    v8 = v4;
    v7 = v2;
    do
    {
      v6 = param_2;
      if ( v5 )
      {
        Buf = v5;
        do
        {
          FUN_1001e427(png_ptr, (void *)*v6++, 0, v7);
          Buf = (int *)((char *)Buf - 1);
        }
        while ( Buf );
      }
      --v8;
    }
    while ( v8 );
  }
}

// FUN_1001e81b @ 0x1001E81B
void FUN_1001e81b(void *png_ptr, unsigned int *param_2, unsigned int *param_3)
{
  int v3; // edi
  int v4; // esi
  int v5; // eax
  int v6; // edx
  int v7; // esi
  _BYTE v8[64]; // [esp+Ch] [ebp-40h] BYREF

  v3 = 0;
  if ( param_2 )
    FUN_100205da((int)png_ptr);
  if ( param_3 )
    FUN_100205da((int)png_ptr);
  png_free(png_ptr, *((void **)png_ptr + 39));
  png_free(png_ptr, *((void **)png_ptr + 55));
  png_free(png_ptr, *((void **)png_ptr + 54));
  png_free(png_ptr, *((void **)png_ptr + 93));
  png_free(png_ptr, *((void **)png_ptr + 94));
  png_free(png_ptr, *((void **)png_ptr + 78));
  if ( (*((_BYTE *)png_ptr + 93) & 0x10) != 0 )
    png_free_thunk(png_ptr, *((void **)png_ptr + 65));
  if ( (*((_BYTE *)png_ptr + 93) & 0x20) != 0 )
    png_free(png_ptr, *((void **)png_ptr + 87));
  if ( *((_DWORD *)png_ptr + 81) )
  {
    v4 = 1 << (8 - *((_BYTE *)png_ptr + 300));
    if ( v4 > 0 )
    {
      do
        png_free(png_ptr, *(void **)(*((_DWORD *)png_ptr + 81) + 4 * v3++));
      while ( v3 < v4 );
    }
    png_free(png_ptr, *((void **)png_ptr + 81));
  }
  inflateEnd((char *)png_ptr + 100);
  v5 = *((_DWORD *)png_ptr + 18);
  v6 = *((_DWORD *)png_ptr + 16);
  qmemcpy(v8, png_ptr, sizeof(v8));
  v7 = *((_DWORD *)png_ptr + 17);
  memset(png_ptr, 0, 0x19Cu);
  *((_DWORD *)png_ptr + 17) = v7;
  qmemcpy(png_ptr, v8, 0x40u);
  *((_DWORD *)png_ptr + 16) = v6;
  *((_DWORD *)png_ptr + 18) = v5;
}

// sub_1001E93E @ 0x1001E93E
int __cdecl sub_1001E93E(int *a1, int *a2, int *a3)
{
  int result; // eax
  int v4; // esi
  int v5; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  result = (int)a1;
  v4 = 0;
  v6 = 0;
  v5 = 0;
  if ( a1 )
  {
    result = *a1;
    v6 = *a1;
  }
  if ( a2 )
    v4 = *a2;
  if ( a3 )
  {
    result = *a3;
    v5 = *a3;
  }
  if ( v6 )
    result = FUN_1001e81b(v6, v4, v5);
  if ( v4 )
  {
    result = png_free_ptr(v4);
    *a2 = 0;
  }
  if ( v5 )
  {
    result = png_free_ptr(v5);
    *a3 = 0;
  }
  if ( v6 )
  {
    png_free_ptr(v6);
    *a1 = 0;
    return (int)a1;
  }
  return result;
}

// sub_1001E9BF @ 0x1001E9BF
int __cdecl sub_1001E9BF(int a1, int a2, int a3)
{
  if ( a1 && a2 )
    return a3 & *(_DWORD *)(a2 + 8);
  else
    return 0;
}

// sub_1001E9D9 @ 0x1001E9D9
int __cdecl sub_1001E9D9(int a1, int a2)
{
  if ( a1 && a2 )
    return *(_DWORD *)(a2 + 12);
  else
    return 0;
}

// sub_1001E9EF @ 0x1001E9EF
char __cdecl sub_1001E9EF(int a1, int a2)
{
  if ( a1 && a2 )
    return *(_BYTE *)(a2 + 29);
  else
    return 0;
}

// sub_1001EA05 @ 0x1001EA05
int __cdecl sub_1001EA05(int a1, int a2, double *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 1) == 0 || !a3 )
    return 0;
  *a3 = *(float *)(a2 + 40);
  return 1;
}

// sub_1001EA2E @ 0x1001EA2E
int __cdecl sub_1001EA2E(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  result = 2048;
  if ( (*(_DWORD *)(a2 + 8) & 0x800) == 0 || !a3 )
    return 0;
  *a3 = *(unsigned __int8 *)(a2 + 44);
  return result;
}

// FUN_1001ea59 @ 0x1001EA59
unsigned int FUN_1001ea59(
        void *png_ptr,
        unsigned int *param_2,
        unsigned int *param_3,
        unsigned int *param_4,
        unsigned int *param_5,
        unsigned int *param_6,
        unsigned int *param_7,
        unsigned int *param_8,
        unsigned int *param_9)
{
  unsigned int v9; // eax

  if ( !png_ptr || !param_2 || !param_3 || !param_4 || !param_5 || !param_6 )
    return 0;
  *param_3 = *param_2;
  *param_4 = param_2[1];
  *param_5 = *((unsigned __int8 *)param_2 + 24);
  *param_6 = *((unsigned __int8 *)param_2 + 25);
  if ( param_8 )
    *param_8 = *((unsigned __int8 *)param_2 + 26);
  if ( param_9 )
    *param_9 = *((unsigned __int8 *)param_2 + 27);
  if ( param_7 )
    *param_7 = *((unsigned __int8 *)param_2 + 28);
  if ( *param_6 == 3 )
    v9 = 1;
  else
    v9 = *param_6 & 2 | 1;
  if ( (*param_6 & 4) != 0 )
    ++v9;
  if ( *param_3 > 0x7FFFFFFFu / ((int)(v9 * *param_5 + 7) >> 3) )
    png_warning(png_ptr, "Width too large for libpng to process image data.");
  return 1;
}

// sub_1001EB2A @ 0x1001EB2A
int __cdecl sub_1001EB2A(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 8) == 0 || !a3 )
    return 0;
  *a3 = *(_DWORD *)(a2 + 16);
  *a4 = *(unsigned __int16 *)(a2 + 20);
  return 8;
}

// sub_1001EB5D @ 0x1001EB5D
int __cdecl sub_1001EB5D(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax

  result = 0;
  if ( a1 && a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    if ( *(_BYTE *)(a2 + 25) == 3 )
    {
      if ( a3 )
      {
        *a3 = *(_DWORD *)(a2 + 48);
        result = 16;
      }
      if ( a5 )
        *a5 = a2 + 52;
    }
    else
    {
      if ( a5 )
      {
        *a5 = a2 + 52;
        result = 16;
      }
      if ( a3 )
        *a3 = 0;
    }
    if ( a4 )
    {
      *a4 = *(unsigned __int16 *)(a2 + 22);
      return result | 0x10;
    }
  }
  return result;
}

// sub_1001EBC4 @ 0x1001EBC4
int __cdecl sub_1001EBC4(int a1)
{
  *(_DWORD *)(a1 + 96) |= 1u;
  return a1;
}

// sub_1001EBCD @ 0x1001EBCD
int __cdecl sub_1001EBCD(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 279) == 16 )
    *(_DWORD *)(a1 + 96) |= 0x10u;
  return result;
}

// sub_1001EBDF @ 0x1001EBDF
int __cdecl sub_1001EBDF(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 279) < 8u )
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    *(_BYTE *)(a1 + 280) = 8;
  }
  return result;
}

// sub_1001EBF8 @ 0x1001EBF8
int __cdecl sub_1001EBF8(int a1)
{
  if ( !*(_BYTE *)(a1 + 275) )
    return 1;
  *(_DWORD *)(a1 + 96) |= 2u;
  return 7;
}

// sub_1001EC11 @ 0x1001EC11
int __cdecl sub_1001EC11(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax
  char v4; // cl

  result = a1;
  *(_BYTE *)(a1 + 97) |= 0x80u;
  *(_WORD *)(a1 + 286) = a2;
  if ( a3 == 1 )
    *(_BYTE *)(a1 + 92) |= 0x80u;
  else
    *(_BYTE *)(a1 + 92) &= ~0x80u;
  v4 = *(_BYTE *)(a1 + 278);
  if ( v4 == 2 )
    *(_BYTE *)(a1 + 283) = 4;
  if ( !v4 && *(_BYTE *)(a1 + 279) >= 8u )
    *(_BYTE *)(a1 + 283) = 2;
  return result;
}

// sub_1001EC5E @ 0x1001EC5E
void __cdecl sub_1001EC5E(int a1, char *a2)
{
  int v3; // esi
  char v4; // dl

  if ( *(_BYTE *)(a1 + 9) == 16 && *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
  {
    v3 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
    do
    {
      v4 = *a2;
      *a2 = a2[1];
      a2[1] = v4;
      a2 += 2;
      --v3;
    }
    while ( v3 );
  }
}

// sub_1001EC8B @ 0x1001EC8B
char __cdecl sub_1001EC8B(int *a1, char *a2)
{
  char *v2; // eax
  char v3; // dl
  int v4; // ecx
  int v5; // esi
  char v6; // dl
  int v7; // esi
  char v8; // dl
  int v9; // esi
  char v10; // cl
  char v11; // dl
  char v12; // cl
  int v13; // esi
  char v14; // cl
  char v15; // dl
  char v16; // cl

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v2 = a2;
        if ( v4 )
        {
          v5 = *a1;
          do
          {
            v6 = *v2;
            *v2 = v2[2];
            v2[2] = v6;
            v2 += 3;
            --v5;
          }
          while ( v5 );
        }
      }
      else if ( v3 == 6 )
      {
        v2 = a2;
        if ( v4 )
        {
          v7 = *a1;
          do
          {
            v8 = *v2;
            *v2 = v2[2];
            v2[2] = v8;
            v2 += 4;
            --v7;
          }
          while ( v7 );
        }
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          v2 = a2 + 1;
          v9 = *a1;
          do
          {
            v10 = *(v2 - 1);
            *(v2 - 1) = v2[3];
            v11 = v2[4];
            v2[3] = v10;
            v12 = *v2;
            *v2 = v11;
            v2[4] = v12;
            v2 += 6;
            --v9;
          }
          while ( v9 );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        v2 = a2 + 1;
        v13 = *a1;
        do
        {
          v14 = *(v2 - 1);
          *(v2 - 1) = v2[3];
          v15 = v2[4];
          v2[3] = v14;
          v16 = *v2;
          *v2 = v15;
          v2[4] = v16;
          v2 += 8;
          --v13;
        }
        while ( v13 );
      }
    }
  }
  return (char)v2;
}

// sub_1001ED4A @ 0x1001ED4A
int __cdecl sub_1001ED4A(int a1, double a2, double a3)
{
  int result; // eax

  result = a1;
  if ( fabs(a2 * a3 - 1.0) > 0.05 )
    *(_BYTE *)(a1 + 97) |= 0x20u;
  *(float *)(a1 + 304) = a3;
  *(float *)(a1 + 308) = a2;
  return result;
}

// sub_1001ED80 @ 0x1001ED80
int __cdecl sub_1001ED80(int a1)
{
  *(_BYTE *)(a1 + 97) |= 0x10u;
  return a1;
}

// sub_1001ED89 @ 0x1001ED89
unsigned int __cdecl sub_1001ED89(int a1, int a2)
{
  char v2; // dl
  char v3; // dl
  char v4; // dl
  unsigned __int8 v5; // al
  unsigned int result; // eax

  if ( (*(_BYTE *)(a1 + 97) & 0x10) != 0 )
  {
    v2 = *(_BYTE *)(a2 + 25);
    if ( v2 == 3 )
    {
      *(_BYTE *)(a2 + 25) = 4 * (*(_WORD *)(a1 + 266) != 0) + 2;
    }
    else
    {
      if ( *(_WORD *)(a1 + 266) )
        *(_BYTE *)(a2 + 25) = v2 | 4;
      if ( *(_BYTE *)(a2 + 24) >= 8u )
        goto LABEL_8;
    }
    *(_BYTE *)(a2 + 24) = 8;
LABEL_8:
    *(_WORD *)(a2 + 22) = 0;
  }
  if ( (*(_BYTE *)(a1 + 97) & 0x20) != 0 )
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 304);
  if ( (*(_BYTE *)(a1 + 97) & 4) != 0 && *(_BYTE *)(a2 + 24) == 16 )
    *(_BYTE *)(a2 + 24) = 8;
  if ( (*(_BYTE *)(a1 + 96) & 0x40) != 0 )
  {
    v3 = *(_BYTE *)(a2 + 25);
    if ( (v3 == 2 || v3 == 6) && *(_DWORD *)(a1 + 372) && *(_BYTE *)(a2 + 24) == 8 )
      *(_BYTE *)(a2 + 25) = 3;
  }
  if ( (*(_BYTE *)(a1 + 96) & 4) != 0 && *(_BYTE *)(a2 + 24) < 8u )
    *(_BYTE *)(a2 + 24) = 8;
  v4 = *(_BYTE *)(a2 + 25);
  if ( v4 == 3 || (v4 & 2) == 0 )
    *(_BYTE *)(a2 + 29) = 1;
  else
    *(_BYTE *)(a2 + 29) = 3;
  if ( (v4 & 4) != 0 )
    ++*(_BYTE *)(a2 + 29);
  if ( *(char *)(a1 + 97) < 0 && (v4 == 2 || !v4) )
    ++*(_BYTE *)(a2 + 29);
  v5 = *(_BYTE *)(a2 + 29) * *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a2 + 30) = v5;
  result = (*(_DWORD *)a2 * (unsigned int)v5 + 7) >> 3;
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

// sub_1001EE74 @ 0x1001EE74
void __cdecl sub_1001EE74(int *a1, int a2)
{
  int *v2; // ebx
  unsigned __int8 v3; // cl
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  _BYTE *v7; // esi
  _BYTE *v8; // edi
  int v9; // edx
  _BYTE *v10; // esi
  _BYTE *v11; // edi
  int v12; // edx
  _BYTE *v13; // esi
  _BYTE *v14; // edi
  int v15; // edx
  unsigned __int8 v16; // dl
  int v17; // [esp+4h] [ebp-4h]
  int v18; // [esp+4h] [ebp-4h]
  int v19; // [esp+4h] [ebp-4h]

  v2 = a1;
  v3 = *((_BYTE *)a1 + 9);
  if ( v3 < 8u )
  {
    v4 = *a1;
    v5 = v3 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 2 )
          goto LABEL_26;
        v7 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 1));
        v8 = (_BYTE *)(v4 + a2 - 1);
        v9 = 4 - 4 * ((v4 - 1) & 1);
        if ( !v4 )
          goto LABEL_26;
        v17 = *a1;
        do
        {
          *v8 = (*v7 >> v9) & 0xF;
          if ( v9 == 4 )
          {
            v9 = 0;
            --v7;
          }
          else
          {
            v9 = 4;
          }
          --v8;
          --v17;
        }
        while ( v17 );
        goto LABEL_25;
      }
      v10 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 2));
      v11 = (_BYTE *)(v4 + a2 - 1);
      v12 = 6 - 2 * ((v4 - 1) & 3);
      if ( v4 )
      {
        v18 = *a1;
        do
        {
          *v11 = (*v10 >> v12) & 3;
          if ( v12 == 6 )
          {
            v12 = 0;
            --v10;
          }
          else
          {
            v12 += 2;
          }
          --v11;
          --v18;
        }
        while ( v18 );
LABEL_25:
        v2 = a1;
      }
    }
    else
    {
      v13 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 3));
      v14 = (_BYTE *)(v4 + a2 - 1);
      v15 = 7 - ((v4 - 1) & 7);
      if ( v4 )
      {
        v19 = *a1;
        do
        {
          *v14 = (*v13 >> v15) & 1;
          if ( v15 == 7 )
          {
            v15 = 0;
            --v13;
          }
          else
          {
            ++v15;
          }
          --v14;
          --v19;
        }
        while ( v19 );
        goto LABEL_25;
      }
    }
LABEL_26:
    v16 = *((_BYTE *)v2 + 10);
    *((_BYTE *)v2 + 9) = 8;
    *((_BYTE *)v2 + 11) = 8 * v16;
    v2[1] = v4 * v16;
  }
}

// sub_1001EF84 @ 0x1001EF84
char __cdecl sub_1001EF84(int *a1, _BYTE *a2, unsigned __int8 *a3)
{
  int i; // eax
  int v5; // edi
  bool v6; // zf
  int v7; // edx
  int v8; // ebx
  int v9; // ebx
  int v10; // ecx
  unsigned __int8 *v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // esi
  unsigned int j; // edi
  int v15; // esi
  _BYTE *v16; // edi
  int v17; // esi
  _DWORD v19[4]; // [esp+4h] [ebp-14h] BYREF
  unsigned int v20; // [esp+14h] [ebp-4h]
  __int16 v21; // [esp+20h] [ebp+8h]
  unsigned int k; // [esp+20h] [ebp+8h]
  unsigned int v23; // [esp+20h] [ebp+8h]

  LOBYTE(i) = *((_BYTE *)a1 + 8);
  if ( (_BYTE)i != 3 )
  {
    v21 = 0;
    v5 = *a1;
    v6 = (i & 2) == 0;
    LOBYTE(i) = (_BYTE)a3;
    if ( v6 )
    {
      v7 = *((unsigned __int8 *)a1 + 9) - a3[3];
      v9 = 1;
    }
    else
    {
      v7 = *((unsigned __int8 *)a1 + 9) - *a3;
      v8 = a3[2];
      v19[1] = *((unsigned __int8 *)a1 + 9) - a3[1];
      v19[2] = *((unsigned __int8 *)a1 + 9) - v8;
      v9 = 3;
    }
    v6 = (a1[2] & 4) == 0;
    v19[0] = v7;
    if ( !v6 )
    {
      i = *((unsigned __int8 *)a1 + 9) - a3[4];
      v19[v9] = i;
      LOBYTE(v7) = v19[0];
      ++v9;
    }
    v10 = 0;
    if ( v9 > 0 )
    {
      do
      {
        i = (int)&v19[v10];
        if ( *(int *)i > 0 )
        {
          v21 = 1;
        }
        else
        {
          *(_DWORD *)i = 0;
          LOBYTE(v7) = v19[0];
        }
        ++v10;
      }
      while ( v10 < v9 );
      if ( v21 )
      {
        if ( *((_BYTE *)a1 + 9) == 2 )
        {
          v17 = a1[1];
          for ( i = (int)a2; v17; --v17 )
          {
            *(_BYTE *)i = (*(_BYTE *)i >> 1) & 0x55;
            ++i;
          }
        }
        else if ( *((_BYTE *)a1 + 9) == 4 )
        {
          v15 = a1[1];
          v16 = a2;
          for ( LOBYTE(i) = (15 >> v7) | (240 >> v7) & 0xF0; v15; --v15 )
          {
            *v16 = i & (*v16 >> v7);
            ++v16;
          }
        }
        else
        {
          LOBYTE(i) = *((_BYTE *)a1 + 9) - 8;
          if ( *((_BYTE *)a1 + 9) == 8 )
          {
            v13 = a2;
            v23 = v9 * v5;
            for ( j = 0; j < v23; ++j )
            {
              i = j / v9;
              *v13++ >>= LOBYTE(v19[j % v9]);
            }
          }
          else
          {
            LOBYTE(i) = *((_BYTE *)a1 + 9) - 16;
            if ( *((_BYTE *)a1 + 9) == 16 )
            {
              v11 = a2;
              v20 = v9 * v5;
              for ( k = 0; k < v20; LOBYTE(i) = k )
              {
                LOWORD(i) = (unsigned __int16)(v11[1] + (*v11 << 8)) >> LOWORD(v19[k % v9]);
                *v11 = BYTE1(i);
                v12 = v11 + 1;
                *v12 = i;
                v11 = v12 + 1;
                ++k;
              }
            }
          }
        }
      }
    }
  }
  return i;
}

// sub_1001F0FB @ 0x1001F0FB
int __cdecl sub_1001F0FB(int a1, _BYTE *a2)
{
  int result; // eax
  _BYTE *v3; // esi
  char *v4; // edx
  int v5; // edi
  char v6; // cl
  unsigned __int8 v7; // dl
  int v8; // ecx

  result = a1;
  if ( *(_BYTE *)(a1 + 9) == 16 )
  {
    v3 = a2;
    v4 = a2;
    if ( *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
    {
      v5 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
      do
      {
        v6 = *v4;
        v4 += 2;
        *v3++ = v6;
        --v5;
      }
      while ( v5 );
    }
    v7 = *(_BYTE *)(a1 + 10);
    v8 = *(_DWORD *)a1 * v7;
    *(_BYTE *)(a1 + 9) = 8;
    *(_BYTE *)(a1 + 11) = 8 * v7;
    *(_DWORD *)(a1 + 4) = v8;
  }
  return result;
}

// sub_1001F13F @ 0x1001F13F
unsigned int __cdecl sub_1001F13F(int a1, int a2, unsigned int a3, char a4)
{
  char v4; // dl
  char v6; // cl
  unsigned int result; // eax
  unsigned int v8; // ebx
  char v9; // cl
  _BYTE *v10; // ecx
  _BYTE *v11; // edi
  _BYTE *v12; // edi
  bool v13; // zf
  _BYTE *v14; // edi
  _BYTE *v15; // ecx
  _BYTE *v16; // edi
  _BYTE *v17; // ecx
  _BYTE *v18; // edi
  _BYTE *v19; // ecx
  char *v20; // edi
  char v21; // cl
  char *v22; // edi
  char v23; // cl
  _BYTE *v24; // ecx
  _BYTE *v25; // edi
  _BYTE *v26; // edi
  _BYTE *v27; // ecx
  char v28; // bl
  _BYTE *v29; // edi
  _BYTE *v30; // ecx
  _BYTE *v31; // edi
  _BYTE *v32; // ecx
  _BYTE *v33; // edi
  _BYTE *v34; // ecx
  _BYTE *v35; // ecx
  _BYTE *v36; // edi
  char v37; // bl
  _BYTE *v38; // ecx
  _BYTE *v39; // edi
  _BYTE *v40; // ecx
  unsigned int v41; // [esp+18h] [ebp+8h]
  unsigned int v42; // [esp+18h] [ebp+8h]
  char *v43; // [esp+18h] [ebp+8h]
  char *v44; // [esp+18h] [ebp+8h]
  unsigned int v45; // [esp+18h] [ebp+8h]
  unsigned int v46; // [esp+18h] [ebp+8h]
  char v47; // [esp+1Bh] [ebp+Bh]
  unsigned int v48; // [esp+20h] [ebp+10h]
  unsigned int v49; // [esp+20h] [ebp+10h]
  unsigned int v50; // [esp+20h] [ebp+10h]
  unsigned int v51; // [esp+20h] [ebp+10h]

  v4 = a3;
  v6 = *(_BYTE *)(a1 + 8);
  result = *(_DWORD *)a1;
  v8 = a3 >> 8;
  v47 = BYTE1(a3);
  if ( v6 )
  {
    if ( v6 != 2 )
      return result;
    v23 = *(_BYTE *)(a1 + 9);
    if ( v23 == 8 )
    {
      if ( a4 >= 0 )
      {
        v29 = (_BYTE *)(a2 + 2 * result + result);
        v30 = &v29[result];
        if ( result )
        {
          v46 = result;
          do
          {
            v31 = v29 - 1;
            v32 = v30 - 1;
            *v32 = *v31--;
            *--v32 = *v31;
            v29 = v31 - 1;
            *--v32 = *v29;
            v30 = v32 - 1;
            v13 = v46-- == 1;
            *v30 = a3;
          }
          while ( !v13 );
        }
      }
      else
      {
        v24 = (_BYTE *)(a2 + 2 * result + result);
        v25 = &v24[result];
        if ( result > 1 )
        {
          v45 = result - 1;
          do
          {
            v26 = v25 - 1;
            *v26 = a3;
            v27 = v24 - 1;
            *--v26 = *v27;
            v28 = *--v27;
            --v26;
            v24 = v27 - 1;
            *v26 = v28;
            v25 = v26 - 1;
            v13 = v45-- == 1;
            *v25 = *v24;
          }
          while ( !v13 );
        }
        *(v25 - 1) = a3;
      }
      *(_BYTE *)(a1 + 11) = 32;
      result *= 4;
    }
    else
    {
      if ( v23 != 16 )
        return result;
      v33 = (_BYTE *)(a2 + 2 * result + result);
      v34 = &v33[result];
      if ( a4 >= 0 )
      {
        if ( result )
        {
          v51 = result;
          do
          {
            v39 = v33 - 1;
            v40 = v34 - 1;
            *v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39;
            v33 = v39 - 1;
            *--v40 = *v33;
            *--v40 = v47;
            v34 = v40 - 1;
            v13 = v51-- == 1;
            *v34 = v4;
          }
          while ( !v13 );
        }
      }
      else
      {
        if ( result > 1 )
        {
          v50 = result - 1;
          do
          {
            v35 = v34 - 1;
            *v35-- = v47;
            *v35 = v4;
            v36 = v33 - 1;
            *--v35 = *v36--;
            *--v35 = *v36--;
            *--v35 = *v36--;
            *--v35 = *v36;
            v37 = *--v36;
            --v35;
            v33 = v36 - 1;
            *v35 = v37;
            v34 = v35 - 1;
            v13 = v50-- == 1;
            *v34 = *v33;
          }
          while ( !v13 );
          LOBYTE(v8) = v47;
        }
        v38 = v34 - 1;
        *v38 = v8;
        *(v38 - 1) = v4;
      }
      *(_BYTE *)(a1 + 11) = 64;
      result *= 8;
    }
    *(_BYTE *)(a1 + 10) = 4;
  }
  else
  {
    v9 = *(_BYTE *)(a1 + 9);
    if ( v9 == 8 )
    {
      v10 = (_BYTE *)(result + a2);
      v11 = (_BYTE *)(result + a2 + result);
      if ( a4 >= 0 )
      {
        if ( result )
        {
          v42 = result;
          do
          {
            --v10;
            v14 = v11 - 1;
            *v14 = *v10;
            v11 = v14 - 1;
            v13 = v42-- == 1;
            *v11 = a3;
          }
          while ( !v13 );
        }
      }
      else
      {
        if ( result > 1 )
        {
          v41 = result - 1;
          do
          {
            v12 = v11 - 1;
            --v10;
            *v12 = a3;
            v11 = v12 - 1;
            v13 = v41-- == 1;
            *v11 = *v10;
          }
          while ( !v13 );
        }
        *(v11 - 1) = a3;
      }
      *(_BYTE *)(a1 + 10) = 2;
      *(_BYTE *)(a1 + 11) = 16;
      result *= 2;
    }
    else
    {
      if ( v9 != 16 )
        return result;
      if ( a4 >= 0 )
      {
        v43 = (char *)(result + a2);
        v20 = (char *)(result + result + a2);
        if ( result )
        {
          v49 = result;
          do
          {
            v44 = v43 - 1;
            v21 = *v44;
            v22 = v20 - 1;
            v43 = v44 - 1;
            *v22-- = v21;
            *v22-- = *v43;
            *v22 = v8;
            v20 = v22 - 1;
            v13 = v49-- == 1;
            *v20 = v4;
          }
          while ( !v13 );
        }
      }
      else
      {
        v15 = (_BYTE *)(result + result + a2);
        if ( result > 1 )
        {
          v48 = result - 1;
          v16 = (_BYTE *)(result + a2);
          do
          {
            v17 = v15 - 1;
            *v17-- = v8;
            *v17 = v4;
            v18 = v16 - 1;
            *--v17 = *v18;
            v16 = v18 - 1;
            v15 = v17 - 1;
            v13 = v48-- == 1;
            *v15 = *v16;
            LOBYTE(v8) = v47;
          }
          while ( !v13 );
        }
        v19 = v15 - 1;
        *v19 = v8;
        *(v19 - 1) = v4;
      }
      *(_BYTE *)(a1 + 10) = 2;
      *(_BYTE *)(a1 + 11) = 32;
      result *= 4;
    }
  }
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

// sub_1001F377 @ 0x1001F377
unsigned __int8 *__cdecl sub_1001F377(int *a1, _BYTE *a2, unsigned __int8 *a3, int a4, char a5)
{
  unsigned __int8 *result; // eax
  int *v6; // edi
  unsigned __int8 v7; // cl
  int v8; // edx
  _BYTE *v9; // ecx
  int v10; // esi
  _BYTE *v11; // ecx
  __int16 v12; // cx
  unsigned __int8 *v13; // eax
  __int16 v14; // cx
  __int16 v15; // cx
  _BYTE *v16; // ecx
  int v17; // esi
  __int16 v18; // cx
  _BYTE *v19; // ecx
  int v20; // esi
  _BYTE *v21; // ecx
  __int16 v22; // cx
  unsigned __int8 *v23; // eax
  __int16 v24; // cx
  __int16 v25; // cx
  char v26; // cl
  int v27; // edx
  int v28; // edi
  char *v29; // ecx
  bool v30; // zf
  char v31; // cl
  _BYTE *v32; // esi
  unsigned int v33; // edi
  _BYTE *v34; // ecx
  int v35; // esi
  __int16 v36; // cx
  int v37; // [esp+8h] [ebp-14h]
  unsigned int v38; // [esp+14h] [ebp-8h]
  char *v39; // [esp+18h] [ebp-4h]
  int v40; // [esp+24h] [ebp+8h]
  int v41; // [esp+24h] [ebp+8h]

  result = a3;
  v6 = a1;
  v7 = *((_BYTE *)a1 + 9);
  v8 = *a1;
  v37 = *a1;
  if ( v7 <= 8u && a3 || v7 == 16 && a4 )
  {
    if ( *((_BYTE *)a1 + 8) )
    {
      switch ( *((_BYTE *)a1 + 8) )
      {
        case 2:
          if ( v7 == 8 )
          {
            v19 = a2;
            if ( v8 )
            {
              v20 = *a1;
              do
              {
                *v19 = a3[(unsigned __int8)*v19];
                v21 = v19 + 1;
                *v21 = a3[(unsigned __int8)*v21];
                ++v21;
                *v21 = a3[(unsigned __int8)*v21];
                v19 = v21 + 1;
                --v20;
              }
              while ( v20 );
            }
          }
          else
          {
            result = a2;
            if ( v8 )
            {
              v41 = *a1;
              do
              {
                v22 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                result[1] = v22;
                *result = HIBYTE(v22);
                v23 = result + 2;
                v24 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                v23[1] = v24;
                *v23 = HIBYTE(v24);
                v23 += 2;
                v25 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                *v23 = HIBYTE(v25);
                v23[1] = v25;
                result = v23 + 2;
                --v41;
              }
              while ( v41 );
            }
          }
          break;
        case 4:
          if ( v7 == 8 )
          {
            v16 = a2;
            if ( v8 )
            {
              v17 = *a1;
              do
              {
                *v16 = a3[(unsigned __int8)*v16];
                v16 += 2;
                --v17;
              }
              while ( v17 );
            }
          }
          else
          {
            for ( result = a2; v8; --v8 )
            {
              v18 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
              *result = HIBYTE(v18);
              result[1] = v18;
              result += 4;
            }
          }
          break;
        case 6:
          if ( v7 == 8 )
          {
            v9 = a2;
            if ( v8 )
            {
              v10 = *a1;
              do
              {
                *v9 = a3[(unsigned __int8)*v9];
                v11 = v9 + 1;
                *v11 = a3[(unsigned __int8)*v11];
                ++v11;
                *v11 = a3[(unsigned __int8)*v11];
                v9 = v11 + 2;
                --v10;
              }
              while ( v10 );
            }
          }
          else
          {
            result = a2;
            if ( v8 )
            {
              v40 = *a1;
              do
              {
                v12 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                result[1] = v12;
                *result = HIBYTE(v12);
                v13 = result + 2;
                v14 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                v13[1] = v14;
                *v13 = HIBYTE(v14);
                v13 += 2;
                v15 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                *v13 = HIBYTE(v15);
                v13[1] = v15;
                result = v13 + 4;
                --v40;
              }
              while ( v40 );
            }
          }
          break;
      }
    }
    else
    {
      if ( v7 == 2 )
      {
        v39 = a2;
        if ( v8 )
        {
          v38 = ((unsigned int)(v8 - 1) >> 2) + 1;
          do
          {
            v26 = *v39;
            v27 = *v39 & 0xC;
            v28 = *v39 & 0x30;
            LOBYTE(v27) = a3[*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0) >> 2)) >> 2)) >> 2)] & 0xC0
                        | ((unsigned __int8)(a3[v28 | (4 * v28) | ((v28 | (v28 >> 2)) >> 2)] & 0xC3
                                           | ((unsigned __int8)((a3[v26 & 3
                                                                  | (4 * (v26 & 3 | (4 * (v26 & 3 | (4 * (v26 & 3))))))] >> 2)
                                                              | a3[v27 | (v27 >> 2) | (4 * (v27 | (4 * (v26 & 0xC))))]
                                                              & 0xCF) >> 2)) >> 2);
            v29 = v39++;
            v30 = v38-- == 1;
            *v29 = v27;
          }
          while ( !v30 );
          v8 = v37;
          v6 = a1;
        }
      }
      v31 = *((_BYTE *)v6 + 9);
      switch ( v31 )
      {
        case 4:
          v32 = a2;
          if ( v8 )
          {
            v33 = ((unsigned int)(v8 - 1) >> 1) + 1;
            do
            {
              *v32 = (a3[*v32 & 0xF | (16 * (*v32 & 0xF))] >> 4) | a3[*v32 & 0xF0 | ((*v32 & 0xF0) >> 4)] & 0xF0;
              ++v32;
              --v33;
            }
            while ( v33 );
          }
          break;
        case 8:
          v34 = a2;
          if ( v8 )
          {
            v35 = v8;
            do
            {
              *v34 = a3[(unsigned __int8)*v34];
              ++v34;
              --v35;
            }
            while ( v35 );
          }
          break;
        case 16:
          for ( result = a2; v8; --v8 )
          {
            v36 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
            *result = HIBYTE(v36);
            result[1] = v36;
            result += 2;
          }
          break;
      }
    }
  }
  return result;
}

// sub_1001F6C5 @ 0x1001F6C5
int __cdecl sub_1001F6C5(int *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  unsigned __int8 v7; // cl
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  _BYTE *v11; // edx
  bool v12; // zf
  int v13; // ecx
  _BYTE *v14; // edx
  int v15; // ecx
  _BYTE *v16; // edx
  unsigned __int8 *v17; // edx
  int v18; // ebx
  _BYTE *v19; // ecx
  _BYTE *v20; // ecx
  _BYTE *v21; // ecx
  _BYTE *v22; // ecx
  int v23; // [esp+4h] [ebp-8h]
  int v24; // [esp+4h] [ebp-8h]
  int v25; // [esp+4h] [ebp-8h]
  int v26; // [esp+4h] [ebp-8h]
  int v27; // [esp+4h] [ebp-8h]
  _BYTE *v28; // [esp+8h] [ebp-4h]
  _BYTE *v29; // [esp+8h] [ebp-4h]
  _BYTE *v30; // [esp+8h] [ebp-4h]
  int v31; // [esp+14h] [ebp+8h]
  int v32; // [esp+14h] [ebp+8h]
  int v33; // [esp+14h] [ebp+8h]
  int v34; // [esp+14h] [ebp+8h]
  int v35; // [esp+14h] [ebp+8h]

  result = *a1;
  if ( *((_BYTE *)a1 + 8) == 3 )
  {
    v7 = *((_BYTE *)a1 + 9);
    if ( v7 < 8u )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          if ( v9 == 2 )
          {
            v28 = (_BYTE *)(result + a2 - 1);
            LOBYTE(v10) = 4 * (result & 1);
            v11 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 1));
            v31 = 4 * (*a1 & 1);
            if ( result )
            {
              v23 = result;
              do
              {
                *v28 = (*v11 >> v10) & 0xF;
                if ( v31 == 4 )
                {
                  v10 = 0;
                  --v11;
                }
                else
                {
                  v10 = v31 + 4;
                }
                --v28;
                v12 = v23-- == 1;
                v31 = v10;
              }
              while ( !v12 );
            }
          }
        }
        else
        {
          v29 = (_BYTE *)(result + a2 - 1);
          LOBYTE(v13) = 2 * (3 - ((result - 1) & 3));
          v14 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 2));
          v32 = 2 * (3 - (((_BYTE)result - 1) & 3));
          if ( result )
          {
            v24 = result;
            do
            {
              *v29 = (*v14 >> v13) & 3;
              if ( v32 == 6 )
              {
                v13 = 0;
                --v14;
              }
              else
              {
                v13 = v32 + 2;
              }
              --v29;
              v12 = v24-- == 1;
              v32 = v13;
            }
            while ( !v12 );
          }
        }
      }
      else
      {
        v30 = (_BYTE *)(result + a2 - 1);
        LOBYTE(v15) = 7 - ((result - 1) & 7);
        v16 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 3));
        v33 = 7 - (((_BYTE)result - 1) & 7);
        if ( result )
        {
          v25 = result;
          do
          {
            *v30 = (*v16 >> v15) & 1;
            if ( v33 == 7 )
            {
              v15 = 0;
              --v16;
            }
            else
            {
              v15 = v33 + 1;
            }
            --v30;
            v12 = v25-- == 1;
            v33 = v15;
          }
          while ( !v12 );
        }
      }
      *((_BYTE *)a1 + 9) = 8;
      *((_BYTE *)a1 + 11) = 8;
      a1[1] = result;
    }
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      v17 = (unsigned __int8 *)(result + a2 - 1);
      if ( a4 )
      {
        v18 = 4 * result;
        v26 = 4 * result;
        v19 = (_BYTE *)(4 * result + a2 - 1);
        if ( result )
        {
          v34 = result;
          result = a3;
          do
          {
            if ( *v17 < a5 )
              *v19 = *(_BYTE *)(*v17 + a4);
            else
              *v19 = -1;
            v20 = v19 - 1;
            *v20-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 2);
            *v20-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 1);
            *v20 = *(_BYTE *)(*v17 + a3 + 2 * *v17);
            v19 = v20 - 1;
            --v17;
            --v34;
          }
          while ( v34 );
          v18 = v26;
        }
        *((_BYTE *)a1 + 11) = 32;
        *((_BYTE *)a1 + 8) = 6;
        *((_BYTE *)a1 + 10) = 4;
      }
      else
      {
        v18 = 3 * result;
        v27 = 3 * result;
        v21 = (_BYTE *)(3 * result + a2 - 1);
        if ( result )
        {
          v35 = result;
          result = a3;
          do
          {
            *v21 = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 2);
            v22 = v21 - 1;
            *v22-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 1);
            *v22 = *(_BYTE *)(*v17 + a3 + 2 * *v17);
            v21 = v22 - 1;
            --v17;
            --v35;
          }
          while ( v35 );
          v18 = v27;
        }
        *((_BYTE *)a1 + 11) = 24;
        *((_BYTE *)a1 + 8) = 2;
        *((_BYTE *)a1 + 10) = 3;
      }
      *((_BYTE *)a1 + 9) = 8;
      a1[1] = v18;
    }
  }
  return result;
}

// sub_1001F8CD @ 0x1001F8CD
int __cdecl sub_1001F8CD(int *a1, int a2, _WORD *a3)
{
  char v4; // cl
  int result; // eax
  unsigned __int16 v6; // bx
  unsigned __int8 v7; // cl
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  unsigned __int8 *v11; // edx
  bool v12; // zf
  int v13; // ecx
  unsigned __int8 *v14; // edx
  char v15; // bl
  int v16; // ecx
  _BYTE *v17; // edx
  char v18; // cl
  _BYTE *v19; // ecx
  _BYTE *v20; // edi
  int v21; // edx
  _BYTE *v22; // edi
  int v23; // edx
  _BYTE *v24; // ecx
  _BYTE *v25; // edi
  unsigned __int16 v26; // bx
  _BYTE *v27; // edi
  _BYTE *v28; // edi
  char v29; // cl
  unsigned __int8 v30; // cl
  _WORD *v31; // edx
  char v32; // cl
  _BYTE *v33; // ecx
  _BYTE *v34; // edi
  _BYTE *v35; // edi
  _BYTE *v36; // ecx
  _BYTE *v37; // ecx
  _BYTE *v38; // edi
  __int16 v39; // bx
  __int16 v40; // dx
  __int16 v41; // dx
  _BYTE *v42; // edi
  _BYTE *v43; // edi
  _BYTE *v44; // ecx
  char v45; // cl
  int v46; // [esp+Ch] [ebp-Ch]
  int v47; // [esp+Ch] [ebp-Ch]
  int v48; // [esp+Ch] [ebp-Ch]
  int v49; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v50; // [esp+10h] [ebp-8h]
  _BYTE *v51; // [esp+14h] [ebp-4h]
  _BYTE *v52; // [esp+14h] [ebp-4h]
  _BYTE *v53; // [esp+14h] [ebp-4h]
  int v54; // [esp+20h] [ebp+8h]
  int v55; // [esp+20h] [ebp+8h]
  int v56; // [esp+20h] [ebp+8h]
  int v57; // [esp+20h] [ebp+8h]
  int v58; // [esp+20h] [ebp+8h]
  int v59; // [esp+20h] [ebp+8h]

  v4 = *((_BYTE *)a1 + 8);
  result = *a1;
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      v31 = a3;
      if ( a3 )
      {
        v32 = *((_BYTE *)a1 + 9);
        if ( v32 == 8 )
        {
          v33 = (_BYTE *)(a1[1] + a2 - 1);
          v34 = (_BYTE *)(a2 + 4 * result - 1);
          if ( result )
          {
            v58 = *a1;
            do
            {
              if ( (unsigned __int8)*(v33 - 2) == a3[1]
                && (unsigned __int8)*(v33 - 1) == a3[2]
                && (unsigned __int8)*v33 == a3[3] )
              {
                *v34 = 0;
              }
              else
              {
                *v34 = -1;
              }
              v35 = v34 - 1;
              *v35-- = *v33;
              v36 = v33 - 1;
              *v35-- = *v36;
              *v35 = *--v36;
              v34 = v35 - 1;
              v33 = v36 - 1;
              --v58;
            }
            while ( v58 );
          }
        }
        else if ( v32 == 16 )
        {
          v37 = (_BYTE *)(a1[1] + a2 - 1);
          v38 = (_BYTE *)(a2 + 8 * result - 1);
          if ( result )
          {
            v59 = *a1;
            while ( 1 )
            {
              HIBYTE(v39) = *(v37 - 5);
              LOBYTE(v39) = *(v37 - 4);
              if ( v39 == v31[1]
                && (HIBYTE(v40) = *(v37 - 3), LOBYTE(v40) = *(v37 - 2), v40 == a3[2])
                && (HIBYTE(v41) = *(v37 - 1), LOBYTE(v41) = *v37, v41 == a3[3]) )
              {
                *v38 = 0;
                v42 = v38 - 1;
                *v42 = 0;
              }
              else
              {
                *v38 = -1;
                v42 = v38 - 1;
                *v42 = -1;
              }
              v43 = v42 - 1;
              *v43-- = *v37;
              v44 = v37 - 1;
              *v43-- = *v44;
              *v43-- = *--v44;
              *v43-- = *--v44;
              *v43-- = *--v44;
              *v43 = *--v44;
              v38 = v43 - 1;
              v37 = v44 - 1;
              if ( !--v59 )
                break;
              v31 = a3;
            }
          }
        }
        v45 = *((_BYTE *)a1 + 9);
        *((_BYTE *)a1 + 8) = 6;
        *((_BYTE *)a1 + 10) = 4;
        v30 = 4 * v45;
        goto LABEL_68;
      }
    }
  }
  else
  {
    v6 = 0;
    if ( a3 )
      v6 = a3[4];
    v7 = *((_BYTE *)a1 + 9);
    v50 = v6;
    if ( v7 < 8u )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          if ( v9 == 2 )
          {
            v51 = (_BYTE *)(result + a2 - 1);
            v50 = 17 * v6;
            LOBYTE(v10) = 4 - 4 * ((result - 1) & 1);
            v11 = (unsigned __int8 *)(a2 + ((unsigned int)(result - 1) >> 1));
            v54 = 4 - 4 * (((_BYTE)result - 1) & 1);
            if ( result )
            {
              v46 = result;
              do
              {
                *v51 = (*v11 >> v10) & 0xF | (16 * ((*v11 >> v10) & 0xF));
                v10 = 4;
                if ( v54 == 4 )
                {
                  v10 = 0;
                  --v11;
                }
                --v51;
                v12 = v46-- == 1;
                v54 = v10;
              }
              while ( !v12 );
            }
          }
        }
        else
        {
          v50 = 85 * v6;
          v52 = (_BYTE *)(result + a2 - 1);
          v13 = (unsigned __int8)(2 * (3 - ((result - 1) & 3)));
          v14 = (unsigned __int8 *)(a2 + ((unsigned int)(result - 1) >> 2));
          v55 = 2 * (3 - (((_BYTE)result - 1) & 3));
          if ( result )
          {
            v47 = result;
            do
            {
              v15 = (*v14 >> v13) & 3;
              *v52 = v15 | (4 * (v15 | (4 * (v15 | (4 * v15)))));
              if ( v55 == 6 )
              {
                v13 = 0;
                --v14;
              }
              else
              {
                v13 = v55 + 2;
              }
              --v52;
              v12 = v47-- == 1;
              v55 = v13;
            }
            while ( !v12 );
          }
        }
      }
      else
      {
        v50 = 255 * v6;
        v53 = (_BYTE *)(result + a2 - 1);
        v16 = (unsigned __int8)(7 - ((result - 1) & 7));
        v17 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 3));
        v56 = 7 - (((_BYTE)result - 1) & 7);
        if ( result )
        {
          v48 = result;
          do
          {
            *v53 = -(((*v17 >> v16) & 1) != 0);
            if ( v56 == 7 )
            {
              v16 = 0;
              --v17;
            }
            else
            {
              v16 = v56 + 1;
            }
            --v53;
            v12 = v48-- == 1;
            v56 = v16;
          }
          while ( !v12 );
        }
      }
      v6 = v50;
      *((_BYTE *)a1 + 9) = 8;
      *((_BYTE *)a1 + 11) = 8;
      a1[1] = result;
    }
    if ( a3 )
    {
      v18 = *((_BYTE *)a1 + 9);
      if ( v18 == 8 )
      {
        v19 = (_BYTE *)(result + a2 - 1);
        v20 = (_BYTE *)(a2 + 2 * result - 1);
        if ( result )
        {
          v21 = result;
          do
          {
            if ( (unsigned __int8)*v19 == v50 )
              *v20 = 0;
            else
              *v20 = -1;
            v22 = v20 - 1;
            *v22 = *v19;
            v20 = v22 - 1;
            --v19;
            --v21;
          }
          while ( v21 );
        }
      }
      else if ( v18 == 16 )
      {
        v23 = a1[1];
        v24 = (_BYTE *)(v23 + a2 - 1);
        v25 = (_BYTE *)(a2 + 2 * v23 - 1);
        if ( result )
        {
          v49 = v6;
          v57 = result;
          do
          {
            HIBYTE(v26) = *(v24 - 1);
            LOBYTE(v26) = *v24;
            if ( v26 == v49 )
            {
              *v25 = 0;
              v27 = v25 - 1;
              *v27 = 0;
            }
            else
            {
              *v25 = -1;
              v27 = v25 - 1;
              *v27 = -1;
            }
            v28 = v27 - 1;
            *v28-- = *v24;
            *v28 = *(v24 - 1);
            v25 = v28 - 1;
            v24 -= 2;
            --v57;
          }
          while ( v57 );
        }
      }
      v29 = *((_BYTE *)a1 + 9);
      *((_BYTE *)a1 + 8) = 4;
      *((_BYTE *)a1 + 10) = 2;
      v30 = 2 * v29;
LABEL_68:
      *((_BYTE *)a1 + 11) = v30;
      a1[1] = (result * (unsigned int)v30) >> 3;
    }
  }
  return result;
}

// sub_1001FC1F @ 0x1001FC1F
int __cdecl sub_1001FC1F(int *a1, char *a2, int a3, int a4)
{
  char v5; // cl
  int result; // eax
  char *v7; // edx
  char v8; // al
  char *v9; // edx
  char v10; // bl
  char v11; // al
  char *v12; // esi
  bool v13; // zf
  unsigned __int8 v14; // cl
  char *v15; // edx
  char v16; // al
  char *v17; // edx
  char v18; // bl
  char v19; // al
  char *v20; // esi
  char *i; // ecx
  int v22; // [esp+Ch] [ebp-8h]
  int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  char *v25; // [esp+1Ch] [ebp+8h]
  char *v26; // [esp+1Ch] [ebp+8h]

  v5 = *((_BYTE *)a1 + 8);
  result = *a1;
  v22 = *a1;
  if ( v5 == 2 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v7 = a2;
    v25 = a2;
    if ( !result )
    {
LABEL_8:
      v14 = *((_BYTE *)a1 + 9);
      *((_BYTE *)a1 + 11) = v14;
      *((_BYTE *)a1 + 8) = 3;
      *((_BYTE *)a1 + 10) = 1;
      a1[1] = (result * (unsigned int)v14 + 7) >> 3;
      return result;
    }
    v23 = result;
    do
    {
      v8 = *v7;
      v9 = v7 + 1;
      v10 = *v9++;
      v11 = *(_BYTE *)((((int)(unsigned __int8)*v9 >> 3) & 0x1F | (4 * (v10 & 0xF8 | (32 * (v8 & 0xF8))))) + a3);
      v12 = v25;
      v7 = v9 + 1;
      ++v25;
      v13 = v23-- == 1;
      *v12 = v11;
    }
    while ( !v13 );
LABEL_7:
    result = v22;
    goto LABEL_8;
  }
  if ( v5 == 6 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v15 = a2;
    v26 = a2;
    if ( !result )
      goto LABEL_8;
    v24 = result;
    do
    {
      v16 = *v15;
      v17 = v15 + 1;
      v18 = *v17++;
      v19 = *(_BYTE *)((((int)(unsigned __int8)*v17 >> 3) & 0x1F | (4 * (v18 & 0xF8 | (32 * (v16 & 0xF8))))) + a3);
      v20 = v26;
      v15 = v17 + 2;
      ++v26;
      v13 = v24-- == 1;
      *v20 = v19;
    }
    while ( !v13 );
    goto LABEL_7;
  }
  if ( v5 == 3 )
  {
    if ( a4 )
    {
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        for ( i = a2; result; --result )
        {
          *i = *(_BYTE *)((unsigned __int8)*i + a4);
          ++i;
        }
      }
    }
  }
  return result;
}

// FUN_1001fd2d @ 0x1001FD2D
void FUN_1001fd2d(void *png_ptr)
{
  long double v2; // st7
  void *v3; // eax
  __int64 v4; // rax
  int v5; // eax
  unsigned int v6; // edi
  int v7; // ebx
  long double v8; // st7
  void *v9; // eax
  bool v10; // zf
  void *v11; // eax
  int *__attribute__((__org_typedef(jmp_buf))) v12; // edx
  __int16 v13; // cx
  unsigned int v14; // ebx
  int v15; // eax
  int v16; // ebx
  __int64 v17; // rax
  double v18; // [esp+4h] [ebp-28h]
  unsigned int v19; // [esp+14h] [ebp-18h]
  unsigned int v20; // [esp+18h] [ebp-14h]
  char v21; // [esp+1Ch] [ebp-10h]
  unsigned int v22; // [esp+20h] [ebp-Ch]
  int v23; // [esp+28h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+34h] [ebp+8h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+34h] [ebp+8h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufb; // [esp+34h] [ebp+8h]

  if ( *((float *)png_ptr + 76) != 0.0 )
  {
    if ( *((_BYTE *)png_ptr + 279) > 8u )
    {
      if ( (*((_BYTE *)png_ptr + 278) & 2) != 0 )
      {
        v5 = *((unsigned __int8 *)png_ptr + 336);
        if ( *((unsigned __int8 *)png_ptr + 337) > v5 )
          v5 = *((unsigned __int8 *)png_ptr + 337);
        if ( *((unsigned __int8 *)png_ptr + 338) > v5 )
          v5 = *((unsigned __int8 *)png_ptr + 338);
      }
      else
      {
        v5 = *((unsigned __int8 *)png_ptr + 339);
      }
      v6 = 0;
      if ( v5 <= 0 )
        v23 = 0;
      else
        v23 = 16 - v5;
      if ( (*((_BYTE *)png_ptr + 97) & 4) != 0 && v23 < 5 )
        v23 = 5;
      if ( v23 > 8 )
        v23 = 8;
      if ( v23 < 0 )
        v23 = 0;
      v7 = 1 << (8 - v23);
      v21 = 8 - v23;
      *((_DWORD *)png_ptr + 75) = (unsigned __int8)v23;
      if ( *((float *)png_ptr + 77) <= 0.000001 )
        v8 = 1.0;
      else
        v8 = 1.0 / (*((float *)png_ptr + 77) * *((float *)png_ptr + 76));
      v9 = png_malloc(png_ptr, 4 * v7);
      v10 = (*((_WORD *)png_ptr + 48) & 0x480) == 0;
      *((_DWORD *)png_ptr + 81) = v9;
      Bufa = 0;
      if ( v10 )
      {
        if ( v7 > 0 )
        {
          do
          {
            *(_DWORD *)(*((_DWORD *)png_ptr + 81) + 4 * (_DWORD)Bufa) = png_malloc(png_ptr, 0x200u);
            v16 = 0;
            v22 = (unsigned int)((_DWORD)Bufa * dword_100544A0[v23]) >> 4;
            do
            {
              v17 = (__int64)(pow((double)v22 * 0.00001525902189669642, v8) * 65535.0 + 0.5);
              v22 += 256;
              *(_WORD *)(v16 + *(_DWORD *)(*((_DWORD *)png_ptr + 81) + 4 * (_DWORD)Bufa)) = v17;
              v16 += 2;
            }
            while ( v16 < 512 );
            Bufa = (int *)((char *)Bufa + 1);
          }
          while ( (int)Bufa < 1 << (8 - v23) );
        }
      }
      else
      {
        if ( v7 > 0 )
        {
          do
          {
            v11 = png_malloc(png_ptr, 0x200u);
            v12 = Bufa;
            Bufa = (int *)((char *)Bufa + 1);
            *(_DWORD *)(*((_DWORD *)png_ptr + 81) + 4 * (_DWORD)v12) = v11;
          }
          while ( (int)Bufa < v7 );
          v6 = 0;
        }
        Bufb = 0;
        v20 = v7 << 8;
        v18 = (double)(unsigned int)(v7 << 8);
        do
        {
          v19 = (__int64)(pow(((double)(int)Bufb + 0.5) * 0.00390625, 1.0 / v8) * v18);
          if ( v6 <= v19 )
          {
            LOBYTE(v13) = 0;
            HIBYTE(v13) = (_BYTE)Bufb;
            do
            {
              v14 = v6 >> v21;
              v15 = *(_DWORD *)(*((_DWORD *)png_ptr + 81) + 4 * (v6++ & (255 >> v23)));
              *(_WORD *)(v15 + 2 * v14) = (unsigned __int16)Bufb | v13;
            }
            while ( v6 <= v19 );
          }
          Bufb = (int *)((char *)Bufb + 1);
        }
        while ( (int)Bufb < 256 );
        for ( ; v6 < v20; ++v6 )
          *(_WORD *)(*(_DWORD *)(*((_DWORD *)png_ptr + 81) + 4 * (v6 & (255 >> v23))) + 2 * (v6 >> v21)) = -1;
      }
    }
    else
    {
      if ( *((float *)png_ptr + 77) <= 0.000001 )
        v2 = 1.0;
      else
        v2 = 1.0 / (*((float *)png_ptr + 77) * *((float *)png_ptr + 76));
      v3 = png_malloc(png_ptr, 0x100u);
      Buf = 0;
      *((_DWORD *)png_ptr + 78) = v3;
      do
      {
        v4 = (__int64)(pow((double)(int)Buf * 0.00392156862745098, v2) * 255.0 + 0.5);
        HIDWORD(v4) = Buf;
        Buf = (int *)((char *)Buf + 1);
        *(_BYTE *)(HIDWORD(v4) + *((_DWORD *)png_ptr + 78)) = v4;
      }
      while ( (int)Buf < 256 );
    }
  }
}

// FUN_10020036 @ 0x10020036
void FUN_10020036(void *png_ptr)
{
  int v2; // edi
  int v3; // ecx
  _BYTE *v4; // eax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 v8; // cx
  int v9; // eax
  int v10; // edi
  char v11; // [esp+Ch] [ebp-4h]
  char Buf; // [esp+18h] [ebp+8h]

  v2 = *((unsigned __int8 *)png_ptr + 278);
  if ( (*((_DWORD *)png_ptr + 24) & 0x602000) != 0 )
  {
    FUN_1001fd2d(png_ptr);
    if ( v2 == 3 )
    {
      v3 = *((unsigned __int16 *)png_ptr + 132);
      if ( *((_WORD *)png_ptr + 132) )
      {
        v4 = (_BYTE *)(*((_DWORD *)png_ptr + 65) + 2);
        do
        {
          *(v4 - 2) = *(_BYTE *)((unsigned __int8)*(v4 - 2) + *((_DWORD *)png_ptr + 78));
          *(v4 - 1) = *(_BYTE *)((unsigned __int8)*(v4 - 1) + *((_DWORD *)png_ptr + 78));
          *v4 = *(_BYTE *)((unsigned __int8)*v4 + *((_DWORD *)png_ptr + 78));
          v4 += 3;
          --v3;
        }
        while ( v3 );
      }
    }
  }
  if ( (*((_BYTE *)png_ptr + 96) & 8) != 0 && v2 == 3 )
  {
    v5 = 8 - *((unsigned __int8 *)png_ptr + 336);
    v6 = 8 - *((unsigned __int8 *)png_ptr + 337);
    v7 = 8 - *((unsigned __int8 *)png_ptr + 338);
    Buf = 8 - *((_BYTE *)png_ptr + 337);
    v11 = 8 - *((_BYTE *)png_ptr + 338);
    if ( v5 > 8 )
      LOBYTE(v5) = 0;
    if ( v6 > 8 )
      Buf = 0;
    if ( v7 > 8 )
      v11 = 0;
    v8 = *((_WORD *)png_ptr + 132);
    if ( v8 )
    {
      v9 = 0;
      v10 = v8;
      do
      {
        *(_BYTE *)(v9 + *((_DWORD *)png_ptr + 65)) >>= v5;
        *(_BYTE *)(v9 + *((_DWORD *)png_ptr + 65) + 1) >>= Buf;
        *(_BYTE *)(v9 + *((_DWORD *)png_ptr + 65) + 2) >>= v11;
        v9 += 3;
        --v10;
      }
      while ( v10 );
    }
  }
}

// FUN_10020149 @ 0x10020149
void FUN_10020149(void *png_ptr)
{
  if ( !*((_DWORD *)png_ptr + 55) )
    png_error(png_ptr, "NULL row buffer");
  if ( (*((_BYTE *)png_ptr + 97) & 0x10) != 0 )
  {
    if ( *((_BYTE *)png_ptr + 248) == 3 )
    {
      sub_1001F6C5(
        (int *)png_ptr + 60,
        *((_DWORD *)png_ptr + 55) + 1,
        *((_DWORD *)png_ptr + 65),
        *((_DWORD *)png_ptr + 87),
        *((unsigned __int16 *)png_ptr + 133));
    }
    else if ( *((_WORD *)png_ptr + 133) )
    {
      sub_1001F8CD((int *)png_ptr + 60, *((_DWORD *)png_ptr + 55) + 1, (_WORD *)png_ptr + 176);
    }
    else
    {
      sub_1001F8CD((int *)png_ptr + 60, *((_DWORD *)png_ptr + 55) + 1, 0);
    }
  }
  if ( (*((_BYTE *)png_ptr + 97) & 0x20) != 0 && *((_BYTE *)png_ptr + 278) != 3 )
    sub_1001F377(
      (int *)png_ptr + 60,
      (_BYTE *)(*((_DWORD *)png_ptr + 55) + 1),
      *((unsigned __int8 **)png_ptr + 78),
      *((_DWORD *)png_ptr + 81),
      *((_DWORD *)png_ptr + 75));
  if ( (*((_BYTE *)png_ptr + 97) & 4) != 0 )
    sub_1001F0FB((int)png_ptr + 240, (_BYTE *)(*((_DWORD *)png_ptr + 55) + 1));
  if ( (*((_BYTE *)png_ptr + 96) & 0x40) != 0 )
  {
    sub_1001FC1F(
      (int *)png_ptr + 60,
      (char *)(*((_DWORD *)png_ptr + 55) + 1),
      *((_DWORD *)png_ptr + 93),
      *((_DWORD *)png_ptr + 94));
    if ( !*((_DWORD *)png_ptr + 61) )
      png_error(png_ptr, "png_do_dither returned rowbytes=0");
  }
  if ( (*((_BYTE *)png_ptr + 96) & 8) != 0 )
    sub_1001EF84((int *)png_ptr + 60, (_BYTE *)(*((_DWORD *)png_ptr + 55) + 1), (unsigned __int8 *)png_ptr + 341);
  if ( (*((_BYTE *)png_ptr + 96) & 4) != 0 )
    sub_1001EE74((int *)png_ptr + 60, *((_DWORD *)png_ptr + 55) + 1);
  if ( (*((_BYTE *)png_ptr + 96) & 1) != 0 )
    sub_1001EC8B((int *)png_ptr + 60, (char *)(*((_DWORD *)png_ptr + 55) + 1));
  if ( *((char *)png_ptr + 97) < 0 )
    sub_1001F13F(
      (int)png_ptr + 240,
      *((_DWORD *)png_ptr + 55) + 1,
      *((unsigned __int16 *)png_ptr + 143),
      *((_DWORD *)png_ptr + 23));
  if ( (*((_BYTE *)png_ptr + 96) & 0x10) != 0 )
    sub_1001EC5E((int)png_ptr + 240, (char *)(*((_DWORD *)png_ptr + 55) + 1));
}

// sub_10020301 @ 0x10020301
void __cdecl sub_10020301(int a1, int a2, double a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 1u;
      *(float *)(a2 + 40) = a3;
    }
  }
}

// FUN_1002031c @ 0x1002031C
void FUN_1002031c(
        void *png_ptr,
        unsigned int *param_2,
        unsigned int param_3,
        unsigned int param_4,
        char param_5,
        unsigned __int8 param_6,
        unsigned __int8 param_7,
        unsigned __int8 param_8,
        unsigned __int8 param_9)
{
  unsigned __int8 v9; // al

  if ( png_ptr && param_2 )
  {
    *((_BYTE *)param_2 + 26) = param_8;
    param_2[1] = param_4;
    *((_BYTE *)param_2 + 27) = param_9;
    *param_2 = param_3;
    *((_BYTE *)param_2 + 24) = param_5;
    *((_BYTE *)param_2 + 25) = param_6;
    *((_BYTE *)param_2 + 28) = param_7;
    if ( param_6 == 3 || (param_6 & 2) == 0 )
      *((_BYTE *)param_2 + 29) = 1;
    else
      *((_BYTE *)param_2 + 29) = 3;
    if ( (param_6 & 4) != 0 )
      ++*((_BYTE *)param_2 + 29);
    v9 = param_5 * *((_BYTE *)param_2 + 29);
    *((_BYTE *)param_2 + 30) = v9;
    if ( param_3 <= 0x7FFFFFFFu / ((v9 + 7) >> 3) )
    {
      param_2[3] = (param_3 * v9 + 7) >> 3;
    }
    else
    {
      png_warning(png_ptr, "Width too large to process image data; rowbytes will overflow.");
      param_2[3] = 0;
    }
  }
}

// sub_100203BD @ 0x100203BD
void __cdecl sub_100203BD(int a1, int a2, int a3, __int16 a4)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 8u;
      *(_DWORD *)(a2 + 16) = a3;
      *(_WORD *)(a2 + 20) = a4;
    }
  }
}

// sub_100203E1 @ 0x100203E1
void __cdecl sub_100203E1(int a1, int a2, char a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_BYTE *)(a2 + 9) |= 8u;
      *(_BYTE *)(a2 + 44) = a3;
    }
  }
}

// sub_100203FC @ 0x100203FC
void __cdecl sub_100203FC(int a1, __int64 a2)
{
  if ( a1 )
  {
    if ( (_DWORD)a2 )
    {
      sub_100203E1(a1, a2, SBYTE4(a2));
      sub_10020301(a1, a2, 0.4545499980449677);
    }
  }
}

// sub_10020435 @ 0x10020435
void __cdecl sub_10020435(int a1, int a2, int a3, int a4, int a5)
{
  if ( a1 && a2 )
  {
    if ( a3 )
      *(_DWORD *)(a2 + 48) = a3;
    if ( a5 )
    {
      *(_DWORD *)(a2 + 52) = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 56) = *(_DWORD *)(a5 + 4);
      *(_WORD *)(a2 + 60) = *(_WORD *)(a5 + 8);
      if ( !a4 )
        LOWORD(a4) = 1;
    }
    *(_DWORD *)(a2 + 8) |= 0x10u;
    *(_WORD *)(a2 + 22) = a4;
  }
}

// png_read_data @ 0x1002047C
// png read callback wrapper (errors if NULL)
void png_read_data(void *png_ptr, unsigned __int8 *data, unsigned int length)
{
  void (__cdecl *v3)(void *, unsigned __int8 *, unsigned int); // eax

  v3 = (void (__cdecl *)(void *, unsigned __int8 *, unsigned int))*((_DWORD *)png_ptr + 20);
  if ( !v3 )
    png_error(png_ptr, "Call to NULL read function");
  v3(png_ptr, data, length);
}

// FUN_100204a4 @ 0x100204A4
void FUN_100204a4(void *png_ptr, unsigned int param_2, unsigned int param_3)
{
  bool v3; // zf

  v3 = *((_DWORD *)png_ptr + 19) == 0;
  *((_DWORD *)png_ptr + 21) = param_2;
  *((_DWORD *)png_ptr + 20) = param_3;
  if ( !v3 )
  {
    *((_DWORD *)png_ptr + 19) = 0;
    png_warning(png_ptr, "It's an error to set both read_data_fn and write_data_fn in the ");
    png_warning(png_ptr, "same structure.  Resetting write_data_fn to NULL.");
  }
  *((_DWORD *)png_ptr + 72) = 0;
}

// sub_100204E3 @ 0x100204E3
int __cdecl sub_100204E3(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ecx

  v3 = a3;
  if ( a3 <= 8 )
  {
    if ( !a3 )
      return 0;
  }
  else
  {
    v3 = 8;
  }
  if ( a2 > 7 )
    return 0;
  if ( a2 + v3 > 8 )
    v3 = 8 - a2;
  return memcmp((const char *)(a1 + a2), &byte_1004E51C[a2], v3);
}

// FUN_1002052b @ 0x1002052B
unsigned int *FUN_1002052b(void *png_ptr, int param_2, int param_3)
{
  unsigned int v3; // esi
  char *v4; // edx
  unsigned int *result; // eax
  void *v6; // edi
  unsigned int v7; // ecx

  v3 = param_3 * param_2;
  v4 = (char *)png_malloc(png_ptr, param_3 * param_2);
  result = 0;
  if ( v4 )
  {
    v6 = v4;
    if ( v3 <= 0x8000 )
    {
      v7 = param_3 * param_2;
    }
    else
    {
      memset(v4, 0, 0x8000u);
      v7 = v3 - 0x8000;
      v6 = v4 + 0x8000;
    }
    memset(v6, 0, v7);
    return (unsigned int *)v4;
  }
  return result;
}

// png_reset_crc @ 0x10020583
// reset png CRC state
void png_reset_crc(void *png_ptr)
{
  *((_DWORD *)png_ptr + 64) = sub_10025AEC(0, 0, 0);
}

// FUN_100205da @ 0x100205DA
// [binja] void sub_100205da(int32_t arg1)
void FUN_100205da(int arg1)
{
  void *v1; // [esp+Ch] [ebp+8h]

  memset(v1, 0, 0x40u);
}

// sub_100205E8 @ 0x100205E8
void *__cdecl sub_100205E8(int a1)
{
  void *v2; // edx

  if ( !a1 )
    return 0;
  v2 = (void *)sub_100246F2(2);
  if ( v2 )
    memset(v2, 0, 0x40u);
  return v2;
}

// grim_dxt_decode_rgb565 @ 0x1002060E
// unpacks RGB565 into RGBA floats (alpha=1)
void grim_dxt_decode_rgb565(float *out_rgba, unsigned int rgb565)
{
  float *v2; // eax
  unsigned int v3; // ecx

  *v2 = (double)((unsigned __int16)v3 >> 11) * 0.032258064;
  v2[1] = (double)((v3 >> 5) & 0x3F) * 0.015873017;
  v2[2] = (double)(v3 & 0x1F) * 0.032258064;
  v2[3] = 1.0;
}

// grim_dxt_unpremultiply_rgba_block @ 0x1002065A
// divides rgb by alpha for a 4x4 RGBA block
int grim_dxt_unpremultiply_rgba_block(float *rgba)
{
  float *v1; // ecx
  int v2; // edx
  double v3; // st7
  double v4; // st7
  double v5; // st6
  double v6; // st6

  v2 = 16;
  do
  {
    if ( 0.0 == v1[3] )
    {
      *v1 = 0.0;
      v1[1] = 0.0;
      v3 = 0.0;
    }
    else
    {
      if ( v1[3] >= 1.0 )
        goto LABEL_15;
      v4 = 1.0 / v1[3];
      if ( *v1 >= (double)v1[3] )
        v5 = 1.0;
      else
        v5 = v4 * *v1;
      *v1 = v5;
      if ( v1[1] >= (double)v1[3] )
        v6 = 1.0;
      else
        v6 = v4 * v1[1];
      v1[1] = v6;
      if ( v1[2] >= (double)v1[3] )
        v3 = 1.0;
      else
        v3 = v4 * v1[2];
    }
    v1[2] = v3;
LABEL_15:
    v1 += 4;
    --v2;
  }
  while ( v2 );
  return 0;
}

// grim_dxt_premultiply_rgba_block @ 0x100206D8
// multiplies rgb by alpha for a 4x4 RGBA block
int grim_dxt_premultiply_rgba_block(float *out_rgba)
{
  float *v1; // eax
  float *v2; // ecx
  int v3; // edx
  double v4; // st7

  v3 = 16;
  do
  {
    v4 = v1[3] * *v1;
    v1 += 4;
    *v2 = v4;
    v2 += 4;
    --v3;
    *(v2 - 3) = *(v1 - 3) * *(v1 - 1);
    *(v2 - 2) = *(v1 - 2) * *(v1 - 1);
    *(v2 - 1) = *(v1 - 1);
  }
  while ( v3 );
  return 0;
}

// fpu_save_control_word @ 0x10020708
// captures x87 FPU control word into DAT_1005db70 (used by DXT encode helpers)
void fpu_save_control_word()
{
  int v0; // [esp+0h] [ebp-8h]

  fpu_control_word_saved_dxt = v0;
}

// grim_dxt_pack_rgb565 @ 0x1002072B
// clamps rgb floats and packs into RGB565
unsigned int grim_dxt_pack_rgb565(float *rgb)
{
  float *v1; // ecx
  double v2; // st6
  double v3; // st6
  double v4; // st7
  int v5; // ecx
  float v7; // [esp+0h] [ebp-18h]
  float v8; // [esp+4h] [ebp-14h]
  float v9; // [esp+8h] [ebp-10h]
  float v10; // [esp+10h] [ebp-8h]
  float v11; // [esp+10h] [ebp-8h]
  float v12; // [esp+14h] [ebp-4h]

  if ( *v1 < 0.0 )
  {
    v2 = 0.0;
LABEL_3:
    v7 = v2;
    goto LABEL_7;
  }
  if ( *v1 > 1.0 )
  {
    v2 = 1.0;
    goto LABEL_3;
  }
  v7 = *v1;
LABEL_7:
  if ( v1[1] < 0.0 )
  {
    v3 = 0.0;
LABEL_9:
    v8 = v3;
    goto LABEL_13;
  }
  if ( v1[1] > 1.0 )
  {
    v3 = 1.0;
    goto LABEL_9;
  }
  v8 = v1[1];
LABEL_13:
  if ( v1[2] >= 0.0 )
  {
    if ( v1[2] <= 1.0 )
    {
      v9 = v1[2];
      goto LABEL_19;
    }
    v4 = 1.0;
  }
  else
  {
    v4 = 0.0;
  }
  v9 = v4;
LABEL_19:
  fpu_save_control_word();
  v12 = v7 * 31.0 + 0.5;
  v10 = v8 * 63.0 + 0.5;
  v5 = (int)v10;
  v11 = v9 * 31.0 + 0.5;
  return (int)v11 | (32 * (v5 | ((int)v12 << 6)));
}

// grim_dxt5_optimize_alpha_endpoints @ 0x10020825
// iteratively chooses DXT5 alpha endpoints for 6/8-alpha modes
void grim_dxt5_optimize_alpha_endpoints(float *min_out, float *max_out, float *alphas, unsigned int mode)
{
  unsigned int v4; // esi
  float *v5; // ebx
  unsigned int v6; // edx
  float *v7; // ecx
  float *v8; // ecx
  double v9; // st7
  int v10; // edx
  float *v11; // eax
  unsigned int v12; // edx
  float *v13; // ecx
  double v14; // st7
  unsigned int v15; // eax
  unsigned int v16; // eax
  double v17; // st7
  double v18; // st6
  float *v19; // eax
  float v20; // eax
  double v21; // st7
  double v22; // st7
  float v23[8]; // [esp+Ch] [ebp-50h] BYREF
  unsigned int v24; // [esp+2Ch] [ebp-30h]
  float v25; // [esp+30h] [ebp-2Ch]
  float v26; // [esp+34h] [ebp-28h]
  float v27; // [esp+38h] [ebp-24h]
  unsigned int i; // [esp+3Ch] [ebp-20h]
  _BYTE *v29; // [esp+40h] [ebp-1Ch]
  float v30; // [esp+44h] [ebp-18h]
  float v31; // [esp+48h] [ebp-14h]
  float v32; // [esp+4Ch] [ebp-10h]
  float v33; // [esp+50h] [ebp-Ch]
  float v34; // [esp+54h] [ebp-8h]
  float v35; // [esp+58h] [ebp-4h]

  v4 = mode;
  if ( mode == 6 )
  {
    v5 = (float *)&grim_dxt5_alpha_weights_min_6;
    v29 = &grim_dxt5_alpha_weights_max_6;
  }
  else
  {
    v5 = (float *)&grim_dxt5_alpha_weights_min_8;
    v29 = &grim_dxt5_alpha_weights_max_8;
  }
  v6 = 0;
  v35 = 1.0;
  v34 = 0.0;
  if ( mode == 8 )
  {
    do
    {
      v7 = &alphas[v6];
      if ( *v7 < (double)v35 )
        v35 = *v7;
      if ( *v7 > (double)v34 )
        v34 = *v7;
      ++v6;
    }
    while ( v6 < 0x10 );
  }
  else
  {
    do
    {
      v8 = &alphas[v6];
      if ( *v8 < (double)v35 && *v8 > 0.0 )
        v35 = *v8;
      if ( *v8 > (double)v34 && *v8 < 1.0 )
        v34 = *v8;
      ++v6;
    }
    while ( v6 < 0x10 );
  }
  v24 = mode - 1;
  v27 = (float)(mode - 1);
  fpu_save_control_word();
  for ( i = 0; i < 8; ++i )
  {
    v9 = v34 - v35;
    if ( v9 < 0.00390625 )
      break;
    v26 = v27 / v9;
    if ( v4 )
    {
      v10 = v29 - (_BYTE *)v5;
      v11 = v5;
      do
      {
        *(float *)((char *)v11 + (char *)v23 - (char *)v5) = v34 * *(float *)((char *)v11 + v10) + v35 * *v11;
        ++v11;
        --v4;
      }
      while ( v4 );
      v4 = mode;
    }
    if ( v4 == 6 )
    {
      v23[6] = 0.0;
      v23[7] = 1.0;
    }
    v12 = 0;
    v33 = 0.0;
    v32 = 0.0;
    v31 = 0.0;
    v30 = 0.0;
    do
    {
      v13 = &alphas[v12];
      v14 = (*v13 - v35) * v26;
      if ( v14 > 0.0 )
      {
        if ( v14 < v27 )
        {
          v25 = v14 + 0.5;
          v24 = (int)v25;
          v15 = v24;
        }
        else
        {
          if ( v4 == 6 && (v34 + 1.0) * 0.5 <= *v13 )
            goto LABEL_38;
          v15 = mode - 1;
        }
      }
      else
      {
        if ( v4 == 6 && v35 * 0.5 >= *v13 )
          goto LABEL_38;
        v15 = 0;
      }
      if ( v15 < v4 )
      {
        v16 = v15;
        v17 = *v13 - v23[v16];
        v33 = v17 * v5[v16] + v33;
        v18 = v5[v16];
        v19 = (float *)&v29[v16 * 4];
        v31 = v18 * v18 + v31;
        v32 = v17 * *v19 + v32;
        v30 = *v19 * *v19 + v30;
      }
LABEL_38:
      ++v12;
    }
    while ( v12 < 0x10 );
    if ( v31 > 0.0 )
      v35 = v35 - v33 / v31;
    if ( v30 > 0.0 )
      v34 = v34 - v32 / v30;
    if ( v35 > (double)v34 )
    {
      v20 = v34;
      v34 = v35;
      v35 = v20;
    }
    if ( v33 * v33 < 0.015625 && v32 * v32 < 0.015625 )
      break;
  }
  if ( v35 >= 0.0 )
  {
    if ( v35 <= 1.0 )
      v21 = v35;
    else
      v21 = 1.0;
  }
  else
  {
    v21 = 0.0;
  }
  *min_out = v21;
  if ( v34 >= 0.0 )
  {
    if ( v34 <= 1.0 )
      v22 = v34;
    else
      v22 = 1.0;
  }
  else
  {
    v22 = 0.0;
  }
  *max_out = v22;
}

// grim_dxt1_optimize_color_endpoints @ 0x10020B2A
// optimizes DXT1 color endpoints for 3- or 4-color mode
void grim_dxt1_optimize_color_endpoints(float *min_out, float *max_out, float *rgba, float mode)
{
  double v4; // st7
  float *v5; // ecx
  int v6; // edx
  double v7; // st6
  double v8; // st5
  unsigned __int8 v10; // c0
  unsigned __int8 v11; // c2
  float *v12; // eax
  float v13; // ecx
  float *v14; // eax
  double v15; // st5
  int v16; // ecx
  double v17; // st6
  double v18; // st5
  double v19; // st5
  double v20; // st3
  double v21; // st3
  double v22; // st4
  char v23; // bl
  unsigned int i; // edx
  float *v25; // ecx
  float v26; // eax
  float v27; // eax
  double v29; // st7
  float *v30; // eax
  float *v31; // ecx
  int v32; // edx
  float v33; // esi
  double v34; // st6
  double v35; // st5
  double v36; // st6
  double v37; // st5
  double v38; // st4
  double v39; // st4
  float *v40; // ecx
  int v41; // esi
  double v42; // st6
  int v43; // edx
  double v44; // st6
  double v45; // st5
  int v46; // eax
  float *v47; // edx
  double v48; // st4
  float *v49; // eax
  double v50; // st4
  double v51; // st3
  double v52; // st6
  double v53; // st6
  float v55[15]; // [esp+4h] [ebp-54h] BYREF
  float *v56; // [esp+40h] [ebp-18h]
  int v57; // [esp+44h] [ebp-14h]
  float v58; // [esp+48h] [ebp-10h]
  float v59; // [esp+4Ch] [ebp-Ch]
  float v60; // [esp+50h] [ebp-8h]
  float *v61; // [esp+58h] [ebp+0h]
  _BYTE *v62; // [esp+5Ch] [ebp+4h]
  float v63; // [esp+60h] [ebp+8h]
  float v64; // [esp+64h] [ebp+Ch]
  float v65; // [esp+68h] [ebp+10h]
  float v66; // [esp+6Ch] [ebp+14h]
  float v67; // [esp+70h] [ebp+18h]
  float v68; // [esp+74h] [ebp+1Ch]
  float v69; // [esp+7Ch] [ebp+24h]
  float v70; // [esp+80h] [ebp+28h]
  float v71; // [esp+84h] [ebp+2Ch]
  float v72; // [esp+88h] [ebp+30h]
  float v73; // [esp+90h] [ebp+38h] BYREF
  float v74; // [esp+94h] [ebp+3Ch]
  float v75; // [esp+98h] [ebp+40h]
  float v76; // [esp+9Ch] [ebp+44h]
  float v77; // [esp+A0h] [ebp+48h]
  float v78; // [esp+A4h] [ebp+4Ch]
  float v79; // [esp+A8h] [ebp+50h]
  float v80; // [esp+B0h] [ebp+58h]
  float v81; // [esp+B4h] [ebp+5Ch]
  float v82; // [esp+B8h] [ebp+60h]
  int v83; // [esp+BCh] [ebp+64h]
  float modea; // [esp+D4h] [ebp+7Ch]

  if ( LODWORD(mode) == 3 )
  {
    v61 = (float *)&grim_dxt1_color_weights_min_3;
    v62 = &grim_dxt1_color_weights_max_3;
  }
  else
  {
    v61 = (float *)&grim_dxt1_color_weights_min_4;
    v62 = &grim_dxt1_color_weights_max_4;
  }
  v77 = 0.0;
  v4 = 0.0;
  v78 = 0.0;
  v80 = flt_100544C0;
  v81 = flt_100544C4;
  v79 = 0.0;
  v82 = flt_100544C8;
  v83 = unk_100544CC;
  v56 = rgba + 2;
  v5 = rgba + 2;
  v6 = 16;
  do
  {
    if ( *(v5 - 2) < (double)v80 )
      v80 = *(v5 - 2);
    if ( *(v5 - 1) < (double)v81 )
      v81 = *(v5 - 1);
    if ( *v5 < (double)v82 )
      v82 = *v5;
    if ( *(v5 - 2) > (double)v77 )
      v77 = *(v5 - 2);
    if ( v4 < *(v5 - 1) )
      v4 = *(v5 - 1);
    if ( *v5 > (double)v79 )
      v79 = *v5;
    v5 += 4;
    --v6;
  }
  while ( v6 );
  v78 = v4;
  v70 = v77 - v80;
  v71 = v4 - v81;
  v7 = v79 - v82;
  v8 = v7 * v7 + v71 * v71 + v70 * v70;
  v69 = v8;
  if ( v10 | v11 )
    goto LABEL_19;
  v14 = rgba + 2;
  v15 = 1.0 / v8;
  v16 = 16;
  v58 = v70 * v15;
  v59 = v71 * v15;
  v60 = v15 * v7;
  v66 = (v77 + v80) * 0.5;
  v67 = (v4 + v81) * 0.5;
  v68 = (v79 + v82) * 0.5;
  v76 = 0.0;
  v75 = 0.0;
  v74 = 0.0;
  v17 = 0.0;
  do
  {
    v70 = (*(v14 - 2) - v66) * v58;
    v71 = (*(v14 - 1) - v67) * v59;
    v18 = *v14;
    v14 += 4;
    --v16;
    v19 = (v18 - v68) * v60;
    v20 = v71 + v19 + v70;
    v17 = v17 + v20 * v20;
    v21 = v71 + v70 - v19;
    v74 = v21 * v21 + v74;
    v22 = v70 - v71;
    v75 = (v22 + v19) * (v22 + v19) + v75;
    v76 = (v22 - v19) * (v22 - v19) + v76;
  }
  while ( v16 );
  v73 = v17;
  v23 = 0;
  for ( i = 1; i < 4; ++i )
  {
    v25 = &v73 + i;
    if ( v17 < *v25 )
    {
      v23 = i;
      v17 = *v25;
    }
  }
  if ( (v23 & 2) != 0 )
  {
    v26 = v81;
    v81 = v4;
    v64 = v26;
    v4 = v26;
    v78 = v26;
  }
  if ( (v23 & 1) != 0 )
  {
    v27 = v79;
    v79 = v82;
    v82 = v27;
  }
  if ( v69 < 0.00024414062 )
  {
LABEL_19:
    *min_out = v80;
    min_out[1] = v81;
    min_out[2] = v82;
    v12 = max_out;
    v13 = v77;
    max_out[1] = v4;
    *max_out = v13;
  }
  else
  {
    v64 = (float)(unsigned int)(LODWORD(mode) - 1);
    fpu_save_control_word();
    v69 = 0.0;
    v29 = 0.000015258789;
    do
    {
      if ( mode != 0.0 )
      {
        v30 = v61;
        v31 = v55;
        v32 = v62 - (_BYTE *)v61;
        v33 = mode;
        do
        {
          *(v31 - 1) = v80 * *v30 + v77 * *(float *)((char *)v30 + v32);
          *v31 = v81 * *v30 + v78 * *(float *)((char *)v30 + v32);
          v34 = v82 * *v30;
          v35 = v79 * *(float *)((char *)v30++ + v32);
          v31[1] = v34 + v35;
          v31 += 4;
          --LODWORD(v33);
        }
        while ( v33 != 0.0 );
      }
      v36 = v77 - v80;
      v71 = v78 - v81;
      v37 = v79 - v82;
      v38 = v37 * v37 + v71 * v71 + v36 * v36;
      if ( v38 < 0.00024414062 )
        break;
      v39 = v64 / v38;
      v40 = v56;
      v41 = 16;
      v70 = v39 * v36;
      v71 = v71 * v39;
      v72 = v39 * v37;
      v75 = 0.0;
      v74 = 0.0;
      v73 = 0.0;
      v68 = 0.0;
      v67 = 0.0;
      v66 = 0.0;
      v65 = 0.0;
      modea = 0.0;
      do
      {
        v42 = (*(v40 - 1) - v81) * v71 + (*(v40 - 2) - v80) * v70 + (*v40 - v82) * v72;
        v63 = v42;
        if ( v42 < v64 )
        {
          v63 = v63 + 0.5;
          v57 = (int)v63;
          v43 = v57;
          v29 = 0.000015258789;
        }
        else
        {
          v43 = LODWORD(mode) - 1;
        }
        v44 = v55[4 * v43 - 1] - *(v40 - 2);
        v59 = v55[4 * v43] - *(v40 - 1);
        v45 = v55[4 * v43 + 1] - *v40;
        v46 = v43;
        v47 = &v61[v46];
        v48 = v61[v46];
        v49 = (float *)&v62[v46 * 4];
        v50 = v48 * 0.125;
        v40 += 4;
        --v41;
        v51 = *v49 * 0.125;
        modea = v50 * *v47 + modea;
        v66 = v50 * v44 + v66;
        v67 = v50 * v59 + v67;
        v68 = v50 * v45 + v68;
        v65 = v51 * *v49 + v65;
        v73 = v51 * v44 + v73;
        v74 = v59 * v51 + v74;
        v75 = v51 * v45 + v75;
      }
      while ( v41 );
      if ( modea > 0.0 )
      {
        v52 = -1.0 / modea;
        v80 = v66 * v52 + v80;
        v81 = v67 * v52 + v81;
        v82 = v52 * v68 + v82;
      }
      if ( v65 > 0.0 )
      {
        v53 = -1.0 / v65;
        v77 = v73 * v53 + v77;
        v78 = v74 * v53 + v78;
        v79 = v53 * v75 + v79;
      }
      if ( v66 * v66 < v29
        && v67 * v67 < v29
        && v68 * v68 < v29
        && v73 * v73 < v29
        && v74 * v74 < v29
        && v75 * v75 < v29 )
      {
        break;
      }
      ++LODWORD(v69);
    }
    while ( LODWORD(v69) < 8 );
    *min_out = v80;
    min_out[1] = v81;
    min_out[2] = v82;
    v12 = max_out;
    *max_out = v77;
    max_out[1] = v78;
  }
  v12[2] = v79;
}

// grim_dxt1_encode_color_block @ 0x10021095
// encodes a 4x4 RGBA block into a DXT1 color block (supports 1-bit alpha mode)
int grim_dxt1_encode_color_block(unsigned __int16 *out_block, float mode)
{
  int v2; // eax
  int v3; // ebx
  int v4; // esi
  float *v5; // ecx
  int v6; // edi
  char v7; // dl
  char *v8; // esi
  char *v9; // edi
  float *v10; // eax
  unsigned int v11; // ecx
  double v12; // st7
  double v13; // st6
  double v14; // st5
  double v15; // st4
  bool v16; // zf
  unsigned int v17; // eax
  unsigned __int16 v18; // si
  unsigned int v19; // eax
  unsigned __int16 v20; // di
  float *p_max_out; // esi
  float *v22; // esi
  double v23; // st7
  double v24; // st6
  double v25; // st4
  double v26; // st5
  double v27; // st4
  double v28; // st7
  double v29; // st6
  double v30; // st5
  unsigned int v31; // edx
  _BYTE *v32; // esi
  char *v33; // edi
  float *v34; // ecx
  double v35; // st7
  int v36; // eax
  int v37; // ebx
  int v38; // eax
  double v39; // st7
  int v40; // ebx
  double v41; // st6
  float v43; // [esp+0h] [ebp-270h]
  float *v44; // [esp+4h] [ebp-26Ch]
  unsigned int v45; // [esp+8h] [ebp-268h]
  float rgba; // [esp+10h] [ebp-260h] BYREF
  _BYTE v48[248]; // [esp+18h] [ebp-258h] BYREF
  float v49[64]; // [esp+110h] [ebp-160h] BYREF
  float v50; // [esp+210h] [ebp-60h]
  float v51; // [esp+214h] [ebp-5Ch]
  float v52; // [esp+218h] [ebp-58h]
  int v53; // [esp+220h] [ebp-50h]
  char *v54; // [esp+224h] [ebp-4Ch]
  char *v55; // [esp+228h] [ebp-48h]
  char *v56; // [esp+22Ch] [ebp-44h]
  char *v57; // [esp+230h] [ebp-40h]
  char *v58; // [esp+234h] [ebp-3Ch]
  char *v59; // [esp+238h] [ebp-38h]
  char *v60; // [esp+23Ch] [ebp-34h]
  char *v61; // [esp+240h] [ebp-30h]
  char *v62; // [esp+244h] [ebp-2Ch]
  float v63; // [esp+248h] [ebp-28h]
  float v64; // [esp+24Ch] [ebp-24h]
  float v65; // [esp+250h] [ebp-20h]
  float v66; // [esp+254h] [ebp-1Ch]
  float v67; // [esp+258h] [ebp-18h]
  float v68; // [esp+25Ch] [ebp-14h]
  float v69; // [esp+260h] [ebp-10h]
  float v70; // [esp+264h] [ebp-Ch]
  float v71; // [esp+268h] [ebp-8h]
  float v72; // [esp+26Ch] [ebp-4h]
  float v73; // [esp+270h] [ebp+0h]
  float v74; // [esp+274h] [ebp+4h]
  float v75; // [esp+278h] [ebp+8h]
  float v76; // [esp+27Ch] [ebp+Ch]
  float v77; // [esp+280h] [ebp+10h]
  float v78; // [esp+284h] [ebp+14h]
  int v79; // [esp+288h] [ebp+18h]
  char *v80; // [esp+28Ch] [ebp+1Ch]
  char *v81; // [esp+290h] [ebp+20h]
  char *v82; // [esp+294h] [ebp+24h]
  float min_out; // [esp+298h] [ebp+28h] BYREF
  float v84; // [esp+29Ch] [ebp+2Ch]
  float v85; // [esp+2A0h] [ebp+30h]
  float v86; // [esp+2A4h] [ebp+34h]
  float v87; // [esp+2A8h] [ebp+38h]
  float v88; // [esp+2ACh] [ebp+3Ch]
  float v89; // [esp+2B0h] [ebp+40h]
  char *v90; // [esp+2B8h] [ebp+48h]
  float v91; // [esp+2BCh] [ebp+4Ch]
  float v92; // [esp+2C0h] [ebp+50h]
  float max_out; // [esp+2C4h] [ebp+54h] BYREF
  float v94; // [esp+2C8h] [ebp+58h]
  float v95; // [esp+2CCh] [ebp+5Ch]
  float v96; // [esp+2D0h] [ebp+60h]
  int v97; // [esp+2D4h] [ebp+64h]
  int v98; // [esp+2D8h] [ebp+68h]
  float v99; // [esp+2DCh] [ebp+6Ch]
  char modea; // [esp+2ECh] [ebp+7Ch]
  float modeb; // [esp+2ECh] [ebp+7Ch]
  unsigned int modec; // [esp+2ECh] [ebp+7Ch]

  v3 = v2;
  if ( mode == 0.0 )
  {
    v97 = 4;
  }
  else
  {
    v4 = 0;
    v5 = (float *)(v2 + 12);
    v6 = 16;
    do
    {
      if ( *v5 < 0.5 )
        ++v4;
      v5 += 4;
      --v6;
    }
    while ( v6 );
    if ( v4 == 16 )
    {
      out_block[1] = -1;
      *((_DWORD *)out_block + 1) = -1;
      *out_block = 0;
      return 0;
    }
    v97 = 4 - (v4 != 0);
  }
  memset(v49, 0, sizeof(v49));
  fpu_save_control_word();
  v80 = (char *)&v49[2] - v3;
  v56 = (char *)&v49[3] - v3;
  v54 = (char *)&v49[4] - v3;
  v79 = (int)&v49[10] - v3;
  v57 = (char *)&v49[11] - v3;
  v59 = (char *)&v49[12] - v3;
  LODWORD(v91) = (char *)&v49[14] - v3;
  v55 = (char *)&v49[15] - v3;
  v61 = (char *)&v49[16] - v3;
  v90 = (char *)&v49[18] - v3;
  v62 = (char *)&v49[19] - v3;
  modea = v7;
  v8 = (char *)v49 - v3;
  v58 = (char *)&v49[20] - v3;
  v9 = (char *)&rgba - v3;
  v10 = (float *)(v3 + 8);
  v60 = (char *)v49 - v3;
  v11 = 0;
  while ( 1 )
  {
    max_out = v49[v11] + *(v10 - 2);
    v94 = *(v10 - 1) + v49[v11 + 1];
    v95 = *(float *)((char *)v10 + (_DWORD)v8) + *v10;
    v99 = max_out * 31.0 + 0.5;
    v53 = (int)v99;
    v92 = (double)v53 * 0.032258064;
    *(float *)((char *)&rgba + v11 * 4) = v92;
    v99 = v94 * 63.0 + 0.5;
    v82 = (char *)(int)v99;
    v99 = (double)(int)v82 * 0.015873017;
    *(float *)&v48[v11 * 4 - 4] = v99;
    *(float *)&v98 = v95 * 31.0 + 0.5;
    v81 = (char *)(int)*(float *)&v98;
    v12 = (double)(int)v81 * 0.032258064;
    v98 = modea & 3;
    *(float *)((char *)v10 + (_DWORD)v9) = v12;
    *(float *)&v48[(_DWORD)v10 - 4 - v3] = 1.0;
    v13 = max_out - v92;
    v14 = v94 - v99;
    v88 = v14;
    v15 = v95 - v12;
    v89 = v15;
    if ( (modea & 3) != 3 )
    {
      *(float *)&v80[(_DWORD)v10] = v13 * 0.4375 + *(float *)&v80[(_DWORD)v10];
      *(float *)&v56[(_DWORD)v10] = v14 * 0.4375 + *(float *)&v56[(_DWORD)v10];
      *(float *)&v54[(_DWORD)v10] = v15 * 0.4375 + *(float *)&v54[(_DWORD)v10];
    }
    if ( v11 < 48 )
    {
      if ( *(float *)&v98 != 0.0 )
      {
        *(float *)((char *)v10 + v79) = v13 * 0.1875 + *(float *)((char *)v10 + v79);
        *(float *)&v57[(_DWORD)v10] = v14 * 0.1875 + *(float *)&v57[(_DWORD)v10];
        *(float *)&v59[(_DWORD)v10] = v15 * 0.1875 + *(float *)&v59[(_DWORD)v10];
      }
      *(float *)((char *)v10 + LODWORD(v91)) = v13 * 0.3125 + *(float *)((char *)v10 + LODWORD(v91));
      *(float *)&v55[(_DWORD)v10] = v14 * 0.3125 + *(float *)&v55[(_DWORD)v10];
      v16 = v98 == 3;
      *(float *)&v61[(_DWORD)v10] = v15 * 0.3125 + *(float *)&v61[(_DWORD)v10];
      if ( !v16 )
      {
        *(float *)&v90[(_DWORD)v10] = v13 * 0.0625 + *(float *)&v90[(_DWORD)v10];
        *(float *)&v62[(_DWORD)v10] = v88 * 0.0625 + *(float *)&v62[(_DWORD)v10];
        *(float *)&v58[(_DWORD)v10] = v89 * 0.0625 + *(float *)&v58[(_DWORD)v10];
      }
    }
    ++modea;
    v11 += 4;
    *(float *)((char *)&v43 + v11 * 4) = v92 * flt_100544C0;
    *(float *)&(&v44)[v11] = v99 * flt_100544C4;
    *(float *)((char *)v10 + (_DWORD)v9) = v12 * flt_100544C8;
    v10 += 4;
    if ( v11 >= 64 )
      break;
    v8 = v60;
  }
  grim_dxt1_optimize_color_endpoints(&min_out, &max_out, &rgba, *(float *)&v97);
  v50 = min_out * flt_100544D0;
  v51 = v84 * flt_100544D4;
  v52 = v85 * flt_100544D8;
  v87 = max_out * flt_100544D0;
  v88 = v94 * flt_100544D4;
  v89 = v95 * flt_100544D8;
  *(float *)&v17 = COERCE_FLOAT(grim_dxt_pack_rgb565(v44));
  v18 = v17;
  v91 = *(float *)&v17;
  v19 = grim_dxt_pack_rgb565(v44);
  v20 = v19;
  v90 = (char *)v19;
  if ( v97 == 4 && v18 == (_WORD)v19 )
  {
    *((_DWORD *)out_block + 1) = 0;
    *out_block = v18;
    out_block[1] = v19;
  }
  else
  {
    grim_dxt_decode_rgb565(v44, v45);
    grim_dxt_decode_rgb565(v44, v45);
    min_out = v50 * flt_100544C0;
    v84 = v51 * flt_100544C4;
    v85 = v52 * flt_100544C8;
    max_out = v87 * flt_100544C0;
    v94 = v88 * flt_100544C4;
    v95 = v89 * flt_100544C8;
    if ( (v97 == 3) == v20 >= v18 )
    {
      *out_block = v18;
      out_block[1] = v20;
      v63 = min_out;
      v64 = v84;
      v65 = v85;
      v66 = v86;
      p_max_out = &max_out;
    }
    else
    {
      out_block[1] = v18;
      *out_block = v20;
      v63 = max_out;
      v64 = v94;
      v65 = v95;
      v66 = v96;
      p_max_out = &min_out;
    }
    v67 = *p_max_out;
    v22 = p_max_out + 1;
    v68 = *v22++;
    v69 = *v22;
    v70 = v22[1];
    v23 = v67 - v63;
    if ( v97 == 3 )
    {
      v92 = COERCE_FLOAT(&grim_dxt1_index_map_3color);
      v71 = 0.5 * v23 + v63;
      v24 = v68 - v64;
      v72 = v24 * 0.5 + v64;
      v25 = v69 - v65;
      modeb = v25;
      v73 = v25 * 0.5 + v65;
      v74 = (v70 - v66) * 0.5 + v66;
    }
    else
    {
      v92 = COERCE_FLOAT(&grim_dxt1_index_map_4color);
      v71 = 0.33333334 * v23 + v63;
      v24 = v68 - v64;
      v72 = 0.33333334 * v24 + v64;
      v26 = v69 - v65;
      modeb = v26;
      v73 = 0.33333334 * v26 + v65;
      v27 = v70 - v66;
      v74 = 0.33333334 * v27 + v66;
      v75 = v23 * 0.66666669 + v63;
      v76 = v24 * 0.66666669 + v64;
      v77 = v26 * 0.66666669 + v65;
      v78 = v27 * 0.66666669 + v66;
    }
    max_out = v23;
    v28 = v24;
    v29 = modeb;
    v99 = (float)(unsigned int)(v97 - 1);
    if ( LOWORD(v91) == (_WORD)v90 )
      v30 = 0.0;
    else
      v30 = v99 / (v29 * v29 + v28 * v28 + max_out * max_out);
    max_out = max_out * v30;
    memset(v49, 0, sizeof(v49));
    v94 = v30 * v28;
    v95 = v30 * v29;
    fpu_save_control_word();
    *(float *)&v98 = COERCE_FLOAT(v49);
    v90 = (char *)&v49[1] - v3;
    v80 = (char *)&v49[5] - v3;
    v81 = (char *)&v49[13] - v3;
    v32 = &v48[-v3];
    v33 = (char *)&v49[17] - v3;
    modec = v31;
    v34 = (float *)(v3 + 4);
    v82 = (char *)&v49[21] - v3;
    do
    {
      if ( v97 == 3 && v34[2] < 0.5 )
      {
        v31 = (v31 >> 2) | 0xC0000000;
      }
      else
      {
        min_out = flt_100544C0 * *(v34 - 1) + *(float *)v98;
        v84 = flt_100544C4 * *v34 + *(float *)&v60[(_DWORD)v34];
        v85 = flt_100544C8 * v34[1] + *(float *)((char *)v34 + (_DWORD)v90);
        v35 = (min_out - v63) * max_out + (v85 - v65) * v95 + (v84 - v64) * v94;
        if ( v35 > 0.0 )
        {
          if ( v35 < v99 )
          {
            v91 = v35 + 0.5;
            v79 = (int)v91;
            v36 = *(_DWORD *)(LODWORD(v92) + 4 * v79);
          }
          else
          {
            v36 = 1;
          }
        }
        else
        {
          v36 = 0;
        }
        v37 = v36;
        v38 = 16 * v36;
        v31 = (v37 << 30) | (v31 >> 2);
        v39 = (min_out - *(float *)((char *)&v63 + v38)) * *(float *)((char *)v34 + (_DWORD)v32);
        v40 = modec & 3;
        v41 = (v84 - *(float *)((char *)&v64 + v38)) * *(float *)((char *)v34 + (_DWORD)v32);
        v88 = v41;
        v89 = (v85 - *(float *)((char *)&v65 + v38)) * *(float *)((char *)v34 + (_DWORD)v32);
        if ( v40 != 3 )
        {
          *(float *)&v56[(_DWORD)v34] = v39 * 0.4375 + *(float *)&v56[(_DWORD)v34];
          *(float *)&v54[(_DWORD)v34] = 0.4375 * v41 + *(float *)&v54[(_DWORD)v34];
          *(float *)&v80[(_DWORD)v34] = v89 * 0.4375 + *(float *)&v80[(_DWORD)v34];
        }
        if ( modec < 0xC )
        {
          if ( (modec & 3) != 0 )
          {
            *(float *)&v57[(_DWORD)v34] = v39 * 0.1875 + *(float *)&v57[(_DWORD)v34];
            *(float *)&v59[(_DWORD)v34] = 0.1875 * v41 + *(float *)&v59[(_DWORD)v34];
            *(float *)&v81[(_DWORD)v34] = v89 * 0.1875 + *(float *)&v81[(_DWORD)v34];
          }
          *(float *)&v55[(_DWORD)v34] = v39 * 0.3125 + *(float *)&v55[(_DWORD)v34];
          *(float *)&v61[(_DWORD)v34] = v41 * 0.3125 + *(float *)&v61[(_DWORD)v34];
          *(float *)((char *)v34 + (_DWORD)v33) = v89 * 0.3125 + *(float *)((char *)v34 + (_DWORD)v33);
          if ( v40 != 3 )
          {
            *(float *)&v62[(_DWORD)v34] = v39 * 0.0625 + *(float *)&v62[(_DWORD)v34];
            *(float *)&v58[(_DWORD)v34] = v88 * 0.0625 + *(float *)&v58[(_DWORD)v34];
            *(float *)&v82[(_DWORD)v34] = v89 * 0.0625 + *(float *)&v82[(_DWORD)v34];
          }
        }
      }
      ++modec;
      v98 += 16;
      v34 += 4;
    }
    while ( modec < 0x10 );
    *((_DWORD *)out_block + 1) = v31;
  }
  return 0;
}

// grim_dxt1_decode_color_block @ 0x10021899
// decodes a DXT1 color block into 16 RGBA floats
int grim_dxt1_decode_color_block(float *out_rgba, unsigned __int16 *block)
{
  unsigned __int16 v3; // si
  int v4; // edi
  double v5; // st7
  double v6; // st5
  double v7; // st5
  double v8; // st5
  unsigned int v9; // ebx
  int v11; // ecx
  float *v12; // esi
  float *v13; // edi
  float *v15; // [esp+0h] [ebp-64h]
  float *v16; // [esp+0h] [ebp-64h]
  unsigned int v17; // [esp+4h] [ebp-60h]
  unsigned int v18; // [esp+4h] [ebp-60h]
  float v19; // [esp+Ch] [ebp-58h] BYREF
  float v20; // [esp+10h] [ebp-54h]
  float v21; // [esp+14h] [ebp-50h]
  float v22; // [esp+18h] [ebp-4Ch]
  float v23; // [esp+1Ch] [ebp-48h]
  float v24; // [esp+20h] [ebp-44h]
  float v25; // [esp+24h] [ebp-40h]
  float v26; // [esp+28h] [ebp-3Ch]
  float v27; // [esp+2Ch] [ebp-38h]
  float v28; // [esp+30h] [ebp-34h]
  float v29; // [esp+34h] [ebp-30h]
  float v30; // [esp+38h] [ebp-2Ch]
  float v31; // [esp+3Ch] [ebp-28h]
  float v32; // [esp+40h] [ebp-24h]
  float v33; // [esp+44h] [ebp-20h]
  float v34; // [esp+48h] [ebp-1Ch]
  float v35; // [esp+4Ch] [ebp-18h]
  float v36; // [esp+50h] [ebp-14h]
  float v37; // [esp+54h] [ebp-10h]
  float v38; // [esp+58h] [ebp-Ch]
  float v39; // [esp+5Ch] [ebp-8h]
  float v40; // [esp+60h] [ebp-4h]
  float blocka; // [esp+70h] [ebp+Ch]

  v3 = *block;
  grim_dxt_decode_rgb565(v15, v17);
  v4 = block[1];
  grim_dxt_decode_rgb565(v16, v18);
  if ( v3 > (unsigned __int16)v4 )
  {
    v5 = v23 - v19;
    v27 = v5 * 0.33333334 + v19;
    v6 = v24 - v20;
    blocka = v6;
    v28 = v6 * 0.33333334 + v20;
    v7 = v25 - v21;
    v40 = v7;
    v29 = v7 * 0.33333334 + v21;
    v8 = v26 - v22;
    v39 = v8;
    v30 = v8 * 0.33333334 + v22;
    v31 = v5 * 0.66666669 + v19;
    v32 = blocka * 0.66666669 + v20;
    v33 = v40 * 0.66666669 + v21;
    v34 = v39 * 0.66666669 + v22;
  }
  else
  {
    v27 = (v23 - v19) * 0.5 + v19;
    v28 = (v24 - v20) * 0.5 + v20;
    v29 = (v25 - v21) * 0.5 + v21;
    v30 = (v26 - v22) * 0.5 + v22;
    v35 = 0.0;
    v36 = 0.0;
    v37 = 0.0;
    v38 = 0.0;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v34 = 0.0;
  }
  v9 = *((_DWORD *)block + 1);
  v11 = 16;
  do
  {
    v12 = &v19 + 4 * (v9 & 3);
    *out_rgba = *v12++;
    out_rgba[1] = *v12++;
    out_rgba[2] = *v12;
    v13 = out_rgba + 3;
    out_rgba += 4;
    v9 >>= 2;
    --v11;
    *v13 = v12[1];
  }
  while ( v11 );
  return 0;
}

// grim_dxt3_decode_block @ 0x100219D7
// decodes a DXT3 block (explicit alpha + DXT1 color) to RGBA floats
int grim_dxt3_decode_block(float *out_rgba, unsigned int *block)
{
  int result; // eax
  unsigned int v3; // ecx
  int v4; // edx
  float *v5; // eax
  double v6; // st6
  unsigned int v7; // esi
  int v8; // ecx
  float *v9; // eax
  double v10; // st6

  result = grim_dxt1_decode_color_block(out_rgba, (unsigned __int16 *)block + 4);
  if ( result >= 0 )
  {
    v3 = *block;
    v4 = 8;
    v5 = out_rgba + 3;
    do
    {
      v6 = (double)(v3 & 0xF);
      v3 >>= 4;
      *v5 = v6 * 0.06666667;
      v5 += 4;
      --v4;
    }
    while ( v4 );
    v7 = block[1];
    v8 = 8;
    v9 = out_rgba + 35;
    do
    {
      v10 = (double)(v7 & 0xF);
      v7 >>= 4;
      *v9 = v10 * 0.06666667;
      v9 += 4;
      --v8;
    }
    while ( v8 );
    return 0;
  }
  return result;
}

// grim_dxt5_decode_block @ 0x10021A5A
// decodes a DXT5 block (interpolated alpha + DXT1 color) to RGBA floats
int grim_dxt5_decode_block(float *out_rgba, unsigned __int8 *block)
{
  int result; // eax
  unsigned __int8 v3; // al
  unsigned __int8 v4; // cl
  unsigned int j; // eax
  double v6; // st7
  double v7; // st6
  unsigned int i; // eax
  double v9; // st7
  double v10; // st6
  int v11; // edx
  unsigned int v12; // ecx
  float *v13; // eax
  int v14; // ebx
  int v15; // edx
  unsigned int v16; // ecx
  float *v17; // eax
  int v18; // esi
  float v19; // [esp+8h] [ebp-20h]
  float v20; // [esp+Ch] [ebp-1Ch]
  float v21; // [esp+20h] [ebp-8h]
  float v22; // [esp+24h] [ebp-4h]

  result = grim_dxt1_decode_color_block(out_rgba, (unsigned __int16 *)block + 4);
  if ( result >= 0 )
  {
    v3 = *block;
    v4 = block[1];
    v19 = (double)*block * 0.0039215689;
    v20 = (double)v4 * 0.0039215689;
    if ( v3 <= v4 )
    {
      for ( i = 1; i < 5; *(&v19 + i) = (v9 + v10) * 0.2 )
      {
        v9 = (double)(5 - i) * v19;
        v10 = (double)i++ * v20;
      }
      v21 = 0.0;
      v22 = 1.0;
    }
    else
    {
      for ( j = 1; j < 7; *(&v19 + j) = (v6 + v7) * 0.14285715 )
      {
        v6 = (double)(7 - j) * v19;
        v7 = (double)j++ * v20;
      }
    }
    v11 = 8;
    v12 = block[2] | (*(unsigned __int16 *)(block + 3) << 8);
    v13 = out_rgba + 3;
    do
    {
      v14 = v12 & 7;
      v12 >>= 3;
      *v13 = *(&v19 + v14);
      v13 += 4;
      --v11;
    }
    while ( v11 );
    v15 = 8;
    v16 = block[5] | (*((unsigned __int16 *)block + 3) << 8);
    v17 = out_rgba + 35;
    do
    {
      v18 = v16 & 7;
      v16 >>= 3;
      *v17 = *(&v19 + v18);
      v17 += 4;
      --v15;
    }
    while ( v15 );
    return 0;
  }
  return result;
}

// sub_10021B96 @ 0x10021B96
int __cdecl sub_10021B96(int a1, float *a2)
{
  int result; // eax

  result = grim_dxt1_encode_color_block(a2, a1, 1);
  if ( result >= 0 )
    return 0;
  return result;
}

// grim_dxt3_encode_block @ 0x10021BAE
// encodes a 4x4 RGBA block into DXT3 (explicit alpha + DXT1 color)
void grim_dxt3_encode_block(unsigned int *out_block, float *rgba)
{
  unsigned int v3; // edx
  double v4; // st7
  unsigned int *v5; // edx
  int v6; // eax
  double v7; // st7
  int v8; // edx
  double v9; // st7
  float v10[16]; // [esp+Ch] [ebp-50h] BYREF
  float v11; // [esp+4Ch] [ebp-10h]
  float v12; // [esp+50h] [ebp-Ch]
  float v13; // [esp+54h] [ebp-8h]
  float *v14; // [esp+58h] [ebp-4h]
  unsigned int out_blocka; // [esp+64h] [ebp+8h]

  *out_block = 0;
  out_block[1] = 0;
  memset(v10, 0, sizeof(v10));
  fpu_save_control_word();
  out_blocka = v3;
  v14 = rgba + 3;
  do
  {
    v4 = v10[out_blocka] + *v14;
    v13 = v4;
    v12 = v4 * 15.0 + 0.5;
    LODWORD(v11) = (int)v12;
    v5 = &out_block[out_blocka >> 3];
    v6 = (LODWORD(v11) << 28) | (*v5 >> 4);
    v12 = v11;
    v7 = (double)LODWORD(v11);
    *v5 = v6;
    v8 = out_blocka & 3;
    v9 = v13 - v7 * 0.06666667;
    if ( v8 != 3 )
      v10[out_blocka + 1] = 0.4375 * v9 + v10[out_blocka + 1];
    if ( out_blocka < 0xC )
    {
      if ( (out_blocka & 3) != 0 )
        v10[out_blocka + 3] = 0.1875 * v9 + v10[out_blocka + 3];
      v10[out_blocka + 4] = 0.3125 * v9 + v10[out_blocka + 4];
      if ( v8 != 3 )
        v10[out_blocka + 5] = v9 * 0.0625 + v10[out_blocka + 5];
    }
    ++out_blocka;
    v14 += 4;
  }
  while ( out_blocka < 0x10 );
  grim_dxt1_encode_color_block((unsigned __int16 *)out_block + 4, 0.0);
}

// grim_dxt5_encode_block @ 0x10021CC2
// encodes a 4x4 RGBA block into DXT5 (interpolated alpha + DXT1 color)
int grim_dxt5_encode_block(unsigned __int8 *out_block, float *rgba)
{
  float *v2; // ebx
  unsigned int v3; // edx
  float *v4; // edi
  double v5; // st7
  double v6; // st7
  unsigned __int8 v8; // c0
  unsigned __int8 v9; // c2
  double v10; // st7
  int v11; // esi
  unsigned __int8 *v12; // esi
  int result; // eax
  unsigned int v14; // edi
  unsigned __int8 v15; // cl
  double v16; // st7
  double v17; // st6
  unsigned int j; // eax
  double v19; // st7
  double v20; // st6
  unsigned int i; // eax
  double v22; // st7
  double v23; // st6
  double v24; // st7
  unsigned int v25; // eax
  unsigned __int8 *v26; // ecx
  unsigned int v27; // edx
  unsigned int v28; // ebx
  double v29; // st7
  double v30; // st7
  int v31; // eax
  double v32; // st7
  int v33; // edi
  int v34; // [esp-4h] [ebp-40h]
  float v35[16]; // [esp+Ch] [ebp-30h] BYREF
  float alphas[8]; // [esp+4Ch] [ebp+10h] BYREF
  float v37; // [esp+6Ch] [ebp+30h]
  float v38; // [esp+70h] [ebp+34h]
  float v39; // [esp+84h] [ebp+48h]
  float v40; // [esp+88h] [ebp+4Ch]
  int v41; // [esp+8Ch] [ebp+50h]
  float v42; // [esp+90h] [ebp+54h]
  float v43; // [esp+94h] [ebp+58h]
  float v44; // [esp+98h] [ebp+5Ch]
  _DWORD *v45; // [esp+9Ch] [ebp+60h]
  float v46; // [esp+A0h] [ebp+64h]
  float v47; // [esp+A4h] [ebp+68h]
  int min_out; // [esp+A8h] [ebp+6Ch] BYREF

  v2 = rgba + 3;
  v47 = rgba[3];
  v46 = v47;
  memset(v35, 0, sizeof(v35));
  fpu_save_control_word();
  v3 = 0;
  v4 = v2;
  do
  {
    v5 = v35[v3] + *v4;
    v44 = v5;
    *(float *)&min_out = v5 * 255.0 + 0.5;
    v45 = (_DWORD *)(int)*(float *)&min_out;
    min_out = (int)v45;
    v6 = (double)(int)v45 * 0.0039215689;
    alphas[v3] = v6;
    if ( v8 | v9 )
    {
      v47 = v6;
    }
    else if ( v6 > v46 )
    {
      v46 = v6;
    }
    v10 = v44 - v6;
    v11 = v3 & 3;
    if ( v11 != 3 )
      v35[v3 + 1] = 0.4375 * v10 + v35[v3 + 1];
    if ( v3 < 0xC )
    {
      if ( (v3 & 3) != 0 )
        v35[v3 + 3] = 0.1875 * v10 + v35[v3 + 3];
      v35[v3 + 4] = 0.3125 * v10 + v35[v3 + 4];
      if ( v11 != 3 )
        v35[v3 + 5] = v10 * 0.0625 + v35[v3 + 5];
    }
    ++v3;
    v4 += 4;
  }
  while ( v3 < 0x10 );
  min_out = fpu_control_word_saved_dxt;
  v12 = out_block;
  result = grim_dxt1_encode_color_block((unsigned __int16 *)out_block + 4, 0.0);
  if ( result < 0 )
    return result;
  if ( 1.0 == v47 )
  {
    *v12 = -1;
    v12[1] = -1;
LABEL_24:
    *(_DWORD *)(v12 + 2) = 0;
    *((_WORD *)v12 + 3) = 0;
    return 0;
  }
  if ( 0.0 == v47 || 1.0 == v46 )
  {
    rgba = (float *)6;
    v14 = 6;
  }
  else
  {
    v14 = 8;
    rgba = (float *)8;
  }
  grim_dxt5_optimize_alpha_endpoints((float *)&min_out, (float *)&out_block, alphas, v14);
  fpu_save_control_word();
  *(float *)&min_out = *(float *)&min_out * 255.0 + 0.5;
  v45 = (_DWORD *)(int)*(float *)&min_out;
  *(float *)&out_block = *(float *)&out_block * 255.0 + 0.5;
  min_out = (int)*(float *)&out_block;
  v15 = min_out;
  v16 = (double)(unsigned __int8)v45 * 0.0039215689;
  v17 = (double)(unsigned __int8)min_out * 0.0039215689;
  *(float *)&out_block = v17;
  if ( v14 == 8 )
  {
    if ( (_BYTE)v45 == (_BYTE)min_out )
    {
      *v12 = (unsigned __int8)v45;
      v12[1] = v15;
      goto LABEL_24;
    }
    v12[1] = (unsigned __int8)v45;
    v37 = v17;
    v38 = v16;
    *v12 = v15;
    for ( i = 1; i < 7; *(&v37 + i) = (v22 + v23) * 0.14285715 )
    {
      v22 = (double)(7 - i) * v37;
      out_block = (unsigned __int8 *)i;
      v23 = (double)i++ * v38;
    }
    v45 = &grim_dxt5_alpha_index_map_8;
  }
  else
  {
    *v12 = (unsigned __int8)v45;
    v37 = v16;
    v38 = *(float *)&out_block;
    v12[1] = v15;
    for ( j = 1; j < 5; *(&v37 + j) = (v19 + v20) * 0.2 )
    {
      v19 = (double)(5 - j) * v37;
      out_block = (unsigned __int8 *)j;
      v20 = (double)j++ * v38;
    }
    v45 = &grim_dxt5_alpha_index_map_6;
    v39 = 0.0;
    v40 = 1.0;
  }
  out_block = (unsigned __int8 *)(v14 - 1);
  v43 = (float)(v14 - 1);
  if ( v37 == v38 )
    v24 = 0.0;
  else
    v24 = v43 / (v38 - v37);
  v44 = v24;
  memset(v35, 0, sizeof(v35));
  fpu_save_control_word();
  v25 = 0;
  v26 = v12 + 3;
  v47 = *(float *)&v2;
  do
  {
    v27 = 0;
    *(float *)&out_block = 0.0;
    min_out = v25 + 8;
    v28 = v25;
    if ( v25 >= v25 + 8 )
      goto LABEL_58;
    v46 = v47;
    do
    {
      v29 = v35[v28] + *(float *)LODWORD(v46);
      *(float *)&out_block = v29;
      v30 = (v29 - v37) * v44;
      if ( v30 <= 0.0 )
      {
        if ( rgba != (float *)6 || v37 * 0.5 < *(float *)&out_block )
        {
          v31 = 0;
          goto LABEL_49;
        }
        v34 = 6;
        goto LABEL_46;
      }
      if ( v30 < v43 )
      {
        v42 = v30 + 0.5;
        v41 = (int)v42;
        v31 = v45[v41];
      }
      else
      {
        if ( rgba == (float *)6 && (v38 + 1.0) * 0.5 <= *(float *)&out_block )
        {
          v34 = 7;
LABEL_46:
          v31 = v34;
          goto LABEL_49;
        }
        v31 = 1;
      }
LABEL_49:
      v32 = *(float *)&out_block - *(&v37 + v31);
      v27 = (v31 << 21) | (v27 >> 3);
      v33 = v28 & 3;
      if ( v33 != 3 )
        v35[v28 + 1] = 0.4375 * v32 + v35[v28 + 1];
      if ( v28 < 0xC )
      {
        if ( (v28 & 3) != 0 )
          v35[v28 + 3] = 0.1875 * v32 + v35[v28 + 3];
        v35[v28 + 4] = 0.3125 * v32 + v35[v28 + 4];
        if ( v33 != 3 )
          v35[v28 + 5] = v32 * 0.0625 + v35[v28 + 5];
      }
      LODWORD(v46) += 16;
      ++v28;
    }
    while ( v28 < min_out );
    out_block = (unsigned __int8 *)v27;
LABEL_58:
    LODWORD(v47) += 128;
    v26[1] = BYTE2(out_block);
    v25 = min_out;
    *(_WORD *)(v26 - 1) = v27;
    v26 += 3;
  }
  while ( v25 < 0x10 );
  rgba = (float *)fpu_control_word_saved_dxt;
  return 0;
}

// grim_dxt2_decode_block @ 0x10022114
int __cdecl grim_dxt2_decode_block(float *a1, unsigned __int16 *a2)
{
  int result; // eax

  result = grim_dxt3_decode_block(a1, a2);
  if ( result >= 0 )
  {
    result = grim_dxt_unpremultiply_rgba_block(a1);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt4_decode_block @ 0x10022137
int __cdecl grim_dxt4_decode_block(float *a1, unsigned __int16 *a2)
{
  int result; // eax

  result = grim_dxt5_decode_block(a1, a2);
  if ( result >= 0 )
  {
    result = grim_dxt_unpremultiply_rgba_block(a1);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt2_encode_block @ 0x1002215A
// premultiplies RGBA and encodes a DXT3-style block (DXT2)
int grim_dxt2_encode_block(void *out_block)
{
  int result; // eax
  float rgba[64]; // [esp+0h] [ebp-100h] BYREF

  result = grim_dxt_premultiply_rgba_block((float *)LODWORD(rgba[0]));
  if ( result >= 0 )
  {
    grim_dxt3_encode_block((unsigned int *)out_block, rgba);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt4_encode_block @ 0x1002218E
// premultiplies RGBA and encodes a DXT5-style block (DXT4)
int grim_dxt4_encode_block(void *out_block)
{
  int result; // eax
  float rgba[64]; // [esp+0h] [ebp-100h] BYREF

  result = grim_dxt_premultiply_rgba_block((float *)LODWORD(rgba[0]));
  if ( result >= 0 )
  {
    result = grim_dxt5_encode_block((unsigned __int8 *)out_block, rgba);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// sub_100221D0 @ 0x100221D0
__m128 *(__stdcall **__cdecl sub_100221D0(
        __m128 *(__stdcall **a1)(__m128 *, unsigned int *, __m128 *)))(__m128 *, unsigned int *, __m128 *)
{
  a1[28] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026970;
  *a1 = sub_10025C00;
  a1[13] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100266F0;
  a1[27] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100267E0;
  a1[11] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100278B0;
  a1[48] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100265D0;
  a1[47] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100261F0;
  a1[17] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026490;
  a1[54] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026580;
  a1[53] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026280;
  a1[52] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100263F0;
  a1[51] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026520;
  a1[50] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026130;
  a1[49] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026330;
  a1[18] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100272D0;
  a1[22] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026630;
  a1[25] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026D10;
  a1[24] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026BF0;
  a1[19] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026A50;
  a1[44] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026B80;
  a1[20] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026AE0;
  a1[16] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025FE0;
  a1[21] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025F00;
  a1[8] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026090;
  a1[7] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025E30;
  a1[10] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026F60;
  a1[9] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025C40;
  a1[6] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026DE0;
  a1[5] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CA0;
  a1[4] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027590;
  a1[3] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CE0;
  a1[2] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027060;
  a1[1] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026EA0;
  return a1;
}

// sub_100222E0 @ 0x100222E0
__m128 *(__stdcall **__cdecl sub_100222E0(
        __m128 *(__stdcall **a1)(__m128 *, unsigned int *, __m128 *)))(__m128 *, unsigned int *, __m128 *)
{
  a1[28] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027C00;
  *a1 = sub_10025C00;
  a1[13] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027980;
  a1[27] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027A70;
  a1[11] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100278B0;
  a1[48] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100265D0;
  a1[47] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100261F0;
  a1[17] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026490;
  a1[54] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026580;
  a1[53] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026280;
  a1[52] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100263F0;
  a1[51] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026520;
  a1[50] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026130;
  a1[49] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026330;
  a1[18] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100272D0;
  a1[22] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026630;
  a1[25] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027E00;
  a1[24] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027CE0;
  a1[31] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027820;
  a1[30] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100277A0;
  a1[19] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026A50;
  a1[20] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026AE0;
  a1[16] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100276F0;
  a1[21] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100271F0;
  a1[8] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026090;
  a1[7] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027120;
  a1[10] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026F60;
  a1[9] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025C40;
  a1[6] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026DE0;
  a1[5] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CA0;
  a1[4] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027590;
  a1[3] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CE0;
  a1[2] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027060;
  a1[1] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026EA0;
  return a1;
}

// sub_100223F0 @ 0x100223F0
int sub_100223F0()
{
  char v26[16]; // [esp+Ch] [ebp-28h] BYREF
  _DWORD v27[5]; // [esp+1Ch] [ebp-18h] BYREF
  int v28; // [esp+30h] [ebp-4h]

  strcpy((char *)v27, "UnknownVendr");
  strcpy(v26, "AuthenticAMD");
  _EAX = 0;
  __asm { cpuid }
  v28 = 1;
  _EAX = 0;
  __asm { cpuid }
  v27[0] = _EBX;
  v27[1] = _EDX;
  v27[2] = _ECX;
  if ( _EAX )
  {
    _EAX = 1;
    __asm { cpuid }
    v27[4] = _EAX;
    v28 |= ((_EDX & 0x800000) != 0 ? 0x20 : 0) | 2;
    _EAX = 0x80000000;
    __asm { cpuid }
    if ( _EAX > 0x80000000 )
    {
      v28 |= 4u;
      _EAX = -2147483647;
      __asm { cpuid }
      v28 |= _EDX < 0 ? 0x80 : 0;
      if ( !memcmp(v26, v27, 0xCu) )
      {
        v28 |= (_EDX & 0x40000000) != 0 ? 0x100 : 0;
        return ((_EDX & 0x400000) != 0 ? 0x200 : 0) | v28;
      }
    }
  }
  return v28;
}

// grim_init_mmx_sse_functions @ 0x100224C5
// fills a function pointer table with MMX/SSE implementations based on CPUID
void grim_init_mmx_sse_functions(unsigned int *table)
{
  __int16 v1; // ax

  v1 = sub_100223F0();
  if ( (v1 & 0x20) != 0 && (v1 & 0x80u) != 0 )
  {
    *table = (unsigned int)sub_1002DCA8;
    table[1] = (unsigned int)sub_1002D1EA;
    table[2] = (unsigned int)sub_1002DF69;
    table[3] = (unsigned int)sub_1002943A;
    table[5] = (unsigned int)sub_1002DCFD;
    table[6] = (unsigned int)sub_1002D25B;
    table[7] = (unsigned int)sub_1002D2C2;
    table[8] = (unsigned int)sub_1002DFEB;
    table[9] = (unsigned int)sub_1002DD36;
    table[10] = (unsigned int)sub_1002D7A2;
    table[11] = (unsigned int)sub_1002966C;
    table[12] = (unsigned int)sub_1002E393;
    table[13] = (unsigned int)sub_1002E3D6;
    table[14] = (unsigned int)sub_1002D7A7;
    table[15] = (unsigned int)sub_1002D92F;
    table[16] = (unsigned int)sub_1002E04A;
    table[17] = (unsigned int)sub_1002DD9A;
    table[18] = (unsigned int)sub_1002D1CE;
    table[19] = (unsigned int)sub_10027ED0;
    table[20] = (unsigned int)sub_10027F69;
    table[21] = (unsigned int)sub_1002E578;
    table[22] = (unsigned int)sub_1002E4BA;
    table[23] = (unsigned int)sub_10027FC6;
    table[24] = (unsigned int)sub_10028079;
    table[25] = (unsigned int)sub_100284AA;
    table[26] = (unsigned int)sub_1002973B;
    table[27] = (unsigned int)sub_1002978B;
    table[28] = (unsigned int)sub_10029876;
    table[29] = (unsigned int)sub_1002856F;
    table[30] = (unsigned int)sub_10029952;
    table[31] = (unsigned int)sub_100299B5;
    table[32] = (unsigned int)sub_10029A13;
    table[33] = (unsigned int)sub_10029A6C;
    table[34] = (unsigned int)sub_1002E5DC;
    table[35] = (unsigned int)sub_100285DB;
    table[36] = (unsigned int)sub_10028712;
    table[37] = (unsigned int)sub_10029AB3;
    table[38] = (unsigned int)sub_10029B5B;
    table[39] = (unsigned int)sub_10029CE2;
    table[40] = (unsigned int)sub_1002AE7A;
    table[41] = (unsigned int)sub_1002B01F;
    table[42] = (unsigned int)sub_1002B553;
    table[43] = (unsigned int)sub_1002879F;
    table[44] = (unsigned int)sub_10028831;
    table[54] = (unsigned int)sub_1002E17C;
    table[51] = (unsigned int)sub_1002D321;
    table[48] = (unsigned int)sub_1002DE32;
    table[46] = (unsigned int)sub_1002DE7B;
    table[52] = (unsigned int)sub_1002E1ED;
    table[49] = (unsigned int)sub_1002D392;
    table[55] = (unsigned int)sub_10028895;
    table[56] = (unsigned int)sub_1002893C;
    table[53] = (unsigned int)sub_1002E2B5;
    table[47] = (unsigned int)sub_1002DEBE;
    table[50] = (unsigned int)sub_1002D466;
    table[4] = (unsigned int)sub_1002CAA2;
    table[45] = (unsigned int)sub_100289E1;
    if ( (v1 & 0x100) != 0 && (v1 & 0x200) != 0 )
    {
      table[15] = (unsigned int)sub_1002DB55;
      table[18] = (unsigned int)sub_1002C7C0;
      table[38] = (unsigned int)sub_10029C2D;
      table[39] = (unsigned int)sub_1002B66C;
      table[24] = (unsigned int)sub_10028295;
    }
  }
}

// sub_100226EB @ 0x100226EB
float *__stdcall sub_100226EB(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_10022754 @ 0x10022754
float *__stdcall sub_10022754(float *a1, float *a2, float *a3)
{
  double v3; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5];
  *a1 = *a2 * *a3 + a2[1] * a3[4];
  a1[1] = v3;
  return a1;
}

// sub_10022789 @ 0x10022789
float *__stdcall sub_10022789(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_10022814 @ 0x10022814
float *__stdcall sub_10022814(float *a1, float *a2, float *a3)
{
  double v3; // st6
  double v4; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8];
  a1[1] = v3;
  a1[2] = v4;
  return a1;
}

// sub_10022873 @ 0x10022873
float *__stdcall sub_10022873(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a2[3] * a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a2[3] * a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a2[3] * a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a2[3] * a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// FUN_1002290c @ 0x1002290C
// [binja] float* __stdcall sub_1002290c(float* arg1, float* arg2)
float *FUN_1002290c(float *arg1, float *arg2)
{
  float v8; // [esp+4h] [ebp-8h]
  float v9; // [esp+8h] [ebp-4h]
  int v10; // [esp+8h] [ebp-4h]
  unsigned int v11; // [esp+8h] [ebp-4h]

  _EDX = arg2;
  __asm
  {
    fld     dword ptr [edx]
    fmul    dword ptr [edx]
    fld     dword ptr [edx+4]
    fmul    dword ptr [edx+4]
    fld     dword ptr [edx+8]
    fmul    dword ptr [edx+8]
    fxch    st(2)
    faddp   st(1), st
    faddp   st(1), st
    fst     [ebp+var_8]
  }
  if ( v8 == 0.0 )
  {
    __asm { ffree   st }
    *(_DWORD *)arg1 = LOBYTE(v8);
    *((_DWORD *)arg1 + 1) = LOBYTE(v8);
    *((_DWORD *)arg1 + 2) = LOBYTE(v8);
  }
  else
  {
    __asm
    {
      fld1
      fsubp   st(1), st
      fstp    [ebp+var_4]
    }
    if ( (LODWORD(v9) & 0x7FFFFFFFu) > 0x3727C5AC )
    {
      _EDI = (LODWORD(v8) >> 12) & 0xFF8;
      v10 = LODWORD(v8) & 0xFFFFFF | 0x3F000000;
      __asm
      {
        fld     [ebp+var_4]
        fmul    flt_100544E0[edi]
      }
      __asm { fadd    flt_100544E4[edi] }
      v11 = ((unsigned int)(-1090519041 - LODWORD(v8)) >> 1) & 0xFF800000;
      __asm
      {
        fmul    [ebp+var_4]
        fld     dword ptr [edx]
        fmul    st, st(1)
        fld     dword ptr [edx+4]
        fmul    st, st(2)
        fld     dword ptr [edx+8]
        fmul    st, st(3)
        fxch    st(2)
        fstp    dword ptr [ecx]
      }
      *arg1 = _ET1;
      __asm { fstp    dword ptr [ecx+4] }
      arg1[1] = _ET1;
      __asm { fstp    dword ptr [ecx+8] }
      arg1[2] = _ET1;
      __asm { fstp    st }
    }
    else if ( arg1 != arg2 )
    {
      *arg1 = *arg2;
      arg1[1] = arg2[1];
      arg1[2] = arg2[2];
    }
  }
  return arg1;
}

// FUN_100229d6 @ 0x100229D6
// [binja] int32_t __stdcall sub_100229d6(int32_t arg1, int32_t arg2, void* arg3)
int FUN_100229d6(int arg1, int arg2, void *arg3)
{
  int result; // eax
  int v4; // ebx
  int v10; // ebx
  int v13; // edi
  _BYTE v16[64]; // [esp+Ch] [ebp-40h] BYREF

  result = arg1;
  if ( arg3 == (void *)arg1 )
  {
    if ( arg2 != arg1 )
    {
      v4 = arg1;
      _ECX = arg2;
      _EDX = arg3;
      _EDI = -4;
      do
      {
        _ESI = -16;
        __asm
        {
          fld     dword ptr [edx+edi*4+10h]
          fld     dword ptr [edx+edi*4+20h]
          fld     dword ptr [edx+edi*4+30h]
          fld     dword ptr [edx+edi*4+40h]
        }
        do
        {
          __asm
          {
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+40h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+44h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+48h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+4Ch]
            fxch    st(3)
            faddp   st(1), st
            fxch    st(2)
            faddp   st(1), st
            faddp   st(1), st
            fstp    dword ptr [ebx+esi*4+40h]
          }
          *(float *)(v4 + 4 * _ESI + 64) = _ET1;
          _ESI += 4;
        }
        while ( _ESI );
        __asm
        {
          ffree   st(3)
          ffree   st(2)
          ffree   st(1)
          ffree   st
        }
        v4 += 4;
        ++_EDI;
      }
      while ( _EDI );
      return result;
    }
    qmemcpy(v16, arg3, sizeof(v16));
    arg3 = v16;
  }
  v10 = arg1;
  _ECX = arg2;
  _EDX = arg3;
  v13 = -4;
  do
  {
    _ESI = -4;
    __asm
    {
      fld     dword ptr [ecx]
      fld     dword ptr [ecx+4]
      fld     dword ptr [ecx+8]
      fld     dword ptr [ecx+0Ch]
    }
    do
    {
      __asm
      {
        fld     st(3)
        fmul    dword ptr [edx+esi*4+10h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+20h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+30h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+40h]
        fxch    st(3)
        faddp   st(1), st
        fxch    st(2)
        faddp   st(1), st
        faddp   st(1), st
        fstp    dword ptr [ebx+esi*4+10h]
      }
      *(float *)(v10 + 4 * _ESI++ + 16) = _ET1;
    }
    while ( _ESI );
    __asm
    {
      ffree   st(3)
      ffree   st(2)
      ffree   st(1)
      ffree   st
    }
    _ECX += 16;
    v10 += 16;
    ++v13;
  }
  while ( v13 );
  return result;
}

// FUN_10022ab9 @ 0x10022AB9
// [binja] void* __stdcall sub_10022ab9(void* arg1, int32_t arg2, int32_t arg3)
void *FUN_10022ab9(void *arg1, int arg2, int arg3)
{
  char *v3; // eax
  int v6; // edi
  float *v8; // ebx
  void *result; // eax
  char v11; // [esp+0h] [ebp-44h] BYREF
  char *v12; // [esp+40h] [ebp-4h]

  v3 = (char *)arg1;
  if ( arg1 == (void *)arg2 || arg1 == (void *)arg3 )
    v3 = &v11;
  v12 = v3;
  _ECX = arg2;
  _EDX = arg3;
  v6 = -4;
  do
  {
    _ESI = -4;
    v8 = (float *)&v3[4 * v6 + 16];
    __asm
    {
      fld     dword ptr [ecx]
      fld     dword ptr [ecx+4]
      fld     dword ptr [ecx+8]
      fld     dword ptr [ecx+0Ch]
    }
    do
    {
      __asm
      {
        fld     st(3)
        fmul    dword ptr [edx+esi*4+10h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+20h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+30h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+40h]
        fxch    st(3)
        faddp   st(1), st
        fxch    st(2)
        faddp   st(1), st
        faddp   st(1), st
        fstp    dword ptr [ebx]
      }
      *v8 = _ET1;
      v8 += 4;
      ++_ESI;
    }
    while ( _ESI );
    __asm
    {
      ffree   st(3)
      ffree   st(2)
      ffree   st(1)
      ffree   st
    }
    _ECX += 16;
    ++v6;
  }
  while ( v6 );
  result = arg1;
  if ( v12 != arg1 )
    qmemcpy(arg1, v12, 0x40u);
  return result;
}

// sub_10022B47 @ 0x10022B47
float *(__stdcall **__cdecl sub_10022B47(
        float *(__stdcall **a1)(float *a1, float *a2, float *a3)))(float *a1, float *a2, float *a3)
{
  *a1 = sub_100226EB;
  a1[1] = sub_10022789;
  a1[2] = sub_10022873;
  a1[3] = (float *(__stdcall *)(float *, float *, float *))FUN_100229d6;
  a1[4] = (float *(__stdcall *)(float *, float *, float *))FUN_10022ab9;
  a1[5] = sub_10022754;
  a1[6] = sub_10022814;
  a1[7] = (float *(__stdcall *)(float *, float *, float *))FUN_1002290c;
  return a1;
}

// sub_10022B83 @ 0x10022B83
int __cdecl sub_10022B83(int a1, int a2)
{
  return (a1 + a2 - 1) / a2;
}

// sub_10022B93 @ 0x10022B93
int __cdecl sub_10022B93(int a1, int a2)
{
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

// sub_10022BAB @ 0x10022BAB
const void **__cdecl sub_10022BAB(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  const void **result; // eax
  void **v7; // edx
  int v8; // [esp+Ch] [ebp+Ch]

  result = (const void **)(a1 + 4 * a2);
  v7 = (void **)(a3 + 4 * a4);
  if ( a5 > 0 )
  {
    v8 = a5;
    do
    {
      qmemcpy(*v7++, *result++, a6);
      --v8;
    }
    while ( v8 );
  }
  return result;
}

// sub_10022BF2 @ 0x10022BF2
int __cdecl sub_10022BF2(const void *a1, void *a2, int a3)
{
  qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
  return a3 << 7;
}

// memzero @ 0x10022C14
// zero-fill helper (memset to 0)
void memzero(void *dst, unsigned int size)
{
  memset(dst, 0, size);
}

// FUN_10022c2f @ 0x10022C2F
// [binja] int32_t __fastcall sub_10022c2f(int32_t arg1)
int FUN_10022c2f(int arg1)
{
  unsigned int v1; // kr00_4
  unsigned int v2; // kr04_4
  int v3; // edx

  v1 = __readeflags();
  __writeeflags(v1 ^ 0x200000);
  v2 = __readeflags();
  v3 = v1 ^ v2;
  if ( v1 != v2 )
  {
    _EAX = 1;
    __asm { cpuid }
    return (_EDX & 0x800000u) >> 23;
  }
  return v3;
}

// sub_10022C61 @ 0x10022C61
int __usercall sub_10022C61@<eax>(int a1@<esi>)
{
  int v1; // ebx
  bool v2; // cc
  int v3; // edi
  int *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // edi
  int v11; // eax
  int result; // eax

  if ( *(int *)(a1 + 28) > 65500 || *(int *)(a1 + 24) > 65500 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 40;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 65500;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_DWORD *)(a1 + 192) != 8 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 13;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 192);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(int *)(a1 + 32) > 10 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = 0;
  v2 = *(_DWORD *)(a1 + 32) <= 0;
  v3 = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a1 + 268) = 1;
  *(_DWORD *)(a1 + 272) = 1;
  if ( !v2 )
  {
    v4 = (int *)(v3 + 12);
    do
    {
      v5 = *(v4 - 1);
      if ( v5 <= 0 || v5 > 4 || *v4 <= 0 || *v4 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 16;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v6 = *(_DWORD *)(a1 + 268);
      if ( v6 <= *(v4 - 1) )
        v6 = *(v4 - 1);
      *(_DWORD *)(a1 + 268) = v6;
      v7 = *(_DWORD *)(a1 + 272);
      if ( v7 <= *v4 )
        v7 = *v4;
      ++v1;
      *(_DWORD *)(a1 + 272) = v7;
      v4 += 21;
    }
    while ( v1 < *(_DWORD *)(a1 + 32) );
  }
  v8 = *(_DWORD *)(a1 + 196);
  v9 = 0;
  v2 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 276) = 8;
  if ( !v2 )
  {
    v10 = v8 + 28;
    do
    {
      *(_DWORD *)(v10 + 8) = 8;
      *(_DWORD *)v10 = sub_10022B83(*(_DWORD *)(a1 + 24) * *(_DWORD *)(v10 - 20), 8 * *(_DWORD *)(a1 + 268));
      *(_DWORD *)(v10 + 4) = sub_10022B83(*(_DWORD *)(a1 + 28) * *(_DWORD *)(v10 - 16), 8 * *(_DWORD *)(a1 + 272));
      *(_DWORD *)(v10 + 12) = sub_10022B83(*(_DWORD *)(a1 + 24) * *(_DWORD *)(v10 - 20), *(_DWORD *)(a1 + 268));
      v11 = sub_10022B83(*(_DWORD *)(a1 + 28) * *(_DWORD *)(v10 - 16), *(_DWORD *)(a1 + 272));
      *(_DWORD *)(v10 + 48) = 0;
      *(_DWORD *)(v10 + 16) = v11;
      *(_BYTE *)(v10 + 20) = 1;
      ++v9;
      v10 += 84;
    }
    while ( v9 < *(_DWORD *)(a1 + 32) );
  }
  *(_DWORD *)(a1 + 280) = sub_10022B83(*(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
  if ( *(_DWORD *)(a1 + 288) < *(_DWORD *)(a1 + 32) || *(_BYTE *)(a1 + 200) )
  {
    result = *(_DWORD *)(a1 + 396);
    *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 396);
    *(_BYTE *)(result + 16) = 0;
  }
  return result;
}

// sub_10022E1C @ 0x10022E1C
int __usercall sub_10022E1C@<eax>(int *a1@<esi>)
{
  int v1; // eax
  _DWORD *v2; // ecx
  unsigned int v3; // ebx
  int result; // eax
  int v5; // edx
  bool v6; // cc
  _DWORD *v7; // ecx
  unsigned int v8; // ebx
  int v9; // edi
  int v10; // edx
  int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // ebx
  int v14; // edx
  int *v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+Ch] [ebp-4h]

  v1 = a1[72];
  if ( v1 == 1 )
  {
    v2 = (_DWORD *)a1[73];
    a1[77] = v2[7];
    a1[78] = v2[8];
    v3 = v2[3];
    v2[16] = v2[9];
    result = v2[8] / v3;
    v5 = v2[8] % v3;
    v2[13] = 1;
    v2[14] = 1;
    v2[15] = 1;
    v2[17] = 1;
    if ( !v5 )
      v5 = v3;
    v2[18] = v5;
    a1[80] = 0;
    a1[79] = 1;
  }
  else
  {
    if ( v1 <= 0 || v1 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 24;
      *(_DWORD *)(*a1 + 24) = a1[72];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    a1[77] = sub_10022B83(a1[6], 8 * a1[67]);
    result = sub_10022B83(a1[7], 8 * a1[68]);
    v6 = a1[72] <= 0;
    a1[78] = result;
    a1[79] = 0;
    v16 = 0;
    if ( !v6 )
    {
      v15 = a1 + 73;
      do
      {
        v7 = (_DWORD *)*v15;
        v8 = *(_DWORD *)(*v15 + 8);
        v9 = *(_DWORD *)(*v15 + 12);
        v7[16] = v8 * *(_DWORD *)(*v15 + 36);
        v10 = v7[7] % v8;
        v7[14] = v9;
        v11 = v8 * v9;
        v7[13] = v8;
        v7[15] = v11;
        if ( !v10 )
          v10 = v8;
        v12 = v7[8];
        v13 = v7[3];
        v7[17] = v10;
        v14 = v12 % v13;
        if ( !(v12 % v13) )
          v14 = v13;
        v7[18] = v14;
        if ( v11 + a1[79] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 11;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        if ( v11 > 0 )
        {
          do
          {
            a1[a1[79]++ + 80] = v16;
            --v11;
          }
          while ( v11 );
        }
        result = ++v16;
        ++v15;
      }
      while ( v16 < a1[72] );
    }
  }
  return result;
}

// sub_10022F92 @ 0x10022F92
void __usercall sub_10022F92(int a1@<ebx>)
{
  unsigned int v1; // esi
  void *v2; // eax
  int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  int *v5; // [esp+8h] [ebp-4h]

  v4 = 0;
  if ( *(int *)(a1 + 288) > 0 )
  {
    v5 = (int *)(a1 + 292);
    do
    {
      v3 = *v5;
      if ( !*(_DWORD *)(*v5 + 76) )
      {
        v1 = *(_DWORD *)(*v5 + 16);
        if ( v1 >= 4 || !*(_DWORD *)(a1 + 4 * v1 + 144) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v1;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v2 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
        qmemcpy(v2, *(const void **)(a1 + 4 * v1 + 144), 0x82u);
        *(_DWORD *)(v3 + 76) = v2;
      }
      ++v4;
      ++v5;
    }
    while ( v4 < *(_DWORD *)(a1 + 288) );
  }
}

// sub_10023024 @ 0x10023024
int __cdecl sub_10023024(int a1)
{
  int result; // eax

  sub_10022E1C((int *)a1);
  sub_10022F92(a1);
  (**(void (__cdecl ***)(int))(a1 + 404))(a1);
  (**(void (__cdecl ***)(int))(a1 + 388))(a1);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
  **(_DWORD **)(a1 + 396) = result;
  return result;
}

// sub_1002305E @ 0x1002305E
int __cdecl sub_1002305E(_DWORD *a1)
{
  _BYTE *v1; // edi
  int v3; // ebp
  bool v4; // zf
  int v5; // esi

  v1 = (_BYTE *)a1[99];
  if ( v1[17] )
    return 2;
  v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 4))(a1);
  if ( v3 == 1 )
  {
    if ( v1[20] )
    {
      sub_10022C61((int)a1);
      v1[20] = 0;
    }
    else
    {
      if ( !v1[16] )
      {
        *(_DWORD *)(*a1 + 20) = 34;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_10023024((int)a1);
    }
  }
  else if ( v3 == 2 )
  {
    v4 = v1[20] == 0;
    v1[17] = 1;
    if ( v4 )
    {
      v5 = a1[31];
      if ( a1[33] > v5 )
        a1[33] = v5;
    }
    else if ( *(_BYTE *)(a1[100] + 81) )
    {
      *(_DWORD *)(*a1 + 20) = 58;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  return v3;
}

// sub_100230F1 @ 0x100230F1
int __cdecl sub_100230F1(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 396);
  *(_BYTE *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 17) = 0;
  *(_DWORD *)v1 = sub_1002305E;
  *(_BYTE *)(v1 + 20) = 1;
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
  result = (**(int (__cdecl ***)(int))(a1 + 400))(a1);
  *(_DWORD *)(a1 + 140) = 0;
  return result;
}

// sub_10023128 @ 0x10023128
_DWORD *__cdecl sub_10023128(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 396);
  *result = sub_1002305E;
  return result;
}

// sub_10023139 @ 0x10023139
int __cdecl sub_10023139(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 396) = result;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_DWORD *)result = sub_1002305E;
  *(_DWORD *)(result + 4) = sub_100230F1;
  *(_DWORD *)(result + 8) = sub_10023024;
  *(_DWORD *)(result + 12) = sub_10023128;
  *(_BYTE *)(result + 20) = 1;
  return result;
}

// sub_1002317A @ 0x1002317A
int __usercall sub_1002317A@<eax>(int a1@<eax>, int a2@<edx>)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 53;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a2;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// FUN_1002318f @ 0x1002318F
// [binja] void* sub_1002318f(int32_t* arg1, int32_t* arg2, int32_t* arg3)
void *FUN_1002318f(int *arg1, int *arg2, int *arg3)
{
  int *v3; // ebx
  int *v5; // eax
  int *v6; // edi
  unsigned int v7; // esi
  int *v8; // ecx
  int v9; // ecx
  int v11; // [esp+Ch] [ebp-4h]
  int *arg2a; // [esp+1Ch] [ebp+Ch]
  int *arg3a; // [esp+20h] [ebp+10h]

  v3 = arg3;
  v11 = arg1[1];
  if ( (unsigned int)arg3 > 0x3B9AC9F0 )
    sub_1002317A((int)arg1, 1);
  if ( ((unsigned __int8)arg3 & 7) != 0 )
    v3 = (int *)((char *)arg3 + 8 - ((unsigned __int8)arg3 & 7));
  if ( (unsigned int)arg2 >= 2 )
  {
    *(_DWORD *)(*arg1 + 20) = 12;
    *(_DWORD *)(*arg1 + 24) = arg2;
    (*(void (__cdecl **)(int *))*arg1)(arg1);
  }
  arg3a = 0;
  arg2a = (int *)(v11 + 4 * (_DWORD)arg2 + 48);
  v5 = (int *)*arg2a;
  if ( !*arg2a )
    goto LABEL_11;
  do
  {
    if ( v5[2] >= (unsigned int)v3 )
      break;
    arg3a = v5;
    v5 = (int *)*v5;
  }
  while ( v5 );
  if ( !v5 )
  {
LABEL_11:
    v6 = v3 + 4;
    if ( arg3a )
      v7 = dword_1004EA08[(_DWORD)arg2];
    else
      v7 = dword_1004EA00[(_DWORD)arg2];
    if ( v7 > 1000000000 - (int)v6 )
      v7 = 1000000000 - (_DWORD)v6;
    while ( 1 )
    {
      v5 = (int *)FUN_1002e65a((uint)arg1);
      if ( v5 )
        break;
      v7 >>= 1;
      if ( v7 < 0x32 )
        sub_1002317A((int)arg1, 2);
    }
    *(_DWORD *)(v11 + 72) += (char *)v6 + v7;
    v8 = arg3a;
    *v5 = 0;
    v5[1] = 0;
    v5[2] = (int)v3 + v7;
    if ( !arg3a )
      v8 = arg2a;
    *v8 = (int)v5;
  }
  v9 = v5[1];
  v5[2] -= (int)v3;
  v5[1] = (int)v3 + v9;
  return (char *)v5 + v9 + 16;
}

// FUN_1002328b @ 0x1002328B
// [binja] void* sub_1002328b(uint32_t arg1, int32_t arg2, int32_t arg3)
void *FUN_1002328b(uint arg1, int arg2, int arg3)
{
  int v3; // ebx
  int v4; // edi
  _DWORD *v5; // esi
  int *v6; // eax
  int v7; // ecx

  v3 = *(_DWORD *)(arg1 + 4);
  v4 = arg3;
  if ( (unsigned int)arg3 > 0x3B9AC9F0 )
    sub_1002317A(arg1, 3);
  if ( (arg3 & 7) != 0 )
    v4 = 8 - (arg3 & 7) + arg3;
  if ( (unsigned int)arg2 >= 2 )
  {
    *(_DWORD *)(*(_DWORD *)arg1 + 20) = 12;
    *(_DWORD *)(*(_DWORD *)arg1 + 24) = arg2;
    (**(void (__cdecl ***)(uint))arg1)(arg1);
  }
  v5 = (_DWORD *)FUN_1002e65a(arg1);
  if ( !v5 )
    sub_1002317A(arg1, 4);
  *(_DWORD *)(v3 + 72) += v4 + 16;
  v6 = (int *)(v3 + 4 * arg2 + 56);
  v7 = *v6;
  v5[2] = 0;
  v5[1] = v4;
  *v5 = v7;
  *v6 = (int)v5;
  return v5 + 4;
}

// sub_10023319 @ 0x10023319
int __cdecl sub_10023319(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v4; // edi
  unsigned int v5; // esi
  unsigned int v7; // edi
  _DWORD *v8; // eax
  unsigned int v9; // ecx
  int v11; // [esp+20h] [ebp+14h]

  v4 = a1[1];
  v5 = 0x3B9AC9F0 / a3;
  if ( (int)(0x3B9AC9F0 / a3) <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)v5 >= (int)a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  v7 = 0;
  v11 = FUN_1002318f(a1, a2, 4 * a4);
  while ( v7 < a4 )
  {
    if ( v5 >= a4 - v7 )
      v5 = a4 - v7;
    v8 = FUN_1002328b(a1, a2, a3 * v5);
    if ( v5 )
    {
      v9 = v5;
      do
      {
        *(_DWORD *)(v11 + 4 * v7) = v8;
        v8 = (_DWORD *)((char *)v8 + a3);
        ++v7;
        --v9;
      }
      while ( v9 );
    }
  }
  return v11;
}

// sub_100233AB @ 0x100233AB
int __cdecl sub_100233AB(_DWORD *a1, unsigned int a2, int a3, signed int a4)
{
  int v4; // edi
  signed int v5; // esi
  unsigned int v7; // edi
  _DWORD *v8; // eax
  signed int v9; // ecx
  int v11; // [esp+24h] [ebp+14h]

  v4 = a1[1];
  v5 = 0x3B9AC9F0u / (a3 << 7);
  if ( v5 <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( v5 >= a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  v7 = 0;
  v11 = FUN_1002318f(a1, a2, 4 * a4);
  while ( v7 < a4 )
  {
    if ( v5 >= a4 - v7 )
      v5 = a4 - v7;
    v8 = FUN_1002328b(a1, a2, (a3 * v5) << 7);
    if ( v5 )
    {
      v9 = v5;
      do
      {
        *(_DWORD *)(v11 + 4 * v7) = v8;
        v8 += 32 * a3;
        ++v7;
        --v9;
      }
      while ( v9 );
    }
  }
  return v11;
}

// FUN_10023449 @ 0x10023449
// [binja] void* sub_10023449(int32_t* arg1, int32_t* arg2, char arg3, int32_t arg4, int32_t arg5, int32_t arg6)
void *FUN_10023449(int *arg1, int *arg2, char arg3, int arg4, int arg5, int arg6)
{
  int v6; // esi
  void *result; // eax

  v6 = arg1[1];
  if ( arg2 != (int *)1 )
  {
    *(_DWORD *)(*arg1 + 20) = 12;
    *(_DWORD *)(*arg1 + 24) = arg2;
    (*(void (__cdecl **)(int *))*arg1)(arg1);
  }
  result = FUN_1002318f(arg1, arg2, (int *)0x78);
  *(_DWORD *)result = 0;
  *((_DWORD *)result + 1) = arg5;
  *((_DWORD *)result + 2) = arg4;
  *((_DWORD *)result + 3) = arg6;
  *((_BYTE *)result + 34) = 0;
  *((_BYTE *)result + 32) = arg3;
  *((_DWORD *)result + 9) = *(_DWORD *)(v6 + 64);
  *(_DWORD *)(v6 + 64) = result;
  return result;
}

// FUN_100234aa @ 0x100234AA
// [binja] void* sub_100234aa(int32_t* arg1, int32_t* arg2, char arg3, int32_t arg4, int32_t arg5, int32_t arg6)
void *FUN_100234aa(int *arg1, int *arg2, char arg3, int arg4, int arg5, int arg6)
{
  int v6; // esi
  void *result; // eax

  v6 = arg1[1];
  if ( arg2 != (int *)1 )
  {
    *(_DWORD *)(*arg1 + 20) = 12;
    *(_DWORD *)(*arg1 + 24) = arg2;
    (*(void (__cdecl **)(int *))*arg1)(arg1);
  }
  result = FUN_1002318f(arg1, arg2, (int *)0x78);
  *(_DWORD *)result = 0;
  *((_DWORD *)result + 1) = arg5;
  *((_DWORD *)result + 2) = arg4;
  *((_DWORD *)result + 3) = arg6;
  *((_BYTE *)result + 34) = 0;
  *((_BYTE *)result + 32) = arg3;
  *((_DWORD *)result + 9) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(v6 + 68) = result;
  return result;
}

// sub_1002350B @ 0x1002350B
int __cdecl sub_1002350B(_DWORD *a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax
  int v3; // esi
  int v4; // ebx
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  int i; // esi
  int v9; // ebx
  unsigned int v10; // ecx
  int j; // esi
  int v12; // ebx
  unsigned int v13; // ecx
  signed int v14; // [esp+Ch] [ebp-4h]

  v1 = (_DWORD *)a1[1];
  v2 = (_DWORD *)v1[16];
  v3 = 0;
  v4 = 0;
  while ( v2 )
  {
    if ( !*v2 )
    {
      v5 = v2[2];
      v3 += v5 * v2[3];
      v4 += v5 * v2[1];
    }
    v2 = (_DWORD *)v2[9];
  }
  for ( result = v1[17]; result; result = *(_DWORD *)(result + 36) )
  {
    if ( !*(_DWORD *)result )
    {
      v7 = *(_DWORD *)(result + 8);
      v3 += (v7 * *(_DWORD *)(result + 12)) << 7;
      v4 += (v7 * *(_DWORD *)(result + 4)) << 7;
    }
  }
  if ( v3 > 0 )
  {
    result = FUN_1002e670(a1, v3, v4);
    if ( result < v4 )
    {
      result /= v3;
      v14 = result;
      if ( result <= 0 )
        v14 = 1;
    }
    else
    {
      v14 = 1000000000;
    }
    for ( i = v1[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( !*(_DWORD *)i )
      {
        v9 = *(_DWORD *)(i + 4);
        v10 = *(_DWORD *)(i + 12);
        if ( (int)((v9 - 1) / v10 + 1) > v14 )
        {
          *(_DWORD *)(i + 16) = v14 * v10;
          sub_1002E675(a1);
          *(_BYTE *)(i + 34) = 1;
        }
        else
        {
          *(_DWORD *)(i + 16) = v9;
        }
        *(_DWORD *)i = sub_10023319(a1, 1u, *(_DWORD *)(i + 8), *(_DWORD *)(i + 16));
        result = v1[19];
        *(_DWORD *)(i + 24) = 0;
        *(_DWORD *)(i + 28) = 0;
        *(_BYTE *)(i + 33) = 0;
        *(_DWORD *)(i + 20) = result;
      }
    }
    for ( j = v1[17]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( !*(_DWORD *)j )
      {
        v12 = *(_DWORD *)(j + 4);
        v13 = *(_DWORD *)(j + 12);
        if ( (int)((v12 - 1) / v13 + 1) > v14 )
        {
          *(_DWORD *)(j + 16) = v14 * v13;
          sub_1002E675(a1);
          *(_BYTE *)(j + 34) = 1;
        }
        else
        {
          *(_DWORD *)(j + 16) = v12;
        }
        *(_DWORD *)j = sub_100233AB(a1, 1u, *(_DWORD *)(j + 8), *(_DWORD *)(j + 16));
        result = v1[19];
        *(_DWORD *)(j + 24) = 0;
        *(_DWORD *)(j + 28) = 0;
        *(_BYTE *)(j + 33) = 0;
        *(_DWORD *)(j + 20) = result;
      }
    }
  }
  return result;
}

// sub_1002368A @ 0x1002368A
int __usercall sub_1002368A@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebx
  int result; // eax
  int i; // edi
  int v6; // ecx
  int v7; // [esp-4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 8);
  result = *(_DWORD *)(a1 + 16);
  for ( i = 0; i < result; v3 += v9 )
  {
    result -= i;
    if ( *(_DWORD *)(a1 + 20) < result )
      result = *(_DWORD *)(a1 + 20);
    v6 = i + *(_DWORD *)(a1 + 24);
    if ( result >= *(_DWORD *)(a1 + 28) - v6 )
      result = *(_DWORD *)(a1 + 28) - v6;
    if ( result >= *(_DWORD *)(a1 + 4) - v6 )
      result = *(_DWORD *)(a1 + 4) - v6;
    if ( result <= 0 )
      break;
    v7 = v8 * result;
    v9 = v8 * result;
    if ( a3 )
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 44))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    else
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 40))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    i += *(_DWORD *)(a1 + 20);
    result = *(_DWORD *)(a1 + 16);
  }
  return result;
}

// sub_10023712 @ 0x10023712
int __usercall sub_10023712@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebx
  int result; // eax
  int i; // edi
  int v6; // ecx
  int v7; // [esp-4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (*(_DWORD *)(a1 + 8) << 7) * *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 8) << 7;
  result = *(_DWORD *)(a1 + 16);
  for ( i = 0; i < result; v3 += v9 )
  {
    result -= i;
    if ( *(_DWORD *)(a1 + 20) < result )
      result = *(_DWORD *)(a1 + 20);
    v6 = i + *(_DWORD *)(a1 + 24);
    if ( result >= *(_DWORD *)(a1 + 28) - v6 )
      result = *(_DWORD *)(a1 + 28) - v6;
    if ( result >= *(_DWORD *)(a1 + 4) - v6 )
      result = *(_DWORD *)(a1 + 4) - v6;
    if ( result <= 0 )
      break;
    v7 = v8 * result;
    v9 = v8 * result;
    if ( a3 )
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 44))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    else
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 40))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    i += *(_DWORD *)(a1 + 20);
    result = *(_DWORD *)(a1 + 16);
  }
  return result;
}

// sub_1002379D @ 0x1002379D
int __cdecl sub_1002379D(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebx
  int v6; // edi
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // ebx
  unsigned int v15; // [esp+20h] [ebp+14h]

  v5 = a3 + a4;
  if ( a3 + a4 <= *(_DWORD *)(a2 + 4) && a4 <= *(_DWORD *)(a2 + 12) && *(_DWORD *)a2 )
  {
    v6 = a1;
  }
  else
  {
    v6 = a1;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v7 = *(_DWORD *)(a2 + 24);
  if ( a3 < v7 || v5 > v7 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)v6 + 20) = 68;
      (**(void (__cdecl ***)(int))v6)(v6);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_1002368A(a2, v6, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    v8 = a3;
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v8 = v5 - *(_DWORD *)(a2 + 16);
      if ( v8 < 0 )
        v8 = 0;
    }
    *(_DWORD *)(a2 + 24) = v8;
    sub_1002368A(a2, v6, 0);
  }
  v9 = *(_DWORD *)(a2 + 28);
  if ( v9 < v5 )
  {
    if ( v9 >= a3 )
    {
      v10 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      if ( a5 )
      {
        *(_DWORD *)(*(_DWORD *)v6 + 20) = 20;
        (**(void (__cdecl ***)(int))v6)(v6);
      }
      v10 = a3;
    }
    if ( a5 )
      *(_DWORD *)(a2 + 28) = v5;
    if ( *(_BYTE *)(a2 + 32) )
    {
      v15 = *(_DWORD *)(a2 + 8);
      v11 = *(_DWORD *)(a2 + 24);
      v12 = v10 - v11;
      v13 = v5 - v11;
      while ( v12 < v13 )
        memzero(*(void **)(*(_DWORD *)a2 + 4 * v12++), v15);
    }
    else
    {
      if ( a5 )
      {
LABEL_32:
        *(_BYTE *)(a2 + 33) = 1;
        return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
  }
  if ( a5 )
    goto LABEL_32;
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// sub_100238BB @ 0x100238BB
int __cdecl sub_100238BB(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // ebx
  int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // ebx
  unsigned int v14; // [esp+20h] [ebp+14h]
  unsigned int v15; // [esp+20h] [ebp+14h]

  v6 = a3 + a4;
  v14 = a3 + a4;
  if ( v14 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v7 = *(_DWORD *)(a2 + 24);
  if ( a3 < v7 || v6 > v7 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_10023712(a2, a1, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v8 = v6 - *(_DWORD *)(a2 + 16);
      if ( v8 < 0 )
        v8 = 0;
      *(_DWORD *)(a2 + 24) = v8;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    sub_10023712(a2, a1, 0);
  }
  v9 = *(_DWORD *)(a2 + 28);
  if ( v9 < v6 )
  {
    if ( v9 < a3 )
    {
      if ( a5 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v9 = a3;
    }
    if ( a5 )
      *(_DWORD *)(a2 + 28) = v6;
    if ( *(_BYTE *)(a2 + 32) )
    {
      v10 = *(_DWORD *)(a2 + 24);
      v11 = *(_DWORD *)(a2 + 8) << 7;
      v12 = v9 - v10;
      v15 = v14 - v10;
      while ( v12 < v15 )
        memzero(*(void **)(*(_DWORD *)a2 + 4 * v12++), v11);
    }
    else
    {
      if ( a5 )
      {
LABEL_32:
        *(_BYTE *)(a2 + 33) = 1;
        return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
  }
  if ( a5 )
    goto LABEL_32;
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// sub_100239DE @ 0x100239DE
_DWORD *__cdecl sub_100239DE(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  _DWORD *v3; // esi
  int i; // edi
  int j; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  int v8; // edi
  _DWORD **v9; // ecx
  _DWORD *result; // eax
  _DWORD *v11; // ebx
  int v12; // edi

  v2 = a2;
  v3 = (_DWORD *)a1[1];
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 == 1 )
  {
    for ( i = v3[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( *(_BYTE *)(i + 34) )
      {
        *(_BYTE *)(i + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
      }
    }
    v3[16] = 0;
    for ( j = v3[17]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( *(_BYTE *)(j + 34) )
      {
        *(_BYTE *)(j + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(j + 48))(a1, j + 40);
      }
    }
    v3[17] = 0;
  }
  v6 = (_DWORD *)v3[a2 + 14];
  v3[a2 + 14] = 0;
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      v8 = v6[2] + v6[1] + 16;
      zcfree((int)a1, v6);
      v3[18] -= v8;
      v6 = v7;
    }
    while ( v7 );
    v2 = a2;
  }
  v9 = (_DWORD **)&v3[v2 + 12];
  result = *v9;
  *v9 = 0;
  if ( result )
  {
    do
    {
      v11 = (_DWORD *)*result;
      v12 = result[2] + result[1] + 16;
      zcfree((int)a1, result);
      v3[18] -= v12;
      result = v11;
    }
    while ( v11 );
  }
  return result;
}

// sub_10023ABF @ 0x10023ABF
void __cdecl sub_10023ABF(int a1)
{
  signed int i; // edi

  for ( i = 1; i >= 0; --i )
    sub_100239DE((_DWORD *)a1, i);
  zcfree(a1, *(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  nullsub_3();
}

// sub_10023AEF @ 0x10023AEF
_DWORD *__cdecl sub_10023AEF(_DWORD *a1)
{
  int v1; // edi
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  int v4; // edx

  a1[1] = 0;
  v1 = sub_1002E689(a1);
  result = (_DWORD *)FUN_1002e65a((int)a1, 0x50u);
  if ( result )
  {
    *result = FUN_1002318f;
    result[1] = FUN_1002328b;
    result[2] = sub_10023319;
    result[3] = sub_100233AB;
    result[4] = FUN_10023449;
    result[5] = FUN_100234aa;
    result[6] = sub_1002350B;
    result[7] = sub_1002379D;
    result[8] = sub_100238BB;
    result[9] = sub_100239DE;
    result[10] = sub_10023ABF;
    result[11] = v1;
    v3 = result + 15;
    v4 = 2;
    do
    {
      *(v3 - 2) = 0;
      *v3-- = 0;
      --v4;
    }
    while ( v4 );
    result[16] = 0;
    result[17] = 0;
    result[18] = 80;
    a1[1] = result;
  }
  else
  {
    nullsub_3();
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 0;
    return (_DWORD *)(*(int (__cdecl **)(_DWORD *, _DWORD *))*a1)(a1, a1);
  }
  return result;
}

// sub_10023BA3 @ 0x10023BA3
int __cdecl sub_10023BA3(int a1)
{
  int result; // eax

  (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 4) + 36))(a1, 1);
  result = *(_BYTE *)(a1 + 12) != 0 ? 200 : 100;
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

// sub_10023BC5 @ 0x10023BC5
int __cdecl sub_10023BC5(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = (*(int (__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

// sub_10023BE0 @ 0x10023BE0
int __cdecl sub_10023BE0(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

// sub_10023BFC @ 0x10023BFC
int __cdecl sub_10023BFC(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

// FUN_10023c18 @ 0x10023C18
// [binja] int32_t __fastcall sub_10023c18(int32_t arg1, void* arg2)
int FUN_10023c18(int arg1, void *arg2)
{
  int v2; // edx
  _DWORD *v3; // ecx
  int result; // eax
  int v5; // edx

  if ( *(_BYTE *)(v2 + 72)
    || *(_BYTE *)(v2 + 264)
    || *(_DWORD *)(v2 + 36) != 3
    || *(_DWORD *)(v2 + 32) != 3
    || *(_DWORD *)(v2 + 40) != 2
    || *(_DWORD *)(v2 + 100) != 3
    || (v3 = *(_DWORD **)(v2 + 196), v3[2] != 2)
    || (result = 1, v3[23] != 1)
    || v3[44] != 1
    || (int)v3[3] > 2
    || v3[24] != 1
    || v3[45] != 1
    || (v5 = *(_DWORD *)(v2 + 276), v3[9] != v5)
    || v3[30] != v5
    || v3[51] != v5 )
  {
    LOBYTE(result) = 0;
  }
  return result;
}

// sub_10023C89 @ 0x10023C89
int __cdecl sub_10023C89(int a1)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v8; // cc
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // ebx
  _DWORD *v12; // edi
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int result; // eax
  int v17; // [esp-18h] [ebp-20h]
  int v18; // [esp-18h] [ebp-20h]
  int v19; // [esp-18h] [ebp-20h]
  int v20; // [esp+0h] [ebp-8h]
  char *v21; // [esp+4h] [ebp-4h]
  int i; // [esp+10h] [ebp+8h]

  if ( *(_DWORD *)(a1 + 16) != 202 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 48);
  if ( 8 * v2 > v3 )
  {
    if ( 4 * v2 > v3 )
    {
      if ( 2 * v2 > v3 )
      {
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 24);
        v5 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 276) = 8;
      }
      else
      {
        v7 = sub_10022B83(*(_DWORD *)(a1 + 24), 2);
        v19 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = v7;
        v5 = sub_10022B83(v19, 2);
        *(_DWORD *)(a1 + 276) = 4;
      }
    }
    else
    {
      v6 = sub_10022B83(*(_DWORD *)(a1 + 24), 4);
      v18 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 92) = v6;
      v5 = sub_10022B83(v18, 4);
      *(_DWORD *)(a1 + 276) = 2;
    }
  }
  else
  {
    v4 = sub_10022B83(*(_DWORD *)(a1 + 24), 8);
    v17 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 92) = v4;
    v5 = sub_10022B83(v17, 8);
    *(_DWORD *)(a1 + 276) = 1;
  }
  v21 = 0;
  v8 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 96) = v5;
  if ( !v8 )
  {
    v9 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 12);
    do
    {
      v10 = *(_DWORD *)(a1 + 276);
      for ( i = v10; i < 8; i *= 2 )
      {
        if ( 2 * i * *(v9 - 1) > v10 * *(_DWORD *)(a1 + 268) )
          break;
        if ( 2 * i * *v9 > v10 * *(_DWORD *)(a1 + 272) )
          break;
      }
      ++v21;
      v9[6] = i;
      v9 += 21;
    }
    while ( (int)v21 < *(_DWORD *)(a1 + 32) );
  }
  v11 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v12 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    do
    {
      v12[1] = sub_10022B83(*(_DWORD *)(a1 + 24) * *v12 * *(v12 - 7), 8 * *(_DWORD *)(a1 + 268));
      v12[2] = sub_10022B83(*v12 * *(_DWORD *)(a1 + 28) * *(v12 - 6), 8 * *(_DWORD *)(a1 + 272));
      ++v11;
      v12 += 21;
    }
    while ( v11 < *(_DWORD *)(a1 + 32) );
  }
  v13 = *(_DWORD *)(a1 + 40);
  v14 = 1;
  if ( v13 != 1 )
  {
    if ( v13 <= 1 )
    {
LABEL_25:
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      goto LABEL_27;
    }
    v14 = 3;
    if ( v13 > 3 )
    {
      if ( v13 <= 5 )
      {
        *(_DWORD *)(a1 + 100) = 4;
        goto LABEL_27;
      }
      goto LABEL_25;
    }
  }
  *(_DWORD *)(a1 + 100) = v14;
LABEL_27:
  if ( *(_BYTE *)(a1 + 74) )
    v15 = 1;
  else
    v15 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 104) = v15;
  result = FUN_10023c18(v20, v21);
  if ( (_BYTE)result )
  {
    result = *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 108) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 1;
  }
  return result;
}

// sub_10023E78 @ 0x10023E78
int __usercall sub_10023E78@<eax>(int a1@<eax>)
{
  int v2; // edx
  int v3; // eax
  int v4; // edx

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1408) + 256;
  v3 = 0;
  *(_DWORD *)(a1 + 284) = v2;
  memset((void *)(v2 - 256), 0, 0x100u);
  do
  {
    *(_BYTE *)(v3 + v2) = v3;
    ++v3;
  }
  while ( v3 <= 255 );
  v4 = v2 + 128;
  memset((void *)(v4 + 128), 0xFFu, 0x180u);
  memset((void *)(v4 + 512), 0, 0x180u);
  qmemcpy((void *)(v4 + 896), *(const void **)(a1 + 284), 0x80u);
  return 0;
}

// sub_10023EE7 @ 0x10023EE7
int __usercall sub_10023EE7@<eax>(int a1@<esi>)
{
  int v1; // edi
  char v2; // al
  int result; // eax
  int v4; // ecx
  int v5; // eax
  int v6; // [esp+0h] [ebp-10h]
  int v7; // [esp+4h] [ebp-Ch]
  void *v8; // [esp+8h] [ebp-8h]
  char v9; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 380);
  sub_10023C89(v6);
  sub_10023E78(a1);
  *(_DWORD *)(v1 + 12) = 0;
  *(_BYTE *)(v1 + 16) = FUN_10023c18(v7, v8);
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  v2 = *(_BYTE *)(a1 + 74);
  if ( !v2 || !*(_BYTE *)(a1 + 64) )
  {
    *(_BYTE *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 89) = 0;
    *(_BYTE *)(a1 + 90) = 0;
  }
  if ( v2 )
  {
    if ( *(_BYTE *)(a1 + 65) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_DWORD *)(a1 + 100) == 3 )
    {
      if ( *(_DWORD *)(a1 + 116) )
      {
        *(_BYTE *)(a1 + 89) = 1;
        goto LABEL_10;
      }
      if ( *(_BYTE *)(a1 + 80) )
      {
        *(_BYTE *)(a1 + 90) = 1;
        goto LABEL_10;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 89) = 0;
      *(_BYTE *)(a1 + 90) = 0;
      *(_DWORD *)(a1 + 116) = 0;
    }
    *(_BYTE *)(a1 + 88) = 1;
LABEL_10:
    if ( *(_BYTE *)(a1 + 88) )
    {
      sub_10033E84((_DWORD *)a1);
      *(_DWORD *)(v1 + 20) = *(_DWORD *)(a1 + 420);
    }
    if ( *(_BYTE *)(a1 + 90) || *(_BYTE *)(a1 + 89) )
    {
      sub_100333F2(a1);
      *(_DWORD *)(v1 + 24) = *(_DWORD *)(a1 + 420);
    }
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(v1 + 16) )
    {
      sub_1003247D(a1);
    }
    else
    {
      sub_10031E84(a1);
      sub_100316F9(a1);
    }
    sub_1003123A(a1, *(_BYTE *)(a1 + 90));
  }
  sub_10030F9F(a1);
  if ( *(_BYTE *)(a1 + 201) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 200) )
  {
    sub_10030D87(a1);
  }
  else
  {
    sub_100301D9(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) || (v9 = 0, *(_BYTE *)(a1 + 64)) )
    v9 = 1;
  sub_1002F809(a1, v9);
  if ( !*(_BYTE *)(a1 + 65) )
    sub_1002EBCA(a1, 0);
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 396) + 8))(a1);
  v4 = *(_DWORD *)(a1 + 8);
  if ( v4 )
  {
    if ( !*(_BYTE *)(a1 + 64) )
    {
      result = *(_DWORD *)(a1 + 396);
      if ( *(_BYTE *)(result + 16) )
      {
        v5 = *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(a1 + 200) )
          v5 = 3 * v5 + 2;
        *(_DWORD *)(v4 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = v5 * *(_DWORD *)(a1 + 280);
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) = 0;
        result = (*(_BYTE *)(a1 + 90) != 0) + 2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
        ++*(_DWORD *)(v1 + 12);
      }
    }
  }
  return result;
}

// sub_10024094 @ 0x10024094
int __cdecl sub_10024094(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, 0);
    (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, 2);
    (**(void (__cdecl ***)(int, int))(a1 + 384))(a1, 2);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) && !*(_DWORD *)(a1 + 116) )
    {
      if ( *(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 90) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      }
      else if ( *(_BYTE *)(a1 + 88) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 20);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void (__cdecl ***)(int))(a1 + 408))(a1);
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 388) + 8))(a1);
    if ( !*(_BYTE *)(a1 + 65) )
    {
      if ( !*(_BYTE *)(v1 + 16) )
        (**(void (__cdecl ***)(int))(a1 + 416))(a1);
      (**(void (__cdecl ***)(int))(a1 + 412))(a1);
      if ( *(_BYTE *)(a1 + 74) )
        (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8 *)(v1 + 8));
      (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      (**(void (__cdecl ***)(int, _DWORD))(a1 + 384))(a1, 0);
    }
  }
  result = *(_DWORD *)(a1 + 8);
  if ( result )
  {
    *(_DWORD *)(result + 12) = *(_DWORD *)(v1 + 12);
    result = *(_DWORD *)(v1 + 12) + (*(_BYTE *)(v1 + 8) != 0) + 1;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
    if ( *(_BYTE *)(a1 + 64) )
    {
      result = *(_DWORD *)(a1 + 396);
      if ( !*(_BYTE *)(result + 17) )
      {
        result = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(result + 16) += (*(_BYTE *)(a1 + 90) != 0) + 1;
      }
    }
  }
  return result;
}

// sub_100241C1 @ 0x100241C1
int __cdecl sub_100241C1(int a1)
{
  int result; // eax
  int v2; // esi

  result = a1;
  v2 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(a1 + 74) )
    result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 420) + 8))(a1);
  ++*(_DWORD *)(v2 + 12);
  return result;
}

// sub_100241E2 @ 0x100241E2
int __cdecl sub_100241E2(int a1)
{
  int v1; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 380) = v1;
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)v1 = sub_10024094;
  *(_DWORD *)(v1 + 4) = sub_100241C1;
  return sub_10023EE7(a1);
}

// inflateReset @ 0x10024212
// zlib: reset inflate state
int inflateReset(void *strm)
{
  _DWORD *v1; // ecx

  if ( !strm )
    return -2;
  v1 = (_DWORD *)*((_DWORD *)strm + 7);
  if ( !v1 )
    return -2;
  *((_DWORD *)strm + 5) = 0;
  *((_DWORD *)strm + 2) = 0;
  *((_DWORD *)strm + 6) = 0;
  *v1 = v1[3] != 0 ? 7 : 0;
  inflate_blocks_reset(*(void **)(*((_DWORD *)strm + 7) + 20), strm, 0);
  return 0;
}

// inflateEnd @ 0x10024251
// zlib: free inflate state
int inflateEnd(void *strm)
{
  int v1; // eax
  void *v2; // eax

  if ( !strm )
    return -2;
  v1 = *((_DWORD *)strm + 7);
  if ( !v1 || !*((_DWORD *)strm + 9) )
    return -2;
  v2 = *(void **)(v1 + 20);
  if ( v2 )
    inflate_blocks_free(v2, strm);
  (*((void (__cdecl **)(_DWORD, _DWORD))strm + 9))(*((_DWORD *)strm + 10), *((_DWORD *)strm + 7));
  *((_DWORD *)strm + 7) = 0;
  return 0;
}

// inflateInit2_ @ 0x1002428F
// zlib: init inflate with window bits
int inflateInit2_(void *strm, int windowBits, char *version, int stream_size)
{
  bool v4; // zf
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  int v10; // [esp-4h] [ebp-10h]

  if ( !version || *version != 49 || stream_size != 56 )
    return -6;
  if ( !strm )
    return -2;
  v4 = *((_DWORD *)strm + 8) == 0;
  *((_DWORD *)strm + 6) = 0;
  if ( v4 )
  {
    *((_DWORD *)strm + 8) = zcalloc;
    *((_DWORD *)strm + 10) = 0;
  }
  if ( !*((_DWORD *)strm + 9) )
    *((_DWORD *)strm + 9) = zcfree;
  v5 = (*((int (__cdecl **)(_DWORD, int, int))strm + 8))(*((_DWORD *)strm + 10), 1, 24);
  *((_DWORD *)strm + 7) = v5;
  if ( v5 )
  {
    v6 = windowBits;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(*((_DWORD *)strm + 7) + 12) = 0;
    if ( windowBits < 0 )
    {
      v6 = -windowBits;
      *(_DWORD *)(*((_DWORD *)strm + 7) + 12) = 1;
    }
    if ( v6 < 8 || v6 > 15 )
    {
      v10 = -2;
    }
    else
    {
      *(_DWORD *)(*((_DWORD *)strm + 7) + 16) = v6;
      *(_DWORD *)(*((_DWORD *)strm + 7) + 20) = inflate_blocks_new(
                                                  strm,
                                                  *(_DWORD *)(*((_DWORD *)strm + 7) + 12) == 0 ? adler32 : 0,
                                                  1 << v6);
      if ( *(_DWORD *)(*((_DWORD *)strm + 7) + 20) )
      {
        inflateReset(strm);
        return 0;
      }
      v10 = -4;
    }
    v7 = v10;
    inflateEnd(strm);
    return v7;
  }
  return -4;
}

// inflateInit_ @ 0x10024374
// zlib: init inflate (wrapper for inflateInit2_)
int inflateInit_(void *strm, char *version, int stream_size)
{
  return inflateInit2_(strm, 15, version, stream_size);
}

// inflate @ 0x1002438B
// zlib: inflate compressed data
int inflate(void *strm, int flush)
{
  int v2; // ebx
  _DWORD *v3; // eax
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  _DWORD *v7; // eax
  int v8; // eax
  _DWORD *v9; // ecx
  int v10; // ebx
  bool v11; // zf
  int v12; // eax
  _DWORD *v13; // eax
  int v14; // eax
  int v15; // ecx
  _DWORD *v16; // eax
  int v17; // eax
  unsigned __int8 *v18; // ecx
  _DWORD *v19; // eax
  int v20; // eax
  unsigned __int8 *v21; // ecx
  _DWORD *v22; // eax
  int v23; // eax
  unsigned __int8 *v24; // ecx
  _DWORD *v25; // eax
  int v27; // eax
  int v28; // ecx
  _DWORD *v29; // eax
  int v30; // eax
  unsigned __int8 *v31; // ecx
  _DWORD *v32; // eax
  int v33; // eax
  unsigned __int8 *v34; // ecx
  _DWORD *v35; // eax
  int v36; // eax
  unsigned __int8 *v37; // ecx
  _DWORD *v38; // eax
  int v39; // eax
  int flusha; // [esp+18h] [ebp+8h]

  v2 = 0;
  if ( !strm )
    return -2;
  v3 = (_DWORD *)*((_DWORD *)strm + 7);
  if ( !v3 || !*(_DWORD *)strm )
    return -2;
  v4 = -5;
  if ( flush == 4 )
    v2 = -5;
  flusha = v2;
  while ( 1 )
  {
    switch ( *v3 )
    {
      case 0:
        v5 = *((_DWORD *)strm + 1);
        if ( !v5 )
          return v4;
        v6 = *((_DWORD *)strm + 7);
        ++*((_DWORD *)strm + 2);
        *((_DWORD *)strm + 1) = v5 - 1;
        *(_DWORD *)(v6 + 4) = **(unsigned __int8 **)strm;
        v7 = (_DWORD *)*((_DWORD *)strm + 7);
        LOBYTE(v6) = v7[1] & 0xF;
        ++*(_DWORD *)strm;
        v4 = v2;
        if ( (_BYTE)v6 == 8 )
        {
          if ( (unsigned int)((v7[1] >> 4) + 8) <= v7[4] )
          {
            *v7 = 1;
LABEL_14:
            v8 = *((_DWORD *)strm + 1);
            if ( !v8 )
              return v4;
            v9 = (_DWORD *)*((_DWORD *)strm + 7);
            ++*((_DWORD *)strm + 2);
            *((_DWORD *)strm + 1) = v8 - 1;
            v4 = v2;
            v10 = *(unsigned __int8 *)(*(_DWORD *)strm)++;
            if ( !((v10 + (v9[1] << 8)) % 0x1Fu) )
            {
              v11 = (v10 & 0x20) == 0;
              v2 = flusha;
              if ( v11 )
              {
                *v9 = 7;
                goto LABEL_37;
              }
              **((_DWORD **)strm + 7) = 2;
LABEL_43:
              v27 = *((_DWORD *)strm + 1);
              if ( !v27 )
                return v4;
              v28 = *((_DWORD *)strm + 7);
              ++*((_DWORD *)strm + 2);
              *((_DWORD *)strm + 1) = v27 - 1;
              *(_DWORD *)(v28 + 8) = **(unsigned __int8 **)strm << 24;
              v29 = (_DWORD *)*((_DWORD *)strm + 7);
              ++*(_DWORD *)strm;
              v4 = v2;
              *v29 = 3;
LABEL_45:
              v30 = *((_DWORD *)strm + 1);
              if ( !v30 )
                return v4;
              v31 = *(unsigned __int8 **)strm;
              ++*((_DWORD *)strm + 2);
              *((_DWORD *)strm + 1) = v30 - 1;
              *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v31 << 16;
              v32 = (_DWORD *)*((_DWORD *)strm + 7);
              ++*(_DWORD *)strm;
              v4 = v2;
              *v32 = 4;
LABEL_47:
              v33 = *((_DWORD *)strm + 1);
              if ( !v33 )
                return v4;
              v34 = *(unsigned __int8 **)strm;
              ++*((_DWORD *)strm + 2);
              *((_DWORD *)strm + 1) = v33 - 1;
              *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v34 << 8;
              v35 = (_DWORD *)*((_DWORD *)strm + 7);
              ++*(_DWORD *)strm;
              v4 = v2;
              *v35 = 5;
LABEL_49:
              v36 = *((_DWORD *)strm + 1);
              if ( !v36 )
                return v4;
              v37 = *(unsigned __int8 **)strm;
              ++*((_DWORD *)strm + 2);
              *((_DWORD *)strm + 1) = v36 - 1;
              *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v37;
              v38 = (_DWORD *)*((_DWORD *)strm + 7);
              ++*(_DWORD *)strm;
              *((_DWORD *)strm + 12) = v38[2];
              *v38 = 6;
              return 2;
            }
            v2 = flusha;
            *v9 = 13;
            *((_DWORD *)strm + 6) = "incorrect header check";
          }
          else
          {
            *v7 = 13;
            *((_DWORD *)strm + 6) = "invalid window size";
          }
        }
        else
        {
          *v7 = 13;
          *((_DWORD *)strm + 6) = "unknown compression method";
        }
LABEL_36:
        *(_DWORD *)(*((_DWORD *)strm + 7) + 4) = 5;
LABEL_37:
        v3 = (_DWORD *)*((_DWORD *)strm + 7);
        break;
      case 1:
        goto LABEL_14;
      case 2:
        goto LABEL_43;
      case 3:
        goto LABEL_45;
      case 4:
        goto LABEL_47;
      case 5:
        goto LABEL_49;
      case 6:
        **((_DWORD **)strm + 7) = 13;
        v39 = *((_DWORD *)strm + 7);
        *((_DWORD *)strm + 6) = "need dictionary";
        *(_DWORD *)(v39 + 4) = 0;
        return -2;
      case 7:
        v12 = inflate_blocks(*(void **)(*((_DWORD *)strm + 7) + 20), strm, v4);
        v4 = v12;
        if ( v12 == -3 )
        {
          **((_DWORD **)strm + 7) = 13;
          *(_DWORD *)(*((_DWORD *)strm + 7) + 4) = 0;
          goto LABEL_37;
        }
        if ( !v12 )
          v4 = v2;
        if ( v4 != 1 )
          return v4;
        v4 = v2;
        inflate_blocks_reset(*(void **)(*((_DWORD *)strm + 7) + 20), strm, (unsigned int *)(*((_DWORD *)strm + 7) + 4));
        v13 = (_DWORD *)*((_DWORD *)strm + 7);
        if ( v13[3] )
        {
          *v13 = 12;
          goto LABEL_37;
        }
        *v13 = 8;
LABEL_27:
        v14 = *((_DWORD *)strm + 1);
        if ( !v14 )
          return v4;
        v15 = *((_DWORD *)strm + 7);
        ++*((_DWORD *)strm + 2);
        *((_DWORD *)strm + 1) = v14 - 1;
        *(_DWORD *)(v15 + 8) = **(unsigned __int8 **)strm << 24;
        v16 = (_DWORD *)*((_DWORD *)strm + 7);
        ++*(_DWORD *)strm;
        v4 = v2;
        *v16 = 9;
LABEL_29:
        v17 = *((_DWORD *)strm + 1);
        if ( !v17 )
          return v4;
        v18 = *(unsigned __int8 **)strm;
        ++*((_DWORD *)strm + 2);
        *((_DWORD *)strm + 1) = v17 - 1;
        *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v18 << 16;
        v19 = (_DWORD *)*((_DWORD *)strm + 7);
        ++*(_DWORD *)strm;
        v4 = v2;
        *v19 = 10;
LABEL_31:
        v20 = *((_DWORD *)strm + 1);
        if ( !v20 )
          return v4;
        v21 = *(unsigned __int8 **)strm;
        ++*((_DWORD *)strm + 2);
        *((_DWORD *)strm + 1) = v20 - 1;
        *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v21 << 8;
        v22 = (_DWORD *)*((_DWORD *)strm + 7);
        ++*(_DWORD *)strm;
        v4 = v2;
        *v22 = 11;
LABEL_33:
        v23 = *((_DWORD *)strm + 1);
        if ( !v23 )
          return v4;
        v24 = *(unsigned __int8 **)strm;
        ++*((_DWORD *)strm + 2);
        *((_DWORD *)strm + 1) = v23 - 1;
        *(_DWORD *)(*((_DWORD *)strm + 7) + 8) += *v24;
        v25 = (_DWORD *)*((_DWORD *)strm + 7);
        ++*(_DWORD *)strm;
        v4 = v2;
        if ( v25[1] != v25[2] )
        {
          *v25 = 13;
          *((_DWORD *)strm + 6) = "incorrect data check";
          goto LABEL_36;
        }
        **((_DWORD **)strm + 7) = 12;
        return 1;
      case 8:
        goto LABEL_27;
      case 9:
        goto LABEL_29;
      case 0xA:
        goto LABEL_31;
      case 0xB:
        goto LABEL_33;
      case 0xC:
        return 1;
      case 0xD:
        return -3;
      default:
        return -2;
    }
  }
}

// sub_100246F2 @ 0x100246F2
void *__cdecl sub_100246F2(int a1)
{
  size_t v1; // esi
  void *v2; // edx

  if ( a1 == 2 )
  {
    v1 = 64;
  }
  else
  {
    if ( a1 != 1 )
      return 0;
    v1 = 412;
  }
  v2 = malloc(v1);
  if ( v2 )
    memset(v2, 0, v1);
  return v2;
}

// png_free_ptr @ 0x10024734
// free wrapper for png allocations
void png_free_ptr(void *ptr)
{
  if ( ptr )
    free(ptr);
}

// png_malloc @ 0x10024741
// png malloc wrapper (errors on OOM)
void *png_malloc(void *png_ptr, unsigned int size)
{
  void *result; // eax

  if ( !png_ptr || !size )
    return 0;
  result = malloc(size);
  if ( !result )
    png_error(png_ptr, "Out of Memory");
  return result;
}

// png_free @ 0x10024777
// png free callback wrapper
void png_free(void *png_ptr, void *ptr)
{
  if ( png_ptr )
  {
    if ( ptr )
      free(ptr);
  }
}

// FUN_10024790 @ 0x10024790
// [binja] int32_t sub_10024790(int32_t arg1, int32_t arg2, int32_t arg3)
int FUN_10024790(int arg1, int arg2, int arg3)
{
  unsigned int v4; // [esp+18h] [ebp+10h]

  qmemcpy((void *)arg2, (const void *)arg3, v4);
  return arg2;
}

// FUN_100247b3 @ 0x100247B3
// [binja] int32_t sub_100247b3(int32_t arg1, char arg2, int32_t arg3)
int FUN_100247b3(int arg1, char arg2, int arg3)
{
  int v3; // ebx
  int v4; // eax
  unsigned int v6; // [esp+1Ch] [ebp+10h]

  LOBYTE(v3) = arg3;
  BYTE1(v3) = arg3;
  v4 = v3 << 16;
  LOWORD(v4) = v3;
  memset32((void *)arg2, v4, v6 >> 2);
  memset((void *)(arg2 + 4 * (v6 >> 2)), arg3, v6 & 3);
  return arg2;
}

// png_get_uint_32 @ 0x100247E4
// read big-endian 32-bit value
unsigned int png_get_uint_32(unsigned __int8 *buf)
{
  return buf[3] + ((buf[2] + ((buf[1] + (*buf << 8)) << 8)) << 8);
}

// png_crc_read @ 0x10024807
// read PNG chunk data and update CRC
void png_crc_read(void *png_ptr, unsigned __int8 *buf, unsigned int length)
{
  png_read_data(png_ptr, buf, length);
  if ( (*((_BYTE *)png_ptr + 268) & 0x20) == 0 )
  {
    if ( (*((_BYTE *)png_ptr + 93) & 8) != 0 )
      return;
    goto LABEL_5;
  }
  if ( (*((_DWORD *)png_ptr + 23) & 0x300) != 0x300 )
LABEL_5:
    *((_DWORD *)png_ptr + 64) = sub_10025AEC(*((_DWORD *)png_ptr + 64), buf, length);
}

// png_crc_error @ 0x10024821
// read stored CRC and compare with computed
int png_crc_error(void *png_ptr)
{
  _DWORD *v1; // esi
  int v2; // edi

  v1 = png_ptr;
  v2 = 1;
  if ( (*((_BYTE *)png_ptr + 268) & 0x20) != 0 )
  {
    if ( (*((_DWORD *)png_ptr + 23) & 0x300) != 0x300 )
      goto LABEL_6;
  }
  else if ( (*((_BYTE *)png_ptr + 93) & 8) == 0 )
  {
    goto LABEL_6;
  }
  v2 = 0;
LABEL_6:
  png_read_data(png_ptr, (unsigned __int8 *)&png_ptr, 4u);
  return v2 && png_get_uint_32((unsigned __int8 *)&png_ptr) != v1[64];
}

// png_check_chunk_name @ 0x1002487F
// validate PNG chunk type characters
void png_check_chunk_name(void *png_ptr, unsigned __int8 *chunk_name)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  unsigned __int8 v5; // al

  v2 = *chunk_name;
  if ( *chunk_name < 0x29u
    || v2 > 0x7Au
    || v2 > 0x5Au && v2 < 0x61u
    || (v3 = chunk_name[1], v3 < 0x29u)
    || v3 > 0x7Au
    || v3 > 0x5Au && v3 < 0x61u
    || (v4 = chunk_name[2], v4 < 0x29u)
    || v4 > 0x7Au
    || v4 > 0x5Au && v4 < 0x61u
    || (v5 = chunk_name[3], v5 < 0x29u)
    || v5 > 0x7Au
    || v5 > 0x5Au && v5 < 0x61u )
  {
    FUN_1001e147(png_ptr, (unsigned int *)"invalid chunk type");
  }
}

// sub_100248E1 @ 0x100248E1
char __cdecl sub_100248E1(int a1, char *a2, int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  char *v5; // ebx
  char *v6; // edx
  _BYTE *v7; // edi
  unsigned __int8 *v8; // esi
  int v9; // edx
  _BYTE *v10; // edi
  unsigned __int8 *v11; // esi
  int v12; // edx
  _BYTE *v13; // edi
  unsigned __int8 *v14; // esi
  int v15; // edx
  int v17; // [esp+8h] [ebp-Ch]
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+8h] [ebp-Ch]
  unsigned int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  int v23; // [esp+Ch] [ebp-8h]
  int v24; // [esp+Ch] [ebp-8h]
  unsigned __int8 v25; // [esp+13h] [ebp-1h]

  v3 = *(unsigned __int8 *)(a1 + 251);
  if ( a3 == 255 )
  {
    v4 = (*(_DWORD *)(a1 + 184) * v3 + 7) >> 3;
    qmemcpy(a2, (const void *)(*(_DWORD *)(a1 + 220) + 1), 4 * ((*(_DWORD *)(a1 + 184) * v3 + 7) >> 5) + (v4 & 3));
  }
  else
  {
    switch ( v3 )
    {
      case 1u:
        v4 = *(_DWORD *)(a1 + 184);
        v13 = a2;
        v14 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v24 = 128;
        v15 = 7;
        if ( v4 )
        {
          v20 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v24) != 0 )
            {
              LOBYTE(v4) = ((*v14 >> v15) & 1) << v15;
              *v13 = v4 | *v13 & (32639 >> (7 - v15));
            }
            if ( v15 )
            {
              --v15;
            }
            else
            {
              ++v14;
              v15 = 7;
              ++v13;
            }
            if ( v24 == 1 )
              v24 = 128;
            else
              v24 >>= 1;
            --v20;
          }
          while ( v20 );
        }
        break;
      case 2u:
        v4 = *(_DWORD *)(a1 + 184);
        v10 = a2;
        v11 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v23 = 128;
        v12 = 6;
        if ( v4 )
        {
          v19 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v23) != 0 )
            {
              LOBYTE(v4) = ((*v11 >> v12) & 3) << v12;
              *v10 = v4 | *v10 & (16191 >> (6 - v12));
            }
            if ( v12 )
            {
              v12 -= 2;
            }
            else
            {
              ++v11;
              v12 = 6;
              ++v10;
            }
            if ( v23 == 1 )
              v23 = 128;
            else
              v23 >>= 1;
            --v19;
          }
          while ( v19 );
        }
        break;
      case 4u:
        v4 = *(_DWORD *)(a1 + 184);
        v7 = a2;
        v8 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v22 = 128;
        v9 = 4;
        if ( v4 )
        {
          v18 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v22) != 0 )
            {
              LOBYTE(v4) = ((*v8 >> v9) & 0xF) << v9;
              *v7 = v4 | *v7 & (3855 >> (4 - v9));
            }
            if ( v9 )
            {
              v9 -= 4;
            }
            else
            {
              ++v8;
              v9 = 4;
              ++v7;
            }
            if ( v22 == 1 )
              v22 = 128;
            else
              v22 >>= 1;
            --v18;
          }
          while ( v18 );
        }
        break;
      default:
        v4 = *(_DWORD *)(a1 + 184);
        v5 = a2;
        v6 = (char *)(*(_DWORD *)(a1 + 220) + 1);
        v21 = v3 >> 3;
        v25 = 0x80;
        if ( v4 )
        {
          v17 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( ((unsigned __int8)a3 & v25) != 0 )
            {
              v4 = v3 >> 3;
              qmemcpy(v5, v6, v21);
            }
            v6 += v21;
            v5 += v21;
            if ( v25 == 1 )
              v25 = 0x80;
            else
              v25 >>= 1;
            --v17;
          }
          while ( v17 );
        }
        break;
    }
  }
  return v4;
}

// sub_10024AF7 @ 0x10024AF7
void __cdecl sub_10024AF7(int *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  unsigned int v5; // esi
  unsigned int v6; // esi
  char *v7; // ebx
  char v8; // al
  unsigned int v9; // ecx
  _BYTE *v10; // edi
  char *v11; // esi
  int v12; // eax
  bool v13; // cc
  void *v14; // edi
  _BYTE *v15; // edi
  _BYTE *v16; // esi
  char v17; // al
  bool v18; // zf
  _BYTE *v19; // edi
  _BYTE *v20; // esi
  char v21; // al
  _BYTE *v22; // edi
  _BYTE *v23; // esi
  char v24; // al
  unsigned int v25; // ecx
  _BYTE v26[4]; // [esp+0h] [ebp-18h] BYREF
  int v27; // [esp+4h] [ebp-14h]
  unsigned int v28; // [esp+8h] [ebp-10h]
  int v29; // [esp+Ch] [ebp-Ch]
  unsigned int v30; // [esp+10h] [ebp-8h]
  unsigned int v31; // [esp+14h] [ebp-4h]
  char *v32; // [esp+24h] [ebp+Ch]
  char v33; // [esp+27h] [ebp+Fh]
  char v34; // [esp+27h] [ebp+Fh]
  char v35; // [esp+27h] [ebp+Fh]

  if ( a2 && a1 )
  {
    v3 = *a1;
    v4 = dword_1004EAAC[a3] * *a1;
    v29 = dword_1004EAAC[a3];
    v5 = *((unsigned __int8 *)a1 + 11);
    if ( v5 == 1 )
    {
      v28 = 0;
      v22 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 3));
      v23 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 3));
      v30 = 7 - (((_BYTE)v3 - 1) & 7);
      v31 = 7 - (((_BYTE)v4 - 1) & 7);
      if ( v3 )
      {
        do
        {
          v24 = (*v22 >> v30) & 1;
          v35 = v24;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 7;
              *v23 = (v24 << v31) | *v23 & (32639 >> (7 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v23;
              }
              else
              {
                ++v31;
              }
              if ( !--v27 )
                break;
              v24 = v35;
            }
          }
          if ( v30 == 7 )
          {
            v30 = 0;
            --v22;
          }
          else
          {
            ++v30;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else if ( *((_BYTE *)a1 + 11) == 2 )
    {
      v28 = 0;
      v19 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 2));
      v20 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 2));
      v30 = 2 * (3 - (((_BYTE)v3 - 1) & 3));
      v31 = 2 * (3 - (((_BYTE)v4 - 1) & 3));
      if ( v3 )
      {
        do
        {
          v21 = (*v19 >> v30) & 3;
          v34 = v21;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 6;
              *v20 = (v21 << v31) | *v20 & (16191 >> (6 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v20;
              }
              else
              {
                v31 += 2;
              }
              if ( !--v27 )
                break;
              v21 = v34;
            }
          }
          if ( v30 == 6 )
          {
            v30 = 0;
            --v19;
          }
          else
          {
            v30 += 2;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else if ( *((_BYTE *)a1 + 11) == 4 )
    {
      v28 = 0;
      v15 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 1));
      v16 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 1));
      v30 = 4 - 4 * (((_BYTE)v3 - 1) & 1);
      v31 = 4 - 4 * (((_BYTE)v4 - 1) & 1);
      if ( v3 )
      {
        do
        {
          v17 = (*v15 >> v30) & 0xF;
          v33 = v17;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 4;
              *v16 = (v17 << v31) | *v16 & (3855 >> (4 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v16;
              }
              else
              {
                v31 += 4;
              }
              if ( !--v27 )
                break;
              v17 = v33;
            }
          }
          if ( v30 == 4 )
          {
            v30 = 0;
            --v15;
          }
          else
          {
            v30 += 4;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else
    {
      v31 = 0;
      v6 = v5 >> 3;
      v7 = (char *)(a2 + v6 * (v3 - 1));
      v30 = v6;
      v32 = (char *)(a2 + v6 * (v4 - 1));
      if ( v3 )
      {
        do
        {
          v8 = v30;
          v9 = v30 >> 2;
          qmemcpy(v26, v7, 4 * (v30 >> 2));
          v11 = &v7[4 * v9];
          v10 = &v26[4 * v9];
          LOBYTE(v9) = v8;
          v12 = v29;
          v13 = v29 <= 0;
          qmemcpy(v10, v11, v9 & 3);
          if ( !v13 )
          {
            v28 = v12;
            do
            {
              v14 = v32;
              v32 -= v30;
              qmemcpy(v14, v26, v30);
              --v28;
            }
            while ( v28 );
          }
          v7 -= v30;
          ++v31;
        }
        while ( v31 < *a1 );
      }
    }
    v25 = (v4 * (unsigned int)*((unsigned __int8 *)a1 + 11) + 7) >> 3;
    *a1 = v4;
    a1[1] = v25;
  }
}

// FUN_10024dc0 @ 0x10024DC0
void FUN_10024dc0(void *png_ptr, int param_2, unsigned __int8 *param_3, unsigned __int8 *param_4, int param_5)
{
  unsigned __int8 *v5; // edx
  unsigned __int8 *v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // esi
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  bool v15; // zf
  unsigned __int8 *v16; // esi
  unsigned __int8 *v17; // edi
  int v18; // eax
  int v19; // ecx
  unsigned __int8 *j; // ebx
  unsigned int v21; // esi
  unsigned __int8 *v22; // eax
  unsigned int i; // ecx
  unsigned int v24; // ecx
  unsigned int v25; // eax
  unsigned __int8 *v26; // esi
  unsigned __int8 *v27; // edx
  unsigned int v28; // ecx
  int v29; // [esp+8h] [ebp-14h]
  int v30; // [esp+Ch] [ebp-10h]
  unsigned __int8 *v31; // [esp+10h] [ebp-Ch]
  int v32; // [esp+14h] [ebp-8h]
  unsigned __int8 *v33; // [esp+18h] [ebp-4h]
  unsigned __int8 *param_5a; // [esp+34h] [ebp+18h]

  if ( param_5 )
  {
    switch ( param_5 )
    {
      case 1:
        v24 = *(_DWORD *)(param_2 + 4);
        v25 = (*(unsigned __int8 *)(param_2 + 11) + 7) >> 3;
        v26 = &param_3[v25];
        if ( v25 < v24 )
        {
          v27 = param_3;
          v28 = v24 - v25;
          do
          {
            *v26++ += *v27++;
            --v28;
          }
          while ( v28 );
        }
        break;
      case 2:
        v21 = *(_DWORD *)(param_2 + 4);
        v22 = param_3;
        for ( i = 0; i < v21; ++i )
          *v22++ += param_4[i];
        break;
      case 3:
        v16 = param_3;
        v17 = param_4;
        v18 = (*(unsigned __int8 *)(param_2 + 11) + 7) >> 3;
        v19 = *(_DWORD *)(param_2 + 4) - v18;
        for ( j = param_3; v18; --v18 )
          *v16++ += *v17++ >> 1;
        for ( ; v19; --v19 )
          *v16++ += (*v17++ + *j++) / 2;
        break;
      case 4:
        v5 = param_3;
        v6 = param_4;
        v7 = (*(unsigned __int8 *)(param_2 + 11) + 7) >> 3;
        v8 = *(_DWORD *)(param_2 + 4) - v7;
        v31 = param_3;
        param_5a = param_3;
        v33 = param_4;
        if ( v7 )
        {
          v9 = (*(unsigned __int8 *)(param_2 + 11) + 7) >> 3;
          do
          {
            *v5++ += *v6++;
            --v9;
          }
          while ( v9 );
          v31 = v5;
        }
        if ( v8 )
        {
          v30 = v8;
          do
          {
            v10 = *param_5a;
            v11 = *v33;
            ++param_5a;
            v29 = *v6++;
            ++v33;
            v12 = v10 - v11;
            if ( v29 - v11 >= 0 )
              v32 = v29 - v11;
            else
              v32 = v11 - v29;
            v13 = v10 - v11;
            if ( v12 < 0 )
              v13 = v11 - v10;
            v14 = v12 + v29 - v11;
            if ( v14 < 0 )
              v14 = -v14;
            if ( v32 > v13 || v32 > v14 )
            {
              LOBYTE(v10) = v29;
              if ( v13 > v14 )
                LOBYTE(v10) = v11;
            }
            *v31 += v10;
            v15 = v30-- == 1;
            ++v31;
          }
          while ( !v15 );
        }
        break;
      default:
        png_warning(png_ptr, "Ignoring bad adaptive filter type");
        *param_3 = 0;
        break;
    }
  }
}

// FUN_10024f3b @ 0x10024F3B
void FUN_10024f3b(void *png_ptr)
{
  unsigned int v1; // eax
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  char v8; // cl
  char v9; // cl
  int v10; // ecx
  void *v11; // eax

  *((_DWORD *)png_ptr + 26) = 0;
  FUN_10020036(png_ptr);
  v1 = *((_DWORD *)png_ptr + 47);
  if ( *((_BYTE *)png_ptr + 275) )
  {
    if ( (*((_BYTE *)png_ptr + 96) & 2) == 0 )
      v1 = (v1 + 7) >> 3;
    v2 = *((_DWORD *)png_ptr + 46);
    *((_DWORD *)png_ptr + 48) = v1;
    v3 = (v2
        - dword_1004EA90[*((unsigned __int8 *)png_ptr + 276)]
        + dword_1004EAAC[*((unsigned __int8 *)png_ptr + 276)]
        - 1)
       / (unsigned int)dword_1004EAAC[*((unsigned __int8 *)png_ptr + 276)];
    v4 = ((v3 * *((unsigned __int8 *)png_ptr + 281) + 7) >> 3) + 1;
    *((_DWORD *)png_ptr + 52) = v3;
    *((_DWORD *)png_ptr + 51) = v4;
  }
  else
  {
    v2 = *((_DWORD *)png_ptr + 46);
    *((_DWORD *)png_ptr + 48) = v1;
    v5 = *((_DWORD *)png_ptr + 50) + 1;
    *((_DWORD *)png_ptr + 52) = v2;
    *((_DWORD *)png_ptr + 51) = v5;
  }
  v6 = *((unsigned __int8 *)png_ptr + 281);
  v7 = *((_DWORD *)png_ptr + 24);
  if ( (v7 & 4) != 0 && *((_BYTE *)png_ptr + 279) < 8u )
    v6 = 8;
  if ( (v7 & 0x1000) != 0 )
  {
    v8 = *((_BYTE *)png_ptr + 278);
    if ( v8 == 3 )
    {
      v6 = 8 * (*((_WORD *)png_ptr + 133) != 0) + 24;
    }
    else if ( v8 )
    {
      if ( v8 == 2 && *((_WORD *)png_ptr + 133) )
        v6 = 4 * v6 / 3;
    }
    else
    {
      if ( v6 < 8 )
        v6 = 8;
      if ( *((_WORD *)png_ptr + 133) )
        v6 *= 2;
    }
  }
  if ( (v7 & 0x8000) != 0 )
  {
    v9 = *((_BYTE *)png_ptr + 278);
    if ( v9 != 3 )
    {
      if ( v9 )
      {
        if ( v9 != 2 )
          goto LABEL_28;
        v10 = v6 > 32 ? 64 : 32;
      }
      else
      {
        v10 = v6 > 8 ? 32 : 16;
      }
      v6 = v10;
      goto LABEL_28;
    }
    v6 = 32;
  }
LABEL_28:
  *((_DWORD *)png_ptr + 55) = png_malloc(png_ptr, ((v6 * ((v2 + 7) & 0xFFFFFFF8) + 7) >> 3) + ((v6 + 7) >> 3) + 1);
  v11 = png_malloc(png_ptr, *((_DWORD *)png_ptr + 50) + 1);
  *((_DWORD *)png_ptr + 54) = v11;
  FUN_100247b3((int)png_ptr, (char)v11, 0);
  *((_DWORD *)png_ptr + 23) |= 0x40u;
}

// png_crc_finish @ 0x100250D7
// read remaining chunk bytes and check CRC
int png_crc_finish(void *png_ptr, unsigned int skip)
{
  unsigned int i; // edi

  for ( i = *((_DWORD *)png_ptr + 40); skip > i; skip -= i )
    png_crc_read(png_ptr, *((unsigned __int8 **)png_ptr + 39), *((_DWORD *)png_ptr + 40));
  if ( skip )
    png_crc_read(png_ptr, *((unsigned __int8 **)png_ptr + 39), skip);
  if ( !png_crc_error(png_ptr) )
    return 0;
  if ( ((*((_BYTE *)png_ptr + 268) & 0x20) == 0 || (*((_BYTE *)png_ptr + 93) & 2) != 0)
    && ((*((_BYTE *)png_ptr + 268) & 0x20) != 0 || (*((_BYTE *)png_ptr + 93) & 4) == 0) )
  {
    FUN_1001e147(png_ptr, (unsigned int *)"CRC error");
  }
  FUN_1001e16c(png_ptr, (unsigned int *)"CRC error");
  return 1;
}

// grim_png_read_IHDR @ 0x10025163
void grim_png_read_IHDR(void *png_ptr, unsigned int *param_2, int param_3)
{
  int uint_32; // edi
  signed int v5; // eax
  char v6; // bl
  unsigned __int8 v7; // al
  unsigned __int8 v8; // [esp-Ch] [ebp-34h]
  unsigned __int8 v9; // [esp-8h] [ebp-30h]
  unsigned __int8 v10; // [esp-4h] [ebp-2Ch]
  unsigned __int8 buf[4]; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned __int8 v12[4]; // [esp+10h] [ebp-18h] BYREF
  unsigned __int8 v13; // [esp+14h] [ebp-14h]
  unsigned __int8 v14; // [esp+15h] [ebp-13h]
  unsigned __int8 v15; // [esp+16h] [ebp-12h]
  unsigned __int8 v16; // [esp+17h] [ebp-11h]
  unsigned __int8 v17; // [esp+18h] [ebp-10h]
  unsigned __int8 param_8[4]; // [esp+1Ch] [ebp-Ch]
  unsigned __int8 param_9[4]; // [esp+20h] [ebp-8h]
  unsigned __int8 param_7[4]; // [esp+24h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+30h] [ebp+8h]
  unsigned __int8 param_3a; // [esp+38h] [ebp+10h]

  if ( *((_DWORD *)png_ptr + 22) )
    png_error(png_ptr, "Out of place IHDR");
  if ( param_3 != 13 )
    png_error(png_ptr, "Invalid IHDR chunk");
  *((_DWORD *)png_ptr + 22) |= 1u;
  png_crc_read(png_ptr, buf, 0xDu);
  png_crc_finish(png_ptr, 0);
  uint_32 = png_get_uint_32(buf);
  v5 = png_get_uint_32(v12);
  v6 = v13;
  Buf = (int *)v5;
  param_3a = v14;
  *(_DWORD *)param_8 = v15;
  *(_DWORD *)param_9 = v16;
  *(_DWORD *)param_7 = v17;
  if ( uint_32 <= 0 || v5 <= 0 )
    png_error(png_ptr, "Invalid image size in IHDR");
  if ( v13 != 1 && v13 != 2 && v13 != 4 && v13 != 8 && v13 != 16 )
    png_error(png_ptr, "Invalid bit depth in IHDR");
  if ( v14 == 1 || v14 == 5 || v14 > 6u )
    png_error(png_ptr, "Invalid color type in IHDR");
  if ( v14 == 3 && v13 > 8u || (v14 == 2 || v14 == 4 || v14 == 6) && v13 < 8u )
    png_error(png_ptr, "Invalid color type/bit depth combination in IHDR");
  if ( *(int *)param_7 >= 2 )
    png_error(png_ptr, "Unknown interlace method in IHDR");
  if ( *(_DWORD *)param_8 )
    png_error(png_ptr, "Unknown compression method in IHDR");
  if ( *(_DWORD *)param_9 )
    png_error(png_ptr, "Unknown filter method in IHDR");
  *((_BYTE *)png_ptr + 275) = param_7[0];
  *((_DWORD *)png_ptr + 46) = uint_32;
  *((_DWORD *)png_ptr + 47) = v5;
  *((_BYTE *)png_ptr + 279) = v6;
  *((_BYTE *)png_ptr + 278) = param_3a;
  switch ( param_3a )
  {
    case 0u:
      goto LABEL_39;
    case 2u:
      *((_BYTE *)png_ptr + 282) = 3;
      break;
    case 3u:
LABEL_39:
      *((_BYTE *)png_ptr + 282) = 1;
      break;
    case 4u:
      *((_BYTE *)png_ptr + 282) = 2;
      break;
    case 6u:
      *((_BYTE *)png_ptr + 282) = 4;
      break;
  }
  v10 = param_9[0];
  v7 = v6 * *((_BYTE *)png_ptr + 282);
  v9 = param_8[0];
  *((_BYTE *)png_ptr + 281) = v7;
  v8 = param_7[0];
  *((_DWORD *)png_ptr + 50) = (uint_32 * (unsigned int)v7 + 7) >> 3;
  FUN_1002031c(png_ptr, param_2, uint_32, (unsigned int)Buf, v6, param_3a, v8, v9, v10);
}

// grim_png_read_PLTE @ 0x10025359
void grim_png_read_PLTE(void *this, void *png_ptr, int param_2, unsigned int param_3)
{
  void *v4; // esi
  int v5; // eax
  unsigned int v6; // edx
  int v7; // ebx
  unsigned int *v8; // eax
  _BYTE *v9; // edi
  _BYTE *v10; // edi
  void *v11; // [esp-1Ch] [ebp-28h]
  int v12; // [esp+4h] [ebp-8h]
  int v13; // [esp+8h] [ebp-4h]

  v4 = this;
  v5 = *((_DWORD *)this + 22);
  if ( (v5 & 1) == 0 )
    png_error(this, "Missing IHDR before PLTE");
  if ( (v5 & 4) != 0 )
  {
    png_warning(this, "Invalid PLTE after IDAT");
LABEL_10:
    png_crc_finish(v4, param_2);
    return;
  }
  if ( (v5 & 2) != 0 )
    png_error(this, "Duplicate PLTE chunk");
  v6 = param_2 % 3u;
  *((_DWORD *)this + 22) |= 2u;
  if ( v6 )
  {
    if ( *((_BYTE *)v4 + 278) == 3 )
      png_error(v4, "Invalid palette chunk");
    png_warning(v4, "Invalid palette chunk");
    goto LABEL_10;
  }
  v7 = param_2 / 3;
  v8 = FUN_1002052b(v4, param_2 / 3, 3);
  *((_BYTE *)v4 + 93) |= 0x10u;
  v12 = (int)v8;
  if ( v7 > 0 )
  {
    v9 = (char *)v8 + 2;
    v13 = v7;
    do
    {
      png_crc_read(v4, (unsigned __int8 *)&this, 3u);
      *((_WORD *)v9 - 1) = (_WORD)this;
      *v9 = BYTE2(this);
      v9 += 3;
      --v13;
    }
    while ( v13 );
  }
  png_crc_finish(v4, 0);
  v10 = png_ptr;
  v11 = png_ptr;
  *((_DWORD *)v4 + 65) = v12;
  *((_WORD *)v4 + 132) = v7;
  sub_100203BD((int)v4, (int)v11, v12, v7);
  if ( *((_BYTE *)v4 + 278) == 3 && v10 && (v10[8] & 0x10) != 0 && *((_WORD *)v4 + 133) > *((_WORD *)v4 + 132) )
  {
    png_warning(v4, "Truncating incorrect tRNS chunk length");
    *((_WORD *)v4 + 133) = *((_WORD *)v4 + 132);
  }
}

// FUN_10025483 @ 0x10025483
void FUN_10025483(void *png_ptr, unsigned int param_2, unsigned int param_3, int param_4, unsigned int param_5)
{
  int v5; // eax

  v5 = *((_DWORD *)png_ptr + 22);
  if ( (v5 & 1) == 0 || (v5 & 4) == 0 )
    png_error(png_ptr, "No image in file");
  *((_DWORD *)png_ptr + 22) |= 0x18u;
  if ( param_3 )
    png_warning(png_ptr, "Incorrect IEND chunk length");
  png_crc_finish(png_ptr, param_3);
}

// FUN_100254cd @ 0x100254CD
void FUN_100254cd(void *png_ptr, int param_2, unsigned int param_3)
{
  float *v3; // esi
  int v4; // eax
  int v5; // edi
  int v6; // eax
  unsigned int uint_32; // eax
  double v8; // st7

  v3 = (float *)png_ptr;
  v4 = *((_DWORD *)png_ptr + 22);
  v5 = param_2;
  if ( (v4 & 1) == 0 )
    png_error(png_ptr, "Missing IHDR before gAMA");
  if ( (v4 & 4) != 0 )
  {
    png_warning(png_ptr, "Invalid gAMA after IDAT");
    goto LABEL_5;
  }
  if ( (v4 & 2) != 0 )
  {
    png_warning(png_ptr, "Out of place gAMA chunk");
  }
  else if ( param_2 )
  {
    v6 = *(_DWORD *)(param_2 + 8);
    if ( (v6 & 1) != 0 && (v6 & 0x800) == 0 )
    {
      png_warning(png_ptr, "Duplicate gAMA chunk");
      goto LABEL_5;
    }
  }
  if ( param_3 != 4 )
  {
    png_warning(v3, "Incorrect gAMA chunk length");
LABEL_5:
    png_crc_finish(v3, param_3);
    return;
  }
  png_crc_read(v3, (unsigned __int8 *)&png_ptr, 4u);
  if ( !png_crc_finish(v3, 0) )
  {
    uint_32 = png_get_uint_32((unsigned __int8 *)&png_ptr);
    if ( uint_32 )
    {
      if ( (*(_DWORD *)(v5 + 8) & 0x800) != 0 && fabs((double)uint_32 - 45455.0) > 500.0 )
      {
        png_warning(v3, "Ignoring incorrect gAMA value when sRGB is also present");
      }
      else
      {
        v8 = (double)uint_32 * 0.0000099999997;
        v3[76] = v8;
        sub_10020301((int)v3, v5, v8);
      }
    }
  }
}

// FUN_100255d8 @ 0x100255D8
void FUN_100255d8(void *png_ptr, int param_2, unsigned int param_3)
{
  float *v3; // esi
  int v4; // eax
  unsigned int v5; // edi

  v3 = (float *)png_ptr;
  v4 = *((_DWORD *)png_ptr + 22);
  if ( (v4 & 1) == 0 )
    png_error(png_ptr, "Missing IHDR before sRGB");
  if ( (v4 & 4) != 0 )
  {
    png_warning(png_ptr, "Invalid sRGB after IDAT");
    goto LABEL_5;
  }
  if ( (v4 & 2) != 0 )
  {
    png_warning(png_ptr, "Out of place sRGB chunk");
  }
  else if ( param_2 && (*(_BYTE *)(param_2 + 9) & 8) != 0 )
  {
    png_warning(png_ptr, "Duplicate sRGB chunk");
    goto LABEL_5;
  }
  if ( param_3 != 1 )
  {
    png_warning(v3, "Incorrect sRGB chunk length");
LABEL_5:
    png_crc_finish(v3, param_3);
    return;
  }
  png_crc_read(v3, (unsigned __int8 *)&png_ptr + 3, 1u);
  if ( !png_crc_finish(v3, 0) )
  {
    v5 = HIBYTE(png_ptr);
    if ( HIBYTE(png_ptr) < 4u )
    {
      if ( (*(_BYTE *)(param_2 + 8) & 1) != 0 && fabs(v3[76] * 100000.0 + 0.5 - 45455.0) > 500.0 )
        png_warning(v3, "Ignoring incorrect gAMA value when sRGB is also present");
      sub_100203FC((int)v3, __SPAIR64__(v5, param_2));
    }
    else
    {
      png_warning(v3, "Unknown sRGB intent");
    }
  }
}

// FUN_100256c7 @ 0x100256C7
void FUN_100256c7(void *png_ptr, int param_2, unsigned int param_3)
{
  int v3; // eax
  char v4; // al
  unsigned __int8 *v5; // eax
  __int16 v6; // cx
  __int16 v7; // ax
  __int16 v8; // cx
  unsigned __int8 buf[4]; // [esp+8h] [ebp-8h] BYREF
  unsigned __int8 v10; // [esp+Ch] [ebp-4h]
  unsigned __int8 v11; // [esp+Dh] [ebp-3h]

  v3 = *((_DWORD *)png_ptr + 22);
  if ( (v3 & 1) == 0 )
    png_error(png_ptr, "Missing IHDR before tRNS");
  if ( (v3 & 4) != 0 )
  {
    png_warning(png_ptr, "Invalid tRNS after IDAT");
LABEL_13:
    png_crc_finish(png_ptr, param_3);
    return;
  }
  if ( param_2 && (*(_BYTE *)(param_2 + 8) & 0x10) != 0 )
  {
    png_warning(png_ptr, "Duplicate tRNS chunk");
    goto LABEL_13;
  }
  v4 = *((_BYTE *)png_ptr + 278);
  if ( v4 == 3 )
  {
    if ( (*((_BYTE *)png_ptr + 88) & 2) != 0 )
    {
      if ( param_3 > *((unsigned __int16 *)png_ptr + 132) )
      {
        png_warning(png_ptr, "Incorrect tRNS chunk length");
        png_crc_finish(png_ptr, param_3);
        return;
      }
    }
    else
    {
      png_warning(png_ptr, "Missing PLTE before tRNS");
    }
    if ( !param_3 )
    {
      png_warning(png_ptr, "Zero length tRNS chunk");
      png_crc_finish(png_ptr, 0);
      return;
    }
    v5 = (unsigned __int8 *)png_malloc(png_ptr, param_3);
    *((_BYTE *)png_ptr + 93) |= 0x20u;
    *((_DWORD *)png_ptr + 87) = v5;
    png_crc_read(png_ptr, v5, param_3);
    *((_WORD *)png_ptr + 133) = param_3;
    goto LABEL_25;
  }
  if ( v4 != 2 )
  {
    if ( v4 )
    {
      png_warning(png_ptr, "tRNS chunk not allowed with alpha channel");
      goto LABEL_28;
    }
    if ( param_3 == 2 )
    {
      png_crc_read(png_ptr, buf, 2u);
      *((_WORD *)png_ptr + 180) = buf[1] + (buf[0] << 8);
      goto LABEL_24;
    }
LABEL_22:
    png_warning(png_ptr, "Incorrect tRNS chunk length");
LABEL_28:
    png_crc_finish(png_ptr, param_3);
    return;
  }
  if ( param_3 != 6 )
    goto LABEL_22;
  png_crc_read(png_ptr, buf, 6u);
  v6 = buf[3];
  *((_WORD *)png_ptr + 177) = buf[1] + (buf[0] << 8);
  v7 = v6 + (buf[2] << 8);
  v8 = v11;
  *((_WORD *)png_ptr + 178) = v7;
  *((_WORD *)png_ptr + 179) = v8 + (v10 << 8);
LABEL_24:
  *((_WORD *)png_ptr + 133) = 1;
LABEL_25:
  if ( !png_crc_finish(png_ptr, 0) )
    sub_10020435(
      (int)png_ptr,
      param_2,
      *((_DWORD *)png_ptr + 87),
      *((unsigned __int16 *)png_ptr + 133),
      (int)png_ptr + 352);
}

// grim_png_read_chunk_generic @ 0x1002587E
void grim_png_read_chunk_generic(void *png_ptr, int param_2, unsigned int param_3)
{
  int v3; // eax

  png_check_chunk_name(png_ptr, (unsigned __int8 *)png_ptr + 268);
  if ( (*((_BYTE *)png_ptr + 268) & 0x20) == 0 )
    FUN_1001e147(png_ptr, (unsigned int *)"unknown critical chunk");
  v3 = *((_DWORD *)png_ptr + 22);
  if ( (v3 & 4) != 0 )
    *((_DWORD *)png_ptr + 22) = v3 | 8;
  png_crc_finish(png_ptr, param_3);
}

// sub_100258C8 @ 0x100258C8
int __cdecl sub_100258C8(jmp_buf Buf)
{
  int *__attribute__((__org_typedef(jmp_buf))) v1; // esi
  int result; // eax
  unsigned __int8 v3; // bl
  unsigned int v4; // edx
  bool v5; // zf
  unsigned int v6; // eax
  unsigned int v7; // edx
  unsigned __int8 *v8; // ecx
  int v9; // eax
  char *v10; // eax
  unsigned __int8 data[4]; // [esp+4h] [ebp-4h] BYREF

  v1 = Buf;
  result = (int)(Buf + 53);
  ++Buf[53];
  if ( *(_DWORD *)result >= (unsigned int)v1[48] )
  {
    if ( *((_BYTE *)v1 + 275) )
    {
      *(_DWORD *)result = 0;
      FUN_100247b3((int)v1, v1[54], 0);
      while ( 1 )
      {
        v3 = ++*((_BYTE *)v1 + 276);
        if ( v3 >= 7u )
          break;
        result = (v1[46] - dword_1004EA90[v3] + dword_1004EAAC[v3] - 1) / (unsigned int)dword_1004EAAC[v3];
        v4 = ((result * (unsigned int)*((unsigned __int8 *)v1 + 281) + 7) >> 3) + 1;
        v5 = (v1[24] & 2) == 0;
        v1[52] = result;
        v1[51] = v4;
        if ( v5 )
        {
          result = (v1[47] - dword_1004EAC8[v3] + dword_1004EAE4[v3] - 1) / (unsigned int)dword_1004EAE4[v3];
          v5 = v1[52] == 0;
          v1[48] = result;
          if ( v5 )
            continue;
        }
        return result;
      }
    }
    if ( (v1[23] & 0x20) == 0 )
    {
      v1[28] = (int)&Buf;
      v1[29] = 1;
      while ( 1 )
      {
        if ( !v1[26] )
        {
          while ( !v1[63] )
          {
            png_crc_finish(v1, 0);
            png_read_data(v1, data, 4u);
            v1[63] = png_get_uint_32(data);
            png_reset_crc(v1);
            png_crc_read(v1, (unsigned __int8 *)v1 + 268, 4u);
            if ( v1[67] != *(_DWORD *)"IDAT" )
              png_error(v1, "Not enough image data");
          }
          v6 = v1[40];
          v7 = v1[63];
          v8 = (unsigned __int8 *)v1[39];
          v1[26] = v6;
          v1[25] = (int)v8;
          if ( v6 > v7 )
            v1[26] = v7;
          png_crc_read(v1, v8, v1[26]);
          v1[63] -= v1[26];
        }
        v9 = inflate(v1 + 25, 1);
        if ( v9 == 1 )
          break;
        if ( v9 )
        {
          v10 = (char *)v1[31];
          if ( !v10 )
            v10 = "Decompression Error";
          png_error(v1, v10);
        }
        if ( !v1[29] )
          png_error(v1, "Extra compressed data");
      }
      if ( !v1[29] || v1[26] || v1[63] )
        png_error(v1, "Extra compressed data");
      v1[22] |= 8u;
      v1[23] |= 0x20u;
      v1[29] = 0;
    }
    if ( v1[63] || v1[26] )
      png_error(v1, "Extra compression data");
    result = inflateReset(v1 + 25);
    v1[22] |= 8u;
  }
  return result;
}

// sub_10025AEC @ 0x10025AEC
int __cdecl sub_10025AEC(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edx
  unsigned int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // esi
  _BYTE *v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // esi

  v3 = a2;
  if ( !a2 )
    return 0;
  v5 = ~a1;
  if ( a3 >= 8 )
  {
    v6 = a3 >> 3;
    do
    {
      a3 -= 8;
      v7 = (v5 >> 8) ^ dword_1004EF90[(unsigned __int8)(v5 ^ *v3)];
      v8 = v3 + 1;
      v9 = (v7 >> 8) ^ dword_1004EF90[(unsigned __int8)(v7 ^ *v8++)];
      v10 = (v9 >> 8) ^ dword_1004EF90[(unsigned __int8)(v9 ^ *v8++)];
      v11 = (v10 >> 8) ^ dword_1004EF90[(unsigned __int8)(v10 ^ *v8++)];
      v12 = (v11 >> 8) ^ dword_1004EF90[(unsigned __int8)(v11 ^ *v8++)];
      v13 = (v12 >> 8) ^ dword_1004EF90[(unsigned __int8)(v12 ^ *v8++)];
      v14 = (v13 >> 8) ^ dword_1004EF90[(unsigned __int8)(v13 ^ *v8++)];
      v5 = dword_1004EF90[(unsigned __int8)(v14 ^ *v8)] ^ (v14 >> 8);
      v3 = v8 + 1;
      --v6;
    }
    while ( v6 );
  }
  for ( ; a3; --a3 )
    v5 = dword_1004EF90[(unsigned __int8)(v5 ^ *v3++)] ^ (v5 >> 8);
  return ~v5;
}

// sub_10025C00 @ 0x10025C00
__m128 *__stdcall sub_10025C00(__m128 *a1, unsigned int *a2, __m128 *a3)
{
  *a1 = _mm_add_ps(
          _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3), a3[3]),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1]));
  return a1;
}

// sub_10025C40 @ 0x10025C40
double *__stdcall sub_10025C40(double *a1, unsigned int *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm1

  v3 = _mm_add_ps(
         _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3), a3[3]),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1]));
  v4 = _mm_rcp_ps(v3);
  v5 = _mm_mul_ps(_mm_mul_ps(v4, v4), v3);
  _mm_storel_ps(a1, _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 255)));
  return a1;
}

// sub_10025CA0 @ 0x10025CA0
double *__stdcall sub_10025CA0(double *a1, unsigned int *a2, __m128 *a3)
{
  _mm_storel_ps(
    a1,
    _mm_add_ps(
      _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3),
      _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1])));
  return a1;
}

// sub_10025CE0 @ 0x10025CE0
void __stdcall sub_10025CE0(int a1, int a2, int a3)
{
  JUMPOUT(0x10025CF1);
}

// sub_10025CEE @ 0x10025CEE
double *__stdcall sub_10025CEE(double *a1, unsigned int *a2, const double *a3)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm4
  __m128 v10; // xmm5
  __m128 v11; // xmm6
  __m128 v12; // xmm7
  __m128 v13; // xmm2
  __m128 v14; // xmm1
  __m128 v15; // xmm7

  v5 = _mm_loadh_ps(a3 + 1);
  v6 = _mm_loadh_ps(a3 + 3);
  v7 = _mm_loadh_ps(a3 + 5);
  v8 = _mm_loadh_ps(a3 + 7);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), v5),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v6)),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v7)),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[3], (__m128)a2[3], 0), v8));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[7], (__m128)a2[7], 0), v8));
  v11 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[8], (__m128)a2[8], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v8));
  v12 = _mm_add_ps(
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[12], (__m128)a2[12], 0), v5),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), v6));
  v13 = _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v7);
  v14 = (__m128)a2[15];
  _mm_storel_ps(a1, v9);
  _mm_storeh_ps(a1 + 1, v9);
  _mm_storel_ps(a1 + 2, v10);
  _mm_storeh_ps(a1 + 3, v10);
  _mm_storel_ps(a1 + 4, v11);
  _mm_storeh_ps(a1 + 5, v11);
  v15 = _mm_add_ps(_mm_add_ps(v12, v13), _mm_mul_ps(_mm_shuffle_ps(v14, v14, 0), v8));
  _mm_storel_ps(a1 + 6, v15);
  _mm_storeh_ps(a1 + 7, v15);
  return a1;
}

// sub_10025E30 @ 0x10025E30
void __stdcall sub_10025E30(int a1, int a2)
{
  JUMPOUT(0x10025E41);
}

// sub_10025E3E @ 0x10025E3E
float *__stdcall sub_10025E3E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm6_4
  float v4; // xmm5_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E000 <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E004 * v6)
       * (float)(*(float *)&dword_1005E008
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
  }
  return result;
}

// sub_10025F00 @ 0x10025F00
void __stdcall sub_10025F00(int a1, int a2)
{
  JUMPOUT(0x10025F11);
}

// sub_10025F0E @ 0x10025F0E
float *__stdcall sub_10025F0E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm4_4
  float v4; // xmm6_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E00C <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E010 * v6)
       * (float)(*(float *)&dword_1005E014
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
    a1[3] = v7 * a2[3];
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    a1[3] = 0.0;
  }
  return result;
}

// sub_10025FE0 @ 0x10025FE0
void __stdcall sub_10025FE0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10025FF1);
}

// sub_10025FEE @ 0x10025FEE
__m128 *__stdcall sub_10025FEE(__m128 *a1, int a2, int a3, int a4)
{
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm3
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm4
  __m128 v12; // xmm2
  __m128 v13; // xmm3
  __m128 v14; // xmm1

  v5 = _mm_loadh_ps((const double *)(a3 + 8));
  v6 = _mm_shuffle_ps(v5, v5, 57);
  v7 = _mm_loadh_ps((const double *)(a2 + 8));
  v8 = _mm_loadh_ps((const double *)(a4 + 8));
  v9 = _mm_shuffle_ps(v8, v8, 78);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 57), v6);
  v11 = _mm_mul_ps(v9, v6);
  v12 = _mm_mul_ps(v6, v8);
  v13 = _mm_shuffle_ps(v7, v7, 57);
  v14 = _mm_shuffle_ps(v13, v13, 57);
  *a1 = _mm_xor_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v13, _mm_sub_ps(_mm_shuffle_ps(v11, v11, 57), _mm_shuffle_ps(v12, v12, 78))),
              _mm_mul_ps(_mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10), v14)),
            _mm_mul_ps(_mm_shuffle_ps(v14, v14, 57), _mm_sub_ps(v11, _mm_shuffle_ps(v12, v12, 57)))),
          (__m128)xmmword_10055500);
  return a1;
}

// sub_10026090 @ 0x10026090
float *__stdcall sub_10026090(float *a1, float *a2)
{
  float v2; // xmm1_4
  float v3; // xmm2_4
  float v4; // xmm3_4
  float v5; // xmm4_4
  float v6; // xmm6_4
  float v7; // xmm5_4

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = (float)((float)(*a2 * *a2) + (float)(v2 * v2)) + (float)((float)(v3 * v3) + (float)(v4 * v4));
  v6 = 1.0 / fsqrt(v5);
  v7 = (float)((float)(*(float *)&dword_10055520 - (float)(v5 * (float)(v6 * v6))) * *(float *)&dword_10055510) * v6;
  *a1 = *a2 * v7;
  a1[1] = v2 * v7;
  a1[2] = v3 * v7;
  a1[3] = v4 * v7;
  return a1;
}

// sub_10026130 @ 0x10026130
int __userpurge sub_10026130@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        int a3,
        const double *a4,
        const double *a5,
        const double *a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps(a4), _mm_shuffle_ps(v9, v9, 0)),
              _mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v9, v9, 85))),
            _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v9, v9, 170))),
          _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v9, v9, 255)));
  _mm_storeh_ps((double *)a3, v10);
  *(_DWORD *)(a3 + 8) = v10.m128_i32[0];
  return a3;
}

// sub_100261F0 @ 0x100261F0
double *__userpurge sub_100261F0@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        double *a3,
        int a4,
        const double *a5,
        int a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm6
  __m128 v11; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  v10 = _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v9, v9, 250));
  v11 = _mm_add_ps(_mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v9, v9, 80)), v10);
  _mm_storel_ps(a3, _mm_add_ps(v11, _mm_movehl_ps(v10, v11)));
  return a3;
}

// sub_10026280 @ 0x10026280
__m128 *__userpurge sub_10026280@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 *a3,
        __m128 *a4,
        __m128 *a5,
        __m128 *a6,
        __m128 *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  *a3 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(*a4, _mm_shuffle_ps(v9, v9, 0)), _mm_mul_ps(*a5, _mm_shuffle_ps(v9, v9, 85))),
            _mm_mul_ps(*a6, _mm_shuffle_ps(v9, v9, 170))),
          _mm_mul_ps(*a7, _mm_shuffle_ps(v9, v9, 255)));
  return a3;
}

// sub_10026330 @ 0x10026330
int __userpurge sub_10026330@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        int a3,
        const double *a4,
        const double *a5,
        const double *a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm0
  __m128 v11; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_100555A0);
  v9.m128_f32[0] = v9.m128_f32[0] + *(float *)&dword_10055580;
  v10 = _mm_add_ps(
          _mm_add_ps(v9, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  v11 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps(a4), _mm_shuffle_ps(v10, v10, 0)),
              _mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v10, v10, 85))),
            _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v10, v10, 170))),
          _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v10, v10, 255)));
  _mm_storeh_ps((double *)a3, v11);
  *(_DWORD *)(a3 + 8) = v11.m128_i32[0];
  return a3;
}

// sub_100263F0 @ 0x100263F0
__m128 *__userpurge sub_100263F0@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 *a3,
        __m128 *a4,
        __m128 *a5,
        __m128 *a6,
        __m128 *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm0

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_100555A0);
  v9.m128_f32[0] = v9.m128_f32[0] + *(float *)&dword_10055580;
  v10 = _mm_add_ps(
          _mm_add_ps(v9, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  *a3 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(*a4, _mm_shuffle_ps(v10, v10, 0)), _mm_mul_ps(*a5, _mm_shuffle_ps(v10, v10, 85))),
            _mm_mul_ps(*a6, _mm_shuffle_ps(v10, v10, 170))),
          _mm_mul_ps(*a7, _mm_shuffle_ps(v10, v10, 255)));
  return a3;
}

// sub_10026490 @ 0x10026490
double *__userpurge sub_10026490@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 a3@<xmm3>,
        double *a4,
        int a5,
        const double *a6,
        int a7,
        const double *a8,
        float a9)
{
  __m128 v9; // xmm0
  __m128 v10; // xmm0
  __m128 v11; // xmm0
  __m128 v12; // xmm4

  v9 = (__m128)LODWORD(a9);
  a1.m128_f32[0] = v9.m128_f32[0] * v9.m128_f32[0];
  a2.m128_f32[0] = a9 * (float)(v9.m128_f32[0] * v9.m128_f32[0]);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), (__m128)xmmword_100555A0);
  v10.m128_f32[0] = v10.m128_f32[0] + *(float *)&dword_10055580;
  v11 = _mm_add_ps(
          _mm_add_ps(v10, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  v12 = _mm_add_ps(
          _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v11, v11, 80)),
          _mm_mul_ps(_mm_loadh_ps(a8), _mm_shuffle_ps(v11, v11, 250)));
  _mm_storel_ps(a4, _mm_add_ps(v12, _mm_movehl_ps(a3, v12)));
  return a4;
}

// sub_10026520 @ 0x10026520
int __stdcall sub_10026520(
        int a1,
        const double *a2,
        const double *a3,
        const double *a4,
        unsigned int a5,
        unsigned int a6)
{
  __m128 v6; // xmm2
  __m128 v7; // xmm3

  v6 = _mm_loadh_ps(a2);
  v7 = _mm_add_ps(
         _mm_add_ps(_mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a3), v6), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), v6),
         _mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a4), v6), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0)));
  *(_DWORD *)(a1 + 8) = v7.m128_i32[0];
  _mm_storeh_ps((double *)a1, v7);
  return a1;
}

// sub_10026580 @ 0x10026580
__m128 *__stdcall sub_10026580(__m128 *a1, __m128 *a2, __m128 *a3, __m128 *a4, unsigned int a5, unsigned int a6)
{
  *a1 = _mm_add_ps(
          _mm_add_ps(_mm_mul_ps(_mm_sub_ps(*a3, *a2), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), *a2),
          _mm_mul_ps(_mm_sub_ps(*a4, *a2), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0)));
  return a1;
}

// sub_100265D0 @ 0x100265D0
double *__stdcall sub_100265D0(
        double *a1,
        const double *a2,
        const double *a3,
        const double *a4,
        unsigned int a5,
        unsigned int a6)
{
  __m128 v6; // xmm2

  v6 = _mm_loadh_ps(a2);
  _mm_storeh_ps(
    a1,
    _mm_add_ps(
      _mm_add_ps(_mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a3), v6), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), v6),
      _mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a4), v6), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0))));
  return a1;
}

// sub_10026630 @ 0x10026630
int __userpurge sub_10026630@<eax>(
        __m128 a1@<xmm5>,
        __m128 a2@<xmm6>,
        int a3,
        __m128 *a4,
        const double *a5,
        const double *a6)
{
  __m128 v6; // xmm1
  __m128 v7; // xmm4
  __m128 v8; // xmm0
  __m128 v9; // xmm2
  __m128 v10; // xmm3
  __m128 v11; // xmm0
  __m128 v12; // xmm5
  __m128 v13; // xmm6
  __m128 v14; // xmm0
  float v15; // xmm5_4
  __m128 v16; // xmm3
  __m128 v17; // xmm1
  int v19; // [esp+0h] [ebp-4h]

  v19 = a3;
  v6 = _mm_loadh_ps(a5);
  v7 = *a4;
  v8 = _mm_shuffle_ps(v7, v7, 78);
  v9 = _mm_loadh_ps(a6);
  v10 = _mm_mul_ps(v6, v8);
  v11 = _mm_mul_ps(v8, v9);
  v12 = _mm_movehl_ps(a1, v10);
  v13 = _mm_movehl_ps(a2, v11);
  v16 = _mm_add_ps(v10, v12);
  v14 = _mm_add_ps(v11, v13);
  v16.m128_f32[0] = v16.m128_f32[0] + _mm_shuffle_ps(v12, v16, 85).m128_f32[0];
  v15 = v16.m128_f32[0] - (float)(v14.m128_f32[0] + _mm_shuffle_ps(v13, v14, 85).m128_f32[0]);
  v16.m128_f32[0] = v16.m128_f32[0] + _mm_shuffle_ps(v7, v7, 255).m128_f32[0];
  if ( v15 == *(float *)&dword_1005DB80 )
    return 0;
  v16.m128_f32[0] = v16.m128_f32[0]
                  * (float)((float)((float)(1.0 / v15) + (float)(1.0 / v15))
                          - (float)((float)(v15 * (float)(1.0 / v15)) * (float)(1.0 / v15)));
  v17 = _mm_add_ps(v6, _mm_mul_ps(_mm_shuffle_ps(v16, v16, 0), _mm_sub_ps(v9, v6)));
  _mm_storeh_ps((double *)a3, v17);
  *(_DWORD *)(a3 + 8) = v17.m128_i32[0];
  return v19;
}

// sub_100266F0 @ 0x100266F0
void __stdcall sub_100266F0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10026701);
}

// sub_100266FE @ 0x100266FE
__m128 *__stdcall sub_100266FE(__m128 *a1, const double *a2, const double *a3, const double *a4)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  __m128 v8; // xmm4
  __m128 v9; // xmm5
  __m128 v10; // xmm3
  __m128 v11; // xmm5
  __m128 v12; // xmm1
  __m128 v13; // xmm3
  __m128 v14; // xmm5
  __m128 v15; // xmm0
  __m128 v16; // xmm5
  __m128 v17; // xmm3
  __m128 v18; // xmm0

  v5 = _mm_loadh_ps(a2);
  v6 = _mm_sub_ps(v5, _mm_loadh_ps(a4));
  v7 = _mm_shuffle_ps(v6, v6, 120);
  v8 = v5;
  v9 = _mm_sub_ps(v5, _mm_loadh_ps(a3));
  v10 = _mm_shuffle_ps(v9, v9, 99);
  v11 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 120), _mm_shuffle_ps(v6, v6, 99));
  v12 = (__m128)xmmword_100555D0;
  v13 = _mm_sub_ps(_mm_mul_ps(v7, v10), v11);
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = v15;
  v15.m128_f32[0] = fsqrt(v15.m128_f32[0]);
  v12.m128_f32[0] = (float)(*(float *)&xmmword_100555D0 * (float)(1.0 / v15.m128_f32[0]))
                  * (float)(*(float *)&xmmword_100555C0
                          - (float)((float)(v16.m128_f32[0] * (float)(1.0 / v15.m128_f32[0]))
                                  * (float)(1.0 / v15.m128_f32[0])));
  v17 = _mm_mul_ps(v13, _mm_shuffle_ps(v12, v12, 0));
  *a1 = v17;
  v18 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 14), v17);
  a1->m128_i32[3] = COERCE_UNSIGNED_INT(
                      v18.m128_f32[0]
                    + (float)(_mm_movehl_ps(v16, v18).m128_f32[0] + _mm_shuffle_ps(v18, v18, 85).m128_f32[0]))
                  ^ xmmword_100555B0;
  return a1;
}

// sub_100267E0 @ 0x100267E0
void __stdcall sub_100267E0(int a1, int a2, int a3)
{
  JUMPOUT(0x100267F1);
}

// sub_100267EE @ 0x100267EE
double *__stdcall sub_100267EE(double *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  char v8; // al
  __m128 v9; // xmm4
  float v10; // xmm3_4
  float v11; // xmm5_4
  double *result; // eax
  __m128 v13; // xmm4
  __m128 v14; // xmm0
  __m128 v15; // xmm0
  __m128 v16; // xmm0
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  float v19; // xmm7_4
  __m128 v20; // xmm0
  __m128 v21; // xmm1
  __m128 v22; // xmm2
  __m128 v23; // xmm3

  v3 = *a3;
  v4 = _mm_and_ps((__m128)xmmword_10055620, *a3);
  v5 = _mm_mul_ps(v4, v4);
  v6 = _mm_add_ps(v5, _mm_movehl_ps((__m128)0LL, v5));
  v7 = _mm_shuffle_ps(v6, v6, 1);
  v7.m128_f32[0] = v7.m128_f32[0] + v6.m128_f32[0];
  if ( v7.m128_f32[0] != 0.0 )
  {
    v8 = byte_1005DBF0;
    if ( (byte_1005DBF0 & 1) != 0 )
    {
      v9 = (__m128)xmmword_1005DBD0;
    }
    else
    {
      v8 = byte_1005DBF0 | 1;
      v9 = (__m128)(unsigned int)dword_1005E0C0;
      byte_1005DBF0 |= 1u;
      xmmword_1005DBD0 = (unsigned int)dword_1005E0C0;
    }
    if ( (v8 & 2) != 0 )
    {
      v10 = *(float *)&xmmword_1005DBE0;
    }
    else
    {
      v10 = *(float *)&dword_1005E0C4;
      byte_1005DBF0 = v8 | 2;
      xmmword_1005DBE0 = (unsigned int)dword_1005E0C4;
    }
    v11 = 1.0 / fsqrt(v7.m128_f32[0]);
    v9.m128_f32[0] = (float)(v9.m128_f32[0] * v11) * (float)(v10 - (float)((float)(v7.m128_f32[0] * v11) * v11));
    v7 = _mm_mul_ps(v3, _mm_shuffle_ps(v9, v9, 0));
  }
  result = a1;
  v13 = _mm_xor_ps((__m128)xmmword_100555E0, v7);
  v14 = _mm_mul_ps(v7, *a2);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v6, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = _mm_shuffle_ps(v15, v15, 0);
  v17 = _mm_and_ps((__m128)xmmword_10055600, v16);
  v18 = _mm_and_ps((__m128)xmmword_10055610, v16);
  v19 = v16.m128_f32[0];
  v20 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 85), *a2), _mm_and_ps((__m128)xmmword_100555F0, v16));
  v21 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), *a2), v17);
  v23 = _mm_mul_ps(_mm_shuffle_ps(v13, v13, 0), *a2);
  v22 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 255), *a2), v18);
  v23.m128_f32[0] = v23.m128_f32[0] + v19;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    _mm_storel_ps(a1, v23);
    _mm_storeh_ps(a1 + 1, v23);
    _mm_storel_ps(a1 + 2, v20);
    _mm_storeh_ps(a1 + 3, v20);
    _mm_storel_ps(a1 + 4, v21);
    _mm_storeh_ps(a1 + 5, v21);
    _mm_storel_ps(a1 + 6, v22);
    _mm_storeh_ps(a1 + 7, v22);
  }
  else
  {
    *(__m128 *)a1 = v23;
    *((__m128 *)a1 + 1) = v20;
    *((__m128 *)a1 + 2) = v21;
    *((__m128 *)a1 + 3) = v22;
  }
  return result;
}

// sub_10026970 @ 0x10026970
void __stdcall sub_10026970(int a1, int a2)
{
  JUMPOUT(0x10026981);
}

// sub_1002697E @ 0x1002697E
__m128 *__stdcall sub_1002697E(__m128 *a1, const double *a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm0
  __m128 v5; // xmm3
  __m128 v6; // xmm4
  __m128 v7; // xmm0
  float v8; // xmm5_4
  __m128 v9; // xmm1
  __m128 v10; // xmm4
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm2
  __m128 v14; // xmm0
  __m128 v15; // xmm3
  __m128 v16; // xmm2
  __m128 v17; // xmm4

  v3 = _mm_loadl_ps(a2);
  v4 = _mm_and_ps((__m128)xmmword_100556A0, v3);
  v5 = (__m128)(unsigned int)dword_10055690;
  v6 = _mm_mul_ps(v4, v4);
  v7 = _mm_add_ps(v6, _mm_movehl_ps(v6, v6));
  v8 = v7.m128_f32[0] + _mm_shuffle_ps(v7, v7, 1).m128_f32[0];
  v7.m128_f32[0] = 1.0 / fsqrt(v8);
  v5.m128_f32[0] = (float)(*(float *)&dword_10055690 * v7.m128_f32[0])
                 * (float)(*(float *)&dword_10055680 - (float)((float)(v8 * v7.m128_f32[0]) * v7.m128_f32[0]));
  v9 = _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 0));
  v10 = _mm_mul_ps((__m128)xmmword_10055670, v9);
  v11 = v9;
  v12 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), v10), (__m128)xmmword_10055660);
  v13 = v11;
  v14 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v11, v11, 255), v10), (__m128)xmmword_10055630);
  v15 = v13;
  v16 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), v10), (__m128)xmmword_10055640);
  v17 = _mm_add_ps(_mm_mul_ps(v10, _mm_shuffle_ps(v15, v15, 85)), (__m128)xmmword_10055650);
  *a1 = v12;
  a1[1] = v17;
  a1[2] = v16;
  a1[3] = v14;
  return a1;
}

// sub_10026A50 @ 0x10026A50
double *__stdcall sub_10026A50(double *a1, int a2, int a3)
{
  __m128 v3; // xmm0
  __m128 v4; // xmm2
  __m128 v5; // xmm1
  __m128 v6; // xmm0
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm1

  v3 = _mm_loadh_ps((const double *)(a2 + 8));
  v4 = _mm_loadh_ps((const double *)(a3 + 8));
  v5 = _mm_mul_ps(_mm_shuffle_ps(v4, v4, 255), v3);
  v6 = _mm_shuffle_ps(v3, v3, 27);
  v7 = _mm_add_ps(v5, _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 0), (__m128)xmmword_1005E100), v6));
  v8 = _mm_shuffle_ps(v6, v6, 177);
  v9 = _mm_add_ps(
         _mm_add_ps(v7, _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 85), (__m128)xmmword_1005E0F0), v8)),
         _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 170), (__m128)xmmword_1005E0E0), _mm_shuffle_ps(v8, v8, 27)));
  _mm_storel_ps(a1, v9);
  _mm_storeh_ps(a1 + 1, v9);
  return a1;
}

// sub_10026AE0 @ 0x10026AE0
float *__stdcall sub_10026AE0(float *a1, float *a2)
{
  float v2; // xmm1_4
  float v3; // xmm2_4
  float v4; // xmm3_4
  float v5; // xmm4_4
  float v6; // xmm6_4
  float v7; // xmm5_4

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = (float)((float)(*a2 * *a2) + (float)(v2 * v2)) + (float)((float)(v3 * v3) + (float)(v4 * v4));
  v6 = 1.0 / fsqrt(v5);
  v7 = (float)((float)(*(float *)&dword_100556D0 - (float)(v5 * (float)(v6 * v6))) * *(float *)&dword_100556C0) * v6;
  *a1 = *a2 * v7;
  a1[1] = v2 * v7;
  a1[2] = v3 * v7;
  a1[3] = v4 * v7;
  return a1;
}

// sub_10026B80 @ 0x10026B80
void __stdcall sub_10026B80(int a1, int a2)
{
  JUMPOUT(0x10026B91);
}

// sub_10026B8E @ 0x10026B8E
__m128 *__stdcall sub_10026B8E(__m128 *a1, int a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm2
  __m128 v5; // xmm0
  __m128 v6; // xmm3

  v3 = _mm_loadh_ps((const double *)(a2 + 8));
  v4 = _mm_mul_ps(v3, v3);
  v5 = _mm_add_ps(v4, _mm_movehl_ps(v4, v4));
  v4.m128_f32[0] = v5.m128_f32[0] + _mm_shuffle_ps(v5, v5, 85).m128_f32[0];
  v5.m128_f32[0] = 1.0 / v4.m128_f32[0];
  v6 = v5;
  v6.m128_f32[0] = (float)(v6.m128_f32[0] + v6.m128_f32[0])
                 - (float)((float)(v5.m128_f32[0] * v4.m128_f32[0]) * v5.m128_f32[0]);
  *a1 = _mm_mul_ps(_mm_mul_ps(v3, (__m128)xmmword_100556E0), _mm_shuffle_ps(v6, v6, 0));
  return a1;
}

// sub_10026BF0 @ 0x10026BF0
float *__stdcall sub_10026BF0(float *a1, float *a2)
{
  float *result; // eax
  double v3; // st7
  float v4; // edi
  float v5; // esi
  int v6; // ebp
  double v7; // st7
  int v8; // ecx
  int v9; // ebx
  int v10; // ebp
  float *v11; // esi
  long double v12; // st6
  long double v13; // st7
  float *v14; // ecx
  long double v15; // st6
  long double v16; // st7
  _DWORD v17[7]; // [esp+0h] [ebp-1Ch]

  result = a1;
  v3 = *a2 + a2[5] + a2[10];
  v4 = *a2;
  v5 = a2[5];
  v6 = *((_DWORD *)a2 + 10);
  if ( flt_1005E11C < v3 )
  {
    v15 = sqrt(v3 + flt_1005E120) * flt_1005E124;
    v16 = flt_1005E128 / v15;
    a1[3] = v15;
    *a1 = (a2[6] - a2[9]) * v16;
    a1[1] = (a2[8] - a2[2]) * v16;
    a1[2] = v16 * (a2[1] - a2[4]);
  }
  else
  {
    v7 = a2[10];
    *(float *)v17 = *a2;
    *(float *)&v17[1] = v5;
    v17[2] = v6;
    v8 = 2;
    if ( *(float *)&v17[v5 > (double)v4] >= v7 )
      v8 = v5 > (double)v4;
    v9 = dword_1005E110[v8];
    v10 = dword_1005E110[v9];
    v11 = &a2[v8];
    v12 = sqrt(flt_1005E130 + *(float *)&v17[v8] - *(float *)&v17[v9] - *(float *)&v17[v10]) * flt_1005E134;
    v13 = flt_1005E138 / v12;
    a1[v8] = v12;
    v14 = &a2[4 * v8];
    a1[v9] = (v14[v9] + v11[4 * v9]) * v13;
    a1[v10] = (v11[4 * v10] + v14[v10]) * v13;
    a1[3] = v13 * (a2[4 * v9 + v10] - a2[4 * v10 + v9]);
  }
  return result;
}

// sub_10026D10 @ 0x10026D10
void __stdcall sub_10026D10(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10026D21);
}

// sub_10026D1E @ 0x10026D1E
__m128 *__stdcall sub_10026D1E(__m128 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __m128 v4; // xmm0
  __m128 v5; // xmm1
  __m128 v6; // xmm3
  __m128 v7; // xmm2
  __m128 v8; // xmm3
  __m128 v10; // [esp+10h] [ebp-4Ch] BYREF
  __m128 v11[3]; // [esp+20h] [ebp-3Ch] BYREF

  v10 = _mm_mul_ps(
          _mm_shuffle_ps(
            _mm_unpacklo_ps((__m128)a3, (__m128)a4),
            _mm_unpacklo_ps((__m128)(unsigned int)dword_1005E160, (__m128)a2),
            17),
          (__m128)xmmword_1005E150);
  sub_10034900(&v10, &v10, v11);
  v4 = _mm_shuffle_ps(v10, v11[0], 0);
  v5 = _mm_shuffle_ps(v4, v4, 138);
  v6 = _mm_shuffle_ps(v10, v11[0], 153);
  v7 = _mm_shuffle_ps(v6, v6, 247);
  v8 = _mm_shuffle_ps(v6, v6, 168);
  v10 = _mm_add_ps(
          _mm_mul_ps(_mm_mul_ps(v5, v7), v8),
          _mm_xor_ps(
            _mm_mul_ps(_mm_mul_ps(_mm_shuffle_ps(v5, v5, 138), _mm_shuffle_ps(v7, v7, 81)), _mm_shuffle_ps(v8, v8, 1)),
            (__m128)xmmword_1005E140));
  *a1 = v10;
  return a1;
}

// sub_10026DE0 @ 0x10026DE0
void __stdcall sub_10026DE0(int a1, int a2, int a3)
{
  JUMPOUT(0x10026DF1);
}

// sub_10026DEE @ 0x10026DEE
int __stdcall sub_10026DEE(int a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v6; // xmm5
  __m128 v7; // xmm3

  if ( (a3 & 0xF) != 0 )
  {
    v6 = _mm_loadl_ps((const double *)a2);
    v7 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v6, v6, 0)),
             _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v6, v6, 85))),
           _mm_mul_ps(
             _mm_loadh_ps((const double *)(a3 + 40)),
             _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)));
    _mm_storel_ps((double *)a1, v7);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v7, v7).m128_u32[0];
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    v4 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
           _mm_mul_ps(
             _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
             *(__m128 *)(a3 + 32)));
    _mm_storel_ps((double *)a1, v4);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v4, v4).m128_u32[0];
  }
  return a1;
}

// sub_10026EA0 @ 0x10026EA0
void __stdcall sub_10026EA0(int a1, int a2, int a3)
{
  JUMPOUT(0x10026EB1);
}

// sub_10026EAE @ 0x10026EAE
__m128 *__stdcall sub_10026EAE(__m128 *a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v5; // xmm6

  if ( (a3 & 0xF) != 0 )
  {
    v5 = _mm_loadl_ps((const double *)a2);
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v5, v5, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v5, v5, 85))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_loadh_ps((const double *)(a3 + 40)),
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)),
              _mm_loadh_ps((const double *)(a3 + 56))));
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
              _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
                *(__m128 *)(a3 + 32)),
              *(__m128 *)(a3 + 48)));
  }
  return a1;
}

// sub_10026F60 @ 0x10026F60
void __stdcall sub_10026F60(int a1, int a2, int a3)
{
  JUMPOUT(0x10026F71);
}

// sub_10026F6E @ 0x10026F6E
int __stdcall sub_10026F6E(int a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm0
  __m128 v9; // xmm6
  __m128 v10; // xmm4
  __m128 v11; // xmm1
  __m128 v12; // xmm1
  __m128 v13; // xmm4

  if ( (a3 & 0xF) != 0 )
  {
    v9 = _mm_loadl_ps((const double *)a2);
    v10 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v9, v9, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v9, v9, 85))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_loadh_ps((const double *)(a3 + 40)),
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)),
              _mm_loadh_ps((const double *)(a3 + 56))));
    v11 = _mm_rcp_ps(v10);
    v12 = _mm_sub_ps(_mm_add_ps(v11, v11), _mm_mul_ps(_mm_mul_ps(v11, v10), v11));
    v13 = _mm_mul_ps(v10, _mm_shuffle_ps(v12, v12, 255));
    _mm_storel_ps((double *)a1, v13);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v13, v13).m128_u32[0];
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    v4 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
           _mm_add_ps(
             _mm_mul_ps(
               _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
               *(__m128 *)(a3 + 32)),
             *(__m128 *)(a3 + 48)));
    v5 = _mm_rcp_ps(v4);
    v6 = _mm_sub_ps(_mm_add_ps(v5, v5), _mm_mul_ps(_mm_mul_ps(v5, v4), v5));
    v7 = _mm_mul_ps(v4, _mm_shuffle_ps(v6, v6, 255));
    _mm_storel_ps((double *)a1, v7);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v7, v7).m128_u32[0];
  }
  return a1;
}

// sub_10027060 @ 0x10027060
void __stdcall sub_10027060(int a1, int a2, int a3)
{
  JUMPOUT(0x10027071);
}

// sub_1002706E @ 0x1002706E
__m128 *__stdcall sub_1002706E(__m128 *a1, __m128 *a2, int a3)
{
  if ( (a3 & 0xF) != 0 )
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(*a2, *a2, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(*a2, *a2, 85))),
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 40)), _mm_shuffle_ps(*a2, *a2, 170)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 56)), _mm_shuffle_ps(*a2, *a2, 255))));
  else
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 0), *(__m128 *)a3),
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 85), *(__m128 *)(a3 + 16))),
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 170), *(__m128 *)(a3 + 32)),
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 255), *(__m128 *)(a3 + 48))));
  return a1;
}

// sub_10027120 @ 0x10027120
void __stdcall sub_10027120(int a1, int a2)
{
  JUMPOUT(0x10027131);
}

// sub_1002712E @ 0x1002712E
float *__stdcall sub_1002712E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm6_4
  float v4; // xmm5_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E180 <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E184 * v6)
       * (float)(*(float *)&dword_1005E188
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
  }
  return result;
}

// sub_100271F0 @ 0x100271F0
void __stdcall sub_100271F0(int a1, int a2)
{
  JUMPOUT(0x10027201);
}

// sub_100271FE @ 0x100271FE
float *__stdcall sub_100271FE(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm4_4
  float v4; // xmm6_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E18C <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E190 * v6)
       * (float)(*(float *)&dword_1005E194
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
    a1[3] = v7 * a2[3];
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    a1[3] = 0.0;
  }
  return result;
}

// sub_100272D0 @ 0x100272D0
void __stdcall sub_100272D0(int a1, int a2, int a3)
{
  JUMPOUT(0x100272E1);
}

// sub_100272DE @ 0x100272DE
double *__stdcall sub_100272DE(double *a1, _DWORD *a2, const double *a3)
{
  __m128 v3; // xmm4
  __m128 v4; // xmm1
  __m128 v5; // xmm5
  __m128 v6; // xmm0
  __m128 v7; // xmm4
  __m128 v8; // xmm5
  __m128 v9; // xmm6
  __m128 v10; // xmm5
  __m128 v11; // xmm7
  __m128 v12; // xmm3
  __m128 v13; // xmm1
  __m128 v14; // xmm7
  __m128 v15; // xmm3
  __m128 v16; // xmm5
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  __m128 v19; // xmm3
  __m128 v20; // xmm5
  __m128 v21; // xmm6
  __m128 v22; // xmm3
  __m128 v23; // xmm7
  __m128 v24; // xmm7
  __m128 v25; // xmm5
  __m128 v26; // xmm0
  __m128 v27; // xmm6
  __m128 v28; // xmm7
  __m128 v29; // xmm4
  __m128 v30; // xmm0
  __m128 v31; // xmm7
  __m128 v32; // xmm5
  __m128 v33; // xmm6
  __m128 v34; // xmm1
  __m128 v35; // xmm1
  __m128 v36; // xmm0
  __m128 v37; // xmm5
  __m128 v38; // xmm6
  __m128 v39; // xmm3
  __m128 v40; // xmm3
  __m128 v41; // xmm5
  __m128 v42; // xmm7
  __m128 v43; // xmm3
  __m128 v44; // xmm6
  __m128 v45; // xmm4
  __m128 v46; // xmm0
  __m128 v47; // xmm4
  __m128 v48; // xmm3
  __m128 v49; // xmm0
  __m128 v50; // xmm4
  __m128 v51; // xmm6
  __m128 v52; // xmm2
  __m128 v53; // xmm0
  __m128 v55; // xmm5
  __m128 v56; // xmm5
  __m128 v57; // xmm1
  __m128 v58; // xmm4
  __m128 v59; // xmm6
  __m128 v60; // xmm5
  __m128 v61; // [esp+20h] [ebp-FCh]
  __m128 v62; // [esp+30h] [ebp-ECh]
  __m128 v63; // [esp+40h] [ebp-DCh]
  __m128 v64; // [esp+50h] [ebp-CCh]
  __m128 v65; // [esp+60h] [ebp-BCh]
  __m128 v66; // [esp+70h] [ebp-ACh]
  __m128 v67; // [esp+80h] [ebp-9Ch]
  __m128 v68; // [esp+90h] [ebp-8Ch]
  __m128 v69; // [esp+A0h] [ebp-7Ch]
  __m128 v70; // [esp+B0h] [ebp-6Ch]
  __m128 v71; // [esp+E0h] [ebp-3Ch]

  v3 = _mm_loadh_ps(a3 + 7);
  v4 = _mm_loadh_ps(a3 + 2);
  v5 = _mm_loadh_ps(a3 + 3);
  v6 = _mm_shuffle_ps(v5, v3, 136);
  v7 = _mm_shuffle_ps(v3, v5, 221);
  v8 = _mm_mul_ps(v7, v6);
  v9 = _mm_shuffle_ps(v8, v8, 177);
  v10 = _mm_shuffle_ps(v9, v9, 78);
  v11 = _mm_loadh_ps(a3 + 6);
  v12 = _mm_shuffle_ps(v11, v4, 221);
  v13 = _mm_shuffle_ps(v4, v11, 136);
  v14 = v12;
  v15 = _mm_mul_ps(v12, v10);
  v62 = _mm_mul_ps(v10, v13);
  v16 = _mm_mul_ps(v14, v6);
  v17 = _mm_shuffle_ps(v16, v16, 177);
  v63 = _mm_mul_ps(v9, v13);
  v18 = _mm_add_ps(_mm_mul_ps(v7, v17), _mm_sub_ps(v15, _mm_mul_ps(v14, v9)));
  v19 = v17;
  v20 = _mm_shuffle_ps(v17, v17, 78);
  v64 = _mm_mul_ps(v19, v13);
  v21 = _mm_sub_ps(v18, _mm_mul_ps(v7, v20));
  v22 = v14;
  v23 = _mm_mul_ps(_mm_shuffle_ps(v14, v14, 78), v7);
  v24 = _mm_shuffle_ps(v23, v23, 177);
  v65 = _mm_mul_ps(v20, v13);
  v25 = _mm_shuffle_ps(v6, v6, 78);
  v26 = _mm_add_ps(_mm_mul_ps(v25, v24), v21);
  v27 = v24;
  v28 = _mm_shuffle_ps(v24, v24, 78);
  v66 = v7;
  v29 = v25;
  v30 = _mm_sub_ps(v26, _mm_mul_ps(v25, v28));
  v31 = _mm_sub_ps(_mm_mul_ps(v28, v13), _mm_mul_ps(v27, v13));
  v32 = v13;
  v33 = _mm_mul_ps(v13, v30);
  v61 = v30;
  v34 = _mm_add_ps(_mm_shuffle_ps(v33, v33, 78), v33);
  v30.m128_i32[0] = v34.m128_i32[0];
  v35 = _mm_shuffle_ps(v34, v34, 177);
  v35.m128_f32[0] = v35.m128_f32[0] + v30.m128_f32[0];
  v36 = v32;
  v37 = _mm_mul_ps(v32, v22);
  v38 = _mm_shuffle_ps(v37, v37, 177);
  v67 = v29;
  v68 = v22;
  v39 = _mm_mul_ps(v66, v36);
  v40 = _mm_shuffle_ps(v39, v39, 177);
  v69 = _mm_shuffle_ps(v38, v38, 78);
  v70 = v38;
  v41 = _mm_add_ps(
          _mm_mul_ps(v68, v40),
          _mm_sub_ps(_mm_mul_ps(v66, v69), _mm_add_ps(_mm_mul_ps(v66, v38), _mm_shuffle_ps(v31, v31, 78))));
  v42 = v40;
  v43 = _mm_shuffle_ps(v40, v40, 78);
  v44 = _mm_sub_ps(v41, _mm_mul_ps(v68, v43));
  v45 = _mm_sub_ps(v62, v63);
  v46 = _mm_mul_ps(v36, v67);
  v47 = _mm_add_ps(_mm_sub_ps(_mm_shuffle_ps(v45, v45, 78), _mm_mul_ps(v42, v67)), _mm_mul_ps(v43, v67));
  v48 = _mm_shuffle_ps(v46, v46, 177);
  v49 = _mm_shuffle_ps(v48, v48, 78);
  v71 = v44;
  v50 = _mm_sub_ps(_mm_add_ps(v47, _mm_mul_ps(v66, v48)), _mm_mul_ps(v66, v49));
  v51 = _mm_sub_ps(v65, v64);
  v52 = _mm_add_ps(
          _mm_mul_ps(v68, v49),
          _mm_sub_ps(
            _mm_sub_ps(_mm_sub_ps(_mm_mul_ps(v70, v67), _mm_shuffle_ps(v51, v51, 78)), _mm_mul_ps(v67, v69)),
            _mm_mul_ps(v48, v68)));
  if ( v35.m128_f32[0] == 0.0 )
    return 0;
  if ( a2 )
    *a2 = v35.m128_i32[0];
  v53 = v35;
  v53.m128_f32[0] = 1.0 / v35.m128_f32[0];
  v55 = v53;
  v55.m128_f32[0] = (float)(v55.m128_f32[0] + v55.m128_f32[0])
                  - (float)(v35.m128_f32[0] * (float)(v53.m128_f32[0] * v53.m128_f32[0]));
  v56 = _mm_shuffle_ps(v55, v55, 0);
  v57 = _mm_mul_ps(v61, v56);
  _mm_storel_ps(a1, v57);
  _mm_storeh_ps(a1 + 1, v57);
  v58 = _mm_mul_ps(v50, v56);
  _mm_storel_ps(a1 + 2, v58);
  _mm_storeh_ps(a1 + 3, v58);
  v59 = _mm_mul_ps(v71, v56);
  _mm_storel_ps(a1 + 4, v59);
  _mm_storeh_ps(a1 + 5, v59);
  v60 = _mm_mul_ps(v56, v52);
  _mm_storel_ps(a1 + 6, v60);
  _mm_storeh_ps(a1 + 7, v60);
  return a1;
}

// sub_10027590 @ 0x10027590
void __stdcall sub_10027590(int a1, int a2, int a3)
{
  JUMPOUT(0x100275A1);
}

// sub_1002759E @ 0x1002759E
double *__stdcall sub_1002759E(double *a1, unsigned int *a2, const double *a3)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm5
  __m128 v10; // xmm7
  __m128 v11; // xmm4
  __m128 v12; // xmm7
  __m128 v13; // xmm6
  __m128 v14; // xmm5
  __m128 v15; // xmm2
  __m128 v16; // xmm1
  __m128 v17; // xmm5
  __m128 v18; // xmm0
  __m128 v19; // xmm6
  __m128 v20; // xmm0

  v5 = _mm_loadh_ps(a3 + 1);
  v6 = _mm_loadh_ps(a3 + 3);
  v7 = _mm_loadh_ps(a3 + 5);
  v8 = _mm_loadh_ps(a3 + 7);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), v5),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v6)),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v7)),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[7], (__m128)a2[7], 0), v8));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[3], (__m128)a2[3], 0), v8));
  v11 = _mm_unpacklo_ps(v10, v9);
  v12 = _mm_unpackhi_ps(v10, v9);
  v13 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[8], (__m128)a2[8], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v8));
  v14 = _mm_add_ps(
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[12], (__m128)a2[12], 0), v5),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), v6));
  v15 = _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v7);
  v16 = (__m128)a2[15];
  _mm_storel_ps(a1, v11);
  v17 = _mm_add_ps(_mm_add_ps(v14, v15), _mm_mul_ps(_mm_shuffle_ps(v16, v16, 0), v8));
  _mm_storeh_ps(a1 + 2, v11);
  _mm_storel_ps(a1 + 4, v12);
  _mm_storeh_ps(a1 + 6, v12);
  v18 = v13;
  v19 = _mm_unpacklo_ps(v13, v17);
  _mm_storel_ps(a1 + 1, v19);
  _mm_storeh_ps(a1 + 3, v19);
  v20 = _mm_unpackhi_ps(v18, v17);
  _mm_storel_ps(a1 + 5, v20);
  _mm_storeh_ps(a1 + 7, v20);
  return a1;
}

// sub_100276F0 @ 0x100276F0
void __stdcall sub_100276F0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027701);
}

// sub_100276FE @ 0x100276FE
__m128 *__stdcall sub_100276FE(__m128 *a1, int a2, int a3, int a4)
{
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm3
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm4
  __m128 v12; // xmm2
  __m128 v13; // xmm3
  __m128 v14; // xmm1

  v5 = _mm_loadh_ps((const double *)(a3 + 8));
  v6 = _mm_shuffle_ps(v5, v5, 57);
  v7 = _mm_loadh_ps((const double *)(a2 + 8));
  v8 = _mm_loadh_ps((const double *)(a4 + 8));
  v9 = _mm_shuffle_ps(v8, v8, 78);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 57), v6);
  v11 = _mm_mul_ps(v9, v6);
  v12 = _mm_mul_ps(v6, v8);
  v13 = _mm_shuffle_ps(v7, v7, 57);
  v14 = _mm_shuffle_ps(v13, v13, 57);
  *a1 = _mm_xor_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v13, _mm_sub_ps(_mm_shuffle_ps(v11, v11, 57), _mm_shuffle_ps(v12, v12, 78))),
              _mm_mul_ps(_mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10), v14)),
            _mm_mul_ps(_mm_shuffle_ps(v14, v14, 57), _mm_sub_ps(v11, _mm_shuffle_ps(v12, v12, 57)))),
          (__m128)xmmword_10055700);
  return a1;
}

// sub_100277A0 @ 0x100277A0
void __stdcall sub_100277A0(int a1, int a2)
{
  JUMPOUT(0x100277B1);
}

// sub_100277AE @ 0x100277AE
int __stdcall sub_100277AE(int a1, int a2)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm2
  __m128 v5; // xmm3
  __m128 v6; // xmm0
  int v7; // [esp-14h] [ebp-44h]
  int v8; // [esp-10h] [ebp-40h]
  int v9; // [esp-Ch] [ebp-3Ch]
  int v10; // [esp-8h] [ebp-38h]
  void *vars0; // [esp+30h] [ebp+0h]
  void *retaddr; // [esp+38h] [ebp+8h]

  vars0 = retaddr;
  v2 = sub_10034AF0(v7, v8, v9, v10);
  v3 = (__m128)xmmword_1005E1B0;
  v5 = v2;
  v6 = (__m128)xmmword_1005E1C0;
  *(_OWORD *)a1 = xmmword_1005E1D0;
  *(_DWORD *)(a1 + 16) = v6.m128_i32[0];
  _mm_storel_ps((double *)(a1 + 20), v5);
  _mm_storel_ps((double *)(a1 + 28), v6);
  *(_DWORD *)(a1 + 44) = v6.m128_i32[0];
  _mm_storel_ps((double *)(a1 + 36), _mm_xor_ps(_mm_shuffle_ps(v5, v5, 17), v3));
  *(__m128 *)(a1 + 48) = v6;
  return a1;
}

// sub_10027820 @ 0x10027820
void __stdcall sub_10027820(int a1, int a2)
{
  JUMPOUT(0x10027831);
}

// sub_1002782E @ 0x1002782E
int __stdcall sub_1002782E(int a1, int a2)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm0
  __int128 v5; // xmm1
  int v6; // [esp-14h] [ebp-64h]
  int v7; // [esp-10h] [ebp-60h]
  int v8; // [esp-Ch] [ebp-5Ch]
  int v9; // [esp-8h] [ebp-58h]
  __m128 v10; // [esp+1Ch] [ebp-34h]
  __m128 v11; // [esp+2Ch] [ebp-24h]
  void *vars0; // [esp+50h] [ebp+0h]
  void *retaddr; // [esp+58h] [ebp+8h]

  vars0 = retaddr;
  v11 = (__m128)xmmword_1005E210;
  v10 = (__m128)xmmword_1005E200;
  v2 = sub_10034AF0(v6, v7, v8, v9);
  v3 = _mm_and_ps(_mm_shuffle_ps(v2, v2, 80), v11);
  *(__m128 *)a1 = _mm_xor_ps(v10, v3);
  *(_OWORD *)(a1 + 16) = xmmword_1005E1F0;
  v5 = xmmword_1005E1E0;
  *(__m128 *)(a1 + 32) = _mm_shuffle_ps(v3, v3, 70);
  *(_OWORD *)(a1 + 48) = v5;
  return a1;
}

// sub_100278B0 @ 0x100278B0
void __stdcall sub_100278B0(int a1)
{
  JUMPOUT(0x100278C1);
}

// sub_100278BE @ 0x100278BE
double __stdcall sub_100278BE(int a1)
{
  __m128 v1; // xmm7
  __m128 v2; // xmm1
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm2
  __m128 v6; // xmm3
  __m128 v7; // xmm4
  __m128 v8; // xmm0
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm2
  __m128 v12; // xmm0
  __m128 v13; // xmm1
  __m128 v14; // xmm1
  __m128 v15; // xmm0

  if ( (a1 & 0xF) != 0 )
  {
    v2 = _mm_loadh_ps((const double *)(a1 + 24));
    v1 = _mm_loadh_ps((const double *)(a1 + 8));
    v3 = _mm_loadh_ps((const double *)(a1 + 40));
    v4 = _mm_loadh_ps((const double *)(a1 + 56));
  }
  else
  {
    v1 = *(__m128 *)a1;
    v2 = *(__m128 *)(a1 + 16);
    v3 = *(__m128 *)(a1 + 32);
    v4 = *(__m128 *)(a1 + 48);
  }
  v5 = _mm_shuffle_ps(v3, v3, 57);
  v6 = _mm_mul_ps(v4, v5);
  v7 = _mm_shuffle_ps(v4, v4, 78);
  v8 = _mm_shuffle_ps(v7, v7, 57);
  v9 = _mm_mul_ps(v7, v5);
  v10 = _mm_mul_ps(v5, v8);
  v11 = _mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10);
  v12 = _mm_shuffle_ps(v2, v2, 57);
  v13 = _mm_shuffle_ps(v12, v12, 57);
  v14 = _mm_mul_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v12, _mm_sub_ps(_mm_shuffle_ps(v9, v9, 57), _mm_shuffle_ps(v6, v6, 78))),
              _mm_mul_ps(v11, v13)),
            _mm_mul_ps(_mm_shuffle_ps(v13, v13, 57), _mm_sub_ps(v9, _mm_shuffle_ps(v6, v6, 57)))),
          v1);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  return (float)(v15.m128_f32[0] - _mm_shuffle_ps(v15, v15, 1).m128_f32[0]);
}

// sub_10027980 @ 0x10027980
void __stdcall sub_10027980(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027991);
}

// sub_1002798E @ 0x1002798E
__m128 *__stdcall sub_1002798E(__m128 *a1, const double *a2, const double *a3, const double *a4)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  __m128 v8; // xmm4
  __m128 v9; // xmm5
  __m128 v10; // xmm3
  __m128 v11; // xmm5
  __m128 v12; // xmm1
  __m128 v13; // xmm3
  __m128 v14; // xmm5
  __m128 v15; // xmm0
  __m128 v16; // xmm5
  __m128 v17; // xmm3
  __m128 v18; // xmm0

  v5 = _mm_loadh_ps(a2);
  v6 = _mm_sub_ps(v5, _mm_loadh_ps(a4));
  v7 = _mm_shuffle_ps(v6, v6, 120);
  v8 = v5;
  v9 = _mm_sub_ps(v5, _mm_loadh_ps(a3));
  v10 = _mm_shuffle_ps(v9, v9, 99);
  v11 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 120), _mm_shuffle_ps(v6, v6, 99));
  v12 = (__m128)xmmword_10055730;
  v13 = _mm_sub_ps(_mm_mul_ps(v7, v10), v11);
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = v15;
  v15.m128_f32[0] = fsqrt(v15.m128_f32[0]);
  v12.m128_f32[0] = (float)(*(float *)&xmmword_10055730 * (float)(1.0 / v15.m128_f32[0]))
                  * (float)(*(float *)&xmmword_10055720
                          - (float)((float)(v16.m128_f32[0] * (float)(1.0 / v15.m128_f32[0]))
                                  * (float)(1.0 / v15.m128_f32[0])));
  v17 = _mm_mul_ps(v13, _mm_shuffle_ps(v12, v12, 0));
  *a1 = v17;
  v18 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 14), v17);
  a1->m128_i32[3] = COERCE_UNSIGNED_INT(
                      v18.m128_f32[0]
                    + (float)(_mm_movehl_ps(v16, v18).m128_f32[0] + _mm_shuffle_ps(v18, v18, 85).m128_f32[0]))
                  ^ xmmword_10055710;
  return a1;
}

// sub_10027A70 @ 0x10027A70
void __stdcall sub_10027A70(int a1, int a2, int a3)
{
  JUMPOUT(0x10027A81);
}

// sub_10027A7E @ 0x10027A7E
double *__stdcall sub_10027A7E(double *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  char v8; // al
  __m128 v9; // xmm4
  float v10; // xmm3_4
  float v11; // xmm5_4
  double *result; // eax
  __m128 v13; // xmm4
  __m128 v14; // xmm0
  __m128 v15; // xmm0
  __m128 v16; // xmm0
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  float v19; // xmm7_4
  __m128 v20; // xmm0
  __m128 v21; // xmm1
  __m128 v22; // xmm2
  __m128 v23; // xmm3

  v3 = *a3;
  v4 = _mm_and_ps((__m128)xmmword_10055780, *a3);
  v5 = _mm_mul_ps(v4, v4);
  v6 = _mm_add_ps(v5, _mm_movehl_ps((__m128)0LL, v5));
  v7 = _mm_shuffle_ps(v6, v6, 1);
  v7.m128_f32[0] = v7.m128_f32[0] + v6.m128_f32[0];
  if ( v7.m128_f32[0] != 0.0 )
  {
    v8 = byte_1005DBF0;
    if ( (byte_1005DBF0 & 1) != 0 )
    {
      v9 = (__m128)xmmword_1005DBD0;
    }
    else
    {
      v8 = byte_1005DBF0 | 1;
      v9 = (__m128)(unsigned int)dword_1005E220;
      byte_1005DBF0 |= 1u;
      xmmword_1005DBD0 = (unsigned int)dword_1005E220;
    }
    if ( (v8 & 2) != 0 )
    {
      v10 = *(float *)&xmmword_1005DBE0;
    }
    else
    {
      v10 = *(float *)&dword_1005E224;
      byte_1005DBF0 = v8 | 2;
      xmmword_1005DBE0 = (unsigned int)dword_1005E224;
    }
    v11 = 1.0 / fsqrt(v7.m128_f32[0]);
    v9.m128_f32[0] = (float)(v9.m128_f32[0] * v11) * (float)(v10 - (float)((float)(v7.m128_f32[0] * v11) * v11));
    v7 = _mm_mul_ps(v3, _mm_shuffle_ps(v9, v9, 0));
  }
  result = a1;
  v13 = _mm_xor_ps((__m128)xmmword_10055740, v7);
  v14 = _mm_mul_ps(v7, *a2);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v6, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = _mm_shuffle_ps(v15, v15, 0);
  v17 = _mm_and_ps((__m128)xmmword_10055760, v16);
  v18 = _mm_and_ps((__m128)xmmword_10055770, v16);
  v19 = v16.m128_f32[0];
  v20 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 85), *a2), _mm_and_ps((__m128)xmmword_10055750, v16));
  v21 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), *a2), v17);
  v23 = _mm_mul_ps(_mm_shuffle_ps(v13, v13, 0), *a2);
  v22 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 255), *a2), v18);
  v23.m128_f32[0] = v23.m128_f32[0] + v19;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    _mm_storel_ps(a1, v23);
    _mm_storeh_ps(a1 + 1, v23);
    _mm_storel_ps(a1 + 2, v20);
    _mm_storeh_ps(a1 + 3, v20);
    _mm_storel_ps(a1 + 4, v21);
    _mm_storeh_ps(a1 + 5, v21);
    _mm_storel_ps(a1 + 6, v22);
    _mm_storeh_ps(a1 + 7, v22);
  }
  else
  {
    *(__m128 *)a1 = v23;
    *((__m128 *)a1 + 1) = v20;
    *((__m128 *)a1 + 2) = v21;
    *((__m128 *)a1 + 3) = v22;
  }
  return result;
}

// sub_10027C00 @ 0x10027C00
void __stdcall sub_10027C00(int a1, int a2)
{
  JUMPOUT(0x10027C11);
}

// sub_10027C0E @ 0x10027C0E
__m128 *__stdcall sub_10027C0E(__m128 *a1, const double *a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm0
  __m128 v5; // xmm3
  __m128 v6; // xmm4
  __m128 v7; // xmm0
  float v8; // xmm5_4
  __m128 v9; // xmm1
  __m128 v10; // xmm4
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm2
  __m128 v14; // xmm0
  __m128 v15; // xmm3
  __m128 v16; // xmm2
  __m128 v17; // xmm4

  v3 = _mm_loadl_ps(a2);
  v4 = _mm_and_ps((__m128)xmmword_10055800, v3);
  v5 = (__m128)(unsigned int)dword_100557F0;
  v6 = _mm_mul_ps(v4, v4);
  v7 = _mm_add_ps(v6, _mm_movehl_ps(v6, v6));
  v8 = v7.m128_f32[0] + _mm_shuffle_ps(v7, v7, 1).m128_f32[0];
  v7.m128_f32[0] = 1.0 / fsqrt(v8);
  v5.m128_f32[0] = (float)(*(float *)&dword_100557F0 * v7.m128_f32[0])
                 * (float)(*(float *)&dword_100557E0 - (float)((float)(v8 * v7.m128_f32[0]) * v7.m128_f32[0]));
  v9 = _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 0));
  v10 = _mm_mul_ps((__m128)xmmword_100557D0, v9);
  v11 = v9;
  v12 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), v10), (__m128)xmmword_100557C0);
  v13 = v11;
  v14 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v11, v11, 255), v10), (__m128)xmmword_10055790);
  v15 = v13;
  v16 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), v10), (__m128)xmmword_100557A0);
  v17 = _mm_add_ps(_mm_mul_ps(v10, _mm_shuffle_ps(v15, v15, 85)), (__m128)xmmword_100557B0);
  *a1 = v12;
  a1[1] = v17;
  a1[2] = v16;
  a1[3] = v14;
  return a1;
}

// sub_10027CE0 @ 0x10027CE0
float *__stdcall sub_10027CE0(float *a1, float *a2)
{
  float *result; // eax
  double v3; // st7
  float v4; // edi
  float v5; // esi
  int v6; // ebp
  double v7; // st7
  int v8; // ecx
  int v9; // ebx
  int v10; // ebp
  float *v11; // esi
  long double v12; // st6
  long double v13; // st7
  float *v14; // ecx
  long double v15; // st6
  long double v16; // st7
  _DWORD v17[7]; // [esp+0h] [ebp-1Ch]

  result = a1;
  v3 = *a2 + a2[5] + a2[10];
  v4 = *a2;
  v5 = a2[5];
  v6 = *((_DWORD *)a2 + 10);
  if ( flt_1005E27C < v3 )
  {
    v15 = sqrt(v3 + flt_1005E280) * flt_1005E284;
    v16 = flt_1005E288 / v15;
    a1[3] = v15;
    *a1 = (a2[6] - a2[9]) * v16;
    a1[1] = (a2[8] - a2[2]) * v16;
    a1[2] = v16 * (a2[1] - a2[4]);
  }
  else
  {
    v7 = a2[10];
    *(float *)v17 = *a2;
    *(float *)&v17[1] = v5;
    v17[2] = v6;
    v8 = 2;
    if ( *(float *)&v17[v5 > (double)v4] >= v7 )
      v8 = v5 > (double)v4;
    v9 = dword_1005E270[v8];
    v10 = dword_1005E270[v9];
    v11 = &a2[v8];
    v12 = sqrt(flt_1005E290 + *(float *)&v17[v8] - *(float *)&v17[v9] - *(float *)&v17[v10]) * flt_1005E294;
    v13 = flt_1005E298 / v12;
    a1[v8] = v12;
    v14 = &a2[4 * v8];
    a1[v9] = (v14[v9] + v11[4 * v9]) * v13;
    a1[v10] = (v11[4 * v10] + v14[v10]) * v13;
    a1[3] = v13 * (a2[4 * v9 + v10] - a2[4 * v10 + v9]);
  }
  return result;
}

// sub_10027E00 @ 0x10027E00
void __stdcall sub_10027E00(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027E11);
}

// sub_10027E0E @ 0x10027E0E
__m128 *__stdcall sub_10027E0E(__m128 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __m128 v4; // xmm0
  __m128 v5; // xmm1
  __m128 v6; // xmm3
  __m128 v7; // xmm2
  __m128 v8; // xmm3
  __m128 v10; // [esp+10h] [ebp-4Ch] BYREF
  __m128 v11[3]; // [esp+20h] [ebp-3Ch] BYREF

  v10 = _mm_mul_ps(
          _mm_shuffle_ps(
            _mm_unpacklo_ps((__m128)a3, (__m128)a4),
            _mm_unpacklo_ps((__m128)(unsigned int)dword_1005E2C0, (__m128)a2),
            17),
          (__m128)xmmword_1005E2B0);
  sub_10034BE0(&v10, &v10, v11);
  v4 = _mm_shuffle_ps(v10, v11[0], 0);
  v5 = _mm_shuffle_ps(v4, v4, 138);
  v6 = _mm_shuffle_ps(v10, v11[0], 153);
  v7 = _mm_shuffle_ps(v6, v6, 247);
  v8 = _mm_shuffle_ps(v6, v6, 168);
  v10 = _mm_add_ps(
          _mm_mul_ps(_mm_mul_ps(v5, v7), v8),
          _mm_xor_ps(
            _mm_mul_ps(_mm_mul_ps(_mm_shuffle_ps(v5, v5, 138), _mm_shuffle_ps(v7, v7, 81)), _mm_shuffle_ps(v8, v8, 1)),
            (__m128)xmmword_1005E2A0));
  *a1 = v10;
  return a1;
}

// sub_10027ED0 @ 0x10027ED0
__m64 *__stdcall sub_10027ED0(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm3
  __m64 v4; // mm1
  __m64 v6; // mm6
  __m64 v7; // mm7
  unsigned __int64 v8; // mm4
  __m64 v9; // mm6
  __m64 v10; // mm5
  __m64 v11; // mm3

  v3 = a3[1];
  v4 = a2[1];
  v6 = _m_punpckldq(_m_punpckhdq((__m64)a3->m64_u64, (__m64)a3->m64_u64), (__m64)a3->m64_u64);
  v7 = _m_punpckldq(_m_punpckhdq(v3, v3), v3);
  v8 = (unsigned __int64)_m_pfacc(
                           _m_pfsub(_m_pfmul(v6, v4), _m_pfmul(_m_pxor(v7, (__m64)0x80000000LL), (__m64)a2->m64_u64)),
                           _m_pfadd(
                             _m_pxor(_m_pfmul((__m64)a3->m64_u64, v4), (__m64)0x80000000LL),
                             _m_pfmul(v3, (__m64)a2->m64_u64)));
  v9 = _m_pfmul(_m_pxor(v6, (__m64)0x80000000LL), (__m64)a2->m64_u64);
  v10 = _m_pxor(v3, (__m64)0x80000000LL);
  v11 = _m_pfmul((__m64)a3->m64_u64, (__m64)a2->m64_u64);
  a1->m64_u64 = v8;
  a1[1].m64_u64 = (unsigned __int64)_m_pfacc(_m_pfadd(v9, _m_pfmul(v7, v4)), _m_pfsub(_m_pfmul(v10, v4), v11));
  _m_femms();
  return a1;
}

// sub_10027F69 @ 0x10027F69
__m64 *__stdcall sub_10027F69(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v5 = _m_pfacc(v3, v3);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfcmpgt(v5, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v5, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v8);
  _m_femms();
  return a1;
}

// sub_10027FC6 @ 0x10027FC6
int __stdcall sub_10027FC6(__m64 *a1, int a2, _DWORD *a3)
{
  __m64 m64_u64; // mm2
  __m64 v4; // mm0
  __m64 v5; // mm5
  __m64 v6; // mm5
  __m64 v7; // mm1
  int result; // eax
  __m64 v9; // mm4
  __m64 v10; // mm1
  __m64 v11; // mm1

  m64_u64 = (__m64)a1->m64_u64;
  v4 = a1[1];
  v5 = _m_pfadd(_m_pfmul(m64_u64, m64_u64), _m_pfmul(v4, v4));
  v6 = _m_pfacc(v5, v5);
  v7 = _m_pfrsqrt(v6);
  result = _mm_cvtsi64_si32(_m_pfcmpge((__m64)0x80000000800000LL, v6));
  v9 = v7;
  if ( result )
  {
    if ( a2 )
    {
      *(_QWORD *)(a2 + 4) = 0;
      *(_DWORD *)a2 = _mm_cvtsi64_si32((__m64)0xBF8000003F800000uLL);
    }
    if ( a3 )
      *a3 = _mm_cvtsi64_si32(0);
  }
  else
  {
    v10 = _m_pfmul(v7, v7);
    if ( a2 )
    {
      v11 = _m_pfrcpit2(_m_pfrsqit1(v10, v6), v9);
      *(__m64 *)a2 = _m_pfmul(m64_u64, v11);
      *(_DWORD *)(a2 + 8) = _mm_cvtsi64_si32(_m_pfmul(v11, v4));
    }
    if ( a3 )
    {
      result = sub_10034F00(a3, a2);
      *a3 = _mm_cvtsi64_si32(_m_pfmul(_m_punpckhdq(v4, v4), (__m64)0x4000000040000000LL));
    }
  }
  _m_femms();
  return result;
}

// sub_10028079 @ 0x10028079
__m64 *__stdcall sub_10028079(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm4
  __m64 v3; // mm5
  __m64 v4; // mm3
  __m64 v5; // mm0
  __m64 v6; // mm1
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm3
  __m64 v12; // mm6
  int v13; // ecx
  __m64 v14; // mm0
  __m64 v15; // mm7
  __m64 v16; // mm2
  __m64 v17; // mm0
  __m64 v18; // mm4
  __m64 *result; // eax
  __m64 v20; // mm1
  __m64 v21; // mm1
  __m64 v22; // mm0
  __m64 v23; // mm1
  __m64 v24; // mm4
  __m64 v25; // mm1
  __m64 v26; // mm2
  __m64 v27; // mm0
  __m64 v28; // mm2
  __m64 v29; // mm4
  __m64 v30; // mm1
  __m64 v31; // mm3
  __m64 v32; // mm0
  __m64 v33; // mm3
  __m64 v34; // mm2
  __m64 v35; // mm3

  v2 = _mm_cvtsi32_si64(a2[2].m64_u32[1]);
  v3 = _mm_cvtsi32_si64(a2[5].m64_u32[0]);
  v4 = _m_pfsubr((__m64)a2->m64_u64, v3);
  v5 = _m_pfadd(_m_pfadd((__m64)a2->m64_u64, v2), v3);
  v6 = _m_pfsub(_m_pfsub((__m64)a2->m64_u64, v2), v3);
  v7 = _m_pfsub(_m_pfsubr((__m64)a2->m64_u64, v2), v3);
  v8 = a2[4];
  v9 = _m_pfsub(v4, v2);
  v10 = _m_punpckldq(v5, v7);
  v11 = _m_punpckldq(v9, v9);
  v12 = _m_packssdw(_m_pfcmpge(_m_punpckldq(0, v6), v10), _m_pfcmpge(_m_punpckldq(v7, v6), v11));
  v13 = _mm_cvtsi64_si32(_m_packsswb(v12, v12));
  if ( (v13 & 1) != 0 )
  {
    if ( (v13 & 0xFF00FF00) == 0xFF00FF00 )
    {
      v21 = _m_pfadd(v6, (__m64)0xBF8000003F800000uLL);
      v22 = _m_pfrsqrt(v21);
      v23 = _m_punpckldq(v21, v21);
      v24 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v22, v22), v23), v22), (__m64)0x3F0000003F000000LL);
      v25 = _m_punpckldq(
              _m_pfmul(v23, v24),
              _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a2[2].m64_u32[0]), _m_punpckhdq(v7, v7)), v24));
      a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_pxor(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8)),
                                              (__m64)0x8000000000000000uLL)),
                                          v24);
      a1->m64_u64 = (unsigned __int64)v25;
      _m_femms();
      return a1;
    }
    else
    {
      result = a1;
      if ( (v13 & 0x10000) != 0 )
      {
        v26 = _m_pfadd(v7, (__m64)0xBF8000003F800000uLL);
        v27 = _m_pfrsqrt(v26);
        v28 = _m_punpckldq(v26, v26);
        v29 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v27, v27), v28), v27), (__m64)0x3F0000003F000000LL);
        v30 = _m_punpckldq(
                _m_pfmul(_m_pfadd(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v29),
                _m_pfmul(v28, v29));
        a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                            _m_pfadd(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                              _m_pxor(
                                                _m_punpckldq(_m_punpckhdq(v8, v8), (__m64)a2[1].m64_u32[0]),
                                                (__m64)0x8000000000000000uLL)),
                                            v29);
        a1->m64_u64 = (unsigned __int64)v30;
      }
      else
      {
        v31 = _m_pfadd(v11, (__m64)0xBF8000003F800000uLL);
        v32 = _m_pfrsqrt(v31);
        v33 = _m_punpckldq(v31, v31);
        v34 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v32, v32), v33), v32), (__m64)0x3F0000003F000000LL);
        v35 = _m_punpckldq(
                _m_pfmul(v33, v34),
                _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v34));
        a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8))),
                                          v34);
        a1[1].m64_u64 = (unsigned __int64)v35;
      }
      _m_femms();
    }
  }
  else
  {
    v14 = _m_pfadd(v10, (__m64)0xBF8000003F800000uLL);
    v15 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
    v16 = _m_pfrsqrt(v14);
    v17 = _m_punpckldq(v14, v14);
    v18 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v16, v16), v17), v16), (__m64)0x3F0000003F000000LL);
    v20 = _m_punpckldq(
            _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v18),
            _m_pfmul(v17, v18));
    a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                      _m_pfsub(
                                        _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                        _m_punpckhdq(v8, _m_punpckldq(v15, v15))),
                                      v18);
    a1[1].m64_u64 = (unsigned __int64)v20;
    _m_femms();
    return a1;
  }
  return result;
}

// sub_10028295 @ 0x10028295
__m64 *__stdcall sub_10028295(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm4
  __m64 v3; // mm5
  __m64 v4; // mm3
  __m64 v5; // mm0
  __m64 v6; // mm1
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm3
  char v12; // cl
  __m64 v13; // mm0
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm0
  __m64 v17; // mm4
  __m64 *result; // eax
  __m64 v19; // mm1
  __m64 v20; // mm1
  __m64 v21; // mm0
  __m64 v22; // mm1
  __m64 v23; // mm4
  __m64 v24; // mm1
  __m64 v25; // mm2
  __m64 v26; // mm0
  __m64 v27; // mm2
  __m64 v28; // mm4
  __m64 v29; // mm1
  __m64 v30; // mm3
  __m64 v31; // mm0
  __m64 v32; // mm3
  __m64 v33; // mm2
  __m64 v34; // mm3

  v2 = _mm_cvtsi32_si64(a2[2].m64_u32[1]);
  v3 = _mm_cvtsi32_si64(a2[5].m64_u32[0]);
  v4 = _m_pfsubr((__m64)a2->m64_u64, v3);
  v5 = _m_pfadd(_m_pfadd((__m64)a2->m64_u64, v2), v3);
  v6 = _m_pfsub(_m_pfsub((__m64)a2->m64_u64, v2), v3);
  v7 = _m_pfsub(_m_pfsubr((__m64)a2->m64_u64, v2), v3);
  v8 = a2[4];
  v9 = _m_pfsub(v4, v2);
  v10 = _m_punpckldq(v5, v7);
  v11 = _m_punpckldq(v9, v9);
  v12 = _m_pmovmskb(_m_packssdw(_m_pfcmpge(_m_punpckldq(0, v6), v10), _m_pfcmpge(_m_punpckldq(v7, v6), v11)));
  if ( (v12 & 1) != 0 )
  {
    if ( (v12 & 0xCC) == 0xCC )
    {
      v20 = _m_pfadd(v6, (__m64)0xBF8000003F800000uLL);
      v21 = _m_pfrsqrt(v20);
      v22 = _m_punpckldq(v20, v20);
      v23 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v21, v21), v22), v21), (__m64)0x3F0000003F000000LL);
      v24 = _m_punpckldq(
              _m_pfmul(v22, v23),
              _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a2[2].m64_u32[0]), _m_punpckhdq(v7, v7)), v23));
      a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_pxor(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8)),
                                              (__m64)0x8000000000000000uLL)),
                                          v23);
      a1->m64_u64 = (unsigned __int64)v24;
      _m_femms();
      return a1;
    }
    else
    {
      result = a1;
      if ( (v12 & 0x10) != 0 )
      {
        v25 = _m_pfadd(v7, (__m64)0xBF8000003F800000uLL);
        v26 = _m_pfrsqrt(v25);
        v27 = _m_punpckldq(v25, v25);
        v28 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v26, v26), v27), v26), (__m64)0x3F0000003F000000LL);
        v29 = _m_punpckldq(
                _m_pfmul(_m_pfadd(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v28),
                _m_pfmul(v27, v28));
        a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                            _m_pfadd(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                              _m_pxor(
                                                _m_punpckldq(_m_punpckhdq(v8, v8), (__m64)a2[1].m64_u32[0]),
                                                (__m64)0x8000000000000000uLL)),
                                            v28);
        a1->m64_u64 = (unsigned __int64)v29;
      }
      else
      {
        v30 = _m_pfadd(v11, (__m64)0xBF8000003F800000uLL);
        v31 = _m_pfrsqrt(v30);
        v32 = _m_punpckldq(v30, v30);
        v33 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v31, v31), v32), v31), (__m64)0x3F0000003F000000LL);
        v34 = _m_punpckldq(
                _m_pfmul(v32, v33),
                _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v33));
        a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8))),
                                          v33);
        a1[1].m64_u64 = (unsigned __int64)v34;
      }
      _m_femms();
    }
  }
  else
  {
    v13 = _m_pfadd(v10, (__m64)0xBF8000003F800000uLL);
    v14 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
    v15 = _m_pfrsqrt(v13);
    v16 = _m_punpckldq(v13, v13);
    v17 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v15, v15), v16), v15), (__m64)0x3F0000003F000000LL);
    v19 = _m_punpckldq(
            _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v17),
            _m_pfmul(v16, v17));
    a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                      _m_pfsub(
                                        _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                        _m_punpckhdq(v8, _m_punpckldq(v14, v14))),
                                      v17);
    a1[1].m64_u64 = (unsigned __int64)v19;
    _m_femms();
    return a1;
  }
  return result;
}

// sub_100284AA @ 0x100284AA
__m64 *__userpurge sub_100284AA@<eax>(__m64 *a1, __m64 a2, __m64 a3)
{
  __m64 v3; // mm1
  __m64 v5; // mm6
  __m64 v6; // mm2
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v9; // [esp+10h] [ebp-10h]

  _m_femms();
  v9 = _m_pfmul((__m64)0x3F0000003F000000LL, a2);
  sub_100354E0();
  sub_100354E0();
  sub_100354E0();
  v3 = _m_pfmul((__m64)0x3F0000003F000000LL, a3);
  v5 = _m_punpckhdq(v9, v9);
  v6 = _m_punpckldq(v5, v5);
  v7 = _m_punpckhdq(v5, v5);
  v8 = _m_punpckldq(_m_punpckhdq(v3, v3), v3);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(
                                      _m_pfmul(_m_pxor(_m_punpckldq(v9, v9), (__m64)0x8000000000000000uLL), v7),
                                      v3),
                                    _m_pfmul(_m_pfmul(_m_punpckhdq(v9, v9), v6), v8));
  a1[1].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_pfmul(_m_punpckldq(v9, v9), v6), v8),
                                      _m_pfmul(
                                        _m_pfmul(
                                          _m_pxor(_m_punpckhdq(v9, v9), _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u)),
                                          v7),
                                        v3));
  _m_femms();
  return a1;
}

// sub_1002856F @ 0x1002856F
__m64 *__stdcall sub_1002856F(__m64 *a1, int a2, unsigned int a3)
{
  __m64 v3; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm2
  __m64 v7; // [esp+0h] [ebp-18h] BYREF
  unsigned int v8; // [esp+8h] [ebp-10h]

  _m_femms();
  sub_1002D2C2((int)&v7, a2);
  v3 = _m_pfmul(_mm_cvtsi32_si64(a3), (__m64)0x3F0000003F000000LL);
  sub_100354E0();
  v5 = _m_punpckhdq(v3, v3);
  v6 = _m_punpckldq(_m_pfmul(_mm_cvtsi32_si64(v8), v5), v3);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(v7, v5);
  a1[1].m64_u64 = (unsigned __int64)v6;
  _m_femms();
  return a1;
}

// sub_100285DB @ 0x100285DB
__m64 *__stdcall sub_100285DB(__m64 *a1, __m64 *a2, __m64 *a3, unsigned int a4)
{
  __m64 v4; // mm1
  __m64 v5; // mm4
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm7
  __m64 v9; // mm1
  __m64 v10; // mm3
  __m64 v11; // mm4
  __m64 v12; // mm0
  __m64 v13; // mm1
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm6
  __m64 v18; // mm0
  __m64 v19; // mm5
  unsigned int v20; // [esp+28h] [ebp+10h]

  _m_femms();
  v4 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64), _m_pfmul(a2[1], a3[1]));
  v5 = _mm_cvtsi32_si64(a4);
  v6 = _m_pfsub(_mm_cvtsi32_si64(0x3F800000u), v5);
  v7 = _m_pfacc(v4, v4);
  v8 = _m_pand(_m_pfcmpge(0, v7), (__m64)0x8000000080000000uLL);
  v9 = _m_pxor(v7, v8);
  v10 = _m_pfsubr(_m_pfmul(v9, v9), (__m64)0x3F8000003F800000LL);
  if ( _mm_cvtsi64_si32(_m_pfcmpge((__m64)0x3F7FFF583F7FFF58LL, v9)) )
  {
    v11 = _m_pfrsqrt(v10);
    sub_10034E00();
    sub_10035600();
    v20 = _mm_cvtsi64_si32(_m_pfmul(v9, _mm_cvtsi32_si64(a4)));
    v12 = _m_pfmul(_mm_cvtsi32_si64(_mm_cvtsi64_si32(v9)), _mm_cvtsi32_si64(_mm_cvtsi64_si32(v6)));
    sub_10035600();
    v13 = _mm_cvtsi32_si64(_mm_cvtsi64_si32(_m_pfrcpit2(_m_pfrsqit1(v10, _m_pfmul(v11, v11)), v11)));
    v8 = _mm_cvtsi32_si64(_mm_cvtsi64_si32(v8));
    v6 = _m_pfmul(v12, v13);
    v5 = _m_pfmul(_mm_cvtsi32_si64(v20), v13);
  }
  v15 = _m_pxor(v5, v8);
  v16 = _m_punpckldq(v6, v6);
  v17 = _m_punpckldq(v15, v15);
  v18 = _m_pfmul(v16, (__m64)a2->m64_u64);
  v19 = _m_pfadd(_m_pfmul(v16, a2[1]), _m_pfmul(v17, a3[1]));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(v18, _m_pfmul(v17, (__m64)a3->m64_u64));
  a1[1].m64_u64 = (unsigned __int64)v19;
  _m_femms();
  return a1;
}

// sub_10028712 @ 0x10028712
__m64 *__stdcall sub_10028712(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v9[2]; // [esp+Ch] [ebp-24h] BYREF
  __m64 v10[2]; // [esp+1Ch] [ebp-14h] BYREF
  unsigned int v11; // [esp+44h] [ebp+14h]

  _m_femms();
  v11 = _mm_cvtsi64_si32(_m_pfadd(_mm_cvtsi32_si64(a5), _mm_cvtsi32_si64(a6)));
  sub_100285DB(v9, a2, a3, v11);
  sub_100285DB(v10, a2, a4, v11);
  v6 = _mm_cvtsi32_si64(v11);
  v7 = _m_pfrcp(v6);
  sub_100285DB(a1, v9, v10, _mm_cvtsi64_si32(_m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v6, v7), v7), _mm_cvtsi32_si64(a6))));
  _m_femms();
  return a1;
}

// sub_1002879F @ 0x1002879F
__m64 *__stdcall sub_1002879F(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 *result; // eax
  __m64 v8[2]; // [esp+10h] [ebp-20h] BYREF
  __m64 v9[2]; // [esp+20h] [ebp-10h] BYREF

  sub_100285DB(v8, a2, a5, a6);
  sub_100285DB(v9, a3, a4, a6);
  v6 = _mm_cvtsi32_si64(a6);
  result = sub_100285DB(
             a1,
             v8,
             v9,
             _mm_cvtsi64_si32(_m_pfmul(_m_pfsub(v6, _m_pfmul(v6, v6)), (__m64)0x4000000040000000LL)));
  _m_femms();
  return result;
}

// sub_10028831 @ 0x10028831
__m64 *__stdcall sub_10028831(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v6 = _m_pfrcp(v4);
  v7 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrcpit1(v4, v6), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(_m_pxor((__m64)a2->m64_u64, (__m64)0x8000000080000000uLL), v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(_m_pxor(v2, (__m64)0x80000000LL), v7), v8);
  _m_femms();
  return a1;
}

// sub_10028895 @ 0x10028895
__m64 *__stdcall sub_10028895(__m64 *a1, __m64 *a2)
{
  __m64 *result; // eax
  __m64 m64_u64; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm0
  __m64 v6; // mm3
  __m64 v7; // mm4
  __m64 v8; // mm3
  unsigned int v9; // [esp+0h] [ebp-Ch]

  _m_femms();
  result = a1;
  m64_u64 = (__m64)a2->m64_u64;
  v4 = a2[1];
  v5 = _m_punpckhdq(v4, v4);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v5, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, a2);
    v9 = _mm_cvtsi64_si32(v5);
    sub_10035600();
    result = a1;
    m64_u64 = (__m64)a2->m64_u64;
    v4 = a2[1];
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v5, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v6 = _mm_cvtsi32_si64(v9);
      v7 = _m_pfrcp(v5);
      v8 = _m_pfmul(_m_punpckldq(v6, v6), _m_pfrcpit2(_m_pfrcpit1(v5, v7), v7));
      m64_u64 = _m_pfmul(m64_u64, v8);
      v4 = _m_pfmul(v4, v8);
    }
  }
  result->m64_u64 = (unsigned __int64)m64_u64;
  result[1].m64_u64 = (unsigned __int64)_m_pand(v4, (__m64)0xFFFFFFFFLL);
  _m_femms();
  return result;
}

// sub_1002893C @ 0x1002893C
__m64 *__userpurge sub_1002893C@<eax>(unsigned int a1@<esi>, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm2
  __m64 v7; // mm1
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 *result; // eax
  char v11; // cl
  __m64 m64_u64; // mm2
  __m64 v13; // mm0
  __m64 v14; // mm1
  __m64 v15; // mm3
  __m64 v16; // mm1
  __m64 v17; // [esp+0h] [ebp-Ch]

  v3 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v4 = _m_pfadd(_m_pfmul((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_pfmul(v3, v3));
  v5 = _m_pfacc(v4, v4);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v6, v6), v5), v6);
  v17.m64_u64 = __PAIR64__(a1, _mm_cvtsi64_si32(v7));
  sub_100354E0();
  v8 = _m_pfmul(v5, v7);
  v9 = _m_pfcmpge(_m_pand(v8, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  result = a2;
  v11 = _mm_cvtsi64_si32(_m_punpckhdq(v9, v9));
  m64_u64 = (__m64)a3->m64_u64;
  v13 = v8;
  v14 = _m_pfmul(_m_punpckhdq(v8, v8), v17);
  v15 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  if ( (v11 & 1) != 0 )
  {
    v16 = _m_punpckldq(v14, v14);
    v15 = _m_pfmul(v15, v16);
    m64_u64 = _m_pfmul(m64_u64, v16);
  }
  a2->m64_u64 = (unsigned __int64)m64_u64;
  a2[1].m64_u64 = (unsigned __int64)_m_punpckldq(v15, v13);
  _m_femms();
  return result;
}

// sub_100289E1 @ 0x100289E1
__m64 *__userpurge sub_100289E1@<eax>(
        unsigned int a1@<esi>,
        __m64 *a2,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v11; // mm3
  __m64 *v12; // edx
  __m64 v13; // mm0
  __m64 v14; // mm2
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm1
  __m64 v18; // mm3
  __m64 v19; // mm2
  int v20; // eax
  __m64 v21; // mm4
  __m64 v22; // mm6
  __m64 v23; // mm7
  __m64 v24; // mm3
  __m64 v25; // mm5
  __m64 v26; // mm6
  __m64 v27; // mm3
  __m64 v28; // mm0
  __m64 v29; // mm0
  __m64 v30; // mm4
  __m64 v31; // mm5
  __m64 v32; // mm0
  __m64 v33; // mm6
  __m64 v34; // mm7
  __m64 v35; // mm6
  __m64 v36; // mm7
  __m64 v37; // mm1
  __m64 v38; // mm2
  __m64 v39; // mm0
  __m64 v40; // mm3
  __m64 v41; // mm4
  __m64 v42; // mm3
  __m64 v43; // mm1
  __m64 v44; // mm2
  __m64 v45; // mm0
  __m64 v46; // mm3
  __m64 v47; // mm4
  __m64 v48; // mm3
  __m64 v49; // mm1
  __m64 v50; // mm0
  __m64 v51; // mm0
  __m64 v52; // mm2
  __m64 v53; // mm1
  __int32 v54; // edx
  __m64 v55; // mm1
  __m64 v56; // mm0
  char v57; // cl
  __m64 v58; // mm2
  __m64 v59; // mm0
  __m64 v60; // mm1
  __m64 v61; // mm3
  __m64 v62; // mm1
  __m64 v63; // mm6
  __m64 v64; // mm7
  __m64 v65; // mm0
  __m64 v66; // mm0
  __m64 v67; // mm4
  __m64 v68; // mm5
  __m64 v69; // mm0
  __m64 v70; // mm6
  __m64 v71; // mm7
  __m64 v72; // mm6
  __m64 v73; // mm7
  __m64 v74; // mm1
  __m64 v75; // mm2
  __m64 v76; // mm0
  __m64 v77; // mm3
  __m64 v78; // mm4
  __m64 v79; // mm3
  __m64 v80; // mm1
  __m64 v81; // mm2
  __m64 v82; // mm0
  __m64 v83; // mm3
  __m64 v84; // mm4
  __m64 v85; // mm3
  __m64 v86; // mm1
  __m64 v87; // mm0
  __m64 v88; // mm0
  __m64 v89; // mm2
  __m64 v90; // mm1
  __m64 v91; // mm1
  __m64 v92; // mm0
  char v93; // cl
  __m64 v94; // mm2
  __m64 v95; // mm0
  __m64 v96; // mm1
  __m64 v97; // mm3
  __m64 v98; // mm1
  __m64 v99; // mm6
  __m64 v100; // mm7
  unsigned int v102; // [esp+0h] [ebp-ACh]
  unsigned int v103; // [esp+0h] [ebp-ACh]
  __m64 v104; // [esp+0h] [ebp-ACh]
  unsigned int v105; // [esp+0h] [ebp-ACh]
  unsigned int v106; // [esp+0h] [ebp-ACh]
  __m64 v107; // [esp+0h] [ebp-ACh]
  __m64 m64_u64; // [esp+Ch] [ebp-A0h]
  __m64 v109; // [esp+14h] [ebp-98h]
  __m64 v110; // [esp+1Ch] [ebp-90h]
  __m64 v111; // [esp+24h] [ebp-88h]
  __m64 v112; // [esp+2Ch] [ebp-80h]
  __m64 v113; // [esp+34h] [ebp-78h]
  __m64 v114; // [esp+3Ch] [ebp-70h]
  __m64 v115; // [esp+44h] [ebp-68h]
  __m64 v116; // [esp+4Ch] [ebp-60h]
  __m64 v117; // [esp+4Ch] [ebp-60h]
  __m64 v118; // [esp+54h] [ebp-58h]
  __m64 v119; // [esp+54h] [ebp-58h]
  __m64 v120; // [esp+5Ch] [ebp-50h]
  __m64 v121; // [esp+5Ch] [ebp-50h]
  __m64 v122; // [esp+64h] [ebp-48h]
  __m64 v123; // [esp+64h] [ebp-48h]
  __m64 v124; // [esp+84h] [ebp-28h]
  __m64 v125; // [esp+84h] [ebp-28h]
  __m64 v126; // [esp+8Ch] [ebp-20h]
  __m64 v127; // [esp+8Ch] [ebp-20h]
  __m64 v128; // [esp+8Ch] [ebp-20h]
  __m64 v129; // [esp+8Ch] [ebp-20h]
  __m64 v130; // [esp+94h] [ebp-18h]
  unsigned int v131; // [esp+94h] [ebp-18h]
  __m64 v132; // [esp+94h] [ebp-18h]
  unsigned int v133; // [esp+94h] [ebp-18h]
  __m64 v134; // [esp+9Ch] [ebp-10h]
  __m64 v135; // [esp+9Ch] [ebp-10h]
  __m64 v136; // [esp+A4h] [ebp-8h]
  __m64 v137; // [esp+A4h] [ebp-8h]

  m64_u64 = (__m64)a5->m64_u64;
  v109 = a5[1];
  v110 = (__m64)a6->m64_u64;
  v8 = _m_pfadd((__m64)a5->m64_u64, (__m64)a6->m64_u64);
  v111 = a6[1];
  v9 = _m_pfadd(v109, v111);
  v10 = _m_pfsub((__m64)a5->m64_u64, (__m64)a6->m64_u64);
  v11 = _m_pfsub(v109, v111);
  v12 = a7;
  v13 = _m_pfadd(_m_pfmul(v8, v8), _m_pfmul(v9, v9));
  v14 = _m_pfadd(_m_pfmul(v10, v10), _m_pfmul(v11, v11));
  v112 = (__m64)a7->m64_u64;
  v113 = a7[1];
  v15 = _m_pfadd((__m64)a6->m64_u64, (__m64)a7->m64_u64);
  v16 = _m_pfadd(v111, v113);
  v17 = _m_pfsub((__m64)a6->m64_u64, (__m64)a7->m64_u64);
  v18 = _m_pfsub(v111, v113);
  v19 = _m_pfcmpgt(
          _m_pfacc(v14, _m_pfadd(_m_pfmul(v17, v17), _m_pfmul(v18, v18))),
          _m_pfacc(v13, _m_pfadd(_m_pfmul(v15, v15), _m_pfmul(v16, v16))));
  v20 = _mm_cvtsi64_si32(_m_packsswb(v19, v19));
  if ( (v20 & 1) != 0 )
  {
    v12 = a5;
    m64_u64 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a5->m64_u64);
    v109 = _m_pxor((__m64)0x8000000080000000uLL, a5[1]);
  }
  if ( (v20 & 0x10000) != 0 )
  {
    v112 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a7->m64_u64);
    v113 = _m_pxor((__m64)0x8000000080000000uLL, a7[1]);
  }
  v21 = a8[1];
  v22 = _m_pfadd(v112, (__m64)a8->m64_u64);
  v114 = (__m64)a8->m64_u64;
  v23 = _m_pfadd(v113, v21);
  v115 = v21;
  v24 = _m_pfsub(v112, (__m64)a8->m64_u64);
  v25 = _m_pfsub(v113, v21);
  v26 = _m_pfadd(_m_pfmul(v22, v22), _m_pfmul(v23, v23));
  v27 = _m_pfadd(_m_pfmul(v24, v24), _m_pfmul(v25, v25));
  if ( (_mm_cvtsi64_si32(_m_pfcmpgt(_m_pfacc(v27, v27), _m_pfacc(v26, v26))) & 1) != 0 )
  {
    v12 = a8;
    v114 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a8->m64_u64);
    v115 = _m_pxor((__m64)0x8000000080000000uLL, a8[1]);
  }
  v28 = _m_pfadd(_m_pfmul(v110, v110), _m_pfmul(v111, v111));
  v29 = _m_pfacc(v28, v28);
  v30 = _m_pfrcp(v29);
  v31 = _m_pfcmpgt(v29, (__m64)0x80000000800000LL);
  v32 = _m_pfrcpit2(_m_pfrcpit1(v29, v30), v30);
  v116 = _m_pfmul(_m_pand(_m_pxor(v110, (__m64)0x8000000080000000uLL), v31), v32);
  v118 = _m_pfmul(_m_pand(_m_pxor(v111, (__m64)0x80000000LL), v31), v32);
  v33 = _m_punpckldq(_m_punpckhdq(m64_u64, m64_u64), m64_u64);
  v34 = _m_punpckldq(_m_punpckhdq(v109, v109), v109);
  v126 = _m_pfacc(
           _m_pfsub(_m_pfmul(v33, v118), _m_pfmul(_m_pxor(v34, (__m64)0x80000000LL), v116)),
           _m_pfadd(_m_pxor(_m_pfmul(m64_u64, v118), (__m64)0x80000000LL), _m_pfmul(v109, v116)));
  v130 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v33, (__m64)0x80000000LL), v116), _m_pfmul(v34, v118)),
           _m_pfsub(_m_pfmul(_m_pxor(v109, (__m64)0x80000000LL), v118), _m_pfmul(m64_u64, v116)));
  v35 = _m_punpckldq(_m_punpckhdq(v112, v112), v112);
  v36 = _m_punpckldq(_m_punpckhdq(v113, v113), v113);
  v134 = _m_pfacc(
           _m_pfsub(_m_pfmul(v35, v118), _m_pfmul(_m_pxor(v36, (__m64)0x80000000LL), v116)),
           _m_pfadd(_m_pxor(_m_pfmul(v112, v118), (__m64)0x80000000LL), _m_pfmul(v113, v116)));
  v136 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v35, (__m64)0x80000000LL), v116), _m_pfmul(v36, v118)),
           _m_pfsub(_m_pfmul(_m_pxor(v113, (__m64)0x80000000LL), v118), _m_pfmul(v112, v116)));
  v37 = v126;
  v38 = v130;
  v39 = _m_punpckhdq(v130, v130);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v39, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v12);
    v102 = _mm_cvtsi64_si32(v39);
    sub_10035600();
    v12 = (__m64 *)m64_u64.m64_i32[1];
    v37 = v126;
    v38 = v130;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v39, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v40 = _mm_cvtsi32_si64(v102);
      v41 = _m_pfrcp(v39);
      v42 = _m_pfmul(_m_punpckldq(v40, v40), _m_pfrcpit2(_m_pfrcpit1(v39, v41), v41));
      v37 = _m_pfmul(v126, v42);
      v38 = _m_pfmul(v130, v42);
    }
  }
  v120 = v37;
  v122 = _m_pand(v38, (__m64)0xFFFFFFFFLL);
  v43 = v134;
  v44 = v136;
  v45 = _m_punpckhdq(v136, v136);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v45, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v12);
    v103 = _mm_cvtsi64_si32(v45);
    sub_10035600();
    v43 = v134;
    v44 = v136;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v45, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v46 = _mm_cvtsi32_si64(v103);
      v47 = _m_pfrcp(v45);
      v48 = _m_pfmul(_m_punpckldq(v46, v46), _m_pfrcpit2(_m_pfrcpit1(v45, v47), v47));
      v43 = _m_pfmul(v134, v48);
      v44 = _m_pfmul(v136, v48);
    }
  }
  v127 = _m_pfmul(_m_pfadd(v120, v43), (__m64)0xBE800000BE800000uLL);
  v131 = _m_pfmul(_m_pfadd(v122, _m_pand(v44, (__m64)0xFFFFFFFFLL)), (__m64)0xBE800000BE800000uLL).m64_u32[0];
  v49 = _mm_cvtsi32_si64(v131);
  v50 = _m_pfadd(_m_pfmul(v127, v127), _m_pfmul(v49, v49));
  v51 = _m_pfacc(v50, v50);
  v52 = _m_pfrsqrt(v51);
  v53 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v52, v52), v51), v52);
  v104.m64_u64 = __PAIR64__(a1, _mm_cvtsi64_si32(v53));
  sub_100354E0();
  v55 = _m_pfmul(v51, v53);
  v56 = _m_pfcmpge(_m_pand(v55, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  v57 = _mm_cvtsi64_si32(_m_punpckhdq(v56, v56));
  v58 = v127;
  v59 = v55;
  v60 = _m_pfmul(_m_punpckhdq(v55, v55), v104);
  v61 = _mm_cvtsi32_si64(v131);
  if ( (v57 & 1) != 0 )
  {
    v62 = _m_punpckldq(v60, v60);
    v61 = _m_pfmul(v61, v62);
    v58 = _m_pfmul(v127, v62);
  }
  v124 = _m_punpckldq(v61, v59);
  v63 = _m_punpckldq(_m_punpckhdq(v58, v58), v58);
  v64 = _m_punpckldq(_m_punpckhdq(v124, v124), v124);
  a2->m64_u64 = (unsigned __int64)_m_pfacc(
                                    _m_pfsub(_m_pfmul(v63, v111), _m_pfmul(_m_pxor(v64, (__m64)0x80000000LL), v110)),
                                    _m_pfadd(_m_pxor(_m_pfmul(v58, v111), (__m64)0x80000000LL), _m_pfmul(v124, v110)));
  a2[1].m64_u64 = (unsigned __int64)_m_pfacc(
                                      _m_pfadd(_m_pfmul(_m_pxor(v63, (__m64)0x80000000LL), v110), _m_pfmul(v64, v111)),
                                      _m_pfsub(_m_pfmul(_m_pxor(v124, (__m64)0x80000000LL), v111), _m_pfmul(v58, v110)));
  v65 = _m_pfadd(_m_pfmul(v112, v112), _m_pfmul(v113, v113));
  v66 = _m_pfacc(v65, v65);
  v67 = _m_pfrcp(v66);
  v68 = _m_pfcmpgt(v66, (__m64)0x80000000800000LL);
  v69 = _m_pfrcpit2(_m_pfrcpit1(v66, v67), v67);
  v117 = _m_pfmul(_m_pand(_m_pxor(v112, (__m64)0x8000000080000000uLL), v68), v69);
  v119 = _m_pfmul(_m_pand(_m_pxor(v113, (__m64)0x80000000LL), v68), v69);
  v70 = _m_punpckldq(_m_punpckhdq(v110, v110), v110);
  v71 = _m_punpckldq(_m_punpckhdq(v111, v111), v111);
  v128 = _m_pfacc(
           _m_pfsub(_m_pfmul(v70, v119), _m_pfmul(_m_pxor(v71, (__m64)0x80000000LL), v117)),
           _m_pfadd(_m_pxor(_m_pfmul(v110, v119), (__m64)0x80000000LL), _m_pfmul(v111, v117)));
  v132 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v70, (__m64)0x80000000LL), v117), _m_pfmul(v71, v119)),
           _m_pfsub(_m_pfmul(_m_pxor(v111, (__m64)0x80000000LL), v119), _m_pfmul(v110, v117)));
  v72 = _m_punpckldq(_m_punpckhdq(v114, v114), v114);
  v73 = _m_punpckldq(_m_punpckhdq(v115, v115), v115);
  v135 = _m_pfacc(
           _m_pfsub(_m_pfmul(v72, v119), _m_pfmul(_m_pxor(v73, (__m64)0x80000000LL), v117)),
           _m_pfadd(_m_pxor(_m_pfmul(v114, v119), (__m64)0x80000000LL), _m_pfmul(v115, v117)));
  v137 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v72, (__m64)0x80000000LL), v117), _m_pfmul(v73, v119)),
           _m_pfsub(_m_pfmul(_m_pxor(v115, (__m64)0x80000000LL), v119), _m_pfmul(v114, v117)));
  v74 = v128;
  v75 = v132;
  v76 = _m_punpckhdq(v132, v132);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v76, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v54);
    v105 = _mm_cvtsi64_si32(v76);
    sub_10035600();
    v54 = m64_u64.m64_i32[1];
    v74 = v128;
    v75 = v132;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v76, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v77 = _mm_cvtsi32_si64(v105);
      v78 = _m_pfrcp(v76);
      v79 = _m_pfmul(_m_punpckldq(v77, v77), _m_pfrcpit2(_m_pfrcpit1(v76, v78), v78));
      v74 = _m_pfmul(v128, v79);
      v75 = _m_pfmul(v132, v79);
    }
  }
  v121 = v74;
  v123 = _m_pand(v75, (__m64)0xFFFFFFFFLL);
  v80 = v135;
  v81 = v137;
  v82 = _m_punpckhdq(v137, v137);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v82, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v54);
    v106 = _mm_cvtsi64_si32(v82);
    sub_10035600();
    v80 = v135;
    v81 = v137;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v82, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v83 = _mm_cvtsi32_si64(v106);
      v84 = _m_pfrcp(v82);
      v85 = _m_pfmul(_m_punpckldq(v83, v83), _m_pfrcpit2(_m_pfrcpit1(v82, v84), v84));
      v80 = _m_pfmul(v135, v85);
      v81 = _m_pfmul(v137, v85);
    }
  }
  v129 = _m_pfmul(_m_pfadd(v121, v80), (__m64)0xBE800000BE800000uLL);
  v133 = _m_pfmul(_m_pfadd(v123, _m_pand(v81, (__m64)0xFFFFFFFFLL)), (__m64)0xBE800000BE800000uLL).m64_u32[0];
  v86 = _mm_cvtsi32_si64(v133);
  v87 = _m_pfadd(_m_pfmul(v129, v129), _m_pfmul(v86, v86));
  v88 = _m_pfacc(v87, v87);
  v89 = _m_pfrsqrt(v88);
  v90 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v89, v89), v88), v89);
  v107.m64_u64 = __PAIR64__(v104.m64_u32[1], _mm_cvtsi64_si32(v90));
  sub_100354E0();
  v91 = _m_pfmul(v88, v90);
  v92 = _m_pfcmpge(_m_pand(v91, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  v93 = _mm_cvtsi64_si32(_m_punpckhdq(v92, v92));
  v94 = v129;
  v95 = v91;
  v96 = _m_pfmul(_m_punpckhdq(v91, v91), v107);
  v97 = _mm_cvtsi32_si64(v133);
  if ( (v93 & 1) != 0 )
  {
    v98 = _m_punpckldq(v96, v96);
    v97 = _m_pfmul(v97, v98);
    v94 = _m_pfmul(v129, v98);
  }
  v125 = _m_punpckldq(v97, v95);
  v99 = _m_punpckldq(_m_punpckhdq(v94, v94), v94);
  v100 = _m_punpckldq(_m_punpckhdq(v125, v125), v125);
  a3->m64_u64 = (unsigned __int64)_m_pfacc(
                                    _m_pfsub(_m_pfmul(v99, v113), _m_pfmul(_m_pxor(v100, (__m64)0x80000000LL), v112)),
                                    _m_pfadd(_m_pxor(_m_pfmul(v94, v113), (__m64)0x80000000LL), _m_pfmul(v125, v112)));
  a3[1].m64_u64 = (unsigned __int64)_m_pfacc(
                                      _m_pfadd(_m_pfmul(_m_pxor(v99, (__m64)0x80000000LL), v112), _m_pfmul(v100, v113)),
                                      _m_pfsub(_m_pfmul(_m_pxor(v125, (__m64)0x80000000LL), v113), _m_pfmul(v94, v112)));
  a4->m64_u64 = (unsigned __int64)v112;
  a4[1].m64_u64 = (unsigned __int64)v113;
  _m_femms();
  return a4;
}

// sub_1002943A @ 0x1002943A
__m64 *__stdcall sub_1002943A(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm4
  __m64 v5; // mm5
  __m64 v6; // mm7
  __m64 v7; // mm1
  __m64 v8; // mm6
  __m64 v9; // mm4
  __m64 v10; // mm2
  __m64 v12; // mm5
  __m64 v13; // mm4
  __m64 v14; // mm4
  __m64 v15; // mm5
  __m64 v16; // mm4
  __m64 v17; // mm5
  __m64 v18; // mm4
  __m64 v19; // mm5
  __m64 v20; // [esp+0h] [ebp-44h]
  __m64 v21; // [esp+8h] [ebp-3Ch]
  __m64 v22; // [esp+10h] [ebp-34h]
  __m64 v23; // [esp+18h] [ebp-2Ch]
  __m64 v24; // [esp+28h] [ebp-1Ch]
  __m64 v25; // [esp+30h] [ebp-14h]
  __m64 v26; // [esp+38h] [ebp-Ch]

  _m_femms();
  v3 = a3[2];
  v4 = a3[7];
  v5 = a3[5];
  v20 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v22 = _m_punpckhdq((__m64)a3->m64_u64, v3);
  v6 = a3[3];
  v7 = a3[1];
  v24 = _m_punpckldq(v5, v4);
  v26 = _m_punpckhdq(v5, v4);
  v8 = _m_punpckldq(v7, v6);
  v9 = a3[6];
  v10 = a3[4];
  v25 = _m_punpckhdq(v7, v6);
  v23 = _m_punpckhdq(v10, v9);
  v21 = _m_punpckldq(v10, v9);
  v12 = a2[1];
  v13 = _m_pfadd(
          _m_pfacc(_m_pfmul((__m64)a2->m64_u64, v8), _m_pfmul((__m64)a2->m64_u64, v25)),
          _m_pfacc(_m_pfmul(v12, v24), _m_pfmul(v12, v26)));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfacc(_m_pfmul((__m64)a2->m64_u64, v20), _m_pfmul((__m64)a2->m64_u64, v22)),
                                    _m_pfacc(_m_pfmul(v12, v21), _m_pfmul(v12, v23)));
  a1[1].m64_u64 = (unsigned __int64)v13;
  v14 = a2[2];
  v15 = a2[3];
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v14, v20), _m_pfmul(v14, v22)),
                                      _m_pfacc(_m_pfmul(v15, v21), _m_pfmul(v15, v23)));
  a1[3].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v14, v8), _m_pfmul(v14, v25)),
                                      _m_pfacc(_m_pfmul(v15, v24), _m_pfmul(v15, v26)));
  v16 = a2[4];
  v17 = a2[5];
  a1[4].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v16, v20), _m_pfmul(v16, v22)),
                                      _m_pfacc(_m_pfmul(v17, v21), _m_pfmul(v17, v23)));
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v16, v8), _m_pfmul(v16, v25)),
                                      _m_pfacc(_m_pfmul(v17, v24), _m_pfmul(v17, v26)));
  v18 = a2[6];
  v19 = a2[7];
  a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, v20), _m_pfmul(v18, v22)),
                                      _m_pfacc(_m_pfmul(v19, v21), _m_pfmul(v19, v23)));
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, v8), _m_pfmul(v18, v25)),
                                      _m_pfacc(_m_pfmul(v19, v24), _m_pfmul(v19, v26)));
  _m_femms();
  return a1;
}

// sub_1002966C @ 0x1002966C
double __stdcall sub_1002966C(unsigned int *a1)
{
  __m64 v1; // mm0
  __m64 v2; // mm3
  __m64 v3; // mm4
  __m64 v4; // mm2
  __m64 v5; // mm3
  __m64 v6; // mm4

  v1 = *(__m64 *)(a1 + 9);
  v2 = *(__m64 *)(a1 + 13);
  v3 = _m_pfsub(
         _m_pfmul(_m_punpckhdq(*((__m64 *)a1 + 7), *((__m64 *)a1 + 7)), v1),
         _m_pfmul(_m_punpckhdq(*((__m64 *)a1 + 5), *((__m64 *)a1 + 5)), v2));
  v4 = _m_pfsub(
         _m_pfmul(_m_punpckldq(*((__m64 *)a1 + 4), *((__m64 *)a1 + 4)), *((__m64 *)a1 + 7)),
         _m_pfmul(_m_punpckldq(*((__m64 *)a1 + 6), *((__m64 *)a1 + 6)), *((__m64 *)a1 + 5)));
  v5 = _m_pfsub(_m_pfmul(v2, *((__m64 *)a1 + 4)), _m_pfmul(v1, *((__m64 *)a1 + 6)));
  v6 = _m_pfsub(
         _m_pfmul(
           _m_pfsub(
             _m_pfadd(
               _m_pfmul(v3, *((__m64 *)a1 + 2)),
               _m_pfmul(v5, _m_punpckhdq(*((__m64 *)a1 + 3), *((__m64 *)a1 + 3)))),
             _m_pfmul(_m_punpckldq(_m_punpckhdq(v4, v4), v3), *(__m64 *)(a1 + 5))),
           _m_punpckldq(*((__m64 *)a1 + 1), (__m64)*a1)),
         _m_pfmul(
           _m_pfsub(
             _m_pfadd(
               _m_pfmul(_m_punpckhdq(v5, v3), _m_punpckldq(*((__m64 *)a1 + 2), *((__m64 *)a1 + 2))),
               _m_pfmul(_m_punpckldq(v5, v4), *((__m64 *)a1 + 3))),
             _m_pfmul(v4, *(__m64 *)(a1 + 5))),
           _m_punpckhdq(*((__m64 *)a1 + 1), *(__m64 *)a1)));
  _m_femms();
  return COERCE_FLOAT(_mm_cvtsi64_si32(_m_pfacc(v6, v6)));
}

// sub_1002973B @ 0x1002973B
__m64 *__stdcall sub_1002973B(__m64 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  _m_femms();
  a1->m64_u64 = 1065353216;
  a1[1].m64_u64 = 0;
  a1[2].m64_u64 = 0x3F80000000000000LL;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = 1065353216;
  a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(_mm_cvtsi32_si64(a2), _mm_cvtsi32_si64(a3));
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(_mm_cvtsi32_si64(a4), (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_1002978B @ 0x1002978B
__m64 *__stdcall sub_1002978B(__m64 *a1, __m64 *a2, int a3)
{
  __m64 m64_u64; // mm6
  __m64 v5; // mm7
  __m64 v6; // mm3
  __m64 v7; // mm1
  __m64 v8; // mm0
  __m64 v9; // mm2
  __m64 v10; // mm1
  __m64 v11; // mm3
  __m64 v12; // mm1
  __m64 v13; // mm3
  __m64 v14; // [esp+0h] [ebp-14h] BYREF
  __m64 v15; // [esp+8h] [ebp-Ch]

  _m_femms();
  sub_1002E578((int)&v14, a3);
  m64_u64 = (__m64)a2->m64_u64;
  v5 = a2[1];
  v6 = _m_pfmul(v5, v15);
  v7 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, v14), v6);
  v8 = _m_pxor(v14, (__m64)0x8000000080000000uLL);
  v9 = _m_pxor(v15, (__m64)0x8000000080000000uLL);
  v10 = _m_pfacc(v7, v7);
  v11 = _m_punpckldq(v6, v10);
  v12 = _m_psllqi(v10, 0x20u);
  v13 = _m_psrlqi(v11, 0x20u);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckldq(v8, v8), (__m64)a2->m64_u64), v13);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckldq(v8, v8), v5);
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckhdq(v8, v8), m64_u64), v12);
  a1[3].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckhdq(v8, v8), v5);
  a1[4].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckldq(v9, v9), m64_u64);
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckldq(v9, v9), v5), v13);
  a1[6].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckhdq(v9, v9), m64_u64);
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckhdq(v9, v9), v5), v12);
  _m_femms();
  return a1;
}

// sub_10029876 @ 0x10029876
__m64 *__stdcall sub_10029876(__m64 *a1, int a2)
{
  __m64 v3; // mm3
  __m64 v4; // mm0
  __m64 v5; // mm1
  __m64 v6; // mm6
  __m64 v7; // mm4
  __m64 v8; // mm6
  __m64 v9; // mm4
  __m64 v10; // mm6
  __m64 v11; // [esp+0h] [ebp-14h] BYREF
  __m64 v12; // [esp+8h] [ebp-Ch]

  _m_femms();
  sub_1002E578((int)&v11, a2);
  v3 = v12;
  v4 = _m_pfmul(v11, (__m64)0xC0000000C0000000uLL);
  v5 = _m_pfmul(v12, (__m64)0x3F800000C0000000LL);
  v6 = v11;
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckhdq(v6, v6);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(v7, v4), (__m64)1065353216LL);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_psrlqi(v7, 0x20u), v5);
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(v8, v4), (__m64)0x3F80000000000000LL);
  a1[3].m64_u64 = (unsigned __int64)_m_pfmul(_m_psrlqi(v8, 0x20u), v5);
  v9 = _m_punpckldq(v3, v3);
  v10 = _m_punpckhdq(v3, v3);
  a1[4].m64_u64 = (unsigned __int64)_m_pfmul(v9, v4);
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_psrlqi(v9, 0x20u), v5), (__m64)1065353216LL);
  a1[6].m64_u64 = (unsigned __int64)_m_pfmul(v10, v4);
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_psrlqi(v10, 0x20u), v5), (__m64)0x3F80000000000000LL);
  _m_femms();
  return a1;
}

// sub_10029952 @ 0x10029952
__m64 *__stdcall sub_10029952(__m64 *a1, unsigned int a2)
{
  __m64 v2; // mm0
  __m64 v4; // mm4

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2);
  sub_100354E0();
  v4 = _m_psrlqi(v2, 0x20u);
  a1->m64_u64 = 1065353216;
  a1[1].m64_u64 = 0;
  a1[2].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[2].m64_i32[1] = _mm_cvtsi64_si32(v2);
  a1[3].m64_u64 = (unsigned __int64)v4;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[4].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[4].m64_i32[1] = _mm_cvtsi64_si32(_m_pxor(v4, (__m64)0x80000000LL));
  a1[5].m64_i32[0] = _mm_cvtsi64_si32(v2);
  a1[5].m64_i32[1] = _mm_cvtsi64_si32(0);
  _m_femms();
  return a1;
}

// sub_100299B5 @ 0x100299B5
__m64 *__stdcall sub_100299B5(__m64 *a1, unsigned int a2)
{
  __m64 v3; // mm4
  __m64 v4; // mm0
  __m64 v5; // mm4

  _m_femms();
  sub_100354E0();
  v3 = _mm_cvtsi32_si64(a2);
  v4 = _m_pand(v3, (__m64)0xFFFFFFFFLL);
  v5 = _m_psrlqi(v3, 0x20u);
  a1[2].m64_u64 = 0x3F80000000000000LL;
  a1[3].m64_u64 = 0;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[4].m64_u64 = (unsigned __int64)v5;
  a1->m64_u64 = (unsigned __int64)v4;
  a1[5].m64_u64 = (unsigned __int64)v4;
  a1[1].m64_u64 = (unsigned __int64)_m_pxor(v5, (__m64)0x80000000LL);
  _m_femms();
  return a1;
}

// sub_10029A13 @ 0x10029A13
__m64 *__stdcall sub_10029A13(__m64 *a1, unsigned int a2)
{
  __m64 v2; // mm0

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2);
  sub_100354E0();
  a1->m64_u64 = (unsigned __int64)v2;
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = 1065353216;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[2].m64_u64 = (unsigned __int64)_m_pxor(_m_punpckldq(_m_punpckhdq(v2, v2), v2), (__m64)0x80000000LL);
  _m_femms();
  return a1;
}

// sub_10029A6C @ 0x10029A6C
__m64 *__stdcall sub_10029A6C(__m64 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  _m_femms();
  a1->m64_u64 = (unsigned __int64)_mm_cvtsi32_si64(a2);
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[6].m64_u64 = 0;
  a1[2].m64_u64 = (unsigned __int64)_m_psllqi(_mm_cvtsi32_si64(a3), 0x20u);
  a1[5].m64_u64 = (unsigned __int64)_mm_cvtsi32_si64(a4);
  a1[7].m64_u64 = 0x3F80000000000000LL;
  _m_femms();
  return a1;
}

// sub_10029AB3 @ 0x10029AB3
__m64 *__stdcall sub_10029AB3(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm1
  __m64 v3; // mm4
  __m64 v5; // mm2
  __m64 v6; // mm5
  __m64 v7; // mm7
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm4

  v2 = a2[2];
  v3 = a2[7];
  v5 = _m_punpckhdq((__m64)a2->m64_u64, v2);
  v6 = a2[5];
  a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a2->m64_u64, v2);
  a1[2].m64_u64 = (unsigned __int64)v5;
  v7 = a2[3];
  v8 = a2[4];
  v9 = a2[1];
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(v6, v3);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v6, v3);
  v10 = a2[6];
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v9, v7);
  a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v9, v7);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v8, v10);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(v8, v10);
  _m_femms();
  return a1;
}

// sub_10029B22 @ 0x10029B22
__m64 *__cdecl sub_10029B22(__m64 *a1)
{
  __m64 v1; // mm1
  __m64 v3; // mm2

  v1 = _mm_cvtsi32_si64(0x3F800000u);
  a1->m64_u64 = (unsigned __int64)v1;
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = (unsigned __int64)v1;
  v3 = _m_punpckldq(_m_punpckhdq(v1, v1), v1);
  a1[6].m64_u64 = 0;
  a1[2].m64_u64 = (unsigned __int64)v3;
  a1[7].m64_u64 = (unsigned __int64)v3;
  _m_femms();
  return a1;
}

// sub_10029B5B @ 0x10029B5B
__m64 *__stdcall sub_10029B5B(__m64 *a1, __m64 *a2)
{
  __m64 m64_u64; // mm3
  __m64 v4; // mm0
  __m64 v5; // mm7
  __m64 v6; // mm2
  __m64 v7; // mm4
  __m64 v8; // mm3
  __m64 v9; // mm1
  __m64 v10; // mm5
  __m64 v11; // mm7
  __m64 v12; // mm6
  __m64 v13; // mm2
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm7
  __m64 v17; // mm3
  __m64 v18; // mm2
  __m64 v19; // mm3
  __m64 v20; // mm5
  __m64 v21; // mm6

  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_pfadd(m64_u64, m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckhdq(v5, v5);
  v8 = _m_pfmul((__m64)a2->m64_u64, v4);
  v9 = _m_punpckldq(_m_pfadd(v5, v5), v4);
  v10 = _m_pfmul(v4, v7);
  v11 = _m_pfmul(_m_punpckldq(v5, v5), v9);
  v12 = _m_pfmul(v9, v7);
  v13 = _m_pfmul(v9, v6);
  v14 = _m_punpckhdq(v13, v11);
  a1[6].m64_u64 = 0;
  v15 = _m_punpckhdq(_m_punpckldq(v12, v12), v10);
  v16 = _m_pfsubr(_m_pfadd(_m_punpckldq(v11, v11), v8), (__m64)0x3F8000003F800000LL);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsubr(_m_pfacc(v8, v8), (__m64)0x3F8000003F800000LL), 0);
  v17 = v13;
  v18 = _m_pfadd(v13, v10);
  v19 = _m_pfsub(v17, v10);
  v20 = _m_pfsub(v14, v15);
  v21 = _m_pfadd(v14, v15);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v18, 0);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v20, 0);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v20, v16);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v16, _m_punpckldq(v21, v21));
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpckhdq(v21, v21), v19);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_10029C2D @ 0x10029C2D
__m64 *__stdcall sub_10029C2D(__m64 *a1, __m64 *a2)
{
  __m64 v3; // mm4
  __m64 v4; // mm1
  __m64 v5; // mm5
  __m64 v6; // mm0
  __m64 v7; // mm5
  __m64 v8; // mm2
  __m64 v9; // mm3
  __m64 v10; // mm1
  __m64 v11; // mm6
  __m64 v12; // mm3
  __m64 v13; // mm6
  __m64 v14; // mm2
  __m64 v15; // mm1

  v3 = a2[1];
  v4 = _m_pfadd(v3, v3);
  v5 = _m_pfadd((__m64)a2->m64_u64, (__m64)a2->m64_u64);
  v6 = _m_pfmul(v5, (__m64)a2->m64_u64);
  v7 = _m_punpckldq(v5, v4);
  v8 = _m_pfmul((__m64)a2->m64_u64, v4);
  v9 = _m_pfmul(_m_pswapd((__m64)a2->m64_u64), v4);
  v10 = _m_pfmul(v4, v3);
  v11 = _m_pfmul(_m_punpckhdq((__m64)a2->m64_u64, v3), v7);
  v12 = _m_pfpnacc(v9, v9);
  v13 = _m_pfpnacc(v11, v11);
  v14 = _m_pfpnacc(v8, v8);
  v15 = _m_pfsub(_m_pfsubr(v6, (__m64)0x3F8000003F800000LL), _m_punpckldq(v10, v10));
  a1[6].m64_u64 = 0;
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pswapd(v14), v12);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(v14, 0);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(_m_pfsubr(_m_pfacc(v6, v6), (__m64)0x3F8000003F800000LL), 0);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v15, v13);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v13, v15);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v12, 0);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_10029CE2 @ 0x10029CE2
__m64 *__stdcall sub_10029CE2(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, __m64 *a6, __m64 *a7)
{
  __m64 *result; // eax
  __m64 m64_u64; // mm3
  __m64 v9; // mm0
  __m64 v10; // mm7
  __m64 v11; // mm2
  __m64 v12; // mm4
  __m64 v13; // mm3
  __m64 v14; // mm1
  __m64 v15; // mm5
  __m64 v16; // mm7
  __m64 v17; // mm6
  __m64 v18; // mm2
  __m64 v19; // mm1
  __m64 v20; // mm6
  __m64 v21; // mm7
  __m64 v22; // mm3
  __m64 v23; // mm2
  __m64 v24; // mm3
  __m64 v25; // mm5
  __m64 v26; // mm6
  __m64 v27; // mm3
  __m64 v28; // mm4
  __m64 v29; // mm1
  __m64 v30; // mm2
  __m64 v31; // mm2
  __m64 v32; // mm1
  __m64 v33; // mm2
  __m64 v34; // mm3
  __m64 v35; // mm0
  __m64 v36; // mm1
  __m64 v37; // mm2
  __m64 v38; // mm5
  __m64 v39; // mm3
  __m64 v40; // mm2
  __m64 v41; // mm7
  __m64 v42; // mm0
  __m64 v43; // mm3
  __m64 v44; // mm1
  __m64 v45; // mm2
  __m64 v46; // mm3
  __m64 v47; // mm0
  __m64 v48; // mm1
  __m64 v49; // mm2
  __m64 v50; // mm5
  __m64 v51; // mm3
  __m64 v52; // mm2
  __m64 v53; // mm7
  __m64 v54; // mm0
  __m64 v55; // mm3
  __m64 v56; // mm1
  __m64 v57; // mm2
  __m64 v58; // mm3
  __m64 v59; // mm0
  __m64 v60; // mm1
  __m64 v61; // mm2
  __m64 v62; // mm5
  __m64 v63; // mm3
  __m64 v64; // mm2
  __m64 v65; // mm7
  __m64 v66; // mm0
  __m64 v67; // mm3
  __m64 v68; // mm1
  __m64 v69; // mm2
  __m64 v70; // mm3
  __m64 v71; // mm0
  __m64 v72; // mm1
  __m64 v73; // mm2
  __m64 v74; // mm5
  __m64 v75; // mm3
  __m64 v76; // mm7
  __m64 v77; // mm2
  __m64 v78; // mm3
  __m64 v79; // mm1
  __m64 v80; // mm2
  __m64 v81; // mm3
  __m64 v82; // mm0
  __m64 v83; // mm1
  __m64 v84; // mm2
  __m64 v85; // mm5
  __m64 v86; // mm3
  __m64 v87; // mm2
  __m64 v88; // mm7
  __m64 v89; // mm0
  __m64 v90; // mm3
  __m64 v91; // mm1
  __m64 v92; // mm2
  __m64 v93; // mm3
  __m64 v94; // mm0
  __m64 v95; // mm1
  __m64 v96; // mm2
  __m64 v97; // mm5
  __m64 v98; // mm3
  __m64 v99; // mm2
  __m64 v100; // mm7
  __m64 v101; // mm0
  __m64 v102; // mm3
  __m64 v103; // mm1
  __m64 v104; // mm2
  __m64 v105; // mm3
  __m64 v106; // mm0
  __m64 v107; // mm1
  __m64 v108; // mm2
  __m64 v109; // mm5
  __m64 v110; // mm3
  __m64 v111; // mm2
  __m64 v112; // mm7
  __m64 v113; // mm0
  __m64 v114; // mm3
  __m64 v115; // mm1
  __m64 v116; // mm2
  __m64 v117; // mm3
  __m64 v118; // mm0
  __m64 v119; // mm1
  __m64 v120; // mm2
  __m64 v121; // mm5
  __m64 v122; // mm3
  __m64 v123; // mm7
  __m64 v124; // mm2
  __m64 v125; // mm3
  __m64 v126; // mm1
  __m64 v127; // mm2
  __m64 v128; // mm3
  __m64 v129; // mm0
  __m64 v130; // mm1
  __m64 v131; // mm2
  __m64 v132; // mm5
  __m64 v133; // mm3
  __m64 v134; // mm2
  __m64 v135; // mm7
  __m64 v136; // mm0
  __m64 v137; // mm3
  __m64 v138; // mm1
  __m64 v139; // mm2
  __m64 v140; // mm3
  __m64 v141; // mm0
  __m64 v142; // mm1
  __m64 v143; // mm2
  __m64 v144; // mm5
  __m64 v145; // mm3
  __m64 v146; // mm2
  __m64 v147; // mm7
  __m64 v148; // mm0
  __m64 v149; // mm3
  __m64 v150; // mm1
  __m64 v151; // mm2
  __m64 v152; // mm3
  __m64 v153; // mm0
  __m64 v154; // mm1
  __m64 v155; // mm2
  __m64 v156; // mm5
  __m64 v157; // mm3
  __m64 v158; // mm2
  __m64 v159; // mm7
  __m64 v160; // mm0
  __m64 v161; // mm3
  __m64 v162; // mm1
  __m64 v163; // mm2
  __m64 v164; // mm3
  __m64 v165; // mm0
  __m64 v166; // mm1
  __m64 v167; // mm2
  __m64 v168; // mm3
  __m64 v169; // mm2
  __m64 v170; // mm3
  __m64 v171; // mm2
  __m64 v172; // mm1
  __m64 v173; // mm2
  __m64 v174; // mm3
  __m64 v175; // mm0
  __m64 v176; // mm1
  __m64 v177; // mm2
  __m64 v178; // mm5
  __m64 v179; // mm3
  __m64 v180; // mm2
  __m64 v181; // mm7
  __m64 v182; // mm0
  __m64 v183; // mm3
  __m64 v184; // mm1
  __m64 v185; // mm2
  __m64 v186; // mm3
  __m64 v187; // mm0
  __m64 v188; // mm1
  __m64 v189; // mm2
  __m64 v190; // mm5
  __m64 v191; // mm3
  __m64 v192; // mm2
  __m64 v193; // mm7
  __m64 v194; // mm0
  __m64 v195; // mm3
  __m64 v196; // mm1
  __m64 v197; // mm2
  __m64 v198; // mm3
  __m64 v199; // mm0
  __m64 v200; // mm1
  __m64 v201; // mm2
  __m64 v202; // mm5
  __m64 v203; // mm3
  __m64 v204; // mm2
  __m64 v205; // mm7
  __m64 v206; // mm0
  __m64 v207; // mm3
  __m64 v208; // mm1
  __m64 v209; // mm2
  __m64 v210; // mm3
  __m64 v211; // mm0
  __m64 v212; // mm1
  __m64 v213; // mm2
  __m64 v214; // mm5
  __m64 v215; // mm3
  __m64 v216; // mm7
  __m64 v217; // mm2
  __m64 v218; // mm3
  __m64 v219; // mm1
  __m64 v220; // mm2
  __m64 v221; // mm3
  __m64 v222; // mm0
  __m64 v223; // mm1
  __m64 v224; // mm2
  __m64 v225; // mm5
  __m64 v226; // mm3
  __m64 v227; // mm2
  __m64 v228; // mm7
  __m64 v229; // mm0
  __m64 v230; // mm3
  __m64 v231; // mm1
  __m64 v232; // mm2
  __m64 v233; // mm3
  __m64 v234; // mm0
  __m64 v235; // mm1
  __m64 v236; // mm2
  __m64 v237; // mm5
  __m64 v238; // mm3
  __m64 v239; // mm2
  __m64 v240; // mm7
  __m64 v241; // mm0
  __m64 v242; // mm3
  __m64 v243; // mm1
  __m64 v244; // mm2
  __m64 v245; // mm3
  __m64 v246; // mm0
  __m64 v247; // mm1
  __m64 v248; // mm2
  __m64 v249; // mm5
  __m64 v250; // mm3
  __m64 v251; // mm2
  __m64 v252; // mm7
  __m64 v253; // mm0
  __m64 v254; // mm3
  __m64 v255; // mm1
  __m64 v256; // mm2
  __m64 v257; // mm3
  __m64 v258; // mm0
  __m64 v259; // mm1
  __m64 v260; // mm2
  __m64 v261; // mm3
  __m64 v262; // mm4
  __m64 v263; // mm5
  __m64 v264; // mm1
  __m64 v265; // mm2
  __m64 v266; // mm3
  __m64 v267; // mm0
  __m64 v268; // mm7
  __m64 v269; // mm2
  __m64 v270; // mm4
  __m64 v271; // mm3
  __m64 v272; // mm1
  __m64 v273; // mm5
  __m64 v274; // mm7
  __m64 v275; // mm6
  __m64 v276; // mm2
  __m64 v277; // mm1
  __m64 v278; // mm6
  __m64 v279; // mm7
  __m64 v280; // mm3
  __m64 v281; // mm2
  __m64 v282; // mm3
  __m64 v283; // mm5
  __m64 v284; // mm2
  __m64 v285; // mm6
  __m64 v286; // mm2
  __m64 v287; // mm3
  __m64 v288; // mm1
  __m64 v289; // mm1
  __m64 v290; // mm2
  __m64 v291; // mm3
  __m64 v292; // mm0
  __m64 v293; // mm1
  __m64 v294; // mm2
  __m64 v295; // mm5
  __m64 v296; // mm3
  __m64 v297; // mm2
  __m64 v298; // mm7
  __m64 v299; // mm0
  __m64 v300; // mm3
  __m64 v301; // mm1
  __m64 v302; // mm2
  __m64 v303; // mm3
  __m64 v304; // mm0
  __m64 v305; // mm1
  __m64 v306; // mm2
  __m64 v307; // mm5
  __m64 v308; // mm3
  __m64 v309; // mm2
  __m64 v310; // mm7
  __m64 v311; // mm0
  __m64 v312; // mm3
  __m64 v313; // mm1
  __m64 v314; // mm2
  __m64 v315; // mm3
  __m64 v316; // mm0
  __m64 v317; // mm1
  __m64 v318; // mm2
  __m64 v319; // mm5
  __m64 v320; // mm3
  __m64 v321; // mm2
  __m64 v322; // mm7
  __m64 v323; // mm0
  __m64 v324; // mm3
  __m64 v325; // mm1
  __m64 v326; // mm2
  __m64 v327; // mm3
  __m64 v328; // mm0
  __m64 v329; // mm1
  __m64 v330; // mm2
  __m64 v331; // mm3
  __m64 v332; // mm1
  __m64 v333; // mm1
  __m64 v334; // mm2
  __m64 v335; // mm3
  __m64 v336; // mm0
  __m64 v337; // mm1
  __m64 v338; // mm2
  __m64 v339; // mm5
  __m64 v340; // mm3
  __m64 v341; // mm2
  __m64 v342; // mm7
  __m64 v343; // mm0
  __m64 v344; // mm3
  __m64 v345; // mm1
  __m64 v346; // mm2
  __m64 v347; // mm3
  __m64 v348; // mm0
  __m64 v349; // mm1
  __m64 v350; // mm2
  __m64 v351; // mm5
  __m64 v352; // mm3
  __m64 v353; // mm2
  __m64 v354; // mm7
  __m64 v355; // mm0
  __m64 v356; // mm3
  __m64 v357; // mm1
  __m64 v358; // mm2
  __m64 v359; // mm3
  __m64 v360; // mm0
  __m64 v361; // mm1
  __m64 v362; // mm2
  __m64 v363; // mm5
  __m64 v364; // mm3
  __m64 v365; // mm2
  __m64 v366; // mm7
  __m64 v367; // mm0
  __m64 v368; // mm3
  __m64 v369; // mm1
  __m64 v370; // mm2
  __m64 v371; // mm3
  __m64 v372; // mm0
  __m64 v373; // mm1
  __m64 v374; // mm2
  __m64 v375; // mm3
  __m64 v376; // mm1
  __m64 v377; // [esp+0h] [ebp-C0h]
  __m64 v378; // [esp+10h] [ebp-B0h]
  __m64 v379; // [esp+28h] [ebp-98h]
  __m64 v380; // [esp+40h] [ebp-80h]
  __m64 v381; // [esp+40h] [ebp-80h]
  __m64 v382; // [esp+48h] [ebp-78h]
  __m64 v383; // [esp+48h] [ebp-78h]
  __m64 v384; // [esp+50h] [ebp-70h]
  __m64 v385; // [esp+50h] [ebp-70h]
  __m64 v386; // [esp+58h] [ebp-68h]
  __m64 v387; // [esp+58h] [ebp-68h]
  __m64 v388; // [esp+60h] [ebp-60h]
  __m64 v389; // [esp+60h] [ebp-60h]
  __m64 v390; // [esp+68h] [ebp-58h]
  __m64 v391; // [esp+68h] [ebp-58h]
  __m64 v392; // [esp+78h] [ebp-48h]
  __m64 v393; // [esp+78h] [ebp-48h]
  __m64 v394; // [esp+80h] [ebp-40h]
  __m64 v395; // [esp+88h] [ebp-38h]
  __m64 v396; // [esp+90h] [ebp-30h]
  __m64 v397; // [esp+98h] [ebp-28h]
  __m64 v398; // [esp+A0h] [ebp-20h]
  __m64 v399; // [esp+A8h] [ebp-18h]
  __m64 v400; // [esp+B0h] [ebp-10h]
  __m64 v401; // [esp+B8h] [ebp-8h]

  result = a1;
  if ( a4 )
  {
    if ( a3 )
    {
      v377 = _m_punpckldq((__m64)a4->m64_u64, 0);
      v378 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      v379 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      m64_u64 = (__m64)a3->m64_u64;
      v9 = _m_pfadd(m64_u64, m64_u64);
      v10 = a3[1];
      v11 = _m_punpckhdq(m64_u64, m64_u64);
      v12 = _m_punpckhdq(v10, v10);
      v13 = _m_pfmul((__m64)a3->m64_u64, v9);
      v14 = _m_punpckldq(_m_pfadd(v10, v10), v9);
      v15 = _m_pfmul(v9, v12);
      v16 = _m_pfmul(_m_punpckldq(v10, v10), v14);
      v17 = _m_pfmul(v14, v12);
      v18 = _m_pfmul(v14, v11);
      v19 = _m_punpckhdq(v18, v16);
      v20 = _m_punpckhdq(_m_punpckldq(v17, v17), v15);
      v21 = _m_pfsubr(_m_pfadd(_m_punpckldq(v16, v16), v13), (__m64)0x3F8000003F800000LL);
      v390 = _m_punpckldq(_m_pfsubr(_m_pfacc(v13, v13), (__m64)0x3F8000003F800000LL), 0);
      v22 = v18;
      v23 = _m_pfadd(v18, v15);
      v24 = _m_pfsub(v22, v15);
      v25 = _m_pfsub(v19, v20);
      v26 = _m_pfadd(v19, v20);
      v386 = _m_punpckldq(v23, 0);
      v382 = _m_punpckhdq(v25, 0);
      v384 = _m_punpckldq(v25, v21);
      v380 = _m_punpckhdq(v21, _m_punpckldq(v26, v26));
      v388 = _m_punpckldq(_m_punpckhdq(v26, v26), v24);
      v392 = _m_punpckldq(0, (__m64)1065353216LL);
      if ( a2 )
      {
        v394 = _m_punpckldq(v380, v384);
        v396 = _m_punpckhdq(v380, v384);
        v399 = _m_punpckldq(v390, v392);
        v401 = _m_punpckhdq(v390, v392);
        v398 = _m_punpckldq(v382, v386);
        v400 = _m_punpckhdq(v382, v386);
        v397 = _m_punpckhdq(v388, 0);
        v395 = _m_punpckldq(v388, 0);
        result = a1;
        v27 = (__m64)a2->m64_u64;
        v28 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
        v29 = _mm_cvtsi32_si64(0x3F800000u);
        v30 = _m_punpckldq(_m_punpckhdq(v29, v29), v29);
        a1->m64_u64 = (unsigned __int64)v29;
        a1[1].m64_u64 = 0;
        a1[2].m64_u64 = (unsigned __int64)v30;
        a1[3].m64_u64 = 0;
        a1[4].m64_u64 = 0;
        a1[5].m64_u64 = (unsigned __int64)v29;
        v31 = _m_pfsub(v30, v28);
        a1[7].m64_u64 = (unsigned __int64)v31;
        a1[6].m64_u64 = (unsigned __int64)_m_pfsub(0, v27);
        v32 = a1[1];
        v33 = _m_punpckhdq(v31, (__m64)a1->m64_u64);
        v34 = _m_punpckhdq(v27, v32);
        v35 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v36 = _m_punpckldq(v32, v32);
        v37 = _m_punpckhdq(v33, v33);
        v38 = _m_pfmul(v396, v37);
        v39 = _m_punpckhdq(v34, v34);
        v40 = _m_pfadd(_m_pfadd(_m_pfmul(v37, v397), _m_pfmul(v35, v395)), _m_pfmul(v36, v399));
        v41 = _m_pfadd(_m_pfmul(v400, v39), _m_pfadd(_m_pfmul(v398, v36), _m_pfadd(v38, _m_pfmul(v394, v35))));
        v42 = a1[2];
        v43 = _m_pfadd(_m_pfmul(v39, v401), v40);
        v44 = a1[3];
        a1->m64_u64 = (unsigned __int64)v41;
        a1[1].m64_u64 = (unsigned __int64)v43;
        v45 = _m_punpckhdq(v40, v42);
        v46 = _m_punpckhdq(v43, v44);
        v47 = _m_punpckldq(v42, v42);
        v48 = _m_punpckldq(v44, v44);
        v49 = _m_punpckhdq(v45, v45);
        v50 = _m_pfmul(v396, v49);
        v51 = _m_punpckhdq(v46, v46);
        v52 = _m_pfadd(_m_pfadd(_m_pfmul(v49, v397), _m_pfmul(v47, v395)), _m_pfmul(v48, v399));
        v53 = _m_pfadd(_m_pfmul(v400, v51), _m_pfadd(_m_pfmul(v398, v48), _m_pfadd(v50, _m_pfmul(v394, v47))));
        v54 = a1[4];
        v55 = _m_pfadd(_m_pfmul(v51, v401), v52);
        v56 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v53;
        a1[3].m64_u64 = (unsigned __int64)v55;
        v57 = _m_punpckhdq(v52, v54);
        v58 = _m_punpckhdq(v55, v56);
        v59 = _m_punpckldq(v54, v54);
        v60 = _m_punpckldq(v56, v56);
        v61 = _m_punpckhdq(v57, v57);
        v62 = _m_pfmul(v396, v61);
        v63 = _m_punpckhdq(v58, v58);
        v64 = _m_pfadd(_m_pfadd(_m_pfmul(v61, v397), _m_pfmul(v59, v395)), _m_pfmul(v60, v399));
        v65 = _m_pfadd(_m_pfmul(v400, v63), _m_pfadd(_m_pfmul(v398, v60), _m_pfadd(v62, _m_pfmul(v394, v59))));
        v66 = a1[6];
        v67 = _m_pfadd(_m_pfmul(v63, v401), v64);
        v68 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v65;
        a1[5].m64_u64 = (unsigned __int64)v67;
        v69 = _m_punpckhdq(v64, v66);
        v70 = _m_punpckhdq(v67, v68);
        v71 = _m_punpckldq(v66, v66);
        v72 = _m_punpckldq(v68, v68);
        v73 = _m_punpckhdq(v69, v69);
        v74 = _m_pfmul(v396, v73);
        v75 = _m_punpckhdq(v70, v70);
        v76 = _m_pfmul(v400, v75);
        v77 = _m_pfadd(_m_pfadd(_m_pfmul(v73, v397), _m_pfmul(v71, v395)), _m_pfmul(v72, v399));
        v78 = _m_pfadd(_m_pfmul(v75, v401), v77);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v76,
                                            _m_pfadd(_m_pfmul(v398, v72), _m_pfadd(v74, _m_pfmul(v394, v71))));
        a1[7].m64_u64 = (unsigned __int64)v78;
        v79 = a1[1];
        v80 = _m_punpckhdq(v77, (__m64)a1->m64_u64);
        v81 = _m_punpckhdq(v78, v79);
        v82 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v83 = _m_punpckldq(v79, v79);
        v84 = _m_punpckhdq(v80, v80);
        v85 = _m_pfmul(v378, v84);
        v86 = _m_punpckhdq(v81, v81);
        v87 = _m_pfadd(_m_pfadd(_m_pfmul(v84, 0), _m_pfmul(v82, 0)), _m_pfmul(v83, v379));
        v88 = _m_pfadd(_m_pfmul(0, v86), _m_pfadd(_m_pfmul(0, v83), _m_pfadd(v85, _m_pfmul(v377, v82))));
        v89 = a1[2];
        v90 = _m_pfadd(_m_pfmul(v86, (__m64)0x3F80000000000000LL), v87);
        v91 = a1[3];
        a1->m64_u64 = (unsigned __int64)v88;
        a1[1].m64_u64 = (unsigned __int64)v90;
        v92 = _m_punpckhdq(v87, v89);
        v93 = _m_punpckhdq(v90, v91);
        v94 = _m_punpckldq(v89, v89);
        v95 = _m_punpckldq(v91, v91);
        v96 = _m_punpckhdq(v92, v92);
        v97 = _m_pfmul(v378, v96);
        v98 = _m_punpckhdq(v93, v93);
        v99 = _m_pfadd(_m_pfadd(_m_pfmul(v96, 0), _m_pfmul(v94, 0)), _m_pfmul(v95, v379));
        v100 = _m_pfadd(_m_pfmul(0, v98), _m_pfadd(_m_pfmul(0, v95), _m_pfadd(v97, _m_pfmul(v377, v94))));
        v101 = a1[4];
        v102 = _m_pfadd(_m_pfmul(v98, (__m64)0x3F80000000000000LL), v99);
        v103 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v100;
        a1[3].m64_u64 = (unsigned __int64)v102;
        v104 = _m_punpckhdq(v99, v101);
        v105 = _m_punpckhdq(v102, v103);
        v106 = _m_punpckldq(v101, v101);
        v107 = _m_punpckldq(v103, v103);
        v108 = _m_punpckhdq(v104, v104);
        v109 = _m_pfmul(v378, v108);
        v110 = _m_punpckhdq(v105, v105);
        v111 = _m_pfadd(_m_pfadd(_m_pfmul(v108, 0), _m_pfmul(v106, 0)), _m_pfmul(v107, v379));
        v112 = _m_pfadd(_m_pfmul(0, v110), _m_pfadd(_m_pfmul(0, v107), _m_pfadd(v109, _m_pfmul(v377, v106))));
        v113 = a1[6];
        v114 = _m_pfadd(_m_pfmul(v110, (__m64)0x3F80000000000000LL), v111);
        v115 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v112;
        a1[5].m64_u64 = (unsigned __int64)v114;
        v116 = _m_punpckhdq(v111, v113);
        v117 = _m_punpckhdq(v114, v115);
        v118 = _m_punpckldq(v113, v113);
        v119 = _m_punpckldq(v115, v115);
        v120 = _m_punpckhdq(v116, v116);
        v121 = _m_pfmul(v378, v120);
        v122 = _m_punpckhdq(v117, v117);
        v123 = _m_pfmul(0, v122);
        v124 = _m_pfadd(_m_pfadd(_m_pfmul(v120, 0), _m_pfmul(v118, 0)), _m_pfmul(v119, v379));
        v125 = _m_pfadd(_m_pfmul(v122, (__m64)0x3F80000000000000LL), v124);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v123,
                                            _m_pfadd(_m_pfmul(0, v119), _m_pfadd(v121, _m_pfmul(v377, v118))));
        a1[7].m64_u64 = (unsigned __int64)v125;
        v126 = a1[1];
        v127 = _m_punpckhdq(v124, (__m64)a1->m64_u64);
        v128 = _m_punpckhdq(v125, v126);
        v129 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v130 = _m_punpckldq(v126, v126);
        v131 = _m_punpckhdq(v127, v127);
        v132 = _m_pfmul(v384, v131);
        v133 = _m_punpckhdq(v128, v128);
        v134 = _m_pfadd(_m_pfadd(_m_pfmul(v131, v386), _m_pfmul(v129, v382)), _m_pfmul(v130, v390));
        v135 = _m_pfadd(_m_pfmul(0, v133), _m_pfadd(_m_pfmul(v388, v130), _m_pfadd(v132, _m_pfmul(v380, v129))));
        v136 = a1[2];
        v137 = _m_pfadd(_m_pfmul(v133, v392), v134);
        v138 = a1[3];
        a1->m64_u64 = (unsigned __int64)v135;
        a1[1].m64_u64 = (unsigned __int64)v137;
        v139 = _m_punpckhdq(v134, v136);
        v140 = _m_punpckhdq(v137, v138);
        v141 = _m_punpckldq(v136, v136);
        v142 = _m_punpckldq(v138, v138);
        v143 = _m_punpckhdq(v139, v139);
        v144 = _m_pfmul(v384, v143);
        v145 = _m_punpckhdq(v140, v140);
        v146 = _m_pfadd(_m_pfadd(_m_pfmul(v143, v386), _m_pfmul(v141, v382)), _m_pfmul(v142, v390));
        v147 = _m_pfadd(_m_pfmul(0, v145), _m_pfadd(_m_pfmul(v388, v142), _m_pfadd(v144, _m_pfmul(v380, v141))));
        v148 = a1[4];
        v149 = _m_pfadd(_m_pfmul(v145, v392), v146);
        v150 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v147;
        a1[3].m64_u64 = (unsigned __int64)v149;
        v151 = _m_punpckhdq(v146, v148);
        v152 = _m_punpckhdq(v149, v150);
        v153 = _m_punpckldq(v148, v148);
        v154 = _m_punpckldq(v150, v150);
        v155 = _m_punpckhdq(v151, v151);
        v156 = _m_pfmul(v384, v155);
        v157 = _m_punpckhdq(v152, v152);
        v158 = _m_pfadd(_m_pfadd(_m_pfmul(v155, v386), _m_pfmul(v153, v382)), _m_pfmul(v154, v390));
        v159 = _m_pfadd(_m_pfmul(0, v157), _m_pfadd(_m_pfmul(v388, v154), _m_pfadd(v156, _m_pfmul(v380, v153))));
        v160 = a1[6];
        v161 = _m_pfadd(_m_pfmul(v157, v392), v158);
        v162 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v159;
        a1[5].m64_u64 = (unsigned __int64)v161;
        v163 = _m_punpckhdq(v158, v160);
        v164 = _m_punpckhdq(v161, v162);
        v165 = _m_punpckldq(v160, v160);
        v166 = _m_punpckldq(v162, v162);
        v167 = _m_punpckhdq(v163, v163);
        v168 = _m_punpckhdq(v164, v164);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v168),
                                            _m_pfadd(
                                              _m_pfmul(v388, v166),
                                              _m_pfadd(_m_pfmul(v384, v167), _m_pfmul(v380, v165))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v168, v392),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v167, v386), _m_pfmul(v165, v382)),
                                              _m_pfmul(v166, v390)));
        v169 = _m_pfadd(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a2->m64_u64, a1[6]);
        a1[7].m64_i32[0] = _mm_cvtsi64_si32(v169);
      }
      else
      {
        result = a1;
        a1->m64_u64 = (unsigned __int64)_m_punpckldq(v380, v384);
        a1[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v380, v384);
        v170 = _m_punpckldq(v390, v392);
        a1[5].m64_u64 = (unsigned __int64)v170;
        a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v390, v392);
        a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v382, v386);
        v171 = _m_punpckldq(v388, 0);
        a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v382, v386);
        a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v388, 0);
        a1[1].m64_u64 = (unsigned __int64)v171;
        v172 = a1[1];
        v173 = _m_punpckhdq(v171, (__m64)a1->m64_u64);
        v174 = _m_punpckhdq(v170, v172);
        v175 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v176 = _m_punpckldq(v172, v172);
        v177 = _m_punpckhdq(v173, v173);
        v178 = _m_pfmul(v378, v177);
        v179 = _m_punpckhdq(v174, v174);
        v180 = _m_pfadd(_m_pfadd(_m_pfmul(v177, 0), _m_pfmul(v175, 0)), _m_pfmul(v176, v379));
        v181 = _m_pfadd(_m_pfmul(0, v179), _m_pfadd(_m_pfmul(0, v176), _m_pfadd(v178, _m_pfmul(v377, v175))));
        v182 = a1[2];
        v183 = _m_pfadd(_m_pfmul(v179, (__m64)0x3F80000000000000LL), v180);
        v184 = a1[3];
        a1->m64_u64 = (unsigned __int64)v181;
        a1[1].m64_u64 = (unsigned __int64)v183;
        v185 = _m_punpckhdq(v180, v182);
        v186 = _m_punpckhdq(v183, v184);
        v187 = _m_punpckldq(v182, v182);
        v188 = _m_punpckldq(v184, v184);
        v189 = _m_punpckhdq(v185, v185);
        v190 = _m_pfmul(v378, v189);
        v191 = _m_punpckhdq(v186, v186);
        v192 = _m_pfadd(_m_pfadd(_m_pfmul(v189, 0), _m_pfmul(v187, 0)), _m_pfmul(v188, v379));
        v193 = _m_pfadd(_m_pfmul(0, v191), _m_pfadd(_m_pfmul(0, v188), _m_pfadd(v190, _m_pfmul(v377, v187))));
        v194 = a1[4];
        v195 = _m_pfadd(_m_pfmul(v191, (__m64)0x3F80000000000000LL), v192);
        v196 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v193;
        a1[3].m64_u64 = (unsigned __int64)v195;
        v197 = _m_punpckhdq(v192, v194);
        v198 = _m_punpckhdq(v195, v196);
        v199 = _m_punpckldq(v194, v194);
        v200 = _m_punpckldq(v196, v196);
        v201 = _m_punpckhdq(v197, v197);
        v202 = _m_pfmul(v378, v201);
        v203 = _m_punpckhdq(v198, v198);
        v204 = _m_pfadd(_m_pfadd(_m_pfmul(v201, 0), _m_pfmul(v199, 0)), _m_pfmul(v200, v379));
        v205 = _m_pfadd(_m_pfmul(0, v203), _m_pfadd(_m_pfmul(0, v200), _m_pfadd(v202, _m_pfmul(v377, v199))));
        v206 = a1[6];
        v207 = _m_pfadd(_m_pfmul(v203, (__m64)0x3F80000000000000LL), v204);
        v208 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v205;
        a1[5].m64_u64 = (unsigned __int64)v207;
        v209 = _m_punpckhdq(v204, v206);
        v210 = _m_punpckhdq(v207, v208);
        v211 = _m_punpckldq(v206, v206);
        v212 = _m_punpckldq(v208, v208);
        v213 = _m_punpckhdq(v209, v209);
        v214 = _m_pfmul(v378, v213);
        v215 = _m_punpckhdq(v210, v210);
        v216 = _m_pfmul(0, v215);
        v217 = _m_pfadd(_m_pfadd(_m_pfmul(v213, 0), _m_pfmul(v211, 0)), _m_pfmul(v212, v379));
        v218 = _m_pfadd(_m_pfmul(v215, (__m64)0x3F80000000000000LL), v217);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v216,
                                            _m_pfadd(_m_pfmul(0, v212), _m_pfadd(v214, _m_pfmul(v377, v211))));
        a1[7].m64_u64 = (unsigned __int64)v218;
        v219 = a1[1];
        v220 = _m_punpckhdq(v217, (__m64)a1->m64_u64);
        v221 = _m_punpckhdq(v218, v219);
        v222 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v223 = _m_punpckldq(v219, v219);
        v224 = _m_punpckhdq(v220, v220);
        v225 = _m_pfmul(v384, v224);
        v226 = _m_punpckhdq(v221, v221);
        v227 = _m_pfadd(_m_pfadd(_m_pfmul(v224, v386), _m_pfmul(v222, v382)), _m_pfmul(v223, v390));
        v228 = _m_pfadd(_m_pfmul(0, v226), _m_pfadd(_m_pfmul(v388, v223), _m_pfadd(v225, _m_pfmul(v380, v222))));
        v229 = a1[2];
        v230 = _m_pfadd(_m_pfmul(v226, v392), v227);
        v231 = a1[3];
        a1->m64_u64 = (unsigned __int64)v228;
        a1[1].m64_u64 = (unsigned __int64)v230;
        v232 = _m_punpckhdq(v227, v229);
        v233 = _m_punpckhdq(v230, v231);
        v234 = _m_punpckldq(v229, v229);
        v235 = _m_punpckldq(v231, v231);
        v236 = _m_punpckhdq(v232, v232);
        v237 = _m_pfmul(v384, v236);
        v238 = _m_punpckhdq(v233, v233);
        v239 = _m_pfadd(_m_pfadd(_m_pfmul(v236, v386), _m_pfmul(v234, v382)), _m_pfmul(v235, v390));
        v240 = _m_pfadd(_m_pfmul(0, v238), _m_pfadd(_m_pfmul(v388, v235), _m_pfadd(v237, _m_pfmul(v380, v234))));
        v241 = a1[4];
        v242 = _m_pfadd(_m_pfmul(v238, v392), v239);
        v243 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v240;
        a1[3].m64_u64 = (unsigned __int64)v242;
        v244 = _m_punpckhdq(v239, v241);
        v245 = _m_punpckhdq(v242, v243);
        v246 = _m_punpckldq(v241, v241);
        v247 = _m_punpckldq(v243, v243);
        v248 = _m_punpckhdq(v244, v244);
        v249 = _m_pfmul(v384, v248);
        v250 = _m_punpckhdq(v245, v245);
        v251 = _m_pfadd(_m_pfadd(_m_pfmul(v248, v386), _m_pfmul(v246, v382)), _m_pfmul(v247, v390));
        v252 = _m_pfadd(_m_pfmul(0, v250), _m_pfadd(_m_pfmul(v388, v247), _m_pfadd(v249, _m_pfmul(v380, v246))));
        v253 = a1[6];
        v254 = _m_pfadd(_m_pfmul(v250, v392), v251);
        v255 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v252;
        a1[5].m64_u64 = (unsigned __int64)v254;
        v256 = _m_punpckhdq(v251, v253);
        v257 = _m_punpckhdq(v254, v255);
        v258 = _m_punpckldq(v253, v253);
        v259 = _m_punpckldq(v255, v255);
        v260 = _m_punpckhdq(v256, v256);
        v261 = _m_punpckhdq(v257, v257);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v261),
                                            _m_pfadd(
                                              _m_pfmul(v388, v259),
                                              _m_pfadd(_m_pfmul(v384, v260), _m_pfmul(v380, v258))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v261, v392),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v260, v386), _m_pfmul(v258, v382)),
                                              _m_pfmul(v259, v390)));
      }
    }
    else
    {
      v262 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v263 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a4->m64_u64, 0);
      a1[1].m64_u64 = 0;
      a1[2].m64_u64 = (unsigned __int64)v263;
      a1[3].m64_u64 = 0;
      a1[4].m64_u64 = 0;
      a1[5].m64_u64 = (unsigned __int64)v262;
      a1[6].m64_u64 = 0;
      a1[7].m64_u64 = 0x3F80000000000000LL;
    }
  }
  else
  {
    v264 = _mm_cvtsi32_si64(0x3F800000u);
    v265 = _m_punpckldq(_m_punpckhdq(v264, v264), v264);
    a1->m64_u64 = (unsigned __int64)v264;
    a1[1].m64_u64 = 0;
    a1[2].m64_u64 = (unsigned __int64)v265;
    a1[3].m64_u64 = 0;
    a1[4].m64_u64 = 0;
    a1[5].m64_u64 = (unsigned __int64)v264;
    a1[6].m64_u64 = 0;
    a1[7].m64_u64 = (unsigned __int64)v265;
  }
  if ( a6 )
  {
    v266 = (__m64)a6->m64_u64;
    v267 = _m_pfadd(v266, v266);
    v268 = a6[1];
    v269 = _m_punpckhdq(v266, v266);
    v270 = _m_punpckhdq(v268, v268);
    v271 = _m_pfmul((__m64)a6->m64_u64, v267);
    v272 = _m_punpckldq(_m_pfadd(v268, v268), v267);
    v273 = _m_pfmul(v267, v270);
    v274 = _m_pfmul(_m_punpckldq(v268, v268), v272);
    v275 = _m_pfmul(v272, v270);
    v276 = _m_pfmul(v272, v269);
    v277 = _m_punpckhdq(v276, v274);
    v278 = _m_punpckhdq(_m_punpckldq(v275, v275), v273);
    v279 = _m_pfsubr(_m_pfadd(_m_punpckldq(v274, v274), v271), (__m64)0x3F8000003F800000LL);
    v391 = _m_punpckldq(_m_pfsubr(_m_pfacc(v271, v271), (__m64)0x3F8000003F800000LL), 0);
    v280 = v276;
    v281 = _m_pfadd(v276, v273);
    v282 = _m_pfsub(v280, v273);
    v283 = _m_pfsub(v277, v278);
    v284 = _m_punpckldq(v281, 0);
    v285 = _m_pfadd(v277, v278);
    v387 = v284;
    v383 = _m_punpckhdq(v283, 0);
    v385 = _m_punpckldq(v283, v279);
    v381 = _m_punpckhdq(v279, _m_punpckldq(v285, v285));
    v389 = _m_punpckldq(_m_punpckhdq(v285, v285), v282);
    v393 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a5 )
    {
      v286 = (__m64)a5->m64_u64;
      v287 = _mm_cvtsi32_si64(a5[1].m64_u32[0]);
      v288 = _m_pfsub(_mm_cvtsi32_si64(result[7].m64_u32[0]), v287);
      result[6].m64_u64 = (unsigned __int64)_m_pfsub(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v288);
      v289 = result[1];
      v290 = _m_punpckhdq(v286, (__m64)result->m64_u64);
      v291 = _m_punpckhdq(v287, v289);
      v292 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v293 = _m_punpckldq(v289, v289);
      v294 = _m_punpckhdq(v290, v290);
      v295 = _m_pfmul(v385, v294);
      v296 = _m_punpckhdq(v291, v291);
      v297 = _m_pfadd(_m_pfadd(_m_pfmul(v294, v387), _m_pfmul(v292, v383)), _m_pfmul(v293, v391));
      v298 = _m_pfadd(_m_pfmul(0, v296), _m_pfadd(_m_pfmul(v389, v293), _m_pfadd(v295, _m_pfmul(v381, v292))));
      v299 = result[2];
      v300 = _m_pfadd(_m_pfmul(v296, v393), v297);
      v301 = result[3];
      result->m64_u64 = (unsigned __int64)v298;
      result[1].m64_u64 = (unsigned __int64)v300;
      v302 = _m_punpckhdq(v297, v299);
      v303 = _m_punpckhdq(v300, v301);
      v304 = _m_punpckldq(v299, v299);
      v305 = _m_punpckldq(v301, v301);
      v306 = _m_punpckhdq(v302, v302);
      v307 = _m_pfmul(v385, v306);
      v308 = _m_punpckhdq(v303, v303);
      v309 = _m_pfadd(_m_pfadd(_m_pfmul(v306, v387), _m_pfmul(v304, v383)), _m_pfmul(v305, v391));
      v310 = _m_pfadd(_m_pfmul(0, v308), _m_pfadd(_m_pfmul(v389, v305), _m_pfadd(v307, _m_pfmul(v381, v304))));
      v311 = result[4];
      v312 = _m_pfadd(_m_pfmul(v308, v393), v309);
      v313 = result[5];
      result[2].m64_u64 = (unsigned __int64)v310;
      result[3].m64_u64 = (unsigned __int64)v312;
      v314 = _m_punpckhdq(v309, v311);
      v315 = _m_punpckhdq(v312, v313);
      v316 = _m_punpckldq(v311, v311);
      v317 = _m_punpckldq(v313, v313);
      v318 = _m_punpckhdq(v314, v314);
      v319 = _m_pfmul(v385, v318);
      v320 = _m_punpckhdq(v315, v315);
      v321 = _m_pfadd(_m_pfadd(_m_pfmul(v318, v387), _m_pfmul(v316, v383)), _m_pfmul(v317, v391));
      v322 = _m_pfadd(_m_pfmul(0, v320), _m_pfadd(_m_pfmul(v389, v317), _m_pfadd(v319, _m_pfmul(v381, v316))));
      v323 = result[6];
      v324 = _m_pfadd(_m_pfmul(v320, v393), v321);
      v325 = result[7];
      result[4].m64_u64 = (unsigned __int64)v322;
      result[5].m64_u64 = (unsigned __int64)v324;
      v326 = _m_punpckhdq(v321, v323);
      v327 = _m_punpckhdq(v324, v325);
      v328 = _m_punpckldq(v323, v323);
      v329 = _m_punpckldq(v325, v325);
      v330 = _m_punpckhdq(v326, v326);
      v331 = _m_punpckhdq(v327, v327);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v331),
                                              _m_pfadd(
                                                _m_pfmul(v389, v329),
                                                _m_pfadd(_m_pfmul(v385, v330), _m_pfmul(v381, v328))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v331, v393),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v330, v387), _m_pfmul(v328, v383)),
                                                _m_pfmul(v329, v391)));
      v332 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a5[1].m64_u32[0]));
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v332);
    }
    else
    {
      v333 = result[1];
      v334 = _m_punpckhdq(v284, (__m64)result->m64_u64);
      v335 = _m_punpckhdq(v282, v333);
      v336 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v337 = _m_punpckldq(v333, v333);
      v338 = _m_punpckhdq(v334, v334);
      v339 = _m_pfmul(v385, v338);
      v340 = _m_punpckhdq(v335, v335);
      v341 = _m_pfadd(_m_pfadd(_m_pfmul(v338, v387), _m_pfmul(v336, v383)), _m_pfmul(v337, v391));
      v342 = _m_pfadd(_m_pfmul(0, v340), _m_pfadd(_m_pfmul(v389, v337), _m_pfadd(v339, _m_pfmul(v381, v336))));
      v343 = result[2];
      v344 = _m_pfadd(_m_pfmul(v340, v393), v341);
      v345 = result[3];
      result->m64_u64 = (unsigned __int64)v342;
      result[1].m64_u64 = (unsigned __int64)v344;
      v346 = _m_punpckhdq(v341, v343);
      v347 = _m_punpckhdq(v344, v345);
      v348 = _m_punpckldq(v343, v343);
      v349 = _m_punpckldq(v345, v345);
      v350 = _m_punpckhdq(v346, v346);
      v351 = _m_pfmul(v385, v350);
      v352 = _m_punpckhdq(v347, v347);
      v353 = _m_pfadd(_m_pfadd(_m_pfmul(v350, v387), _m_pfmul(v348, v383)), _m_pfmul(v349, v391));
      v354 = _m_pfadd(_m_pfmul(0, v352), _m_pfadd(_m_pfmul(v389, v349), _m_pfadd(v351, _m_pfmul(v381, v348))));
      v355 = result[4];
      v356 = _m_pfadd(_m_pfmul(v352, v393), v353);
      v357 = result[5];
      result[2].m64_u64 = (unsigned __int64)v354;
      result[3].m64_u64 = (unsigned __int64)v356;
      v358 = _m_punpckhdq(v353, v355);
      v359 = _m_punpckhdq(v356, v357);
      v360 = _m_punpckldq(v355, v355);
      v361 = _m_punpckldq(v357, v357);
      v362 = _m_punpckhdq(v358, v358);
      v363 = _m_pfmul(v385, v362);
      v364 = _m_punpckhdq(v359, v359);
      v365 = _m_pfadd(_m_pfadd(_m_pfmul(v362, v387), _m_pfmul(v360, v383)), _m_pfmul(v361, v391));
      v366 = _m_pfadd(_m_pfmul(0, v364), _m_pfadd(_m_pfmul(v389, v361), _m_pfadd(v363, _m_pfmul(v381, v360))));
      v367 = result[6];
      v368 = _m_pfadd(_m_pfmul(v364, v393), v365);
      v369 = result[7];
      result[4].m64_u64 = (unsigned __int64)v366;
      result[5].m64_u64 = (unsigned __int64)v368;
      v370 = _m_punpckhdq(v365, v367);
      v371 = _m_punpckhdq(v368, v369);
      v372 = _m_punpckldq(v367, v367);
      v373 = _m_punpckldq(v369, v369);
      v374 = _m_punpckhdq(v370, v370);
      v375 = _m_punpckhdq(v371, v371);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v375),
                                              _m_pfadd(
                                                _m_pfmul(v389, v373),
                                                _m_pfadd(_m_pfmul(v385, v374), _m_pfmul(v381, v372))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v375, v393),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v374, v387), _m_pfmul(v372, v383)),
                                                _m_pfmul(v373, v391)));
    }
  }
  if ( a7 )
  {
    v376 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a7[1].m64_u32[0]));
    result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a7->m64_u64);
    result[7].m64_i32[0] = _mm_cvtsi64_si32(v376);
  }
  _m_femms();
  return result;
}

// sub_1002AE7A @ 0x1002AE7A
__m64 *__userpurge sub_1002AE7A@<eax>(__m64 *a1, __m64 a2, __m64 a3)
{
  __m64 v3; // mm0
  __m64 v4; // mm6
  __m64 v5; // mm2
  __m64 v6; // mm6
  __m64 v7; // mm7
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm7
  __m64 v12; // mm2
  __m64 v13; // mm4
  __m64 v14; // mm3
  __m64 v15; // mm1
  __m64 v16; // mm5
  __m64 v17; // mm7
  __m64 v18; // mm6
  __m64 v19; // mm2
  __m64 v20; // mm1
  __m64 v21; // mm6
  __m64 v22; // mm7
  __m64 v23; // mm3
  __m64 v24; // mm2
  __m64 v25; // mm3
  __m64 v26; // mm5
  __m64 v27; // mm6
  __m64 v28; // [esp+8h] [ebp-28h]
  __m64 v29; // [esp+28h] [ebp-8h]

  sub_100354E0();
  v28 = _m_pfmul((__m64)0x3F0000003F000000LL, a3);
  sub_100354E0();
  v3 = _m_pfmul((__m64)0x3F0000003F000000LL, a2);
  sub_100354E0();
  v4 = _m_punpckhdq(v3, v3);
  v5 = _m_punpckldq(v4, v4);
  v6 = _m_punpckhdq(v4, v4);
  v7 = _m_punpckldq(_m_punpckhdq(v28, v28), v28);
  v29 = _m_pfadd(
          _m_pfmul(_m_pfmul(_m_punpckldq(v3, v3), v5), v7),
          _m_pfmul(_m_pfmul(_m_pxor(_m_punpckhdq(v3, v3), _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u)), v6), v28));
  v9 = _m_pfadd(
         _m_pfmul(_m_pfmul(_m_pxor(_m_punpckldq(v3, v3), (__m64)0x8000000000000000uLL), v6), v28),
         _m_pfmul(_m_pfmul(_m_punpckhdq(v3, v3), v5), v7));
  v10 = _m_pfadd(v9, v9);
  v11 = v29;
  v12 = _m_punpckhdq(v9, v9);
  v13 = _m_punpckhdq(v11, v11);
  v14 = _m_pfmul(v9, v10);
  v15 = _m_punpckldq(_m_pfadd(v11, v11), v10);
  v16 = _m_pfmul(v10, v13);
  v17 = _m_pfmul(_m_punpckldq(v11, v11), v15);
  v18 = _m_pfmul(v15, v13);
  v19 = _m_pfmul(v15, v12);
  v20 = _m_punpckhdq(v19, v17);
  a1[6].m64_u64 = 0;
  v21 = _m_punpckhdq(_m_punpckldq(v18, v18), v16);
  v22 = _m_pfsubr(_m_pfadd(_m_punpckldq(v17, v17), v14), (__m64)0x3F8000003F800000LL);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsubr(_m_pfacc(v14, v14), (__m64)0x3F8000003F800000LL), 0);
  v23 = v19;
  v24 = _m_pfadd(v19, v16);
  v25 = _m_pfsub(v23, v16);
  v26 = _m_pfsub(v20, v21);
  v27 = _m_pfadd(v20, v21);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v24, 0);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v26, 0);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v26, v22);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v22, _m_punpckldq(v27, v27));
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpckhdq(v27, v27), v25);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_1002B01F @ 0x1002B01F
__m64 *__stdcall sub_1002B01F(__m64 *a1, unsigned int a2, __m64 *a3, __m64 *a4, __m64 *a5)
{
  __m64 *result; // eax
  __m64 v6; // mm6
  __m64 m64_u64; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm7
  __m64 v10; // mm2
  __m64 v11; // mm4
  __m64 v12; // mm3
  __m64 v13; // mm1
  __m64 v14; // mm5
  __m64 v15; // mm7
  __m64 v16; // mm6
  __m64 v17; // mm2
  __m64 v18; // mm1
  __m64 v19; // mm6
  __m64 v20; // mm7
  __m64 v21; // mm3
  __m64 v22; // mm2
  __m64 v23; // mm3
  __m64 v24; // mm5
  __m64 v25; // mm2
  __m64 v26; // mm6
  __m64 v27; // mm2
  __m64 v28; // mm3
  __m64 v29; // mm1
  __m64 v30; // mm1
  __m64 v31; // mm2
  __m64 v32; // mm3
  __m64 v33; // mm0
  __m64 v34; // mm1
  __m64 v35; // mm2
  __m64 v36; // mm5
  __m64 v37; // mm3
  __m64 v38; // mm2
  __m64 v39; // mm7
  __m64 v40; // mm0
  __m64 v41; // mm3
  __m64 v42; // mm1
  __m64 v43; // mm2
  __m64 v44; // mm3
  __m64 v45; // mm0
  __m64 v46; // mm1
  __m64 v47; // mm2
  __m64 v48; // mm5
  __m64 v49; // mm3
  __m64 v50; // mm2
  __m64 v51; // mm7
  __m64 v52; // mm0
  __m64 v53; // mm3
  __m64 v54; // mm1
  __m64 v55; // mm2
  __m64 v56; // mm3
  __m64 v57; // mm0
  __m64 v58; // mm1
  __m64 v59; // mm2
  __m64 v60; // mm5
  __m64 v61; // mm3
  __m64 v62; // mm2
  __m64 v63; // mm7
  __m64 v64; // mm0
  __m64 v65; // mm3
  __m64 v66; // mm1
  __m64 v67; // mm2
  __m64 v68; // mm3
  __m64 v69; // mm0
  __m64 v70; // mm1
  __m64 v71; // mm2
  __m64 v72; // mm3
  __m64 v73; // mm1
  __m64 v74; // mm1
  __m64 v75; // mm2
  __m64 v76; // mm3
  __m64 v77; // mm0
  __m64 v78; // mm1
  __m64 v79; // mm2
  __m64 v80; // mm5
  __m64 v81; // mm3
  __m64 v82; // mm2
  __m64 v83; // mm7
  __m64 v84; // mm0
  __m64 v85; // mm3
  __m64 v86; // mm1
  __m64 v87; // mm2
  __m64 v88; // mm3
  __m64 v89; // mm0
  __m64 v90; // mm1
  __m64 v91; // mm2
  __m64 v92; // mm5
  __m64 v93; // mm3
  __m64 v94; // mm2
  __m64 v95; // mm7
  __m64 v96; // mm0
  __m64 v97; // mm3
  __m64 v98; // mm1
  __m64 v99; // mm2
  __m64 v100; // mm3
  __m64 v101; // mm0
  __m64 v102; // mm1
  __m64 v103; // mm2
  __m64 v104; // mm5
  __m64 v105; // mm3
  __m64 v106; // mm2
  __m64 v107; // mm7
  __m64 v108; // mm0
  __m64 v109; // mm3
  __m64 v110; // mm1
  __m64 v111; // mm2
  __m64 v112; // mm3
  __m64 v113; // mm0
  __m64 v114; // mm1
  __m64 v115; // mm2
  __m64 v116; // mm3
  __m64 v117; // mm1
  __m64 v118; // [esp+0h] [ebp-40h]
  __m64 v119; // [esp+8h] [ebp-38h]
  __m64 v120; // [esp+10h] [ebp-30h]
  __m64 v121; // [esp+18h] [ebp-28h]
  __m64 v122; // [esp+20h] [ebp-20h]
  __m64 v123; // [esp+28h] [ebp-18h]
  __m64 v124; // [esp+38h] [ebp-8h]

  result = a1;
  v6 = _mm_cvtsi32_si64(a2);
  a1->m64_u64 = (unsigned __int64)v6;
  a1[1].m64_u64 = 0;
  a1[2].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[2].m64_i32[1] = _mm_cvtsi64_si32(v6);
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = (unsigned __int64)v6;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  if ( a4 )
  {
    m64_u64 = (__m64)a4->m64_u64;
    v8 = _m_pfadd(m64_u64, m64_u64);
    v9 = a4[1];
    v10 = _m_punpckhdq(m64_u64, m64_u64);
    v11 = _m_punpckhdq(v9, v9);
    v12 = _m_pfmul((__m64)a4->m64_u64, v8);
    v13 = _m_punpckldq(_m_pfadd(v9, v9), v8);
    v14 = _m_pfmul(v8, v11);
    v15 = _m_pfmul(_m_punpckldq(v9, v9), v13);
    v16 = _m_pfmul(v13, v11);
    v17 = _m_pfmul(v13, v10);
    v18 = _m_punpckhdq(v17, v15);
    v19 = _m_punpckhdq(_m_punpckldq(v16, v16), v14);
    v20 = _m_pfsubr(_m_pfadd(_m_punpckldq(v15, v15), v12), (__m64)0x3F8000003F800000LL);
    v123 = _m_punpckldq(_m_pfsubr(_m_pfacc(v12, v12), (__m64)0x3F8000003F800000LL), 0);
    v21 = v17;
    v22 = _m_pfadd(v17, v14);
    v23 = _m_pfsub(v21, v14);
    v24 = _m_pfsub(v18, v19);
    v25 = _m_punpckldq(v22, 0);
    v26 = _m_pfadd(v18, v19);
    v121 = v25;
    v119 = _m_punpckhdq(v24, 0);
    v120 = _m_punpckldq(v24, v20);
    v118 = _m_punpckhdq(v20, _m_punpckldq(v26, v26));
    v122 = _m_punpckldq(_m_punpckhdq(v26, v26), v23);
    v124 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a3 )
    {
      v27 = (__m64)a3->m64_u64;
      v28 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
      v29 = _m_pfsub(_mm_cvtsi32_si64(a1[7].m64_u32[0]), v28);
      a1[6].m64_u64 = (unsigned __int64)_m_pfsub(a1[6], (__m64)a3->m64_u64);
      a1[7].m64_i32[0] = _mm_cvtsi64_si32(v29);
      v30 = a1[1];
      v31 = _m_punpckhdq(v27, (__m64)a1->m64_u64);
      v32 = _m_punpckhdq(v28, v30);
      v33 = _m_punpckldq((__m64)a1->m64_u64, (__m64)a1->m64_u64);
      v34 = _m_punpckldq(v30, v30);
      v35 = _m_punpckhdq(v31, v31);
      v36 = _m_pfmul(v120, v35);
      v37 = _m_punpckhdq(v32, v32);
      v38 = _m_pfadd(_m_pfadd(_m_pfmul(v35, v121), _m_pfmul(v33, v119)), _m_pfmul(v34, v123));
      v39 = _m_pfadd(_m_pfmul(0, v37), _m_pfadd(_m_pfmul(v122, v34), _m_pfadd(v36, _m_pfmul(v118, v33))));
      v40 = a1[2];
      v41 = _m_pfadd(_m_pfmul(v37, v124), v38);
      v42 = a1[3];
      a1->m64_u64 = (unsigned __int64)v39;
      a1[1].m64_u64 = (unsigned __int64)v41;
      v43 = _m_punpckhdq(v38, v40);
      v44 = _m_punpckhdq(v41, v42);
      v45 = _m_punpckldq(v40, v40);
      v46 = _m_punpckldq(v42, v42);
      v47 = _m_punpckhdq(v43, v43);
      v48 = _m_pfmul(v120, v47);
      v49 = _m_punpckhdq(v44, v44);
      v50 = _m_pfadd(_m_pfadd(_m_pfmul(v47, v121), _m_pfmul(v45, v119)), _m_pfmul(v46, v123));
      v51 = _m_pfadd(_m_pfmul(0, v49), _m_pfadd(_m_pfmul(v122, v46), _m_pfadd(v48, _m_pfmul(v118, v45))));
      v52 = a1[4];
      v53 = _m_pfadd(_m_pfmul(v49, v124), v50);
      v54 = a1[5];
      a1[2].m64_u64 = (unsigned __int64)v51;
      a1[3].m64_u64 = (unsigned __int64)v53;
      v55 = _m_punpckhdq(v50, v52);
      v56 = _m_punpckhdq(v53, v54);
      v57 = _m_punpckldq(v52, v52);
      v58 = _m_punpckldq(v54, v54);
      v59 = _m_punpckhdq(v55, v55);
      v60 = _m_pfmul(v120, v59);
      v61 = _m_punpckhdq(v56, v56);
      v62 = _m_pfadd(_m_pfadd(_m_pfmul(v59, v121), _m_pfmul(v57, v119)), _m_pfmul(v58, v123));
      v63 = _m_pfadd(_m_pfmul(0, v61), _m_pfadd(_m_pfmul(v122, v58), _m_pfadd(v60, _m_pfmul(v118, v57))));
      v64 = a1[6];
      v65 = _m_pfadd(_m_pfmul(v61, v124), v62);
      v66 = a1[7];
      a1[4].m64_u64 = (unsigned __int64)v63;
      a1[5].m64_u64 = (unsigned __int64)v65;
      v67 = _m_punpckhdq(v62, v64);
      v68 = _m_punpckhdq(v65, v66);
      v69 = _m_punpckldq(v64, v64);
      v70 = _m_punpckldq(v66, v66);
      v71 = _m_punpckhdq(v67, v67);
      v72 = _m_punpckhdq(v68, v68);
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(0, v72),
                                          _m_pfadd(
                                            _m_pfmul(v122, v70),
                                            _m_pfadd(_m_pfmul(v120, v71), _m_pfmul(v118, v69))));
      a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(v72, v124),
                                          _m_pfadd(
                                            _m_pfadd(_m_pfmul(v71, v121), _m_pfmul(v69, v119)),
                                            _m_pfmul(v70, v123)));
      v73 = _m_pfadd(_mm_cvtsi32_si64(a1[7].m64_u32[0]), _mm_cvtsi32_si64(a3[1].m64_u32[0]));
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(a1[6], (__m64)a3->m64_u64);
      a1[7].m64_i32[0] = _mm_cvtsi64_si32(v73);
    }
    else
    {
      v74 = a1[1];
      v75 = _m_punpckhdq(v25, (__m64)a1->m64_u64);
      v76 = _m_punpckhdq(v23, v74);
      v77 = _m_punpckldq((__m64)a1->m64_u64, (__m64)a1->m64_u64);
      v78 = _m_punpckldq(v74, v74);
      v79 = _m_punpckhdq(v75, v75);
      v80 = _m_pfmul(v120, v79);
      v81 = _m_punpckhdq(v76, v76);
      v82 = _m_pfadd(_m_pfadd(_m_pfmul(v79, v121), _m_pfmul(v77, v119)), _m_pfmul(v78, v123));
      v83 = _m_pfadd(_m_pfmul(0, v81), _m_pfadd(_m_pfmul(v122, v78), _m_pfadd(v80, _m_pfmul(v118, v77))));
      v84 = a1[2];
      v85 = _m_pfadd(_m_pfmul(v81, v124), v82);
      v86 = a1[3];
      a1->m64_u64 = (unsigned __int64)v83;
      a1[1].m64_u64 = (unsigned __int64)v85;
      v87 = _m_punpckhdq(v82, v84);
      v88 = _m_punpckhdq(v85, v86);
      v89 = _m_punpckldq(v84, v84);
      v90 = _m_punpckldq(v86, v86);
      v91 = _m_punpckhdq(v87, v87);
      v92 = _m_pfmul(v120, v91);
      v93 = _m_punpckhdq(v88, v88);
      v94 = _m_pfadd(_m_pfadd(_m_pfmul(v91, v121), _m_pfmul(v89, v119)), _m_pfmul(v90, v123));
      v95 = _m_pfadd(_m_pfmul(0, v93), _m_pfadd(_m_pfmul(v122, v90), _m_pfadd(v92, _m_pfmul(v118, v89))));
      v96 = a1[4];
      v97 = _m_pfadd(_m_pfmul(v93, v124), v94);
      v98 = a1[5];
      a1[2].m64_u64 = (unsigned __int64)v95;
      a1[3].m64_u64 = (unsigned __int64)v97;
      v99 = _m_punpckhdq(v94, v96);
      v100 = _m_punpckhdq(v97, v98);
      v101 = _m_punpckldq(v96, v96);
      v102 = _m_punpckldq(v98, v98);
      v103 = _m_punpckhdq(v99, v99);
      v104 = _m_pfmul(v120, v103);
      v105 = _m_punpckhdq(v100, v100);
      v106 = _m_pfadd(_m_pfadd(_m_pfmul(v103, v121), _m_pfmul(v101, v119)), _m_pfmul(v102, v123));
      v107 = _m_pfadd(_m_pfmul(0, v105), _m_pfadd(_m_pfmul(v122, v102), _m_pfadd(v104, _m_pfmul(v118, v101))));
      v108 = a1[6];
      v109 = _m_pfadd(_m_pfmul(v105, v124), v106);
      v110 = a1[7];
      a1[4].m64_u64 = (unsigned __int64)v107;
      a1[5].m64_u64 = (unsigned __int64)v109;
      v111 = _m_punpckhdq(v106, v108);
      v112 = _m_punpckhdq(v109, v110);
      v113 = _m_punpckldq(v108, v108);
      v114 = _m_punpckldq(v110, v110);
      v115 = _m_punpckhdq(v111, v111);
      v116 = _m_punpckhdq(v112, v112);
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(0, v116),
                                          _m_pfadd(
                                            _m_pfmul(v122, v114),
                                            _m_pfadd(_m_pfmul(v120, v115), _m_pfmul(v118, v113))));
      a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(v116, v124),
                                          _m_pfadd(
                                            _m_pfadd(_m_pfmul(v115, v121), _m_pfmul(v113, v119)),
                                            _m_pfmul(v114, v123)));
    }
  }
  if ( a5 )
  {
    v117 = _m_pfadd(_mm_cvtsi32_si64(a5[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a5->m64_u64, a1[6]);
    a1[7].m64_i32[0] = _mm_cvtsi64_si32(v117);
  }
  _m_femms();
  return result;
}

// sub_1002B553 @ 0x1002B553
__m64 *__stdcall sub_1002B553(__m64 *a1, __m64 *a2, unsigned int a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm1
  __m64 v5; // mm0
  __m64 v6; // mm7
  __m64 v7; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v12; // mm3
  __m64 v13; // mm4
  __m64 v14; // mm5
  __m64 v15; // mm1
  __m64 v16; // mm1
  __m64 v17; // mm6
  __m64 v18; // mm7
  __m64 v19; // mm1
  __m64 v20; // mm6
  __m64 v21; // mm2
  __m64 v22; // mm1
  unsigned __int64 m64_u64; // [esp+0h] [ebp-18h] BYREF
  unsigned int v24; // [esp+8h] [ebp-10h]
  unsigned int v25; // [esp+Ch] [ebp-Ch]

  v3 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  m64_u64 = a2->m64_u64;
  v24 = _mm_cvtsi64_si32(v3);
  sub_1002D2C2((int)&m64_u64, (int)&m64_u64);
  sub_100354E0();
  v4 = _mm_cvtsi32_si64(a3);
  v5 = _m_pfsubr(v4, (__m64)0x3F8000003F800000LL);
  v25 = _mm_cvtsi64_si32(_m_punpckhdq(v4, v4));
  v6 = _mm_cvtsi32_si64(v24);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v5, v5);
  v9 = _m_punpckldq(v4, v4);
  v10 = _m_pfmul(_m_pfmul(_m_punpckhdq((__m64)m64_u64, v7), (__m64)m64_u64), v8);
  v12 = _m_pfmul(_m_pfmul(v7, (__m64)m64_u64), v8);
  v13 = _m_pfadd(_m_pfmul(_m_pfmul((__m64)m64_u64, (__m64)m64_u64), v8), v9);
  v14 = _m_pfadd(_m_pfmul(_m_pfmul(v6, v6), v8), v9);
  v15 = _mm_cvtsi32_si64(v25);
  v16 = _m_punpckldq(v15, v15);
  v17 = _m_pfmul((__m64)m64_u64, v16);
  a1[6].m64_u64 = 0;
  v18 = _m_punpckldq(_m_pfmul(v6, v16), v17);
  v19 = v10;
  v20 = _m_punpckhdq(v17, v17);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(v14, 0);
  v21 = _m_pfsub(v10, v18);
  v22 = _m_pfadd(v19, v18);
  a1->m64_u64 = (unsigned __int64)_m_punpckldq(v13, v22);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsub(v12, v20), 0);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v22, 0);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(0, (__m64)0x3F8000003F800000LL);
  a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(_m_pfadd(_m_punpckldq(v12, v12), v20), v21);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v21, _m_punpckhdq(v13, v13));
  _m_femms();
  return a1;
}

// sub_1002B66C @ 0x1002B66C
__m64 *__stdcall sub_1002B66C(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, __m64 *a6, __m64 *a7)
{
  __m64 *result; // eax
  __m64 v8; // mm4
  __m64 v9; // mm1
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm2
  __m64 v14; // mm3
  __m64 v15; // mm1
  __m64 v16; // mm6
  __m64 v17; // mm3
  __m64 v18; // mm6
  __m64 v19; // mm2
  __m64 v20; // mm1
  __m64 m64_u64; // mm3
  __m64 v22; // mm4
  __m64 v23; // mm1
  __m64 v24; // mm2
  __m64 v25; // mm2
  __m64 v26; // mm1
  __m64 v27; // mm2
  __m64 v28; // mm3
  __m64 v29; // mm0
  __m64 v30; // mm1
  __m64 v31; // mm2
  __m64 v32; // mm5
  __m64 v33; // mm3
  __m64 v34; // mm2
  __m64 v35; // mm7
  __m64 v36; // mm0
  __m64 v37; // mm3
  __m64 v38; // mm1
  __m64 v39; // mm2
  __m64 v40; // mm3
  __m64 v41; // mm0
  __m64 v42; // mm1
  __m64 v43; // mm2
  __m64 v44; // mm5
  __m64 v45; // mm3
  __m64 v46; // mm2
  __m64 v47; // mm7
  __m64 v48; // mm0
  __m64 v49; // mm3
  __m64 v50; // mm1
  __m64 v51; // mm2
  __m64 v52; // mm3
  __m64 v53; // mm0
  __m64 v54; // mm1
  __m64 v55; // mm2
  __m64 v56; // mm5
  __m64 v57; // mm3
  __m64 v58; // mm2
  __m64 v59; // mm7
  __m64 v60; // mm0
  __m64 v61; // mm3
  __m64 v62; // mm1
  __m64 v63; // mm2
  __m64 v64; // mm3
  __m64 v65; // mm0
  __m64 v66; // mm1
  __m64 v67; // mm2
  __m64 v68; // mm5
  __m64 v69; // mm3
  __m64 v70; // mm7
  __m64 v71; // mm2
  __m64 v72; // mm3
  __m64 v73; // mm1
  __m64 v74; // mm2
  __m64 v75; // mm3
  __m64 v76; // mm0
  __m64 v77; // mm1
  __m64 v78; // mm2
  __m64 v79; // mm5
  __m64 v80; // mm3
  __m64 v81; // mm2
  __m64 v82; // mm7
  __m64 v83; // mm0
  __m64 v84; // mm3
  __m64 v85; // mm1
  __m64 v86; // mm2
  __m64 v87; // mm3
  __m64 v88; // mm0
  __m64 v89; // mm1
  __m64 v90; // mm2
  __m64 v91; // mm5
  __m64 v92; // mm3
  __m64 v93; // mm2
  __m64 v94; // mm7
  __m64 v95; // mm0
  __m64 v96; // mm3
  __m64 v97; // mm1
  __m64 v98; // mm2
  __m64 v99; // mm3
  __m64 v100; // mm0
  __m64 v101; // mm1
  __m64 v102; // mm2
  __m64 v103; // mm5
  __m64 v104; // mm3
  __m64 v105; // mm2
  __m64 v106; // mm7
  __m64 v107; // mm0
  __m64 v108; // mm3
  __m64 v109; // mm1
  __m64 v110; // mm2
  __m64 v111; // mm3
  __m64 v112; // mm0
  __m64 v113; // mm1
  __m64 v114; // mm2
  __m64 v115; // mm5
  __m64 v116; // mm3
  __m64 v117; // mm7
  __m64 v118; // mm2
  __m64 v119; // mm3
  __m64 v120; // mm1
  __m64 v121; // mm2
  __m64 v122; // mm3
  __m64 v123; // mm0
  __m64 v124; // mm1
  __m64 v125; // mm2
  __m64 v126; // mm5
  __m64 v127; // mm3
  __m64 v128; // mm2
  __m64 v129; // mm7
  __m64 v130; // mm0
  __m64 v131; // mm3
  __m64 v132; // mm1
  __m64 v133; // mm2
  __m64 v134; // mm3
  __m64 v135; // mm0
  __m64 v136; // mm1
  __m64 v137; // mm2
  __m64 v138; // mm5
  __m64 v139; // mm3
  __m64 v140; // mm2
  __m64 v141; // mm7
  __m64 v142; // mm0
  __m64 v143; // mm3
  __m64 v144; // mm1
  __m64 v145; // mm2
  __m64 v146; // mm3
  __m64 v147; // mm0
  __m64 v148; // mm1
  __m64 v149; // mm2
  __m64 v150; // mm5
  __m64 v151; // mm3
  __m64 v152; // mm2
  __m64 v153; // mm7
  __m64 v154; // mm0
  __m64 v155; // mm3
  __m64 v156; // mm1
  __m64 v157; // mm2
  __m64 v158; // mm3
  __m64 v159; // mm0
  __m64 v160; // mm1
  __m64 v161; // mm2
  __m64 v162; // mm3
  __m64 v163; // mm2
  __m64 v164; // mm3
  __m64 v165; // mm2
  __m64 v166; // mm1
  __m64 v167; // mm2
  __m64 v168; // mm3
  __m64 v169; // mm0
  __m64 v170; // mm1
  __m64 v171; // mm2
  __m64 v172; // mm5
  __m64 v173; // mm3
  __m64 v174; // mm2
  __m64 v175; // mm7
  __m64 v176; // mm0
  __m64 v177; // mm3
  __m64 v178; // mm1
  __m64 v179; // mm2
  __m64 v180; // mm3
  __m64 v181; // mm0
  __m64 v182; // mm1
  __m64 v183; // mm2
  __m64 v184; // mm5
  __m64 v185; // mm3
  __m64 v186; // mm2
  __m64 v187; // mm7
  __m64 v188; // mm0
  __m64 v189; // mm3
  __m64 v190; // mm1
  __m64 v191; // mm2
  __m64 v192; // mm3
  __m64 v193; // mm0
  __m64 v194; // mm1
  __m64 v195; // mm2
  __m64 v196; // mm5
  __m64 v197; // mm3
  __m64 v198; // mm2
  __m64 v199; // mm7
  __m64 v200; // mm0
  __m64 v201; // mm3
  __m64 v202; // mm1
  __m64 v203; // mm2
  __m64 v204; // mm3
  __m64 v205; // mm0
  __m64 v206; // mm1
  __m64 v207; // mm2
  __m64 v208; // mm5
  __m64 v209; // mm3
  __m64 v210; // mm7
  __m64 v211; // mm2
  __m64 v212; // mm3
  __m64 v213; // mm1
  __m64 v214; // mm2
  __m64 v215; // mm3
  __m64 v216; // mm0
  __m64 v217; // mm1
  __m64 v218; // mm2
  __m64 v219; // mm5
  __m64 v220; // mm3
  __m64 v221; // mm2
  __m64 v222; // mm7
  __m64 v223; // mm0
  __m64 v224; // mm3
  __m64 v225; // mm1
  __m64 v226; // mm2
  __m64 v227; // mm3
  __m64 v228; // mm0
  __m64 v229; // mm1
  __m64 v230; // mm2
  __m64 v231; // mm5
  __m64 v232; // mm3
  __m64 v233; // mm2
  __m64 v234; // mm7
  __m64 v235; // mm0
  __m64 v236; // mm3
  __m64 v237; // mm1
  __m64 v238; // mm2
  __m64 v239; // mm3
  __m64 v240; // mm0
  __m64 v241; // mm1
  __m64 v242; // mm2
  __m64 v243; // mm5
  __m64 v244; // mm3
  __m64 v245; // mm2
  __m64 v246; // mm7
  __m64 v247; // mm0
  __m64 v248; // mm3
  __m64 v249; // mm1
  __m64 v250; // mm2
  __m64 v251; // mm3
  __m64 v252; // mm0
  __m64 v253; // mm1
  __m64 v254; // mm2
  __m64 v255; // mm3
  __m64 v256; // mm4
  __m64 v257; // mm5
  __m64 v258; // mm1
  __m64 v259; // mm2
  __m64 v260; // mm4
  __m64 v261; // mm1
  __m64 v262; // mm5
  __m64 v263; // mm0
  __m64 v264; // mm5
  __m64 v265; // mm2
  __m64 v266; // mm3
  __m64 v267; // mm1
  __m64 v268; // mm6
  __m64 v269; // mm3
  __m64 v270; // mm6
  __m64 v271; // mm2
  __m64 v272; // mm1
  __m64 v273; // mm5
  __m64 v274; // mm2
  __m64 v275; // mm3
  __m64 v276; // mm2
  __m64 v277; // mm3
  __m64 v278; // mm1
  __m64 v279; // mm1
  __m64 v280; // mm2
  __m64 v281; // mm3
  __m64 v282; // mm0
  __m64 v283; // mm1
  __m64 v284; // mm2
  __m64 v285; // mm5
  __m64 v286; // mm3
  __m64 v287; // mm2
  __m64 v288; // mm7
  __m64 v289; // mm0
  __m64 v290; // mm3
  __m64 v291; // mm1
  __m64 v292; // mm2
  __m64 v293; // mm3
  __m64 v294; // mm0
  __m64 v295; // mm1
  __m64 v296; // mm2
  __m64 v297; // mm5
  __m64 v298; // mm3
  __m64 v299; // mm2
  __m64 v300; // mm7
  __m64 v301; // mm0
  __m64 v302; // mm3
  __m64 v303; // mm1
  __m64 v304; // mm2
  __m64 v305; // mm3
  __m64 v306; // mm0
  __m64 v307; // mm1
  __m64 v308; // mm2
  __m64 v309; // mm5
  __m64 v310; // mm3
  __m64 v311; // mm2
  __m64 v312; // mm7
  __m64 v313; // mm0
  __m64 v314; // mm3
  __m64 v315; // mm1
  __m64 v316; // mm2
  __m64 v317; // mm3
  __m64 v318; // mm0
  __m64 v319; // mm1
  __m64 v320; // mm2
  __m64 v321; // mm3
  __m64 v322; // mm1
  __m64 v323; // mm1
  __m64 v324; // mm2
  __m64 v325; // mm3
  __m64 v326; // mm0
  __m64 v327; // mm1
  __m64 v328; // mm2
  __m64 v329; // mm5
  __m64 v330; // mm3
  __m64 v331; // mm2
  __m64 v332; // mm7
  __m64 v333; // mm0
  __m64 v334; // mm3
  __m64 v335; // mm1
  __m64 v336; // mm2
  __m64 v337; // mm3
  __m64 v338; // mm0
  __m64 v339; // mm1
  __m64 v340; // mm2
  __m64 v341; // mm5
  __m64 v342; // mm3
  __m64 v343; // mm2
  __m64 v344; // mm7
  __m64 v345; // mm0
  __m64 v346; // mm3
  __m64 v347; // mm1
  __m64 v348; // mm2
  __m64 v349; // mm3
  __m64 v350; // mm0
  __m64 v351; // mm1
  __m64 v352; // mm2
  __m64 v353; // mm5
  __m64 v354; // mm3
  __m64 v355; // mm2
  __m64 v356; // mm7
  __m64 v357; // mm0
  __m64 v358; // mm3
  __m64 v359; // mm1
  __m64 v360; // mm2
  __m64 v361; // mm3
  __m64 v362; // mm0
  __m64 v363; // mm1
  __m64 v364; // mm2
  __m64 v365; // mm3
  __m64 v366; // mm1
  __m64 v367; // [esp+0h] [ebp-C0h]
  __m64 v368; // [esp+10h] [ebp-B0h]
  __m64 v369; // [esp+28h] [ebp-98h]
  __m64 v370; // [esp+40h] [ebp-80h]
  __m64 v371; // [esp+40h] [ebp-80h]
  __m64 v372; // [esp+48h] [ebp-78h]
  __m64 v373; // [esp+48h] [ebp-78h]
  __m64 v374; // [esp+50h] [ebp-70h]
  __m64 v375; // [esp+50h] [ebp-70h]
  __m64 v376; // [esp+58h] [ebp-68h]
  __m64 v377; // [esp+58h] [ebp-68h]
  __m64 v378; // [esp+60h] [ebp-60h]
  __m64 v379; // [esp+60h] [ebp-60h]
  __m64 v380; // [esp+68h] [ebp-58h]
  __m64 v381; // [esp+68h] [ebp-58h]
  __m64 v382; // [esp+78h] [ebp-48h]
  __m64 v383; // [esp+78h] [ebp-48h]
  __m64 v384; // [esp+80h] [ebp-40h]
  __m64 v385; // [esp+88h] [ebp-38h]
  __m64 v386; // [esp+90h] [ebp-30h]
  __m64 v387; // [esp+98h] [ebp-28h]
  __m64 v388; // [esp+A0h] [ebp-20h]
  __m64 v389; // [esp+A8h] [ebp-18h]
  __m64 v390; // [esp+B0h] [ebp-10h]
  __m64 v391; // [esp+B8h] [ebp-8h]

  result = a1;
  if ( a4 )
  {
    if ( a3 )
    {
      v367 = _m_punpckldq((__m64)a4->m64_u64, 0);
      v368 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      v369 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v8 = a3[1];
      v9 = _m_pfadd(v8, v8);
      v10 = _m_pfadd((__m64)a3->m64_u64, (__m64)a3->m64_u64);
      v11 = _m_pfmul(v10, (__m64)a3->m64_u64);
      v12 = _m_punpckldq(v10, v9);
      v13 = _m_pfmul((__m64)a3->m64_u64, v9);
      v14 = _m_pfmul(_m_pswapd((__m64)a3->m64_u64), v9);
      v15 = _m_pfmul(v9, v8);
      v16 = _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v8), v12);
      v17 = _m_pfpnacc(v14, v14);
      v18 = _m_pfpnacc(v16, v16);
      v19 = _m_pfpnacc(v13, v13);
      v20 = _m_pfsub(_m_pfsubr(v11, (__m64)0x3F8000003F800000LL), _m_punpckldq(v15, v15));
      v378 = _m_punpckldq(_m_pswapd(v19), v17);
      v372 = _m_punpckldq(v19, 0);
      v380 = _m_punpckhdq(_m_pfsubr(_m_pfacc(v11, v11), (__m64)0x3F8000003F800000LL), 0);
      v370 = _m_punpckhdq(v20, v18);
      v374 = _m_punpckldq(v18, v20);
      v376 = _m_punpckhdq(v17, 0);
      v382 = _m_punpckldq(0, (__m64)1065353216LL);
      if ( a2 )
      {
        v384 = _m_punpckldq(v370, v374);
        v386 = _m_punpckhdq(v370, v374);
        v389 = _m_punpckldq(v380, v382);
        v391 = _m_punpckhdq(v380, v382);
        v388 = _m_punpckldq(v372, v376);
        v390 = _m_punpckhdq(v372, v376);
        v387 = _m_punpckhdq(v378, 0);
        v385 = _m_punpckldq(v378, 0);
        result = a1;
        m64_u64 = (__m64)a2->m64_u64;
        v22 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
        v23 = _mm_cvtsi32_si64(0x3F800000u);
        v24 = _m_pswapd(v23);
        a1->m64_u64 = (unsigned __int64)v23;
        a1[1].m64_u64 = 0;
        a1[2].m64_u64 = (unsigned __int64)v24;
        a1[3].m64_u64 = 0;
        a1[4].m64_u64 = 0;
        a1[5].m64_u64 = (unsigned __int64)v23;
        v25 = _m_pfsub(v24, v22);
        a1[7].m64_u64 = (unsigned __int64)v25;
        a1[6].m64_u64 = (unsigned __int64)_m_pfsub(0, m64_u64);
        v26 = a1[1];
        v27 = _m_punpckhdq(v25, (__m64)a1->m64_u64);
        v28 = _m_punpckhdq(m64_u64, v26);
        v29 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v30 = _m_punpckldq(v26, v26);
        v31 = _m_punpckhdq(v27, v27);
        v32 = _m_pfmul(v386, v31);
        v33 = _m_punpckhdq(v28, v28);
        v34 = _m_pfadd(_m_pfadd(_m_pfmul(v31, v387), _m_pfmul(v29, v385)), _m_pfmul(v30, v389));
        v35 = _m_pfadd(_m_pfmul(v390, v33), _m_pfadd(_m_pfmul(v388, v30), _m_pfadd(v32, _m_pfmul(v384, v29))));
        v36 = a1[2];
        v37 = _m_pfadd(_m_pfmul(v33, v391), v34);
        v38 = a1[3];
        a1->m64_u64 = (unsigned __int64)v35;
        a1[1].m64_u64 = (unsigned __int64)v37;
        v39 = _m_punpckhdq(v34, v36);
        v40 = _m_punpckhdq(v37, v38);
        v41 = _m_punpckldq(v36, v36);
        v42 = _m_punpckldq(v38, v38);
        v43 = _m_punpckhdq(v39, v39);
        v44 = _m_pfmul(v386, v43);
        v45 = _m_punpckhdq(v40, v40);
        v46 = _m_pfadd(_m_pfadd(_m_pfmul(v43, v387), _m_pfmul(v41, v385)), _m_pfmul(v42, v389));
        v47 = _m_pfadd(_m_pfmul(v390, v45), _m_pfadd(_m_pfmul(v388, v42), _m_pfadd(v44, _m_pfmul(v384, v41))));
        v48 = a1[4];
        v49 = _m_pfadd(_m_pfmul(v45, v391), v46);
        v50 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v47;
        a1[3].m64_u64 = (unsigned __int64)v49;
        v51 = _m_punpckhdq(v46, v48);
        v52 = _m_punpckhdq(v49, v50);
        v53 = _m_punpckldq(v48, v48);
        v54 = _m_punpckldq(v50, v50);
        v55 = _m_punpckhdq(v51, v51);
        v56 = _m_pfmul(v386, v55);
        v57 = _m_punpckhdq(v52, v52);
        v58 = _m_pfadd(_m_pfadd(_m_pfmul(v55, v387), _m_pfmul(v53, v385)), _m_pfmul(v54, v389));
        v59 = _m_pfadd(_m_pfmul(v390, v57), _m_pfadd(_m_pfmul(v388, v54), _m_pfadd(v56, _m_pfmul(v384, v53))));
        v60 = a1[6];
        v61 = _m_pfadd(_m_pfmul(v57, v391), v58);
        v62 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v59;
        a1[5].m64_u64 = (unsigned __int64)v61;
        v63 = _m_punpckhdq(v58, v60);
        v64 = _m_punpckhdq(v61, v62);
        v65 = _m_punpckldq(v60, v60);
        v66 = _m_punpckldq(v62, v62);
        v67 = _m_punpckhdq(v63, v63);
        v68 = _m_pfmul(v386, v67);
        v69 = _m_punpckhdq(v64, v64);
        v70 = _m_pfmul(v390, v69);
        v71 = _m_pfadd(_m_pfadd(_m_pfmul(v67, v387), _m_pfmul(v65, v385)), _m_pfmul(v66, v389));
        v72 = _m_pfadd(_m_pfmul(v69, v391), v71);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v70,
                                            _m_pfadd(_m_pfmul(v388, v66), _m_pfadd(v68, _m_pfmul(v384, v65))));
        a1[7].m64_u64 = (unsigned __int64)v72;
        v73 = a1[1];
        v74 = _m_punpckhdq(v71, (__m64)a1->m64_u64);
        v75 = _m_punpckhdq(v72, v73);
        v76 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v77 = _m_punpckldq(v73, v73);
        v78 = _m_punpckhdq(v74, v74);
        v79 = _m_pfmul(v368, v78);
        v80 = _m_punpckhdq(v75, v75);
        v81 = _m_pfadd(_m_pfadd(_m_pfmul(v78, 0), _m_pfmul(v76, 0)), _m_pfmul(v77, v369));
        v82 = _m_pfadd(_m_pfmul(0, v80), _m_pfadd(_m_pfmul(0, v77), _m_pfadd(v79, _m_pfmul(v367, v76))));
        v83 = a1[2];
        v84 = _m_pfadd(_m_pfmul(v80, (__m64)0x3F80000000000000LL), v81);
        v85 = a1[3];
        a1->m64_u64 = (unsigned __int64)v82;
        a1[1].m64_u64 = (unsigned __int64)v84;
        v86 = _m_punpckhdq(v81, v83);
        v87 = _m_punpckhdq(v84, v85);
        v88 = _m_punpckldq(v83, v83);
        v89 = _m_punpckldq(v85, v85);
        v90 = _m_punpckhdq(v86, v86);
        v91 = _m_pfmul(v368, v90);
        v92 = _m_punpckhdq(v87, v87);
        v93 = _m_pfadd(_m_pfadd(_m_pfmul(v90, 0), _m_pfmul(v88, 0)), _m_pfmul(v89, v369));
        v94 = _m_pfadd(_m_pfmul(0, v92), _m_pfadd(_m_pfmul(0, v89), _m_pfadd(v91, _m_pfmul(v367, v88))));
        v95 = a1[4];
        v96 = _m_pfadd(_m_pfmul(v92, (__m64)0x3F80000000000000LL), v93);
        v97 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v94;
        a1[3].m64_u64 = (unsigned __int64)v96;
        v98 = _m_punpckhdq(v93, v95);
        v99 = _m_punpckhdq(v96, v97);
        v100 = _m_punpckldq(v95, v95);
        v101 = _m_punpckldq(v97, v97);
        v102 = _m_punpckhdq(v98, v98);
        v103 = _m_pfmul(v368, v102);
        v104 = _m_punpckhdq(v99, v99);
        v105 = _m_pfadd(_m_pfadd(_m_pfmul(v102, 0), _m_pfmul(v100, 0)), _m_pfmul(v101, v369));
        v106 = _m_pfadd(_m_pfmul(0, v104), _m_pfadd(_m_pfmul(0, v101), _m_pfadd(v103, _m_pfmul(v367, v100))));
        v107 = a1[6];
        v108 = _m_pfadd(_m_pfmul(v104, (__m64)0x3F80000000000000LL), v105);
        v109 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v106;
        a1[5].m64_u64 = (unsigned __int64)v108;
        v110 = _m_punpckhdq(v105, v107);
        v111 = _m_punpckhdq(v108, v109);
        v112 = _m_punpckldq(v107, v107);
        v113 = _m_punpckldq(v109, v109);
        v114 = _m_punpckhdq(v110, v110);
        v115 = _m_pfmul(v368, v114);
        v116 = _m_punpckhdq(v111, v111);
        v117 = _m_pfmul(0, v116);
        v118 = _m_pfadd(_m_pfadd(_m_pfmul(v114, 0), _m_pfmul(v112, 0)), _m_pfmul(v113, v369));
        v119 = _m_pfadd(_m_pfmul(v116, (__m64)0x3F80000000000000LL), v118);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v117,
                                            _m_pfadd(_m_pfmul(0, v113), _m_pfadd(v115, _m_pfmul(v367, v112))));
        a1[7].m64_u64 = (unsigned __int64)v119;
        v120 = a1[1];
        v121 = _m_punpckhdq(v118, (__m64)a1->m64_u64);
        v122 = _m_punpckhdq(v119, v120);
        v123 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v124 = _m_punpckldq(v120, v120);
        v125 = _m_punpckhdq(v121, v121);
        v126 = _m_pfmul(v374, v125);
        v127 = _m_punpckhdq(v122, v122);
        v128 = _m_pfadd(_m_pfadd(_m_pfmul(v125, v376), _m_pfmul(v123, v372)), _m_pfmul(v124, v380));
        v129 = _m_pfadd(_m_pfmul(0, v127), _m_pfadd(_m_pfmul(v378, v124), _m_pfadd(v126, _m_pfmul(v370, v123))));
        v130 = a1[2];
        v131 = _m_pfadd(_m_pfmul(v127, v382), v128);
        v132 = a1[3];
        a1->m64_u64 = (unsigned __int64)v129;
        a1[1].m64_u64 = (unsigned __int64)v131;
        v133 = _m_punpckhdq(v128, v130);
        v134 = _m_punpckhdq(v131, v132);
        v135 = _m_punpckldq(v130, v130);
        v136 = _m_punpckldq(v132, v132);
        v137 = _m_punpckhdq(v133, v133);
        v138 = _m_pfmul(v374, v137);
        v139 = _m_punpckhdq(v134, v134);
        v140 = _m_pfadd(_m_pfadd(_m_pfmul(v137, v376), _m_pfmul(v135, v372)), _m_pfmul(v136, v380));
        v141 = _m_pfadd(_m_pfmul(0, v139), _m_pfadd(_m_pfmul(v378, v136), _m_pfadd(v138, _m_pfmul(v370, v135))));
        v142 = a1[4];
        v143 = _m_pfadd(_m_pfmul(v139, v382), v140);
        v144 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v141;
        a1[3].m64_u64 = (unsigned __int64)v143;
        v145 = _m_punpckhdq(v140, v142);
        v146 = _m_punpckhdq(v143, v144);
        v147 = _m_punpckldq(v142, v142);
        v148 = _m_punpckldq(v144, v144);
        v149 = _m_punpckhdq(v145, v145);
        v150 = _m_pfmul(v374, v149);
        v151 = _m_punpckhdq(v146, v146);
        v152 = _m_pfadd(_m_pfadd(_m_pfmul(v149, v376), _m_pfmul(v147, v372)), _m_pfmul(v148, v380));
        v153 = _m_pfadd(_m_pfmul(0, v151), _m_pfadd(_m_pfmul(v378, v148), _m_pfadd(v150, _m_pfmul(v370, v147))));
        v154 = a1[6];
        v155 = _m_pfadd(_m_pfmul(v151, v382), v152);
        v156 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v153;
        a1[5].m64_u64 = (unsigned __int64)v155;
        v157 = _m_punpckhdq(v152, v154);
        v158 = _m_punpckhdq(v155, v156);
        v159 = _m_punpckldq(v154, v154);
        v160 = _m_punpckldq(v156, v156);
        v161 = _m_punpckhdq(v157, v157);
        v162 = _m_punpckhdq(v158, v158);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v162),
                                            _m_pfadd(
                                              _m_pfmul(v378, v160),
                                              _m_pfadd(_m_pfmul(v374, v161), _m_pfmul(v370, v159))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v162, v382),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v161, v376), _m_pfmul(v159, v372)),
                                              _m_pfmul(v160, v380)));
        v163 = _m_pfadd(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a2->m64_u64, a1[6]);
        a1[7].m64_i32[0] = _mm_cvtsi64_si32(v163);
      }
      else
      {
        result = a1;
        a1->m64_u64 = (unsigned __int64)_m_punpckldq(v370, v374);
        a1[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v370, v374);
        v164 = _m_punpckldq(v380, v382);
        a1[5].m64_u64 = (unsigned __int64)v164;
        a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v380, v382);
        a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v372, v376);
        v165 = _m_punpckldq(v378, 0);
        a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v372, v376);
        a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v378, 0);
        a1[1].m64_u64 = (unsigned __int64)v165;
        v166 = a1[1];
        v167 = _m_punpckhdq(v165, (__m64)a1->m64_u64);
        v168 = _m_punpckhdq(v164, v166);
        v169 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v170 = _m_punpckldq(v166, v166);
        v171 = _m_punpckhdq(v167, v167);
        v172 = _m_pfmul(v368, v171);
        v173 = _m_punpckhdq(v168, v168);
        v174 = _m_pfadd(_m_pfadd(_m_pfmul(v171, 0), _m_pfmul(v169, 0)), _m_pfmul(v170, v369));
        v175 = _m_pfadd(_m_pfmul(0, v173), _m_pfadd(_m_pfmul(0, v170), _m_pfadd(v172, _m_pfmul(v367, v169))));
        v176 = a1[2];
        v177 = _m_pfadd(_m_pfmul(v173, (__m64)0x3F80000000000000LL), v174);
        v178 = a1[3];
        a1->m64_u64 = (unsigned __int64)v175;
        a1[1].m64_u64 = (unsigned __int64)v177;
        v179 = _m_punpckhdq(v174, v176);
        v180 = _m_punpckhdq(v177, v178);
        v181 = _m_punpckldq(v176, v176);
        v182 = _m_punpckldq(v178, v178);
        v183 = _m_punpckhdq(v179, v179);
        v184 = _m_pfmul(v368, v183);
        v185 = _m_punpckhdq(v180, v180);
        v186 = _m_pfadd(_m_pfadd(_m_pfmul(v183, 0), _m_pfmul(v181, 0)), _m_pfmul(v182, v369));
        v187 = _m_pfadd(_m_pfmul(0, v185), _m_pfadd(_m_pfmul(0, v182), _m_pfadd(v184, _m_pfmul(v367, v181))));
        v188 = a1[4];
        v189 = _m_pfadd(_m_pfmul(v185, (__m64)0x3F80000000000000LL), v186);
        v190 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v187;
        a1[3].m64_u64 = (unsigned __int64)v189;
        v191 = _m_punpckhdq(v186, v188);
        v192 = _m_punpckhdq(v189, v190);
        v193 = _m_punpckldq(v188, v188);
        v194 = _m_punpckldq(v190, v190);
        v195 = _m_punpckhdq(v191, v191);
        v196 = _m_pfmul(v368, v195);
        v197 = _m_punpckhdq(v192, v192);
        v198 = _m_pfadd(_m_pfadd(_m_pfmul(v195, 0), _m_pfmul(v193, 0)), _m_pfmul(v194, v369));
        v199 = _m_pfadd(_m_pfmul(0, v197), _m_pfadd(_m_pfmul(0, v194), _m_pfadd(v196, _m_pfmul(v367, v193))));
        v200 = a1[6];
        v201 = _m_pfadd(_m_pfmul(v197, (__m64)0x3F80000000000000LL), v198);
        v202 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v199;
        a1[5].m64_u64 = (unsigned __int64)v201;
        v203 = _m_punpckhdq(v198, v200);
        v204 = _m_punpckhdq(v201, v202);
        v205 = _m_punpckldq(v200, v200);
        v206 = _m_punpckldq(v202, v202);
        v207 = _m_punpckhdq(v203, v203);
        v208 = _m_pfmul(v368, v207);
        v209 = _m_punpckhdq(v204, v204);
        v210 = _m_pfmul(0, v209);
        v211 = _m_pfadd(_m_pfadd(_m_pfmul(v207, 0), _m_pfmul(v205, 0)), _m_pfmul(v206, v369));
        v212 = _m_pfadd(_m_pfmul(v209, (__m64)0x3F80000000000000LL), v211);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v210,
                                            _m_pfadd(_m_pfmul(0, v206), _m_pfadd(v208, _m_pfmul(v367, v205))));
        a1[7].m64_u64 = (unsigned __int64)v212;
        v213 = a1[1];
        v214 = _m_punpckhdq(v211, (__m64)a1->m64_u64);
        v215 = _m_punpckhdq(v212, v213);
        v216 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v217 = _m_punpckldq(v213, v213);
        v218 = _m_punpckhdq(v214, v214);
        v219 = _m_pfmul(v374, v218);
        v220 = _m_punpckhdq(v215, v215);
        v221 = _m_pfadd(_m_pfadd(_m_pfmul(v218, v376), _m_pfmul(v216, v372)), _m_pfmul(v217, v380));
        v222 = _m_pfadd(_m_pfmul(0, v220), _m_pfadd(_m_pfmul(v378, v217), _m_pfadd(v219, _m_pfmul(v370, v216))));
        v223 = a1[2];
        v224 = _m_pfadd(_m_pfmul(v220, v382), v221);
        v225 = a1[3];
        a1->m64_u64 = (unsigned __int64)v222;
        a1[1].m64_u64 = (unsigned __int64)v224;
        v226 = _m_punpckhdq(v221, v223);
        v227 = _m_punpckhdq(v224, v225);
        v228 = _m_punpckldq(v223, v223);
        v229 = _m_punpckldq(v225, v225);
        v230 = _m_punpckhdq(v226, v226);
        v231 = _m_pfmul(v374, v230);
        v232 = _m_punpckhdq(v227, v227);
        v233 = _m_pfadd(_m_pfadd(_m_pfmul(v230, v376), _m_pfmul(v228, v372)), _m_pfmul(v229, v380));
        v234 = _m_pfadd(_m_pfmul(0, v232), _m_pfadd(_m_pfmul(v378, v229), _m_pfadd(v231, _m_pfmul(v370, v228))));
        v235 = a1[4];
        v236 = _m_pfadd(_m_pfmul(v232, v382), v233);
        v237 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v234;
        a1[3].m64_u64 = (unsigned __int64)v236;
        v238 = _m_punpckhdq(v233, v235);
        v239 = _m_punpckhdq(v236, v237);
        v240 = _m_punpckldq(v235, v235);
        v241 = _m_punpckldq(v237, v237);
        v242 = _m_punpckhdq(v238, v238);
        v243 = _m_pfmul(v374, v242);
        v244 = _m_punpckhdq(v239, v239);
        v245 = _m_pfadd(_m_pfadd(_m_pfmul(v242, v376), _m_pfmul(v240, v372)), _m_pfmul(v241, v380));
        v246 = _m_pfadd(_m_pfmul(0, v244), _m_pfadd(_m_pfmul(v378, v241), _m_pfadd(v243, _m_pfmul(v370, v240))));
        v247 = a1[6];
        v248 = _m_pfadd(_m_pfmul(v244, v382), v245);
        v249 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v246;
        a1[5].m64_u64 = (unsigned __int64)v248;
        v250 = _m_punpckhdq(v245, v247);
        v251 = _m_punpckhdq(v248, v249);
        v252 = _m_punpckldq(v247, v247);
        v253 = _m_punpckldq(v249, v249);
        v254 = _m_punpckhdq(v250, v250);
        v255 = _m_punpckhdq(v251, v251);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v255),
                                            _m_pfadd(
                                              _m_pfmul(v378, v253),
                                              _m_pfadd(_m_pfmul(v374, v254), _m_pfmul(v370, v252))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v255, v382),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v254, v376), _m_pfmul(v252, v372)),
                                              _m_pfmul(v253, v380)));
      }
    }
    else
    {
      v256 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v257 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a4->m64_u64, 0);
      a1[1].m64_u64 = 0;
      a1[2].m64_u64 = (unsigned __int64)v257;
      a1[3].m64_u64 = 0;
      a1[4].m64_u64 = 0;
      a1[5].m64_u64 = (unsigned __int64)v256;
      a1[6].m64_u64 = 0;
      a1[7].m64_u64 = 0x3F80000000000000LL;
    }
  }
  else
  {
    v258 = _mm_cvtsi32_si64(0x3F800000u);
    v259 = _m_pswapd(v258);
    a1->m64_u64 = (unsigned __int64)v258;
    a1[1].m64_u64 = 0;
    a1[2].m64_u64 = (unsigned __int64)v259;
    a1[3].m64_u64 = 0;
    a1[4].m64_u64 = 0;
    a1[5].m64_u64 = (unsigned __int64)v258;
    a1[6].m64_u64 = 0;
    a1[7].m64_u64 = (unsigned __int64)v259;
  }
  if ( a6 )
  {
    v260 = a6[1];
    v261 = _m_pfadd(v260, v260);
    v262 = _m_pfadd((__m64)a6->m64_u64, (__m64)a6->m64_u64);
    v263 = _m_pfmul(v262, (__m64)a6->m64_u64);
    v264 = _m_punpckldq(v262, v261);
    v265 = _m_pfmul((__m64)a6->m64_u64, v261);
    v266 = _m_pfmul(_m_pswapd((__m64)a6->m64_u64), v261);
    v267 = _m_pfmul(v261, v260);
    v268 = _m_pfmul(_m_punpckhdq((__m64)a6->m64_u64, v260), v264);
    v269 = _m_pfpnacc(v266, v266);
    v270 = _m_pfpnacc(v268, v268);
    v271 = _m_pfpnacc(v265, v265);
    v272 = _m_pfsub(_m_pfsubr(v263, (__m64)0x3F8000003F800000LL), _m_punpckldq(v267, v267));
    v273 = _m_punpckldq(_m_pswapd(v271), v269);
    v274 = _m_punpckldq(v271, 0);
    v379 = v273;
    v275 = _m_punpckhdq(v269, 0);
    v373 = v274;
    v381 = _m_punpckhdq(_m_pfsubr(_m_pfacc(v263, v263), (__m64)0x3F8000003F800000LL), 0);
    v371 = _m_punpckhdq(v272, v270);
    v375 = _m_punpckldq(v270, v272);
    v377 = v275;
    v383 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a5 )
    {
      v276 = (__m64)a5->m64_u64;
      v277 = _mm_cvtsi32_si64(a5[1].m64_u32[0]);
      v278 = _m_pfsub(_mm_cvtsi32_si64(result[7].m64_u32[0]), v277);
      result[6].m64_u64 = (unsigned __int64)_m_pfsub(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v278);
      v279 = result[1];
      v280 = _m_punpckhdq(v276, (__m64)result->m64_u64);
      v281 = _m_punpckhdq(v277, v279);
      v282 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v283 = _m_punpckldq(v279, v279);
      v284 = _m_punpckhdq(v280, v280);
      v285 = _m_pfmul(v375, v284);
      v286 = _m_punpckhdq(v281, v281);
      v287 = _m_pfadd(_m_pfadd(_m_pfmul(v284, v377), _m_pfmul(v282, v373)), _m_pfmul(v283, v381));
      v288 = _m_pfadd(_m_pfmul(0, v286), _m_pfadd(_m_pfmul(v379, v283), _m_pfadd(v285, _m_pfmul(v371, v282))));
      v289 = result[2];
      v290 = _m_pfadd(_m_pfmul(v286, v383), v287);
      v291 = result[3];
      result->m64_u64 = (unsigned __int64)v288;
      result[1].m64_u64 = (unsigned __int64)v290;
      v292 = _m_punpckhdq(v287, v289);
      v293 = _m_punpckhdq(v290, v291);
      v294 = _m_punpckldq(v289, v289);
      v295 = _m_punpckldq(v291, v291);
      v296 = _m_punpckhdq(v292, v292);
      v297 = _m_pfmul(v375, v296);
      v298 = _m_punpckhdq(v293, v293);
      v299 = _m_pfadd(_m_pfadd(_m_pfmul(v296, v377), _m_pfmul(v294, v373)), _m_pfmul(v295, v381));
      v300 = _m_pfadd(_m_pfmul(0, v298), _m_pfadd(_m_pfmul(v379, v295), _m_pfadd(v297, _m_pfmul(v371, v294))));
      v301 = result[4];
      v302 = _m_pfadd(_m_pfmul(v298, v383), v299);
      v303 = result[5];
      result[2].m64_u64 = (unsigned __int64)v300;
      result[3].m64_u64 = (unsigned __int64)v302;
      v304 = _m_punpckhdq(v299, v301);
      v305 = _m_punpckhdq(v302, v303);
      v306 = _m_punpckldq(v301, v301);
      v307 = _m_punpckldq(v303, v303);
      v308 = _m_punpckhdq(v304, v304);
      v309 = _m_pfmul(v375, v308);
      v310 = _m_punpckhdq(v305, v305);
      v311 = _m_pfadd(_m_pfadd(_m_pfmul(v308, v377), _m_pfmul(v306, v373)), _m_pfmul(v307, v381));
      v312 = _m_pfadd(_m_pfmul(0, v310), _m_pfadd(_m_pfmul(v379, v307), _m_pfadd(v309, _m_pfmul(v371, v306))));
      v313 = result[6];
      v314 = _m_pfadd(_m_pfmul(v310, v383), v311);
      v315 = result[7];
      result[4].m64_u64 = (unsigned __int64)v312;
      result[5].m64_u64 = (unsigned __int64)v314;
      v316 = _m_punpckhdq(v311, v313);
      v317 = _m_punpckhdq(v314, v315);
      v318 = _m_punpckldq(v313, v313);
      v319 = _m_punpckldq(v315, v315);
      v320 = _m_punpckhdq(v316, v316);
      v321 = _m_punpckhdq(v317, v317);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v321),
                                              _m_pfadd(
                                                _m_pfmul(v379, v319),
                                                _m_pfadd(_m_pfmul(v375, v320), _m_pfmul(v371, v318))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v321, v383),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v320, v377), _m_pfmul(v318, v373)),
                                                _m_pfmul(v319, v381)));
      v322 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a5[1].m64_u32[0]));
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v322);
    }
    else
    {
      v323 = result[1];
      v324 = _m_punpckhdq(v274, (__m64)result->m64_u64);
      v325 = _m_punpckhdq(v275, v323);
      v326 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v327 = _m_punpckldq(v323, v323);
      v328 = _m_punpckhdq(v324, v324);
      v329 = _m_pfmul(v375, v328);
      v330 = _m_punpckhdq(v325, v325);
      v331 = _m_pfadd(_m_pfadd(_m_pfmul(v328, v377), _m_pfmul(v326, v373)), _m_pfmul(v327, v381));
      v332 = _m_pfadd(_m_pfmul(0, v330), _m_pfadd(_m_pfmul(v379, v327), _m_pfadd(v329, _m_pfmul(v371, v326))));
      v333 = result[2];
      v334 = _m_pfadd(_m_pfmul(v330, v383), v331);
      v335 = result[3];
      result->m64_u64 = (unsigned __int64)v332;
      result[1].m64_u64 = (unsigned __int64)v334;
      v336 = _m_punpckhdq(v331, v333);
      v337 = _m_punpckhdq(v334, v335);
      v338 = _m_punpckldq(v333, v333);
      v339 = _m_punpckldq(v335, v335);
      v340 = _m_punpckhdq(v336, v336);
      v341 = _m_pfmul(v375, v340);
      v342 = _m_punpckhdq(v337, v337);
      v343 = _m_pfadd(_m_pfadd(_m_pfmul(v340, v377), _m_pfmul(v338, v373)), _m_pfmul(v339, v381));
      v344 = _m_pfadd(_m_pfmul(0, v342), _m_pfadd(_m_pfmul(v379, v339), _m_pfadd(v341, _m_pfmul(v371, v338))));
      v345 = result[4];
      v346 = _m_pfadd(_m_pfmul(v342, v383), v343);
      v347 = result[5];
      result[2].m64_u64 = (unsigned __int64)v344;
      result[3].m64_u64 = (unsigned __int64)v346;
      v348 = _m_punpckhdq(v343, v345);
      v349 = _m_punpckhdq(v346, v347);
      v350 = _m_punpckldq(v345, v345);
      v351 = _m_punpckldq(v347, v347);
      v352 = _m_punpckhdq(v348, v348);
      v353 = _m_pfmul(v375, v352);
      v354 = _m_punpckhdq(v349, v349);
      v355 = _m_pfadd(_m_pfadd(_m_pfmul(v352, v377), _m_pfmul(v350, v373)), _m_pfmul(v351, v381));
      v356 = _m_pfadd(_m_pfmul(0, v354), _m_pfadd(_m_pfmul(v379, v351), _m_pfadd(v353, _m_pfmul(v371, v350))));
      v357 = result[6];
      v358 = _m_pfadd(_m_pfmul(v354, v383), v355);
      v359 = result[7];
      result[4].m64_u64 = (unsigned __int64)v356;
      result[5].m64_u64 = (unsigned __int64)v358;
      v360 = _m_punpckhdq(v355, v357);
      v361 = _m_punpckhdq(v358, v359);
      v362 = _m_punpckldq(v357, v357);
      v363 = _m_punpckldq(v359, v359);
      v364 = _m_punpckhdq(v360, v360);
      v365 = _m_punpckhdq(v361, v361);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v365),
                                              _m_pfadd(
                                                _m_pfmul(v379, v363),
                                                _m_pfadd(_m_pfmul(v375, v364), _m_pfmul(v371, v362))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v365, v383),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v364, v377), _m_pfmul(v362, v373)),
                                                _m_pfmul(v363, v381)));
    }
  }
  if ( a7 )
  {
    v366 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a7[1].m64_u32[0]));
    result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a7->m64_u64);
    result[7].m64_i32[0] = _mm_cvtsi64_si32(v366);
  }
  _m_femms();
  return result;
}

// sub_1002C7C0 @ 0x1002C7C0
int __stdcall sub_1002C7C0(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm0
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm7
  __m64 v11; // mm2
  __m64 v12; // rt1
  __m64 v13; // mm1
  __m64 v14; // mm0
  __m64 v15; // mm5
  __m64 v16; // mm6
  __m64 v17; // mm1
  __m64 v18; // mm0
  __m64 v19; // mm7
  __m64 v20; // mm2
  __m64 v21; // mm0
  __m64 v22; // mm0
  __m64 v23; // mm1
  int result; // eax
  __m64 v25; // mm0
  __m64 v26; // mm1
  __m64 v27; // mm3
  __m64 v28; // mm6
  __m64 v29; // mm4
  __m64 v30; // mm7
  __m64 v31; // mm3
  __m64 v32; // mm6
  __m64 v33; // mm4
  __m64 v34; // mm7
  __m64 v35; // [esp+0h] [ebp-40h]
  __m64 v36; // [esp+8h] [ebp-38h]
  __m64 v37; // [esp+10h] [ebp-30h]
  __m64 v38; // [esp+18h] [ebp-28h]
  __m64 v39; // [esp+20h] [ebp-20h]
  __m64 v40; // [esp+28h] [ebp-18h]
  __m64 v41; // [esp+30h] [ebp-10h]
  __m64 v42; // [esp+38h] [ebp-8h]

  v3 = a3[2];
  v4 = a3[4];
  v5 = _m_pswapd(a3[6]);
  v6 = _m_pfnacc(_m_pfmul(_m_pswapd(v3), (__m64)a3->m64_u64), _m_pfmul(_m_pswapd(v4), (__m64)a3->m64_u64));
  v7 = _m_pfnacc(_m_pfmul(v5, (__m64)a3->m64_u64), _m_pfmul(_m_pswapd(v4), v3));
  v8 = _m_pfnacc(_m_pfmul(v3, v5), _m_pfmul(v4, v5));
  v9 = a3[7];
  v10 = a3[5];
  v36 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v7, v7), v9), _m_pfmul(_m_punpckhdq(v8, v8), a3[3])),
          _m_pfmul(_m_punpckldq(v8, v8), v10));
  v38 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v6, v6), v9), _m_pfmul(_m_punpckldq(v7, v7), v10)),
          _m_pfmul(_m_punpckhdq(v8, v8), a3[1]));
  v11 = _m_punpckldq(v6, v6);
  v40 = _m_pfsub(
          _m_pfadd(_m_pfmul(v9, v11), _m_pfmul(_m_punpckldq(v8, v8), a3[1])),
          _m_pfmul(_m_punpckldq(v7, v7), a3[3]));
  v12 = a3[1];
  v42 = _m_pfadd(
          _m_pfsub(_m_pfmul(v11, v10), _m_pfmul(_m_punpckhdq(v6, v6), a3[3])),
          _m_pfmul(_m_punpckhdq(v7, v7), v12));
  v13 = a3[3];
  v14 = _m_pswapd(v9);
  v15 = _m_pfnacc(_m_pfmul(_m_pswapd(v13), v12), _m_pfmul(_m_pswapd(v10), v12));
  v16 = _m_pfnacc(_m_pfmul(v14, v12), _m_pfmul(_m_pswapd(v10), v13));
  v17 = _m_pfnacc(_m_pfmul(v13, v14), _m_pfmul(v10, v14));
  v18 = a3[6];
  v19 = a3[4];
  v35 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v16, v16), v18), _m_pfmul(_m_punpckhdq(v17, v17), a3[2])),
          _m_pfmul(_m_punpckldq(v17, v17), v19));
  v37 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v15, v15), v18), _m_pfmul(_m_punpckldq(v16, v16), v19)),
          _m_pfmul(_m_punpckhdq(v17, v17), (__m64)a3->m64_u64));
  v20 = _m_punpckldq(v15, v15);
  v39 = _m_pfsub(
          _m_pfadd(_m_pfmul(v18, v20), _m_pfmul(_m_punpckldq(v17, v17), (__m64)a3->m64_u64)),
          _m_pfmul(_m_punpckldq(v16, v16), a3[2]));
  v41 = _m_pfadd(
          _m_pfsub(_m_pfmul(v20, v19), _m_pfmul(_m_punpckhdq(v15, v15), a3[2])),
          _m_pfmul(_m_punpckhdq(v16, v16), (__m64)a3->m64_u64));
  v21 = _m_pfnacc(
          _m_pfmul(_m_punpckhdq(v39, v41), _m_punpckldq(v19, v18)),
          _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3[2].m64_u32[0]), _m_punpckhdq(v35, v37)));
  v22 = _m_pfacc(v21, v21);
  if ( a2 )
    *a2 = _mm_cvtsi64_si32(v22);
  v23 = _m_pfrcp(v22);
  result = _mm_cvtsi64_si32(_m_pfcmpeq(0, v22));
  v25 = _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(_m_punpckldq(v22, v22), v23), v23), (__m64)0xBF8000003F800000uLL);
  v26 = _m_pswapd(v25);
  if ( !result )
  {
    result = (int)a1;
    v27 = _m_pfmul(v37, v25);
    v28 = _m_pfmul(v38, v25);
    v29 = _m_pfmul(v35, v26);
    v30 = _m_pfmul(v36, v26);
    a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v29, v27);
    a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v29, v27);
    a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(v30, v28);
    a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(v30, v28);
    v31 = _m_pfmul(v41, v25);
    v32 = _m_pfmul(v42, v25);
    v33 = _m_pfmul(v39, v26);
    v34 = _m_pfmul(v40, v26);
    a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v33, v31);
    a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v33, v31);
    a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(v34, v32);
    a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(v34, v32);
  }
  _m_femms();
  return result;
}

// sub_1002CAA2 @ 0x1002CAA2
__m64 *__stdcall sub_1002CAA2(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm4
  __m64 v5; // mm5
  __m64 v6; // mm7
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm4
  __m64 *result; // eax
  __m64 v11; // mm4
  __m64 v12; // mm4
  __m64 v13; // mm4
  __m64 v14; // mm4
  __m64 v15; // mm4
  __m64 v16; // mm4
  __m64 v17; // mm4
  __m64 v18; // [esp+0h] [ebp-44h]
  __m64 v19; // [esp+0h] [ebp-44h]
  __m64 v20; // [esp+8h] [ebp-3Ch]
  __m64 v21; // [esp+8h] [ebp-3Ch]
  __m64 v22; // [esp+10h] [ebp-34h]
  __m64 v23; // [esp+10h] [ebp-34h]
  __m64 v24; // [esp+18h] [ebp-2Ch]
  __m64 v25; // [esp+18h] [ebp-2Ch]
  __m64 v26; // [esp+20h] [ebp-24h]
  __m64 v27; // [esp+20h] [ebp-24h]
  __m64 v28; // [esp+28h] [ebp-1Ch]
  __m64 v29; // [esp+28h] [ebp-1Ch]
  __m64 v30; // [esp+30h] [ebp-14h]
  __m64 v31; // [esp+38h] [ebp-Ch]

  _m_femms();
  v3 = a3[2];
  v4 = a3[7];
  v5 = a3[5];
  v18 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v22 = _m_punpckhdq((__m64)a3->m64_u64, v3);
  v6 = a3[3];
  v7 = a3[4];
  v8 = a3[1];
  v28 = _m_punpckldq(v5, v4);
  v31 = _m_punpckhdq(v5, v4);
  v9 = a3[6];
  v26 = _m_punpckldq(v8, v6);
  v30 = _m_punpckhdq(v8, v6);
  v24 = _m_punpckhdq(v7, v9);
  v20 = _m_punpckldq(v7, v9);
  result = a1;
  v11 = _m_pfadd(
          _m_pfacc(_m_pfmul(v18, a2[4]), _m_pfmul(v18, a2[6])),
          _m_pfacc(_m_pfmul(v20, a2[5]), _m_pfmul(v20, a2[7])));
  if ( a2 == a1 )
  {
    v19 = _m_pfadd(
            _m_pfacc(_m_pfmul(v18, (__m64)a2->m64_u64), _m_pfmul(v18, a2[2])),
            _m_pfacc(_m_pfmul(v20, a2[1]), _m_pfmul(v20, a2[3])));
    v21 = v11;
    v15 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, a2[4]), _m_pfmul(v22, a2[6])),
            _m_pfacc(_m_pfmul(v24, a2[5]), _m_pfmul(v24, a2[7])));
    v23 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v22, a2[2])),
            _m_pfacc(_m_pfmul(v24, a2[1]), _m_pfmul(v24, a2[3])));
    v25 = v15;
    v16 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, a2[4]), _m_pfmul(v26, a2[6])),
            _m_pfacc(_m_pfmul(v28, a2[5]), _m_pfmul(v28, a2[7])));
    v27 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, (__m64)a2->m64_u64), _m_pfmul(v26, a2[2])),
            _m_pfacc(_m_pfmul(v28, a2[1]), _m_pfmul(v28, a2[3])));
    v29 = v16;
    v17 = _m_pfadd(
            _m_pfacc(_m_pfmul(v30, a2[4]), _m_pfmul(v30, a2[6])),
            _m_pfacc(_m_pfmul(v31, a2[5]), _m_pfmul(v31, a2[7])));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v30, (__m64)a2->m64_u64), _m_pfmul(v30, a2[2])),
                                        _m_pfacc(_m_pfmul(v31, a2[1]), _m_pfmul(v31, a2[3])));
    a1[7].m64_u64 = (unsigned __int64)v17;
    a1->m64_u64 = (unsigned __int64)v19;
    a1[1].m64_u64 = (unsigned __int64)v21;
    a1[2].m64_u64 = (unsigned __int64)v23;
    a1[3].m64_u64 = (unsigned __int64)v25;
    a1[4].m64_u64 = (unsigned __int64)v27;
    a1[5].m64_u64 = (unsigned __int64)v29;
  }
  else
  {
    a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, (__m64)a2->m64_u64), _m_pfmul(v18, a2[2])),
                                      _m_pfacc(_m_pfmul(v20, a2[1]), _m_pfmul(v20, a2[3])));
    a1[1].m64_u64 = (unsigned __int64)v11;
    v12 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, a2[4]), _m_pfmul(v22, a2[6])),
            _m_pfacc(_m_pfmul(v24, a2[5]), _m_pfmul(v24, a2[7])));
    a1[2].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v22, a2[2])),
                                        _m_pfacc(_m_pfmul(v24, a2[1]), _m_pfmul(v24, a2[3])));
    a1[3].m64_u64 = (unsigned __int64)v12;
    v13 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, a2[4]), _m_pfmul(v26, a2[6])),
            _m_pfacc(_m_pfmul(v28, a2[5]), _m_pfmul(v28, a2[7])));
    a1[4].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v26, (__m64)a2->m64_u64), _m_pfmul(v26, a2[2])),
                                        _m_pfacc(_m_pfmul(v28, a2[1]), _m_pfmul(v28, a2[3])));
    a1[5].m64_u64 = (unsigned __int64)v13;
    v14 = _m_pfadd(
            _m_pfacc(_m_pfmul(v30, a2[4]), _m_pfmul(v30, a2[6])),
            _m_pfacc(_m_pfmul(v31, a2[5]), _m_pfmul(v31, a2[7])));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v30, (__m64)a2->m64_u64), _m_pfmul(v30, a2[2])),
                                        _m_pfacc(_m_pfmul(v31, a2[1]), _m_pfmul(v31, a2[3])));
    a1[7].m64_u64 = (unsigned __int64)v14;
  }
  _m_femms();
  return result;
}

// sub_1002CE9A @ 0x1002CE9A
int __stdcall sub_1002CE9A(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm5
  __m64 v6; // mm0
  __m64 v7; // mm4
  __m64 v8; // mm3
  __m64 v9; // mm6
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm1
  __m64 v13; // mm0
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm0
  __m64 v17; // mm1
  __m64 v18; // mm5
  __m64 v19; // mm0
  __m64 v20; // mm4
  __m64 v21; // mm3
  __m64 v22; // mm6
  __m64 v23; // mm4
  __m64 v24; // mm6
  __m64 v25; // mm1
  __m64 v26; // mm0
  __m64 v27; // mm7
  __m64 v28; // mm2
  __m64 v29; // mm2
  __m64 v30; // mm0
  __m64 v31; // mm0
  __m64 v32; // mm1
  int result; // eax
  __m64 v34; // mm0
  __m64 v35; // mm1
  __m64 v36; // mm3
  __m64 v37; // mm6
  __m64 v38; // mm4
  __m64 v39; // mm7
  __m64 v40; // mm3
  __m64 v41; // mm6
  __m64 v42; // mm4
  __m64 v43; // mm7
  __m64 v44; // [esp+0h] [ebp-44h]
  __m64 v45; // [esp+8h] [ebp-3Ch]
  __m64 v46; // [esp+10h] [ebp-34h]
  __m64 v47; // [esp+18h] [ebp-2Ch]
  __m64 v48; // [esp+20h] [ebp-24h]
  __m64 v49; // [esp+28h] [ebp-1Ch]
  __m64 v50; // [esp+38h] [ebp-Ch]

  v3 = a3[2];
  v4 = a3[4];
  v5 = _m_pfsub(
         _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_punpckhdq(v3, v4)),
         _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_punpckldq(v3, v4)));
  v6 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v7 = a3[6];
  v8 = _m_punpckhdq(v7, v7);
  v9 = _m_punpckhdq(v7, v4);
  v10 = _m_punpckldq(v7, v4);
  v11 = _m_pfsub(_m_pfmul(v9, v6), _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v3), v10));
  v12 = _m_pfsubr(_m_pfmul(_m_punpckhdq(v3, v4), _m_punpckldq(v10, v10)), _m_pfmul(_m_punpckhdq(v6, v10), v8));
  v13 = a3[7];
  v14 = a3[5];
  v45 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v11, v11), v13), _m_pfmul(_m_punpckhdq(v12, v12), a3[3])),
          _m_pfmul(_m_punpckldq(v12, v12), v14));
  v47 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v5, v5), v13), _m_pfmul(_m_punpckldq(v11, v11), v14)),
          _m_pfmul(_m_punpckhdq(v12, v12), a3[1]));
  v15 = _m_punpckldq(v5, v5);
  v49 = _m_pfsub(
          _m_pfadd(_m_pfmul(v13, v15), _m_pfmul(_m_punpckldq(v12, v12), a3[1])),
          _m_pfmul(_m_punpckldq(v11, v11), a3[3]));
  v50 = _m_pfadd(
          _m_pfsub(_m_pfmul(v15, v14), _m_pfmul(_m_punpckhdq(v5, v5), a3[3])),
          _m_pfmul(_m_punpckhdq(v11, v11), a3[1]));
  v16 = a3[1];
  v17 = a3[3];
  v18 = _m_pfsub(
          _m_pfmul(_m_punpckldq(v16, v16), _m_punpckhdq(v17, v14)),
          _m_pfmul(_m_punpckhdq(v16, v16), _m_punpckldq(v17, v14)));
  v19 = _m_punpckldq(v16, v17);
  v20 = a3[7];
  v21 = _m_punpckhdq(v20, v20);
  v22 = _m_punpckhdq(v20, v14);
  v23 = _m_punpckldq(v20, v14);
  v24 = _m_pfsub(_m_pfmul(v22, v19), _m_pfmul(_m_punpckhdq(a3[1], v17), v23));
  v25 = _m_pfsubr(_m_pfmul(_m_punpckhdq(v17, v14), _m_punpckldq(v23, v23)), _m_pfmul(_m_punpckhdq(v19, v23), v21));
  v26 = a3[6];
  v27 = a3[4];
  v44 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v24, v24), v26), _m_pfmul(_m_punpckhdq(v25, v25), a3[2])),
          _m_pfmul(_m_punpckldq(v25, v25), v27));
  v46 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v18, v18), v26), _m_pfmul(_m_punpckldq(v24, v24), v27)),
          _m_pfmul(_m_punpckhdq(v25, v25), (__m64)a3->m64_u64));
  v28 = _m_punpckldq(v18, v18);
  v48 = _m_pfsub(
          _m_pfadd(_m_pfmul(v26, v28), _m_pfmul(_m_punpckldq(v25, v25), (__m64)a3->m64_u64)),
          _m_pfmul(_m_punpckldq(v24, v24), a3[2]));
  v29 = _m_pfadd(
          _m_pfsub(_m_pfmul(v28, v27), _m_pfmul(_m_punpckhdq(v18, v18), a3[2])),
          _m_pfmul(_m_punpckhdq(v24, v24), (__m64)a3->m64_u64));
  v30 = _m_pfadd(
          _m_pfmul(_m_punpckhdq(v48, v29), _m_pfmul(_m_punpckldq(v27, v26), (__m64)0xBF8000003F800000uLL)),
          _m_pfmul(
            _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3[2].m64_u32[0]), (__m64)0xBF8000003F800000uLL),
            _m_punpckhdq(v44, v46)));
  v31 = _m_pfacc(v30, v30);
  if ( a2 )
    *a2 = _mm_cvtsi64_si32(v31);
  v32 = _m_pfrcp(v31);
  result = _mm_cvtsi64_si32(_m_pfcmpeq(0, v31));
  v34 = _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(_m_punpckldq(v31, v31), v32), v32), (__m64)0xBF8000003F800000uLL);
  v35 = _m_punpckhdq(v34, _m_punpckldq(v29, v34));
  if ( !result )
  {
    v36 = _m_pfmul(v46, v34);
    v37 = _m_pfmul(v47, v34);
    v38 = _m_pfmul(v44, v35);
    v39 = _m_pfmul(v45, v35);
    a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v38, v36);
    a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v38, v36);
    a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(v39, v37);
    a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(v39, v37);
    v40 = _m_pfmul(v29, v34);
    v41 = _m_pfmul(v50, v34);
    v42 = _m_pfmul(v48, v35);
    v43 = _m_pfmul(v49, v35);
    a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v42, v40);
    a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v42, v40);
    a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(v43, v41);
    a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(v43, v41);
    return (int)a1;
  }
  return result;
}

// sub_1002D1CE @ 0x1002D1CE
__m64 *__stdcall sub_1002D1CE(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  _m_femms();
  sub_1002CE9A(a1, a2, a3);
  _m_femms();
  return a1;
}

// sub_1002D1EA @ 0x1002D1EA
__m64 *__stdcall sub_1002D1EA(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]),
                                    _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4])));
  a1[1].m64_u64 = (unsigned __int64)v8;
  _m_femms();
  return a1;
}

// sub_1002D25B @ 0x1002D25B
__m64 *__stdcall sub_1002D25B(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfmul(v4, a3[1]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(v4, (__m64)a3->m64_u64),
                                    _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4])));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v8);
  _m_femms();
  return a1;
}

// sub_1002D2C2 @ 0x1002D2C2
__m64 *__stdcall sub_1002D2C2(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm5
  __m64 v8; // mm0

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v5 = _m_pfrsqrt(v4);
  v6 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v4, _m_pfmul(v5, v5)), v5);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v6), v8);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(_m_pand(v2, v6), v8));
  _m_femms();
  return a1;
}

// sub_1002D321 @ 0x1002D321
__m64 *__stdcall sub_1002D321(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm5
  __m64 v8; // mm7
  __m64 v10; // mm6
  __m64 v11; // mm7
  __m64 v12; // mm1

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v8 = _mm_cvtsi32_si64(a6);
  v10 = _m_punpckldq(v6, v6);
  v11 = _m_punpckldq(v8, v8);
  v12 = _m_pfadd(
          _m_pfadd(_m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a3[1].m64_u32[0]), v7), v10), v7),
          _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v7), v11));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), v10),
                                      (__m64)a2->m64_u64),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), v11));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v12);
  _m_femms();
  return a1;
}

// sub_1002D392 @ 0x1002D392
__m64 *__stdcall sub_1002D392(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2
  __m64 v17; // mm5
  __m64 v18; // mm0
  __m64 v19; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm3
  __m64 v23; // mm0

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  v17 = _m_punpckldq(v9, v9);
  v18 = _m_punpckldq(v14, v14);
  v19 = _m_pfmul(v18, (__m64)a4->m64_u64);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v16, v16);
  v23 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, _mm_cvtsi32_si64(a4[1].m64_u32[0])), _m_pfmul(v17, _mm_cvtsi32_si64(a5[1].m64_u32[0]))),
          _m_pfadd(_m_pfmul(v22, _mm_cvtsi32_si64(a2[1].m64_u32[0])), _m_pfmul(v21, _mm_cvtsi32_si64(a3[1].m64_u32[0]))));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(v19, _m_pfmul(v17, (__m64)a5->m64_u64)),
                                    _m_pfadd(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v21, (__m64)a3->m64_u64)));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v23);
  _m_femms();
  return a1;
}

// sub_1002D466 @ 0x1002D466
__m64 *__stdcall sub_1002D466(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm0
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 v17; // mm4
  __m64 v18; // mm5
  __m64 v19; // mm6
  __m64 v21; // mm7
  __m64 v22; // mm0
  __m64 v23; // mm4

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  v17 = _m_punpckhdq(v15, v15);
  v18 = _m_punpckldq(v16, v16);
  v19 = _m_punpckldq(v15, v15);
  v21 = _m_punpckhdq(v16, v16);
  v22 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, (__m64)a3->m64_u64), _m_pfmul(v17, (__m64)a2->m64_u64)),
          _m_pfmul(v19, (__m64)a4->m64_u64));
  v23 = _m_pfadd(
          _m_pfadd(
            _m_pfadd(
              _m_pfmul(v17, _mm_cvtsi32_si64(a2[1].m64_u32[0])),
              _m_pfmul(v18, _mm_cvtsi32_si64(a3[1].m64_u32[0]))),
            _m_pfmul(v19, _mm_cvtsi32_si64(a4[1].m64_u32[0]))),
          _m_pfmul(v21, _mm_cvtsi32_si64(a5[1].m64_u32[0])));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(v22, _m_pfmul(v21, (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(v23, (__m64)0x3F0000003F000000LL));
  _m_femms();
  return a1;
}

// sub_1002D550 @ 0x1002D550
__m64 *__stdcall sub_1002D550(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm1
  __m64 v9; // mm3
  __m64 v10; // mm5
  __m64 v11; // mm4
  __m64 v12; // mm5

  _m_femms();
  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_punpckldq(m64_u64, m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4]));
  v9 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  v10 = _m_punpckhdq(v9, v9);
  v11 = _m_pfrcp(v10);
  v12 = _m_pfrcpit2(_m_pfrcpit1(v10, v11), v11);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), v8), v12);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(v9, v12));
  _m_femms();
  return a1;
}

// sub_1002D5DB @ 0x1002D5DB
__m64 *__userpurge sub_1002D5DB@<eax>(__m64 a1@<mm2>, __m64 a2@<mm3>, __m64 *a3, __m64 *a4, __m64 *a5)
{
  __m64 v5; // mm1
  __m64 v6; // mm2
  __m64 v7; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v11; // mm5
  __m64 v12; // mm3
  __m64 v13; // mm2
  __m64 v14; // mm7
  __m64 v15; // mm0
  __m64 v16; // mm3
  __m64 v17; // mm1
  __m64 m64_u64; // mm4
  __m64 v19; // mm2
  __m64 v20; // mm3
  __m64 v21; // mm0
  __m64 v22; // mm1
  __m64 v23; // mm2
  __m64 v24; // mm5
  __m64 v25; // mm3
  __m64 v26; // mm2
  __m64 v27; // mm7
  __m64 v28; // mm0
  __m64 v29; // mm3
  __m64 v30; // mm1
  __m64 v31; // mm4
  __m64 v32; // mm2
  __m64 v33; // mm3
  __m64 v34; // mm0
  __m64 v35; // mm1
  __m64 v36; // mm2
  __m64 v37; // mm5
  __m64 v38; // mm3
  __m64 v39; // mm2
  __m64 v40; // mm7
  __m64 v41; // mm0
  __m64 v42; // mm3
  __m64 v43; // mm1
  __m64 v44; // mm4
  __m64 v45; // mm2
  __m64 v46; // mm3
  __m64 v47; // mm0
  __m64 v48; // mm1
  __m64 v49; // mm2
  __m64 v50; // mm3
  __m64 v51; // mm7
  __m64 v52; // mm3

  v5 = a4[1];
  v6 = _m_punpckhdq(a1, (__m64)a4->m64_u64);
  v7 = _m_punpckhdq(a2, v5);
  v8 = _m_punpckldq((__m64)a4->m64_u64, (__m64)a4->m64_u64);
  v9 = _m_punpckldq(v5, v5);
  v10 = _m_punpckhdq(v6, v6);
  v11 = _m_pfmul(a5[2], v10);
  v12 = _m_punpckhdq(v7, v7);
  v13 = _m_pfadd(_m_pfadd(_m_pfmul(v10, a5[3]), _m_pfmul(v8, a5[1])), _m_pfmul(v9, a5[5]));
  v14 = _m_pfadd(_m_pfmul(a5[6], v12), _m_pfadd(_m_pfmul(a5[4], v9), _m_pfadd(v11, _m_pfmul((__m64)a5->m64_u64, v8))));
  v15 = a4[2];
  v16 = _m_pfadd(_m_pfmul(v12, a5[7]), v13);
  v17 = a4[3];
  a3->m64_u64 = (unsigned __int64)v14;
  m64_u64 = (__m64)a5->m64_u64;
  a3[1].m64_u64 = (unsigned __int64)v16;
  v19 = _m_punpckhdq(v13, v15);
  v20 = _m_punpckhdq(v16, v17);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v17, v17);
  v23 = _m_punpckhdq(v19, v19);
  v24 = _m_pfmul(a5[2], v23);
  v25 = _m_punpckhdq(v20, v20);
  v26 = _m_pfadd(_m_pfadd(_m_pfmul(v23, a5[3]), _m_pfmul(v21, a5[1])), _m_pfmul(v22, a5[5]));
  v27 = _m_pfadd(_m_pfmul(a5[6], v25), _m_pfadd(_m_pfmul(a5[4], v22), _m_pfadd(v24, _m_pfmul(m64_u64, v21))));
  v28 = a4[4];
  v29 = _m_pfadd(_m_pfmul(v25, a5[7]), v26);
  v30 = a4[5];
  a3[2].m64_u64 = (unsigned __int64)v27;
  v31 = (__m64)a5->m64_u64;
  a3[3].m64_u64 = (unsigned __int64)v29;
  v32 = _m_punpckhdq(v26, v28);
  v33 = _m_punpckhdq(v29, v30);
  v34 = _m_punpckldq(v28, v28);
  v35 = _m_punpckldq(v30, v30);
  v36 = _m_punpckhdq(v32, v32);
  v37 = _m_pfmul(a5[2], v36);
  v38 = _m_punpckhdq(v33, v33);
  v39 = _m_pfadd(_m_pfadd(_m_pfmul(v36, a5[3]), _m_pfmul(v34, a5[1])), _m_pfmul(v35, a5[5]));
  v40 = _m_pfadd(_m_pfmul(a5[6], v38), _m_pfadd(_m_pfmul(a5[4], v35), _m_pfadd(v37, _m_pfmul(v31, v34))));
  v41 = a4[6];
  v42 = _m_pfadd(_m_pfmul(v38, a5[7]), v39);
  v43 = a4[7];
  a3[4].m64_u64 = (unsigned __int64)v40;
  v44 = (__m64)a5->m64_u64;
  a3[5].m64_u64 = (unsigned __int64)v42;
  v45 = _m_punpckhdq(v39, v41);
  v46 = _m_punpckhdq(v42, v43);
  v47 = _m_punpckldq(v41, v41);
  v48 = _m_punpckldq(v43, v43);
  v49 = _m_punpckhdq(v45, v45);
  v50 = _m_punpckhdq(v46, v46);
  v51 = _m_pfmul(a5[6], v50);
  v52 = _m_pfadd(
          _m_pfmul(v50, a5[7]),
          _m_pfadd(_m_pfadd(_m_pfmul(v49, a5[3]), _m_pfmul(v47, a5[1])), _m_pfmul(v48, a5[5])));
  a3[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                      v51,
                                      _m_pfadd(_m_pfmul(a5[4], v48), _m_pfadd(_m_pfmul(a5[2], v49), _m_pfmul(v44, v47))));
  a3[7].m64_u64 = (unsigned __int64)v52;
  _m_femms();
  return a3;
}

// sub_1002D7A7 @ 0x1002D7A7
__m64 *__userpurge sub_1002D7A7@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 *v8; // esi
  __m64 v9; // mm1
  __m64 v11; // [esp+Ch] [ebp-40h] BYREF
  float v12; // [esp+14h] [ebp-38h]
  float v13; // [esp+18h] [ebp-34h]
  float v14; // [esp+1Ch] [ebp-30h]
  float v15; // [esp+20h] [ebp-2Ch]
  float v16; // [esp+24h] [ebp-28h]
  float v17; // [esp+28h] [ebp-24h]
  float v18; // [esp+2Ch] [ebp-20h]
  float v19; // [esp+30h] [ebp-1Ch]
  float v20; // [esp+34h] [ebp-18h]
  float v21; // [esp+38h] [ebp-14h]
  float v22; // [esp+3Ch] [ebp-10h]
  float v23; // [esp+40h] [ebp-Ch]
  float v24; // [esp+44h] [ebp-8h]
  float v25; // [esp+48h] [ebp-4h]

  v8 = &v11;
  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      v24 = 0.0;
      v23 = 0.0;
      v22 = 0.0;
      v21 = 0.0;
      v19 = 0.0;
      v18 = 0.0;
      v17 = 0.0;
      v16 = 0.0;
      v14 = 0.0;
      v13 = 0.0;
      v12 = 0.0;
      v11.m64_f32[1] = 0.0;
      v25 = 1.0;
      v20 = 1.0;
      v15 = 1.0;
      v11.m64_f32[0] = 1.0;
      break;
    case 1:
      v8 = a6;
      break;
    case 2:
      v8 = a7;
      break;
    case 3:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a7, a6);
      _m_femms();
      break;
    case 4:
      v8 = a8;
      break;
    case 5:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a6);
      _m_femms();
      break;
    case 6:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a7);
      _m_femms();
      break;
    case 7:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a7);
      sub_1002D5DB(a1, a2, &v11, &v11, a6);
      _m_femms();
      break;
    default:
      break;
  }
  sub_1002D550(a3, a4, v8);
  if ( a5 )
  {
    _m_femms();
    v9 = _m_pfadd(_m_pfmul(_mm_cvtsi32_si64(a3[1].m64_u32[0]), _m_pfsub(_m_punpckhdq(a5[2], a5[2]), a5[2])), a5[2]);
    a3->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(
                                        _m_pfadd(
                                          _m_pxor((__m64)a3->m64_u64, (__m64)0x8000000000000000uLL),
                                          (__m64)0x3F8000003F800000LL),
                                        _m_pfmul(_m_pi2fd(a5[1]), (__m64)0x3F0000003F000000LL)),
                                      _m_pi2fd((__m64)a5->m64_u64));
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v9);
    _m_femms();
  }
  return a3;
}

// sub_1002D92F @ 0x1002D92F
__m64 *__userpurge sub_1002D92F@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm4
  __m64 v9; // mm2
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm6
  __m64 v14; // mm3
  __m64 v16; // [esp+Ch] [ebp-40h] BYREF
  float v17; // [esp+14h] [ebp-38h]
  float v18; // [esp+18h] [ebp-34h]
  float v19; // [esp+1Ch] [ebp-30h]
  float v20; // [esp+20h] [ebp-2Ch]
  float v21; // [esp+24h] [ebp-28h]
  float v22; // [esp+28h] [ebp-24h]
  float v23; // [esp+2Ch] [ebp-20h]
  float v24; // [esp+30h] [ebp-1Ch]
  float v25; // [esp+34h] [ebp-18h]
  float v26; // [esp+38h] [ebp-14h]
  float v27; // [esp+3Ch] [ebp-10h]
  float v28; // [esp+40h] [ebp-Ch]
  float v29; // [esp+44h] [ebp-8h]
  float v30; // [esp+48h] [ebp-4h]

  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      v29 = 0.0;
      v28 = 0.0;
      v27 = 0.0;
      v26 = 0.0;
      v24 = 0.0;
      v23 = 0.0;
      v22 = 0.0;
      v21 = 0.0;
      v19 = 0.0;
      v18 = 0.0;
      v17 = 0.0;
      v16.m64_f32[1] = 0.0;
      v30 = 1.0;
      v25 = 1.0;
      v20 = 1.0;
      v16.m64_f32[0] = 1.0;
      break;
    case 1:
      _m_femms();
      sub_1002CE9A(&v16, 0, a6);
      _m_femms();
      break;
    case 2:
      _m_femms();
      sub_1002CE9A(&v16, 0, a7);
      _m_femms();
      break;
    case 3:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a7, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 4:
      _m_femms();
      sub_1002CE9A(&v16, 0, a8);
      _m_femms();
      break;
    case 5:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 6:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a7);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 7:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a7);
      sub_1002D5DB(a1, a2, &v16, &v16, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    default:
      break;
  }
  if ( a5 )
  {
    _m_femms();
    v8 = a5[2];
    v9 = _m_pi2fd(a5[1]);
    v10 = _m_punpckldq(_m_pfrcp(v9), _m_pfrcp(_m_punpckhdq(v9, v9)));
    v11 = _m_pfmul(
            _m_pfsub((__m64)a4->m64_u64, _m_pi2fd((__m64)a5->m64_u64)),
            _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v9, v10), v10), (__m64)0x4000000040000000LL));
    v12 = _m_pfsub(_m_punpckhdq(v8, v8), v8);
    v13 = _m_pfrcp(v12);
    v14 = _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v8), _m_pfrcpit2(_m_pfrcpit1(v12, v13), v13));
    a3->m64_u64 = (unsigned __int64)_m_pxor(_m_pfsub(v11, (__m64)0x3F8000003F800000LL), (__m64)0x8000000000000000uLL);
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v14);
    _m_femms();
    sub_1002D550(a3, a3, &v16);
  }
  else
  {
    sub_1002D550(a3, a4, &v16);
  }
  return a3;
}

// sub_1002DB55 @ 0x1002DB55
__m64 *__userpurge sub_1002DB55@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm4
  __m64 v9; // mm2
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm6
  __m64 v14; // mm3
  __m64 *v16; // [esp-4h] [ebp-50h]
  __m64 v17[8]; // [esp+Ch] [ebp-40h] BYREF

  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      sub_10029B22(v17);
      break;
    case 1:
      sub_1002C7C0(v17, 0, a6);
      break;
    case 2:
      sub_1002C7C0(v17, 0, a7);
      break;
    case 3:
      sub_1002D5DB(a1, a2, v17, a7, a6);
      goto LABEL_11;
    case 4:
      sub_1002C7C0(v17, 0, a8);
      break;
    case 5:
      v16 = a6;
      goto LABEL_9;
    case 6:
      v16 = a7;
LABEL_9:
      sub_1002D5DB(a1, a2, v17, a8, v16);
      goto LABEL_11;
    case 7:
      sub_1002D5DB(a1, a2, v17, a8, a7);
      sub_1002D5DB(a1, a2, v17, v17, a6);
LABEL_11:
      sub_1002C7C0(v17, 0, v17);
      break;
    default:
      break;
  }
  if ( a5 )
  {
    _m_femms();
    v8 = a5[2];
    v9 = _m_pi2fd(a5[1]);
    v10 = _m_punpckldq(_m_pfrcp(v9), _m_pfrcp(_m_punpckhdq(v9, v9)));
    v11 = _m_pfmul(
            _m_pfsub((__m64)a4->m64_u64, _m_pi2fd((__m64)a5->m64_u64)),
            _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v9, v10), v10), (__m64)0x4000000040000000LL));
    v12 = _m_pfsub(_m_punpckhdq(v8, v8), v8);
    v13 = _m_pfrcp(v12);
    v14 = _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v8), _m_pfrcpit2(_m_pfrcpit1(v12, v13), v13));
    a3->m64_u64 = (unsigned __int64)_m_pxor(_m_pfsub(v11, (__m64)0x3F8000003F800000LL), (__m64)0x8000000000000000uLL);
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v14);
    _m_femms();
    sub_1002D550(a3, a3, v17);
  }
  else
  {
    sub_1002D550(a3, a4, v17);
  }
  return a3;
}

// sub_1002DCA8 @ 0x1002DCA8
__m64 *__stdcall sub_1002DCA8(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v6 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfmul(v5, a3[3]));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), _m_pfmul(v5, a3[2]));
  a1[1].m64_u64 = (unsigned __int64)v6;
  _m_femms();
  return a1;
}

// sub_1002DCFD @ 0x1002DCFD
__m64 *__stdcall sub_1002DCFD(__m64 *a1, __m64 *a2, __m64 *a3)
{
  _m_femms();
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(_m_punpckldq((__m64)a2->m64_u64, (__m64)a2->m64_u64), (__m64)a3->m64_u64),
                                    _m_pfmul(_m_punpckhdq((__m64)a2->m64_u64, (__m64)a2->m64_u64), a3[2]));
  _m_femms();
  return a1;
}

// sub_1002DD36 @ 0x1002DD36
__m64 *__stdcall sub_1002DD36(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm1
  __m64 v7; // mm3
  __m64 v8; // mm3
  __m64 v9; // mm4

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v6 = _m_pfmul(v5, a3[2]);
  v7 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfmul(v5, a3[3]));
  v8 = _m_punpckhdq(v7, v7);
  v9 = _m_pfrcp(v8);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), v6),
                                    _m_pfrcpit2(_m_pfrcpit1(v8, v9), v9));
  _m_femms();
  return a1;
}

// sub_1002DD9A @ 0x1002DD9A
__m64 *__stdcall sub_1002DD9A(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_punpckldq(v16, v16), (__m64)a2->m64_u64),
                                      _m_pfmul(_m_punpckldq(v15, v15), (__m64)a3->m64_u64)),
                                    _m_pfadd(
                                      _m_pfmul(_m_punpckldq(v14, v14), (__m64)a4->m64_u64),
                                      _m_pfmul(_m_punpckldq(v9, v9), (__m64)a5->m64_u64)));
  _m_femms();
  return a1;
}

// sub_1002DE32 @ 0x1002DE32
__m64 *__stdcall sub_1002DE32(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm7

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a6);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      (__m64)a2->m64_u64,
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), _m_punpckldq(v6, v6))),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), _m_punpckldq(v7, v7)));
  _m_femms();
  return a1;
}

// sub_1002DE7B @ 0x1002DE7B
__m64 *__stdcall sub_1002DE7B(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm0
  __m64 v4; // mm0
  __m64 v5; // mm5

  v2 = _m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64);
  v4 = _m_pfacc(v2, v2);
  v5 = _m_pfrsqrt(v4);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pand((__m64)a2->m64_u64, _m_pfcmpgt(v4, (__m64)0x80000000800000LL)),
                                    _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v5, v5), v4), v5));
  _m_femms();
  return a1;
}

// sub_1002DEBE @ 0x1002DEBE
__m64 *__stdcall sub_1002DEBE(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm4
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm1
  __m64 v16; // mm3

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(
                                      _m_pfadd(
                                        _m_pfadd(
                                          _m_pfmul(_m_punpckldq(v16, v16), (__m64)a3->m64_u64),
                                          _m_pfmul(_m_punpckhdq(v15, v15), (__m64)a2->m64_u64)),
                                        _m_pfmul(_m_punpckldq(v15, v15), (__m64)a4->m64_u64)),
                                      _m_pfmul(_m_punpckhdq(v16, v16), (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  _m_femms();
  return a1;
}

// sub_1002DF69 @ 0x1002DF69
__m64 *__stdcall sub_1002DF69(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v9; // mm4

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_punpckhdq(v5, v5);
  v9 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), _m_pfmul(v6, a3[3])), _m_pfadd(_m_pfmul(v7, a3[5]), _m_pfmul(v8, a3[7])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), _m_pfmul(v6, a3[2])),
                                    _m_pfadd(_m_pfmul(v7, a3[4]), _m_pfmul(v8, a3[6])));
  a1[1].m64_u64 = (unsigned __int64)v9;
  _m_femms();
  return a1;
}

// sub_1002DFEB @ 0x1002DFEB
__m64 *__stdcall sub_1002DFEB(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  _m_femms();
  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v6 = _m_pfrsqrt(v4);
  v7 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v4, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v8);
  _m_femms();
  return a1;
}

// sub_1002E04A @ 0x1002E04A
__m64 *__stdcall sub_1002E04A(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v5; // mm2
  __m64 v6; // mm3
  __m64 v7; // mm4
  __m64 v8; // mm5
  __m64 v9; // mm6
  __m64 v10; // mm1
  __m64 m64_u64; // mm0
  __m64 v12; // mm7
  __m64 v13; // mm2
  __m64 v14; // mm6
  __m64 v15; // mm7

  _m_femms();
  v5 = a3[1];
  v6 = a4[1];
  v7 = _m_pfsub(
         _m_pfmul(_m_punpckhdq(v6, v6), _m_punpckhdq(_m_punpckldq(v5, v5), (__m64)a3->m64_u64)),
         _m_pfmul(_m_punpckhdq(v5, v5), _m_punpckhdq(_m_punpckldq(v6, v6), (__m64)a4->m64_u64)));
  v8 = _m_pfsub(
         _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v5), _m_punpckldq(v6, (__m64)a4->m64_u64)),
         _m_pfmul(_m_punpckhdq((__m64)a4->m64_u64, v6), _m_punpckldq(v5, (__m64)a3->m64_u64)));
  v9 = _m_pfsub(
         _m_pfmul(
           _m_punpckldq((__m64)a4->m64_u64, (__m64)a4->m64_u64),
           _m_punpckhdq(_m_punpckldq(v5, v5), (__m64)a3->m64_u64)),
         _m_pfmul(
           _m_punpckldq((__m64)a3->m64_u64, (__m64)a3->m64_u64),
           _m_punpckhdq(_m_punpckldq(v6, v6), (__m64)a4->m64_u64)));
  v10 = a2[1];
  m64_u64 = (__m64)a2->m64_u64;
  a1->m64_u64 = (unsigned __int64)_m_pfsub(
                                    _m_pfmul(
                                      _m_pxor(_m_punpckldq(v7, v7), (__m64)0x8000000000000000uLL),
                                      _m_punpckhdq(
                                        (__m64)a2->m64_u64,
                                        _m_punpckldq((__m64)a2->m64_u64, (__m64)a2->m64_u64))),
                                    _m_pfacc(
                                      _m_pxor(
                                        _m_pfmul(_m_punpckldq(_m_punpckhdq(v7, v7), v8), v10),
                                        (__m64)0x8000000000000000uLL),
                                      _m_pxor(
                                        _m_pfmul(_m_punpckldq(_m_punpckhdq(v8, v8), v9), v10),
                                        (__m64)0x8000000000000000uLL)));
  v12 = _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u);
  v13 = _m_pxor(_m_punpckldq(v8, v9), v12);
  v14 = _m_pxor(_m_punpckhdq(v9, v9), v12);
  v15 = _m_psllqi(v12, 0x20u);
  a1[1].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_punpckhdq(v10, _m_punpckldq(v10, v10)), v14),
                                      _m_pfacc(
                                        _m_pxor(
                                          _m_pfmul(_m_pxor(_m_punpckhdq(v7, v8), (__m64)0x8000000000000000uLL), m64_u64),
                                          v15),
                                        _m_pxor(_m_pfmul(v13, m64_u64), v15)));
  _m_femms();
  return a1;
}

// sub_1002E17C @ 0x1002E17C
__m64 *__stdcall sub_1002E17C(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm7
  __m64 v9; // mm6
  __m64 v10; // mm7
  __m64 v11; // mm1

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a6);
  v9 = _m_punpckldq(v6, v6);
  v10 = _m_punpckldq(v7, v7);
  v11 = _m_pfadd(_m_pfadd(_m_pfmul(_m_pfsub(a3[1], a2[1]), v9), a2[1]), _m_pfmul(_m_pfsub(a4[1], a2[1]), v10));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), v9),
                                      (__m64)a2->m64_u64),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), v10));
  a1[1].m64_u64 = (unsigned __int64)v11;
  _m_femms();
  return a1;
}

// sub_1002E1ED @ 0x1002E1ED
__m64 *__stdcall sub_1002E1ED(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2
  __m64 v17; // mm5
  __m64 v18; // mm0
  __m64 v19; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm3
  __m64 v23; // mm0

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  v17 = _m_punpckldq(v9, v9);
  v18 = _m_punpckldq(v14, v14);
  v19 = _m_pfmul(v18, (__m64)a4->m64_u64);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v16, v16);
  v23 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, a4[1]), _m_pfmul(v17, a5[1])),
          _m_pfadd(_m_pfmul(v22, a2[1]), _m_pfmul(v21, a3[1])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(v19, _m_pfmul(v17, (__m64)a5->m64_u64)),
                                    _m_pfadd(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v21, (__m64)a3->m64_u64)));
  a1[1].m64_u64 = (unsigned __int64)v23;
  _m_femms();
  return a1;
}

// sub_1002E2B5 @ 0x1002E2B5
__m64 *__stdcall sub_1002E2B5(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm0
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 v17; // mm4
  __m64 v18; // mm5
  __m64 v19; // mm6
  __m64 v20; // mm7
  __m64 v22; // mm0
  __m64 v23; // mm4

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  v17 = _m_punpckhdq(v15, v15);
  v18 = _m_punpckldq(v16, v16);
  v19 = _m_punpckldq(v15, v15);
  v20 = _m_punpckhdq(v16, v16);
  v22 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, (__m64)a3->m64_u64), _m_pfmul(v17, (__m64)a2->m64_u64)),
          _m_pfmul(v19, (__m64)a4->m64_u64));
  v23 = _m_pfadd(
          _m_pfadd(_m_pfadd(_m_pfmul(v17, a2[1]), _m_pfmul(v18, a3[1])), _m_pfmul(v19, a4[1])),
          _m_pfmul(v20, a5[1]));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(v22, _m_pfmul(v20, (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(v23, (__m64)0x3F0000003F000000LL);
  _m_femms();
  return a1;
}

// sub_1002E393 @ 0x1002E393
__m64 *__stdcall sub_1002E393(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v4; // mm1
  __m64 v5; // mm2
  __m64 v6; // mm2

  _m_femms();
  v4 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v5 = _m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  v6 = _m_pfadd(_m_pfacc(v5, v5), _m_pfmul(_mm_cvtsi32_si64(a2[1].m64_u32[0]), v4));
  a1->m64_u64 = a3->m64_u64;
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v4);
  a1[1].m64_i32[1] = _mm_cvtsi64_si32(_m_pxor(v6, (__m64)0x80000000LL));
  _m_femms();
  return a1;
}

// sub_1002E3D6 @ 0x1002E3D6
__m64 *__stdcall sub_1002E3D6(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v4; // mm2
  __m64 v5; // mm1
  __m64 v6; // mm4
  __m64 v7; // mm7
  __m64 v8; // mm5
  __m64 v9; // mm0
  __m64 v10; // mm1
  __m64 v11; // mm1
  __m64 v12; // mm7
  __m64 v13; // mm6
  __m64 v14; // mm6
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm6
  unsigned __int64 v19; // mm4
  __m64 v20; // mm5
  __m64 v21; // mm0

  _m_femms();
  v4 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v5 = _m_pfsub(_m_punpckldq(v4, v4), _m_punpckldq(_mm_cvtsi32_si64(a4[1].m64_u32[0]), (__m64)a3[1].m64_u32[0]));
  v6 = _m_pfsub((__m64)a2->m64_u64, (__m64)a4->m64_u64);
  v7 = _m_pfsub(0, v6);
  v8 = _m_pfsub((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  v9 = _m_pxor(
         _m_pfacc(
           _m_pfmul(_m_punpckhdq(v8, v7), v5),
           _m_pfmul(_m_punpckldq(_m_punpckhdq(v5, (__m64)0x8000000000000000uLL), v8), _m_punpckldq(v7, v5))),
         (__m64)0x8000000000000000uLL);
  v10 = _m_pfmul(_m_punpckhdq(v6, _m_punpckldq(v6, v7)), v8);
  v11 = _m_pfacc(v10, v10);
  v12 = _m_psllqi(v11, 0x20u);
  v13 = _m_pfadd(_m_pfmul(v9, v9), _m_pfmul(v12, v12));
  v14 = _m_pfacc(v13, v13);
  v15 = _m_pfrsqrt(v14);
  v16 = _m_pfcmpgt(v14, (__m64)0x80000000800000LL);
  v17 = _m_pfrcpit2(_m_pfrsqit1(v14, _m_pfmul(v15, v15)), v15);
  v19 = (unsigned __int64)_m_pfmul(_m_pand(v9, v16), v17);
  v20 = _m_pfmul(_m_pand(v11, v16), v17);
  v21 = _m_pfmul((__m64)v19, (__m64)a2->m64_u64);
  a1->m64_u64 = v19;
  a1[1].m64_u64 = (unsigned __int64)_m_pxor(
                                      _m_punpckldq(v20, _m_pfadd(_m_pfacc(v21, v21), _m_pfmul(v20, v4))),
                                      (__m64)0x8000000000000000uLL);
  _m_femms();
  return a1;
}

// sub_1002E4BA @ 0x1002E4BA
__m64 *__stdcall sub_1002E4BA(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v4; // mm7
  __m64 v5; // mm4
  __m64 v6; // mm7
  __m64 v7; // mm4
  __m64 v8; // mm5
  __m64 *result; // eax
  __m64 v10; // mm2
  __m64 v11; // mm2
  __m64 v12; // mm2
  __m64 v13; // mm5

  v4 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v5 = _m_pfsub(
         _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64), _m_pfmul(a2[1], v4)),
         _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a4->m64_u64), _m_pfmul(a2[1], _mm_cvtsi32_si64(a4[1].m64_u32[0]))));
  v6 = _m_punpckldq(v4, (__m64)1065353216LL);
  v7 = _m_pfacc(v5, v5);
  v8 = _m_pfrcp(v7);
  result = a1;
  v10 = _m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  if ( _mm_cvtsi64_si32(_m_pfcmpeq(0, v7)) )
  {
    result = 0;
  }
  else
  {
    v11 = _m_pfadd(v10, _m_pfmul(a2[1], v6));
    v12 = _m_pfmul(_m_pfacc(v11, v11), _m_pfrcpit2(_m_pfrcpit1(v7, v8), v8));
    v13 = _m_pfadd(_m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v6), v12), v6);
    a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a3->m64_u64), v12),
                                      (__m64)a3->m64_u64);
    a1[1].m64_i32[0] = _mm_cvtsi64_si32(v13);
  }
  _m_femms();
  return result;
}

// sub_1002E578 @ 0x1002E578
__m64 *__stdcall sub_1002E578(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm2
  __m64 v4; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v9; // mm0

  v2 = a2[1];
  v3 = _m_pand(v2, (__m64)0xFFFFFFFFLL);
  v4 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v3, v3));
  v5 = _m_pfacc(v4, v4);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfcmpgt(v5, (__m64)0x80000000800000LL);
  v9 = _m_pfrcpit2(_m_pfrsqit1(v5, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v9);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v9);
  _m_femms();
  return a1;
}

// sub_1002E5DC @ 0x1002E5DC
__m64 *__stdcall sub_1002E5DC(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v10; // mm4

  _m_femms();
  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_punpckldq(m64_u64, m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_punpckhdq(v5, v5);
  v10 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), _m_pfmul(v6, a3[3])), _m_pfadd(_m_pfmul(v7, a3[5]), _m_pfmul(v8, a3[7])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), _m_pfmul(v6, a3[2])),
                                    _m_pfadd(_m_pfmul(v7, a3[4]), _m_pfmul(v8, a3[6])));
  a1[1].m64_u64 = (unsigned __int64)v10;
  _m_femms();
  return a1;
}

// FUN_1002e65a @ 0x1002E65A
// [binja] int32_t sub_1002e65a(uint32_t arg1)
int FUN_1002e65a(uint arg1)
{
  size_t Size; // [esp+8h] [ebp+8h]

  return (int)malloc(Size);
}

// zcfree @ 0x1002E665
// zlib (internal): default free wrapper
void zcfree(void *opaque, void *ptr)
{
  free(ptr);
}

// FUN_1002e670 @ 0x1002E670
// [binja] int32_t sub_1002e670(int32_t arg1) __pure
int FUN_1002e670(int arg1)
{
  int v2; // [esp+Ch] [ebp+Ch]

  return v2;
}

// sub_1002E675 @ 0x1002E675
int __cdecl sub_1002E675(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_1002E689 @ 0x1002E689
int sub_1002E689()
{
  return 0;
}

// sub_1002E68C @ 0x1002E68C
int __usercall sub_1002E68C@<eax>(int a1@<esi>)
{
  int v1; // ebx
  int v2; // edi
  int v3; // eax
  int result; // eax
  _DWORD *v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  _DWORD *i; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 384);
  v2 = *(_DWORD *)(a1 + 276);
  v3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD *)(a1 + 32));
  v12 = 0;
  *(_DWORD *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 60) = v3 + 4 * *(_DWORD *)(a1 + 32);
  result = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 32) > 0 )
  {
    v5 = (_DWORD *)(result + 12);
    v10 = v2 + 4;
    for ( i = (_DWORD *)(result + 12); ; v5 = i )
    {
      v6 = *v5 * v5[6] / *(_DWORD *)(a1 + 276) * v10;
      v9 = *v5 * v5[6] / *(_DWORD *)(a1 + 276);
      i += 21;
      v7 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * v6) + 4 * v9;
      v8 = 4 * v12;
      *(_DWORD *)(v8 + *(_DWORD *)(v1 + 56)) = v7;
      ++v12;
      *(_DWORD *)(v8 + *(_DWORD *)(v1 + 60)) = v7 + 4 * v6;
      result = v12;
      if ( v12 >= *(_DWORD *)(a1 + 32) )
        break;
    }
  }
  return result;
}

// sub_1002E734 @ 0x1002E734
int __usercall sub_1002E734@<eax>(_DWORD *a1@<edi>)
{
  _DWORD *v1; // ebx
  int result; // eax
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // esi
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int *v10; // ecx
  int v11; // edx
  _DWORD *v12; // esi
  bool v13; // zf
  _DWORD *v14; // ecx
  int *v15; // [esp+4h] [ebp-2Ch]
  _DWORD *v16; // [esp+8h] [ebp-28h]
  _DWORD *v17; // [esp+Ch] [ebp-24h]
  int v18; // [esp+10h] [ebp-20h]
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  _DWORD *v21; // [esp+18h] [ebp-18h]
  int *v22; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h]
  int v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+24h] [ebp-Ch]
  _DWORD *v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+2Ch] [ebp-4h]

  v25 = 0;
  v1 = (_DWORD *)a1[96];
  v20 = a1[69];
  result = a1[49];
  v16 = v1;
  if ( (int)a1[8] > 0 )
  {
    v3 = (_DWORD *)(result + 12);
    v21 = (_DWORD *)(result + 12);
    v22 = v1 + 2;
    while ( 1 )
    {
      v4 = *v3 * v3[6] / a1[69];
      v17 = *(_DWORD **)(4 * v25 + v1[14]);
      v5 = *(_DWORD *)(4 * v25 + v1[15]);
      v6 = *v22;
      v7 = v4 * (v20 + 2);
      v18 = v4;
      if ( v7 > 0 )
      {
        v8 = *(_DWORD **)(4 * v25 + v1[15]);
        v23 = v7;
        do
        {
          v9 = *(_DWORD *)((char *)v8 + v6 - v5);
          *v8 = v9;
          *(_DWORD *)((char *)v8++ + (_DWORD)v17 - v5) = v9;
          --v23;
        }
        while ( v23 );
        v1 = v16;
        v4 = v18;
      }
      if ( 2 * v4 > 0 )
      {
        v26 = (_DWORD *)(v5 + 4 * v20 * v4);
        v4 = v18;
        v15 = (int *)(v6 + 4 * v18 * (v20 - 2));
        v27 = v6 - v5;
        v24 = v5 - v6;
        v19 = 2 * v18;
        v10 = v15;
        do
        {
          *(int *)((char *)v10 + v24) = *(_DWORD *)((char *)v26 + v27);
          v11 = *v10;
          v12 = v26++;
          ++v10;
          v13 = v19-- == 1;
          *v12 = v11;
        }
        while ( !v13 );
      }
      if ( v4 > 0 )
      {
        v14 = &v17[-v4];
        do
        {
          *v14++ = *v17;
          --v4;
        }
        while ( v4 );
      }
      result = ++v25;
      ++v22;
      v21 += 21;
      if ( v25 >= a1[8] )
        break;
      v3 = v21;
    }
  }
  return result;
}

// sub_1002E865 @ 0x1002E865
int __usercall sub_1002E865@<eax>(_DWORD *a1@<edi>)
{
  int v1; // ecx
  int result; // eax
  int v3; // esi
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ebx
  int *v7; // ecx
  int *v8; // eax
  int v9; // esi
  int v10; // edx
  int v11; // [esp+4h] [ebp-1Ch]
  int v12; // [esp+8h] [ebp-18h]
  int v13; // [esp+Ch] [ebp-14h]
  _DWORD *v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+18h] [ebp-8h]
  int *v17; // [esp+1Ch] [ebp-4h]

  v1 = a1[96];
  v16 = 0;
  result = a1[49];
  v3 = a1[69];
  v11 = v1;
  v12 = v3;
  if ( (int)a1[8] > 0 )
  {
    v4 = (_DWORD *)(result + 12);
    v14 = (_DWORD *)(result + 12);
    do
    {
      v15 = *v4 * v4[6] / a1[69];
      v13 = *(_DWORD *)(4 * v16 + *(_DWORD *)(v1 + 56));
      v5 = *(int **)(4 * v16 + *(_DWORD *)(v1 + 60));
      if ( v15 > 0 )
      {
        v6 = &v5[v15 * (v3 + 2)];
        v7 = &v5[-v15];
        v8 = &v5[v15 * (v3 + 1)];
        v17 = v5;
        v9 = v13 - (_DWORD)v5;
        do
        {
          *(int *)((char *)v7 + v9) = *(int *)((char *)v8 + v9);
          *v7 = *v8;
          *(int *)((char *)v6 + v9) = *(int *)((char *)v17 + v9);
          v10 = *v17++;
          *v6 = v10;
          ++v8;
          ++v7;
          ++v6;
          --v15;
        }
        while ( v15 );
        v3 = v12;
        v1 = v11;
        v4 = v14;
      }
      result = ++v16;
      v4 += 21;
      v14 = v4;
    }
    while ( v16 < a1[8] );
  }
  return result;
}

// sub_1002E939 @ 0x1002E939
int __usercall sub_1002E939@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax
  int v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  _DWORD *v5; // edx
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+4h] [ebp-Ch]
  unsigned int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v9 = 0;
  result = a1[49];
  v2 = a1[96];
  if ( (int)a1[8] > 0 )
  {
    v3 = (_DWORD *)(result + 12);
    do
    {
      v6 = *v3 * v3[6] / a1[69];
      v8 = v3[8] % (unsigned int)(*v3 * v3[6]);
      if ( !v8 )
        v8 = *v3 * v3[6];
      if ( !v9 )
        *(_DWORD *)(v2 + 72) = (int)(v8 - 1) / v6 + 1;
      if ( 2 * v6 > 0 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)(v2 + 4 * *(_DWORD *)(v2 + 64) + 56) + 4 * v9) + 4 * v8;
        v5 = (_DWORD *)v4;
        v7 = 2 * v6;
        do
        {
          *v5++ = *(_DWORD *)(v4 - 4);
          --v7;
        }
        while ( v7 );
      }
      result = ++v9;
      v3 += 21;
    }
    while ( v9 < a1[8] );
  }
  return result;
}

// sub_1002E9CF @ 0x1002E9CF
int __cdecl sub_1002E9CF(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // esi
  int result; // eax
  unsigned int v7; // [esp+10h] [ebp+8h]

  v5 = a1[96];
  if ( !*(_BYTE *)(v5 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[97] + 12))(a1, v5 + 8);
    if ( !result )
      return result;
    *(_BYTE *)(v5 + 48) = 1;
  }
  v7 = a1[69];
  (*(void (__cdecl **)(_DWORD *, int, int, _DWORD, int, int, int))(a1[98] + 4))(a1, v5 + 8, v5 + 52, a1[69], a2, a3, a4);
  result = v7;
  if ( *(_DWORD *)(v5 + 52) >= v7 )
  {
    *(_BYTE *)(v5 + 48) = 0;
    *(_DWORD *)(v5 + 52) = 0;
  }
  return result;
}

// sub_1002EA37 @ 0x1002EA37
unsigned int __cdecl sub_1002EA37(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4)
{
  int v4; // ebx
  unsigned int result; // eax
  int v6; // eax
  int v7; // eax

  v4 = a1[96];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[97] + 12))(a1, *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56));
    if ( !result )
      return result;
    ++*(_DWORD *)(v4 + 76);
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = *(_DWORD *)(v4 + 68);
  if ( !v6 )
  {
LABEL_9:
    *(_DWORD *)(v4 + 52) = 0;
    *(_DWORD *)(v4 + 72) = a1[69] - 1;
    if ( *(_DWORD *)(v4 + 76) == a1[70] )
      sub_1002E939(a1);
    *(_DWORD *)(v4 + 68) = 1;
    goto LABEL_12;
  }
  v7 = v6 - 1;
  if ( v7 )
  {
    result = v7 - 1;
    if ( result )
      return result;
    (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
      a1,
      *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
      v4 + 52,
      *(_DWORD *)(v4 + 72),
      a2,
      a3,
      a4);
    result = *(_DWORD *)(v4 + 52);
    if ( result < *(_DWORD *)(v4 + 72) )
      return result;
    result = a4;
    *(_DWORD *)(v4 + 68) = 0;
    if ( *a3 >= a4 )
      return result;
    goto LABEL_9;
  }
LABEL_12:
  (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
    a1,
    *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
    v4 + 52,
    *(_DWORD *)(v4 + 72),
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 52);
  if ( result >= *(_DWORD *)(v4 + 72) )
  {
    if ( *(_DWORD *)(v4 + 76) == 1 )
      sub_1002E865(a1);
    *(_DWORD *)(v4 + 64) ^= 1u;
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = a1[69] + 1;
    *(_DWORD *)(v4 + 72) = a1[69] + 2;
    *(_DWORD *)(v4 + 68) = 2;
    return 2;
  }
  return result;
}

// sub_1002EB3F @ 0x1002EB3F
int __cdecl sub_1002EB3F(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD *)(a1 + 392) + 4))(
           a1,
           0,
           0,
           0,
           a2,
           a3,
           a4);
}

// sub_1002EB62 @ 0x1002EB62
int __cdecl sub_1002EB62(_DWORD *a1, int a2)
{
  int v2; // esi
  int result; // eax

  v2 = a1[96];
  if ( a2 )
  {
    result = a2 - 2;
    if ( a2 == 2 )
    {
      *(_DWORD *)(v2 + 4) = sub_1002EB3F;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 4;
      return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  else
  {
    result = a1[103];
    if ( *(_BYTE *)(result + 8) )
    {
      *(_DWORD *)(v2 + 4) = sub_1002EA37;
      result = sub_1002E734(a1);
      *(_DWORD *)(v2 + 64) = 0;
      *(_DWORD *)(v2 + 68) = 0;
      *(_DWORD *)(v2 + 76) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 4) = sub_1002E9CF;
    }
    *(_BYTE *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 52) = 0;
  }
  return result;
}

// sub_1002EBCA @ 0x1002EBCA
int __cdecl sub_1002EBCA(int a1, char a2)
{
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // ecx
  _DWORD *v6; // edi
  _DWORD *v7; // ebx
  int v8; // [esp+14h] [ebp+8h]
  int v9; // [esp+18h] [ebp+Ch]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 384) = v3;
  *v3 = sub_1002EB62;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 412) + 8) )
  {
    if ( *(int *)(a1 + 276) < 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    result = sub_1002E68C(a1);
    v5 = *(_DWORD *)(a1 + 276) + 2;
    v9 = v5;
  }
  else
  {
    result = *(_DWORD *)(a1 + 276);
    v9 = result;
    v5 = result;
  }
  v8 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    v7 = v3 + 2;
    while ( 1 )
    {
      ++v8;
      *v7 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
              a1,
              1,
              *v6 * *(v6 - 2),
              v5 * (*v6 * *(v6 - 6) / *(_DWORD *)(a1 + 276)));
      result = v8;
      ++v7;
      v6 += 21;
      if ( v8 >= *(_DWORD *)(a1 + 32) )
        break;
      v5 = v9;
    }
  }
  return result;
}

// FUN_1002ec9d @ 0x1002EC9D
// [binja] void* __fastcall sub_1002ec9d(void* arg1)
void *FUN_1002ec9d(void *arg1)
{
  _DWORD *v1; // ecx
  void *result; // eax
  bool v3; // cf
  int v4; // ecx
  int v5; // ecx

  result = (void *)v1[97];
  if ( (int)v1[72] <= 1 )
  {
    v3 = v1[32] < (unsigned int)(v1[70] - 1);
    v4 = v1[73];
    if ( v3 )
      v5 = *(_DWORD *)(v4 + 12);
    else
      v5 = *(_DWORD *)(v4 + 72);
    *((_DWORD *)result + 7) = v5;
  }
  else
  {
    *((_DWORD *)result + 7) = 1;
  }
  *((_DWORD *)result + 5) = 0;
  *((_DWORD *)result + 6) = 0;
  return result;
}

// sub_1002ECDC @ 0x1002ECDC
_DWORD *__cdecl sub_1002ECDC(_DWORD *a1)
{
  a1[32] = 0;
  return FUN_1002ec9d(a1);
}

// sub_1002ECEC @ 0x1002ECEC
int __cdecl sub_1002ECEC(_DWORD *a1, int a2)
{
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // ebx
  void (__cdecl *v12)(_DWORD *, _DWORD *, _DWORD, int, int); // [esp+Ch] [ebp-38h]
  unsigned int v13; // [esp+10h] [ebp-34h]
  unsigned int v14; // [esp+14h] [ebp-30h]
  int v15; // [esp+18h] [ebp-2Ch]
  int v16; // [esp+1Ch] [ebp-28h]
  _DWORD *v17; // [esp+20h] [ebp-24h]
  int v18; // [esp+24h] [ebp-20h]
  int i; // [esp+28h] [ebp-1Ch]
  int v20; // [esp+2Ch] [ebp-18h]
  _DWORD *v21; // [esp+30h] [ebp-14h]
  int v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h]
  int v25; // [esp+40h] [ebp-4h]
  unsigned int v26; // [esp+4Ch] [ebp+8h]

  v3 = a1[97];
  v4 = a1[77] - 1;
  v13 = a1[70] - 1;
  v5 = *(_DWORD *)(v3 + 24);
  v18 = v3;
  v14 = v4;
  while ( 1 )
  {
    v25 = v5;
    if ( v5 >= *(_DWORD *)(v3 + 28) )
    {
      ++a1[34];
      if ( ++a1[32] >= a1[70] )
      {
        (*(void (__cdecl **)(_DWORD *))(a1[99] + 12))(a1);
        return 4;
      }
      else
      {
        FUN_1002ec9d(a1);
        return 3;
      }
    }
    v26 = *(_DWORD *)(v3 + 20);
    if ( v26 <= v4 )
      break;
LABEL_24:
    *(_DWORD *)(v3 + 20) = 0;
    ++v5;
  }
  while ( 1 )
  {
    memzero(*(void **)(v3 + 32), a1[79] << 7);
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, int))(a1[101] + 4))(a1, v3 + 32) )
      break;
    v6 = 0;
    v20 = 0;
    v23 = 0;
    if ( (int)a1[72] > 0 )
    {
      v17 = a1 + 73;
      do
      {
        v7 = (_DWORD *)*v17;
        if ( *(_BYTE *)(*v17 + 48) )
        {
          v12 = *(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, int))(a1[102] + 4 * v7[1] + 4);
          if ( v26 >= v14 )
            v8 = v7[17];
          else
            v8 = v7[13];
          v9 = v26 * v7[16];
          v24 = 0;
          v16 = v8;
          for ( i = *(_DWORD *)(a2 + 4 * v23) + 4 * v25 * v7[9]; v24 < v7[14]; v20 = v6 )
          {
            if ( a1[32] < v13 || v25 + v24 < v7[18] )
            {
              v22 = v9;
              if ( v16 > 0 )
              {
                v21 = (_DWORD *)(v18 + 4 * v6 + 32);
                v15 = v16;
                do
                {
                  v12(a1, v7, *v21, i, v22);
                  v22 += v7[9];
                  ++v21;
                  --v15;
                }
                while ( v15 );
                v6 = v20;
              }
            }
            v6 += v7[13];
            ++v24;
            i += 4 * v7[9];
          }
          v3 = v18;
        }
        else
        {
          v6 += v7[15];
          v20 = v6;
        }
        ++v23;
        ++v17;
      }
      while ( v23 < a1[72] );
      v4 = v14;
    }
    if ( ++v26 > v4 )
    {
      v5 = v25;
      goto LABEL_24;
    }
  }
  *(_DWORD *)(v3 + 24) = v25;
  *(_DWORD *)(v3 + 20) = v26;
  return 0;
}

// sub_1002EEC6 @ 0x1002EEC6
int sub_1002EEC6()
{
  return 0;
}

// sub_1002EEC9 @ 0x1002EEC9
int __cdecl sub_1002EEC9(_DWORD *a1)
{
  _DWORD *v2; // edi
  int v3; // eax
  _DWORD *i; // eax
  unsigned int v5; // ebx
  bool v6; // cf
  bool v7; // cc
  int v8; // ecx
  int v9; // ebx
  int v10; // edx
  int *j; // ebx
  _DWORD v14[4]; // [esp+Ch] [ebp-34h]
  int *v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+20h] [ebp-20h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  _DWORD *v18; // [esp+28h] [ebp-18h]
  int v19; // [esp+2Ch] [ebp-14h]
  _DWORD *v20; // [esp+30h] [ebp-10h]
  int v21; // [esp+34h] [ebp-Ch]
  int v22; // [esp+38h] [ebp-8h]
  _DWORD *v23; // [esp+3Ch] [ebp-4h]
  int v24; // [esp+48h] [ebp+8h]
  int v25; // [esp+48h] [ebp+8h]

  v24 = 0;
  v2 = (_DWORD *)a1[97];
  if ( (int)a1[72] > 0 )
  {
    v23 = a1 + 73;
    do
    {
      v3 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(a1[1] + 32))(
             a1,
             v2[*(_DWORD *)(*v23 + 4) + 18],
             *(_DWORD *)(*v23 + 12) * a1[32],
             *(_DWORD *)(*v23 + 12),
             1);
      ++v23;
      v14[v24++] = v3;
    }
    while ( v24 < a1[72] );
  }
  for ( i = (_DWORD *)v2[6]; ; i = (_DWORD *)((char *)i + 1) )
  {
    v7 = (int)i < v2[7];
    v23 = i;
    if ( !v7 )
    {
      if ( ++a1[32] >= a1[70] )
      {
        (*(void (__cdecl **)(_DWORD *))(a1[99] + 12))(a1);
        return 4;
      }
      else
      {
        FUN_1002ec9d(a1);
        return 3;
      }
    }
    v5 = v2[5];
    v6 = v5 < a1[77];
    v17 = v5;
    if ( v6 )
      break;
LABEL_20:
    v2[5] = 0;
  }
  while ( 1 )
  {
    v7 = a1[72] <= 0;
    v22 = 0;
    v25 = 0;
    if ( !v7 )
    {
      v18 = a1 + 73;
      do
      {
        v8 = *v18;
        v9 = *(_DWORD *)(*v18 + 52);
        v19 = 0;
        if ( *(int *)(v8 + 56) > 0 )
        {
          v16 = (v17 * v9) << 7;
          v20 = (_DWORD *)(v14[v25] + 4 * (_DWORD)v23);
          do
          {
            v10 = v16 + *v20;
            v21 = 0;
            if ( v9 > 0 )
            {
              for ( j = &v2[v22 + 8]; ; j = v15 )
              {
                ++v22;
                *j = v10;
                v10 += 128;
                ++v21;
                v15 = j + 1;
                v9 = *(_DWORD *)(v8 + 52);
                if ( v21 >= v9 )
                  break;
              }
            }
            ++v19;
            ++v20;
          }
          while ( v19 < *(_DWORD *)(v8 + 56) );
        }
        ++v25;
        ++v18;
      }
      while ( v25 < a1[72] );
      v5 = v17;
    }
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(a1[101] + 4))(a1, v2 + 8) )
      break;
    v6 = ++v5 < a1[77];
    v17 = v5;
    if ( !v6 )
    {
      i = v23;
      goto LABEL_20;
    }
  }
  v2[6] = v23;
  v2[5] = v5;
  return 0;
}

// sub_1002F068 @ 0x1002F068
int __cdecl sub_1002F068(int a1, int a2)
{
  unsigned int v3; // ebx
  int v4; // eax
  int v5; // ecx
  int result; // eax
  int v7; // edi
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // ebx
  unsigned int v11; // [esp+8h] [ebp-24h]
  void (__cdecl *v12)(int, int, int, int, int); // [esp+Ch] [ebp-20h]
  int v13; // [esp+10h] [ebp-1Ch]
  int v14; // [esp+14h] [ebp-18h]
  _DWORD *v15; // [esp+18h] [ebp-14h]
  int v16; // [esp+1Ch] [ebp-10h]
  unsigned int v17; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  int v19; // [esp+28h] [ebp-4h]
  int v20; // [esp+34h] [ebp+8h]
  int v21; // [esp+34h] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 280) - 1;
  v20 = *(_DWORD *)(a1 + 388);
  v11 = v3;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 124);
    v5 = *(_DWORD *)(a1 + 132);
    if ( v4 >= v5 && (v4 != v5 || *(_DWORD *)(a1 + 128) > *(_DWORD *)(a1 + 136)) )
      break;
    result = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
    if ( !result )
      return result;
  }
  v19 = 0;
  v7 = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 32) > 0 )
  {
    v15 = (_DWORD *)(v20 + 72);
    do
    {
      if ( *(_BYTE *)(v7 + 48) )
      {
        v13 = (*(int (__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 4) + 32))(
                a1,
                *v15,
                *(_DWORD *)(v7 + 12) * *(_DWORD *)(a1 + 136),
                *(_DWORD *)(v7 + 12),
                0);
        if ( *(_DWORD *)(a1 + 136) >= v3 )
        {
          v21 = *(_DWORD *)(v7 + 32) % *(_DWORD *)(v7 + 12);
          if ( !v21 )
            v21 = *(_DWORD *)(v7 + 12);
        }
        else
        {
          v21 = *(_DWORD *)(v7 + 12);
        }
        v12 = *(void (__cdecl **)(int, int, int, int, int))(*(_DWORD *)(a1 + 408) + 4 * v19 + 4);
        v8 = 0;
        v16 = *(_DWORD *)(4 * v19 + a2);
        v14 = 0;
        if ( v21 > 0 )
        {
          v9 = *(_DWORD *)(v7 + 28);
          do
          {
            v10 = 0;
            v17 = 0;
            for ( i = *(_DWORD *)(v13 + 4 * v8); v17 < v9; ++v17 )
            {
              v12(a1, v7, i, v16, v10);
              i += 128;
              v10 += *(_DWORD *)(v7 + 36);
              v9 = *(_DWORD *)(v7 + 28);
            }
            v16 += 4 * *(_DWORD *)(v7 + 36);
            v8 = ++v14;
          }
          while ( v14 < v21 );
          v3 = v11;
        }
      }
      ++v19;
      ++v15;
      v7 += 84;
    }
    while ( v19 < *(_DWORD *)(a1 + 32) );
  }
  return 4 - (++*(_DWORD *)(a1 + 136) < *(_DWORD *)(a1 + 280));
}

// sub_1002F1CE @ 0x1002F1CE
char __usercall sub_1002F1CE@<al>(int a1@<esi>)
{
  int v1; // edi
  _WORD **v2; // eax
  _WORD *v3; // eax
  int *v4; // eax
  _DWORD *v5; // ecx
  int v6; // edx
  int v7; // eax
  _WORD **i; // [esp+8h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  int v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+1Bh] [ebp-1h]

  v1 = *(_DWORD *)(a1 + 388);
  v13 = 0;
  if ( *(_BYTE *)(a1 + 200) && *(_DWORD *)(a1 + 140) )
  {
    if ( !*(_DWORD *)(v1 + 112) )
      *(_DWORD *)(v1 + 112) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD *)(a1 + 32));
    v12 = *(_DWORD *)(v1 + 112);
    v10 = 0;
    if ( *(int *)(a1 + 32) <= 0 )
      return v13;
    v2 = (_WORD **)(*(_DWORD *)(a1 + 196) + 76);
    v11 = 0;
    for ( i = v2; ; i += 21 )
    {
      v3 = *v2;
      if ( !v3 )
        break;
      if ( !*v3 )
        break;
      if ( !v3[1] )
        break;
      if ( !v3[8] )
        break;
      if ( !v3[16] )
        break;
      if ( !v3[9] )
        break;
      if ( !v3[2] )
        break;
      v4 = (int *)(v11 + *(_DWORD *)(a1 + 140));
      if ( *v4 < 0 )
        break;
      v5 = v4 + 1;
      v6 = v12 - (_DWORD)v4;
      v7 = 5;
      do
      {
        *(_DWORD *)((char *)v5 + v6) = *v5;
        if ( *v5 )
          v13 = 1;
        ++v5;
        --v7;
      }
      while ( v7 );
      v12 += 24;
      ++v10;
      v11 += 256;
      v2 = i + 21;
      if ( v10 >= *(_DWORD *)(a1 + 32) )
        return v13;
    }
  }
  return 0;
}

// sub_1002F2B1 @ 0x1002F2B1
int __cdecl sub_1002F2B1(_DWORD *a1, int a2)
{
  int v3; // eax
  bool v4; // cc
  int v5; // esi
  unsigned int v6; // ebx
  unsigned int v7; // ecx
  int v8; // eax
  int v10; // eax
  _DWORD *v11; // eax
  unsigned __int16 *v12; // eax
  int v13; // ecx
  int v14; // eax
  __int16 **v15; // edx
  __int16 *v16; // ecx
  __int16 *v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // ebx
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // edx
  int v33; // ecx
  int v34; // eax
  int v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  int v44; // eax
  int v45; // ecx
  int v46; // edx
  int v47; // ecx
  int v48; // eax
  int v49; // eax
  int v50; // ecx
  int v51; // eax
  int v52; // ecx
  int v53; // eax
  _BYTE v54[2]; // [esp+8h] [ebp-98h] BYREF
  __int16 v55; // [esp+Ah] [ebp-96h]
  __int16 v56; // [esp+Ch] [ebp-94h]
  __int16 v57; // [esp+18h] [ebp-88h]
  __int16 v58; // [esp+1Ah] [ebp-86h]
  __int16 v59; // [esp+28h] [ebp-78h]
  void (__cdecl *v60)(_DWORD *, int, _BYTE *, int, int); // [esp+88h] [ebp-18h]
  unsigned int v61; // [esp+8Ch] [ebp-14h]
  int v62; // [esp+90h] [ebp-10h]
  int v63; // [esp+94h] [ebp-Ch]
  int v64; // [esp+98h] [ebp-8h]
  unsigned int v65; // [esp+9Ch] [ebp-4h]
  int v66; // [esp+A0h] [ebp+0h]
  int v67; // [esp+A4h] [ebp+4h]
  int v68; // [esp+A8h] [ebp+8h]
  int i; // [esp+ACh] [ebp+Ch]
  __int16 *v70; // [esp+B0h] [ebp+10h]
  int v71; // [esp+B4h] [ebp+14h]
  __int16 *v72; // [esp+B8h] [ebp+18h]
  int v73; // [esp+BCh] [ebp+1Ch]
  int v74; // [esp+C0h] [ebp+20h]
  int v75; // [esp+C4h] [ebp+24h]
  unsigned int v76; // [esp+C8h] [ebp+28h]
  int v77; // [esp+CCh] [ebp+2Ch]
  int v78; // [esp+D0h] [ebp+30h]
  int v79; // [esp+D4h] [ebp+34h]
  int v80; // [esp+D8h] [ebp+38h]
  int v81; // [esp+DCh] [ebp+3Ch]
  int v82; // [esp+E0h] [ebp+40h]
  int v83; // [esp+E4h] [ebp+44h]
  int v84; // [esp+E8h] [ebp+48h]
  int v85; // [esp+ECh] [ebp+4Ch]
  _DWORD *v86; // [esp+F0h] [ebp+50h]
  int v87; // [esp+F4h] [ebp+54h]
  int v88; // [esp+F8h] [ebp+58h]
  int v89; // [esp+FCh] [ebp+5Ch]
  int v90; // [esp+100h] [ebp+60h]
  __int16 *v91; // [esp+104h] [ebp+64h]
  char v92; // [esp+10Bh] [ebp+6Bh]
  _DWORD *v93; // [esp+10Ch] [ebp+6Ch]
  char v94; // [esp+11Bh] [ebp+7Bh]

  v66 = a1[97];
  v61 = a1[70] - 1;
  while ( a1[31] <= a1[33] )
  {
    v3 = a1[99];
    if ( *(_BYTE *)(v3 + 17) || a1[31] == a1[33] && a1[32] > a1[34] + (unsigned int)(a1[90] == 0) )
      break;
    if ( !(*(int (__cdecl **)(_DWORD *))v3)(a1) )
      return 0;
  }
  v4 = a1[8] <= 0;
  v5 = a1[49];
  v74 = 0;
  if ( !v4 )
  {
    v67 = 0;
    v68 = -72 - v66;
    v86 = (_DWORD *)(v66 + 72);
    do
    {
      if ( *(_BYTE *)(v5 + 48) )
      {
        v6 = a1[34];
        v7 = *(_DWORD *)(v5 + 12);
        if ( v6 >= v61 )
        {
          v90 = *(_DWORD *)(v5 + 32) % v7;
          if ( !v90 )
            v90 = v7;
          v8 = v90;
          v92 = 1;
        }
        else
        {
          v90 = *(_DWORD *)(v5 + 12);
          v8 = 2 * v7;
          v92 = 0;
        }
        if ( v6 )
        {
          v94 = 0;
          v10 = (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                  a1,
                  *v86,
                  v7 * (v6 - 1),
                  v7 + v8,
                  0)
              + 4 * *(_DWORD *)(v5 + 12);
        }
        else
        {
          v10 = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v86, 0, v8, 0);
          v94 = 1;
        }
        v64 = v10;
        v11 = (_DWORD *)(v67 + *(_DWORD *)(v66 + 112));
        v88 = 0;
        v93 = v11;
        v12 = *(unsigned __int16 **)(v5 + 76);
        v87 = *v12;
        v78 = v12[1];
        v83 = v12[8];
        v75 = v12[16];
        v13 = v12[9];
        v77 = v12[2];
        v14 = v68 + a1[102];
        v81 = v13;
        v60 = *(void (__cdecl **)(_DWORD *, int, _BYTE *, int, int))((char *)v86 + v14 + 4);
        for ( i = *(_DWORD *)(a2 + 4 * v74); v88 < v90; i += 4 * v53 )
        {
          v15 = (__int16 **)(v64 + 4 * v88);
          v16 = *v15;
          v91 = *v15;
          if ( !v94 || v88 )
            v16 = *(v15 - 1);
          if ( !v92 || (v17 = v91, v88 != v90 - 1) )
            v17 = v15[1];
          v18 = *v16;
          v71 = 0;
          v76 = 0;
          v79 = v18;
          v84 = v18;
          v62 = v18;
          v89 = *v91;
          v82 = v89;
          v73 = v89;
          v80 = *v17;
          v85 = v80;
          v63 = v80;
          v65 = *(_DWORD *)(v5 + 28) - 1;
          v72 = v17 + 64;
          v70 = v16 + 64;
          do
          {
            sub_10022BF2(v91, v54, 1);
            if ( v76 < v65 )
            {
              v79 = *v70;
              v89 = v91[64];
              v80 = *v72;
            }
            if ( v93[1] && !v55 )
            {
              v19 = v78 << 8;
              v20 = v78 << 7;
              v21 = 36 * v87 * (v73 - v89);
              if ( v21 < 0 )
              {
                v24 = (v20 - v21) / v19;
                v25 = v93[1];
                if ( v25 > 0 && v24 >= 1 << v25 )
                  v24 = (1 << v25) - 1;
                v22 = -v24;
              }
              else
              {
                v22 = (v21 + v20) / v19;
                v23 = v93[1];
                if ( v23 > 0 && v22 >= 1 << v23 )
                  LOWORD(v22) = (1 << v23) - 1;
              }
              v55 = v22;
            }
            v26 = v93[2];
            if ( v26 && !v57 )
            {
              v27 = v83 << 8;
              v28 = v83 << 7;
              v29 = 36 * v87 * (v84 - v85);
              if ( v29 < 0 )
              {
                v31 = (v28 - v29) / v27;
                if ( v26 > 0 && v31 >= 1 << v26 )
                  v31 = (1 << v26) - 1;
                v30 = -v31;
              }
              else
              {
                v30 = (v29 + v28) / v27;
                if ( v26 > 0 && v30 >= 1 << v26 )
                  LOWORD(v30) = (1 << v26) - 1;
              }
              v57 = v30;
            }
            if ( v93[3] && !v59 )
            {
              v32 = 9 * v87 * (v84 + v85 - 2 * v82);
              v33 = v75 << 8;
              v34 = v75 << 7;
              if ( v32 < 0 )
              {
                v37 = (v34 - v32) / v33;
                v38 = v93[3];
                if ( v38 > 0 && v37 >= 1 << v38 )
                  v37 = (1 << v38) - 1;
                v35 = -v37;
              }
              else
              {
                v35 = (v32 + v34) / v33;
                v36 = v93[3];
                if ( v36 > 0 && v35 >= 1 << v36 )
                  LOWORD(v35) = (1 << v36) - 1;
              }
              v59 = v35;
            }
            if ( v93[4] && !v58 )
            {
              v39 = 5 * v87 * (v62 + v80 - v63 - v79);
              v40 = v81 << 8;
              v41 = v81 << 7;
              if ( v39 < 0 )
              {
                v44 = (v41 - v39) / v40;
                v45 = v93[4];
                if ( v45 > 0 && v44 >= 1 << v45 )
                  v44 = (1 << v45) - 1;
                v42 = -v44;
              }
              else
              {
                v42 = (v39 + v41) / v40;
                v43 = v93[4];
                if ( v43 > 0 && v42 >= 1 << v43 )
                  LOWORD(v42) = (1 << v43) - 1;
              }
              v58 = v42;
            }
            if ( v93[5] && !v56 )
            {
              v46 = 9 * v87 * (v73 + v89 - 2 * v82);
              v47 = v77 << 8;
              v48 = v77 << 7;
              if ( v46 < 0 )
              {
                v51 = (v48 - v46) / v47;
                v52 = v93[5];
                if ( v52 > 0 && v51 >= 1 << v52 )
                  v51 = (1 << v52) - 1;
                v49 = -v51;
              }
              else
              {
                v49 = (v46 + v48) / v47;
                v50 = v93[5];
                if ( v50 > 0 && v49 >= 1 << v50 )
                  LOWORD(v49) = (1 << v50) - 1;
              }
              v56 = v49;
            }
            v60(a1, v5, v54, i, v71);
            v91 += 64;
            v70 += 64;
            v72 += 64;
            v62 = v84;
            v84 = v79;
            v73 = v82;
            v82 = v89;
            v63 = v85;
            v85 = v80;
            v71 += *(_DWORD *)(v5 + 36);
            ++v76;
          }
          while ( v76 <= v65 );
          v53 = *(_DWORD *)(v5 + 36);
          ++v88;
        }
      }
      ++v74;
      v67 += 24;
      ++v86;
      v5 += 84;
    }
    while ( v74 < a1[8] );
  }
  return 4 - (++a1[34] < a1[70]);
}

// sub_1002F7CE @ 0x1002F7CE
void __cdecl sub_1002F7CE(int a1)
{
  int v1; // edi

  v1 = *(_DWORD *)(a1 + 388);
  if ( *(_DWORD *)(v1 + 16) )
  {
    if ( *(_BYTE *)(a1 + 73) && sub_1002F1CE(a1) )
      *(_DWORD *)(v1 + 12) = sub_1002F2B1;
    else
      *(_DWORD *)(v1 + 12) = sub_1002F068;
  }
  *(_DWORD *)(a1 + 136) = 0;
}

// sub_1002F809 @ 0x1002F809
int __cdecl sub_1002F809(int a1, char a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  int *v5; // edi
  int v6; // ecx
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int *v10; // ecx
  int result; // eax
  int *v12; // ecx
  int v13; // edx
  int v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]
  _DWORD *v16; // [esp+Ch] [ebp-4h]
  int v17; // [esp+18h] [ebp+8h]
  int *v18; // [esp+1Ch] [ebp+Ch]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 116);
  *(_DWORD *)(a1 + 388) = v3;
  v16 = v3;
  *v3 = sub_1002ECDC;
  v3[2] = sub_1002F7CE;
  v3[28] = 0;
  if ( a2 )
  {
    v4 = *(_DWORD *)(a1 + 196);
    v17 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v5 = (int *)(v4 + 12);
      v18 = v3 + 18;
      do
      {
        v6 = *v5;
        if ( *(_BYTE *)(a1 + 200) )
          v6 *= 3;
        v7 = *(_DWORD *)(a1 + 4);
        v15 = v6;
        v14 = sub_10022B93(v5[5], *v5);
        v8 = sub_10022B93(v5[4], *(v5 - 1));
        v9 = (*(int (__cdecl **)(int, int, int, int, int, int))(v7 + 20))(a1, 1, 1, v8, v14, v15);
        v10 = v18++;
        ++v17;
        *v10 = v9;
        v5 += 21;
      }
      while ( v17 < *(_DWORD *)(a1 + 32) );
      v3 = v16;
    }
    v3[1] = sub_1002EEC9;
    v3[3] = sub_1002F068;
    v3[4] = v3 + 18;
    return (int)(v3 + 18);
  }
  else
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v12 = v3 + 8;
    v13 = 10;
    do
    {
      *v12++ = result;
      result += 128;
      --v13;
    }
    while ( v13 );
    v3[1] = sub_1002EEC6;
    v3[3] = sub_1002ECEC;
    v3[4] = 0;
  }
  return result;
}

// sub_1002F901 @ 0x1002F901
int __cdecl sub_1002F901(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  _BYTE *v7; // edi
  int v8; // edx
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  char *v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  _DWORD *v18; // eax
  int v19; // edi
  int result; // eax
  unsigned __int8 *v21; // edi
  bool v22; // cf
  int v23; // edx
  _BYTE *v24; // ebx
  int v25; // eax
  _BYTE *v26; // edi
  int *v27; // eax
  _DWORD v28[258]; // [esp+8h] [ebp-520h]
  _BYTE v29[260]; // [esp+410h] [ebp-118h] BYREF
  unsigned __int8 *v30; // [esp+514h] [ebp-14h]
  int v31; // [esp+518h] [ebp-10h]
  int j; // [esp+51Ch] [ebp-Ch]
  int v33; // [esp+520h] [ebp-8h]
  int v34; // [esp+524h] [ebp-4h]
  int i; // [esp+538h] [ebp+10h]
  int v36; // [esp+538h] [ebp+10h]

  if ( !*(_DWORD *)a3 )
    *(_DWORD *)a3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1492);
  v3 = *(_DWORD **)a3;
  v4 = a2;
  v5 = 0;
  *(_DWORD *)(*(_DWORD *)a3 + 208) = a2;
  v34 = 0;
  for ( i = 1; i <= 16; ++i )
  {
    v6 = *(unsigned __int8 *)(i + v4);
    v33 = v6;
    if ( v6 >= 1 )
    {
      v7 = &v29[v5];
      LOBYTE(v4) = i;
      BYTE1(v4) = i;
      v8 = v6;
      v9 = (unsigned int)v6 >> 2;
      v10 = v4 << 16;
      LOWORD(v10) = v4;
      v4 = a2;
      memset32(v7, v10, v9);
      memset(&v7[4 * v9], v10, v8 & 3);
      v5 = v8 + v34;
      v34 += v8;
    }
  }
  v29[v5] = 0;
  v11 = v29[0];
  v12 = 0;
  v13 = 0;
  if ( v29[0] )
  {
    v14 = v29;
    do
    {
      v15 = *v14;
      while ( v15 == v11 )
      {
        v15 = (char)v29[v12 + 1];
        v28[++v12] = v13++;
      }
      v13 *= 2;
      v14 = &v29[v12];
      ++v11;
    }
    while ( v29[v12] );
  }
  v16 = 0;
  v17 = 1;
  v18 = v3 + 18;
  do
  {
    if ( *(_BYTE *)(v17 + v4) )
    {
      v19 = v28[v16 + 1];
      v18[18] = v16;
      *(v18 - 17) = v19;
      v16 += *(unsigned __int8 *)(v17 + v4);
      *v18 = v28[v16];
    }
    else
    {
      *v18 = -1;
    }
    ++v17;
    ++v18;
  }
  while ( v17 <= 16 );
  v34 = 0;
  v3[34] = 0xFFFFF;
  memset(v3 + 53, 0, 0x400u);
  v36 = 1;
  for ( j = 7; j >= 0; --j )
  {
    result = v36;
    v21 = (unsigned __int8 *)(v36 + v4);
    v22 = *(_BYTE *)(v36 + v4) == 0;
    v31 = 1;
    v30 = (unsigned __int8 *)(v36 + v4);
    if ( !v22 )
    {
      v23 = 1 << j;
      v24 = (_BYTE *)(v34 + v4 + 17);
      do
      {
        v25 = v28[v34 + 1] << j;
        if ( v23 > 0 )
        {
          v26 = (char *)v3 + v25 + 1236;
          v27 = &v3[v25 + 53];
          v33 = v23;
          do
          {
            *v27++ = v36;
            *v26++ = *v24;
            --v33;
          }
          while ( v33 );
          v21 = v30;
        }
        ++v31;
        result = *v21;
        ++v34;
        ++v24;
      }
      while ( v31 <= result );
      v4 = a2;
    }
    ++v36;
  }
  return result;
}

// sub_1002FAAB @ 0x1002FAAB
char __cdecl sub_1002FAAB(unsigned __int8 **a1, int a2, int a3, int a4)
{
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // edi
  unsigned __int8 **v6; // eax
  int v7; // ecx
  unsigned __int8 **v8; // eax
  unsigned __int8 *v9; // ecx

  v4 = a1[1];
  v5 = *a1;
  while ( 1 )
  {
    if ( a3 >= 25 )
    {
LABEL_20:
      a1[3] = (unsigned __int8 *)a2;
      a1[6] = (unsigned __int8 *)a3;
      *a1 = v5;
      a1[1] = v4;
      return 1;
    }
    if ( a1[2] )
      goto LABEL_14;
    if ( !v4 )
      break;
LABEL_6:
    v7 = *v5;
    --v4;
    ++v5;
    if ( v7 != 255 )
      goto LABEL_18;
    do
    {
      if ( !v4 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[7] + 5) + 12))(a1[7]) )
          return 0;
        v8 = (unsigned __int8 **)*((_DWORD *)a1[7] + 5);
        v5 = *v8;
        v4 = v8[1];
      }
      v9 = (unsigned __int8 *)*v5;
      --v4;
      ++v5;
    }
    while ( v9 == (unsigned __int8 *)255 );
    if ( !v9 )
    {
      v7 = 255;
      goto LABEL_18;
    }
    a1[2] = v9;
LABEL_14:
    if ( a3 >= a4 )
      goto LABEL_20;
    if ( !*a1[8] )
    {
      *(_DWORD *)(*(_DWORD *)a1[7] + 20) = 113;
      (*(void (__cdecl **)(unsigned __int8 *, int))(*(_DWORD *)a1[7] + 4))(a1[7], -1);
      *a1[8] = 1;
    }
    v7 = 0;
LABEL_18:
    a3 += 8;
    a2 = v7 | (a2 << 8);
  }
  if ( (*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[7] + 5) + 12))(a1[7]) )
  {
    v6 = (unsigned __int8 **)*((_DWORD *)a1[7] + 5);
    v5 = *v6;
    v4 = v6[1];
    goto LABEL_6;
  }
  return 0;
}

// sub_1002FB95 @ 0x1002FB95
int __cdecl sub_1002FB95(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // edx
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  int v11; // esi
  int v12; // [esp+8h] [ebp-4h]
  int *v13; // [esp+24h] [ebp+18h]

  v5 = a3;
  v12 = a5;
  if ( a3 >= a5 )
  {
    v7 = a2;
  }
  else
  {
    if ( !sub_1002FAAB((unsigned __int8 **)a1, a2, a3, a5) )
      return -1;
    v7 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 24);
  }
  v8 = v5 - a5;
  v9 = ((1 << a5) - 1) & (v7 >> v8);
  v10 = a4;
  if ( v9 > *(_DWORD *)(a4 + 4 * a5 + 68) )
  {
    v13 = (int *)(a4 + 4 * a5 + 68);
    while ( 1 )
    {
      v11 = 2 * v9;
      if ( v8 < 1 )
      {
        if ( !sub_1002FAAB((unsigned __int8 **)a1, v7, v8, 1) )
          return -1;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(_DWORD *)(a1 + 24);
      }
      ++v13;
      v9 = (v7 >> --v8) & 1 | v11;
      ++v12;
      if ( v9 <= *v13 )
      {
        v10 = a4;
        break;
      }
    }
  }
  *(_DWORD *)(a1 + 24) = v8;
  *(_DWORD *)(a1 + 12) = v7;
  if ( v12 <= 16 )
    return *(unsigned __int8 *)(*(_DWORD *)(v10 + 208)
                              + *(_DWORD *)(v10 + 4 * v12 + 140)
                              - *(_DWORD *)(v10 + 4 * v12)
                              + v9
                              + 17);
  *(_DWORD *)(**(_DWORD **)(a1 + 28) + 20) = 114;
  (*(void (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 28) + 4))(*(_DWORD *)(a1 + 28), -1);
  return 0;
}

// sub_1002FC7F @ 0x1002FC7F
char __cdecl sub_1002FC7F(_DWORD *a1)
{
  int v1; // esi
  char result; // al
  int v3; // edx
  _DWORD *v4; // ecx

  v1 = a1[101];
  *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v1 + 20) / 8;
  *(_DWORD *)(v1 + 20) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[100] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[72] > 0 )
    {
      v4 = (_DWORD *)(v1 + 32);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[72] );
    }
    *(_DWORD *)(v1 + 48) = a1[63];
    *(_BYTE *)(v1 + 24) = 0;
    return 1;
  }
  return result;
}

// sub_1002FCDD @ 0x1002FCDD
char __cdecl sub_1002FCDD(_DWORD *a1, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ebx
  char result; // al
  int v5; // eax
  unsigned __int8 *v6; // edx
  int v7; // eax
  bool v8; // cc
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // edi
  int v14; // ecx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // esi
  int v20; // ecx
  int *v21; // ecx
  int v22; // ecx
  int v23; // esi
  int v24; // esi
  int v25; // edi
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // esi
  __int16 v30; // cx
  int v31; // ecx
  int v32; // esi
  int v33; // esi
  int v34; // edi
  int v35; // esi
  int v36; // ecx
  int v37; // esi
  unsigned __int8 *v38; // [esp+4h] [ebp-54h] BYREF
  int v39; // [esp+8h] [ebp-50h]
  int v40; // [esp+Ch] [ebp-4Ch]
  int v41; // [esp+10h] [ebp-48h]
  int v42; // [esp+1Ch] [ebp-3Ch]
  _DWORD *v43; // [esp+20h] [ebp-38h]
  _DWORD *v44; // [esp+24h] [ebp-34h]
  int v45; // [esp+2Ch] [ebp-2Ch] BYREF
  int v46; // [esp+30h] [ebp-28h]
  int v47; // [esp+34h] [ebp-24h]
  int v48; // [esp+38h] [ebp-20h]
  int v49; // [esp+3Ch] [ebp-1Ch]
  _WORD *v50; // [esp+40h] [ebp-18h]
  int v51; // [esp+44h] [ebp-14h]
  int *v52; // [esp+48h] [ebp-10h]
  int v53; // [esp+4Ch] [ebp-Ch]
  int v54; // [esp+50h] [ebp-8h]
  int i; // [esp+54h] [ebp-4h]

  v2 = a1;
  v3 = (_DWORD *)a1[101];
  if ( a1[63] && !v3[12] )
  {
    result = sub_1002FC7F(a1);
    if ( !result )
      return result;
    v2 = a1;
  }
  v5 = v2[5];
  v6 = *(unsigned __int8 **)v5;
  v7 = *(_DWORD *)(v5 + 4);
  v53 = 0;
  v8 = v2[79] <= 0;
  v44 = v3 + 6;
  v45 = v3[8];
  v46 = v3[9];
  v39 = v7;
  v9 = v2[94];
  v47 = v3[10];
  v38 = v6;
  v10 = v3[4];
  v40 = v9;
  v11 = v3[5];
  v43 = v2;
  v48 = v3[11];
  if ( v8 )
    goto LABEL_66;
  v52 = v2 + 80;
  do
  {
    v50 = *(_WORD **)(a2 + 4 * v53);
    v12 = *v52;
    v13 = v2[*v52 + 73];
    i = v3[*(_DWORD *)(v13 + 20) + 13];
    v14 = v3[*(_DWORD *)(v13 + 24) + 17];
    v49 = v12;
    v51 = v13;
    v54 = v14;
    if ( v11 < 8 )
    {
      if ( !sub_1002FAAB(&v38, v10, v11, 0) )
        return 0;
      v11 = v42;
      v10 = v41;
      if ( v42 < 8 )
      {
        v15 = 1;
LABEL_14:
        v18 = sub_1002FB95((int)&v38, v10, v11, i, v15);
        if ( v18 < 0 )
          return 0;
        v10 = v41;
        v11 = v42;
        goto LABEL_16;
      }
    }
    v16 = (unsigned __int8)(v10 >> (v11 - 8));
    v17 = *(_DWORD *)(i + 4 * v16 + 212);
    if ( !v17 )
    {
      v15 = 9;
      goto LABEL_14;
    }
    v11 -= v17;
    v18 = *(unsigned __int8 *)(v16 + i + 1236);
LABEL_16:
    if ( v18 )
    {
      if ( v11 < v18 )
      {
        if ( !sub_1002FAAB(&v38, v10, v11, v18) )
          return 0;
        v10 = v41;
        v11 = v42;
      }
      v11 -= v18;
      i = (1 << v18) - 1;
      v19 = v18;
      v20 = (v10 >> v11) & i;
      v13 = v51;
      if ( v20 >= dword_1004F3A8[v19] )
        v18 = (v10 >> v11) & i;
      else
        v18 = v20 + dword_1004F3E8[v19];
    }
    if ( *(_BYTE *)(v13 + 48) )
    {
      v21 = &v45 + v49;
      *v21 += v18;
      *v50 = *v21;
      if ( *(int *)(v13 + 36) > 1 )
      {
        i = 1;
        while ( 1 )
        {
          if ( v11 < 8 )
          {
            if ( !sub_1002FAAB(&v38, v10, v11, 0) )
              return 0;
            v11 = v42;
            v10 = v41;
            if ( v42 < 8 )
              break;
          }
          v22 = v54;
          v24 = (unsigned __int8)(v10 >> (v11 - 8));
          v25 = *(_DWORD *)(v54 + 4 * v24 + 212);
          if ( !v25 )
          {
            v23 = 9;
            goto LABEL_33;
          }
          v11 -= v25;
          v26 = *(unsigned __int8 *)(v24 + v54 + 1236);
LABEL_35:
          v27 = v26 >> 4;
          v28 = v26 & 0xF;
          v49 = v28;
          if ( v28 )
          {
            i += v27;
            if ( v11 < v28 )
            {
              if ( !sub_1002FAAB(&v38, v10, v11, v28) )
                return 0;
              v10 = v41;
              v11 = v42;
            }
            v11 -= v28;
            v29 = (v10 >> v11) & ((1 << v28) - 1);
            if ( v29 >= dword_1004F3A8[v49] )
              v30 = (v10 >> v11) & ((1 << v28) - 1);
            else
              v30 = v29 + dword_1004F3E8[v49];
            v50[dword_1004E8C0[i]] = v30;
          }
          else
          {
            if ( v27 != 15 )
              goto LABEL_65;
            i += 15;
          }
          if ( ++i >= 64 )
            goto LABEL_65;
        }
        v22 = v54;
        v23 = 1;
LABEL_33:
        v26 = sub_1002FB95((int)&v38, v10, v11, v22, v23);
        if ( v26 < 0 )
          return 0;
        v10 = v41;
        v11 = v42;
        goto LABEL_35;
      }
    }
    for ( i = 1; i < 64; ++i )
    {
      if ( v11 >= 8 )
        goto LABEL_52;
      if ( !sub_1002FAAB(&v38, v10, v11, 0) )
        return 0;
      v11 = v42;
      v10 = v41;
      if ( v42 >= 8 )
      {
LABEL_52:
        v31 = v54;
        v33 = (unsigned __int8)(v10 >> (v11 - 8));
        v34 = *(_DWORD *)(v54 + 4 * v33 + 212);
        if ( v34 )
        {
          v35 = *(unsigned __int8 *)(v33 + v54 + 1236);
          v11 -= v34;
          goto LABEL_57;
        }
        v32 = 9;
      }
      else
      {
        v31 = v54;
        v32 = 1;
      }
      v35 = sub_1002FB95((int)&v38, v10, v11, v31, v32);
      if ( v35 < 0 )
        return 0;
      v10 = v41;
      v11 = v42;
LABEL_57:
      v36 = v35 >> 4;
      v37 = v35 & 0xF;
      if ( v37 )
      {
        i += v36;
        if ( v11 < v37 )
        {
          if ( !sub_1002FAAB(&v38, v10, v11, v37) )
            return 0;
          v10 = v41;
          v11 = v42;
        }
        v11 -= v37;
      }
      else
      {
        if ( v36 != 15 )
          break;
        i += 15;
      }
    }
LABEL_65:
    ++v53;
    v2 = a1;
    ++v52;
  }
  while ( v53 < a1[79] );
LABEL_66:
  *(_DWORD *)v2[5] = v38;
  *(_DWORD *)(v2[5] + 4) = v39;
  v2[94] = v40;
  --v3[12];
  v3[8] = v45;
  v3[9] = v46;
  v3[10] = v47;
  v3[5] = v11;
  v3[4] = v10;
  v3[11] = v48;
  return 1;
}

// sub_100300AA @ 0x100300AA
int __cdecl sub_100300AA(_DWORD *a1)
{
  int v2; // edi
  unsigned int v3; // ebx
  unsigned int v4; // eax
  int result; // eax
  unsigned int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+14h] [ebp-4h]
  _DWORD *v9; // [esp+20h] [ebp+8h]

  v2 = a1[101];
  if ( a1[90] || a1[91] != 63 || a1[92] || a1[93] )
  {
    *(_DWORD *)(*a1 + 20) = 118;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v7 = 0;
  if ( (int)a1[72] > 0 )
  {
    v8 = (_DWORD *)(v2 + 32);
    v9 = a1 + 73;
    do
    {
      v3 = *(_DWORD *)(*v9 + 20);
      v4 = *(_DWORD *)(*v9 + 24);
      v6 = v4;
      if ( v3 >= 4 || !a1[v3 + 40] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v3;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        v4 = v6;
      }
      if ( v4 >= 4 || !a1[v4 + 44] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v4;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_1002F901((int)a1, a1[v3 + 40], v2 + 4 * v3 + 52);
      sub_1002F901((int)a1, a1[v6 + 44], v2 + 4 * v6 + 68);
      *v8 = 0;
      ++v9;
      ++v8;
      ++v7;
    }
    while ( v7 < a1[72] );
  }
  *(_BYTE *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  result = a1[63];
  *(_DWORD *)(v2 + 48) = result;
  return result;
}

// sub_100301D9 @ 0x100301D9
_DWORD *__cdecl sub_100301D9(int a1)
{
  _DWORD *v1; // eax
  int v2; // ecx
  _DWORD *result; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 88);
  *(_DWORD *)(a1 + 404) = v1;
  v2 = 4;
  *v1 = sub_100300AA;
  v1[1] = sub_1002FCDD;
  result = v1 + 13;
  do
  {
    result[4] = 0;
    *result++ = 0;
    --v2;
  }
  while ( v2 );
  return result;
}

// sub_10030213 @ 0x10030213
char __usercall sub_10030213@<al>(_DWORD *a1@<edi>)
{
  int v1; // esi
  char result; // al
  int v3; // edx
  _DWORD *v4; // ecx

  v1 = a1[101];
  *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v1 + 20) / 8;
  *(_DWORD *)(v1 + 20) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[100] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[72] > 0 )
    {
      v4 = (_DWORD *)(v1 + 36);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[72] );
    }
    *(_DWORD *)(v1 + 32) = 0;
    *(_DWORD *)(v1 + 52) = a1[63];
    *(_BYTE *)(v1 + 24) = 0;
    return 1;
  }
  return result;
}

// sub_1003026E @ 0x1003026E
char __cdecl sub_1003026E(_DWORD *a1, int a2)
{
  bool v3; // zf
  _DWORD *v4; // eax
  int v5; // ecx
  char result; // al
  int v7; // ecx
  bool v8; // cc
  int v9; // edx
  int v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // esi
  unsigned __int8 *v19; // [esp+8h] [ebp-58h] BYREF
  int v20; // [esp+Ch] [ebp-54h]
  int v21; // [esp+10h] [ebp-50h]
  int v22; // [esp+14h] [ebp-4Ch]
  int v23; // [esp+20h] [ebp-40h]
  _DWORD *v24; // [esp+24h] [ebp-3Ch]
  _DWORD *v25; // [esp+28h] [ebp-38h]
  _DWORD v26[5]; // [esp+30h] [ebp-30h] BYREF
  _WORD *v27; // [esp+44h] [ebp-1Ch]
  int v28; // [esp+48h] [ebp-18h]
  int v29; // [esp+4Ch] [ebp-14h]
  int *v30; // [esp+50h] [ebp-10h]
  int v31; // [esp+54h] [ebp-Ch]
  _DWORD *v32; // [esp+58h] [ebp-8h]
  int v33; // [esp+5Ch] [ebp-4h]
  int v34; // [esp+68h] [ebp+8h]

  v3 = a1[63] == 0;
  v4 = (_DWORD *)a1[101];
  v5 = a1[93];
  v32 = v4;
  v28 = v5;
  if ( !v3 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
    v4 = v32;
  }
  v7 = a1[5];
  v31 = 0;
  v8 = a1[79] <= 0;
  v24 = a1;
  v19 = *(unsigned __int8 **)v7;
  v20 = *(_DWORD *)(v7 + 4);
  v21 = a1[94];
  v9 = v4[5];
  v34 = v4[4];
  v25 = v4 + 6;
  qmemcpy(v26, v4 + 8, sizeof(v26));
  if ( !v8 )
  {
    v30 = a1 + 80;
    do
    {
      v27 = *(_WORD **)(a2 + 4 * v31);
      v29 = *v30;
      v10 = v4[*(_DWORD *)(a1[v29 + 73] + 20) + 14];
      if ( v9 < 8 )
      {
        if ( !sub_1002FAAB(&v19, v34, v9, 0) )
          return 0;
        v9 = v23;
        v34 = v22;
        if ( v23 < 8 )
        {
          v11 = 1;
          goto LABEL_15;
        }
        v4 = v32;
      }
      v12 = (unsigned __int8)(v34 >> (v9 - 8));
      v13 = *(_DWORD *)(v10 + 4 * v12 + 212);
      if ( v13 )
      {
        v14 = *(unsigned __int8 *)(v12 + v10 + 1236);
        v9 -= v13;
        goto LABEL_17;
      }
      v11 = 9;
LABEL_15:
      v14 = sub_1002FB95((int)&v19, v34, v9, v10, v11);
      if ( v14 < 0 )
        return 0;
      v9 = v23;
      v34 = v22;
      v4 = v32;
LABEL_17:
      if ( v14 )
      {
        if ( v9 < v14 )
        {
          if ( !sub_1002FAAB(&v19, v34, v9, v14) )
            return 0;
          v9 = v23;
          v34 = v22;
          v4 = v32;
        }
        v9 -= v14;
        v33 = (1 << v14) - 1;
        v15 = v14;
        v16 = (v34 >> v9) & v33;
        if ( v16 >= dword_1004F490[v15] )
          v14 = (v34 >> v9) & v33;
        else
          v14 = v16 + dword_1004F4D0[v15];
      }
      ++v30;
      v17 = &v26[v29 + 1];
      *v17 += v14;
      v18 = *v17 << v28;
      ++v31;
      *v27 = v18;
    }
    while ( v31 < a1[79] );
  }
  *(_DWORD *)a1[5] = v19;
  *(_DWORD *)(a1[5] + 4) = v20;
  a1[94] = v21;
  --v4[13];
  v4[4] = v34;
  v4[5] = v9;
  qmemcpy(v4 + 8, v26, 0x14u);
  return 1;
}

// sub_1003046B @ 0x1003046B
char __cdecl sub_1003046B(_DWORD *a1, int *a2)
{
  bool v3; // zf
  _DWORD *v4; // esi
  char result; // al
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // ecx
  int v15; // edx
  int v16; // ebx
  unsigned __int8 *v17; // [esp+8h] [ebp-48h] BYREF
  int v18; // [esp+Ch] [ebp-44h]
  int v19; // [esp+10h] [ebp-40h]
  int v20; // [esp+14h] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-30h]
  _DWORD *v22; // [esp+24h] [ebp-2Ch]
  _DWORD *v23; // [esp+28h] [ebp-28h]
  int v24; // [esp+30h] [ebp-20h]
  int v25; // [esp+34h] [ebp-1Ch]
  int v26; // [esp+38h] [ebp-18h]
  int v27; // [esp+3Ch] [ebp-14h]
  int v28; // [esp+40h] [ebp-10h]
  int v29; // [esp+44h] [ebp-Ch]
  int v30; // [esp+48h] [ebp-8h]
  int v31; // [esp+4Ch] [ebp-4h]
  int v32; // [esp+58h] [ebp+8h]
  int v33; // [esp+58h] [ebp+8h]
  int v34; // [esp+58h] [ebp+8h]

  v3 = a1[63] == 0;
  v4 = (_DWORD *)a1[101];
  v26 = a1[91];
  v25 = a1[93];
  if ( !v3 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
  }
  v30 = v4[8];
  if ( v30 )
  {
    v6 = v30 - 1;
    goto LABEL_37;
  }
  v7 = a1[5];
  v22 = a1;
  v17 = *(unsigned __int8 **)v7;
  v18 = *(_DWORD *)(v7 + 4);
  v19 = a1[94];
  v8 = v4[4];
  v9 = v4[5];
  v23 = v4 + 6;
  v24 = *a2;
  v27 = v4[18];
  v10 = a1[90];
  v29 = v8;
  v31 = v10;
  while ( v10 <= v26 )
  {
    if ( v9 >= 8 )
      goto LABEL_11;
    if ( !sub_1002FAAB(&v17, v8, v9, 0) )
      return 0;
    v9 = v21;
    v8 = v20;
    v29 = v20;
    if ( v21 >= 8 )
    {
LABEL_11:
      v12 = (unsigned __int8)(v8 >> (v9 - 8));
      v13 = *(_DWORD *)(v27 + 4 * v12 + 212);
      if ( v13 )
      {
        v9 -= v13;
        v32 = *(unsigned __int8 *)(v12 + v27 + 1236);
        goto LABEL_16;
      }
      v11 = 9;
    }
    else
    {
      v11 = 1;
    }
    v32 = sub_1002FB95((int)&v17, v8, v9, v27, v11);
    if ( v32 < 0 )
      return 0;
    v8 = v20;
    v9 = v21;
    v29 = v20;
LABEL_16:
    v14 = v32 >> 4;
    v3 = (v32 & 0xF) == 0;
    v33 = v32 & 0xF;
    v28 = v14;
    if ( v3 )
    {
      if ( v14 != 15 )
      {
        v34 = 1 << v14;
        v30 = 1 << v14;
        if ( v28 )
        {
          if ( v9 < v28 )
          {
            if ( !sub_1002FAAB(&v17, v8, v9, v28) )
              return 0;
            v8 = v20;
            v9 = v21;
          }
          v9 -= v28;
          v30 += (v34 - 1) & (v8 >> v9);
        }
        --v30;
        break;
      }
      v31 += 15;
    }
    else
    {
      v31 += v14;
      if ( v9 < v33 )
      {
        if ( !sub_1002FAAB(&v17, v8, v9, v33) )
          return 0;
        v8 = v20;
        v9 = v21;
        v29 = v20;
      }
      v9 -= v33;
      v15 = (v8 >> v9) & ((1 << v33) - 1);
      if ( v15 >= dword_1004F490[v33] )
        v16 = (v8 >> v9) & ((1 << v33) - 1);
      else
        v16 = v15 + dword_1004F4D0[v33];
      *(_WORD *)(v24 + 2 * dword_1004E8C0[v31]) = v16 << v25;
      v8 = v29;
    }
    v10 = ++v31;
  }
  *(_DWORD *)a1[5] = v17;
  *(_DWORD *)(a1[5] + 4) = v18;
  a1[94] = v19;
  v4[5] = v9;
  v6 = v30;
  v4[4] = v8;
LABEL_37:
  --v4[13];
  v4[8] = v6;
  return 1;
}

// sub_10030694 @ 0x10030694
char __cdecl sub_10030694(_DWORD *a1, int a2)
{
  _DWORD *v3; // esi
  bool v4; // zf
  bool v5; // cc
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _WORD *v9; // ebx
  unsigned __int8 *v11; // [esp+Ch] [ebp-2Ch] BYREF
  int v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+24h] [ebp-14h]
  _DWORD *v16; // [esp+28h] [ebp-10h]
  _DWORD *v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+34h] [ebp-4h]
  int v19; // [esp+40h] [ebp+8h]

  v3 = (_DWORD *)a1[101];
  v4 = a1[63] == 0;
  v18 = 1 << a1[93];
  if ( !v4 && !v3[13] && !sub_10030213(a1) )
    return 0;
  v5 = a1[79] <= 0;
  v6 = a1[5];
  v16 = a1;
  v11 = *(unsigned __int8 **)v6;
  v12 = *(_DWORD *)(v6 + 4);
  v13 = a1[94];
  v7 = v3[4];
  v8 = v3[5];
  v17 = v3 + 6;
  v19 = 0;
  if ( !v5 )
  {
    do
    {
      v9 = *(_WORD **)(a2 + 4 * v19);
      if ( v8 < 1 )
      {
        if ( !sub_1002FAAB(&v11, v7, v8, 1) )
          return 0;
        v7 = v14;
        v8 = v15;
      }
      if ( ((v7 >> --v8) & 1) != 0 )
        *v9 |= v18;
      ++v19;
    }
    while ( v19 < a1[79] );
  }
  *(_DWORD *)a1[5] = v11;
  *(_DWORD *)(a1[5] + 4) = v12;
  a1[94] = v13;
  --v3[13];
  v3[4] = v7;
  v3[5] = v8;
  return 1;
}

// sub_10030776 @ 0x10030776
char __cdecl sub_10030776(_DWORD *a1, int *a2)
{
  int v3; // ecx
  _DWORD *v4; // esi
  bool v5; // zf
  char result; // al
  int v7; // eax
  int v8; // ebx
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  __int16 *v17; // eax
  __int16 v18; // dx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int i; // eax
  __int16 *v23; // eax
  __int16 v24; // dx
  int j; // eax
  int v26; // ecx
  _DWORD v27[65]; // [esp+4h] [ebp-158h]
  unsigned __int8 *v28; // [esp+108h] [ebp-54h] BYREF
  int v29; // [esp+10Ch] [ebp-50h]
  int v30; // [esp+110h] [ebp-4Ch]
  int v31; // [esp+114h] [ebp-48h]
  int v32; // [esp+120h] [ebp-3Ch]
  _DWORD *v33; // [esp+124h] [ebp-38h]
  _DWORD *v34; // [esp+128h] [ebp-34h]
  int v35; // [esp+130h] [ebp-2Ch]
  int v36; // [esp+134h] [ebp-28h]
  __int16 *v37; // [esp+138h] [ebp-24h]
  int v38; // [esp+13Ch] [ebp-20h]
  int v39; // [esp+140h] [ebp-1Ch]
  int v40; // [esp+144h] [ebp-18h]
  int v41; // [esp+148h] [ebp-14h]
  int v42; // [esp+14Ch] [ebp-10h]
  int v43; // [esp+150h] [ebp-Ch]
  int v44; // [esp+154h] [ebp-8h]
  int v45; // [esp+158h] [ebp-4h]
  int v46; // [esp+164h] [ebp+8h]

  v3 = a1[93];
  v4 = (_DWORD *)a1[101];
  v42 = a1[91];
  v36 = 1 << v3;
  v5 = a1[63] == 0;
  v35 = -1 << v3;
  if ( !v5 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
  }
  v7 = a1[5];
  v40 = 0;
  v33 = a1;
  v28 = *(unsigned __int8 **)v7;
  v29 = *(_DWORD *)(v7 + 4);
  v30 = a1[94];
  v46 = v4[4];
  v8 = v4[5];
  v34 = v4 + 6;
  v9 = v4[8];
  v41 = *a2;
  v39 = v4[18];
  v10 = a1[90];
  v43 = v9;
  v45 = v10;
  if ( v9 )
  {
LABEL_47:
    if ( v43 )
    {
      for ( i = v45; i <= v42; i = ++v45 )
      {
        v23 = (__int16 *)(v41 + 2 * dword_1004E8C0[i]);
        v5 = *v23 == 0;
        v37 = v23;
        if ( !v5 )
        {
          if ( v8 < 1 )
          {
            if ( !sub_1002FAAB(&v28, v46, v8, 1) )
              goto LABEL_63;
            v8 = v32;
            v46 = v31;
            v23 = v37;
          }
          if ( ((v46 >> --v8) & 1) != 0 )
          {
            v24 = v36;
            if ( (*v23 & v36) == 0 )
            {
              if ( *v23 < 0 )
                v24 = v35;
              *v23 += v24;
            }
          }
        }
      }
      --v43;
    }
LABEL_61:
    *(_DWORD *)a1[5] = v28;
    *(_DWORD *)(a1[5] + 4) = v29;
    a1[94] = v30;
    --v4[13];
    v4[4] = v46;
    v4[8] = v43;
    v4[5] = v8;
    return 1;
  }
  while ( 1 )
  {
    if ( v10 > v42 )
      goto LABEL_61;
    if ( v8 >= 8 )
      goto LABEL_10;
    if ( !sub_1002FAAB(&v28, v46, v8, 0) )
      goto LABEL_63;
    v8 = v32;
    v46 = v31;
    if ( v32 >= 8 )
    {
LABEL_10:
      v12 = (unsigned __int8)(v46 >> (v8 - 8));
      v13 = *(_DWORD *)(v39 + 4 * v12 + 212);
      if ( v13 )
      {
        v8 -= v13;
        v44 = *(unsigned __int8 *)(v12 + v39 + 1236);
        goto LABEL_15;
      }
      v11 = 9;
    }
    else
    {
      v11 = 1;
    }
    v44 = sub_1002FB95((int)&v28, v46, v8, v39, v11);
    if ( v44 < 0 )
      goto LABEL_63;
    v8 = v32;
    v46 = v31;
LABEL_15:
    v14 = v44 >> 4;
    v5 = (v44 & 0xF) == 0;
    v44 &= 0xFu;
    v38 = v14;
    if ( v5 )
      break;
    if ( v44 != 1 )
    {
      *(_DWORD *)(*a1 + 20) = 114;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    }
    if ( v8 < 1 )
    {
      if ( !sub_1002FAAB(&v28, v46, v8, 1) )
        goto LABEL_63;
      v8 = v32;
      v46 = v31;
    }
    --v8;
    v15 = v36;
    if ( ((v46 >> v8) & 1) == 0 )
      v15 = v35;
    v44 = v15;
LABEL_25:
    v16 = v45;
    do
    {
      v17 = (__int16 *)(v41 + 2 * dword_1004E8C0[v16]);
      v5 = *v17 == 0;
      v37 = v17;
      if ( v5 )
      {
        if ( --v38 < 0 )
          break;
      }
      else
      {
        if ( v8 < 1 )
        {
          if ( !sub_1002FAAB(&v28, v46, v8, 1) )
            goto LABEL_63;
          v8 = v32;
          v46 = v31;
          v17 = v37;
        }
        if ( ((v46 >> --v8) & 1) != 0 )
        {
          v18 = v36;
          if ( (*v17 & v36) == 0 )
          {
            if ( *v17 < 0 )
              v18 = v35;
            *v17 += v18;
          }
        }
      }
      v16 = ++v45;
    }
    while ( v45 <= v42 );
    if ( v44 )
    {
      v19 = dword_1004E8C0[v16];
      *(_WORD *)(v41 + 2 * v19) = v44;
      v20 = v40++;
      v27[v20 + 1] = v19;
    }
    v10 = ++v45;
  }
  if ( v14 == 15 )
    goto LABEL_25;
  v21 = 1 << v14;
  v39 = 1 << v14;
  v43 = 1 << v14;
  if ( !v14 )
    goto LABEL_47;
  if ( v8 >= v14 )
    goto LABEL_46;
  if ( sub_1002FAAB(&v28, v46, v8, v14) )
  {
    v8 = v32;
    v46 = v31;
    v21 = v39;
LABEL_46:
    v8 -= v38;
    v43 += (v21 - 1) & (v46 >> v8);
    goto LABEL_47;
  }
LABEL_63:
  for ( j = v40; j > 0; --j )
  {
    v26 = v27[j];
    *(_WORD *)(v41 + 2 * v26) = 0;
  }
  return 0;
}

// sub_10030AE4 @ 0x10030AE4
int __cdecl sub_10030AE4(int *a1)
{
  int v2; // eax
  int v3; // ebx
  char v4; // dl
  bool v5; // zf
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int *v9; // ebx
  int i; // edi
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // edi
  unsigned int v14; // edi
  _DWORD *v15; // eax
  int result; // eax
  int v17; // [esp+10h] [ebp-10h]
  _DWORD *v18; // [esp+10h] [ebp-10h]
  _DWORD *v19; // [esp+14h] [ebp-Ch]
  int *v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  int v22; // [esp+1Ch] [ebp-4h]
  int v23; // [esp+1Ch] [ebp-4h]
  bool v24; // [esp+2Bh] [ebp+Bh]

  v2 = a1[90];
  v3 = a1[101];
  v24 = v2 == 0;
  v4 = 0;
  v21 = v3;
  if ( v2 )
  {
    v6 = a1[91];
    if ( v2 > v6 || v6 >= 64 )
      v4 = 1;
    v5 = a1[72] == 1;
  }
  else
  {
    v5 = a1[91] == 0;
  }
  if ( !v5 )
    v4 = 1;
  v7 = a1[92];
  if ( v7 && a1[93] != v7 - 1 )
    v4 = 1;
  if ( a1[93] > 13 )
    v4 = 1;
  if ( v4 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a1[90];
    *(_DWORD *)(*a1 + 28) = a1[91];
    *(_DWORD *)(*a1 + 32) = a1[92];
    *(_DWORD *)(*a1 + 36) = a1[93];
    (*(void (__cdecl **)(int *))*a1)(a1);
  }
  v22 = 0;
  if ( a1[72] > 0 )
  {
    v19 = a1 + 73;
    do
    {
      v8 = *(_DWORD *)(*v19 + 4);
      v9 = (int *)(a1[35] + (v8 << 8));
      v17 = v8;
      if ( !v24 && *v9 < 0 )
      {
        *(_DWORD *)(*a1 + 20) = 111;
        *(_DWORD *)(*a1 + 24) = v8;
        *(_DWORD *)(*a1 + 28) = 0;
        (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
        v8 = v17;
      }
      for ( i = a1[90]; i <= a1[91]; ++i )
      {
        v11 = v9[i];
        if ( v11 < 0 )
          v11 = 0;
        if ( a1[92] != v11 )
        {
          *(_DWORD *)(*a1 + 20) = 111;
          *(_DWORD *)(*a1 + 24) = v8;
          *(_DWORD *)(*a1 + 28) = i;
          (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
          v8 = v17;
        }
        v9[i] = a1[93];
      }
      ++v22;
      ++v19;
    }
    while ( v22 < a1[72] );
    v3 = v21;
  }
  if ( a1[92] )
  {
    if ( v24 )
      *(_DWORD *)(v3 + 4) = sub_10030694;
    else
      *(_DWORD *)(v3 + 4) = sub_10030776;
  }
  else if ( v24 )
  {
    *(_DWORD *)(v3 + 4) = sub_1003026E;
  }
  else
  {
    *(_DWORD *)(v3 + 4) = sub_1003046B;
  }
  v23 = 0;
  if ( a1[72] > 0 )
  {
    v18 = (_DWORD *)(v3 + 36);
    v20 = a1 + 73;
    while ( 1 )
    {
      v12 = *v20;
      if ( !v24 )
        break;
      if ( !a1[92] )
      {
        v13 = *(_DWORD *)(v12 + 20);
        if ( v13 >= 4 || !a1[v13 + 40] )
        {
          *(_DWORD *)(*a1 + 20) = 49;
          *(_DWORD *)(*a1 + 24) = v13;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        sub_1002F901((int)a1, a1[v13 + 40], v21 + 4 * v13 + 56);
LABEL_49:
        v3 = v21;
      }
      v15 = v18;
      ++v23;
      ++v20;
      ++v18;
      *v15 = 0;
      if ( v23 >= a1[72] )
        goto LABEL_51;
    }
    v14 = *(_DWORD *)(v12 + 24);
    if ( v14 >= 4 || !a1[v14 + 44] )
    {
      *(_DWORD *)(*a1 + 20) = 49;
      *(_DWORD *)(*a1 + 24) = v14;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    sub_1002F901((int)a1, a1[v14 + 44], v21 + 4 * v14 + 56);
    *(_DWORD *)(v21 + 72) = *(_DWORD *)(v21 + 4 * v14 + 56);
    goto LABEL_49;
  }
LABEL_51:
  *(_BYTE *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  result = a1[63];
  *(_DWORD *)(v3 + 52) = result;
  return result;
}

// sub_10030D87 @ 0x10030D87
int __cdecl sub_10030D87(int a1)
{
  int (__cdecl **v1)(int *); // eax
  int result; // eax
  int v3; // edx
  bool v4; // cc
  char *v5; // ebx
  void *v6; // edi

  v1 = (int (__cdecl **)(int *))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_10030AE4;
  v1[14] = 0;
  v1[15] = 0;
  v1[16] = 0;
  v1[17] = 0;
  result = (**(int (__cdecl ***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD *)(a1 + 32) << 8);
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 140) = result;
  v5 = (char *)result;
  if ( !v4 )
  {
    do
    {
      result = -1;
      v6 = v5;
      v5 += 256;
      ++v3;
      memset(v6, 0xFFu, 0x100u);
    }
    while ( v3 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10030DE8 @ 0x10030DE8
int __cdecl sub_10030DE8(_DWORD *a1)
{
  bool v2; // cc
  int result; // eax
  int v4; // edi
  int *v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // eax
  double *v12; // ecx
  double v13; // st7
  __int16 *v14; // eax
  int v15; // edx
  _WORD *v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // [esp+Ch] [ebp-14h]
  int i; // [esp+10h] [ebp-10h]
  int v21; // [esp+14h] [ebp-Ch]
  double *v22; // [esp+18h] [ebp-8h]
  int v23; // [esp+18h] [ebp-8h]
  int v24; // [esp+1Ch] [ebp-4h]
  int (__cdecl *v25)(int, int, int, int, int); // [esp+28h] [ebp+8h]

  v2 = a1[8] <= 0;
  result = a1[102];
  v4 = a1[49];
  v24 = 0;
  v25 = 0;
  v21 = 0;
  if ( !v2 )
  {
    v5 = (int *)(result + 44);
    v6 = v4 + 36;
    for ( i = result + 44; ; i += 4 )
    {
      if ( *(_DWORD *)v6 == 1 )
      {
        v25 = sub_10035ECB;
        goto LABEL_19;
      }
      if ( *(_DWORD *)v6 == 2 )
      {
        v25 = sub_10035D0D;
        goto LABEL_19;
      }
      if ( *(_DWORD *)v6 == 4 )
        break;
      if ( *(_DWORD *)v6 != 8 )
      {
        *(_DWORD *)(*a1 + 20) = 6;
        *(_DWORD *)(*a1 + 24) = *(_DWORD *)v6;
LABEL_12:
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        goto LABEL_20;
      }
      v7 = a1[17];
      if ( !v7 )
      {
        v25 = sub_10035F08;
LABEL_19:
        v24 = 0;
        goto LABEL_20;
      }
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 != 1 )
        {
          *(_DWORD *)(*a1 + 20) = 47;
          goto LABEL_12;
        }
        v25 = sub_10035FA0;
        v24 = 2;
      }
      else
      {
        v25 = sub_10035F54;
        v24 = 1;
      }
LABEL_20:
      *(v5 - 10) = (int)v25;
      if ( *(_BYTE *)(v6 + 12) )
      {
        if ( *v5 != v24 )
        {
          v9 = *(_DWORD *)(v6 + 40);
          v19 = v9;
          if ( v9 )
          {
            *v5 = v24;
            if ( v24 )
            {
              if ( v24 == 1 )
              {
                v14 = (__int16 *)&unk_1004F510;
                v15 = v9 - (_DWORD)&unk_1004F510;
                v23 = *(_DWORD *)(v6 + 44) - (_DWORD)&unk_1004F510;
                do
                {
                  *(__int16 *)((char *)v14 + v23) = (*v14 * *(__int16 *)((char *)v14 + v15) + 2048) >> 12;
                  ++v14;
                }
                while ( (int)v14 < (int)word_1004F590 );
              }
              else
              {
                v10 = *(_DWORD *)(v6 + 44);
                v11 = 0;
                v22 = (double *)word_1004F590;
                do
                {
                  v12 = (double *)word_1004F590;
                  do
                  {
                    v13 = (double)*(unsigned __int16 *)(v19 + 2 * v11) * *v12++;
                    *(float *)(v10 + 4 * v11++) = v13 * *v22;
                  }
                  while ( (int)v12 < (int)dbl_1004F5D0 );
                  ++v22;
                }
                while ( (int)v22 < (int)dbl_1004F5D0 );
              }
            }
            else
            {
              v16 = *(_WORD **)(v6 + 44);
              v17 = v9 - (_DWORD)v16;
              v18 = 64;
              do
              {
                *v16 = *(_WORD *)((char *)v16 + v17);
                ++v16;
                --v18;
              }
              while ( v18 );
            }
          }
        }
      }
      result = ++v21;
      v5 = (int *)(i + 4);
      v6 += 84;
      if ( v21 >= a1[8] )
        return result;
    }
    v25 = sub_100359F8;
    goto LABEL_19;
  }
  return result;
}

// sub_10030F9F @ 0x10030F9F
_DWORD *__cdecl sub_10030F9F(int a1)
{
  _DWORD *result; // eax
  _DWORD *v3; // ebx
  void *v4; // edi
  _DWORD *v5; // eax
  int v6; // [esp+4h] [ebp-4h]
  int v7; // [esp+10h] [ebp+8h]

  result = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  v6 = 0;
  *(_DWORD *)(a1 + 408) = result;
  *result = sub_10030DE8;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = *(_DWORD *)(a1 + 196) + 80;
    v3 = result + 11;
    do
    {
      v4 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
      v5 = (_DWORD *)v7;
      v7 += 84;
      *v5 = v4;
      memset(v4, 0, 0x100u);
      *v3 = -1;
      result = (_DWORD *)++v6;
      ++v3;
    }
    while ( v6 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10031013 @ 0x10031013
int __cdecl sub_10031013(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  _DWORD *v9; // edi
  unsigned int v10; // eax
  int result; // eax

  v7 = a1;
  v8 = *(_DWORD *)(a1 + 392);
  v9 = a6;
  v10 = a7 - *a6;
  if ( v10 > *(_DWORD *)(v8 + 16) )
    v10 = *(_DWORD *)(v8 + 16);
  a1 = 0;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, int *, unsigned int))(*(_DWORD *)(v7 + 412) + 4))(
    v7,
    a2,
    a3,
    a4,
    *(_DWORD *)(v8 + 12),
    &a1,
    v10);
  (*(void (__cdecl **)(int, _DWORD, int, int))(*(_DWORD *)(v7 + 420) + 4))(v7, *(_DWORD *)(v8 + 12), a5 + 4 * *v9, a1);
  result = a1;
  *v9 += a1;
  return result;
}

// FUN_10031078 @ 0x10031078
// [binja] int32_t sub_10031078(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)
int FUN_10031078(int arg1, int arg2, int arg3, int arg4, int *arg5)
{
  _DWORD *v6; // esi
  unsigned int *v7; // edi
  unsigned int v8; // ecx
  int result; // eax
  unsigned int arg1a; // [esp+14h] [ebp+8h]
  int arg1b; // [esp+14h] [ebp+8h]
  _DWORD *v12; // [esp+28h] [ebp+1Ch]

  v6 = *(_DWORD **)(arg1 + 392);
  v7 = v6 + 6;
  if ( !v6[6] )
    v6[3] = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(arg1 + 4) + 28))(
              arg1,
              v6[2],
              v6[5],
              v6[4],
              1);
  arg1a = *v7;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, _DWORD *, _DWORD))(*(_DWORD *)(arg1 + 412) + 4))(
    arg1,
    arg2,
    arg3,
    arg4,
    v6[3],
    v6 + 6,
    v6[4]);
  v8 = arg1a;
  if ( *v7 > arg1a )
  {
    arg1b = *v7 - arg1a;
    (*(void (__cdecl **)(int, unsigned int, _DWORD, int))(*(_DWORD *)(arg1 + 420) + 4))(arg1, v6[3] + 4 * v8, 0, arg1b);
    *v12 += arg1b;
  }
  result = v6[4];
  if ( *v7 >= result )
  {
    v6[5] += result;
    *v7 = 0;
  }
  return result;
}

// FUN_10031108 @ 0x10031108
// [binja] int32_t sub_10031108(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
int FUN_10031108(void *arg1, int arg2, int *arg3, int arg4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edi
  int result; // eax
  int v7; // [esp+24h] [ebp+18h]
  _DWORD *v8; // [esp+28h] [ebp+1Ch]
  int v9; // [esp+2Ch] [ebp+20h]

  v4 = (_DWORD *)*((_DWORD *)arg1 + 98);
  if ( !v4[6] )
    v4[3] = (*(int (__cdecl **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)arg1 + 1) + 28))(
              arg1,
              v4[2],
              v4[5],
              v4[4],
              0);
  v5 = v4[4] - v4[6];
  if ( v5 > v9 - *v8 )
    v5 = v9 - *v8;
  if ( v5 > *((_DWORD *)arg1 + 24) - v4[5] )
    v5 = *((_DWORD *)arg1 + 24) - v4[5];
  (*(void (__cdecl **)(void *, int, int, unsigned int))(*((_DWORD *)arg1 + 105) + 4))(
    arg1,
    v4[3] + 4 * v4[6],
    v7 + 4 * *v8,
    v5);
  *v8 += v5;
  v4[6] += v5;
  result = v4[4];
  if ( v4[6] >= (unsigned int)result )
  {
    v4[5] += result;
    v4[6] = 0;
  }
  return result;
}

// sub_10031194 @ 0x10031194
int __cdecl sub_10031194(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // esi
  bool v4; // zf

  result = a1;
  v3 = *(_DWORD **)(a1 + 392);
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10031108;
    }
    else if ( a2 == 3 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10031078;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (**(int (__cdecl ***)(int))a1)(a1);
    }
  }
  else if ( *(_BYTE *)(a1 + 74) )
  {
    v4 = v3[3] == 0;
    v3[1] = sub_10031013;
    if ( v4 )
    {
      result = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 4) + 28))(a1, v3[2], 0, v3[4], 1);
      v3[3] = result;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a1 + 412) + 4);
    v3[1] = result;
  }
  v3[6] = 0;
  v3[5] = 0;
  return result;
}

// sub_1003123A @ 0x1003123A
int (__cdecl **__cdecl sub_1003123A(int a1, char a2))(int a1, int a2)
{
  int (__cdecl **result)(int, int); // eax
  int (__cdecl **v3)(int, int); // edi
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v7; // [esp-8h] [ebp-14h]

  result = (int (__cdecl **)(int, int))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  v3 = result;
  *(_DWORD *)(a1 + 392) = result;
  *result = sub_10031194;
  result[2] = 0;
  result[3] = 0;
  if ( *(_BYTE *)(a1 + 74) )
  {
    v4 = *(_DWORD *)(a1 + 272);
    v3[4] = (int (__cdecl *)(int, int))v4;
    if ( a2 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      v7 = v4;
      v6 = sub_10022B93(*(_DWORD *)(a1 + 96), v4);
      result = (int (__cdecl **)(int, int))(*(int (__cdecl **)(int, int, _DWORD, int, int, int))(v5 + 16))(
                                             a1,
                                             1,
                                             0,
                                             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
                                             v6,
                                             v7);
      v3[2] = (int (__cdecl *)(int, int))result;
    }
    else
    {
      result = (int (__cdecl **)(int, int))(*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
                                             a1,
                                             1,
                                             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
                                             v4);
      v3[3] = (int (__cdecl *)(int, int))result;
    }
  }
  return result;
}

// sub_100312BD @ 0x100312BD
int __cdecl sub_100312BD(_DWORD *a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1[103];
  *(_DWORD *)(v1 + 92) = a1[68];
  result = a1[24];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

// FUN_100312d7 @ 0x100312D7
// [binja] int32_t* sub_100312d7(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t arg6)
int *FUN_100312d7(void *arg1, int arg2, int *arg3, int arg4, int *arg5, int arg6)
{
  int v7; // esi
  int v8; // edi
  unsigned int v9; // edi
  int *result; // eax
  int v11; // [esp+Ch] [ebp-4h]
  int arg1a; // [esp+18h] [ebp+8h]
  int v13; // [esp+30h] [ebp+20h]
  unsigned int v14; // [esp+30h] [ebp+20h]

  v7 = *((_DWORD *)arg1 + 103);
  if ( *(_DWORD *)(v7 + 92) >= *((_DWORD *)arg1 + 68) )
  {
    arg1a = 0;
    v11 = *((_DWORD *)arg1 + 49);
    if ( *((int *)arg1 + 8) > 0 )
    {
      v8 = v7 + 12;
      do
      {
        (*(void (__cdecl **)(void *, int, int, int))(v8 + 40))(
          arg1,
          v11,
          *(_DWORD *)(arg2 + 4 * arg1a) + 4 * *arg3 * *(_DWORD *)(v8 + 88),
          v8);
        v11 += 84;
        ++arg1a;
        v8 += 4;
      }
      while ( arg1a < *((_DWORD *)arg1 + 8) );
    }
    *(_DWORD *)(v7 + 92) = 0;
  }
  v9 = *((_DWORD *)arg1 + 68) - *(_DWORD *)(v7 + 92);
  if ( v9 > *(_DWORD *)(v7 + 96) )
    v9 = *(_DWORD *)(v7 + 96);
  v14 = v13 - *(_DWORD *)arg6;
  if ( v9 > v14 )
    v9 = v14;
  (*(void (__cdecl **)(void *, int, _DWORD, int *, unsigned int))(*((_DWORD *)arg1 + 104) + 4))(
    arg1,
    v7 + 12,
    *(_DWORD *)(v7 + 92),
    &arg5[*(_DWORD *)arg6],
    v9);
  result = (int *)arg6;
  *(_DWORD *)arg6 += v9;
  *(_DWORD *)(v7 + 96) -= v9;
  *(_DWORD *)(v7 + 92) += v9;
  if ( *(_DWORD *)(v7 + 92) >= *((_DWORD *)arg1 + 68) )
  {
    ++*arg3;
    return arg3;
  }
  return result;
}

// sub_1003139D @ 0x1003139D
_DWORD *__cdecl sub_1003139D(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = a3;
  return a4;
}

// sub_100313A8 @ 0x100313A8
_DWORD *__cdecl sub_100313A8(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = 0;
  return a4;
}

// sub_100313B0 @ 0x100313B0
const void **__cdecl sub_100313B0(unsigned int *a1, int a2, char **a3, int *a4)
{
  int v4; // ebx
  int v6; // eax
  int v7; // ecx
  const void **result; // eax
  int v9; // edi
  char *v10; // edx
  char *v11; // eax
  unsigned int v12; // ecx
  char v13; // al
  int v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-14h]
  int v16; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]
  int v18; // [esp+1Ch] [ebp-4h]
  char *v19; // [esp+28h] [ebp+8h]
  int v21; // [esp+34h] [ebp+14h]

  v4 = *a4;
  v6 = *(_DWORD *)(a2 + 4) + a1[103];
  v7 = *(unsigned __int8 *)(v6 + 140);
  result = (const void **)*(unsigned __int8 *)(v6 + 150);
  v9 = 0;
  v16 = *a4;
  v21 = v7;
  v18 = (int)result;
  for ( i = 0; v9 < (int)a1[68]; i = v9 )
  {
    v10 = *a3;
    v11 = *(char **)(v4 + 4 * v9);
    v12 = (unsigned int)&v11[a1[23]];
    v19 = v11;
    v15 = v12;
    while ( (unsigned int)v19 < v12 )
    {
      v13 = *v10++;
      if ( v21 > 0 )
      {
        LOBYTE(v4) = v13;
        BYTE1(v4) = v13;
        v14 = v4 << 16;
        LOWORD(v14) = v4;
        v4 = v16;
        memset32(v19, v14, (unsigned int)v21 >> 2);
        memset(&v19[4 * ((unsigned int)v21 >> 2)], v14, v21 & 3);
        v9 = i;
        v12 = v15;
        v19 += v21;
      }
    }
    result = (const void **)v18;
    if ( v18 > 1 )
      result = sub_10022BAB(v4, v9, v4, v9 + 1, v18 - 1, a1[23]);
    v9 += v18;
    ++a3;
  }
  return result;
}

// FUN_1003148d @ 0x1003148D
// [binja] int32_t* sub_1003148d(int32_t* arg1, int32_t arg2, int32_t* arg3)
int *FUN_1003148d(int *arg1, int arg2, int *arg3)
{
  int *result; // eax
  char *v5; // esi
  int *v6; // edx
  _BYTE *v7; // eax
  char *v8; // edi
  unsigned int v9; // ecx
  char v10; // dl
  _BYTE *v11; // eax
  int *arg1a; // [esp+10h] [ebp+8h]
  int *v13; // [esp+1Ch] [ebp+14h]
  int v14; // [esp+1Ch] [ebp+14h]

  result = v13;
  v14 = 0;
  v5 = (char *)*result;
  if ( arg1[68] > 0 )
  {
    v6 = (int *)((char *)arg3 - v5);
    arg1a = (int *)((char *)arg3 - v5);
    do
    {
      v7 = *(_BYTE **)v5;
      v8 = *(char **)&v5[(_DWORD)v6];
      v9 = *(_DWORD *)v5 + arg1[23];
      if ( *(_DWORD *)v5 < v9 )
      {
        do
        {
          v10 = *v8++;
          *v7 = v10;
          v11 = v7 + 1;
          *v11 = v10;
          v7 = v11 + 1;
        }
        while ( (unsigned int)v7 < v9 );
        v6 = arg1a;
      }
      result = (int *)++v14;
      v5 += 4;
    }
    while ( v14 < arg1[68] );
  }
  return result;
}

// FUN_100314e4 @ 0x100314E4
// [binja] int32_t* sub_100314e4(void* arg1, int32_t* arg2, int32_t* arg3)
int *FUN_100314e4(void *arg1, int *arg2, int *arg3)
{
  int *result; // eax
  int v4; // ebx
  int v5; // esi
  char *v6; // edx
  _BYTE *v7; // ecx
  _BYTE *v8; // eax
  char v9; // bl
  _BYTE *v10; // ecx
  int i; // [esp+Ch] [ebp-4h]
  int *v12; // [esp+24h] [ebp+14h]

  result = v12;
  v4 = *v12;
  v5 = 0;
  for ( i = *v12; v5 < *((_DWORD *)arg1 + 68); v5 += 2 )
  {
    v6 = (char *)*arg3;
    v7 = *(_BYTE **)(v4 + 4 * v5);
    v8 = &v7[*((_DWORD *)arg1 + 23)];
    if ( v7 < v8 )
    {
      do
      {
        v9 = *v6++;
        *v7 = v9;
        v10 = v7 + 1;
        *v10 = v9;
        v7 = v10 + 1;
      }
      while ( v7 < v8 );
      v4 = i;
    }
    result = (int *)sub_10022BAB(v4, v5, v4, v5 + 1, 1, *((_DWORD *)arg1 + 23));
    ++arg3;
  }
  return result;
}

// sub_1003154E @ 0x1003154E
int __cdecl sub_1003154E(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v5; // esi
  int result; // eax
  int v7; // ebx
  unsigned __int8 *v8; // eax
  int v9; // edx
  _BYTE *v10; // ecx
  unsigned __int8 *v11; // eax
  _BYTE *v12; // ecx
  int v13; // edi
  int v14; // edx
  _BYTE *v15; // ecx
  int v16; // edx
  int v17; // [esp+4h] [ebp-4h]
  int v18; // [esp+1Ch] [ebp+14h]

  v18 = 0;
  v5 = *a4;
  result = a1;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v7 = a3 - (_DWORD)v5;
    do
    {
      v8 = *(_BYTE **)((char *)v5 + v7);
      v9 = *v8;
      v10 = *v5;
      *v10 = v9;
      v11 = v8 + 1;
      *++v10 = (3 * v9 + *v11 + 2) >> 2;
      v12 = v10 + 1;
      if ( *(_DWORD *)(a2 + 40) != 2 )
      {
        v17 = *(_DWORD *)(a2 + 40) - 2;
        do
        {
          v13 = *v11;
          v14 = *(v11++ - 1);
          v13 *= 3;
          *v12 = (v14 + v13 + 1) >> 2;
          v15 = v12 + 1;
          *v15 = (*v11 + v13 + 2) >> 2;
          v12 = v15 + 1;
          --v17;
        }
        while ( v17 );
      }
      v16 = *v11;
      ++v18;
      *v12 = (*(v11 - 1) + 3 * v16 + 1) >> 2;
      result = a1;
      v12[1] = v16;
      ++v5;
    }
    while ( v18 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_100315F2 @ 0x100315F2
unsigned __int8 **__cdecl sub_100315F2(unsigned __int8 **a1, int a2, unsigned __int8 **a3, int *a4)
{
  unsigned __int8 **result; // eax
  unsigned __int8 *v5; // edx
  unsigned __int8 *v6; // edi
  _BYTE *v7; // esi
  int v8; // ecx
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // edx
  int v11; // eax
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // edx
  _BYTE *v14; // esi
  _BYTE *v15; // esi
  bool v16; // zf
  int v17; // [esp+0h] [ebp-14h]
  int v18; // [esp+4h] [ebp-10h]
  unsigned __int8 **v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+10h] [ebp-4h]
  int v22; // [esp+28h] [ebp+14h]

  v21 = 0;
  v17 = *a4;
  result = a1;
  if ( (int)a1[68] > 0 )
  {
    result = a3;
    v19 = a3;
    do
    {
      v22 = 0;
      do
      {
        v5 = *result;
        if ( v22 )
          v6 = result[1];
        else
          v6 = *(result - 1);
        v7 = *(_BYTE **)(v17 + 4 * v21++);
        v8 = *v6 + 3 * *v5;
        v9 = v6 + 1;
        v10 = v5 + 1;
        v11 = *v9 + 3 * *v10;
        *v7 = (4 * v8 + 8) >> 4;
        v12 = v9 + 1;
        v13 = v10 + 1;
        *++v7 = (v8 + v11 + 2 * v8 + 7) >> 4;
        v14 = v7 + 1;
        v20 = v11;
        if ( *(_DWORD *)(a2 + 40) != 2 )
        {
          v18 = *(_DWORD *)(a2 + 40) - 2;
          do
          {
            v11 = *v12 + 3 * *v13;
            *v14 = (3 * v20 + v8 + 8) >> 4;
            ++v12;
            ++v13;
            v15 = v14 + 1;
            *v15 = (3 * v20 + v11 + 7) >> 4;
            v8 = v20;
            v14 = v15 + 1;
            v16 = v18-- == 1;
            v20 = v11;
          }
          while ( !v16 );
        }
        ++v22;
        *v14 = (v11 + v8 + 2 * v11 + 8) >> 4;
        v14[1] = (4 * v11 + 7) >> 4;
        result = v19;
      }
      while ( v22 < 2 );
      result = ++v19;
    }
    while ( v21 < (int)a1[68] );
  }
  return result;
}

// sub_100316F9 @ 0x100316F9
int __cdecl sub_100316F9(int a1)
{
  int result; // eax
  int v3; // ebx
  _DWORD *v4; // ecx
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // [esp-4h] [ebp-28h]
  _DWORD *v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+18h] [ebp-Ch]
  int v16; // [esp+1Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp-4h]
  bool v18; // [esp+2Fh] [ebp+Bh]

  result = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  v3 = result;
  *(_DWORD *)(a1 + 412) = result;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)result = sub_100312BD;
  *(_DWORD *)(result + 4) = FUN_100312d7;
  v14 = result;
  if ( *(_BYTE *)(a1 + 264) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 23;
    result = (**(int (__cdecl ***)(int))a1)(a1);
  }
  v18 = *(_BYTE *)(a1 + 72) && *(int *)(a1 + 276) > 1;
  v16 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v4 = (_DWORD *)(v3 + 52);
    v5 = *(_DWORD *)(a1 + 196) + 36;
    v13 = (_DWORD *)(v3 + 52);
    do
    {
      v6 = *(_DWORD *)(a1 + 276);
      v15 = *(_DWORD *)v5 * *(_DWORD *)(v5 - 28) / v6;
      v7 = *(_DWORD *)v5 * *(_DWORD *)(v5 - 24) / v6;
      v8 = *(_DWORD *)(a1 + 268);
      v17 = *(_DWORD *)(a1 + 272);
      v4[12] = v7;
      if ( *(_BYTE *)(v5 + 12) )
      {
        if ( v15 != v8 || v7 != v17 )
        {
          if ( 2 * v15 == v8 )
          {
            if ( v7 == v17 )
            {
              if ( v18 && *(_DWORD *)(v5 + 4) > 2u )
                *v4 = sub_1003154E;
              else
                *v4 = FUN_1003148d;
LABEL_30:
              v12 = *(_DWORD *)(a1 + 272);
              v9 = *(_DWORD *)(a1 + 4);
              v10 = sub_10022B93(*(_DWORD *)(a1 + 92), *(_DWORD *)(a1 + 268));
              v11 = (*(int (__cdecl **)(int, int, int, int))(v9 + 8))(a1, 1, v10, v12);
              v4 = v13;
              *(v13 - 10) = v11;
              goto LABEL_31;
            }
            if ( 2 * v15 == v8 && 2 * v7 == v17 )
            {
              if ( v18 && *(_DWORD *)(v5 + 4) > 2u )
              {
                *v4 = sub_100315F2;
                *(_BYTE *)(v14 + 8) = 1;
              }
              else
              {
                *v4 = FUN_100314e4;
              }
              goto LABEL_30;
            }
          }
          if ( v8 % v15 || v17 % v7 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 37;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            *v4 = sub_100313B0;
            *(_BYTE *)(v16 + v14 + 140) = v8 / v15;
            *(_BYTE *)(v16 + v14 + 150) = v17 / v7;
          }
          goto LABEL_30;
        }
        *v4 = sub_1003139D;
      }
      else
      {
        *v4 = sub_100313A8;
      }
LABEL_31:
      result = ++v16;
      ++v4;
      v5 += 84;
      v13 = v4;
    }
    while ( v16 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_100318BA @ 0x100318BA
int __usercall sub_100318BA@<eax>(int a1@<eax>)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // edx
  int i; // ecx
  int v6; // edi
  int v7; // edi
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 416);
  v2[2] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[3] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v4 = 5990656;
  v8 = -14831872;
  v9 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    v6 = v9;
    v9 += 91881;
    *(_DWORD *)(result + v2[2]) = v6 >> 16;
    v7 = v8;
    v8 += 116130;
    *(_DWORD *)(result + v2[3]) = v7 >> 16;
    *(_DWORD *)(result + v2[4]) = v4;
    *(_DWORD *)(result + v2[5]) = i;
    v4 -= 46802;
    result += 4;
  }
  return result;
}

// sub_1003196A @ 0x1003196A
_BYTE *__cdecl sub_1003196A(int a1, int a2, int a3, _DWORD *a4, _BYTE *a5)
{
  int v5; // ebx
  _BYTE *result; // eax
  int v8; // edi
  int i; // esi
  _BYTE *v10; // ecx
  int v11; // [esp+4h] [ebp-8h]
  _BYTE *v12; // [esp+8h] [ebp-4h]
  int v13; // [esp+14h] [ebp+8h]
  int v14; // [esp+24h] [ebp+18h]

  v5 = *(_DWORD *)(a1 + 92);
  result = a5 - 1;
  v13 = *(_DWORD *)(a1 + 32);
  v11 = v5;
  if ( (int)(a5 - 1) >= 0 )
  {
    v8 = 4 * a3;
    result = a5;
    v12 = a5;
    do
    {
      for ( i = 0; i < v13; ++i )
      {
        v10 = *(_BYTE **)(v8 + *(_DWORD *)(a2 + 4 * i));
        result = (_BYTE *)(i + *a4);
        if ( v5 )
        {
          v14 = v5;
          do
          {
            *result = *v10;
            result += v13;
            ++v10;
            --v14;
          }
          while ( v14 );
          v5 = v11;
        }
      }
      v8 += 4;
      ++a4;
      --v12;
    }
    while ( v12 );
  }
  return result;
}

// sub_100319D5 @ 0x100319D5
const void **__cdecl sub_100319D5(int a1, int *a2, int a3, int a4, int a5)
{
  return sub_10022BAB(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 92));
}

// sub_100319F8 @ 0x100319F8
_BYTE *__cdecl sub_100319F8(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edi
  int v7; // ecx
  _BYTE *result; // eax
  int v9; // edx
  _DWORD *v10; // esi
  unsigned __int8 *v11; // ecx
  _BYTE **v12; // eax
  int v13; // ebx
  int v14; // esi
  int v15; // esi
  int v16; // edi
  int v17; // [esp+8h] [ebp-28h]
  int v18; // [esp+Ch] [ebp-24h]
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  int v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h]
  int v24; // [esp+24h] [ebp-Ch]
  int v25; // [esp+24h] [ebp-Ch]
  int v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+2Ch] [ebp-4h]
  int v28; // [esp+2Ch] [ebp-4h]
  int v29; // [esp+38h] [ebp+8h]
  int v30; // [esp+48h] [ebp+18h]
  int v31; // [esp+48h] [ebp+18h]

  v5 = (_DWORD *)a1[104];
  v6 = a1[23];
  v29 = a1[71];
  v21 = v5[2];
  v18 = v5[3];
  v7 = v5[4];
  v20 = v5[5];
  result = (_BYTE *)(a5 - 1);
  v17 = v6;
  v19 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = 4 * a3;
    v10 = a2;
    v26 = a5;
    do
    {
      v30 = *(_DWORD *)(v9 + *v10);
      v11 = *(unsigned __int8 **)(v9 + v10[1]);
      v27 = *(_DWORD *)(v9 + v10[2]);
      v24 = *(_DWORD *)(v9 + v10[3]);
      v12 = a4++;
      result = *v12;
      v9 += 4;
      if ( v6 )
      {
        v13 = v30 - (_DWORD)v11;
        v14 = v27 - (_DWORD)v11;
        v23 = v30 - (_DWORD)v11;
        v22 = v27 - (_DWORD)v11;
        v25 = v24 - (_DWORD)v11;
        v28 = v6;
        while ( 1 )
        {
          v31 = v11[v13];
          v15 = 4 * v11[v14];
          v16 = 4 * *v11;
          *result = *(_BYTE *)(v29 - *(_DWORD *)(v15 + v21) - v31 + 255);
          result += 4;
          *(result - 3) = *(_BYTE *)(v29 - ((*(_DWORD *)(v15 + v19) + *(_DWORD *)(v16 + v20)) >> 16) - v31 + 255);
          *(result - 2) = *(_BYTE *)(v29 - *(_DWORD *)(v16 + v18) - v31 + 255);
          *(result - 1) = (v11++)[v25];
          if ( !--v28 )
            break;
          v13 = v23;
          v14 = v22;
        }
        v6 = v17;
        v10 = a2;
      }
      --v26;
    }
    while ( v26 );
  }
  return result;
}

// sub_10031B2A @ 0x10031B2A
unsigned int *__cdecl sub_10031B2A(unsigned int a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, int a5)
{
  unsigned int *result; // eax
  unsigned int v8; // edi
  __m64 v10; // mm0
  __m64 v11; // mm3
  __m64 v12; // mm4
  __m64 v13; // mm6
  __m64 v14; // mm2
  __m64 v15; // mm5
  __m64 v16; // mm6
  __m64 v17; // mm7
  __m64 v18; // mm1
  __m64 v19; // mm0
  __m64 v20; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm0
  __m64 v23; // mm3
  __m64 v24; // mm2
  __m64 v25; // mm3

  result = a2;
  v8 = a1 >> 2;
  do
  {
    v10 = _m_punpcklbw(_mm_cvtsi32_si64(*result), 0);
    v11 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a4), 0), (__m64)qword_10055840);
    v12 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a3), 0), (__m64)qword_10055840);
    v13 = _m_psllwi(v10, 8u);
    v14 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpcklwd(v12, v11), (__m64)qword_10055848), _m_punpcklwd(v13, 0)), 8u);
    v15 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpckhwd(v12, v11), (__m64)qword_10055848), _m_punpckhwd(v13, 0)), 8u);
    v16 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v11, v10), (__m64)qword_10055850), 8u);
    v17 = _m_pmaddwd(_m_punpckhwd(v12, v10), (__m64)qword_10055858);
    v18 = _m_pmaddwd(_m_punpckhwd(v11, v10), (__m64)qword_10055850);
    v19 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v12, v10), (__m64)qword_10055858), 8u);
    v20 = _m_psradi(v18, 8u);
    v21 = _m_psradi(v17, 8u);
    v22 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v16, v14), _m_punpckldq(v19, (__m64)(unsigned int)qword_1005DBA0)),
            _m_packssdw(_m_punpckhdq(v16, v14), _m_punpckhdq(v19, (__m64)qword_1005DBA0)));
    v23 = _m_psrlqi(_m_pand(v22, (__m64)qword_10055860), 8u);
    a5 += 12;
    v24 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v20, v15), _m_punpckldq(v21, (__m64)(unsigned int)qword_1005DBA0)),
            _m_packssdw(_m_punpckhdq(v20, v15), _m_punpckhdq(v21, (__m64)qword_1005DBA0)));
    ++result;
    *(_DWORD *)(a5 - 12) = _mm_cvtsi64_si32(_m_por(v22, v23));
    v25 = _m_punpcklwd(_m_psrlqi(v23, 0x20u), v24);
    ++a4;
    *(_DWORD *)(a5 - 8) = _mm_cvtsi64_si32(v25);
    ++a3;
    *(_DWORD *)(a5 - 4) = _mm_cvtsi64_si32(_m_por(_m_psrlqi(v24, 0x18u), _m_psrlqi(v25, 0x30u)));
    --v8;
  }
  while ( v8 );
  return result;
}

// sub_10031C66 @ 0x10031C66
unsigned int *__cdecl sub_10031C66(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  unsigned int *result; // eax
  unsigned int v10; // ebx
  int v11; // eax
  unsigned int *v12; // edx
  unsigned int *v13; // edi
  unsigned int *v14; // ecx
  int *v15; // eax
  int v16; // edi
  _BYTE *v17; // edi
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  bool v21; // zf
  _DWORD *v22; // ebx
  int v23; // edx
  unsigned int **v24; // eax
  unsigned __int8 *v25; // ecx
  int v26; // edx
  int v27; // edx
  int v28; // ebx
  unsigned int v29; // [esp+Ch] [ebp-34h]
  int v30; // [esp+Ch] [ebp-34h]
  int v31; // [esp+10h] [ebp-30h]
  int v32; // [esp+10h] [ebp-30h]
  int v33; // [esp+14h] [ebp-2Ch]
  int v34; // [esp+18h] [ebp-28h]
  int v35; // [esp+1Ch] [ebp-24h]
  unsigned int *v36; // [esp+20h] [ebp-20h]
  int v37; // [esp+24h] [ebp-1Ch]
  int v38; // [esp+28h] [ebp-18h]
  unsigned int v39; // [esp+28h] [ebp-18h]
  unsigned int v40; // [esp+2Ch] [ebp-14h]
  int v41; // [esp+2Ch] [ebp-14h]
  unsigned int v42; // [esp+30h] [ebp-10h]
  unsigned int *v43; // [esp+38h] [ebp-8h]
  int v44; // [esp+38h] [ebp-8h]
  int v45; // [esp+38h] [ebp-8h]
  int v46; // [esp+38h] [ebp-8h]
  unsigned int *v47; // [esp+3Ch] [ebp-4h]
  int v48; // [esp+3Ch] [ebp-4h]
  int v49; // [esp+3Ch] [ebp-4h]
  int v50; // [esp+3Ch] [ebp-4h]
  unsigned int *v51; // [esp+48h] [ebp+8h]
  int v52; // [esp+48h] [ebp+8h]
  unsigned __int8 *v53; // [esp+48h] [ebp+8h]

  v5 = (_DWORD *)a1[104];
  v6 = a1[71];
  v7 = a1[23];
  v37 = v5[2];
  v34 = v5[3];
  v8 = v5[4];
  result = (unsigned int *)v5[5];
  v10 = v7 & 0xFFFFFFF8;
  v42 = v7;
  v29 = v7 & 0xFFFFFFF8;
  v35 = v8;
  v36 = result;
  if ( byte_100554E8 )
  {
    if ( a5 - 1 >= 0 )
    {
      v31 = 3 * v10;
      v11 = 4 * a3;
      v38 = a5;
      while ( 1 )
      {
        v12 = *(unsigned int **)(v11 + *a2);
        v13 = *(unsigned int **)(v11 + a2[1]);
        v14 = *(unsigned int **)(v11 + a2[2]);
        v33 = v11 + 4;
        v15 = a4++;
        v51 = v13;
        v16 = *v15;
        v47 = v12;
        v43 = v14;
        result = sub_10031B2A(v10, v12, v51, v14, *v15);
        v17 = (_BYTE *)(v31 + v16);
        if ( v10 < v42 )
        {
          v48 = (char *)v47 - (char *)v51;
          v18 = (char *)v43 - (char *)v51;
          result = (unsigned int *)((char *)v51 + v10);
          v44 = (char *)v43 - (char *)v51;
          v40 = v42 - v10;
          while ( 1 )
          {
            v19 = 4 * *((unsigned __int8 *)result + v18);
            v52 = *((unsigned __int8 *)result + v48);
            v20 = *(unsigned __int8 *)result;
            *v17 = *(_BYTE *)(v52 + *(_DWORD *)(v19 + v37) + v6);
            v17 += 3;
            *(v17 - 2) = *(_BYTE *)(v52 + ((int)(*(_DWORD *)(v19 + v35) + v36[v20]) >> 16) + v6);
            result = (unsigned int *)((char *)result + 1);
            v21 = v40-- == 1;
            *(v17 - 1) = *(_BYTE *)(v52 + *(_DWORD *)(4 * v20 + v34) + v6);
            if ( v21 )
              break;
            v18 = v44;
          }
          v10 = v29;
        }
        if ( !--v38 )
          break;
        v11 = v33;
      }
    }
    _m_empty();
  }
  else
  {
    result = (unsigned int *)(a5 - 1);
    if ( a5 - 1 >= 0 )
    {
      v22 = a2;
      v23 = 4 * a3;
      v41 = a5;
      do
      {
        v49 = *(_DWORD *)(v23 + *v22);
        v53 = *(unsigned __int8 **)(v23 + v22[1]);
        v45 = *(_DWORD *)(v23 + v22[2]);
        v24 = (unsigned int **)a4++;
        result = *v24;
        v23 += 4;
        v32 = v23;
        if ( v7 )
        {
          v25 = v53;
          v50 = v49 - (_DWORD)v53;
          v26 = v45 - (_DWORD)v53;
          v46 = v45 - (_DWORD)v53;
          v39 = v7;
          while ( 1 )
          {
            v27 = v25[v26];
            v28 = v25[v50];
            v30 = *v25;
            *(_BYTE *)result = *(_BYTE *)(v28 + *(_DWORD *)(4 * v27 + v37) + v6);
            result = (unsigned int *)((char *)result + 3);
            *((_BYTE *)result - 2) = *(_BYTE *)(v28 + ((int)(*(_DWORD *)(4 * v27 + v35) + v36[v30]) >> 16) + v6);
            ++v25;
            v21 = v39-- == 1;
            *((_BYTE *)result - 1) = *(_BYTE *)(v28 + *(_DWORD *)(4 * v30 + v34) + v6);
            if ( v21 )
              break;
            v26 = v46;
          }
          v23 = v32;
          v22 = a2;
          v7 = v42;
        }
        --v41;
      }
      while ( v41 );
    }
  }
  return result;
}

// sub_10031E84 @ 0x10031E84
int __cdecl sub_10031E84(int a1)
{
  void (**v1)(); // edi
  int v2; // eax
  bool v3; // zf
  int result; // eax
  bool v5; // zf
  int v6; // eax
  int v7; // ecx

  v1 = (void (**)())(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 416) = v1;
  *v1 = warn_fn;
  v2 = *(_DWORD *)(a1 + 36);
  if ( v2 == 1 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 1;
LABEL_10:
    if ( v3 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( v2 <= 1 )
    goto LABEL_7;
  if ( v2 <= 3 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 3;
    goto LABEL_10;
  }
  if ( v2 <= 5 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 4;
    goto LABEL_10;
  }
LABEL_7:
  if ( *(int *)(a1 + 32) >= 1 )
    goto LABEL_12;
LABEL_11:
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
  (**(void (__cdecl ***)(int))a1)(a1);
LABEL_12:
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    if ( *(_DWORD *)(a1 + 40) == 2 )
    {
      result = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 3;
      if ( result == 3 )
      {
        v1[1] = (void (*)())sub_10031C66;
        goto LABEL_23;
      }
      v5 = result == 2;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 40) != 4 )
      {
        if ( *(_DWORD *)(a1 + 40) == *(_DWORD *)(a1 + 36) )
        {
          result = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 100) = result;
LABEL_26:
          v1[1] = (void (*)())sub_1003196A;
          goto LABEL_32;
        }
LABEL_17:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
        result = (**(int (__cdecl ***)(int))a1)(a1);
        goto LABEL_32;
      }
      result = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 4;
      if ( result == 5 )
      {
        v1[1] = (void (*)())sub_100319F8;
LABEL_23:
        result = sub_100318BA(a1);
        goto LABEL_32;
      }
      v5 = result == 4;
    }
    if ( v5 )
      goto LABEL_26;
    goto LABEL_17;
  }
  v6 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 100) = 1;
  if ( v6 != 1 && v6 != 3 )
    goto LABEL_17;
  v1[1] = (void (*)())sub_100319D5;
  result = 1;
  if ( *(int *)(a1 + 32) > 1 )
  {
    v7 = 84;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 196) + v7 + 48) = 0;
      ++result;
      v7 += 84;
    }
    while ( result < *(_DWORD *)(a1 + 32) );
  }
LABEL_32:
  if ( *(_BYTE *)(a1 + 74) )
  {
    *(_DWORD *)(a1 + 104) = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 104) = result;
  }
  return result;
}

// sub_10031FA5 @ 0x10031FA5
int __usercall sub_10031FA5@<eax>(int a1@<eax>)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // edx
  int i; // ecx
  int v6; // edi
  int v7; // edi
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 412);
  v2[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[6] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[7] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v4 = 5990656;
  v8 = -14831872;
  v9 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    v6 = v9;
    v9 += 91881;
    *(_DWORD *)(result + v2[4]) = v6 >> 16;
    v7 = v8;
    v8 += 116130;
    *(_DWORD *)(result + v2[5]) = v7 >> 16;
    *(_DWORD *)(result + v2[6]) = v4;
    *(_DWORD *)(result + v2[7]) = i;
    v4 -= 46802;
    result += 4;
  }
  return result;
}

// sub_10032055 @ 0x10032055
int __cdecl sub_10032055(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 412);
  *(_BYTE *)(result + 36) = 0;
  *(_DWORD *)(result + 44) = *(_DWORD *)(a1 + 96);
  return result;
}

// sub_1003206A @ 0x1003206A
const void **__cdecl sub_1003206A(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v7; // esi
  _DWORD *v8; // ebx
  unsigned int v9; // edi
  const void **result; // eax
  int *v11; // eax
  int v12; // [esp+Ch] [ebp-8h] BYREF
  int v13; // [esp+10h] [ebp-4h]
  unsigned int v14; // [esp+34h] [ebp+20h]

  v7 = *(_DWORD *)(a1 + 412);
  if ( *(_BYTE *)(v7 + 36) )
  {
    v8 = a6;
    v9 = 1;
    result = sub_10022BAB(v7 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v7 + 40));
    *(_BYTE *)(v7 + 36) = 0;
  }
  else
  {
    v9 = 2;
    if ( *(_DWORD *)(v7 + 44) < 2u )
      v9 = *(_DWORD *)(v7 + 44);
    v8 = a6;
    v14 = a7 - *a6;
    if ( v9 > v14 )
      v9 = v14;
    v11 = (int *)(a5 + 4 * *a6);
    v12 = *v11;
    if ( v9 <= 1 )
    {
      v13 = *(_DWORD *)(v7 + 32);
      *(_BYTE *)(v7 + 36) = 1;
    }
    else
    {
      v13 = v11[1];
    }
    result = (const void **)(*(int (__cdecl **)(int, int, _DWORD, int *))(v7 + 12))(a1, a2, *a3, &v12);
  }
  *v8 += v9;
  *(_DWORD *)(v7 + 44) -= v9;
  if ( !*(_BYTE *)(v7 + 36) )
  {
    ++*a3;
    return (const void **)a3;
  }
  return result;
}

// FUN_10032110 @ 0x10032110
// [binja] int32_t sub_10032110(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5)
int FUN_10032110(void *arg1, int arg2, int *arg3, int arg4, int *arg5)
{
  int result; // eax
  _DWORD *v6; // [esp+24h] [ebp+1Ch]

  result = (*(int (__cdecl **)(void *, int, int, int *))(*((_DWORD *)arg1 + 103) + 12))(arg1, arg2, *arg3, &arg5[*v6]);
  ++*v6;
  ++*arg3;
  return result;
}

// sub_10032141 @ 0x10032141
_BYTE *__cdecl sub_10032141(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4)
{
  _DWORD *v4; // eax
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // esi
  _BYTE *result; // eax
  int v10; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // edx
  unsigned __int8 *v14; // edi
  int v15; // edx
  _BYTE *v16; // eax
  int v17; // edi
  int v18; // ebx
  int v19; // esi
  int v20; // [esp+Ch] [ebp-18h]
  int v21; // [esp+10h] [ebp-14h]
  int v22; // [esp+14h] [ebp-10h]
  int v23; // [esp+18h] [ebp-Ch]
  unsigned __int8 *v24; // [esp+1Ch] [ebp-8h]
  unsigned __int8 *v25; // [esp+20h] [ebp-4h]
  int v26; // [esp+30h] [ebp+Ch]
  int v27; // [esp+34h] [ebp+10h]
  int v28; // [esp+34h] [ebp+10h]
  int v29; // [esp+34h] [ebp+10h]
  int v30; // [esp+38h] [ebp+14h]

  v4 = (_DWORD *)a1[103];
  v5 = a1[71];
  v20 = v4[4];
  v21 = v4[5];
  v23 = v4[7];
  v22 = v4[6];
  v6 = *(unsigned __int8 **)(4 * a3 + *a2);
  v7 = *(unsigned __int8 **)(4 * a3 + a2[1]);
  v8 = *(unsigned __int8 **)(4 * a3 + a2[2]);
  result = *a4;
  if ( a1[23] >> 1 )
  {
    v30 = a1[23] >> 1;
    do
    {
      v10 = *v7;
      v25 = v7 + 1;
      v11 = 4 * *v8;
      v24 = v8 + 1;
      v26 = *(_DWORD *)(v11 + v20);
      v12 = *(_DWORD *)(v11 + v22) + *(_DWORD *)(4 * v10 + v23);
      v27 = *(_DWORD *)(4 * v10 + v21);
      v13 = *v6;
      *result = *(_BYTE *)(v13 + v26 + v5);
      v12 >>= 16;
      result[1] = *(_BYTE *)(v13 + v12 + v5);
      result[2] = *(_BYTE *)(v27 + v13 + v5);
      v14 = v6 + 1;
      v15 = *v14;
      v16 = result + 3;
      *v16 = *(_BYTE *)(v15 + v26 + v5);
      LOBYTE(v10) = *(_BYTE *)(v15 + v12 + v5);
      v8 = v24;
      v16[1] = v10;
      v16[2] = *(_BYTE *)(v27 + v15 + v5);
      v7 = v25;
      v6 = v14 + 1;
      result = v16 + 3;
      --v30;
    }
    while ( v30 );
  }
  if ( (a1[23] & 1) != 0 )
  {
    v17 = *v6;
    v28 = 4 * *v7;
    v18 = 4 * *v8;
    v19 = *(_DWORD *)(v18 + v22) + *(_DWORD *)(v28 + v23);
    v29 = *(_DWORD *)(v28 + v21);
    *result = *(_BYTE *)(v17 + *(_DWORD *)(v18 + v20) + v5);
    result[1] = *(_BYTE *)(v17 + (v19 >> 16) + v5);
    result[2] = *(_BYTE *)(v29 + v17 + v5);
  }
  return result;
}

// sub_10032297 @ 0x10032297
char __cdecl sub_10032297(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ecx
  int v5; // eax
  unsigned __int8 **v6; // edx
  unsigned __int8 *v7; // edi
  int v8; // esi
  int v9; // ecx
  unsigned __int8 *v10; // edx
  unsigned __int8 *v11; // edi
  _BYTE *v12; // ecx
  _BYTE *v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // edi
  int v17; // edx
  int v18; // edx
  _BYTE *v19; // ecx
  int v20; // edx
  int v21; // edx
  _BYTE *v22; // esi
  int v23; // ebx
  int v24; // edx
  int v25; // edi
  int v26; // edx
  int v27; // ecx
  int v29; // [esp+Ch] [ebp-20h]
  int v30; // [esp+10h] [ebp-1Ch]
  int v31; // [esp+14h] [ebp-18h]
  int v32; // [esp+18h] [ebp-14h]
  unsigned __int8 *v33; // [esp+1Ch] [ebp-10h]
  unsigned __int8 *v34; // [esp+20h] [ebp-Ch]
  int v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+28h] [ebp-4h]
  int v37; // [esp+28h] [ebp-4h]
  unsigned __int8 *v38; // [esp+38h] [ebp+Ch]
  unsigned __int8 *v39; // [esp+38h] [ebp+Ch]
  unsigned __int8 *v40; // [esp+3Ch] [ebp+10h]
  unsigned __int8 *v41; // [esp+3Ch] [ebp+10h]
  int v42; // [esp+40h] [ebp+14h]
  int v43; // [esp+40h] [ebp+14h]

  v4 = (_DWORD *)a1[103];
  v5 = a1[71];
  v32 = v4[4];
  v29 = v4[5];
  v30 = v4[6];
  v31 = v4[7];
  v6 = (unsigned __int8 **)(*a2 + 8 * a3);
  v7 = *v6;
  v8 = 4 * a3;
  v40 = v6[1];
  v9 = a2[2];
  v10 = *(unsigned __int8 **)(v8 + a2[1]);
  v38 = v7;
  v11 = *(unsigned __int8 **)(v8 + v9);
  v12 = *(_BYTE **)a4;
  v13 = *(_BYTE **)(a4 + 4);
  if ( a1[23] >> 1 )
  {
    v35 = a1[23] >> 1;
    do
    {
      v14 = *v10;
      v34 = v10 + 1;
      v15 = 4 * *v11;
      v33 = v11 + 1;
      v42 = *(_DWORD *)(v15 + v32);
      v16 = *(_DWORD *)(v15 + v30) + *(_DWORD *)(4 * v14 + v31);
      v36 = *(_DWORD *)(4 * v14 + v29);
      v17 = *v38;
      *v12 = *(_BYTE *)(v17 + v42 + v5);
      v16 >>= 16;
      v39 = v38 + 1;
      v12[1] = *(_BYTE *)(v17 + v16 + v5);
      v12[2] = *(_BYTE *)(v36 + v17 + v5);
      v18 = *v39;
      v19 = v12 + 3;
      *v19 = *(_BYTE *)(v18 + v42 + v5);
      v19[1] = *(_BYTE *)(v18 + v16 + v5);
      v19[2] = *(_BYTE *)(v36 + v18 + v5);
      v20 = *v40;
      v38 = v39 + 1;
      *v13 = *(_BYTE *)(v20 + v42 + v5);
      v13[1] = *(_BYTE *)(v20 + v16 + v5);
      v13[2] = *(_BYTE *)(v36 + v20 + v5);
      v12 = v19 + 3;
      v41 = v40 + 1;
      v21 = *v41;
      v22 = v13 + 3;
      v40 = v41 + 1;
      *v22 = *(_BYTE *)(v21 + v42 + v5);
      v22[1] = *(_BYTE *)(v21 + v16 + v5);
      v22[2] = *(_BYTE *)(v36 + v21 + v5);
      v11 = v33;
      v10 = v34;
      v13 = v22 + 3;
      --v35;
    }
    while ( v35 );
  }
  if ( (a1[23] & 1) != 0 )
  {
    v23 = *v10;
    v24 = 4 * *v11;
    v43 = *(_DWORD *)(v24 + v32);
    v25 = *(_DWORD *)(v24 + v30) + *(_DWORD *)(4 * v23 + v31);
    v37 = *(_DWORD *)(4 * v23 + v29);
    v26 = *v38;
    *v12 = *(_BYTE *)(v26 + v43 + v5);
    v25 >>= 16;
    v12[1] = *(_BYTE *)(v26 + v25 + v5);
    v12[2] = *(_BYTE *)(v37 + v26 + v5);
    v27 = *v40;
    *v13 = *(_BYTE *)(v27 + v43 + v5);
    v13[1] = *(_BYTE *)(v27 + v25 + v5);
    LOBYTE(v5) = *(_BYTE *)(v37 + v27 + v5);
    v13[2] = v5;
  }
  return v5;
}

// sub_1003247D @ 0x1003247D
int __cdecl sub_1003247D(int a1)
{
  int v1; // esi
  int v3; // [esp-4h] [ebp-Ch]

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 412) = v1;
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)v1 = sub_10032055;
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100);
  if ( *(_DWORD *)(a1 + 272) == 2 )
  {
    v3 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = sub_1003206A;
    *(_DWORD *)(v1 + 12) = sub_10032297;
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v3);
  }
  else
  {
    *(_DWORD *)(v1 + 32) = 0;
    *(_DWORD *)(v1 + 4) = FUN_10032110;
    *(_DWORD *)(v1 + 12) = sub_10032141;
  }
  return sub_10031FA5(a1);
}

// FUN_100324f2 @ 0x100324F2
// [binja] int16_t* sub_100324f2(int16_t* arg1, int16_t* arg2, int32_t arg3)
__int16 *FUN_100324f2(__int16 *arg1, __int16 *arg2, int arg3)
{
  __int16 *result; // eax
  __int16 *v4; // ebx
  int v5; // esi
  int i; // edi
  unsigned __int8 *v7; // ecx
  __int16 *arg1a; // [esp+14h] [ebp+8h]
  int v9; // [esp+20h] [ebp+14h]

  result = arg1;
  v4 = (__int16 *)*((_DWORD *)arg1 + 23);
  v5 = *(_DWORD *)(*((_DWORD *)arg1 + 105) + 24);
  for ( i = 0; i < v9; ++i )
  {
    result = arg2;
    v7 = *(unsigned __int8 **)&arg2[2 * i];
    if ( v4 )
    {
      arg1a = v4;
      do
      {
        result = (__int16 *)(*(_DWORD *)(v5 + 4 * (*v7 >> 3)) + 2 * ((v7[2] >> 3) + 32 * (v7[1] >> 2)));
        if ( !++*result )
          *result = -1;
        v7 += 3;
        arg1a = (__int16 *)((char *)arg1a - 1);
      }
      while ( arg1a );
    }
  }
  return result;
}

// sub_1003255E @ 0x1003255E
int __usercall sub_1003255E@<eax>(int a1@<eax>, int *a2@<esi>)
{
  int v2; // ecx
  int v3; // edi
  int v4; // eax
  int v6; // ecx
  int v7; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  _WORD *v12; // eax
  int v14; // ecx
  int v15; // edx
  _WORD *v16; // eax
  _WORD *v18; // eax
  int v19; // edx
  _WORD *v20; // eax
  int v21; // edx
  int v22; // edx
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v27; // [esp+8h] [ebp-28h]
  int v28; // [esp+Ch] [ebp-24h]
  int v29; // [esp+10h] [ebp-20h]
  _WORD *v30; // [esp+14h] [ebp-1Ch]
  _WORD *v31; // [esp+14h] [ebp-1Ch]
  int v32; // [esp+14h] [ebp-1Ch]
  int v33; // [esp+14h] [ebp-1Ch]
  _WORD *v34; // [esp+14h] [ebp-1Ch]
  int v35; // [esp+18h] [ebp-18h]
  int v36; // [esp+18h] [ebp-18h]
  int v37; // [esp+1Ch] [ebp-14h]
  int v38; // [esp+20h] [ebp-10h]
  int v39; // [esp+24h] [ebp-Ch]
  int v40; // [esp+28h] [ebp-8h]
  int v41; // [esp+28h] [ebp-8h]
  int v42; // [esp+28h] [ebp-8h]
  int v43; // [esp+28h] [ebp-8h]
  int v44; // [esp+28h] [ebp-8h]
  int v45; // [esp+2Ch] [ebp-4h]
  int v46; // [esp+2Ch] [ebp-4h]
  int v47; // [esp+2Ch] [ebp-4h]
  int v48; // [esp+2Ch] [ebp-4h]
  int v49; // [esp+2Ch] [ebp-4h]
  int v50; // [esp+2Ch] [ebp-4h]

  v2 = *a2;
  v29 = a2[3];
  v28 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v3 = a2[2];
  v39 = a2[4];
  v35 = *a2;
  v38 = a2[1];
  v27 = v3;
  v37 = a2[5];
  if ( *a2 < v38 )
  {
    while ( 1 )
    {
      v40 = a2[2];
      if ( v3 <= v29 )
        break;
LABEL_8:
      if ( ++v2 > v38 )
        goto LABEL_11;
    }
    v4 = *(_DWORD *)(v28 + 4 * v2) + 2 * (v39 + 32 * v3);
    while ( 1 )
    {
      v45 = a2[4];
      v30 = (_WORD *)v4;
      if ( v39 <= v37 )
        break;
LABEL_7:
      ++v40;
      v4 += 64;
      if ( v40 > v29 )
        goto LABEL_8;
    }
    while ( !*v30++ )
    {
      if ( ++v45 > v37 )
        goto LABEL_7;
    }
    v35 = v2;
    *a2 = v2;
LABEL_11:
    v6 = v38;
    if ( v38 > v35 )
    {
      while ( 1 )
      {
        v41 = v3;
        if ( v3 <= v29 )
          break;
LABEL_18:
        if ( --v6 < v35 )
          goto LABEL_21;
      }
      v7 = *(_DWORD *)(v28 + 4 * v6) + 2 * (v39 + 32 * v3);
      while ( 1 )
      {
        v46 = v39;
        v31 = (_WORD *)v7;
        if ( v39 <= v37 )
          break;
LABEL_17:
        ++v41;
        v7 += 64;
        if ( v41 > v29 )
          goto LABEL_18;
      }
      while ( !*v31++ )
      {
        if ( ++v46 > v37 )
          goto LABEL_17;
      }
      v38 = v6;
      a2[1] = v6;
    }
  }
LABEL_21:
  v9 = v29;
  if ( v3 < v29 )
  {
    v42 = v3;
    v10 = 2 * (v39 + 32 * v3);
    while ( 1 )
    {
      v11 = v35;
      if ( v35 <= v38 )
        break;
LABEL_29:
      ++v42;
      v10 += 64;
      if ( v42 > v29 )
        goto LABEL_32;
    }
    while ( 1 )
    {
      v12 = (_WORD *)(v10 + *(_DWORD *)(v28 + 4 * v11));
      v47 = v39;
      if ( v39 <= v37 )
        break;
LABEL_27:
      if ( ++v11 > v38 )
      {
        v3 = v27;
        goto LABEL_29;
      }
    }
    while ( !*v12++ )
    {
      if ( ++v47 > v37 )
        goto LABEL_27;
    }
    v3 = v42;
    v27 = v42;
    a2[2] = v42;
LABEL_32:
    v9 = v29;
    if ( v29 > v3 )
    {
      v43 = v29;
      v14 = 2 * (v39 + 32 * v29);
      while ( 1 )
      {
        v15 = v35;
        if ( v35 <= v38 )
          break;
LABEL_40:
        --v43;
        v14 -= 64;
        if ( v43 < v3 )
        {
          v9 = v29;
          goto LABEL_43;
        }
      }
      while ( 1 )
      {
        v16 = (_WORD *)(v14 + *(_DWORD *)(v28 + 4 * v15));
        v48 = v39;
        if ( v39 <= v37 )
          break;
LABEL_38:
        if ( ++v15 > v38 )
        {
          v3 = v27;
          goto LABEL_40;
        }
      }
      while ( !*v16++ )
      {
        if ( ++v48 > v37 )
          goto LABEL_38;
      }
      v3 = v27;
      v9 = v43;
      v29 = v43;
      a2[3] = v43;
    }
  }
LABEL_43:
  if ( v39 < v37 )
  {
    v49 = v39;
    while ( 1 )
    {
      v32 = v35;
      if ( v35 <= v38 )
        break;
LABEL_50:
      if ( ++v49 > v37 )
        goto LABEL_53;
    }
    while ( 1 )
    {
      v18 = (_WORD *)(2 * (v49 + 32 * v3) + *(_DWORD *)(v28 + 4 * v32));
      v19 = v3;
      if ( v3 <= v9 )
        break;
LABEL_49:
      if ( ++v32 > v38 )
        goto LABEL_50;
    }
    while ( !*v18 )
    {
      ++v19;
      v18 += 32;
      if ( v19 > v9 )
        goto LABEL_49;
    }
    v39 = v49;
    a2[4] = v49;
LABEL_53:
    if ( v37 > v39 )
    {
      v50 = v37;
      while ( 1 )
      {
        v33 = v35;
        if ( v35 <= v38 )
          break;
LABEL_60:
        if ( --v50 < v39 )
          goto LABEL_63;
      }
      while ( 1 )
      {
        v20 = (_WORD *)(2 * (v50 + 32 * v3) + *(_DWORD *)(v28 + 4 * v33));
        v21 = v3;
        if ( v3 <= v9 )
          break;
LABEL_59:
        if ( ++v33 > v38 )
          goto LABEL_60;
      }
      while ( !*v20 )
      {
        ++v21;
        v20 += 32;
        if ( v21 > v9 )
          goto LABEL_59;
      }
      v37 = v50;
      a2[5] = v50;
    }
  }
LABEL_63:
  v22 = v9 - v3;
  v44 = 0;
  v23 = v35;
  a2[6] = 16 * (v38 - v35) * 16 * (v38 - v35) + 12 * (v9 - v3) * 12 * (v9 - v3) + 8 * (v37 - v39) * 8 * (v37 - v39);
  while ( v23 <= v38 )
  {
    if ( v27 <= v29 )
    {
      v24 = *(_DWORD *)(v28 + 4 * v23) + 2 * (v39 + 32 * v27);
      v25 = v22 + 1;
      do
      {
        v34 = (_WORD *)v24;
        if ( v39 <= v37 )
        {
          v36 = v37 - v39 + 1;
          do
          {
            if ( *v34 )
              ++v44;
            ++v34;
            --v36;
          }
          while ( v36 );
        }
        v24 += 64;
        --v25;
      }
      while ( v25 );
    }
    ++v23;
  }
  a2[7] = v44;
  return v44;
}

// sub_10032896 @ 0x10032896
int __cdecl sub_10032896(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // ecx
  _DWORD *v6; // edi
  int *v7; // esi
  int v8; // ebx
  int *v9; // ecx
  int *v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // [esp+0h] [ebp-8h]
  int v18; // [esp+0h] [ebp-8h]
  int v19; // [esp+4h] [ebp-4h]

  result = a3;
  v5 = a2;
  if ( a3 < a4 )
  {
    v19 = 2 * a3;
    v6 = (_DWORD *)(32 * a3 + a2 + 12);
    while ( 1 )
    {
      v7 = 0;
      v8 = 0;
      if ( v19 > a4 )
      {
        if ( v19 > 0 )
        {
          v10 = (int *)(v5 + 24);
          v18 = result;
          do
          {
            if ( *v10 > v8 )
            {
              v7 = v10 - 6;
              v8 = *v10;
            }
            v10 += 8;
            --v18;
          }
          while ( v18 );
        }
      }
      else if ( v19 > 0 )
      {
        v9 = (int *)(v5 + 28);
        v17 = result;
        do
        {
          if ( *v9 > v8 && *(v9 - 1) > 0 )
          {
            v7 = v9 - 7;
            v8 = *v9;
          }
          v9 += 8;
          --v17;
        }
        while ( v17 );
      }
      if ( !v7 )
        break;
      *(v6 - 2) = v7[1];
      *v6 = v7[3];
      v6[2] = v7[5];
      *(v6 - 3) = *v7;
      *(v6 - 1) = v7[2];
      v6[1] = v7[4];
      v11 = 12 * (v7[3] - v7[2]);
      v12 = 1;
      if ( 16 * (v7[1] - *v7) > v11 )
      {
        v11 = 16 * (v7[1] - *v7);
        v12 = 0;
      }
      if ( 8 * (v7[5] - v7[4]) > v11 )
        v12 = 2;
      if ( v12 )
      {
        v13 = v12 - 1;
        if ( v13 )
        {
          if ( v13 == 1 )
          {
            v14 = (v7[4] + v7[5]) / 2;
            v7[5] = v14;
            v6[1] = v14 + 1;
          }
        }
        else
        {
          v15 = (v7[2] + v7[3]) / 2;
          v7[3] = v15;
          *(v6 - 1) = v15 + 1;
        }
      }
      else
      {
        v16 = (*v7 + v7[1]) / 2;
        v7[1] = v16;
        *(v6 - 3) = v16 + 1;
      }
      sub_1003255E(a1, v7);
      sub_1003255E(a1, v6 - 3);
      v19 += 2;
      result = a3 + 1;
      v6 += 8;
      if ( ++a3 >= a4 )
        break;
      v5 = a2;
    }
  }
  return result;
}

// sub_100329E9 @ 0x100329E9
int __usercall sub_100329E9@<eax>(int *a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int result; // eax
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  int v21; // [esp+3Ch] [ebp-Ch]
  int v22; // [esp+40h] [ebp-8h]
  unsigned __int16 *v23; // [esp+44h] [ebp-4h]

  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v3 = a1[5];
  v11 = a1[1];
  v4 = a1[2];
  v14 = a1[3];
  v5 = a1[4];
  v6 = *a1;
  v7 = a3;
  if ( v6 <= v11 )
  {
    v19 = 8 * v6 + 4;
    do
    {
      if ( v4 <= v14 )
      {
        v20 = 4 * v4 + 2;
        v21 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 420) + 24) + 4 * v6) + 2 * (v5 + 32 * v4);
        v8 = v14 - v4 + 1;
        v12 = v8;
        do
        {
          v23 = (unsigned __int16 *)v21;
          if ( v5 <= v3 )
          {
            v22 = 8 * v5 + 4;
            v13 = v3 - v5 + 1;
            do
            {
              v9 = *v23++;
              if ( v9 )
              {
                v18 += v9;
                v16 += v9 * v20;
                v17 += v9 * v19;
                v15 += v9 * v22;
              }
              v22 += 8;
              --v13;
            }
            while ( v13 );
            v8 = v12;
          }
          v21 += 64;
          v20 += 4;
          v12 = --v8;
        }
        while ( v8 );
        v7 = a3;
      }
      v19 += 8;
      ++v6;
    }
    while ( v6 <= v11 );
  }
  *(_BYTE *)(v7 + **(_DWORD **)(a2 + 116)) = ((v18 >> 1) + v17) / v18;
  *(_BYTE *)(v7 + *(_DWORD *)(*(_DWORD *)(a2 + 116) + 4)) = ((v18 >> 1) + v16) / v18;
  result = ((v18 >> 1) + v15) / v18;
  *(_BYTE *)(v7 + *(_DWORD *)(*(_DWORD *)(a2 + 116) + 8)) = result;
  return result;
}

// sub_10032B21 @ 0x10032B21
int __usercall sub_10032B21@<eax>(int a1@<edi>, int a2)
{
  int *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  int *v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+14h] [ebp+8h]

  v2 = (int *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32 * a2);
  v2[1] = 31;
  v2[5] = 31;
  *v2 = 0;
  v2[2] = 0;
  v2[3] = 63;
  v2[4] = 0;
  sub_1003255E(a1, v2);
  v3 = sub_10032896(a1, (int)v2, 1, a2);
  v8 = 0;
  v4 = v3;
  if ( v3 > 0 )
  {
    v7 = v2;
    do
    {
      sub_100329E9(v7, a1, v8++);
      v7 += 8;
    }
    while ( v8 < v4 );
  }
  v5 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 112) = v4;
  *(_DWORD *)(v5 + 20) = 95;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
}

// sub_10032BAE @ 0x10032BAE
int __usercall sub_10032BAE@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ebx
  int *v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // esi
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  bool v24; // cc
  int v25; // ecx
  int result; // eax
  _DWORD v27[256]; // [esp+8h] [ebp-428h]
  int v28; // [esp+408h] [ebp-28h]
  int v29; // [esp+40Ch] [ebp-24h]
  int v30; // [esp+410h] [ebp-20h]
  int v31; // [esp+414h] [ebp-1Ch]
  int v32; // [esp+418h] [ebp-18h]
  int v33; // [esp+41Ch] [ebp-14h]
  int v34; // [esp+420h] [ebp-10h]
  int v35; // [esp+424h] [ebp-Ch]
  int v36; // [esp+428h] [ebp-8h]
  int v37; // [esp+42Ch] [ebp-4h]

  v5 = a3;
  v37 = 0;
  v32 = (2 * a3 + 24) >> 1;
  v6 = a4;
  v30 = (2 * a2 + 28) >> 1;
  v35 = *(_DWORD *)(a1 + 112);
  v29 = (2 * a4 + 24) >> 1;
  v36 = 0x7FFFFFFF;
  if ( v35 > 0 )
  {
    v7 = *(int **)(a1 + 116);
    v28 = *v7;
    v8 = v7[1];
    v9 = v7[2];
    v34 = v8;
    v33 = v9;
    do
    {
      v10 = *(unsigned __int8 *)(v28 + v37);
      v11 = v5 + 24;
      if ( v10 >= v5 )
      {
        if ( v10 > v11 )
        {
          v12 = 2 * (v10 - v11) * 2 * (v10 - v11);
LABEL_7:
          v13 = v10 - v5;
          goto LABEL_8;
        }
        v12 = 0;
        if ( v10 > v32 )
          goto LABEL_7;
      }
      else
      {
        v12 = 2 * (v10 - v5) * 2 * (v10 - v5);
      }
      v13 = v10 - v11;
LABEL_8:
      v14 = 2 * v13 * 2 * v13;
      v15 = *(unsigned __int8 *)(v34 + v37);
      if ( v15 < a2 )
      {
        v12 += 3 * (v15 - a2) * 3 * (v15 - a2);
        v6 = a4;
        v16 = v15 - (a2 + 28);
        goto LABEL_15;
      }
      if ( v15 > a2 + 28 )
      {
        v12 += 3 * (v15 - (a2 + 28)) * 3 * (v15 - (a2 + 28));
        v6 = a4;
LABEL_14:
        v16 = v15 - a2;
        goto LABEL_15;
      }
      if ( v15 > v30 )
        goto LABEL_14;
      v16 = v15 - (a2 + 28);
LABEL_15:
      v17 = 3 * v16 * 3 * v16 + v14;
      v18 = *(unsigned __int8 *)(v33 + v37);
      if ( v18 < v6 )
      {
        v12 += (v18 - v6) * (v18 - v6);
        v6 = a4;
        v19 = a4 + 24;
LABEL_31:
        v20 = v18 - v19;
        goto LABEL_22;
      }
      v19 = v6 + 24;
      v31 = v6 + 24;
      if ( v18 <= v6 + 24 )
      {
        if ( v18 <= v29 )
          goto LABEL_31;
      }
      else
      {
        v12 += (v18 - v31) * (v18 - v31);
        v6 = a4;
      }
      v20 = v18 - v6;
LABEL_22:
      v21 = v20 * v20;
      v22 = v37;
      v23 = v21 + v17;
      v24 = v23 < v36;
      v5 = a3;
      v27[v37] = v12;
      if ( v24 )
        v36 = v23;
      v37 = v22 + 1;
    }
    while ( v22 + 1 < v35 );
  }
  v25 = 0;
  for ( result = 0; v25 < v35; ++v25 )
  {
    if ( v27[v25] <= v36 )
    {
      *(_BYTE *)(result + a5) = v25;
      ++result;
    }
  }
  return result;
}

// sub_10032D2E @ 0x10032D2E
int __cdecl sub_10032D2E(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7)
{
  int result; // eax
  int v8; // ebx
  _DWORD *v9; // edx
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // ecx
  _DWORD v17[128]; // [esp+4h] [ebp-228h] BYREF
  int v18; // [esp+204h] [ebp-28h]
  int v19; // [esp+208h] [ebp-24h]
  int v20; // [esp+20Ch] [ebp-20h]
  _BYTE *v21; // [esp+210h] [ebp-1Ch]
  int v22; // [esp+214h] [ebp-18h]
  int v23; // [esp+218h] [ebp-14h]
  int *v24; // [esp+21Ch] [ebp-10h]
  int v25; // [esp+220h] [ebp-Ch]
  int v26; // [esp+224h] [ebp-8h]
  int v27; // [esp+228h] [ebp-4h]

  v26 = 0;
  result = 0x7FFFFFFF;
  memset32(v17, 0x7FFFFFFF, 0x80u);
  if ( a5 > 0 )
  {
    do
    {
      v8 = *(unsigned __int8 *)(v26 + a6);
      v9 = *(_DWORD **)(a1 + 116);
      v10 = a2 - *(unsigned __int8 *)(v8 + *v9);
      v11 = 3 * (a3 - *(unsigned __int8 *)(v9[1] + v8));
      v12 = a4 - *(unsigned __int8 *)(v9[2] + v8);
      v10 *= 2;
      v13 = v10 * v10 + v11 * v11 + v12 * v12;
      v14 = 8 * (3 * v11 + 18);
      v15 = 16 * (v12 + 4);
      v24 = v17;
      v21 = a7;
      v27 = 32 * (v10 + 8);
      v19 = 4;
      do
      {
        v22 = v13;
        v25 = v14;
        v18 = 8;
        do
        {
          v16 = v22;
          v23 = v15;
          v20 = 4;
          do
          {
            if ( v16 < *v24 )
            {
              *v24 = v16;
              *v21 = v8;
            }
            v16 += v23;
            v23 += 128;
            ++v24;
            ++v21;
            --v20;
          }
          while ( v20 );
          v22 += v25;
          v25 += 288;
          --v18;
        }
        while ( v18 );
        v13 += v27;
        v27 += 512;
        --v19;
      }
      while ( v19 );
      result = ++v26;
    }
    while ( v26 < a5 );
  }
  return result;
}

// sub_10032E48 @ 0x10032E48
_WORD *__usercall sub_10032E48@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  unsigned __int8 *v6; // edx
  _DWORD *v7; // ecx
  int v8; // ebx
  _WORD *result; // eax
  int v10; // edi
  _BYTE v11[256]; // [esp+Ch] [ebp-188h] BYREF
  _BYTE v12[128]; // [esp+10Ch] [ebp-88h] BYREF
  int v13; // [esp+18Ch] [ebp-8h]
  int v14; // [esp+190h] [ebp-4h]
  int v15; // [esp+19Ch] [ebp+8h]
  int v16; // [esp+1A0h] [ebp+Ch]
  int v17; // [esp+1A0h] [ebp+Ch]
  int v18; // [esp+1A4h] [ebp+10h]
  int v19; // [esp+1A4h] [ebp+10h]

  v18 = a4 >> 2;
  v16 = a3 >> 2;
  v14 = *(_DWORD *)(*(_DWORD *)(a2 + 420) + 24);
  v4 = a1 >> 3;
  v13 = 32 * v18 + 4;
  v5 = sub_10032BAE(a2, 32 * (a1 >> 3) + 2, 32 * v16 + 4, v13, (int)v11);
  sub_10032D2E(a2, 32 * v16 + 4, 32 * v4 + 2, v13, v5, (int)v11, v12);
  v6 = v12;
  v15 = 2 * (4 * v18 + (v4 << 8));
  v7 = (_DWORD *)(v14 + 16 * v16);
  v17 = 4;
  do
  {
    v8 = v15;
    v19 = 8;
    do
    {
      result = (_WORD *)(v8 + *v7);
      v10 = 4;
      do
      {
        *result++ = *v6++ + 1;
        --v10;
      }
      while ( v10 );
      v8 += 64;
      --v19;
    }
    while ( v19 );
    ++v7;
    --v17;
  }
  while ( v17 );
  return result;
}

// sub_10032F18 @ 0x10032F18
int __cdecl sub_10032F18(int a1, int a2, _DWORD *a3, int a4)
{
  int result; // eax
  int v5; // ecx
  unsigned __int8 *v6; // esi
  int v7; // ecx
  unsigned __int8 *v8; // esi
  int v9; // eax
  int v10; // edx
  _WORD *v11; // edi
  _BYTE *v12; // ecx
  bool v13; // zf
  int v14; // [esp+4h] [ebp-14h]
  int v15; // [esp+8h] [ebp-10h]
  int v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  _DWORD *v18; // [esp+14h] [ebp-4h]
  _BYTE *v19; // [esp+2Ch] [ebp+14h]

  result = a1;
  v15 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v5 = *(_DWORD *)(a1 + 92);
  v14 = v5;
  if ( a4 > 0 )
  {
    result = a2 - (_DWORD)a3;
    v18 = a3;
    v16 = a4;
    do
    {
      v6 = *(unsigned __int8 **)((char *)v18 + result);
      v19 = (_BYTE *)*v18;
      if ( v5 )
      {
        v17 = v5;
        do
        {
          v7 = *v6 >> 3;
          v8 = v6 + 1;
          v9 = *v8++ >> 2;
          v10 = *v8 >> 3;
          v11 = (_WORD *)(*(_DWORD *)(v15 + 4 * v7) + 2 * (v10 + 32 * v9));
          v6 = v8 + 1;
          if ( !*v11 )
            sub_10032E48(v9, a1, v7, v10);
          v12 = v19++;
          v13 = v17-- == 1;
          *v12 = *(_BYTE *)v11 - 1;
        }
        while ( !v13 );
        v5 = v14;
        result = a2 - (_DWORD)a3;
      }
      ++v18;
      --v16;
    }
    while ( v16 );
  }
  return result;
}

// sub_10032FC1 @ 0x10032FC1
__int16 __cdecl sub_10032FC1(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int *v6; // eax
  int v7; // esi
  __int16 result; // ax
  int v9; // esi
  unsigned __int8 *v10; // eax
  _BYTE *v11; // esi
  _WORD *v12; // esi
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ebx
  _WORD *v17; // eax
  int v18; // eax
  int v19; // edi
  int v20; // ebx
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  int v24; // ecx
  int v25; // ebx
  __int16 v26; // dx
  int v27; // ecx
  int v28; // eax
  __int16 v29; // dx
  bool v30; // zf
  int v31; // [esp+4h] [ebp-68h]
  int v32; // [esp+Ch] [ebp-60h]
  int v33; // [esp+10h] [ebp-5Ch]
  int v34; // [esp+14h] [ebp-58h]
  _WORD *v35; // [esp+18h] [ebp-54h]
  int v36; // [esp+20h] [ebp-4Ch]
  int v37; // [esp+28h] [ebp-44h]
  int v38; // [esp+2Ch] [ebp-40h]
  int v39; // [esp+30h] [ebp-3Ch]
  int v40; // [esp+34h] [ebp-38h]
  __int16 v41; // [esp+38h] [ebp-34h]
  __int16 v42; // [esp+3Ch] [ebp-30h]
  __int16 v43; // [esp+40h] [ebp-2Ch]
  int v44; // [esp+44h] [ebp-28h]
  _DWORD *v45; // [esp+48h] [ebp-24h]
  __int16 v46; // [esp+4Ch] [ebp-20h]
  __int16 v47; // [esp+50h] [ebp-1Ch]
  __int16 v48; // [esp+54h] [ebp-18h]
  int v49; // [esp+58h] [ebp-14h]
  _BYTE *v50; // [esp+5Ch] [ebp-10h]
  int v51; // [esp+64h] [ebp-8h]
  int v52; // [esp+68h] [ebp-4h]
  int v53; // [esp+80h] [ebp+14h]
  int v54; // [esp+80h] [ebp+14h]
  __int16 v55; // [esp+80h] [ebp+14h]
  __int16 v56; // [esp+80h] [ebp+14h]
  __int16 v57; // [esp+80h] [ebp+14h]

  v4 = a1[105];
  v49 = a1[71];
  v36 = *(_DWORD *)(v4 + 24);
  v5 = a1[23];
  v6 = (int *)a1[29];
  v44 = *(_DWORD *)(v4 + 40);
  v34 = *v6;
  v7 = v6[1];
  v32 = v6[2];
  result = a4;
  v31 = v4;
  v38 = v5;
  v33 = v7;
  if ( a4 > 0 )
  {
    v9 = a2 - (_DWORD)a3;
    v45 = a3;
    v37 = a4;
    while ( 1 )
    {
      v10 = *(unsigned __int8 **)((char *)v45 + v9);
      v11 = (_BYTE *)*v45;
      v51 = (int)v10;
      v50 = (_BYTE *)*v45;
      if ( *(_BYTE *)(v4 + 36) )
      {
        v40 = -1;
        *(_BYTE *)(v4 + 36) = 0;
        v51 = (int)&v10[2 * v5 - 3 + v5];
        v50 = &v11[v5 - 1];
        v12 = (_WORD *)(*(_DWORD *)(v4 + 32) + 2 * (3 * v5 + 3));
        v10 = (unsigned __int8 *)v51;
        v52 = -3;
      }
      else
      {
        v12 = *(_WORD **)(v4 + 32);
        v40 = 1;
        v52 = 3;
        *(_BYTE *)(v4 + 36) = 1;
      }
      v5 = v38;
      v13 = 0;
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v14 = 0;
      v53 = 0;
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( v38 )
      {
        v39 = v38;
        while ( 1 )
        {
          v15 = *(unsigned __int8 *)(*v10 + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52] + v14 + 8) >> 4)) + v49);
          v16 = *(unsigned __int8 *)(v10[1] + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52 + 1] + v13 + 8) >> 4)) + v49);
          v54 = *(unsigned __int8 *)(v10[2] + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52 + 2] + v53 + 8) >> 4)) + v49);
          v17 = (_WORD *)(*(_DWORD *)(v36 + 4 * (v15 >> 3)) + 2 * ((v54 >> 3) + 32 * (v16 >> 2)));
          v35 = v17;
          if ( !*v17 )
          {
            sub_10032E48(v16 >> 2, (int)a1, v15 >> 3, v54 >> 3);
            v17 = v35;
          }
          v18 = (unsigned __int16)*v17 - 1;
          *v50 = v18;
          v19 = v15 - *(unsigned __int8 *)(v18 + v34);
          v20 = v16 - *(unsigned __int8 *)(v18 + v33);
          v21 = v54 - *(unsigned __int8 *)(v18 + v32);
          v55 = v19;
          v22 = 2 * v19;
          v19 *= 3;
          *v12 = v19 + v48;
          v23 = v22 + v19;
          v48 = v23 + v43;
          v43 = v55;
          v14 = v22 + v23;
          v56 = v20;
          v24 = 2 * v20;
          v20 *= 3;
          v12[1] = v20 + v47;
          v25 = v24 + v20;
          v47 = v25 + v42;
          v26 = v56;
          v57 = v21;
          v42 = v26;
          v13 = v24 + v25;
          v27 = 2 * v21;
          v21 *= 3;
          v12[2] = v21 + v46;
          v12 += v52;
          v28 = v27 + v21;
          v46 = v28 + v41;
          v29 = v57;
          v53 = v27 + v28;
          v51 += v52;
          v50 += v40;
          v30 = v39-- == 1;
          v41 = v29;
          if ( v30 )
            break;
          v10 = (unsigned __int8 *)v51;
        }
        v4 = v31;
        v5 = v38;
      }
      ++v45;
      v30 = v37-- == 1;
      *v12 = v48;
      v12[1] = v47;
      result = v46;
      v12[2] = v46;
      if ( v30 )
        break;
      v9 = a2 - (_DWORD)a3;
    }
  }
  return result;
}

// sub_1003322F @ 0x1003322F
int __usercall sub_1003322F@<eax>(int a1@<eax>)
{
  int v1; // esi
  int result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edi
  _DWORD *v6; // esi
  _DWORD *v7; // esi
  _DWORD *v8; // esi

  v1 = *(_DWORD *)(a1 + 420);
  result = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020;
  *(_DWORD *)(v1 + 40) = result;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = (_DWORD *)result;
  do
  {
    *(_DWORD *)(result + 4 * v4) = v3;
    *v6 = v5;
    ++v4;
    --v6;
    ++v3;
    --v5;
  }
  while ( v4 < 16 );
  if ( v4 < 48 )
  {
    v7 = (_DWORD *)(result - 4 * v4);
    do
    {
      *(_DWORD *)(result + 4 * v4) = v3;
      *v7 = -v3;
      ++v4;
      --v7;
      v3 += (v4 & 1) == 0;
    }
    while ( v4 < 48 );
  }
  if ( v4 <= 255 )
  {
    v8 = (_DWORD *)(result - 4 * v4);
    do
    {
      *(_DWORD *)(result + 4 * v4) = v3;
      *v8 = -v3;
      ++v4;
      --v8;
    }
    while ( v4 <= 255 );
  }
  return result;
}

// sub_100332BF @ 0x100332BF
int __cdecl sub_100332BF(int a1)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 420);
  *(_DWORD *)(a1 + 116) = *(_DWORD *)(v1 + 16);
  result = sub_10032B21(a1, *(_DWORD *)(v1 + 20));
  *(_BYTE *)(v1 + 28) = 1;
  return result;
}

// sub_100332E1 @ 0x100332E1
int __cdecl sub_100332E1(_DWORD *a1, char a2)
{
  bool v3; // zf
  int v4; // edi
  int result; // eax
  int v6; // ebx
  unsigned int v7; // ebx
  int i; // esi
  int v9; // [esp+10h] [ebp+8h]

  v3 = a1[19] == 0;
  v4 = a1[105];
  result = *(_DWORD *)(v4 + 24);
  v9 = result;
  if ( !v3 )
    a1[19] = 2;
  if ( a2 )
  {
    *(_DWORD *)(v4 + 4) = FUN_100324f2;
    *(_DWORD *)(v4 + 8) = sub_100332BF;
    *(_BYTE *)(v4 + 28) = 1;
  }
  else
  {
    if ( a1[19] == 2 )
      *(_DWORD *)(v4 + 4) = sub_10032FC1;
    else
      *(_DWORD *)(v4 + 4) = sub_10032F18;
    *(_DWORD *)(v4 + 8) = warn_fn;
    v6 = a1[28];
    if ( v6 < 1 )
    {
      *(_DWORD *)(*a1 + 20) = 55;
      *(_DWORD *)(*a1 + 24) = 1;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    result = 256;
    if ( v6 > 256 )
    {
      *(_DWORD *)(*a1 + 20) = 56;
      *(_DWORD *)(*a1 + 24) = 256;
      result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( a1[19] == 2 )
    {
      v7 = 6 * (a1[23] + 2);
      if ( !*(_DWORD *)(v4 + 32) )
        *(_DWORD *)(v4 + 32) = (*(int (__cdecl **)(_DWORD *, int, unsigned int))(a1[1] + 4))(a1, 1, v7);
      result = memzero(*(void **)(v4 + 32), v7);
      if ( !*(_DWORD *)(v4 + 40) )
        result = sub_1003322F((int)a1);
      *(_BYTE *)(v4 + 36) = 0;
    }
  }
  if ( *(_BYTE *)(v4 + 28) )
  {
    for ( i = 0; i < 32; ++i )
      result = memzero(*(void **)(v9 + 4 * i), 0x1000u);
    *(_BYTE *)(v4 + 28) = 0;
  }
  return result;
}

// sub_100333E3 @ 0x100333E3
int __cdecl sub_100333E3(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 420);
  *(_BYTE *)(result + 28) = 1;
  return result;
}

// sub_100333F2 @ 0x100333F2
int __cdecl sub_100333F2(int a1)
{
  int v1; // edi
  int v2; // ebp
  int result; // eax
  int v4; // ebp

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 420) = v1;
  v2 = 0;
  *(_DWORD *)v1 = sub_100332E1;
  *(_DWORD *)(v1 + 12) = sub_100333E3;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v1 + 24) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  do
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 4096);
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + v2) = result;
    v2 += 4;
  }
  while ( v2 < 128 );
  *(_BYTE *)(v1 + 28) = 1;
  if ( *(_BYTE *)(a1 + 90) )
  {
    v4 = *(_DWORD *)(a1 + 84);
    if ( v4 < 8 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 55;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( v4 > 256 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    result = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, v4, 3);
    *(_DWORD *)(v1 + 16) = result;
    *(_DWORD *)(v1 + 20) = v4;
  }
  else
  {
    *(_DWORD *)(v1 + 16) = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
    *(_DWORD *)(a1 + 76) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                             a1,
                             1,
                             6 * (*(_DWORD *)(a1 + 92) + 2));
    return sub_1003322F(a1);
  }
  return result;
}

// sub_10033505 @ 0x10033505
int __cdecl sub_10033505(_DWORD *a1, char *a2)
{
  _DWORD *v2; // esi
  signed int v3; // ebx
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  signed int v8; // edx
  int v9; // eax
  int *v10; // ecx
  int v11; // edi
  int v12; // eax
  int v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+10h] [ebp-Ch]
  signed int v16; // [esp+14h] [ebp-8h]
  char v17; // [esp+1Bh] [ebp-1h]

  v2 = a1;
  v3 = a1[25];
  v14 = a1[21];
  v4 = 1;
  do
  {
    v5 = ++v4;
    if ( v3 > 1 )
    {
      v6 = v3 - 1;
      do
      {
        v5 *= v4;
        --v6;
      }
      while ( v6 );
    }
  }
  while ( v5 <= a1[21] );
  v7 = v4 - 1;
  if ( v7 < 2 )
  {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = v5;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v15 = 1;
  if ( v3 > 0 )
  {
    v8 = v3;
    memset32(a2, v7, v3);
    do
    {
      --v8;
      v15 *= v7;
    }
    while ( v8 );
  }
  while ( 1 )
  {
    v17 = 0;
    v16 = 0;
    if ( v3 <= 0 )
      break;
    while ( 1 )
    {
      v9 = v16;
      if ( v2[10] == 2 )
        v9 = dword_1004F6D0[v16];
      v10 = (int *)&a2[4 * v9];
      v11 = *v10 + 1;
      v12 = v11 * (v15 / *v10);
      if ( v12 > v14 )
        break;
      ++v16;
      *v10 = v11;
      v15 = v12;
      v17 = 1;
      if ( v16 >= v3 )
        break;
      v2 = a1;
    }
    if ( !v17 )
      break;
    v2 = a1;
  }
  return v15;
}

// sub_100335D0 @ 0x100335D0
int __usercall sub_100335D0@<eax>(_DWORD *a1@<esi>)
{
  int v1; // ebx
  int v2; // eax
  int *v3; // eax
  int result; // eax
  int v5; // ecx
  int v6; // edi
  int i; // edx
  int v8; // eax
  int v9; // [esp+8h] [ebp-34h]
  int v10; // [esp+14h] [ebp-28h]
  int v11; // [esp+18h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-20h]
  _DWORD *v13; // [esp+20h] [ebp-1Ch]
  int *v14; // [esp+24h] [ebp-18h]
  int v15; // [esp+28h] [ebp-14h]
  int v16; // [esp+2Ch] [ebp-10h]
  int v17; // [esp+34h] [ebp-8h]
  int j; // [esp+38h] [ebp-4h]

  v10 = a1[105];
  v1 = sub_10033505(a1, (char *)(v10 + 32));
  v2 = *a1;
  if ( a1[25] == 3 )
  {
    v3 = (int *)(v2 + 24);
    *v3 = v1;
    v3[1] = *(_DWORD *)(v10 + 32);
    v3[2] = *(_DWORD *)(v10 + 36);
    v3[3] = *(_DWORD *)(v10 + 40);
    *(_DWORD *)(*a1 + 20) = 93;
  }
  else
  {
    *(_DWORD *)(v2 + 20) = 94;
    *(_DWORD *)(*a1 + 24) = v1;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  result = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v1, a1[25]);
  v12 = 0;
  v9 = result;
  v15 = v1;
  if ( (int)a1[25] > 0 )
  {
    v13 = (_DWORD *)result;
    v14 = (int *)(v10 + 32);
    do
    {
      v5 = *v14;
      v6 = 0;
      v17 = v15 / *v14;
      if ( *v14 > 0 )
      {
        v16 = 0;
        v11 = *v14;
        do
        {
          for ( i = v16; i < v1; i += v15 )
          {
            for ( j = 0; j < v17; *(_BYTE *)(v8 + i) = (v6 + (v5 - 1) / 2) / (v5 - 1) )
            {
              v8 = j + *v13;
              ++j;
            }
          }
          v16 += v17;
          v6 += 255;
          --v11;
        }
        while ( v11 );
      }
      ++v12;
      ++v14;
      ++v13;
      v15 = v17;
    }
    while ( v12 < a1[25] );
    result = v9;
  }
  *(_DWORD *)(v10 + 20) = v1;
  *(_DWORD *)(v10 + 16) = result;
  return result;
}

// sub_100336FD @ 0x100336FD
int __cdecl sub_100336FD(_DWORD *a1)
{
  int v1; // esi
  int v2; // ebx
  int result; // eax
  int v4; // ecx
  _BYTE *v5; // edi
  int v6; // edx
  int i; // eax
  int v8; // ebx
  int v9; // edx
  _BYTE *v10; // ecx
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int *v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]

  v1 = a1[105];
  if ( a1[19] == 1 )
  {
    v14 = 510;
    *(_BYTE *)(v1 + 28) = 1;
  }
  else
  {
    v14 = 0;
    *(_BYTE *)(v1 + 28) = 0;
  }
  v2 = 0;
  *(_DWORD *)(v1 + 24) = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v14 + 256, a1[25]);
  result = *(_DWORD *)(v1 + 20);
  v11 = 0;
  if ( (int)a1[25] > 0 )
  {
    v13 = (int *)(v1 + 32);
    while ( 1 )
    {
      v4 = *v13;
      v12 = result / *v13;
      if ( v14 )
        *(_DWORD *)(*(_DWORD *)(v1 + 24) + 4 * v2) += 255;
      v5 = *(_BYTE **)(*(_DWORD *)(v1 + 24) + 4 * v2);
      v15 = 0;
      v16 = 0;
      v6 = (v4 + 254) / (2 * v4 - 2);
      do
      {
        if ( v16 > v6 )
        {
          for ( i = 510 * v15; ; i += 510 )
          {
            ++v15;
            v6 = (i + 510 + v4 + 254) / (2 * v4 - 2);
            if ( v16 <= v6 )
              break;
          }
        }
        v8 = v16++;
        v5[v8] = v12 * v15;
      }
      while ( v16 <= 255 );
      if ( v14 )
      {
        v9 = 1;
        v10 = v5 - 1;
        do
        {
          *v10 = *v5;
          v5[v9++ + 255] = v5[255];
          --v10;
        }
        while ( v9 <= 255 );
      }
      result = (int)a1;
      ++v13;
      v2 = ++v11;
      if ( v11 >= a1[25] )
        break;
      result = v12;
    }
  }
  return result;
}

// sub_10033828 @ 0x10033828
void __usercall sub_10033828(int a1@<edi>)
{
  int v1; // edx
  int *v2; // ecx
  int v3; // esi
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // ebx
  int *v8; // ecx
  int i; // esi
  int v10; // eax
  int v11; // [esp+0h] [ebp-14h]
  int v12; // [esp+4h] [ebp-10h]
  int *v13; // [esp+8h] [ebp-Ch]
  double *v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 420);
  v15 = 0;
  v11 = v1;
  if ( *(int *)(a1 + 100) > 0 )
  {
    v2 = (int *)(v1 + 52);
    v13 = (int *)(v1 + 52);
    do
    {
      v3 = *(v2 - 5);
      v4 = 0;
      if ( v15 <= 0 )
        goto LABEL_9;
      v5 = (_DWORD *)(v1 + 32);
      while ( v3 != *v5 )
      {
        ++v4;
        ++v5;
        if ( v4 >= v15 )
          goto LABEL_9;
      }
      v6 = *(_DWORD *)(v1 + 4 * v4 + 52);
      if ( !v6 )
      {
LABEL_9:
        v12 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
        v7 = (v3 << 9) - 512;
        v14 = dbl_1004F5D0;
        v8 = (int *)v12;
        do
        {
          for ( i = 0; i < 16; ++i )
          {
            v10 = (65025 - 510 * *((unsigned __int8 *)v14 + i)) / v7;
            *v8++ = v10;
          }
          v14 += 2;
        }
        while ( (int)v14 < (int)dword_1004F6D0 );
        v6 = v12;
        v1 = v11;
        v2 = v13;
      }
      ++v15;
      *v2++ = v6;
      v13 = v2;
    }
    while ( v15 < *(_DWORD *)(a1 + 100) );
  }
}

// sub_100338ED @ 0x100338ED
int __cdecl sub_100338ED(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // esi
  int result; // eax
  _DWORD *v6; // ecx
  unsigned __int8 *v7; // edx
  int v8; // esi
  _BYTE *v9; // esi
  bool v10; // zf
  int v11; // [esp+4h] [ebp-14h]
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]
  char v16; // [esp+20h] [ebp+8h]
  _BYTE *v17; // [esp+2Ch] [ebp+14h]

  v4 = a1[23];
  result = a1[25];
  v13 = *(_DWORD *)(a1[105] + 24);
  v11 = v4;
  v12 = result;
  if ( a4 > 0 )
  {
    v6 = a3;
    v14 = a4;
    do
    {
      v7 = *(unsigned __int8 **)((char *)v6 + a2 - (_DWORD)a3);
      v17 = (_BYTE *)*v6;
      if ( v4 )
      {
        v15 = v4;
        do
        {
          v16 = 0;
          v8 = 0;
          if ( result > 0 )
          {
            do
            {
              v16 += *(_BYTE *)(*(_DWORD *)(v13 + 4 * v8) + *v7);
              result = v12;
              ++v7;
              ++v8;
            }
            while ( v8 < v12 );
          }
          v9 = v17++;
          v10 = v15-- == 1;
          *v9 = v16;
        }
        while ( !v10 );
        v4 = v11;
      }
      ++v6;
      --v14;
    }
    while ( v14 );
  }
  return result;
}

// sub_10033975 @ 0x10033975
int __cdecl sub_10033975(int a1, int a2, _DWORD *a3, int a4)
{
  int *v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // edx
  _DWORD *v8; // edi
  unsigned __int8 *v9; // ecx
  _BYTE *v10; // esi
  char v11; // dl
  unsigned __int8 *v12; // ecx
  char v13; // dl
  char v14; // al
  int v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+8h]

  v4 = *(int **)(*(_DWORD *)(a1 + 420) + 24);
  v18 = *v4;
  v5 = v4[1];
  result = v4[2];
  v17 = v5;
  v7 = *(_DWORD *)(a1 + 92);
  v16 = result;
  v15 = v7;
  if ( a4 > 0 )
  {
    v8 = a3;
    result = a2 - (_DWORD)a3;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v8 + result);
      v10 = (_BYTE *)*v8;
      if ( v7 )
      {
        v19 = v7;
        do
        {
          v11 = *(_BYTE *)(*v9 + v18);
          v12 = v9 + 1;
          v13 = *(_BYTE *)(*v12++ + v17) + v11;
          v14 = *(_BYTE *)(*v12 + v16);
          v9 = v12 + 1;
          *v10++ = v14 + v13;
          --v19;
        }
        while ( v19 );
        v7 = v15;
        result = a2 - (_DWORD)a3;
      }
      ++v8;
      --a4;
    }
    while ( a4 );
  }
  return result;
}

// sub_10033A02 @ 0x10033A02
int __cdecl sub_10033A02(_DWORD *a1, int a2, void **a3, int a4)
{
  _DWORD *v4; // esi
  int result; // eax
  void **v6; // ebx
  int v7; // edi
  int v8; // eax
  _BYTE *v9; // edi
  unsigned __int8 *v10; // eax
  int v11; // ecx
  int v12; // edx
  bool v13; // zf
  char v14; // [esp+4h] [ebp-2Ch]
  int v15; // [esp+Ch] [ebp-24h]
  int v16; // [esp+10h] [ebp-20h]
  _DWORD *v17; // [esp+14h] [ebp-1Ch]
  int v18; // [esp+18h] [ebp-18h]
  void **v19; // [esp+1Ch] [ebp-14h]
  unsigned int v20; // [esp+20h] [ebp-10h]
  unsigned int v21; // [esp+24h] [ebp-Ch]
  int v22; // [esp+28h] [ebp-8h]
  _DWORD *v23; // [esp+2Ch] [ebp-4h]
  int v24; // [esp+38h] [ebp+8h]
  int v25; // [esp+44h] [ebp+14h]

  v4 = (_DWORD *)a1[105];
  v21 = a1[23];
  result = a4;
  v22 = a1[25];
  if ( a4 > 0 )
  {
    v6 = a3;
    v7 = a2 - (_DWORD)a3;
    v19 = a3;
    v18 = a4;
    do
    {
      memzero(*v6, v21);
      v8 = v4[12];
      v24 = 0;
      v14 = v8;
      if ( v22 > 0 )
      {
        v16 = v8 << 6;
        v17 = (void **)((char *)v6 + v7);
        v23 = v4 + 13;
        do
        {
          v25 = 0;
          v9 = *v6;
          v10 = (unsigned __int8 *)(v24 + *v17);
          v15 = *(_DWORD *)(v4[6] + 4 * v24);
          v11 = v16 + *v23;
          if ( v21 )
          {
            v20 = v21;
            do
            {
              v12 = *v10;
              v10 += v22;
              *v9++ += *(_BYTE *)(v12 + *(_DWORD *)(v11 + 4 * v25) + v15);
              v13 = v20-- == 1;
              v25 = ((_BYTE)v25 + 1) & 0xF;
            }
            while ( !v13 );
            v6 = v19;
          }
          ++v24;
          ++v23;
        }
        while ( v24 < v22 );
        v7 = a2 - (_DWORD)a3;
        LOBYTE(v8) = v14;
      }
      result = ((_BYTE)v8 + 1) & 0xF;
      ++v6;
      v13 = v18-- == 1;
      v4[12] = result;
      v19 = v6;
    }
    while ( !v13 );
  }
  return result;
}

// sub_10033AED @ 0x10033AED
_DWORD *__cdecl sub_10033AED(int a1, int a2, _BYTE **a3, int a4)
{
  _DWORD *result; // eax
  int *v5; // ecx
  int v6; // edx
  unsigned __int8 *v7; // ecx
  int v8; // edx
  int v9; // esi
  unsigned __int8 *v10; // ecx
  bool v11; // zf
  int v12; // [esp+4h] [ebp-30h]
  int v13; // [esp+8h] [ebp-2Ch]
  int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  int v17; // [esp+18h] [ebp-1Ch]
  int v18; // [esp+1Ch] [ebp-18h]
  int v19; // [esp+24h] [ebp-10h]
  int v20; // [esp+28h] [ebp-Ch]
  _BYTE **v21; // [esp+2Ch] [ebp-8h]
  _BYTE *v22; // [esp+30h] [ebp-4h]
  int v23; // [esp+3Ch] [ebp+8h]
  char v24; // [esp+48h] [ebp+14h]
  char v25; // [esp+48h] [ebp+14h]

  result = *(_DWORD **)(a1 + 420);
  v5 = (int *)result[6];
  v16 = *v5;
  v13 = v5[2];
  v18 = *(_DWORD *)(a1 + 92);
  v15 = v5[1];
  if ( a4 > 0 )
  {
    v6 = a2 - (_DWORD)a3;
    v21 = a3;
    v19 = a4;
    while ( 1 )
    {
      v7 = *(_BYTE **)((char *)v21 + v6);
      v23 = 0;
      v12 = result[12];
      v22 = *v21;
      v8 = (v12 << 6) + result[14];
      v9 = (v12 << 6) + result[13];
      v17 = v8;
      v14 = (v12 << 6) + result[15];
      if ( v18 )
      {
        v20 = v18;
        while ( 1 )
        {
          v24 = *(_BYTE *)(*v7 + *(_DWORD *)(v9 + 4 * v23) + v16);
          v10 = v7 + 1;
          v25 = *(_BYTE *)(*v10++ + *(_DWORD *)(v8 + 4 * v23) + v15) + v24;
          *v22 = *(_BYTE *)(*v10 + *(_DWORD *)(v14 + 4 * v23) + v13) + v25;
          v7 = v10 + 1;
          ++v22;
          v11 = v20-- == 1;
          v23 = ((_BYTE)v23 + 1) & 0xF;
          if ( v11 )
            break;
          v8 = v17;
        }
      }
      ++v21;
      v11 = v19-- == 1;
      result[12] = ((_BYTE)v12 + 1) & 0xF;
      if ( v11 )
        break;
      v6 = a2 - (_DWORD)a3;
    }
  }
  return result;
}

// sub_10033BEC @ 0x10033BEC
char __cdecl sub_10033BEC(_DWORD *a1, int a2, void **a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v7; // esi
  unsigned __int8 *v8; // edi
  _BYTE *v9; // esi
  _WORD *v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // edx
  bool v14; // zf
  int v16; // [esp+8h] [ebp-40h]
  int v17; // [esp+10h] [ebp-38h]
  int v18; // [esp+14h] [ebp-34h]
  int v19; // [esp+18h] [ebp-30h]
  int v20; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v21; // [esp+20h] [ebp-28h]
  int v22; // [esp+24h] [ebp-24h]
  unsigned int v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+2Ch] [ebp-1Ch]
  __int16 v25; // [esp+30h] [ebp-18h]
  __int16 v26; // [esp+34h] [ebp-14h]
  int v27; // [esp+38h] [ebp-10h]
  unsigned int v28; // [esp+3Ch] [ebp-Ch]
  _DWORD *v29; // [esp+40h] [ebp-8h]
  int v30; // [esp+44h] [ebp-4h]
  int v31; // [esp+50h] [ebp+8h]
  void **v32; // [esp+5Ch] [ebp+14h]

  v30 = a1[25];
  v4 = a1[105];
  v5 = a1[71];
  v28 = a1[23];
  v16 = v4;
  v20 = v5;
  if ( a4 > 0 )
  {
    v7 = a2 - (_DWORD)a3;
    v32 = a3;
    v22 = a4;
    do
    {
      memzero(*v32, v28);
      v31 = 0;
      if ( v30 > 0 )
      {
        v21 = (void **)((char *)v32 + v7);
        v29 = (_DWORD *)(v4 + 68);
        do
        {
          v8 = (unsigned __int8 *)(v31 + *v21);
          v9 = *v32;
          if ( *(_BYTE *)(v4 + 84) )
          {
            v27 = -1;
            v9 += v28 - 1;
            v8 += v30 * (v28 - 1);
            v24 = -v30;
            v10 = (_WORD *)(*v29 + 2 * v28 + 2);
          }
          else
          {
            v24 = v30;
            v10 = (_WORD *)*v29;
            v27 = 1;
          }
          v19 = *(_DWORD *)(4 * v31 + *(_DWORD *)(v4 + 24));
          v18 = *(_DWORD *)(4 * v31 + *(_DWORD *)(v4 + 16));
          v11 = 0;
          v26 = 0;
          v25 = 0;
          if ( v28 )
          {
            v23 = v28;
            do
            {
              v12 = *(unsigned __int8 *)(*v8 + (((__int16)v10[v27] + v11 + 8) >> 4) + v20);
              v13 = *(unsigned __int8 *)(v12 + v19);
              *v9 += v13;
              v8 += v24;
              v9 += v27;
              v17 = v12 - *(unsigned __int8 *)(v13 + v18);
              *v10 = 3 * v17 + v26;
              v26 = 5 * v17 + v25;
              v11 = 7 * v17;
              v14 = v23-- == 1;
              v25 = v17;
              v10 += v27;
            }
            while ( !v14 );
            v4 = v16;
          }
          ++v31;
          ++v29;
          *v10 = v26;
        }
        while ( v31 < v30 );
        v7 = a2 - (_DWORD)a3;
      }
      LOBYTE(v5) = *(_BYTE *)(v4 + 84) == 0;
      ++v32;
      v14 = v22-- == 1;
      *(_BYTE *)(v4 + 84) = v5;
    }
    while ( !v14 );
  }
  return v5;
}

// sub_10033D70 @ 0x10033D70
int __usercall sub_10033D70@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax
  int v2; // edi
  int v3; // ebp
  int *v4; // ebx

  result = a1[105];
  v2 = 0;
  v3 = 2 * a1[23] + 4;
  if ( (int)a1[25] > 0 )
  {
    v4 = (int *)(result + 68);
    do
    {
      result = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v3);
      *v4 = result;
      ++v2;
      ++v4;
    }
    while ( v2 < a1[25] );
  }
  return result;
}

// sub_10033DA6 @ 0x10033DA6
void __cdecl sub_10033DA6(_DWORD *a1)
{
  int v1; // edi
  int v2; // eax
  int v3; // eax
  void **v4; // ebx
  bool v5; // zf
  int v6; // edi
  unsigned int i; // ebp

  v1 = a1[105];
  a1[29] = *(_DWORD *)(v1 + 16);
  a1[28] = *(_DWORD *)(v1 + 20);
  v2 = a1[19];
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        *(_BYTE *)(v1 + 84) = 0;
        v4 = (void **)(v1 + 68);
        v5 = *(_DWORD *)(v1 + 68) == 0;
        *(_DWORD *)(v1 + 4) = sub_10033BEC;
        if ( v5 )
          sub_10033D70(a1);
        v6 = 0;
        for ( i = 2 * a1[23] + 4; v6 < a1[25]; ++v4 )
        {
          memzero(*v4, i);
          ++v6;
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 47;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      if ( a1[25] == 3 )
        *(_DWORD *)(v1 + 4) = sub_10033AED;
      else
        *(_DWORD *)(v1 + 4) = sub_10033A02;
      v5 = *(_BYTE *)(v1 + 28) == 0;
      *(_DWORD *)(v1 + 48) = 0;
      if ( v5 )
        sub_100336FD(a1);
      if ( !*(_DWORD *)(v1 + 52) )
        sub_10033828((int)a1);
    }
  }
  else if ( a1[25] == 3 )
  {
    *(_DWORD *)(v1 + 4) = sub_10033975;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_100338ED;
  }
}

// sub_10033E70 @ 0x10033E70
int __cdecl sub_10033E70(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_10033E84 @ 0x10033E84
int __cdecl sub_10033E84(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 88);
  a1[105] = v1;
  v1[17] = 0;
  v1[13] = 0;
  *v1 = sub_10033DA6;
  v1[2] = warn_fn;
  v1[3] = sub_10033E70;
  if ( (int)a1[25] > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[21] > 256 )
  {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  sub_100335D0(a1);
  result = sub_100336FD(a1);
  if ( a1[19] == 2 )
    return sub_10033D70(a1);
  return result;
}

// inflate_blocks_reset @ 0x10033F0B
// zlib (internal): reset inflate blocks state
void inflate_blocks_reset(void *s, void *z, unsigned int *c)
{
  int v3; // eax
  int (__cdecl *v4)(_DWORD, _DWORD, _DWORD); // eax
  int v5; // eax

  if ( c )
    *c = *((_DWORD *)s + 15);
  if ( *(_DWORD *)s == 4 || *(_DWORD *)s == 5 )
    (*((void (__cdecl **)(_DWORD, _DWORD))z + 9))(*((_DWORD *)z + 10), *((_DWORD *)s + 3));
  if ( *(_DWORD *)s == 6 )
    inflate_codes_free(*((void **)s + 1), z);
  v3 = *((_DWORD *)s + 10);
  *((_DWORD *)s + 13) = v3;
  *((_DWORD *)s + 12) = v3;
  v4 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))*((_DWORD *)s + 14);
  *(_DWORD *)s = 0;
  *((_DWORD *)s + 7) = 0;
  *((_DWORD *)s + 8) = 0;
  if ( v4 )
  {
    v5 = v4(0, 0, 0);
    *((_DWORD *)s + 15) = v5;
    *((_DWORD *)z + 12) = v5;
  }
}

// inflate_blocks_new @ 0x10033F76
// zlib (internal): allocate inflate blocks state
void *inflate_blocks_new(void *z, void *check_func, unsigned int w)
{
  _DWORD *v3; // edi
  int v4; // eax
  int v6; // eax

  v3 = (_DWORD *)(*((int (__cdecl **)(_DWORD, int, int))z + 8))(*((_DWORD *)z + 10), 1, 64);
  if ( !v3 )
    return 0;
  v4 = (*((int (__cdecl **)(_DWORD, int, int))z + 8))(*((_DWORD *)z + 10), 8, 1440);
  v3[9] = v4;
  if ( !v4 )
  {
    (*((void (__cdecl **)(_DWORD, _DWORD *))z + 9))(*((_DWORD *)z + 10), v3);
    return 0;
  }
  v6 = (*((int (__cdecl **)(_DWORD, int, unsigned int))z + 8))(*((_DWORD *)z + 10), 1, w);
  v3[10] = v6;
  if ( v6 )
  {
    *v3 = 0;
    v3[11] = w + v6;
    v3[14] = check_func;
    inflate_blocks_reset(v3, z, 0);
    return v3;
  }
  else
  {
    (*((void (__cdecl **)(_DWORD, _DWORD))z + 9))(*((_DWORD *)z + 10), v3[9]);
    (*((void (__cdecl **)(_DWORD, _DWORD *))z + 9))(*((_DWORD *)z + 10), v3);
    return 0;
  }
}

// inflate_blocks @ 0x10034003
// zlib (internal): process inflate blocks
int inflate_blocks(void *s, void *z, int r)
{
  unsigned int v4; // ecx
  _DWORD *v5; // esi
  char *v6; // eax
  unsigned __int8 *v7; // edi
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  void *v19; // eax
  int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // eax
  char *v24; // ecx
  unsigned int v25; // eax
  unsigned int v26; // edx
  int v27; // eax
  unsigned int v28; // ecx
  char *v29; // edx
  unsigned int v30; // eax
  const void *v31; // esi
  void *v32; // edi
  unsigned int v33; // ecx
  int v34; // eax
  unsigned int v35; // eax
  unsigned int v36; // ecx
  unsigned int v37; // eax
  int v38; // eax
  unsigned int i; // ecx
  int v40; // eax
  char v41; // al
  int v42; // ecx
  int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int v46; // eax
  int v47; // ecx
  unsigned int v48; // edx
  int v49; // eax
  int v50; // edx
  int v51; // ecx
  int v52; // eax
  unsigned int v53; // eax
  int v54; // eax
  void *v55; // eax
  char *v56; // eax
  int v57; // eax
  char *v58; // ecx
  unsigned int v59; // eax
  int v60; // eax
  bool v61; // zf
  unsigned int v62; // eax
  char *v63; // eax
  unsigned __int8 *v64; // ecx
  int v65; // [esp-28h] [ebp-68h]
  unsigned int *v66; // [esp-1Ch] [ebp-5Ch]
  unsigned int *v67; // [esp-14h] [ebp-54h]
  void *v68; // [esp-8h] [ebp-48h]
  void *v69; // [esp-8h] [ebp-48h]
  int v70; // [esp-4h] [ebp-44h]
  void *v71; // [esp+Ch] [ebp-34h] BYREF
  void *v72; // [esp+10h] [ebp-30h] BYREF
  char *v73; // [esp+14h] [ebp-2Ch]
  unsigned int v74; // [esp+18h] [ebp-28h] BYREF
  unsigned int bd; // [esp+1Ch] [ebp-24h] BYREF
  void *tl; // [esp+20h] [ebp-20h] BYREF
  void *td; // [esp+24h] [ebp-1Ch] BYREF
  unsigned int v78; // [esp+28h] [ebp-18h] BYREF
  unsigned int v79; // [esp+2Ch] [ebp-14h] BYREF
  int v80; // [esp+30h] [ebp-10h]
  char *v81; // [esp+34h] [ebp-Ch]
  unsigned int v82; // [esp+38h] [ebp-8h]
  unsigned int v83; // [esp+3Ch] [ebp-4h]
  unsigned int sa; // [esp+48h] [ebp+8h]
  void *sb; // [esp+48h] [ebp+8h]
  int ra; // [esp+50h] [ebp+10h]

  v4 = *((_DWORD *)s + 12);
  v5 = z;
  v82 = *((_DWORD *)z + 1);
  v83 = *((_DWORD *)s + 8);
  sa = *((_DWORD *)s + 7);
  v6 = (char *)*((_DWORD *)s + 13);
  v7 = *(unsigned __int8 **)z;
  v79 = *(_DWORD *)z;
  v81 = v6;
  if ( (unsigned int)v6 >= v4 )
    v8 = *((_DWORD *)s + 11) - (_DWORD)v6;
  else
    v8 = v4 - (_DWORD)v6 - 1;
  v9 = *(_DWORD *)s;
  v80 = v8;
  while ( 2 )
  {
    switch ( v9 )
    {
      case 0:
        while ( sa < 3 )
        {
          if ( !v82 )
            goto LABEL_114;
          v13 = *v7;
          r = 0;
          --v82;
          v83 |= v13 << sa;
          ++v7;
          sa += 8;
          v79 = (unsigned int)v7;
        }
        v14 = (unsigned __int8)(v83 & 7) >> 1;
        *((_DWORD *)s + 6) = v83 & 1;
        if ( !v14 )
        {
          sb = (void *)(sa - 3);
          v20 = (unsigned __int8)sb & 7;
          v21 = v83 >> 3 >> v20;
          sa = (unsigned int)sb - v20;
          *(_DWORD *)s = 1;
          v83 = v21;
          goto LABEL_107;
        }
        v15 = v14 - 1;
        if ( v15 )
        {
          v16 = v15 - 1;
          if ( !v16 )
          {
            v83 >>= 3;
            v18 = 3;
            sa -= 3;
            goto LABEL_22;
          }
          if ( v16 != 1 )
            goto LABEL_107;
          v17 = v83 >> 3;
          *(_DWORD *)s = 9;
          v5[6] = "invalid block type";
          *((_DWORD *)s + 8) = v17;
          v10 = sa - 3;
          v70 = -3;
          goto LABEL_7;
        }
        sub_10036E31(&v74, &bd, &tl, &td);
        v19 = inflate_codes_new(v74, bd, tl, td, v5);
        *((_DWORD *)s + 1) = v19;
        if ( !v19 )
          goto LABEL_120;
        v83 >>= 3;
        sa -= 3;
        *(_DWORD *)s = 6;
        goto LABEL_107;
      case 1:
        v22 = sa;
        while ( 2 )
        {
          if ( v22 < 0x20 )
          {
            if ( v82 )
            {
              v23 = *v7;
              r = 0;
              --v82;
              v83 |= v23 << v22;
              ++v7;
              v22 += 8;
              v79 = (unsigned int)v7;
              sa = v22;
              continue;
            }
LABEL_114:
            v70 = r;
            *((_DWORD *)s + 8) = v83;
            *((_DWORD *)s + 7) = sa;
            v5[1] = 0;
LABEL_8:
            v5[2] += &v7[-*v5];
            v11 = (unsigned int)v81;
LABEL_9:
            *v5 = v7;
            *((_DWORD *)s + 13) = v11;
            return inflate_flush(s, v5, v70);
          }
          break;
        }
        if ( ~v83 >> 16 != (unsigned __int16)v83 )
        {
          *(_DWORD *)s = 9;
          v5[6] = "invalid stored block lengths";
          goto LABEL_110;
        }
        *((_DWORD *)s + 1) = (unsigned __int16)v83;
        v61 = *((_DWORD *)s + 1) == 0;
        sa = 0;
        v83 = 0;
        if ( v61 )
LABEL_57:
          v18 = *((_DWORD *)s + 6) != 0 ? 7 : 0;
        else
          v18 = 2;
LABEL_22:
        *(_DWORD *)s = v18;
LABEL_107:
        v9 = *(_DWORD *)s;
        v5 = z;
        v7 = (unsigned __int8 *)v79;
        if ( *(_DWORD *)s > 9u )
        {
LABEL_5:
          v70 = -2;
          goto LABEL_6;
        }
        v8 = v80;
        continue;
      case 2:
        if ( !v82 )
          goto LABEL_114;
        if ( !v8 )
        {
          if ( (v24 = (char *)*((_DWORD *)s + 11), v81 != v24)
            || (v25 = *((_DWORD *)s + 12), v26 = *((_DWORD *)s + 10), v26 == v25)
            || ((v81 = (char *)*((_DWORD *)s + 10), v26 >= v25) ? (v8 = (unsigned int)&v24[-v26]) : (v8 = v25 - v26 - 1),
                (v80 = v8) == 0) )
          {
            *((_DWORD *)s + 13) = v81;
            v27 = inflate_flush(s, v5, r);
            v28 = *((_DWORD *)s + 12);
            ra = v27;
            v81 = (char *)*((_DWORD *)s + 13);
            v11 = (unsigned int)v81;
            v78 = v28;
            if ( (unsigned int)v81 >= v28 )
              v8 = *((_DWORD *)s + 11) - (_DWORD)v81;
            else
              v8 = v28 - (_DWORD)v81 - 1;
            v29 = (char *)*((_DWORD *)s + 11);
            v80 = v8;
            v73 = v29;
            if ( v81 == v29 )
            {
              v11 = *((_DWORD *)s + 10);
              if ( v11 == v78 )
              {
                v11 = (unsigned int)v81;
              }
              else
              {
                v81 = (char *)*((_DWORD *)s + 10);
                if ( v11 >= v78 )
                  v8 = (unsigned int)&v73[-v11];
                else
                  v8 = v78 - v11 - 1;
                v80 = v8;
              }
            }
            if ( !v8 )
            {
              v70 = ra;
              *((_DWORD *)s + 8) = v83;
              *((_DWORD *)s + 7) = sa;
              v5[1] = v82;
              v5[2] += &v7[-*v5];
              goto LABEL_9;
            }
          }
        }
        v30 = *((_DWORD *)s + 1);
        r = 0;
        if ( v30 > v82 )
          v30 = v82;
        if ( v30 > v8 )
          v30 = v8;
        v31 = (const void *)v79;
        v32 = v81;
        v79 += v30;
        v82 -= v30;
        v81 += v30;
        v80 -= v30;
        qmemcpy(v32, v31, v30);
        v61 = *((_DWORD *)s + 1) == v30;
        *((_DWORD *)s + 1) -= v30;
        if ( v61 )
          goto LABEL_57;
        goto LABEL_107;
      case 3:
        v33 = sa;
        while ( 2 )
        {
          if ( v33 < 0xE )
          {
            if ( v82 )
            {
              v34 = *v7;
              r = 0;
              --v82;
              v83 |= v34 << v33;
              ++v7;
              v33 += 8;
              sa = v33;
              continue;
            }
            goto LABEL_114;
          }
          break;
        }
        v35 = v83 & 0x3FFF;
        v36 = v83 & 0x1F;
        *((_DWORD *)s + 1) = v35;
        if ( v36 > 0x1D || (v37 = (v35 >> 5) & 0x1F, v37 > 0x1D) )
        {
          *(_DWORD *)s = 9;
          v5[6] = "too many length or distance symbols";
LABEL_110:
          v70 = -3;
LABEL_6:
          *((_DWORD *)s + 8) = v83;
          v10 = sa;
LABEL_7:
          *((_DWORD *)s + 7) = v10;
          v5[1] = v82;
          goto LABEL_8;
        }
        v38 = ((int (__cdecl *)(_DWORD, unsigned int, int))v5[8])(v5[10], v37 + v36 + 258, 4);
        *((_DWORD *)s + 3) = v38;
        if ( !v38 )
          goto LABEL_120;
        v83 >>= 14;
        sa -= 14;
        *((_DWORD *)s + 2) = 0;
        *(_DWORD *)s = 4;
LABEL_71:
        while ( *((_DWORD *)s + 2) < (unsigned int)((*((_DWORD *)s + 1) >> 10) + 4) )
        {
          for ( i = sa; i < 3; sa = i )
          {
            if ( !v82 )
              goto LABEL_114;
            v40 = *v7;
            r = 0;
            --v82;
            v83 |= v40 << i;
            ++v7;
            i += 8;
          }
          v41 = v83;
          v42 = dword_1004F6E0[*((_DWORD *)s + 2)];
          v43 = *((_DWORD *)s + 3);
          v83 >>= 3;
          *(_DWORD *)(v43 + 4 * v42) = v41 & 7;
          ++*((_DWORD *)s + 2);
          sa -= 3;
        }
        while ( *((_DWORD *)s + 2) < 0x13u )
          *(_DWORD *)(*((_DWORD *)s + 3) + 4 * dword_1004F6E0[(*((_DWORD *)s + 2))++]) = 0;
        v68 = (void *)*((_DWORD *)s + 9);
        v67 = (unsigned int *)*((_DWORD *)s + 3);
        *((_DWORD *)s + 4) = 7;
        v80 = inflate_trees_bits(v67, (unsigned int *)s + 4, (void **)s + 5, v68, v5);
        if ( v80 )
        {
          ((void (__cdecl *)(_DWORD, _DWORD))v5[9])(v5[10], *((_DWORD *)s + 3));
          v61 = v80 == -3;
LABEL_117:
          if ( v61 )
            *(_DWORD *)s = 9;
          v70 = v80;
          goto LABEL_6;
        }
        *((_DWORD *)s + 2) = 0;
        *(_DWORD *)s = 5;
LABEL_97:
        while ( *((_DWORD *)s + 2) < ((*((_DWORD *)s + 1) >> 5) & 0x1F) + (*((_DWORD *)s + 1) & 0x1Fu) + 258 )
        {
          v44 = *((_DWORD *)s + 4);
          while ( sa < v44 )
          {
            if ( !v82 )
              goto LABEL_114;
            v45 = *v7;
            r = 0;
            --v82;
            v83 |= v45 << sa;
            ++v7;
            sa += 8;
          }
          v46 = *((_DWORD *)s + 5) + 8 * (v83 & dword_10057020[v44]);
          v47 = *(unsigned __int8 *)(v46 + 1);
          v48 = *(_DWORD *)(v46 + 4);
          v80 = v47;
          v73 = (char *)v48;
          if ( v48 >= 0x10 )
          {
            if ( v48 == 18 )
              v49 = 7;
            else
              v49 = v48 - 14;
            v79 = 8 * (v48 == 18) + 3;
            while ( sa < v49 + v80 )
            {
              if ( !v82 )
                goto LABEL_114;
              v50 = *v7;
              r = 0;
              --v82;
              v83 |= v50 << sa;
              ++v7;
              sa += 8;
            }
            v83 >>= v80;
            v79 += v83 & dword_10057020[v49];
            v83 >>= v49;
            sa -= v80 + v49;
            v51 = *((_DWORD *)s + 2);
            if ( v51 + v79 > ((*((_DWORD *)s + 1) >> 5) & 0x1F) + (*((_DWORD *)s + 1) & 0x1Fu) + 258 )
            {
LABEL_115:
              ((void (__cdecl *)(_DWORD, _DWORD))v5[9])(v5[10], *((_DWORD *)s + 3));
              v62 = v83;
              *(_DWORD *)s = 9;
              v5[6] = "invalid bit length repeat";
              *((_DWORD *)s + 8) = v62;
              *((_DWORD *)s + 7) = sa;
              v5[1] = v82;
              v5[2] += &v7[-*v5];
              v63 = v81;
              *v5 = v7;
              *((_DWORD *)s + 13) = v63;
              return inflate_flush(s, v5, -3);
            }
            if ( v73 == (char *)16 )
            {
              if ( !v51 )
                goto LABEL_115;
              v52 = *(_DWORD *)(*((_DWORD *)s + 3) + 4 * v51 - 4);
            }
            else
            {
              v52 = 0;
            }
            do
            {
              *(_DWORD *)(*((_DWORD *)s + 3) + 4 * v51++) = v52;
              --v79;
            }
            while ( v79 );
            *((_DWORD *)s + 2) = v51;
          }
          else
          {
            v83 >>= v47;
            sa -= v47;
            *(_DWORD *)(*((_DWORD *)s + 3) + 4 * (*((_DWORD *)s + 2))++) = v48;
          }
        }
        v53 = *((_DWORD *)s + 1);
        *((_DWORD *)s + 5) = 0;
        v69 = (void *)*((_DWORD *)s + 9);
        v66 = (unsigned int *)*((_DWORD *)s + 3);
        v78 = 9;
        v79 = 6;
        v54 = inflate_trees_dynamic((v53 & 0x1F) + 257, ((v53 >> 5) & 0x1F) + 1, v66, &v78, &v79, &v71, &v72, v69, v5);
        v65 = *((_DWORD *)s + 3);
        v80 = v54;
        ((void (__cdecl *)(_DWORD, int))v5[9])(v5[10], v65);
        if ( v80 )
        {
          v61 = v80 == -3;
          goto LABEL_117;
        }
        v55 = inflate_codes_new(v78, v79, v71, v72, v5);
        if ( !v55 )
        {
LABEL_120:
          v70 = -4;
          goto LABEL_6;
        }
        *((_DWORD *)s + 1) = v55;
        *(_DWORD *)s = 6;
LABEL_101:
        *((_DWORD *)s + 8) = v83;
        *((_DWORD *)s + 7) = sa;
        v5[1] = v82;
        v5[2] += &v7[-*v5];
        v56 = v81;
        *v5 = v7;
        *((_DWORD *)s + 13) = v56;
        v57 = inflate_codes(s, v5, r);
        if ( v57 != 1 )
          return inflate_flush(s, v5, v57);
        r = 0;
        inflate_codes_free(*((void **)s + 1), v5);
        v7 = (unsigned __int8 *)*v5;
        v82 = v5[1];
        v83 = *((_DWORD *)s + 8);
        v58 = (char *)*((_DWORD *)s + 13);
        sa = *((_DWORD *)s + 7);
        v59 = *((_DWORD *)s + 12);
        v79 = (unsigned int)v7;
        v81 = v58;
        if ( (unsigned int)v58 >= v59 )
          v60 = *((_DWORD *)s + 11) - (_DWORD)v81;
        else
          v60 = v59 - (_DWORD)v58 - 1;
        v61 = *((_DWORD *)s + 6) == 0;
        v80 = v60;
        if ( v61 )
        {
          *(_DWORD *)s = 0;
          goto LABEL_107;
        }
        *(_DWORD *)s = 7;
LABEL_122:
        *((_DWORD *)s + 13) = v81;
        v57 = inflate_flush(s, v5, r);
        v61 = *((_DWORD *)s + 12) == *((_DWORD *)s + 13);
        v81 = (char *)*((_DWORD *)s + 13);
        if ( v61 )
        {
          *(_DWORD *)s = 8;
LABEL_126:
          v70 = 1;
          goto LABEL_6;
        }
        *((_DWORD *)s + 8) = v83;
        *((_DWORD *)s + 7) = sa;
        v5[1] = v82;
        v64 = &v7[-*v5];
        *v5 = v7;
        v5[2] += v64;
        *((_DWORD *)s + 13) = v81;
        return inflate_flush(s, v5, v57);
      case 4:
        goto LABEL_71;
      case 5:
        goto LABEL_97;
      case 6:
        goto LABEL_101;
      case 7:
        goto LABEL_122;
      case 8:
        goto LABEL_126;
      case 9:
        goto LABEL_110;
      default:
        goto LABEL_5;
    }
  }
}

// inflate_blocks_free @ 0x1003479E
// zlib (internal): free inflate blocks state
void inflate_blocks_free(void *s, void *z)
{
  inflate_blocks_reset(s, z, 0);
  (*((void (__cdecl **)(_DWORD, _DWORD))z + 9))(*((_DWORD *)z + 10), *((_DWORD *)s + 10));
  (*((void (__cdecl **)(_DWORD, _DWORD))z + 9))(*((_DWORD *)z + 10), *((_DWORD *)s + 9));
  (*((void (__cdecl **)(_DWORD, void *))z + 9))(*((_DWORD *)z + 10), s);
}

// adler32 @ 0x100347D2
// zlib: adler32 checksum
unsigned int adler32(unsigned int adler, unsigned __int8 **buf, unsigned int len)
{
  unsigned __int8 *v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // edi
  unsigned int v7; // edx
  unsigned int v8; // eax
  int v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // edi
  int v19; // esi
  int v20; // edi
  int v21; // esi
  int v22; // edi
  int v23; // esi
  int v24; // edi
  int v25; // esi
  int v26; // edi
  int v27; // esi
  int v28; // edi
  int v29; // esi
  int v30; // edi
  int v31; // esi
  int v32; // edi
  int v33; // esi
  int v34; // edi
  int v35; // esi
  int v36; // edi
  int v37; // esi
  int v38; // edi

  v3 = (unsigned __int8 *)buf;
  v4 = (unsigned __int16)adler;
  v5 = HIWORD(adler);
  if ( !buf )
    return 1;
  for ( ; len; v5 %= 0xFFF1u )
  {
    v7 = 5552;
    if ( len < 0x15B0 )
      v7 = len;
    len -= v7;
    if ( (int)v7 >= 16 )
    {
      v8 = v7 >> 4;
      v7 += -16 * (v7 >> 4);
      do
      {
        v9 = *v3 + v4;
        v10 = v9 + v5;
        v11 = v3[1] + v9;
        v12 = v11 + v10;
        v13 = v3[2] + v11;
        v14 = v13 + v12;
        v15 = v3[3] + v13;
        v16 = v15 + v14;
        v17 = v3[4] + v15;
        v18 = v17 + v16;
        v19 = v3[5] + v17;
        v20 = v19 + v18;
        v21 = v3[6] + v19;
        v22 = v21 + v20;
        v23 = v3[7] + v21;
        v24 = v23 + v22;
        v25 = v3[8] + v23;
        v26 = v25 + v24;
        v27 = v3[9] + v25;
        v28 = v27 + v26;
        v29 = v3[10] + v27;
        v30 = v29 + v28;
        v31 = v3[11] + v29;
        v32 = v31 + v30;
        v33 = v3[12] + v31;
        v34 = v33 + v32;
        v35 = v3[13] + v33;
        v36 = v35 + v34;
        v37 = v3[14] + v35;
        v38 = v37 + v36;
        v4 = v3[15] + v37;
        v5 = v4 + v38;
        v3 += 16;
        --v8;
      }
      while ( v8 );
    }
    for ( ; v7; --v7 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

// zcalloc @ 0x100348EB
// zlib (internal): default alloc wrapper (calloc)
void *zcalloc(void *opaque, unsigned int items, unsigned int size)
{
  return calloc(items, size);
}

// sub_10034900 @ 0x10034900
__m128 *__cdecl sub_10034900(__m128 *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm2
  __m128 *v5; // edx
  __m128 v6; // xmm3
  __m128 v7; // xmm0
  __m128 v8; // xmm5
  __m128 v9; // xmm6
  __m128 v10; // xmm2
  __m128 v11; // xmm4
  __m128 v12; // xmm3
  __m128 v13; // xmm3
  __m128 v14; // xmm0
  __m128 v15; // xmm5
  __m128 v16; // xmm6
  __m128 v17; // xmm1
  __m128 v18; // xmm0
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v3 = _mm_and_ps(*a1, (__m128)xmmword_10055B50);
  v4 = _mm_and_ps(*a1, (__m128)xmmword_10055B60);
  v5 = (__m128 *)(&savedregs - 16);
  v6 = _mm_add_ps(_mm_mul_ps(v4, (__m128)xmmword_10055B40), (__m128)xmmword_10055AF0);
  v7 = _mm_sub_ps(v6, (__m128)xmmword_10055AF0);
  v8 = (__m128)xmmword_10055AE0;
  v9 = (__m128)xmmword_10055AD0;
  v10 = _mm_sub_ps(
          _mm_sub_ps(
            _mm_sub_ps(
              _mm_sub_ps(v4, _mm_mul_ps((__m128)xmmword_10055B30, v7)),
              _mm_mul_ps((__m128)xmmword_10055B20, v7)),
            _mm_mul_ps((__m128)xmmword_10055B10, v7)),
          _mm_mul_ps((__m128)xmmword_10055B00, v7));
  v11 = _mm_mul_ps(v10, v10);
  v12 = _mm_and_ps(v6, (__m128)xmmword_10055AC0);
  *v5 = _mm_and_ps(v12, (__m128)xmmword_10055AB0);
  v5[1] = v12;
  v5[2] = v12;
  v5[1].m128_i32[0] = (dword_10055AA0 & (v5[1].m128_i32[0] - v5->m128_i32[0])) << 30;
  v5[1].m128_i32[1] = (dword_10055AA0 & (v5[1].m128_i32[1] - v5->m128_i32[1])) << 30;
  v5[1].m128_i32[2] = (dword_10055AA0 & (v5[1].m128_i32[2] - v5->m128_i32[2])) << 30;
  v5[1].m128_i32[3] = (dword_10055AA0 & (v5[1].m128_i32[3] - v5->m128_i32[3])) << 30;
  v5[2].m128_i32[0] = (dword_10055AA0 & (v5->m128_i32[0] + v5[2].m128_i32[0])) << 30;
  v5[2].m128_i32[1] = (dword_10055AA0 & (v5->m128_i32[1] + v5[2].m128_i32[1])) << 30;
  v5[2].m128_i32[2] = (dword_10055AA0 & (v5->m128_i32[2] + v5[2].m128_i32[2])) << 30;
  v5[2].m128_i32[3] = (dword_10055AA0 & (v5->m128_i32[3] + v5[2].m128_i32[3])) << 30;
  v5->m128_i32[0] = *(&savedregs - 16) << 30;
  v5->m128_i32[1] <<= 30;
  v5->m128_i32[2] <<= 30;
  v5->m128_i32[3] = *(&savedregs - 13) << 30;
  v13 = _mm_xor_ps(*((__m128 *)&savedregs - 3), v3);
  v14 = _mm_cmpneq_ps(*((__m128 *)&savedregs - 4), (__m128)0LL);
  v15 = _mm_mul_ps(
          _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_mul_ps(_mm_add_ps(_mm_mul_ps(v8, v11), (__m128)xmmword_10055A90), v11),
                (__m128)xmmword_10055A70),
              v11),
            (__m128)xmmword_10055A50),
          v10);
  v16 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps(v9, v11), (__m128)xmmword_10055A80), v11),
                  (__m128)xmmword_10055A60),
                v11),
              (__m128)xmmword_10055A40),
            v11),
          (__m128)xmmword_10055A30);
  v17 = _mm_or_ps(_mm_andnot_ps(v14, v15), _mm_and_ps(v14, v16));
  v18 = _mm_xor_ps(_mm_or_ps(_mm_and_ps(v14, v15), _mm_andnot_ps(v14, v16)), *((__m128 *)&savedregs - 2));
  *a2 = _mm_xor_ps(v17, v13);
  *a3 = v18;
  return a2;
}

// sub_10034AF0 @ 0x10034AF0
__m128 __userpurge sub_10034AF0@<xmm0>(__m128i a1@<xmm0>, int a2, int a3, int a4, int a5)
{
  __m128 v6; // xmm2
  __m128 v7; // xmm3
  __m128 v8; // xmm4
  __m128 v9; // xmm2
  __m128 v10; // xmm4
  __m128 v11; // xmm2
  __m128 v12; // xmm4
  __m128 v13; // xmm2
  __m128 v14; // xmm4
  __m128 v15; // xmm7
  __m128i v16; // xmm0
  __m128i v17; // xmm3
  __m128 v18; // xmm7
  __m128 v19; // xmm5
  __m128 v20; // xmm2
  __m128 v21; // xmm0
  __m128 v22; // xmm2

  v6 = (__m128)_mm_and_si128(a1, (__m128i)xmmword_10055C40);
  v7 = _mm_add_ps(_mm_mul_ps(v6, (__m128)xmmword_10055C20), (__m128)xmmword_10055C00);
  v8 = _mm_mul_ps((__m128)xmmword_10055C10, _mm_sub_ps(v7, (__m128)xmmword_10055C00));
  v9 = _mm_sub_ps(v6, v8);
  v10 = _mm_shuffle_ps(v8, v8, 57);
  v11 = _mm_sub_ps(v9, v10);
  v12 = _mm_shuffle_ps(v10, v10, 57);
  v13 = _mm_sub_ps(_mm_sub_ps(v11, v12), _mm_shuffle_ps(v12, v12, 57));
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_and_ps(v7, (__m128)xmmword_10055BF0);
  v16 = (__m128i)_mm_and_ps(v15, (__m128)xmmword_10055BE0);
  v17 = _mm_sub_epi32((__m128i)v15, v16);
  v18 = (__m128)_mm_slli_epi32(_mm_and_si128(_mm_add_epi32((__m128i)v15, v16), (__m128i)xmmword_10055BD0), 0x1Eu);
  v19 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055BC0, v14), (__m128)xmmword_10055BB0), v14),
                  (__m128)xmmword_10055BA0),
                v14),
              (__m128)xmmword_10055B90),
            _mm_unpacklo_ps(v13, v14)),
          (__m128)xmmword_10055B80);
  v20 = _mm_cmpneq_ps((__m128)_mm_slli_epi32(v16, 0x1Eu), (__m128)0LL);
  v21 = _mm_and_ps(v20, v19);
  v22 = _mm_andnot_ps(v20, v19);
  return _mm_xor_ps(
           _mm_or_ps(v21, _mm_shuffle_ps(v22, v22, 177)),
           _mm_unpacklo_ps(
             v18,
             (__m128)_mm_xor_si128(
                       _mm_slli_epi32(_mm_and_si128(v17, (__m128i)xmmword_10055BD0), 0x1Eu),
                       _mm_and_si128(a1, (__m128i)xmmword_10055C30))));
}

// sub_10034BE0 @ 0x10034BE0
__m128 *__cdecl sub_10034BE0(__m128i *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm0
  __m128 v6; // xmm2
  __m128 v7; // xmm4
  __m128 v8; // xmm7
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128 v11; // xmm7
  __m128 v12; // xmm0
  __m128 v13; // xmm5
  __m128 v14; // xmm6

  v3 = (__m128)_mm_and_si128(*a1, (__m128i)xmmword_10055D80);
  v4 = _mm_add_ps(_mm_mul_ps(v3, (__m128)xmmword_10055D60), (__m128)xmmword_10055D10);
  v5 = _mm_sub_ps(v4, (__m128)xmmword_10055D10);
  v6 = _mm_sub_ps(
         _mm_sub_ps(
           _mm_sub_ps(
             _mm_sub_ps(v3, _mm_mul_ps((__m128)xmmword_10055D50, v5)),
             _mm_mul_ps((__m128)xmmword_10055D40, v5)),
           _mm_mul_ps((__m128)xmmword_10055D30, v5)),
         _mm_mul_ps((__m128)xmmword_10055D20, v5));
  v7 = _mm_mul_ps(v6, v6);
  v8 = _mm_and_ps(v4, (__m128)xmmword_10055CE0);
  v9 = (__m128i)_mm_and_ps(v8, (__m128)xmmword_10055CD0);
  v10 = _mm_sub_epi32((__m128i)v8, v9);
  v11 = (__m128)_mm_slli_epi32(_mm_and_si128(_mm_add_epi32((__m128i)v8, v9), (__m128i)xmmword_10055CC0), 0x1Eu);
  v12 = _mm_cmpneq_ps((__m128)_mm_slli_epi32(v9, 0x1Eu), (__m128)0LL);
  v13 = _mm_mul_ps(
          _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055D00, v7), (__m128)xmmword_10055CB0), v7),
                (__m128)xmmword_10055C90),
              v7),
            (__m128)xmmword_10055C70),
          v6);
  v14 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055CF0, v7), (__m128)xmmword_10055CA0), v7),
                  (__m128)xmmword_10055C80),
                v7),
              (__m128)xmmword_10055C60),
            v7),
          (__m128)xmmword_10055C50);
  *a2 = _mm_xor_ps(
          _mm_or_ps(_mm_andnot_ps(v12, v13), _mm_and_ps(v12, v14)),
          (__m128)_mm_xor_si128(
                    _mm_slli_epi32(_mm_and_si128(v10, (__m128i)xmmword_10055CC0), 0x1Eu),
                    _mm_and_si128(*a1, (__m128i)xmmword_10055D70)));
  *a3 = _mm_xor_ps(_mm_or_ps(_mm_and_ps(v12, v13), _mm_andnot_ps(v12, v14)), v11);
  return a2;
}

// sub_10034E00 @ 0x10034E00
void sub_10034E00()
{
  ;
}

// sub_10034F00 @ 0x10034F00
void sub_10034F00()
{
  ;
}

// sub_10035100 @ 0x10035100
void sub_10035100()
{
  ;
}

// sub_100354E0 @ 0x100354E0
unsigned int __usercall sub_100354E0@<eax>(__m64 a1@<mm0>)
{
  int v1; // eax

  v1 = _mm_cvtsi64_si32(a1);
  return v1 & 0x80000000 ^ v1;
}

// sub_10035600 @ 0x10035600
unsigned int __usercall sub_10035600@<eax>(__m64 a1@<mm0>)
{
  int v1; // eax

  v1 = _mm_cvtsi64_si32(a1);
  return v1 & 0x80000000 ^ v1;
}

// sub_100359F8 @ 0x100359F8
_BYTE *__cdecl sub_100359F8(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  unsigned __int16 *v7; // esi
  int *v8; // edi
  _WORD *v9; // ecx
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // bx
  __int16 v12; // ax
  unsigned __int16 v13; // bx
  bool v14; // zf
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // edi
  int v22; // edx
  int v23; // edi
  int v24; // ebx
  int v25; // esi
  int v26; // esi
  int v27; // eax
  char *v28; // ecx
  int v29; // ebx
  _BYTE *result; // eax
  char v31; // bl
  int v32; // esi
  int v33; // edx
  int v34; // edi
  int v35; // edx
  int v36; // esi
  int v37; // ebx
  int v38; // esi
  int v39; // edx
  int v40; // ebx
  int v41; // edi
  int v42; // edi
  char v43; // [esp+Ch] [ebp-98h] BYREF
  _BYTE v44[96]; // [esp+2Ch] [ebp-78h] BYREF
  int v45; // [esp+8Ch] [ebp-18h]
  unsigned __int16 *v46; // [esp+90h] [ebp-14h]
  int *v47; // [esp+94h] [ebp-10h]
  int v48; // [esp+98h] [ebp-Ch]
  int v49; // [esp+9Ch] [ebp-8h]
  int v50; // [esp+A0h] [ebp-4h]
  int v51; // [esp+ACh] [ebp+8h]
  int v52; // [esp+ACh] [ebp+8h]
  __int16 v53; // [esp+B0h] [ebp+Ch]
  __int16 v54; // [esp+B0h] [ebp+Ch]
  int v55; // [esp+B0h] [ebp+Ch]
  unsigned __int16 v56; // [esp+B4h] [ebp+10h]
  __int16 v57; // [esp+B4h] [ebp+10h]
  int v58; // [esp+B4h] [ebp+10h]
  int v59; // [esp+B4h] [ebp+10h]

  v5 = *(_DWORD *)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (unsigned __int16 *)(a3 + 96);
  v8 = (int *)v44;
  v48 = v6;
  v51 = 8;
  v47 = (int *)v44;
  v46 = (unsigned __int16 *)(a3 + 96);
  v9 = (_WORD *)(v5 + 96);
  do
  {
    if ( v51 != 4 )
    {
      v56 = v7[8];
      v10 = *v7;
      v53 = *(v7 - 8);
      LOWORD(v50) = *(v7 - 24);
      v11 = *(v7 - 40);
      v45 = v10;
      v49 = v11;
      v12 = v53 | v50 | v11 | v10;
      v13 = *(v7 - 32);
      v14 = (v13 | (unsigned __int16)(v56 | v12)) == 0;
      v15 = (__int16)*(v9 - 48);
      if ( v14 )
      {
        v16 = 4 * (__int16)*(v7 - 48) * v15;
        *(v8 - 8) = v16;
        *v8 = v16;
        v8[16] = v16;
      }
      else
      {
        v17 = 15137 * (__int16)(v13 * *(v9 - 32)) - 6270 * (__int16)(v45 * *v9);
        v18 = ((__int16)*(v7 - 48) * v15) << 14;
        v19 = v17 + v18;
        v20 = v18 - v17;
        LOWORD(v17) = v56 * v9[8];
        v57 = v50 * *(v9 - 24);
        v54 = v53 * *(v9 - 8);
        v49 = (__int16)v49 * (__int16)*(v9 - 40);
        v21 = v57;
        v50 = (__int16)v49;
        v58 = (__int16)v17;
        v22 = 8697 * (__int16)v49 + 11893 * v54 - 1730 * (__int16)v17 - 17799 * v21;
        v23 = 20995 * (__int16)v49 + 7373 * v21 - 4926 * v54 - 4176 * v58;
        v24 = v19 + v23 + 2048;
        v25 = v19 - v23;
        v8 = v47;
        *(v47 - 8) = v24 >> 12;
        v8[16] = (v25 + 2048) >> 12;
        v26 = v20 + v22 + 2048;
        v27 = v20 - v22;
        v6 = v48;
        *v8 = v26 >> 12;
        v7 = v46;
        v16 = (v27 + 2048) >> 12;
      }
      v8[8] = v16;
    }
    ++v7;
    ++v8;
    ++v9;
    --v51;
    v46 = v7;
    v47 = v8;
  }
  while ( v51 > 0 );
  v52 = 0;
  v28 = &v43;
  do
  {
    v29 = *((_DWORD *)v28 + 5);
    result = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * v52));
    if ( *((_DWORD *)v28 + 2)
       | *((_DWORD *)v28 + 6)
       | *((_DWORD *)v28 + 7)
       | v29
       | *((_DWORD *)v28 + 3)
       | *((_DWORD *)v28 + 1) )
    {
      v32 = 15137 * *((__int16 *)v28 + 4) - 6270 * *((__int16 *)v28 + 12);
      v33 = *(_DWORD *)v28 << 14;
      v34 = v32 + v33;
      v35 = v33 - v32;
      v50 = *((__int16 *)v28 + 2);
      v59 = *((__int16 *)v28 + 14);
      v55 = (__int16)v29;
      v36 = 8697 * v50 + 11893 * (__int16)v29 - 1730 * v59;
      v49 = v35;
      v37 = *((__int16 *)v28 + 6);
      v38 = v36 - 17799 * v37;
      v39 = 20995 * v50 + 7373 * v37 - 4926 * v55 - 4176 * v59;
      v40 = (v34 + v39 + 0x40000) >> 19;
      v41 = v34 - v39;
      v6 = v48;
      *result = *(_BYTE *)((v40 & 0x3FF) + v48);
      LOBYTE(v40) = *(_BYTE *)((((v41 + 0x40000) >> 19) & 0x3FF) + v6);
      v42 = v49;
      result[3] = v40;
      result[1] = *(_BYTE *)((((v42 + v38 + 0x40000) >> 19) & 0x3FF) + v6);
      v31 = *(_BYTE *)((((v42 - v38 + 0x40000) >> 19) & 0x3FF) + v6);
    }
    else
    {
      v31 = *(_BYTE *)((((*(_DWORD *)v28 + 16) >> 5) & 0x3FF) + v6);
      *result = v31;
      result[1] = v31;
      result[3] = v31;
    }
    v28 += 32;
    ++v52;
    result[2] = v31;
  }
  while ( v52 < 4 );
  return result;
}

// sub_10035D0D @ 0x10035D0D
_BYTE *__cdecl sub_10035D0D(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // ebx
  int *v7; // edi
  _WORD *v8; // esi
  _WORD *v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  _BYTE *result; // eax
  _BYTE *v16; // edi
  int v17; // ecx
  char v18; // cl
  int v19; // ecx
  int v20; // esi
  _BYTE v21[64]; // [esp+Ch] [ebp-48h] BYREF
  int v22; // [esp+4Ch] [ebp-8h]
  int *v23; // [esp+50h] [ebp-4h]
  int v24; // [esp+5Ch] [ebp+8h]
  int v25; // [esp+5Ch] [ebp+8h]

  v5 = *(_DWORD *)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (int *)v21;
  v8 = (_WORD *)(a3 + 48);
  v22 = v6;
  v23 = (int *)v21;
  v24 = 8;
  v9 = (_WORD *)(v5 + 48);
  do
  {
    if ( v24 != 6 && v24 != 4 && v24 != 2 )
    {
      v10 = (__int16)*(v9 - 24);
      v11 = (__int16)*(v8 - 24);
      if ( *v8 | (unsigned __int16)(*(v8 - 16) | v8[16] | v8[32]) )
      {
        v13 = (v11 * v10) << 15;
        v14 = 29692 * (__int16)(*(v8 - 16) * *(v9 - 16))
            + 6967 * (__int16)(v8[16] * v9[16])
            - 5906 * (__int16)(v8[32] * v9[32])
            - 10426 * (__int16)(*v8 * *v9);
        v7 = v23;
        *v23 = (v14 + v13 + 4096) >> 13;
        v6 = v22;
        v12 = (v13 - v14 + 4096) >> 13;
      }
      else
      {
        v12 = 4 * v11 * v10;
        *v7 = v12;
      }
      v7[8] = v12;
    }
    ++v8;
    ++v7;
    ++v9;
    --v24;
    v23 = v7;
  }
  while ( v24 > 0 );
  v25 = 0;
  result = v21;
  do
  {
    v16 = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * v25));
    v17 = *(_DWORD *)result;
    if ( *((_DWORD *)result + 5) | *((_DWORD *)result + 1) | *((_DWORD *)result + 3) | *((_DWORD *)result + 7) )
    {
      v19 = v17 << 15;
      v20 = 6967 * *((__int16 *)result + 10)
          + 29692 * *((__int16 *)result + 2)
          + -10426 * *((__int16 *)result + 6)
          - 5906 * *((__int16 *)result + 14);
      v6 = v22;
      *v16 = *(_BYTE *)((((v20 + v19 + 0x80000) >> 20) & 0x3FF) + v22);
      v18 = *(_BYTE *)((((v19 - v20 + 0x80000) >> 20) & 0x3FF) + v6);
    }
    else
    {
      v18 = *(_BYTE *)((((v17 + 16) >> 5) & 0x3FF) + v6);
      *v16 = v18;
    }
    result += 32;
    ++v25;
    v16[1] = v18;
  }
  while ( v25 < 2 );
  return result;
}

// sub_10035ECB @ 0x10035ECB
char __cdecl sub_10035ECB(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  char result; // al

  result = *(_BYTE *)((((*a3 * **(__int16 **)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD *)(a1 + 284) + 128);
  *(_BYTE *)(a5 + *a4) = result;
  return result;
}

// sub_10035F08 @ 0x10035F08
int __cdecl sub_10035F08(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp-14h] [ebp-A4h]
  int v7; // [esp-4h] [ebp-94h]
  _BYTE v8[136]; // [esp+8h] [ebp-88h] BYREF

  v7 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(_DWORD *)(a2 + 80);
  if ( byte_100554E8 )
    return sub_100373D7(a3, v6, v8, a4, a5, v7);
  else
    return sub_10036F75(a3, v6, v8, a4, a5, v7);
}

// sub_10035F54 @ 0x10035F54
int __cdecl sub_10035F54(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp-10h] [ebp-A0h]
  int v7; // [esp-4h] [ebp-94h]
  _BYTE v8[136]; // [esp+8h] [ebp-88h] BYREF

  v7 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(_DWORD *)(a2 + 80);
  if ( byte_100554E8 )
    return sub_10037DEA(a3, v8, v6, a4, a5, v7);
  else
    return sub_10037A8F(a3, v8, v6, a4, a5, v7);
}

// sub_10035FA0 @ 0x10035FA0
char __cdecl sub_10035FA0(int a1, int a2, __int16 *a3, int a4, int a5)
{
  float *v6; // ecx
  float *v7; // eax
  __int16 v8; // si
  __int16 v9; // di
  double v10; // st5
  int v11; // edi
  double v12; // st4
  double v13; // st5
  double v14; // st4
  double v15; // st3
  double v16; // st5
  double v17; // st4
  double v18; // st3
  double v19; // st2
  double v20; // st2
  double v21; // st4
  double v22; // st3
  double v23; // st2
  double v24; // st1
  float *v25; // esi
  _BYTE *v26; // edi
  double v27; // st5
  double v28; // st4
  double v29; // st3
  double v30; // st5
  double v31; // st4
  double v32; // st4
  double v33; // st3
  double v34; // st2
  double v35; // st1
  double v36; // st3
  double v37; // st4
  double v38; // st5
  __int64 v39; // rax
  double v40; // st5
  __int64 v41; // rax
  double v42; // st5
  char result; // al
  bool v44; // cc
  char v45; // [esp+Ch] [ebp-118h] BYREF
  char v46; // [esp+14h] [ebp-110h] BYREF
  int v47; // [esp+10Ch] [ebp-18h]
  float v48; // [esp+110h] [ebp-14h]
  int v49; // [esp+114h] [ebp-10h]
  float v50; // [esp+118h] [ebp-Ch]
  float v51; // [esp+11Ch] [ebp-8h]
  float v52; // [esp+120h] [ebp-4h]
  float v53; // [esp+12Ch] [ebp+8h]
  float v54; // [esp+12Ch] [ebp+8h]
  float v55; // [esp+12Ch] [ebp+8h]
  float v56; // [esp+130h] [ebp+Ch]
  float v57; // [esp+130h] [ebp+Ch]
  float v58; // [esp+130h] [ebp+Ch]
  float v59; // [esp+130h] [ebp+Ch]
  float v60; // [esp+130h] [ebp+Ch]
  float v61; // [esp+130h] [ebp+Ch]
  int v62; // [esp+134h] [ebp+10h]
  float v63; // [esp+134h] [ebp+10h]
  float v64; // [esp+134h] [ebp+10h]
  float v65; // [esp+134h] [ebp+10h]

  v49 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(float **)(a2 + 80);
  v7 = (float *)&v45;
  v47 = 8;
  do
  {
    v8 = a3[56];
    v9 = a3[48];
    v10 = (double)*a3 * *v6;
    if ( (unsigned __int16)v8 | (unsigned __int16)(v9 | a3[40] | a3[32] | a3[24] | a3[16] | a3[8]) )
    {
      v53 = v6[16] * (double)a3[16];
      v62 = v9;
      v11 = a3[8];
      v12 = v6[32] * (double)a3[32];
      v63 = v6[48] * (double)v62;
      v56 = v12 + v10;
      v13 = v10 - v12;
      v14 = v63 + v53;
      v15 = (v53 - v63) * 1.4142135 - v14;
      v48 = v14 + v56;
      v64 = v56 - v14;
      v54 = v15 + v13;
      v16 = v13 - v15;
      v17 = v6[8] * (double)v11;
      v18 = v6[24] * (double)a3[24];
      v19 = v6[40] * (double)a3[40];
      LODWORD(v50) = v8;
      v57 = v19;
      v20 = v6[56] * (double)v8;
      v51 = v57 + v18;
      v58 = v57 - v18;
      v52 = v20 + v17;
      v21 = v17 - v20;
      v22 = v52 + v51;
      v50 = (v21 + v58) * 1.847759;
      v23 = v50 - v58 * 2.613126 - v22;
      v24 = (v52 - v51) * 1.4142135 - v23;
      v52 = v24;
      v51 = v21 * 1.0823922 - v50 + v24;
      *v7 = v22 + v48;
      v7[56] = v48 - v22;
      v7[8] = v54 + v23;
      v7[48] = v54 - v23;
      v7[16] = v52 + v16;
      v7[40] = v16 - v52;
      v7[32] = v51 + v64;
      v7[24] = v64 - v51;
    }
    else
    {
      *v7 = v10;
      v7[8] = v10;
      v7[16] = v10;
      v7[24] = v10;
      v7[32] = v10;
      v7[40] = v10;
      v7[48] = v10;
      v7[56] = v10;
    }
    ++v6;
    ++a3;
    ++v7;
    --v47;
  }
  while ( *(float *)&v47 != 0.0 );
  v50 = 0.0;
  v25 = (float *)&v46;
  do
  {
    v26 = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * LODWORD(v50)));
    v59 = v25[2] + *(v25 - 2);
    v27 = *(v25 - 2) - v25[2];
    v28 = *v25 + v25[4];
    v29 = (*v25 - v25[4]) * 1.4142135 - v28;
    v48 = v28 + v59;
    v65 = v59 - v28;
    v55 = v29 + v27;
    v30 = v27 - v29;
    v31 = v25[3] + v25[1];
    v51 = v31;
    v60 = v25[3] - v25[1];
    v52 = v25[5] + *(v25 - 1);
    *(float *)&v47 = *(v25 - 1) - v25[5];
    v32 = v31 + v52;
    v33 = (*(float *)&v47 + v60) * 1.847759;
    v34 = v33 - v60 * 2.613126 - v32;
    v61 = v34;
    v35 = (v52 - v51) * 1.4142135 - v34;
    v52 = v35;
    v51 = *(float *)&v47 * 1.0823922 - v33 + v35;
    v36 = v48 - v32;
    *v26 = *(_BYTE *)((((int)((__int64)(v48 + v32) + 4) >> 3) & 0x3FF) + v49);
    v26[7] = *(_BYTE *)((((int)((__int64)v36 + 4) >> 3) & 0x3FF) + v49);
    v26[1] = *(_BYTE *)((((int)((__int64)(v61 + v55) + 4) >> 3) & 0x3FF) + v49);
    v37 = v52 + v30;
    v26[6] = *(_BYTE *)((((int)((__int64)(v55 - v61) + 4) >> 3) & 0x3FF) + v49);
    v38 = v30 - v52;
    v26[2] = *(_BYTE *)((((int)((__int64)v37 + 4) >> 3) & 0x3FF) + v49);
    v39 = (__int64)v38;
    v40 = v51 + v65;
    v26[5] = *(_BYTE *)(((((int)v39 + 4) >> 3) & 0x3FF) + v49);
    v41 = (__int64)v40;
    v42 = v65 - v51;
    v26[4] = *(_BYTE *)(((((int)v41 + 4) >> 3) & 0x3FF) + v49);
    result = *(_BYTE *)((((int)((__int64)v42 + 4) >> 3) & 0x3FF) + v49);
    v25 += 8;
    v44 = ++LODWORD(v50) < 8;
    v26[3] = result;
  }
  while ( v44 );
  return result;
}

// inflate_codes_new @ 0x10036381
// zlib (internal): allocate codes state
void *inflate_codes_new(unsigned int bl, unsigned int bd, void *tl, void *td, void *z)
{
  void *result; // eax

  result = (void *)(*((int (__cdecl **)(_DWORD, int, int))z + 8))(*((_DWORD *)z + 10), 1, 28);
  if ( result )
  {
    *(_DWORD *)result = 0;
    *((_BYTE *)result + 16) = bl;
    *((_BYTE *)result + 17) = bd;
    *((_DWORD *)result + 5) = tl;
    *((_DWORD *)result + 6) = td;
  }
  return result;
}

// inflate_codes @ 0x100363B5
// zlib (internal): decode codes
int inflate_codes(void *s, void *z, int r)
{
  _BYTE *v5; // edx
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  unsigned int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  unsigned int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  int v20; // eax
  unsigned int v21; // eax
  int v22; // ecx
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // ecx
  int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // ecx
  unsigned int v29; // eax
  unsigned int v30; // ecx
  int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // ecx
  unsigned __int8 *v34; // ecx
  int v36; // eax
  unsigned __int8 *v37; // ebx
  int v38; // [esp-4h] [ebp-28h]
  int v39; // [esp+Ch] [ebp-18h]
  unsigned int v40; // [esp+Ch] [ebp-18h]
  unsigned int v41; // [esp+Ch] [ebp-18h]
  _BYTE *v42; // [esp+10h] [ebp-14h]
  _BYTE *v43; // [esp+14h] [ebp-10h]
  _BYTE *v44; // [esp+14h] [ebp-10h]
  unsigned int v45; // [esp+18h] [ebp-Ch]
  unsigned int v46; // [esp+1Ch] [ebp-8h]
  unsigned __int8 *v47; // [esp+20h] [ebp-4h]
  unsigned int sa; // [esp+2Ch] [ebp+8h]
  unsigned int za; // [esp+30h] [ebp+Ch]
  int ra; // [esp+34h] [ebp+10h]

  v47 = *(unsigned __int8 **)z;
  v5 = (_BYTE *)*((_DWORD *)s + 13);
  v6 = *((_DWORD *)s + 1);
  v46 = *((_DWORD *)z + 1);
  za = *((_DWORD *)s + 8);
  sa = *((_DWORD *)s + 7);
  v7 = *((_DWORD *)s + 12);
  if ( (unsigned int)v5 >= v7 )
    v8 = *((_DWORD *)s + 11) - (_DWORD)v5;
  else
    v8 = v7 - (_DWORD)v5 - 1;
LABEL_83:
  v45 = v8;
  while ( 2 )
  {
    switch ( *(_DWORD *)v6 )
    {
      case 0:
        if ( v8 >= 0x102 && v46 >= 0xA )
        {
          *((_DWORD *)s + 8) = za;
          *((_DWORD *)s + 7) = sa;
          *((_DWORD *)z + 1) = v46;
          *((_DWORD *)z + 2) += &v47[-*(_DWORD *)z];
          *(_DWORD *)z = v47;
          *((_DWORD *)s + 13) = v5;
          v9 = sub_10038BBD(
                 *(unsigned __int8 *)(v6 + 16),
                 *(unsigned __int8 *)(v6 + 17),
                 *(_DWORD *)(v6 + 20),
                 *(_DWORD *)(v6 + 24),
                 s,
                 (unsigned __int8 **)z);
          v5 = (_BYTE *)*((_DWORD *)s + 13);
          r = v9;
          v47 = *(unsigned __int8 **)z;
          v46 = *((_DWORD *)z + 1);
          za = *((_DWORD *)s + 8);
          sa = *((_DWORD *)s + 7);
          v10 = *((_DWORD *)s + 12);
          v11 = (unsigned int)v5 >= v10 ? *((_DWORD *)s + 11) - (_DWORD)v5 : v10 - (_DWORD)v5 - 1;
          v45 = v11;
          if ( r )
          {
            *(_DWORD *)v6 = 2 * (r != 1) + 7;
            goto LABEL_36;
          }
        }
        *(_DWORD *)(v6 + 12) = *(unsigned __int8 *)(v6 + 16);
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 20);
        *(_DWORD *)v6 = 1;
        goto LABEL_15;
      case 1:
LABEL_15:
        while ( 2 )
        {
          v12 = *(_DWORD *)(v6 + 12);
          if ( sa >= v12 )
          {
            v13 = (unsigned __int8 *)(*(_DWORD *)(v6 + 8) + 8 * (za & dword_10057020[v12]));
            za >>= v13[1];
            sa -= v13[1];
            v39 = *v13;
            if ( *v13 )
            {
              if ( (v39 & 0x10) != 0 )
              {
                *(_DWORD *)(v6 + 8) = v39 & 0xF;
                *(_DWORD *)(v6 + 4) = *((_DWORD *)v13 + 1);
                *(_DWORD *)v6 = 2;
                goto LABEL_36;
              }
              if ( (v39 & 0x40) != 0 )
              {
                if ( (v39 & 0x20) != 0 )
                {
                  *(_DWORD *)v6 = 7;
                  goto LABEL_36;
                }
                *(_DWORD *)v6 = 9;
                *((_DWORD *)z + 6) = "invalid literal/length code";
LABEL_89:
                v38 = -3;
                goto LABEL_85;
              }
              *(_DWORD *)(v6 + 12) = v39;
              v14 = &v13[8 * *((_DWORD *)v13 + 1)];
            }
            else
            {
              v14 = (unsigned __int8 *)*((_DWORD *)v13 + 1);
              *(_DWORD *)v6 = 6;
            }
            goto LABEL_35;
          }
          if ( v46 )
          {
            r = 0;
            --v46;
            za |= *v47++ << sa;
            sa += 8;
            continue;
          }
          goto LABEL_91;
        }
      case 2:
        while ( 2 )
        {
          v15 = *(_DWORD *)(v6 + 8);
          if ( sa < v15 )
          {
            if ( v46 )
            {
              r = 0;
              --v46;
              za |= *v47++ << sa;
              sa += 8;
              continue;
            }
LABEL_91:
            v38 = r;
            *((_DWORD *)s + 8) = za;
            *((_DWORD *)s + 7) = sa;
            *((_DWORD *)z + 1) = 0;
            goto LABEL_86;
          }
          break;
        }
        v16 = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v6 + 4) += za & dword_10057020[v15];
        za >>= v16;
        sa -= v16;
        *(_DWORD *)(v6 + 12) = *(unsigned __int8 *)(v6 + 17);
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 24);
        *(_DWORD *)v6 = 3;
LABEL_30:
        while ( 1 )
        {
          v17 = *(_DWORD *)(v6 + 12);
          if ( sa >= v17 )
            break;
          if ( !v46 )
            goto LABEL_91;
          r = 0;
          --v46;
          za |= *v47++ << sa;
          sa += 8;
        }
        v18 = (unsigned __int8 *)(*(_DWORD *)(v6 + 8) + 8 * (za & dword_10057020[v17]));
        za >>= v18[1];
        sa -= v18[1];
        v19 = v18;
        v20 = *v18;
        if ( (v20 & 0x10) != 0 )
        {
          *(_DWORD *)(v6 + 8) = v20 & 0xF;
          *(_DWORD *)(v6 + 12) = *((_DWORD *)v19 + 1);
          *(_DWORD *)v6 = 4;
          goto LABEL_36;
        }
        if ( (v20 & 0x40) != 0 )
        {
          *(_DWORD *)v6 = 9;
          *((_DWORD *)z + 6) = "invalid distance code";
          goto LABEL_89;
        }
        *(_DWORD *)(v6 + 12) = v20;
        v14 = &v19[8 * *((_DWORD *)v19 + 1)];
LABEL_35:
        *(_DWORD *)(v6 + 8) = v14;
LABEL_36:
        v8 = v45;
        continue;
      case 3:
        goto LABEL_30;
      case 4:
        while ( 2 )
        {
          v21 = *(_DWORD *)(v6 + 8);
          if ( sa < v21 )
          {
            if ( v46 )
            {
              r = 0;
              --v46;
              za |= *v47++ << sa;
              sa += 8;
              continue;
            }
            goto LABEL_91;
          }
          break;
        }
        v22 = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v6 + 12) += za & dword_10057020[v21];
        za >>= v22;
        sa -= v22;
        *(_DWORD *)v6 = 5;
LABEL_41:
        v23 = *(_DWORD *)(v6 + 12);
        if ( (unsigned int)&v5[-*((_DWORD *)s + 10)] >= v23 )
          v42 = &v5[-v23];
        else
          v42 = &v5[*((_DWORD *)s + 11) - *((_DWORD *)s + 10) - *(_DWORD *)(v6 + 12)];
        v8 = v45;
LABEL_45:
        if ( !*(_DWORD *)(v6 + 4) )
        {
          *(_DWORD *)v6 = 0;
          continue;
        }
        if ( v8 )
          goto LABEL_62;
        if ( v5 == *((_BYTE **)s + 11) )
        {
          v24 = *((_DWORD *)s + 12);
          v25 = *((_DWORD *)s + 10);
          if ( v24 != v25 )
          {
            v5 = (_BYTE *)*((_DWORD *)s + 10);
            v8 = v25 >= v24 ? *((_DWORD *)s + 11) - v25 : v24 - v25 - 1;
            if ( v8 )
              goto LABEL_62;
          }
        }
        *((_DWORD *)s + 13) = v5;
        v26 = inflate_flush(s, z, r);
        v5 = (_BYTE *)*((_DWORD *)s + 13);
        ra = v26;
        v27 = *((_DWORD *)s + 12);
        v40 = v27;
        if ( (unsigned int)v5 >= v27 )
          v8 = *((_DWORD *)s + 11) - (_DWORD)v5;
        else
          v8 = v27 - (_DWORD)v5 - 1;
        v43 = (_BYTE *)*((_DWORD *)s + 11);
        if ( v5 == v43 )
        {
          v28 = *((_DWORD *)s + 10);
          if ( v40 != v28 )
          {
            v5 = (_BYTE *)*((_DWORD *)s + 10);
            if ( v28 >= v40 )
              v8 = (unsigned int)&v43[-v28];
            else
              v8 = v40 - v28 - 1;
          }
        }
        if ( v8 )
        {
LABEL_62:
          r = 0;
          *v5++ = *v42++;
          v45 = --v8;
          if ( v42 == *((_BYTE **)s + 11) )
            v42 = (_BYTE *)*((_DWORD *)s + 10);
          --*(_DWORD *)(v6 + 4);
          goto LABEL_45;
        }
LABEL_92:
        v38 = ra;
LABEL_85:
        *((_DWORD *)s + 8) = za;
        *((_DWORD *)s + 7) = sa;
        *((_DWORD *)z + 1) = v46;
LABEL_86:
        v34 = &v47[-*(_DWORD *)z];
        *(_DWORD *)z = v47;
        *((_DWORD *)z + 2) += v34;
LABEL_87:
        *((_DWORD *)s + 13) = v5;
        return inflate_flush(s, z, v38);
      case 5:
        goto LABEL_41;
      case 6:
        if ( !v8 )
        {
          if ( v5 != *((_BYTE **)s + 11)
            || (v29 = *((_DWORD *)s + 12), v30 = *((_DWORD *)s + 10), v29 == v30)
            || ((v5 = (_BYTE *)*((_DWORD *)s + 10), v30 >= v29)
              ? (v8 = *((_DWORD *)s + 11) - v30)
              : (v8 = v29 - v30 - 1),
                !v8) )
          {
            *((_DWORD *)s + 13) = v5;
            v31 = inflate_flush(s, z, r);
            v5 = (_BYTE *)*((_DWORD *)s + 13);
            ra = v31;
            v32 = *((_DWORD *)s + 12);
            v41 = v32;
            if ( (unsigned int)v5 >= v32 )
              v8 = *((_DWORD *)s + 11) - (_DWORD)v5;
            else
              v8 = v32 - (_DWORD)v5 - 1;
            v44 = (_BYTE *)*((_DWORD *)s + 11);
            if ( v5 == v44 )
            {
              v33 = *((_DWORD *)s + 10);
              if ( v41 != v33 )
              {
                v5 = (_BYTE *)*((_DWORD *)s + 10);
                if ( v33 >= v41 )
                  v8 = (unsigned int)&v44[-v33];
                else
                  v8 = v41 - v33 - 1;
              }
            }
            if ( !v8 )
              goto LABEL_92;
          }
        }
        r = 0;
        *v5++ = *(_BYTE *)(v6 + 8);
        --v8;
        *(_DWORD *)v6 = 0;
        goto LABEL_83;
      case 7:
        if ( sa > 7 )
        {
          sa -= 8;
          ++v46;
          --v47;
        }
        *((_DWORD *)s + 13) = v5;
        v36 = inflate_flush(s, z, r);
        v5 = (_BYTE *)*((_DWORD *)s + 13);
        if ( *((_BYTE **)s + 12) != v5 )
        {
          *((_DWORD *)s + 8) = za;
          *((_DWORD *)s + 7) = sa;
          *((_DWORD *)z + 1) = v46;
          v37 = &v47[-*(_DWORD *)z];
          *(_DWORD *)z = v47;
          *((_DWORD *)z + 2) += v37;
          v38 = v36;
          goto LABEL_87;
        }
        *(_DWORD *)v6 = 8;
LABEL_98:
        v38 = 1;
        goto LABEL_85;
      case 8:
        goto LABEL_98;
      case 9:
        goto LABEL_89;
      default:
        v38 = -2;
        goto LABEL_85;
    }
  }
}

// inflate_codes_free @ 0x10036919
// zlib (internal): free codes state
void inflate_codes_free(void *c, void *z)
{
  (*((void (__cdecl **)(_DWORD, void *))z + 9))(*((_DWORD *)z + 10), c);
}

// huft_build @ 0x1003692A
// zlib (internal): build Huffman decoding tables
int huft_build(
        unsigned int *b,
        unsigned int n,
        unsigned int s,
        unsigned int *d,
        unsigned int *e,
        void **t,
        unsigned int *m,
        void *hp,
        unsigned int *hn)
{
  unsigned int *v9; // eax
  unsigned int *v10; // ecx
  unsigned int *v11; // esi
  unsigned int v12; // edx
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // eax
  int v17; // edx
  int v18; // edx
  unsigned int v19; // esi
  int *v20; // ecx
  int v21; // ebx
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // eax
  int v25; // ebx
  unsigned int *v26; // ecx
  unsigned int v27; // ebx
  int v28; // eax
  int *v29; // eax
  int v30; // ecx
  unsigned int v31; // eax
  int v32; // ebx
  unsigned int v33; // eax
  unsigned int j; // ecx
  unsigned int v35; // esi
  unsigned int v36; // ecx
  unsigned int v37; // eax
  unsigned int v38; // eax
  _DWORD *v39; // edx
  unsigned int v40; // edx
  unsigned int v41; // eax
  int v42; // eax
  unsigned int v43; // esi
  unsigned int **v44; // edx
  unsigned int v45; // esi
  unsigned int v46; // eax
  int v47; // ecx
  int v48; // edx
  unsigned int v49; // eax
  unsigned int v50; // eax
  int v51; // esi
  unsigned int v52; // eax
  unsigned int *v53; // ecx
  unsigned int v54; // esi
  unsigned int i; // eax
  int v56; // ecx
  int v57; // eax
  _DWORD v59[15]; // [esp+Ch] [ebp-A4h] BYREF
  int v60; // [esp+48h] [ebp-68h] BYREF
  _DWORD v61[15]; // [esp+4Ch] [ebp-64h]
  int v62; // [esp+88h] [ebp-28h] BYREF
  _DWORD v63[15]; // [esp+8Ch] [ebp-24h] BYREF
  unsigned int v64; // [esp+C8h] [ebp+18h]
  signed int v65; // [esp+CCh] [ebp+1Ch]
  int v66; // [esp+D0h] [ebp+20h]
  int v67; // [esp+D4h] [ebp+24h]
  signed int v68; // [esp+D8h] [ebp+28h]
  unsigned int *v69; // [esp+DCh] [ebp+2Ch]
  _DWORD *v70; // [esp+E0h] [ebp+30h]
  unsigned int v71; // [esp+E4h] [ebp+34h]
  int v72; // [esp+E8h] [ebp+38h]
  unsigned int v73; // [esp+ECh] [ebp+3Ch]
  unsigned int v74; // [esp+F0h] [ebp+40h]
  unsigned int v75; // [esp+F4h] [ebp+44h]
  int v76; // [esp+F8h] [ebp+48h]
  signed int v77; // [esp+FCh] [ebp+4Ch]
  unsigned int v78; // [esp+100h] [ebp+50h]
  unsigned int *ba; // [esp+10Ch] [ebp+5Ch]
  unsigned int *bb; // [esp+10Ch] [ebp+5Ch]
  unsigned int na; // [esp+110h] [ebp+60h]

  v10 = b;
  v11 = v9;
  v62 = 0;
  memset(v63, 0, sizeof(v63));
  v12 = n;
  do
  {
    ++v63[*v10++ - 1];
    --v12;
  }
  while ( v12 );
  if ( v62 != n )
  {
    v14 = *v9;
    v78 = *v9;
    v15 = 1;
    v16 = 15;
    do
    {
      if ( v63[v15 - 1] )
        break;
      ++v15;
    }
    while ( v15 <= 0xF );
    v77 = v15;
    if ( v14 < v15 )
      v78 = v15;
    do
    {
      if ( v63[v16 - 1] )
        break;
      --v16;
    }
    while ( v16 );
    v68 = v16;
    if ( v78 > v16 )
      v78 = v16;
    *v11 = v78;
    v17 = 1 << v15;
    while ( v15 < v16 )
    {
      v18 = v17 - v63[v15 - 1];
      if ( v18 < 0 )
        return -3;
      ++v15;
      v17 = 2 * v18;
    }
    v19 = v16;
    v20 = &v63[v16 - 1];
    v21 = *v20;
    v22 = v17 - *v20;
    v66 = v22;
    if ( v22 < 0 )
      return -3;
    *v20 = v22 + v21;
    v23 = 0;
    v24 = v16 - 1;
    v61[0] = 0;
    if ( v24 )
    {
      v25 = 0;
      do
      {
        v23 += v63[v25++];
        --v24;
        v61[v25] = v23;
      }
      while ( v24 );
    }
    v26 = b;
    v27 = 0;
    do
    {
      v28 = *v26++;
      ba = v26;
      if ( v28 )
      {
        v29 = &v61[v28 - 1];
        v30 = *v29;
        hn[v30] = v27;
        v22 = v66;
        *v29 = v30 + 1;
        v26 = ba;
      }
      ++v27;
    }
    while ( v27 < n );
    v31 = v61[v19 - 1];
    v76 = -1;
    na = v31;
    bb = hn;
    v32 = -v78;
    v71 = 0;
    v60 = 0;
    v59[0] = 0;
    v69 = 0;
    v75 = 0;
    if ( v77 > v68 )
    {
LABEL_68:
      if ( !v22 || v68 == 1 )
        return 0;
      return -5;
    }
    else
    {
      v67 = v77 - 1;
      v70 = &v63[v77 - 1];
      while ( 1 )
      {
        v72 = *v70;
        if ( v72 )
          break;
LABEL_67:
        ++v77;
        ++v70;
        ++v67;
        if ( v77 > v68 )
          goto LABEL_68;
      }
      while ( 1 )
      {
        --v72;
        v33 = v32 + v78;
        if ( v77 > (int)(v32 + v78) )
          break;
LABEL_50:
        BYTE1(v73) = v77 - v32;
        if ( bb < &hn[na] )
        {
          v49 = *bb;
          if ( *bb >= s )
          {
            v50 = v49 - s;
            LOBYTE(v73) = LOBYTE(e[v50]) + 80;
            v49 = d[v50];
          }
          else
          {
            LOBYTE(v73) = v49 < 0x100 ? 0 : 0x60;
          }
          ++bb;
          v74 = v49;
        }
        else
        {
          LOBYTE(v73) = -64;
        }
        v51 = 1 << (v77 - v32);
        v52 = v71 >> v32;
        if ( v71 >> v32 < v75 )
        {
          v53 = &v69[2 * v52];
          do
          {
            *v53 = v73;
            v53[1] = v74;
            v52 += v51;
            v53 += 2 * v51;
          }
          while ( v52 < v75 );
          v22 = v66;
        }
        v54 = v71;
        for ( i = 1 << v67; (i & v54) != 0; i >>= 1 )
          v54 ^= i;
        v71 = i ^ v54;
        v56 = (i ^ v54) & ((1 << v32) - 1);
        v57 = v76;
        if ( v56 != v61[v76 - 1] )
        {
          do
          {
            v32 -= v78;
            --v57;
          }
          while ( (v71 & ((1 << v32) - 1)) != v61[v57 - 1] );
          v76 = v57;
        }
        if ( !v72 )
          goto LABEL_67;
      }
      for ( j = v32 - v78; ; j = v64 )
      {
        ++v76;
        v32 += v78;
        v35 = v68 - v32;
        v64 = v78 + j;
        v65 = v78 + v33;
        if ( v68 - v32 > v78 )
          v35 = v78;
        v36 = v77 - v32;
        v37 = 1 << (v77 - v32);
        if ( v37 > v72 + 1 )
        {
          v38 = -1 - v72 + v37;
          v39 = v70;
          if ( v36 < v35 && ++v36 < v35 )
          {
            while ( 1 )
            {
              v75 = (unsigned int)(v39 + 1);
              v40 = v39[1];
              v41 = 2 * v38;
              if ( v41 <= v40 )
                break;
              v38 = v41 - v40;
              if ( ++v36 >= v35 )
                break;
              v39 = (_DWORD *)v75;
            }
          }
        }
        v42 = *(_DWORD *)hp;
        v43 = *(_DWORD *)hp + (1 << v36);
        v75 = 1 << v36;
        if ( v43 > 0x5A0 )
          break;
        v44 = (unsigned int **)&v59[v76];
        v69 = &m[2 * v42];
        *v44 = v69;
        *(_DWORD *)hp = v43;
        if ( v76 )
        {
          v45 = v71;
          v61[v76 - 1] = v71;
          BYTE1(v73) = v78;
          LOBYTE(v73) = v36;
          v46 = v45 >> v64;
          v47 = (int)*(v44 - 1);
          v48 = (((int)v69 - v47) >> 3) - (v45 >> v64);
          *(_DWORD *)(v47 + 8 * v46) = v73;
          v74 = v48;
          *(_DWORD *)(v47 + 8 * v46 + 4) = v48;
        }
        else
        {
          *t = v69;
        }
        v33 = v65;
        if ( v77 <= v65 )
        {
          v22 = v66;
          goto LABEL_50;
        }
      }
      return -4;
    }
  }
  *t = 0;
  *v9 = 0;
  return 0;
}

// inflate_trees_bits @ 0x10036CAF
// zlib (internal): build bit length Huffman tree
int inflate_trees_bits(unsigned int *c, unsigned int *bb, void **tb, void *hp, void *z)
{
  unsigned int *v6; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // [esp+4h] [ebp-4h] BYREF
  struct z_stream_s *za; // [esp+20h] [ebp+18h]

  v10 = 0;
  v6 = (unsigned int *)(*((int (__cdecl **)(_DWORD, int, int))z + 8))(*((_DWORD *)z + 10), 19, 4);
  za = (struct z_stream_s *)v6;
  if ( !v6 )
    return -4;
  v8 = huft_build(c, 0x13u, 0x13u, 0, 0, tb, (unsigned int *)hp, &v10, v6);
  v9 = v8;
  if ( v8 == -3 )
  {
    *((_DWORD *)z + 6) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v8 == -5 || !*bb )
  {
    *((_DWORD *)z + 6) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*((void (__cdecl **)(_DWORD, struct z_stream_s *))z + 9))(*((_DWORD *)z + 10), za);
  return v9;
}

// inflate_trees_dynamic @ 0x10036D2E
// zlib (internal): build dynamic Huffman trees
int inflate_trees_dynamic(
        unsigned int nl,
        unsigned int nd,
        unsigned int *c,
        unsigned int *bl,
        unsigned int *bd,
        void **tl,
        void **td,
        void *hp,
        void *z)
{
  unsigned int *v10; // eax
  int v12; // eax
  int v13; // edi
  int v14; // [esp+4h] [ebp-4h] BYREF
  unsigned int *za; // [esp+30h] [ebp+28h]

  v14 = 0;
  v10 = (unsigned int *)(*((int (__cdecl **)(_DWORD, int, int))z + 8))(*((_DWORD *)z + 10), 288, 4);
  za = v10;
  if ( !v10 )
    return -4;
  v12 = huft_build(c, nl, 0x101u, (unsigned int *)&d, (unsigned int *)&e, tl, (unsigned int *)hp, &v14, v10);
  if ( v12 )
  {
    if ( v12 == -3 )
    {
      *((_DWORD *)z + 6) = "oversubscribed literal/length tree";
      goto LABEL_20;
    }
    if ( v12 == -4 )
      goto LABEL_20;
LABEL_18:
    *((_DWORD *)z + 6) = "incomplete literal/length tree";
    goto LABEL_19;
  }
  if ( !*bl )
    goto LABEL_18;
  v12 = huft_build(
          &c[nl],
          nd,
          0,
          (unsigned int *)&dword_1004F968,
          (unsigned int *)&dword_1004F9E0,
          td,
          (unsigned int *)hp,
          &v14,
          za);
  if ( v12 )
  {
    switch ( v12 )
    {
      case -3:
        *((_DWORD *)z + 6) = "oversubscribed distance tree";
        break;
      case -5:
        *((_DWORD *)z + 6) = "incomplete distance tree";
LABEL_19:
        v12 = -3;
        break;
      case -4:
        break;
      default:
LABEL_14:
        *((_DWORD *)z + 6) = "empty distance tree with lengths";
        goto LABEL_19;
    }
LABEL_20:
    v13 = v12;
    goto LABEL_21;
  }
  if ( !*bd && nl > 0x101 )
    goto LABEL_14;
  v13 = 0;
LABEL_21:
  (*((void (__cdecl **)(_DWORD, unsigned int *))z + 9))(*((_DWORD *)z + 10), za);
  return v13;
}

// sub_10036E31 @ 0x10036E31
int __cdecl sub_10036E31(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_10055F18;
  *a2 = dword_10055F1C;
  *a3 = &unk_10055F20;
  *a4 = &unk_10056F20;
  return 0;
}

// inflate_flush @ 0x10036E60
// zlib (internal): flush pending output
int inflate_flush(void *s, void *z, int r)
{
  char *v4; // edx
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // edi
  int (__cdecl *v8)(_DWORD, char *, unsigned int); // eax
  int v9; // eax
  char v10; // al
  unsigned int v11; // ecx
  char *v12; // edi
  char *v13; // eax
  char *v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // edi
  int (__cdecl *v17)(_DWORD, char *, unsigned int); // eax
  int v18; // eax
  char v19; // al
  unsigned int v20; // ecx
  char *v21; // edi
  char *v23; // [esp+Ch] [ebp-8h]
  char *v24; // [esp+Ch] [ebp-8h]
  unsigned int v25; // [esp+10h] [ebp-4h]
  unsigned int v26; // [esp+10h] [ebp-4h]
  char *sa; // [esp+1Ch] [ebp+8h]
  char *sb; // [esp+1Ch] [ebp+8h]
  char *sc; // [esp+1Ch] [ebp+8h]

  v4 = (char *)*((_DWORD *)s + 12);
  v5 = *((_DWORD *)s + 13);
  v23 = (char *)*((_DWORD *)z + 3);
  sa = v4;
  if ( (unsigned int)v4 > v5 )
    v5 = *((_DWORD *)s + 11);
  v6 = *((_DWORD *)z + 4);
  v7 = v5 - (_DWORD)v4;
  v25 = v7;
  if ( v7 > v6 )
  {
    v25 = *((_DWORD *)z + 4);
    v7 = v25;
  }
  if ( v7 && r == -5 )
    r = 0;
  *((_DWORD *)z + 5) += v7;
  *((_DWORD *)z + 4) = v6 - v7;
  v8 = (int (__cdecl *)(_DWORD, char *, unsigned int))*((_DWORD *)s + 14);
  if ( v8 )
  {
    v9 = v8(*((_DWORD *)s + 15), v4, v7);
    v4 = sa;
    *((_DWORD *)s + 15) = v9;
    *((_DWORD *)z + 12) = v9;
  }
  v10 = v7;
  v11 = v7 >> 2;
  qmemcpy(v23, v4, 4 * (v7 >> 2));
  v12 = &v23[4 * (v7 >> 2)];
  v24 = &v23[v25];
  sb = &sa[v25];
  qmemcpy(v12, &v4[4 * v11], v10 & 3);
  v13 = (char *)*((_DWORD *)s + 11);
  if ( sb == v13 )
  {
    v14 = (char *)*((_DWORD *)s + 10);
    sc = v14;
    if ( *((char **)s + 13) == v13 )
      *((_DWORD *)s + 13) = v14;
    v15 = *((_DWORD *)z + 4);
    v16 = *((_DWORD *)s + 13) - (_DWORD)v14;
    v26 = v16;
    if ( v16 > v15 )
    {
      v26 = *((_DWORD *)z + 4);
      v16 = v26;
    }
    if ( v16 && r == -5 )
      r = 0;
    *((_DWORD *)z + 5) += v16;
    *((_DWORD *)z + 4) = v15 - v16;
    v17 = (int (__cdecl *)(_DWORD, char *, unsigned int))*((_DWORD *)s + 14);
    if ( v17 )
    {
      v18 = v17(*((_DWORD *)s + 15), v14, v16);
      v14 = sc;
      *((_DWORD *)s + 15) = v18;
      *((_DWORD *)z + 12) = v18;
    }
    v19 = v16;
    v20 = v16 >> 2;
    qmemcpy(v24, v14, 4 * (v16 >> 2));
    v21 = &v24[4 * (v16 >> 2)];
    v24 += v26;
    sb = &sc[v26];
    qmemcpy(v21, &v14[4 * v20], v19 & 3);
  }
  *((_DWORD *)z + 3) = v24;
  *((_DWORD *)s + 12) = sb;
  return r;
}

// sub_10036F75 @ 0x10036F75
int __cdecl sub_10036F75(__int16 *a1, __int16 *a2, int *a3, int a4, int a5, int a6)
{
  int v6; // ecx
  int v7; // ebx
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int v18; // ecx
  int v19; // ebx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  int v26; // edi
  int *v27; // edi
  int v28; // ecx
  int v29; // ebx
  int v30; // eax
  int v31; // ebx
  int v32; // edx
  int v33; // ebx
  int v34; // edx
  int v35; // eax
  int v36; // edx
  int v37; // esi
  int v38; // ecx
  int v39; // ebx
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // edx
  int v44; // esi
  int result; // eax
  int *v48; // [esp+14h] [ebp-3Ch]
  int *v49; // [esp+14h] [ebp-3Ch]
  int v50; // [esp+18h] [ebp-38h]
  int v51; // [esp+18h] [ebp-38h]
  int v52; // [esp+1Ch] [ebp-34h]
  int v53; // [esp+1Ch] [ebp-34h]
  int v54; // [esp+1Ch] [ebp-34h]
  int v55; // [esp+1Ch] [ebp-34h]
  int v56; // [esp+1Ch] [ebp-34h]
  int v57; // [esp+20h] [ebp-30h]
  int v58; // [esp+20h] [ebp-30h]
  int v59; // [esp+20h] [ebp-30h]
  int v60; // [esp+20h] [ebp-30h]
  int v61; // [esp+24h] [ebp-2Ch]
  int v62; // [esp+24h] [ebp-2Ch]
  int v63; // [esp+28h] [ebp-28h]
  int v64; // [esp+28h] [ebp-28h]
  int v65; // [esp+2Ch] [ebp-24h]
  int v66; // [esp+2Ch] [ebp-24h]
  int v67; // [esp+30h] [ebp-20h]
  int v68; // [esp+30h] [ebp-20h]
  int v69; // [esp+34h] [ebp-1Ch]
  int v70; // [esp+34h] [ebp-1Ch]
  int v71; // [esp+34h] [ebp-1Ch]
  int v72; // [esp+38h] [ebp-18h]
  int v73; // [esp+40h] [ebp-10h]
  int v74; // [esp+4Ch] [ebp-4h]

  v48 = a3;
  v50 = 8;
  do
  {
    v6 = a2[48] * a1[48];
    v7 = a2[16] * a1[16];
    v8 = 6270 * v7;
    v9 = 4433 * (v6 + v7);
    v52 = v9 - 15137 * v6;
    v57 = v9 + v8;
    v10 = *a2 * *a1;
    v11 = a2[32] * a1[32];
    v12 = (v10 + v11) << 13;
    v13 = (v10 - v11) << 13;
    v61 = v57 + v12;
    v63 = v52 + v13;
    v65 = v12 - v57;
    v67 = v13 - v52;
    v69 = a2[56] * a1[56];
    v53 = a2[24] * a1[24];
    v58 = a2[8] * a1[8];
    v14 = a2[40] * a1[40];
    v15 = v58 + v14;
    v16 = -20995 * (v53 + v14);
    v17 = 9633 * (v15 + v53 + v69);
    v18 = v17 - 16069 * (v53 + v69);
    v19 = v17 - 3196 * v15;
    v20 = v18 - 7373 * (v58 + v69);
    v21 = v16 + v18;
    v22 = 2446 * v69 + v20;
    v23 = 16819 * a2[40] * a1[40] + v19 + v16;
    v24 = 25172 * v53 + v21;
    v25 = 12299 * v58 + v19 - 7373 * (v58 + v69);
    v48[32] = (v65 - v22 + 1024) >> 11;
    v48[24] = (v65 + v22 + 1024) >> 11;
    v48[40] = (v67 - v23 + 1024) >> 11;
    v48[48] = (v63 - v24 + 1024) >> 11;
    v48[16] = (v67 + v23 + 1024) >> 11;
    v48[8] = (v63 + v24 + 1024) >> 11;
    v48[56] = (v61 - v25 + 1024) >> 11;
    *v48 = (v25 + v61 + 1024) >> 11;
    ++a1;
    ++v48;
    ++a2;
    --v50;
  }
  while ( v50 );
  v51 = 8;
  v74 = 0;
  v49 = a3;
  do
  {
    v26 = *(_DWORD *)(v74 + a4);
    v74 += 4;
    v27 = (int *)(a5 + v26);
    v28 = v49[6];
    v29 = v49[2];
    v30 = 6270 * v29;
    v31 = 4433 * (v28 + v29);
    v54 = v31 - 15137 * v28;
    v59 = v31 + v30;
    v32 = v49[4];
    v33 = (*v49 + v32) << 13;
    v34 = (*v49 - v32) << 13;
    v62 = v59 + v33;
    v64 = v54 + v34;
    v66 = v33 - v59;
    v68 = v34 - v54;
    v70 = v49[7];
    v55 = v49[3];
    v35 = v49[5];
    v60 = v49[1];
    v73 = 16819 * v35;
    v36 = -20995 * (v55 + v35);
    v37 = 9633 * (v60 + v35 + v55 + v70);
    v38 = v37 - 16069 * (v55 + v70);
    v39 = v37 - 3196 * (v60 + v35);
    v40 = v38 - 7373 * (v60 + v70);
    v41 = v36 + v38;
    v42 = 2446 * v70 + v40;
    v43 = v73 + v39 + v36;
    v44 = 12299 * v60 + v39 - 7373 * (v60 + v70);
    v71 = v42;
    v72 = v43;
    v56 = 25172 * v55 + v41;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v42 + v66 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v62 - v44 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v72 + v68 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v64 - v56 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v56 + v64 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v68 - v72 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v44 + v62 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v66 - v71 + 0x20000) >> 18) & 0x3FF));
    *v27 = v42;
    v27[1] = v43;
    v49 += 8;
    result = --v51;
  }
  while ( v51 );
  return result;
}

// sub_100373D7 @ 0x100373D7
int __cdecl sub_100373D7(__m64 *a1, __m64 *a2, __m64 *a3, int a4, int a5, int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v8; // mm4
  __m64 v9; // mm5
  __m64 v10; // mm0
  __m64 v11; // mm6
  __m64 v12; // mm0
  __m64 v13; // mm6
  __m64 v14; // mm4
  __m64 v15; // mm3
  __m64 v16; // mm5
  __m64 v17; // mm6
  __m64 v18; // mm1
  __m64 v19; // mm0
  __m64 v20; // mm1
  __m64 v21; // mm6
  __m64 v22; // mm0
  __m64 v23; // mm6
  __m64 v24; // mm2
  __m64 v25; // mm1
  __m64 v26; // mm0
  __m64 v27; // mm2
  __m64 v28; // mm1
  __m64 v29; // mm3
  __m64 v30; // mm6
  __m64 v31; // mm4
  __m64 v32; // mm5
  __m64 v33; // mm7
  __m64 v34; // mm0
  __m64 v35; // mm2
  __m64 v36; // mm4
  __m64 v37; // mm1
  __m64 v38; // mm5
  __m64 v39; // mm3
  __m64 v40; // mm0
  __m64 v41; // mm7
  __m64 v42; // mm6
  __m64 v43; // mm1
  __m64 v44; // mm5
  __m64 v45; // mm2
  __m64 v46; // mm4
  __m64 v47; // mm6
  __m64 v48; // mm0
  __m64 v49; // mm1
  __m64 v50; // mm0
  __m64 v51; // mm2
  __m64 v52; // mm0
  __m64 v53; // mm1
  __m64 v54; // mm4
  __m64 v55; // mm7
  __m64 v56; // mm1
  __m64 v57; // mm0
  __m64 v58; // mm6
  __m64 v59; // mm2
  __m64 v60; // mm6
  __m64 v61; // mm0
  __m64 v62; // mm3
  __m64 v63; // mm1
  int result; // eax
  __m64 v65; // mm1
  __m64 v66; // mm4
  __m64 v67; // mm2
  __m64 v68; // mm5
  __m64 v69; // mm7
  __m64 v70; // mm5
  __m64 v71; // mm3
  __m64 v72; // mm4
  __m64 v73; // mm7
  __m64 v74; // mm5
  __m64 v75; // mm3
  __m64 v76; // mm5
  __m64 v77; // mm1
  __m64 v78; // mm0
  __m64 v79; // mm1
  __m64 v80; // mm3
  __m64 v81; // mm2
  __m64 v82; // mm1
  __m64 v83; // mm0
  int v84; // edi
  __m64 v85; // mm3
  unsigned int v86; // eax
  __m64 v87; // mm4
  __m64 v88; // mm2
  __m64 v89; // [esp+Ch] [ebp-9Ch]
  __m64 v90; // [esp+14h] [ebp-94h]
  __m64 v91; // [esp+1Ch] [ebp-8Ch]
  __m64 v92; // [esp+24h] [ebp-84h]
  __m64 v93; // [esp+2Ch] [ebp-7Ch]
  __m64 v94; // [esp+3Ch] [ebp-6Ch]
  __m64 v95; // [esp+44h] [ebp-64h]
  __m64 v96; // [esp+4Ch] [ebp-5Ch]
  __m64 v97; // [esp+5Ch] [ebp-4Ch]
  __m64 v98; // [esp+6Ch] [ebp-3Ch]
  __m64 v99; // [esp+74h] [ebp-34h]
  __m64 v100; // [esp+7Ch] [ebp-2Ch]
  __m64 v101; // [esp+84h] [ebp-24h]
  __m64 v102; // [esp+8Ch] [ebp-1Ch]
  __m64 v103; // [esp+9Ch] [ebp-Ch]
  __m64 v104; // [esp+ACh] [ebp+4h]
  __m64 v105; // [esp+B4h] [ebp+Ch]
  __m64 v106; // [esp+BCh] [ebp+14h]
  __m64 v107; // [esp+CCh] [ebp+24h]
  __m64 v108; // [esp+D4h] [ebp+2Ch]
  __m64 v109; // [esp+DCh] [ebp+34h]
  __m64 v110; // [esp+E4h] [ebp+3Ch]
  __m64 v111; // [esp+ECh] [ebp+44h]
  __m64 *v113; // [esp+F8h] [ebp+50h]
  __m64 *v114; // [esp+F8h] [ebp+50h]
  int v116; // [esp+100h] [ebp+58h]
  int v117; // [esp+104h] [ebp+5Ch]
  int v118; // [esp+104h] [ebp+5Ch]

  v117 = 2;
  v113 = a3;
  do
  {
    v6 = _m_pmullw(a1[4], a2[4]);
    v7 = _m_pmullw(a1[12], a2[12]);
    v8 = _m_pmaddwd(v6, (__m64)0x187E0000187ELL);
    v9 = _m_pmaddwd(_m_psrlqi(v6, 0x10u), (__m64)0x187E0000187ELL);
    v10 = _m_paddw(v6, v7);
    v11 = _m_psrlqi(v10, 0x10u);
    v12 = _m_pmaddwd(v10, (__m64)0x115100001151LL);
    v13 = _m_pmaddwd(v11, (__m64)0x115100001151LL);
    v14 = _m_paddd(v8, v12);
    v15 = _m_paddd(
            _m_paddd(
              _m_pxor(_m_pmaddwd(_m_psrlqi(v7, 0x10u), (__m64)0x3B2100003B21LL), (__m64)-1LL),
              (__m64)0x100000001LL),
            v13);
    v16 = _m_paddd(v9, v13);
    v89 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v7, (__m64)0x3B2100003B21LL), (__m64)-1LL), (__m64)0x100000001LL), v12);
    v17 = _m_pmullw(a1[8], a2[8]);
    v18 = _m_pmullw((__m64)a1->m64_u64, (__m64)a2->m64_u64);
    v19 = _m_paddw(v18, v17);
    v20 = _m_psubw(v18, v17);
    v21 = v19;
    v22 = _m_pslldi(_m_pmaddwd(v19, (__m64)0x100000001LL), 0xDu);
    v23 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v21, 0x10u), (__m64)0x100000001LL), 0xDu);
    v24 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v20, 0x10u), (__m64)0x100000001LL), 0xDu);
    v91 = _m_psubd(v22, v14);
    v93 = _m_paddd(v16, v23);
    v94 = _m_psubd(v23, v16);
    v96 = _m_paddd(v14, v22);
    v25 = _m_pslldi(_m_pmaddwd(v20, (__m64)0x100000001LL), 0xDu);
    v97 = _m_paddd(v15, v24);
    v98 = _m_psubd(v24, v15);
    v100 = _m_paddd(v89, v25);
    v102 = _m_psubd(v25, v89);
    v103 = _m_pmullw(a1[2], a2[2]);
    v104 = _m_pmullw(a1[14], a2[14]);
    v26 = _m_paddw(v104, v103);
    v106 = _m_pmullw(a1[10], a2[10]);
    v107 = _m_pmullw(a1[6], a2[6]);
    v27 = _m_paddw(v106, v107);
    v28 = _m_paddw(v104, v107);
    v29 = _m_paddw(v106, v103);
    v30 = _m_paddw(v28, v29);
    v109 = _m_pmaddwd(v30, (__m64)0x25A1000025A1LL);
    v31 = _m_psrlqi(v27, 0x10u);
    v110 = _m_pmaddwd(_m_psrlqi(v30, 0x10u), (__m64)0x25A1000025A1LL);
    v32 = _m_psrlqi(v28, 0x10u);
    v95 = _m_paddd(_m_pxor(_m_pmaddwd(v26, (__m64)0x1CCD00001CCDLL), (__m64)-1LL), (__m64)0x100000001LL);
    v33 = _m_pmaddwd(_m_psrlqi(v26, 0x10u), (__m64)0x1CCD00001CCDLL);
    v34 = _m_psrlqi(v29, 0x10u);
    v35 = _m_paddd(_m_pxor(_m_pmaddwd(v27, (__m64)0x520300005203LL), (__m64)-1LL), (__m64)0x100000001LL);
    v36 = _m_paddd(_m_pxor(_m_pmaddwd(v31, (__m64)0x520300005203LL), (__m64)-1LL), (__m64)0x100000001LL);
    v101 = _m_paddd(_m_pxor(v33, (__m64)-1LL), (__m64)0x100000001LL);
    v37 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v28, (__m64)0x3EC500003EC5LL), (__m64)-1LL), (__m64)0x100000001LL), v109);
    v38 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v32, (__m64)0x3EC500003EC5LL), (__m64)-1LL), (__m64)0x100000001LL), v110);
    v39 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v29, (__m64)0xC7C00000C7CLL), (__m64)-1LL), (__m64)0x100000001LL), v109);
    v40 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v34, (__m64)0xC7C00000C7CLL), (__m64)-1LL), (__m64)0x100000001LL), v110);
    v111 = _m_paddd(v37, v35);
    v105 = _m_paddd(v38, v36);
    v92 = _m_paddd(_m_pmaddwd(v104, (__m64)0x98E0000098ELL), _m_paddd(v95, v37));
    v108 = _m_paddd(_m_pmaddwd(_m_psrlqi(v104, 0x10u), (__m64)0x98E0000098ELL), _m_paddd(v101, v38));
    v41 = _m_paddd(_m_pmaddwd(v103, (__m64)0x300B0000300BLL), _m_paddd(v39, v95));
    v42 = _m_paddd(_m_pmaddwd(_m_psrlqi(v103, 0x10u), (__m64)0x300B0000300BLL), _m_paddd(v40, v101));
    v99 = _m_paddd(_m_pmaddwd(v106, (__m64)0x41B3000041B3LL), _m_paddd(v35, v39));
    v90 = _m_paddd(_m_pmaddwd(_m_psrlqi(v106, 0x10u), (__m64)0x41B3000041B3LL), _m_paddd(v36, v40));
    v43 = _m_psradi(_m_paddd(_m_psubd(v93, v42), (__m64)0x40000000400LL), 0xBu);
    v44 = _m_paddd(_m_pmaddwd(v107, (__m64)0x625400006254LL), v111);
    v45 = _m_psradi(_m_paddd(_m_psubd(v96, v41), (__m64)0x40000000400LL), 0xBu);
    v46 = _m_paddd(_m_pmaddwd(_m_psrlqi(v107, 0x10u), (__m64)0x625400006254LL), v105);
    v113[14].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v45, v43), _m_punpckhwd(v45, v43));
    v47 = _m_psradi(_m_paddd(_m_paddd(v42, v93), (__m64)0x40000000400LL), 0xBu);
    v48 = _m_psradi(_m_paddd(_m_paddd(v41, v96), (__m64)0x40000000400LL), 0xBu);
    v113->m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v48, v47), _m_punpckhwd(v48, v47));
    v49 = _m_psradi(_m_paddd(_m_psubd(v97, v46), (__m64)0x40000000400LL), 0xBu);
    v50 = _m_psradi(_m_paddd(_m_psubd(v100, v44), (__m64)0x40000000400LL), 0xBu);
    v51 = _m_punpcklwd(v50, v49);
    v52 = _m_punpckhwd(v50, v49);
    v53 = _m_psradi(_m_paddd(_m_paddd(v44, v100), (__m64)0x40000000400LL), 0xBu);
    v113[12].m64_u64 = (unsigned __int64)_m_punpckldq(v51, v52);
    v54 = _m_psradi(_m_paddd(_m_paddd(v46, v97), (__m64)0x40000000400LL), 0xBu);
    v113[2].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v53, v54), _m_punpckhwd(v53, v54));
    v55 = _m_psradi(_m_paddd(_m_paddd(v98, v90), (__m64)0x40000000400LL), 0xBu);
    v56 = _m_psradi(_m_paddd(_m_paddd(v102, v99), (__m64)0x40000000400LL), 0xBu);
    v57 = _m_psradi(_m_paddd(_m_psubd(v98, v90), (__m64)0x40000000400LL), 0xBu);
    v113[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v56, v55), _m_punpckhwd(v56, v55));
    v58 = _m_psradi(_m_paddd(_m_psubd(v102, v99), (__m64)0x40000000400LL), 0xBu);
    v59 = _m_punpckldq(_m_punpcklwd(v58, v57), _m_punpckhwd(v58, v57));
    v60 = _m_psradi(_m_paddd(_m_paddd(v91, v92), (__m64)0x40000000400LL), 0xBu);
    v61 = _m_psradi(_m_paddd(_m_paddd(v94, v108), (__m64)0x40000000400LL), 0xBu);
    v62 = _m_psradi(_m_paddd(_m_psubd(v91, v92), (__m64)0x40000000400LL), 0xBu);
    v113[10].m64_u64 = (unsigned __int64)v59;
    v63 = _m_psradi(_m_paddd(_m_psubd(v94, v108), (__m64)0x40000000400LL), 0xBu);
    v113[6].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v60, v61), _m_punpckhwd(v60, v61));
    ++a1;
    ++a2;
    v113[8].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v62, v63), _m_punpckhwd(v62, v63));
    ++v113;
    result = --v117;
  }
  while ( v117 );
  v118 = 8;
  v114 = a3;
  v116 = 0;
  do
  {
    v65 = v114[1];
    v66 = _m_paddw((__m64)v114->m64_u64, v65);
    v67 = _m_pmaddwd(v66, (__m64)0x115100000000LL);
    v68 = _m_pmaddwd(_m_punpckhdq((__m64)v114->m64_u64, v65), (__m64)0x3B210000187ELL);
    v69 = _m_psradi(_m_pslldi(_m_punpckldq(v66, _m_psubw((__m64)v114->m64_u64, v65)), 0x10u), 3u);
    v70 = _m_paddd(
            _m_punpckldq(v68, _m_psrlqi(_m_paddd(_m_pxor(v68, (__m64)-1LL), (__m64)0x100000001LL), 0x20u)),
            _m_punpckhdq(v67, v67));
    v71 = v66;
    v72 = _m_paddd(v69, v70);
    v73 = _m_psubd(v69, v70);
    v74 = _m_pmaddwd(_m_paddw(_m_punpckldq(v71, v71), v71), (__m64)0x25A1000000000000LL);
    v75 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v71, (__m64)0x3EC500000C7C0000LL), (__m64)-1LL), (__m64)0x100000001LL),
            _m_punpckhdq(v74, v74));
    v76 = _m_paddd(
            _m_pxor(
              _m_pmaddwd(
                _m_paddw(
                  _m_punpckhdq((__m64)v114->m64_u64, _m_punpckldq((__m64)v114->m64_u64, (__m64)v114->m64_u64)),
                  v65),
                (__m64)0x1CCD000052030000LL),
              (__m64)-1LL),
            (__m64)0x100000001LL);
    v77 = _m_paddd(_m_pmaddwd(v65, (__m64)0x98E000041B30000LL), _m_paddd(v76, v75));
    v78 = _m_paddd(
            _m_pmaddwd((__m64)v114->m64_u64, (__m64)0x62540000300B0000LL),
            _m_paddd(_m_punpckhdq(v76, _m_punpckldq(v76, v76)), v75));
    v79 = _m_punpckhdq(v77, _m_punpckldq(v77, v77));
    v80 = _m_psubd(v72, v78);
    v81 = _m_psubd(v73, v79);
    v82 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v79, v73), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    v83 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v78, v72), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    BYTE1(result) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v82));
    v84 = *(_DWORD *)(v116 + a4);
    LOBYTE(result) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v82, 0x20u)));
    v116 += 4;
    v85 = _m_pand(_m_psradi(_m_paddd(v80, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    v86 = result << 16;
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v83));
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v83, 0x20u)));
    v87 = _mm_cvtsi32_si64(v86);
    v88 = _m_pand(_m_psradi(_m_paddd(v81, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v85));
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v85, 0x20u)));
    v86 <<= 16;
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v88));
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v88, 0x20u)));
    v114 += 2;
    *(__m64 *)(a5 + v84) = _m_punpckldq(v87, _mm_cvtsi32_si64(v86));
    result = v118 - 1;
    v118 = result;
  }
  while ( result );
  _m_empty();
  return result;
}

// sub_10037A8F @ 0x10037A8F
__int16 __cdecl sub_10037A8F(_WORD *a1, _WORD *a2, _WORD *a3, int a4, int a5, int a6)
{
  __int16 v6; // bx
  __int16 v7; // dx
  __int16 v8; // ax
  __int16 v9; // bx
  __int16 v10; // bx
  __int16 v11; // ax
  __int16 v12; // bx
  __int16 v13; // cx
  __int16 v14; // ax
  __int16 v15; // bx
  __int16 v16; // dx
  __int16 v17; // bx
  __int16 v18; // cx
  __int16 v19; // ax
  int v20; // ecx
  __int16 v21; // dx
  int v22; // ebx
  __int16 v23; // dx
  __int16 v24; // dx
  _BYTE *v25; // edi
  __int16 v26; // bx
  __int16 v27; // dx
  __int16 v28; // ax
  __int16 v29; // bx
  __int16 v30; // bx
  __int16 v31; // ax
  __int16 v32; // bx
  __int16 v33; // cx
  __int16 v34; // ax
  __int16 v35; // bx
  __int16 v36; // dx
  __int16 v37; // bx
  __int16 v38; // cx
  __int16 v39; // ax
  int v40; // ecx
  __int16 v41; // dx
  int v42; // ebx
  __int16 v43; // dx
  __int16 result; // ax
  _WORD *v47; // [esp+14h] [ebp-24h]
  _WORD *v48; // [esp+14h] [ebp-24h]
  int v49; // [esp+18h] [ebp-20h]
  __int16 v50; // [esp+1Ch] [ebp-1Ch]
  __int16 v51; // [esp+1Ch] [ebp-1Ch]
  __int16 v52; // [esp+20h] [ebp-18h]
  __int16 v53; // [esp+20h] [ebp-18h]
  __int16 v54; // [esp+20h] [ebp-18h]
  __int16 v55; // [esp+20h] [ebp-18h]
  __int16 v56; // [esp+20h] [ebp-18h]
  __int16 v57; // [esp+24h] [ebp-14h]
  __int16 v58; // [esp+24h] [ebp-14h]
  __int16 v59; // [esp+28h] [ebp-10h]
  __int16 v60; // [esp+28h] [ebp-10h]
  __int16 v61; // [esp+2Ch] [ebp-Ch]
  __int16 v62; // [esp+2Ch] [ebp-Ch]
  __int16 v63; // [esp+30h] [ebp-8h]
  __int16 v64; // [esp+30h] [ebp-8h]
  __int16 v65; // [esp+30h] [ebp-8h]
  __int16 v66; // [esp+30h] [ebp-8h]
  __int16 v67; // [esp+34h] [ebp-4h]

  v47 = a2;
  v50 = 8;
  do
  {
    v6 = a3[32] * a1[32];
    v7 = a3[48] * a1[48];
    v52 = *a3 * *a1;
    v8 = v6 + v52;
    v53 = v52 - v6;
    v9 = a3[16] * a1[16];
    v57 = v7 + v9 + v8;
    v59 = v8 - (v7 + v9);
    v10 = ((362 * (__int16)(v9 - v7)) >> 8) - (v7 + v9);
    v11 = v10 + v53;
    v54 = v53 - v10;
    v61 = v11;
    v12 = a3[56] * a1[56];
    v13 = a3[24] * a1[24];
    v63 = a3[8] * a1[8];
    v14 = v12 + v63;
    v64 = v63 - v12;
    v15 = a3[40] * a1[40];
    v16 = v13 + v15;
    v17 = v15 - v13;
    v18 = v14;
    v19 = v16 + v14;
    v20 = (__int16)(v18 - v16);
    v21 = v17;
    v22 = (473 * (__int16)(v64 + v17)) >> 8;
    v23 = v22 + ((-669 * v21) >> 8) - v19;
    *v47 = v57 + v19;
    v47[56] = v57 - v19;
    v47[8] = v61 + v23;
    v47[48] = v61 - v23;
    v24 = ((362 * v20) >> 8) - v23;
    v47[16] = v54 + v24;
    v47[40] = v54 - v24;
    LOWORD(v20) = v24 + ((277 * v64) >> 8) - v22;
    v47[32] = v59 + v20;
    v47[24] = v59 - v20;
    ++a1;
    ++a3;
    ++v47;
    --v50;
  }
  while ( v50 );
  v49 = 0;
  v51 = 8;
  v48 = a2;
  do
  {
    v25 = (_BYTE *)(a5 + *(_DWORD *)(v49 + a4));
    v49 += 4;
    v26 = v48[4];
    v27 = v48[6];
    v28 = v26 + *v48;
    v55 = *v48 - v26;
    v29 = v48[2];
    v58 = v27 + v29 + v28;
    v60 = v28 - (v27 + v29);
    v30 = ((362 * (__int16)(v29 - v27)) >> 8) - (v27 + v29);
    v31 = v30 + v55;
    v56 = v55 - v30;
    v62 = v31;
    v32 = v48[7];
    v33 = v48[3];
    v65 = v48[1];
    v34 = v32 + v65;
    v66 = v65 - v32;
    v35 = v48[5];
    v36 = v33 + v35;
    v37 = v35 - v33;
    v38 = v34;
    v39 = v36 + v34;
    v40 = (__int16)(v38 - v36);
    v41 = v37;
    v42 = (473 * (__int16)(v66 + v37)) >> 8;
    v43 = v42 + ((-669 * v41) >> 8) - v39;
    LOWORD(v40) = ((362 * v40) >> 8) - v43;
    v67 = v40 + ((277 * v66) >> 8) - v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v58 - v39) >> 5) & 0x3FF));
    *v25 = *(_BYTE *)(a6 + (((__int16)(v58 + v39) >> 5) & 0x3FF));
    v25[7] = v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v62 - v43) >> 5) & 0x3FF));
    v25[1] = *(_BYTE *)(a6 + (((__int16)(v62 + v43) >> 5) & 0x3FF));
    v25[6] = v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v56 - v40) >> 5) & 0x3FF));
    v25[2] = *(_BYTE *)(a6 + (((__int16)(v56 + v40) >> 5) & 0x3FF));
    v25[5] = v42;
    LOBYTE(v39) = *(_BYTE *)(a6 + (((__int16)(v60 - v67) >> 5) & 0x3FF));
    v25[4] = *(_BYTE *)(a6 + (((__int16)(v60 + v67) >> 5) & 0x3FF));
    v25[3] = v39;
    v48 += 8;
    result = --v51;
  }
  while ( v51 );
  return result;
}

// sub_10037DEA @ 0x10037DEA
char __cdecl sub_10037DEA(__m64 *a1, __m64 *a2, __m64 *a3, _DWORD *a4, int a5, int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm6
  __m64 v10; // mm2
  __m64 v11; // mm4
  __m64 v12; // mm3
  __m64 v13; // mm4
  __m64 v14; // mm5
  __m64 v15; // mm6
  __m64 v16; // mm0
  __m64 v17; // mm3
  __m64 v18; // mm7
  __m64 v19; // mm4
  __m64 v20; // mm3
  __m64 v21; // mm0
  __m64 v22; // mm5
  __m64 v23; // mm4
  __m64 v24; // mm0
  __m64 v25; // mm4
  __m64 v26; // mm5
  __m64 v27; // mm2
  __m64 v28; // mm1
  __m64 v29; // mm0
  __m64 v30; // mm3
  __m64 v31; // mm4
  __m64 v32; // mm1
  __m64 v33; // mm2
  __m64 v34; // mm4
  __m64 v35; // mm0
  __m64 v36; // mm6
  __m64 v37; // mm3
  __m64 v38; // mm0
  __m64 v39; // mm1
  __m64 m64_u64; // mm6
  __m64 v41; // mm1
  __m64 v42; // mm7
  __m64 v43; // mm5
  __m64 v44; // mm2
  __m64 v45; // mm4
  __m64 v46; // mm0
  __m64 v47; // mm1
  __m64 v48; // mm4
  __m64 v49; // mm3
  __m64 v50; // mm1
  __m64 v51; // mm6
  __m64 v52; // mm5
  __m64 v53; // mm6
  __m64 v54; // mm7
  __m64 v55; // mm3
  __m64 v56; // mm0
  __m64 v57; // mm3
  __m64 v58; // mm4
  __m64 v59; // mm6
  __m64 v60; // mm5
  __m64 v61; // mm6
  __m64 v62; // mm4
  __m64 v63; // mm5
  __m64 v64; // mm1
  __m64 v65; // mm2
  __m64 v66; // mm7
  __m64 v67; // mm3
  __m64 v68; // mm6
  __m64 v69; // mm3
  __m64 v70; // mm1
  __m64 v71; // mm4
  __m64 v72; // mm0
  __m64 v73; // mm2
  __m64 v74; // mm6
  __m64 v75; // mm1
  __m64 v76; // mm0
  __m64 v77; // mm5
  __m64 v78; // mm6
  __m64 v79; // mm0
  __m64 v80; // mm5
  __m64 v81; // mm0
  __m64 v82; // mm6
  __m64 v83; // mm2
  __m64 v84; // mm3
  __m64 v85; // mm7
  __m64 v86; // mm2
  __m64 v87; // mm5
  __m64 v88; // mm4
  __m64 v89; // mm3
  __m64 v90; // mm2
  __m64 v91; // mm7
  __m64 v92; // mm3
  __m64 v93; // mm1
  __m64 v94; // mm2
  __m64 v95; // mm0
  __m64 v96; // mm2
  __m64 v97; // mm1
  __m64 v98; // mm4
  __m64 v99; // mm3
  __m64 v100; // mm4
  __m64 v101; // mm1
  __m64 v102; // mm5
  __m64 v103; // mm0
  __m64 v104; // mm1
  __m64 v105; // mm3
  __m64 v106; // mm2
  __m64 v107; // mm5
  __m64 v108; // mm4
  __m64 v109; // mm1
  __m64 v110; // mm0
  __m64 v111; // mm3
  __m64 v112; // mm1
  __m64 v113; // mm4
  __m64 v114; // mm2
  __m64 v115; // mm0
  __m64 v116; // mm2
  __m64 v117; // mm0
  __m64 v118; // mm2
  __m64 v119; // mm5
  __m64 v120; // mm4
  __m64 v121; // mm2
  __m64 v122; // mm1
  __m64 v123; // mm4
  __m64 v124; // mm6
  __m64 v125; // mm5
  __m64 v126; // mm0
  __m64 v127; // mm3
  __m64 v128; // mm7
  __m64 v129; // mm4
  __m64 v130; // mm3
  __m64 v131; // mm0
  __m64 v132; // mm2
  __m64 v133; // mm6
  __m64 v134; // mm4
  __m64 v135; // mm5
  __m64 v136; // mm1
  __m64 v137; // mm0
  __m64 v138; // mm3
  __m64 v139; // mm1
  __m64 v140; // mm2
  __m64 v141; // mm4
  __m64 v142; // mm0
  __m64 v143; // mm6
  __m64 v144; // mm3
  __m64 v145; // mm0
  __m64 v146; // mm1
  __m64 v147; // mm6
  __m64 v148; // mm1
  __m64 v149; // mm7
  __m64 v150; // mm5
  __m64 v151; // mm2
  __m64 v152; // mm6
  __m64 v153; // mm4
  __m64 v154; // mm3
  __m64 v155; // mm1
  __m64 v156; // mm5
  __m64 v157; // mm7
  __m64 v158; // mm6
  __m64 v159; // mm4
  __m64 v160; // mm3
  __m64 v161; // mm0
  __m64 v162; // mm3
  __m64 v163; // mm6
  __m64 v164; // mm5
  __m64 v165; // mm6
  __m64 v166; // mm4
  __m64 v167; // mm5
  __m64 v168; // mm1
  __m64 v169; // mm2
  __m64 v170; // mm4
  __m64 v171; // mm2
  __m64 v172; // mm3
  __m64 v173; // mm6
  __m64 v174; // mm3
  __m64 v175; // mm1
  __m64 v176; // mm4
  __m64 v177; // mm2
  __m64 v178; // mm6
  __m64 v179; // mm1
  __m64 v180; // mm5
  __m64 v181; // mm0
  __m64 v182; // mm6
  _BYTE *v183; // ebx
  __m64 v184; // mm0
  __m64 v185; // mm5
  __m64 v186; // mm0
  __m64 v187; // mm2
  __m64 v188; // mm6
  __m64 v189; // mm3
  __m64 v190; // mm7
  __m64 v191; // mm2
  __m64 v192; // mm4
  __m64 v193; // mm5
  __m64 v194; // mm5
  __m64 v195; // mm5
  _BYTE *v196; // ebx
  __m64 v197; // mm4
  __m64 v198; // mm3
  __m64 v199; // mm4
  __m64 v200; // mm4
  __m64 v201; // mm4
  _BYTE *v202; // ecx
  __m64 v203; // mm0
  __m64 v204; // mm0
  __m64 v205; // mm0
  _BYTE *v206; // ebx
  __m64 v207; // mm3
  __m64 v208; // mm3
  __m64 v209; // mm3
  _BYTE *v210; // ebx
  __m64 v211; // mm4
  __m64 v212; // mm5
  __m64 v213; // mm2
  __m64 v214; // mm3
  __m64 v215; // mm7
  __m64 v216; // mm3
  __m64 v217; // mm1
  __m64 v218; // mm6
  __m64 v219; // mm6
  __m64 v220; // mm6
  _BYTE *v221; // ebx
  __m64 v222; // mm2
  __m64 v223; // mm2
  __m64 v224; // mm2
  _BYTE *v225; // ecx
  __m64 v226; // mm5
  __m64 v227; // mm5
  __m64 v228; // mm5
  _BYTE *v229; // ebx
  __m64 v230; // mm1
  __m64 v231; // mm1
  __m64 v232; // mm1
  _BYTE *v233; // ebx
  __m64 v234; // mm1
  __m64 v235; // mm2
  __m64 v236; // mm0
  __m64 v237; // mm2
  __m64 v238; // mm4
  __m64 v239; // mm1
  __m64 v240; // mm5
  __m64 v241; // mm3
  __m64 v242; // mm4
  __m64 v243; // mm1
  __m64 v244; // mm0
  __m64 v245; // mm1
  __m64 v246; // mm3
  __m64 v247; // mm0
  __m64 v248; // mm0
  __m64 v249; // mm0
  _BYTE *v250; // ebx
  __m64 v251; // mm2
  __m64 v252; // mm5
  __m64 v253; // mm4
  __m64 v254; // mm1
  __m64 v255; // mm1
  __m64 v256; // mm1
  _BYTE *v257; // ecx
  __m64 v258; // mm0
  __m64 v259; // mm1
  __m64 v260; // mm3
  __m64 v261; // mm1
  __m64 v262; // mm4
  __m64 v263; // mm2
  __m64 v264; // mm2
  __m64 v265; // mm2
  _BYTE *v266; // ebx
  __m64 v267; // mm2
  __m64 v268; // mm5
  __m64 v269; // mm5
  __m64 v270; // mm5
  __m64 v271; // mm0
  __m64 v272; // mm2
  __m64 v273; // mm4
  __m64 v274; // mm5
  _BYTE *v275; // ebx
  __m64 v276; // mm3
  __m64 v277; // mm3
  __m64 v278; // mm3
  _BYTE *v279; // ebx
  __m64 v280; // mm4
  __m64 v281; // mm4
  __m64 v282; // mm4
  _BYTE *v283; // ecx
  __m64 v284; // mm1
  __m64 v285; // mm1
  __m64 v286; // mm1
  _BYTE *v287; // ebx
  __m64 v288; // mm5
  __m64 v289; // mm5
  __m64 v290; // mm5
  char result; // al
  __m64 v292; // [esp+14h] [ebp-10h]
  __m64 v293; // [esp+14h] [ebp-10h]
  __m64 v294; // [esp+1Ch] [ebp-8h]

  v6 = _m_pmullw(a1[12], a3[12]);
  v7 = _m_pmullw(a1[4], a3[4]);
  v8 = _m_pmullw(a1[8], a3[8]);
  v9 = _m_psubw(v7, v6);
  v10 = _m_paddw(v7, v6);
  v11 = _m_pmullw((__m64)a1->m64_u64, (__m64)a3->m64_u64);
  v12 = _m_paddw(v11, v8);
  v13 = _m_psubw(v11, v8);
  v14 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v9, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v9, 0), (__m64)0x16A0000016ALL), 8u)),
          v10);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v12, v10);
  a2[12].m64_u64 = (unsigned __int64)_m_paddw(v14, v13);
  v15 = _m_psubw(v12, v10);
  a2->m64_u64 = (unsigned __int64)_m_psubw(v13, v14);
  v16 = _m_pmullw(a1[6], a3[6]);
  v17 = _m_pmullw(a1[10], a3[10]);
  v18 = _m_psubw(v17, v16);
  v19 = _m_pmullw(a1[14], a3[14]);
  v20 = _m_paddw(v17, v16);
  v21 = _m_pmullw(a1[2], a3[2]);
  v22 = _m_paddw(v21, v19);
  v23 = _m_psubw(v21, v19);
  v292 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v23, 0), (__m64)0x11500000115LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v23, 0), (__m64)0x11500000115LL), 8u));
  v24 = _m_paddw(v18, v23);
  v25 = v22;
  v26 = _m_paddw(v22, v20);
  v27 = _m_psubw(v25, v20);
  v28 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v24, 0), (__m64)0x1D9000001D9LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v24, 0), (__m64)0x1D9000001D9LL), 8u));
  v29 = _m_psubw(v292, v28);
  v30 = v15;
  v31 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v27, 0), (__m64)0x16A0000016ALL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v27, 0), (__m64)0x16A0000016ALL), 8u));
  v32 = _m_psubw(
          _m_paddw(
            v28,
            _m_packssdw(
              _m_psradi(_m_pmaddwd(_m_punpcklwd(v18, 0), (__m64)0xFD630000FD63LL), 8u),
              _m_psradi(_m_pmaddwd(_m_punpckhwd(v18, 0), (__m64)0xFD630000FD63LL), 8u))),
          v26);
  v33 = a2[12];
  v34 = _m_psubw(v31, v32);
  v35 = _m_paddw(v29, v34);
  v36 = _m_psubw(v15, v35);
  v37 = _m_paddw(v30, v35);
  v38 = v32;
  v39 = a2[4];
  a2[8].m64_u64 = (unsigned __int64)v37;
  a2[6].m64_u64 = (unsigned __int64)v36;
  m64_u64 = (__m64)a2->m64_u64;
  a2->m64_u64 = (unsigned __int64)_m_paddw(v39, v26);
  a2[14].m64_u64 = (unsigned __int64)_m_psubw(v39, v26);
  a2[2].m64_u64 = (unsigned __int64)_m_paddw(v33, v38);
  a2[12].m64_u64 = (unsigned __int64)_m_psubw(v33, v38);
  v41 = _m_pmullw(a1[5], a3[5]);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(m64_u64, v34);
  a2[10].m64_u64 = (unsigned __int64)_m_psubw(m64_u64, v34);
  v42 = _m_pmullw(a1[13], a3[13]);
  v43 = _m_pmullw(a1[9], a3[9]);
  v44 = _m_paddw(v41, v42);
  v45 = _m_psubw(v41, v42);
  v46 = _m_pmullw(a1[11], a3[11]);
  v47 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v45, 0), (__m64)0x16A0000016ALL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v45, 0), (__m64)0x16A0000016ALL), 8u));
  v48 = _m_pmullw(a1[1], a3[1]);
  v49 = _m_paddw(v48, v43);
  v50 = _m_psubw(v47, v44);
  v51 = a1[7];
  v52 = _m_psubw(v48, v43);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v49, v44);
  v53 = _m_pmullw(v51, a3[7]);
  v54 = _m_psubw(v49, v44);
  a2[13].m64_u64 = (unsigned __int64)_m_paddw(v52, v50);
  v55 = v46;
  a2[9].m64_u64 = (unsigned __int64)_m_psubw(v52, v50);
  v56 = _m_paddw(v46, v53);
  v57 = _m_psubw(v55, v53);
  v58 = _m_pmullw(a1[15], a3[15]);
  v294 = v54;
  v59 = _m_pmullw(a1[3], a3[3]);
  v60 = _m_paddw(v59, v58);
  v61 = _m_psubw(v59, v58);
  v62 = v60;
  v63 = _m_paddw(v60, v56);
  v64 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v57, 0), (__m64)0xFD630000FD63LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v57, 0), (__m64)0xFD630000FD63LL), 8u));
  v65 = _m_psubw(v62, v56);
  v66 = _m_paddw(v57, v61);
  v67 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v66, 0), (__m64)0x1D9000001D9LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v66, 0), (__m64)0x1D9000001D9LL), 8u));
  v68 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v61, 0), (__m64)0x11500000115LL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v61, 0), (__m64)0x11500000115LL), 8u)),
          v67);
  v69 = _m_psubw(_m_paddw(v67, v64), v63);
  v70 = a2[5];
  v71 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v65, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v65, 0), (__m64)0x16A0000016ALL), 8u)),
          v69);
  v72 = _m_paddw(v70, v63);
  v73 = a2[13];
  v74 = _m_paddw(v68, v71);
  v75 = _m_psubw(v70, v63);
  a2[1].m64_u64 = (unsigned __int64)v72;
  v76 = a2[9];
  v77 = _m_paddw(v294, v74);
  a2[7].m64_u64 = (unsigned __int64)_m_psubw(v294, v74);
  a2[3].m64_u64 = (unsigned __int64)_m_paddw(v73, v69);
  v78 = _m_psubw(v76, v71);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v76, v71);
  v79 = v77;
  v80 = _m_punpcklwd(v77, v78);
  v81 = _m_punpckhwd(v79, v78);
  v82 = (__m64)a2->m64_u64;
  v83 = _m_psubw(v73, v69);
  v84 = _m_punpcklwd(v83, v75);
  v85 = a2[2];
  v86 = _m_punpckhwd(v83, v75);
  a2[9].m64_u64 = (unsigned __int64)_m_punpckldq(v80, v84);
  a2[11].m64_u64 = (unsigned __int64)_m_punpckhdq(v80, v84);
  a2[13].m64_u64 = (unsigned __int64)_m_punpckldq(v81, v86);
  a2[15].m64_u64 = (unsigned __int64)_m_punpckhdq(v81, v86);
  v87 = _m_punpckhwd(v82, v85);
  v88 = a2[6];
  v89 = a2[4];
  v90 = _m_punpcklwd(v82, v85);
  v91 = _m_punpcklwd(v89, v88);
  v92 = _m_punpckhwd(v89, v88);
  a2->m64_u64 = (unsigned __int64)_m_punpckldq(v90, v91);
  a2[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v90, v91);
  a2[4].m64_u64 = (unsigned __int64)_m_punpckldq(v87, v92);
  a2[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v87, v92);
  v93 = a2[3];
  v94 = a2[1];
  v95 = _m_punpcklwd(v94, v93);
  v96 = _m_punpckhwd(v94, v93);
  v97 = a2[7];
  v98 = a2[5];
  v99 = _m_punpcklwd(v98, v97);
  v100 = _m_punpckhwd(v98, v97);
  v101 = v95;
  v102 = v96;
  v103 = _m_punpckldq(v95, v99);
  v104 = _m_punpckhdq(v101, v99);
  v105 = a2[8];
  a2[8].m64_u64 = (unsigned __int64)v103;
  v106 = _m_punpckldq(v96, v100);
  v107 = _m_punpckhdq(v102, v100);
  v108 = a2[10];
  a2[10].m64_u64 = (unsigned __int64)v104;
  v109 = v105;
  v110 = a2[12];
  v111 = _m_punpcklwd(v105, v108);
  v112 = _m_punpckhwd(v109, v108);
  v113 = a2[14];
  a2[12].m64_u64 = (unsigned __int64)v106;
  v114 = v110;
  a2[14].m64_u64 = (unsigned __int64)v107;
  v115 = _m_punpcklwd(v110, v113);
  v116 = _m_punpckhwd(v114, v113);
  a2[1].m64_u64 = (unsigned __int64)_m_punpckldq(v111, v115);
  a2[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v111, v115);
  a2[5].m64_u64 = (unsigned __int64)_m_punpckldq(v112, v116);
  a2[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v112, v116);
  v117 = a2[12];
  v118 = a2[4];
  v119 = a2[8];
  v120 = _m_psubw(v118, v117);
  v121 = _m_paddw(v118, v117);
  v122 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v120, 0), (__m64)0x16A0000016ALL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v120, 0), (__m64)0x16A0000016ALL), 8u));
  v123 = _m_psubw((__m64)a2->m64_u64, v119);
  v124 = _m_paddw((__m64)a2->m64_u64, v119);
  v125 = _m_psubw(v122, v121);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v124, v121);
  a2[12].m64_u64 = (unsigned __int64)_m_paddw(v125, v123);
  a2->m64_u64 = (unsigned __int64)_m_psubw(v123, v125);
  v126 = a2[6];
  v127 = a2[10];
  v128 = _m_psubw(v127, v126);
  v129 = a2[14];
  v130 = _m_paddw(v127, v126);
  v293 = _m_psubw(v124, v121);
  v131 = a2[2];
  v132 = _m_psubw(v131, v129);
  v133 = _m_paddw(v128, v132);
  v134 = _m_paddw(v131, v129);
  v135 = _m_paddw(v134, v130);
  v136 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v133, 0), (__m64)0x1D9000001D9LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v133, 0), (__m64)0x1D9000001D9LL), 8u));
  v137 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v132, 0), (__m64)0x11500000115LL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v132, 0), (__m64)0x11500000115LL), 8u)),
           v136);
  v138 = _m_psubw(v134, v130);
  v139 = _m_psubw(
           _m_paddw(
             v136,
             _m_packssdw(
               _m_psradi(_m_pmaddwd(_m_punpcklwd(v128, 0), (__m64)0xFD630000FD63LL), 8u),
               _m_psradi(_m_pmaddwd(_m_punpckhwd(v128, 0), (__m64)0xFD630000FD63LL), 8u))),
           v135);
  v140 = a2[12];
  v141 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v138, 0), (__m64)0x16A0000016ALL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v138, 0), (__m64)0x16A0000016ALL), 8u)),
           v139);
  v142 = _m_paddw(v137, v141);
  v143 = _m_psubw(v293, v142);
  v144 = _m_paddw(v293, v142);
  v145 = v139;
  v146 = a2[4];
  a2[8].m64_u64 = (unsigned __int64)v144;
  a2[6].m64_u64 = (unsigned __int64)v143;
  v147 = (__m64)a2->m64_u64;
  a2->m64_u64 = (unsigned __int64)_m_paddw(v146, v135);
  a2[14].m64_u64 = (unsigned __int64)_m_psubw(v146, v135);
  a2[2].m64_u64 = (unsigned __int64)_m_paddw(v140, v145);
  a2[12].m64_u64 = (unsigned __int64)_m_psubw(v140, v145);
  v148 = a2[5];
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v147, v141);
  a2[10].m64_u64 = (unsigned __int64)_m_psubw(v147, v141);
  v149 = a2[13];
  v150 = a2[9];
  v151 = _m_paddw(v148, v149);
  v152 = _m_psubw(v148, v149);
  v153 = a2[1];
  v154 = _m_paddw(v153, v150);
  v155 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v152, 0), (__m64)0x16A0000016ALL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v152, 0), (__m64)0x16A0000016ALL), 8u)),
           v151);
  v156 = _m_psubw(v153, v150);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v154, v151);
  a2[13].m64_u64 = (unsigned __int64)_m_paddw(v156, v155);
  v157 = _m_psubw(v154, v151);
  a2[9].m64_u64 = (unsigned __int64)_m_psubw(v156, v155);
  v158 = a2[7];
  v159 = a2[15];
  v160 = a2[11];
  v161 = _m_paddw(v160, v158);
  v162 = _m_psubw(v160, v158);
  v163 = a2[3];
  v164 = _m_paddw(v163, v159);
  v165 = _m_psubw(v163, v159);
  v166 = v164;
  v167 = _m_paddw(v164, v161);
  v168 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v162, 0), (__m64)0xFD630000FD63LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v162, 0), (__m64)0xFD630000FD63LL), 8u));
  v169 = _m_psubw(v166, v161);
  v170 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v169, 0), (__m64)0x16A0000016ALL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v169, 0), (__m64)0x16A0000016ALL), 8u));
  v171 = _m_paddw(v162, v165);
  v172 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v171, 0), (__m64)0x1D9000001D9LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v171, 0), (__m64)0x1D9000001D9LL), 8u));
  v173 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v165, 0), (__m64)0x11500000115LL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v165, 0), (__m64)0x11500000115LL), 8u)),
           v172);
  v174 = _m_psubw(_m_paddw(v172, v168), v167);
  v175 = a2[5];
  v176 = _m_psubw(v170, v174);
  v177 = a2[13];
  v178 = _m_paddw(v173, v176);
  a2[1].m64_u64 = (unsigned __int64)_m_paddw(v175, v167);
  v179 = _m_psubw(v175, v167);
  v180 = _m_paddw(v157, v178);
  v181 = a2[9];
  a2[7].m64_u64 = (unsigned __int64)_m_psubw(v157, v178);
  a2[3].m64_u64 = (unsigned __int64)_m_paddw(v177, v174);
  v182 = _m_psubw(v181, v176);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v181, v176);
  v183 = (_BYTE *)(a5 + a4[4]);
  v184 = v180;
  v185 = _m_punpcklwd(v180, v182);
  v186 = _m_punpckhwd(v184, v182);
  v187 = _m_psubw(v177, v174);
  v188 = (__m64)a2->m64_u64;
  v189 = _m_punpcklwd(v187, v179);
  v190 = a2[2];
  v191 = _m_punpckhwd(v187, v179);
  v192 = v185;
  v193 = _m_psrlwi(_m_punpckldq(v185, v189), 5u);
  v183[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v193) & 0x3FF));
  v194 = _m_psrlqi(v193, 0x10u);
  v183[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v194) & 0x3FF));
  v195 = _m_psrlqi(v194, 0x10u);
  v183[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v195) & 0x3FF));
  v183[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v195, 0x10u)) & 0x3FF));
  v196 = (_BYTE *)(a5 + a4[5]);
  v197 = _m_punpckhdq(v192, v189);
  v198 = v186;
  v199 = _m_psrlwi(v197, 5u);
  v196[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v199) & 0x3FF));
  v200 = _m_psrlqi(v199, 0x10u);
  v196[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v200) & 0x3FF));
  v201 = _m_psrlqi(v200, 0x10u);
  v196[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v201) & 0x3FF));
  v196[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v201, 0x10u)) & 0x3FF));
  v202 = (_BYTE *)(a5 + a4[6]);
  v203 = _m_psrlwi(_m_punpckldq(v186, v191), 5u);
  v202[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v203) & 0x3FF));
  v204 = _m_psrlqi(v203, 0x10u);
  v202[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v204) & 0x3FF));
  v205 = _m_psrlqi(v204, 0x10u);
  v202[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v205) & 0x3FF));
  v202[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v205, 0x10u)) & 0x3FF));
  v206 = (_BYTE *)(a5 + a4[7]);
  v207 = _m_psrlwi(_m_punpckhdq(v198, v191), 5u);
  v206[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v207) & 0x3FF));
  v208 = _m_psrlqi(v207, 0x10u);
  v206[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v208) & 0x3FF));
  v209 = _m_psrlqi(v208, 0x10u);
  v206[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v209) & 0x3FF));
  v206[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v209, 0x10u)) & 0x3FF));
  v210 = (_BYTE *)(a5 + *a4);
  v211 = a2[6];
  v212 = _m_punpckhwd(v188, v190);
  v213 = _m_punpcklwd(v188, v190);
  v214 = a2[4];
  v215 = _m_punpcklwd(v214, v211);
  v216 = _m_punpckhwd(v214, v211);
  v217 = v212;
  v218 = _m_psrlwi(_m_punpckldq(v213, v215), 5u);
  *v210 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v218) & 0x3FF));
  v219 = _m_psrlqi(v218, 0x10u);
  v210[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v219) & 0x3FF));
  v220 = _m_psrlqi(v219, 0x10u);
  v210[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v220) & 0x3FF));
  v210[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v220, 0x10u)) & 0x3FF));
  v221 = (_BYTE *)(a5 + a4[1]);
  v222 = _m_psrlwi(_m_punpckhdq(v213, v215), 5u);
  *v221 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v222) & 0x3FF));
  v223 = _m_psrlqi(v222, 0x10u);
  v221[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v223) & 0x3FF));
  v224 = _m_psrlqi(v223, 0x10u);
  v221[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v224) & 0x3FF));
  v221[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v224, 0x10u)) & 0x3FF));
  v225 = (_BYTE *)(a5 + a4[2]);
  v226 = _m_psrlwi(_m_punpckldq(v212, v216), 5u);
  *v225 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v226) & 0x3FF));
  v227 = _m_psrlqi(v226, 0x10u);
  v225[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v227) & 0x3FF));
  v228 = _m_psrlqi(v227, 0x10u);
  v225[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v228) & 0x3FF));
  v225[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v228, 0x10u)) & 0x3FF));
  v229 = (_BYTE *)(a5 + a4[3]);
  v230 = _m_psrlwi(_m_punpckhdq(v217, v216), 5u);
  *v229 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v230) & 0x3FF));
  v231 = _m_psrlqi(v230, 0x10u);
  v229[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v231) & 0x3FF));
  v232 = _m_psrlqi(v231, 0x10u);
  v229[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v232) & 0x3FF));
  v229[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v232, 0x10u)) & 0x3FF));
  v233 = (_BYTE *)(a5 + a4[4]);
  v234 = a2[3];
  v235 = a2[1];
  v236 = _m_punpcklwd(v235, v234);
  v237 = _m_punpckhwd(v235, v234);
  v238 = a2[5];
  v239 = a2[7];
  v240 = v237;
  v241 = _m_punpcklwd(v238, v239);
  v242 = _m_punpckhwd(v238, v239);
  v243 = v236;
  v244 = _m_punpckldq(v236, v241);
  v245 = _m_punpckhdq(v243, v241);
  v246 = a2[8];
  v247 = _m_psrlwi(v244, 5u);
  *v233 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v247) & 0x3FF));
  v248 = _m_psrlqi(v247, 0x10u);
  v233[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v248) & 0x3FF));
  v249 = _m_psrlqi(v248, 0x10u);
  v233[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v249) & 0x3FF));
  v233[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v249, 0x10u)) & 0x3FF));
  v250 = (_BYTE *)(a5 + a4[5]);
  v251 = _m_punpckldq(v237, v242);
  v252 = _m_punpckhdq(v240, v242);
  v253 = a2[10];
  v254 = _m_psrlwi(v245, 5u);
  *v250 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v254) & 0x3FF));
  v255 = _m_psrlqi(v254, 0x10u);
  v250[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v255) & 0x3FF));
  v256 = _m_psrlqi(v255, 0x10u);
  v250[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v256) & 0x3FF));
  v250[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v256, 0x10u)) & 0x3FF));
  v257 = (_BYTE *)(a5 + a4[6]);
  v258 = a2[12];
  v259 = v246;
  v260 = _m_punpcklwd(v246, v253);
  v261 = _m_punpckhwd(v259, v253);
  v262 = a2[14];
  v263 = _m_psrlwi(v251, 5u);
  *v257 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v263) & 0x3FF));
  v264 = _m_psrlqi(v263, 0x10u);
  v257[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v264) & 0x3FF));
  v265 = _m_psrlqi(v264, 0x10u);
  v257[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v265) & 0x3FF));
  v257[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v265, 0x10u)) & 0x3FF));
  v266 = (_BYTE *)(a5 + a4[7]);
  v267 = v258;
  v268 = _m_psrlwi(v252, 5u);
  *v266 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v268) & 0x3FF));
  v269 = _m_psrlqi(v268, 0x10u);
  v266[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v269) & 0x3FF));
  v270 = _m_psrlqi(v269, 0x10u);
  v266[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v270) & 0x3FF));
  v266[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v270, 0x10u)) & 0x3FF));
  v271 = _m_punpcklwd(v258, v262);
  v272 = _m_punpckhwd(v267, v262);
  v273 = v260;
  v274 = v261;
  v275 = (_BYTE *)(a5 + *a4);
  v276 = _m_psrlwi(_m_punpckldq(v260, v271), 5u);
  v275[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v276) & 0x3FF));
  v277 = _m_psrlqi(v276, 0x10u);
  v275[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v277) & 0x3FF));
  v278 = _m_psrlqi(v277, 0x10u);
  v275[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v278) & 0x3FF));
  v275[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v278, 0x10u)) & 0x3FF));
  v279 = (_BYTE *)(a5 + a4[1]);
  v280 = _m_psrlwi(_m_punpckhdq(v273, v271), 5u);
  v279[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v280) & 0x3FF));
  v281 = _m_psrlqi(v280, 0x10u);
  v279[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v281) & 0x3FF));
  v282 = _m_psrlqi(v281, 0x10u);
  v279[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v282) & 0x3FF));
  v279[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v282, 0x10u)) & 0x3FF));
  v283 = (_BYTE *)(a5 + a4[2]);
  v284 = _m_psrlwi(_m_punpckldq(v261, v272), 5u);
  v283[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v284) & 0x3FF));
  v285 = _m_psrlqi(v284, 0x10u);
  v283[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v285) & 0x3FF));
  v286 = _m_psrlqi(v285, 0x10u);
  v283[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v286) & 0x3FF));
  v283[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v286, 0x10u)) & 0x3FF));
  v287 = (_BYTE *)(a5 + a4[3]);
  v288 = _m_psrlwi(_m_punpckhdq(v274, v272), 5u);
  v287[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v288) & 0x3FF));
  v289 = _m_psrlqi(v288, 0x10u);
  v287[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v289) & 0x3FF));
  v290 = _m_psrlqi(v289, 0x10u);
  v287[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v290) & 0x3FF));
  result = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v290, 0x10u)) & 0x3FF));
  v287[7] = result;
  _m_empty();
  return result;
}

// sub_10038BBD @ 0x10038BBD
int __cdecl sub_10038BBD(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6)
{
  _DWORD *v7; // edi
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  unsigned int j; // edx
  unsigned int v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  bool i; // zf
  unsigned __int8 v15; // cl
  int v16; // ecx
  unsigned int v17; // ebx
  unsigned int v18; // edx
  int v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // ecx
  int v22; // ebx
  unsigned int v23; // ebx
  unsigned int v24; // ecx
  int v25; // eax
  _BYTE *v26; // ecx
  char *v27; // eax
  unsigned int v28; // ecx
  _BYTE *v29; // ebx
  char v30; // cl
  _BYTE *v31; // ecx
  unsigned int v32; // ecx
  unsigned int v33; // eax
  unsigned __int8 *v34; // ecx
  unsigned __int8 *v35; // eax
  int v36; // ecx
  int v38; // [esp+Ch] [ebp-18h]
  int v39; // [esp+10h] [ebp-14h]
  unsigned int v40; // [esp+14h] [ebp-10h]
  unsigned int v41; // [esp+18h] [ebp-Ch]
  unsigned __int8 *v42; // [esp+1Ch] [ebp-8h]
  unsigned int v43; // [esp+20h] [ebp-4h]
  unsigned int v44; // [esp+2Ch] [ebp+8h]
  unsigned int v45; // [esp+2Ch] [ebp+8h]
  unsigned int v46; // [esp+2Ch] [ebp+8h]
  int v47; // [esp+30h] [ebp+Ch]
  unsigned int v48; // [esp+30h] [ebp+Ch]
  unsigned int v49; // [esp+30h] [ebp+Ch]
  int v50; // [esp+30h] [ebp+Ch]
  _BYTE *v51; // [esp+40h] [ebp+1Ch]

  v42 = *a6;
  v7 = a5;
  v8 = (_BYTE *)a5[13];
  v9 = a5[8];
  j = a5[7];
  v43 = (unsigned int)a6[1];
  v11 = a5[12];
  v51 = v8;
  if ( (unsigned int)v8 >= v11 )
    v12 = a5[11] - (_DWORD)v8;
  else
    v12 = v11 - (_DWORD)v8 - 1;
  v40 = v12;
  v39 = dword_10057020[a1];
  v38 = dword_10057020[a2];
LABEL_6:
  while ( j < 0x14 )
  {
    --v43;
    v9 |= *v42++ << j;
    j += 8;
  }
  v13 = (unsigned __int8 *)(a3 + 8 * (v9 & v39));
  v47 = *v13;
  for ( i = v47 == 0; ; i = v47 == 0 )
  {
    v15 = v13[1];
    if ( i )
    {
      v9 >>= v15;
      j -= v13[1];
      v31 = v51++;
      --v40;
      *v31 = v13[4];
LABEL_32:
      if ( v40 < 0x102 || v43 < 0xA )
      {
        v32 = (unsigned int)&a6[1][-v43];
        if ( j >> 3 < v32 )
          v32 = j >> 3;
        v50 = 0;
        goto LABEL_47;
      }
      goto LABEL_6;
    }
    v9 >>= v15;
    j -= v13[1];
    if ( (v47 & 0x10) != 0 )
    {
      v41 = *((_DWORD *)v13 + 1) + (v9 & dword_10057020[v47 & 0xF]);
      v16 = v47 & 0xF;
      v17 = v9 >> v16;
      v18 = j - v16;
      v44 = v17;
      if ( v18 < 0xF )
      {
        do
        {
          --v43;
          v19 = *v42 << v18;
          v18 += 8;
          v17 |= v19;
          ++v42;
        }
        while ( v18 < 0xF );
        v44 = v17;
      }
      v20 = (unsigned __int8 *)(a4 + 8 * (v17 & v38));
      v45 = v44 >> v20[1];
      for ( j = v18 - v20[1]; ; j -= v21 )
      {
        v22 = *v20;
        if ( (v22 & 0x10) != 0 )
        {
          v23 = v22 & 0xF;
          while ( j < v23 )
          {
            --v43;
            v45 |= *v42++ << j;
            j += 8;
          }
          v7 = a5;
          v24 = *((_DWORD *)v20 + 1) + (v45 & dword_10057020[v23]);
          v40 -= v41;
          v25 = a5[10];
          v48 = v24;
          v46 = v45 >> v23;
          j -= v23;
          if ( (unsigned int)&v51[-v25] < v24 )
          {
            v28 = v24 + v25 - (_DWORD)v51;
            v27 = (char *)(a5[11] - v28);
            v49 = v28;
            if ( v41 > v28 )
            {
              v41 -= v28;
              do
              {
                v29 = v51;
                v30 = *v27;
                ++v51;
                ++v27;
                i = v49-- == 1;
                *v29 = v30;
              }
              while ( !i );
              v27 = (char *)a5[10];
            }
            v26 = v51;
          }
          else
          {
            *v51 = v51[-v24];
            v51[1] = v51[-v24 + 1];
            v26 = v51 + 2;
            v27 = &v51[-v48 + 2];
            v41 -= 2;
          }
          do
          {
            *v26++ = *v27++;
            --v41;
          }
          while ( v41 );
          v9 = v46;
          v51 = v26;
          goto LABEL_32;
        }
        if ( (v22 & 0x40) != 0 )
          break;
        v20 += 8 * *((_DWORD *)v20 + 1) + 8 * (v45 & dword_10057020[v22]);
        v21 = v20[1];
        v45 >>= v21;
      }
      v32 = (unsigned int)&a6[1][-v43];
      a6[6] = "invalid distance code";
      if ( j >> 3 < v32 )
        v32 = j >> 3;
      v7 = a5;
      v9 = v45;
      goto LABEL_46;
    }
    if ( (v47 & 0x40) != 0 )
      break;
    v13 += 8 * *((_DWORD *)v13 + 1) + 8 * (v9 & dword_10057020[v47]);
    v47 = *v13;
  }
  v33 = j >> 3;
  v34 = a6[1];
  if ( (v47 & 0x20) == 0 )
  {
    v32 = (unsigned int)&v34[-v43];
    a6[6] = "invalid literal/length code";
    if ( v33 < v32 )
      v32 = j >> 3;
LABEL_46:
    v50 = -3;
    goto LABEL_47;
  }
  v32 = (unsigned int)&v34[-v43];
  if ( v33 < v32 )
    v32 = j >> 3;
  v50 = 1;
LABEL_47:
  v7[8] = v9;
  v7[7] = j - 8 * v32;
  v35 = &v42[-v32];
  a6[1] = (unsigned __int8 *)(v43 + v32);
  v36 = &v42[-v32] - *a6;
  *a6 = v35;
  a6[2] += v36;
  v7[13] = v51;
  return v50;
}

// nullsub_7 @ 0x1003A4F4
void nullsub_7()
{
  ;
}

// nullsub_8 @ 0x1003A504
void nullsub_8()
{
  ;
}

// nullsub_9 @ 0x1003A574
int nullsub_9()
{
  _BYTE retaddr[8]; // [esp+0h] [ebp+0h]

  return MK_FP(*(_WORD *)retaddr, *(_DWORD *)retaddr)();
}

// nullsub_10 @ 0x1003A584
int nullsub_10()
{
  _BYTE retaddr[8]; // [esp+0h] [ebp+0h]

  return MK_FP(*(_WORD *)retaddr, *(_DWORD *)retaddr)();
}

// sub_1003A990 @ 0x1003A990
_DWORD *__cdecl sub_1003A990(int a1, int a2, int a3)
{
  int v3; // eax
  int (__cdecl **v4)(int, _DWORD, int); // ecx
  _DWORD *result; // eax

  if ( !*(_DWORD *)(a1 + 20) )
  {
    v3 = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 48);
    v4 = *(int (__cdecl ***)(int, _DWORD, int))(a1 + 4);
    *(_DWORD *)(a1 + 20) = v3;
    *(_DWORD *)(v3 + 40) = (*v4)(a1, 0, 4096);
  }
  result = *(_DWORD **)(a1 + 20);
  result[2] = sub_1003AA10;
  result[3] = sub_1003AA20;
  result[4] = sub_1003AAC0;
  result[5] = sub_1003B560;
  result[6] = nullsub_4;
  result[7] = a2;
  result[8] = a3;
  result[9] = 0;
  result[1] = 0;
  *result = 0;
  return result;
}

// sub_1003AA10 @ 0x1003AA10
int __cdecl sub_1003AA10(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 44) = 1;
  return a1;
}

// sub_1003AA20 @ 0x1003AA20
char __cdecl sub_1003AA20(_DWORD *a1)
{
  int v1; // ebx
  int v2; // edx
  int v3; // eax
  signed int v4; // eax
  int v5; // ecx
  int v7; // ecx

  v1 = a1[5];
  v2 = *(_DWORD *)(v1 + 36);
  v3 = *(_DWORD *)(v1 + 32);
  if ( v2 >= v3 )
  {
    if ( *(_BYTE *)(v1 + 44) )
    {
      *(_DWORD *)(*a1 + 20) = 41;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    *(_DWORD *)(*a1 + 20) = 116;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    **(_BYTE **)(v1 + 40) = -1;
    *(_BYTE *)(*(_DWORD *)(v1 + 40) + 1) = -39;
    v7 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = 2;
    *(_DWORD *)v1 = v7;
    *(_BYTE *)(v1 + 44) = 0;
    return 1;
  }
  else
  {
    v4 = v3 - v2;
    if ( v4 > 4096 )
      v4 = 4096;
    qmemcpy(*(void **)(v1 + 40), (const void *)(v2 + *(_DWORD *)(v1 + 28)), v4);
    *(_DWORD *)(v1 + 36) += v4;
    v5 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = v4;
    *(_DWORD *)v1 = v5;
    *(_BYTE *)(v1 + 44) = 0;
    return 1;
  }
}

// sub_1003AAC0 @ 0x1003AAC0
void __cdecl sub_1003AAC0(_DWORD *a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // edi
  int v4; // eax
  int v5; // eax

  v2 = a2;
  v3 = (_DWORD *)a1[5];
  if ( a2 > 0 )
  {
    v4 = v3[1];
    if ( a2 > v4 )
    {
      do
      {
        v2 -= v4;
        sub_1003AA20(a1);
        v4 = v3[1];
      }
      while ( v2 > v4 );
    }
    v5 = v3[1] - v2;
    *v3 += v2;
    v3[1] = v5;
  }
}

// nullsub_4 @ 0x1003AB00
void nullsub_4()
{
  ;
}

// sub_1003AB10 @ 0x1003AB10
_DWORD *__cdecl sub_1003AB10(_DWORD *a1)
{
  *a1 = sub_1003AB60;
  a1[1] = sub_1003ABC0;
  a1[2] = sub_1003AB80;
  a1[3] = sub_1003AC00;
  a1[4] = sub_1003ACB0;
  a1[26] = 0;
  a1[27] = 0;
  a1[5] = 0;
  a1[28] = off_1005035C;
  a1[29] = 119;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  return a1;
}

// sub_1003AB60 @ 0x1003AB60
int __cdecl sub_1003AB60(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  return sub_1003DD30(a1);
}

// sub_1003AB80 @ 0x1003AB80
int __cdecl sub_1003AB80(int a1)
{
  HWND ActiveWindow; // eax
  CHAR Text[200]; // [esp+0h] [ebp-C8h] BYREF

  (*(void (__cdecl **)(int, CHAR *))(*(_DWORD *)a1 + 12))(a1, Text);
  ActiveWindow = GetActiveWindow();
  return MessageBoxA(ActiveWindow, Text, aJpegError, 0);
}

// sub_1003ABC0 @ 0x1003ABC0
int __cdecl sub_1003ABC0(int *a1, int a2)
{
  int result; // eax
  int v3; // esi

  result = a2;
  v3 = *a1;
  if ( a2 >= 0 )
  {
    if ( *(_DWORD *)(v3 + 104) >= a2 )
      return (*(int (__cdecl **)(int *))(v3 + 8))(a1);
  }
  else
  {
    result = *(_DWORD *)(v3 + 108);
    if ( !result || *(int *)(v3 + 104) >= 3 )
      result = (*(int (__cdecl **)(int *))(v3 + 8))(a1);
    ++*(_DWORD *)(v3 + 108);
  }
  return result;
}

// sub_1003AC00 @ 0x1003AC00
int __cdecl sub_1003AC00(int a1, char *Buffer)
{
  _DWORD *v2; // eax
  int v3; // ecx
  const char *v4; // edx
  int v5; // esi
  int v6; // edx
  char v7; // cl
  char *v8; // esi
  bool v9; // zf

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( v3 <= 0 || v3 > v2[29] )
  {
    v5 = v2[30];
    if ( !v5 )
      goto LABEL_9;
    v6 = v2[31];
    if ( v3 < v6 || v3 > v2[32] )
      goto LABEL_9;
    v4 = *(const char **)(v5 + 4 * (v3 - v6));
  }
  else
  {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if ( !v4 )
  {
LABEL_9:
    v2[6] = v3;
    v4 = *(const char **)v2[28];
  }
  v7 = *v4;
  v8 = (char *)(v4 + 1);
  if ( !*v4 )
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  while ( 1 )
  {
    v9 = v7 == 37;
    v7 = *v8;
    if ( v9 )
      break;
    ++v8;
    if ( !v7 )
      return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  }
  if ( v7 == 115 )
    return sprintf(Buffer, v4, v2 + 6);
  else
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
}

// sub_1003ACB0 @ 0x1003ACB0
int __cdecl sub_1003ACB0(int *a1)
{
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

// sub_1003ACD0 @ 0x1003ACD0
int __cdecl sub_1003ACD0(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 396) = result;
  *(_DWORD *)result = sub_1003AFC0;
  *(_DWORD *)(result + 4) = sub_1003B520;
  *(_DWORD *)(result + 8) = sub_1003AD20;
  *(_DWORD *)(result + 12) = sub_1003AFA0;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_BYTE *)(result + 20) = 1;
  return result;
}

// sub_1003AD20 @ 0x1003AD20
int __cdecl sub_1003AD20(int a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // ebp
  int v12; // edx
  int v13; // edi
  unsigned int v14; // eax
  int v15; // edx
  int v16; // edi
  int v17; // eax
  bool v18; // cc
  int v19; // ebp
  unsigned int v20; // esi
  void *v21; // eax
  int result; // eax
  int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+18h] [ebp+4h]
  int *v26; // [esp+18h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 288);
  if ( v2 == 1 )
  {
    v3 = *(_DWORD **)(a1 + 292);
    *(_DWORD *)(a1 + 308) = v3[7];
    *(_DWORD *)(a1 + 312) = v3[8];
    v4 = v3[3];
    v3[16] = v3[9];
    v5 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[17] = 1;
    if ( !v5 )
      v5 = v4;
    v3[18] = v5;
    *(_DWORD *)(a1 + 316) = 1;
    *(_DWORD *)(a1 + 320) = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 288);
      *(_DWORD *)(*(_DWORD *)a1 + 28) = 4;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v6 = sub_1003E460(*(_DWORD *)(a1 + 24), 8 * *(_DWORD *)(a1 + 268));
    v7 = 8 * *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 308) = v6;
    *(_DWORD *)(a1 + 312) = sub_1003E460(*(_DWORD *)(a1 + 28), v7);
    v8 = *(_DWORD *)(a1 + 288);
    *(_DWORD *)(a1 + 316) = 0;
    v25 = 0;
    if ( v8 > 0 )
    {
      v23 = a1 + 292;
      do
      {
        v9 = *(_DWORD **)v23;
        v10 = *(_DWORD *)(*(_DWORD *)v23 + 8);
        v11 = *(_DWORD *)(*(_DWORD *)v23 + 12);
        v9[16] = v10 * *(_DWORD *)(*(_DWORD *)v23 + 36);
        v12 = v9[7] % v10;
        v13 = v10 * v11;
        v9[13] = v10;
        v9[14] = v11;
        v9[15] = v10 * v11;
        if ( !v12 )
          v12 = v10;
        v14 = v9[8];
        v9[17] = v12;
        v15 = v14 % v11;
        if ( !(v14 % v11) )
          v15 = v11;
        v9[18] = v15;
        if ( v13 + *(_DWORD *)(a1 + 316) > 10 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v10 * v11) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 316) + 320) = v25;
            --v17;
            ++*(_DWORD *)(a1 + 316);
          }
          while ( v17 );
        }
        v18 = ++v25 < *(_DWORD *)(a1 + 288);
        v23 += 4;
      }
      while ( v18 );
    }
  }
  v24 = 0;
  if ( *(int *)(a1 + 288) > 0 )
  {
    v26 = (int *)(a1 + 292);
    do
    {
      v19 = *v26;
      if ( !*(_DWORD *)(*v26 + 76) )
      {
        v20 = *(_DWORD *)(v19 + 16);
        if ( v20 >= 4 || !*(_DWORD *)(a1 + 4 * v20 + 144) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v20;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v21 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
        qmemcpy(v21, *(const void **)(a1 + 4 * v20 + 144), 0x82u);
        *(_DWORD *)(v19 + 76) = v21;
      }
      v18 = ++v24 < *(_DWORD *)(a1 + 288);
      ++v26;
    }
    while ( v18 );
  }
  (**(void (__cdecl ***)(int))(a1 + 404))(a1);
  (**(void (__cdecl ***)(int))(a1 + 388))(a1);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
  **(_DWORD **)(a1 + 396) = result;
  return result;
}

// sub_1003AFA0 @ 0x1003AFA0
int __cdecl sub_1003AFA0(int a1)
{
  **(_DWORD **)(a1 + 396) = sub_1003AFC0;
  return a1;
}

// sub_1003AFC0 @ 0x1003AFC0
int __cdecl sub_1003AFC0(int a1)
{
  char v3; // al
  int v4; // eax
  int v5; // esi
  int v6; // edi
  int *v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // edi
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // ebx
  unsigned int v21; // esi
  void *v22; // eax
  bool v23; // cc
  int v24; // [esp+8h] [ebp-8h]
  int v25; // [esp+Ch] [ebp-4h]
  _BYTE *v26; // [esp+14h] [ebp+4h]
  int *v27; // [esp+14h] [ebp+4h]

  v26 = *(_BYTE **)(a1 + 396);
  if ( v26[17] )
    return 2;
  v25 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 400) + 4))(a1);
  if ( v25 != 1 )
  {
    if ( v25 == 2 )
    {
      v3 = v26[20];
      v26[17] = 1;
      if ( v3 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 58;
          (**(void (__cdecl ***)(int))a1)(a1);
          return v25;
        }
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 124);
        if ( *(_DWORD *)(a1 + 132) > v4 )
        {
          *(_DWORD *)(a1 + 132) = v4;
          return v25;
        }
      }
    }
    return v25;
  }
  if ( !v26[20] )
  {
    if ( !v26[16] )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 34;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    sub_1003B370(a1);
    v24 = 0;
    if ( *(int *)(a1 + 288) > 0 )
    {
      v27 = (int *)(a1 + 292);
      do
      {
        v20 = *v27;
        if ( !*(_DWORD *)(*v27 + 76) )
        {
          v21 = *(_DWORD *)(v20 + 16);
          if ( v21 >= 4 || !*(_DWORD *)(a1 + 4 * v21 + 144) )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v21;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          v22 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
          qmemcpy(v22, *(const void **)(a1 + 4 * v21 + 144), 0x82u);
          *(_DWORD *)(v20 + 76) = v22;
        }
        v23 = ++v24 < *(_DWORD *)(a1 + 288);
        ++v27;
      }
      while ( v23 );
    }
    (**(void (__cdecl ***)(int))(a1 + 404))(a1);
    (**(void (__cdecl ***)(int))(a1 + 388))(a1);
    **(_DWORD **)(a1 + 396) = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
    return v25;
  }
  if ( *(int *)(a1 + 28) > 65500 || *(int *)(a1 + 24) > 65500 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 40;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 65500;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_DWORD *)(a1 + 192) != 8 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 13;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 192);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(int *)(a1 + 32) > 10 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v5 = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a1 + 268) = 1;
  *(_DWORD *)(a1 + 272) = 1;
  v6 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = (int *)(v5 + 12);
    do
    {
      v8 = *(v7 - 1);
      if ( v8 <= 0 || v8 > 4 || *v7 <= 0 || *v7 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 16;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v9 = *(_DWORD *)(a1 + 268);
      if ( v9 <= *(v7 - 1) )
        v9 = *(v7 - 1);
      *(_DWORD *)(a1 + 268) = v9;
      v10 = *(_DWORD *)(a1 + 272);
      if ( v10 <= *v7 )
        v10 = *v7;
      *(_DWORD *)(a1 + 272) = v10;
      ++v6;
      v7 += 21;
    }
    while ( v6 < *(_DWORD *)(a1 + 32) );
  }
  v11 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 196);
  v13 = 0;
  *(_DWORD *)(a1 + 276) = 8;
  if ( v11 > 0 )
  {
    v14 = v12 + 28;
    do
    {
      v15 = *(_DWORD *)(v14 - 20);
      *(_DWORD *)(v14 + 8) = 8;
      *(_DWORD *)v14 = sub_1003E460(*(_DWORD *)(a1 + 24) * v15, 8 * *(_DWORD *)(a1 + 268));
      v16 = sub_1003E460(*(_DWORD *)(v14 - 16) * *(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
      v17 = *(_DWORD *)(v14 - 20);
      *(_DWORD *)(v14 + 4) = v16;
      *(_DWORD *)(v14 + 12) = sub_1003E460(*(_DWORD *)(a1 + 24) * v17, *(_DWORD *)(a1 + 268));
      *(_DWORD *)(v14 + 16) = sub_1003E460(*(_DWORD *)(v14 - 16) * *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 272));
      *(_BYTE *)(v14 + 20) = 1;
      *(_DWORD *)(v14 + 48) = 0;
      ++v13;
      v14 += 84;
    }
    while ( v13 < *(_DWORD *)(a1 + 32) );
  }
  v18 = sub_1003E460(*(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
  v19 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 280) = v18;
  if ( *(_DWORD *)(a1 + 288) < v19 || *(_BYTE *)(a1 + 200) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) = 1;
    v26[20] = 0;
    return 1;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) = 0;
    v26[20] = 0;
    return 1;
  }
}

// sub_1003B370 @ 0x1003B370
int __cdecl sub_1003B370(_DWORD *a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  int result; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // ebp
  int v12; // edx
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  bool v18; // cc
  _DWORD *v19; // [esp+Ch] [ebp-4h]
  int v20; // [esp+14h] [ebp+4h]

  v2 = a1[72];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)a1[73];
    a1[77] = v3[7];
    a1[78] = v3[8];
    v4 = v3[3];
    v3[16] = v3[9];
    result = v3[8] / v4;
    v6 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[17] = 1;
    if ( !v6 )
      v6 = v4;
    v3[18] = v6;
    a1[79] = 1;
    a1[80] = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 24;
      *(_DWORD *)(*a1 + 24) = a1[72];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v7 = sub_1003E460(a1[6], 8 * a1[67]);
    v8 = 8 * a1[68];
    a1[77] = v7;
    a1[78] = sub_1003E460(a1[7], v8);
    result = a1[72];
    a1[79] = 0;
    v20 = 0;
    if ( result > 0 )
    {
      v19 = a1 + 73;
      do
      {
        v9 = (_DWORD *)*v19;
        v10 = *(_DWORD *)(*v19 + 8);
        v11 = *(_DWORD *)(*v19 + 12);
        v9[16] = v10 * *(_DWORD *)(*v19 + 36);
        v12 = v9[7] % v10;
        v13 = v10 * v11;
        v9[13] = v10;
        v9[14] = v11;
        v9[15] = v10 * v11;
        if ( !v12 )
          v12 = v10;
        v14 = v9[8];
        v9[17] = v12;
        v15 = v14 % v11;
        if ( !(v14 % v11) )
          v15 = v11;
        v9[18] = v15;
        if ( v13 + a1[79] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 11;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v10 * v11) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            a1[a1[79] + 80] = v20;
            --v17;
            ++a1[79];
          }
          while ( v17 );
        }
        result = v20 + 1;
        v18 = ++v20 < a1[72];
        ++v19;
      }
      while ( v18 );
    }
  }
  return result;
}

// sub_1003B520 @ 0x1003B520
int __cdecl sub_1003B520(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 396);
  *(_DWORD *)v1 = sub_1003AFC0;
  *(_BYTE *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 17) = 0;
  *(_BYTE *)(v1 + 20) = 1;
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
  result = (**(int (__cdecl ***)(int))(a1 + 400))(a1);
  *(_DWORD *)(a1 + 140) = 0;
  return result;
}

// sub_1003B560 @ 0x1003B560
char __cdecl sub_1003B560(_DWORD *a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx

  v2 = a1[94];
  *(_DWORD *)(*a1 + 20) = 117;
  *(_DWORD *)(*a1 + 24) = v2;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while ( 1 )
  {
    if ( v2 < 192 )
    {
LABEL_3:
      v3 = 2;
      goto LABEL_12;
    }
    if ( v2 < 208 || v2 > 215 || v2 == (((_BYTE)a2 + 1) & 7) + 208 || v2 == (((_BYTE)a2 + 2) & 7) + 208 )
    {
      v3 = 3;
    }
    else
    {
      if ( v2 == (((_BYTE)a2 - 1) & 7) + 208 || v2 == (((_BYTE)a2 - 2) & 7) + 208 )
        goto LABEL_3;
      v3 = 1;
    }
LABEL_12:
    *(_DWORD *)(*a1 + 20) = 96;
    *(_DWORD *)(*a1 + 24) = v2;
    *(_DWORD *)(*a1 + 28) = v3;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    v4 = v3 - 1;
    if ( !v4 )
      break;
    v5 = v4 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
        return 1;
    }
    else
    {
      if ( !(unsigned __int8)sub_1003B660(a1) )
        return 0;
      v2 = a1[94];
    }
  }
  a1[94] = 0;
  return 1;
}

// sub_1003B660 @ 0x1003B660
char __cdecl sub_1003B660(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  while ( 1 )
  {
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    --v3;
    ++v4;
    if ( v5 == 255 )
      goto LABEL_10;
    do
    {
      ++*(_DWORD *)(a1[100] + 88);
      *v2 = v4;
      v2[1] = v3;
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
      }
      v6 = *v4;
      --v3;
      ++v4;
    }
    while ( v6 != 255 );
    do
    {
LABEL_10:
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
      }
      v7 = *v4;
      --v3;
      ++v4;
      v9 = v7;
    }
    while ( v7 == 255 );
    if ( v7 )
      break;
    *(_DWORD *)(a1[100] + 88) += 2;
    *v2 = v4;
    v2[1] = v3;
  }
  if ( *(_DWORD *)(a1[100] + 88) )
  {
    *(_DWORD *)(*a1 + 20) = 112;
    *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 88);
    *(_DWORD *)(*a1 + 28) = v7;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    v7 = v9;
    *(_DWORD *)(a1[100] + 88) = 0;
  }
  a1[94] = v7;
  *v2 = v4;
  v2[1] = v3;
  return 1;
}

// sub_1003B770 @ 0x1003B770
int __cdecl sub_1003B770(int a1)
{
  _DWORD *v1; // eax
  int i; // eax
  int v3; // ecx
  int result; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
  *(_DWORD *)(a1 + 400) = v1;
  *v1 = sub_1003D090;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 4) = sub_1003BD30;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 8) = sub_1003D000;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 12) = sub_1003BC90;
  for ( i = 16; i < 80; i += 4 )
    *(_DWORD *)(*(_DWORD *)(a1 + 400) + i) = sub_1003BC90;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 16) = sub_1003B820;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 72) = sub_1003BAC0;
  v3 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_BYTE *)(v3 + 80) = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) = 0;
  result = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// sub_1003B820 @ 0x1003B820
char __cdecl sub_1003B820(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 v12; // dl
  int v13; // ecx
  unsigned __int8 v14; // al
  __int16 v15; // bx
  __int16 v17; // ax
  __int16 v18; // dx
  unsigned __int16 v19; // cx
  __int16 v20; // dx
  __int16 v21; // ax
  __int16 v22; // dx
  _DWORD *v23; // eax
  unsigned __int8 v24; // bl
  unsigned __int8 v25; // al
  int v26; // [esp+10h] [ebp-1Ch]
  unsigned __int8 **v27; // [esp+14h] [ebp-18h]
  _BYTE v28[5]; // [esp+18h] [ebp-14h]
  unsigned __int8 v29; // [esp+1Dh] [ebp-Fh]
  __int16 v30; // [esp+1Eh] [ebp-Eh]
  unsigned __int8 v31; // [esp+20h] [ebp-Ch]
  unsigned __int8 v32; // [esp+21h] [ebp-Bh]
  unsigned __int8 v33; // [esp+22h] [ebp-Ah]
  unsigned __int8 v34; // [esp+23h] [ebp-9h]
  __int16 v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+30h] [ebp+4h]
  int v37; // [esp+30h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  v27 = v2;
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v36 = (unsigned __int16)v5;
  if ( v6 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v7 = *v2;
  v6 = v2[1];
  v5 = v36;
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  v37 = v9;
  if ( v9 < 14 )
  {
    *(_DWORD *)(*a1 + 20) = 76;
  }
  else
  {
    v11 = 0;
    v26 = 0;
    do
    {
      if ( !v8 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v10 = *v2;
        v8 = v2[1];
        v11 = v26;
        v9 = v37;
      }
      v12 = *v10;
      --v8;
      ++v10;
      v28[v11++] = v12;
      v26 = v11;
    }
    while ( v11 < 14 );
    v13 = v9 - 14;
    v37 = v13;
    if ( v28[0] == 74 && v28[1] == 70 && v28[2] == 73 && v28[3] == 70 && !v28[4] )
    {
      v14 = v29;
      if ( v29 == 1 )
      {
        v15 = v30;
        if ( (unsigned __int8)v30 > 2u )
        {
          *(_DWORD *)(*a1 + 20) = 88;
          *(_DWORD *)(*a1 + 24) = 1;
          *(_DWORD *)(*a1 + 28) = (unsigned __int8)v15;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        }
      }
      else
      {
        v15 = v30;
        *(_DWORD *)(*a1 + 20) = 115;
        *(_DWORD *)(*a1 + 24) = v14;
        *(_DWORD *)(*a1 + 28) = (unsigned __int8)v15;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
      }
      v17 = v32;
      v18 = v31;
      *((_BYTE *)a1 + 257) = HIBYTE(v15);
      *((_BYTE *)a1 + 256) = 1;
      v19 = (v18 << 8) + v17;
      v20 = v33;
      v21 = v34;
      *((_WORD *)a1 + 129) = v19;
      v22 = v21 + (v20 << 8);
      v23 = (_DWORD *)*a1;
      *((_WORD *)a1 + 130) = v22;
      v23 += 6;
      *v23 = v19;
      v23[1] = *((unsigned __int16 *)a1 + 130);
      v23[2] = *((unsigned __int8 *)a1 + 257);
      *(_DWORD *)(*a1 + 20) = 86;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      v24 = HIBYTE(v35);
      v25 = v35;
      if ( v35 )
      {
        *(_DWORD *)(*a1 + 20) = 89;
        *(_DWORD *)(*a1 + 24) = v25;
        *(_DWORD *)(*a1 + 28) = v24;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        v25 = v35;
      }
      if ( v37 != 3 * v25 * v24 )
      {
        *(_DWORD *)(*a1 + 20) = 87;
        *(_DWORD *)(*a1 + 24) = v37;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      }
      v2 = v27;
      goto LABEL_28;
    }
    *(_DWORD *)(*a1 + 20) = 76;
    v9 = v13 + 14;
  }
  *(_DWORD *)(*a1 + 24) = v9;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
LABEL_28:
  *v2 = v10;
  v2[1] = v8;
  if ( v37 > 0 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v37);
  return 1;
}

// sub_1003BAC0 @ 0x1003BAC0
char __cdecl sub_1003BAC0(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 v12; // dl
  int v13; // ecx
  unsigned __int8 v14; // dl
  _DWORD *v15; // eax
  int v16; // ecx
  unsigned __int8 v17; // dl
  int v19; // [esp+10h] [ebp-14h]
  int v20; // [esp+10h] [ebp-14h]
  _BYTE v21[16]; // [esp+14h] [ebp-10h]
  int v22; // [esp+28h] [ebp+4h]
  int v23; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v22 = (unsigned __int16)v5;
  if ( v6 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v7 = *v2;
  v6 = v2[1];
  v5 = v22;
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  v23 = v9;
  if ( v9 < 12 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    goto LABEL_22;
  }
  v11 = 0;
  v19 = 0;
  do
  {
    if ( !v8 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v10 = *v2;
      v8 = v2[1];
      v9 = v23;
      v11 = v19;
    }
    v12 = *v10;
    --v8;
    ++v10;
    v21[v11++] = v12;
    v19 = v11;
  }
  while ( v11 < 12 );
  v13 = v9 - 12;
  v23 = v13;
  if ( v21[0] != 65 || v21[1] != 100 || v21[2] != 111 || v21[3] != 98 || v21[4] != 101 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    v9 = v13 + 12;
LABEL_22:
    *(_DWORD *)(*a1 + 24) = v9;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    goto LABEL_23;
  }
  v14 = v21[8];
  v20 = v21[11];
  v15 = (_DWORD *)*a1;
  v15[6] = v21[6] + (v21[5] << 8);
  v15 += 6;
  v16 = v14 + (v21[7] << 8);
  v17 = v21[10];
  v15[1] = v16;
  v15[2] = v17 + (v21[9] << 8);
  v15[3] = v20;
  *(_DWORD *)(*a1 + 20) = 75;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *((_BYTE *)a1 + 262) = 1;
  *((_BYTE *)a1 + 263) = v20;
LABEL_23:
  *v2 = v10;
  v2[1] = v8;
  if ( v23 > 0 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v23);
  return 1;
}

// sub_1003BC90 @ 0x1003BC90
char __cdecl sub_1003BC90(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // ebp
  unsigned __int16 v5; // ax
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  int v8; // ecx
  int v10; // [esp+14h] [ebp+4h]
  int v11; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v10 = v5;
  if ( v6 )
  {
LABEL_7:
    v8 = *v7;
    *(_DWORD *)(*a1 + 20) = 90;
    v11 = v8 + v10;
    *(_DWORD *)(*a1 + 24) = a1[94];
    *(_DWORD *)(*a1 + 28) = v11;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    *v2 = v7 + 1;
    v2[1] = v6 - 1;
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v11 - 2);
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v7 = *v2;
    v6 = v2[1];
    goto LABEL_7;
  }
  return 0;
}

// sub_1003BD30 @ 0x1003BD30
int __cdecl sub_1003BD30(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // ebp
  int v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  int v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  _BYTE *v12; // eax
  int v13; // eax
  char v14; // al
  unsigned __int8 **v15; // ebx
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // ebp
  unsigned __int16 v18; // cx
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // ebp
  int v21; // edi
  unsigned __int8 *v22; // eax
  int v23; // edi
  unsigned __int8 *v24; // ebp
  int v25; // ecx
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // ebp
  int v28; // edi
  int v29; // ebx
  char v31; // [esp-4h] [ebp-1Ch]
  int v32; // [esp+10h] [ebp-8h]
  unsigned __int8 **v33; // [esp+14h] [ebp-4h]
  int v34; // [esp+1Ch] [ebp+4h]
  int v35; // [esp+1Ch] [ebp+4h]
  unsigned __int8 *v36; // [esp+1Ch] [ebp+4h]

  while ( 1 )
  {
    if ( a1[94] )
      goto LABEL_14;
    if ( *(_BYTE *)(a1[100] + 80) )
      break;
    v2 = (unsigned __int8 **)a1[5];
    v3 = v2[1];
    v4 = *v2;
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    v6 = v3 - 1;
    v7 = v4 + 1;
    v34 = v5;
    if ( !v6 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v7 = *v2;
      v6 = v2[1];
      v5 = v34;
    }
    v8 = *v7;
    v9 = v6 - 1;
    v10 = v7 + 1;
    v35 = v8;
    if ( v5 != 255 || v8 != 216 )
    {
      *(_DWORD *)(*a1 + 20) = 52;
      *(_DWORD *)(*a1 + 24) = v5;
      *(_DWORD *)(*a1 + 28) = v8;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v8 = v35;
    }
    a1[94] = v8;
    *v2 = v10;
    v2[1] = v9;
LABEL_14:
    v11 = a1[94];
    switch ( v11 )
    {
      case 1:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        *(_DWORD *)(*a1 + 20) = 91;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[94] = 0;
        continue;
      case 192:
      case 193:
        v14 = sub_1003C320(a1, 0, 0);
        goto LABEL_25;
      case 194:
        v31 = 0;
        goto LABEL_24;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        *(_DWORD *)(*a1 + 20) = 59;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[94] = 0;
        continue;
      case 196:
        if ( !(unsigned __int8)sub_1003C950(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 201:
        v14 = sub_1003C320(a1, 0, 1);
        goto LABEL_25;
      case 202:
        v31 = 1;
LABEL_24:
        v14 = sub_1003C320(a1, 1, v31);
LABEL_25:
        if ( !v14 )
          return 0;
        a1[94] = 0;
        continue;
      case 204:
        v15 = (unsigned __int8 **)a1[5];
        v16 = v15[1];
        v17 = *v15;
        v33 = v15;
        if ( v16 )
          goto LABEL_31;
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v17 = *v15;
        v16 = v15[1];
LABEL_31:
        LOBYTE(v18) = 0;
        HIBYTE(v18) = *v17;
        v19 = v16 - 1;
        v20 = v17 + 1;
        v21 = v18;
        if ( v19 )
          goto LABEL_34;
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v20 = *v15;
        v19 = v15[1];
LABEL_34:
        v22 = v19 - 1;
        v23 = *v20 + v21 - 2;
        v24 = v20 + 1;
        v32 = v23;
        if ( v23 <= 0 )
          goto LABEL_48;
        break;
      case 216:
        *(_DWORD *)(*a1 + 20) = 101;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        if ( *(_BYTE *)(a1[100] + 80) )
        {
          *(_DWORD *)(*a1 + 20) = 60;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
        v12 = (char *)a1 + 218;
        do
        {
          *(v12 - 16) = 0;
          *v12 = 1;
          v12[16] = 5;
          ++v12;
        }
        while ( (int)&v12[-218 - (_DWORD)a1] < 16 );
        v13 = a1[100];
        a1[63] = 0;
        a1[9] = 0;
        *((_BYTE *)a1 + 264) = 0;
        *((_BYTE *)a1 + 256) = 0;
        *((_BYTE *)a1 + 257) = 0;
        *((_WORD *)a1 + 129) = 1;
        *((_WORD *)a1 + 130) = 1;
        *((_BYTE *)a1 + 262) = 0;
        *((_BYTE *)a1 + 263) = 0;
        *(_BYTE *)(v13 + 80) = 1;
        a1[94] = 0;
        continue;
      case 217:
        *(_DWORD *)(*a1 + 20) = 84;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[94] = 0;
        return 2;
      case 218:
        if ( !(unsigned __int8)sub_1003C640(a1) )
          return 0;
        a1[94] = 0;
        return 1;
      case 219:
        if ( !(unsigned __int8)sub_1003CCA0(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 220:
        if ( !sub_1003BC90(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 221:
        if ( !(unsigned __int8)sub_1003CF10(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 4 * v11 - 880))(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 254:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 12))(a1) )
          return 0;
        a1[94] = 0;
        continue;
      default:
        *(_DWORD *)(*a1 + 20) = 67;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[94] = 0;
        continue;
    }
    do
    {
      if ( !v22 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v24 = *v15;
        v22 = v15[1];
      }
      v25 = *v24;
      v26 = v22 - 1;
      v27 = v24 + 1;
      v28 = v25;
      if ( !v26 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v27 = *v15;
        v26 = v15[1];
      }
      v29 = *v27;
      v36 = v26 - 1;
      *(_DWORD *)(*a1 + 20) = 78;
      *(_DWORD *)(*a1 + 24) = v28;
      v32 -= 2;
      *(_DWORD *)(*a1 + 28) = v29;
      v24 = v27 + 1;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      if ( v28 >= 32 )
      {
        *(_DWORD *)(*a1 + 20) = 26;
        *(_DWORD *)(*a1 + 24) = v28;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      if ( v28 < 16 )
      {
        *((_BYTE *)a1 + v28 + 202) = v29 & 0xF;
        *((_BYTE *)a1 + v28 + 218) = v29 >> 4;
        if ( *((_BYTE *)a1 + v28 + 202) > (unsigned __int8)(v29 >> 4) )
        {
          *(_DWORD *)(*a1 + 20) = 27;
          *(_DWORD *)(*a1 + 24) = v29;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
      }
      else
      {
        *((_BYTE *)a1 + v28 + 218) = v29;
      }
      v15 = v33;
      v22 = v36;
    }
    while ( v32 > 0 );
LABEL_48:
    *v15 = v24;
    v15[1] = v22;
    a1[94] = 0;
  }
  if ( sub_1003B660(a1) )
    goto LABEL_14;
  return 0;
}

// sub_1003C320 @ 0x1003C320
char __cdecl sub_1003C320(int a1, char a2, char a3)
{
  unsigned __int8 **v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned __int16 v7; // dx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // ebx
  int v11; // ecx
  unsigned __int8 *v12; // edi
  int v13; // ecx
  unsigned __int8 *v14; // ebx
  unsigned __int8 *v15; // edi
  unsigned __int16 v16; // dx
  unsigned __int8 *v17; // ebx
  unsigned __int8 *v18; // edi
  unsigned __int8 *v19; // ebx
  int v20; // ecx
  unsigned __int8 *v21; // edi
  unsigned __int16 v22; // cx
  unsigned __int8 *v23; // ebx
  unsigned __int8 *v24; // edi
  unsigned __int8 *v25; // ebx
  int v26; // ecx
  unsigned __int8 *v27; // edi
  int v28; // ecx
  int v29; // eax
  unsigned __int8 *v30; // ebx
  unsigned __int8 *v31; // edi
  _DWORD *v32; // eax
  _DWORD *v33; // ebp
  int v34; // edx
  unsigned __int8 *v35; // ebx
  unsigned __int8 *v36; // edi
  int v37; // eax
  unsigned __int8 *v38; // ebx
  unsigned __int8 *v39; // edi
  int v40; // edx
  _DWORD *v41; // eax
  unsigned __int8 **v43; // [esp+14h] [ebp+4h]
  int v44; // [esp+18h] [ebp+8h]
  int v45; // [esp+18h] [ebp+8h]
  int v46; // [esp+18h] [ebp+8h]
  int i; // [esp+18h] [ebp+8h]

  v4 = *(unsigned __int8 ***)(a1 + 20);
  v5 = v4[1];
  v6 = *v4;
  v43 = v4;
  *(_BYTE *)(a1 + 200) = a2;
  *(_BYTE *)(a1 + 201) = a3;
  if ( !v5 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v6 = *v4;
    v5 = v4[1];
  }
  LOBYTE(v7) = 0;
  HIBYTE(v7) = *v6;
  v8 = v5 - 1;
  v9 = v6 + 1;
  v44 = v7;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v9 = *v4;
    v8 = v4[1];
  }
  v10 = v8 - 1;
  v11 = *v9 + v44;
  v12 = v9 + 1;
  v45 = v11;
  if ( !v10 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v12 = *v4;
    v10 = v4[1];
  }
  v13 = *v12;
  v14 = v10 - 1;
  v15 = v12 + 1;
  *(_DWORD *)(a1 + 192) = v13;
  if ( !v14 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v15 = *v4;
    v14 = v4[1];
  }
  LOBYTE(v16) = 0;
  HIBYTE(v16) = *v15;
  v17 = v14 - 1;
  v18 = v15 + 1;
  *(_DWORD *)(a1 + 28) = v16;
  if ( !v17 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v18 = *v4;
    v17 = v4[1];
  }
  v19 = v17 - 1;
  v20 = *v18 + *(_DWORD *)(a1 + 28);
  v21 = v18 + 1;
  *(_DWORD *)(a1 + 28) = v20;
  if ( !v19 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v21 = *v4;
    v19 = v4[1];
  }
  LOBYTE(v22) = 0;
  HIBYTE(v22) = *v21;
  v23 = v19 - 1;
  v24 = v21 + 1;
  *(_DWORD *)(a1 + 24) = v22;
  if ( !v23 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v24 = *v4;
    v23 = v4[1];
  }
  v25 = v23 - 1;
  v26 = *v24 + *(_DWORD *)(a1 + 24);
  v27 = v24 + 1;
  *(_DWORD *)(a1 + 24) = v26;
  if ( !v25 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
    {
      v27 = *v4;
      v25 = v4[1];
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v28 = *(_DWORD *)(a1 + 376);
  v29 = *v27;
  v46 = v45 - 8;
  v30 = v25 - 1;
  v31 = v27 + 1;
  *(_DWORD *)(a1 + 32) = v29;
  v32 = (_DWORD *)(*(_DWORD *)a1 + 24);
  *v32 = v28;
  v32[1] = *(_DWORD *)(a1 + 24);
  v32[2] = *(_DWORD *)(a1 + 28);
  v32[3] = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 99;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 57;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 28) || !*(_DWORD *)(a1 + 24) || *(int *)(a1 + 32) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 31;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( v46 != 3 * *(_DWORD *)(a1 + 32) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 9;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 196) )
    *(_DWORD *)(a1 + 196) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84 * *(_DWORD *)(a1 + 32));
  v33 = *(_DWORD **)(a1 + 196);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    v33[1] = i;
    if ( !v30 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v31 = *v43;
      v30 = v43[1];
    }
    v34 = *v31;
    v35 = v30 - 1;
    v36 = v31 + 1;
    *v33 = v34;
    if ( !v35 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v36 = *v43;
      v35 = v43[1];
    }
    v37 = *v36;
    v38 = v35 - 1;
    v39 = v36 + 1;
    v33[2] = (v37 >> 4) & 0xF;
    v33[3] = v37 & 0xF;
    if ( !v38 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v39 = *v43;
      v38 = v43[1];
    }
    v40 = *v39;
    v30 = v38 - 1;
    v31 = v39 + 1;
    v33[4] = v40;
    v41 = (_DWORD *)(*(_DWORD *)a1 + 24);
    *v41 = *v33;
    v41[1] = v33[2];
    v41[2] = v33[3];
    v41[3] = v33[4];
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 100;
    (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    v33 += 21;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) = 1;
  *v43 = v31;
  v43[1] = v30;
  return 1;
}

// sub_1003C640 @ 0x1003C640
char __cdecl sub_1003C640(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  unsigned __int16 v5; // cx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // ebx
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 *v12; // ebx
  unsigned __int8 *v13; // ebp
  int v14; // edx
  unsigned __int8 *v15; // ebx
  unsigned __int8 *v16; // ebp
  int v17; // ecx
  _DWORD *v18; // edi
  int v19; // ebx
  int v20; // eax
  _DWORD *v21; // eax
  bool v22; // cc
  int v23; // eax
  unsigned __int8 *v24; // ebx
  unsigned __int8 *v25; // ebp
  int v26; // eax
  unsigned __int8 *v27; // ebx
  unsigned __int8 *v28; // ebp
  int v29; // edx
  int v30; // ecx
  _DWORD *v31; // eax
  int v33; // [esp+10h] [ebp-14h]
  int v34; // [esp+10h] [ebp-14h]
  int v35; // [esp+10h] [ebp-14h]
  _DWORD *v36; // [esp+14h] [ebp-10h]
  int v37; // [esp+18h] [ebp-Ch]
  int v38; // [esp+1Ch] [ebp-8h]
  unsigned __int8 **v39; // [esp+20h] [ebp-4h]
  unsigned __int8 *v40; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  v39 = v2;
  if ( !*(_BYTE *)(a1[100] + 81) )
  {
    *(_DWORD *)(*a1 + 20) = 61;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v33 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
  }
  v8 = v6 - 1;
  v9 = *v7 + v33;
  v10 = v7 + 1;
  v34 = v9;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  v11 = *v10;
  v12 = v8 - 1;
  v13 = v10 + 1;
  v37 = v11;
  if ( v34 != 2 * v11 + 6 || v11 < 1 || v11 > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v11 = v37;
  }
  *(_DWORD *)(*a1 + 20) = 102;
  *(_DWORD *)(*a1 + 24) = v11;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  a1[72] = v37;
  v38 = 0;
  if ( v37 > 0 )
  {
    v36 = a1 + 73;
    do
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v13 = *v2;
        v12 = v2[1];
      }
      v14 = *v13;
      v15 = v12 - 1;
      v16 = v13 + 1;
      v35 = v14;
      if ( !v15 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v16 = *v2;
        v15 = v2[1];
      }
      v17 = a1[8];
      v18 = (_DWORD *)a1[49];
      v40 = v15 - 1;
      v19 = *v16;
      v13 = v16 + 1;
      v20 = 0;
      if ( v17 <= 0 )
      {
LABEL_27:
        *(_DWORD *)(*a1 + 20) = 5;
        *(_DWORD *)(*a1 + 24) = v35;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      else
      {
        while ( v35 != *v18 )
        {
          ++v20;
          v18 += 21;
          if ( v20 >= v17 )
            goto LABEL_27;
        }
      }
      *v36 = v18;
      v18[5] = (v19 >> 4) & 0xF;
      v18[6] = v19 & 0xF;
      v21 = (_DWORD *)(*a1 + 24);
      *v21 = v35;
      v21[1] = v18[5];
      v21[2] = v18[6];
      *(_DWORD *)(*a1 + 20) = 103;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      v12 = v40;
      v2 = v39;
      v22 = ++v38 < v37;
      ++v36;
    }
    while ( v22 );
  }
  if ( !v12 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v13 = *v2;
    v12 = v2[1];
  }
  v23 = *v13;
  v24 = v12 - 1;
  v25 = v13 + 1;
  a1[90] = v23;
  if ( !v24 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v25 = *v2;
    v24 = v2[1];
  }
  v26 = *v25;
  v27 = v24 - 1;
  v28 = v25 + 1;
  a1[91] = v26;
  if ( v27 )
  {
LABEL_38:
    v29 = a1[90];
    v30 = *v28;
    a1[93] = v30 & 0xF;
    v31 = (_DWORD *)(*a1 + 24);
    a1[92] = (v30 >> 4) & 0xF;
    *v31 = v29;
    v31[1] = a1[91];
    v31[2] = a1[92];
    v31[3] = a1[93];
    *(_DWORD *)(*a1 + 20) = 104;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    *(_DWORD *)(a1[100] + 84) = 0;
    ++a1[31];
    *v2 = v28 + 1;
    v2[1] = v27 - 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v28 = *v2;
    v27 = v2[1];
    goto LABEL_38;
  }
  return 0;
}

// sub_1003C950 @ 0x1003C950
char __cdecl sub_1003C950(_DWORD *a1)
{
  unsigned __int8 **v1; // esi
  unsigned __int8 *v2; // ebx
  unsigned __int8 *v3; // edi
  int v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  int v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned int v10; // eax
  int v11; // edx
  unsigned __int8 *v12; // edi
  int j; // esi
  int v14; // eax
  int v15; // edx
  _DWORD *v16; // eax
  unsigned __int8 v17; // cl
  unsigned __int8 v18; // cl
  unsigned __int8 v19; // cl
  unsigned __int8 v20; // cl
  _DWORD *v21; // eax
  unsigned __int8 v22; // dl
  unsigned __int8 v23; // cl
  unsigned __int8 v24; // dl
  unsigned __int8 v25; // cl
  unsigned __int8 v26; // dl
  unsigned __int8 v27; // cl
  int v28; // esi
  int v29; // eax
  unsigned __int8 v30; // cl
  unsigned int v31; // eax
  int v32; // edi
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edx
  unsigned __int8 *v38; // [esp+10h] [ebp-128h]
  int v39; // [esp+14h] [ebp-124h]
  int i; // [esp+14h] [ebp-124h]
  int v41; // [esp+14h] [ebp-124h]
  int v42; // [esp+18h] [ebp-120h]
  int k; // [esp+18h] [ebp-120h]
  unsigned __int8 **v44; // [esp+1Ch] [ebp-11Ch]
  int v45; // [esp+20h] [ebp-118h]
  int v46; // [esp+24h] [ebp-114h]
  int v47; // [esp+28h] [ebp-110h]
  int v48; // [esp+2Ch] [ebp-10Ch]
  unsigned __int8 v49; // [esp+30h] [ebp-108h]
  unsigned int v50; // [esp+34h] [ebp-104h]
  _BYTE v51[256]; // [esp+38h] [ebp-100h] BYREF

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v3 = v1[1];
  v44 = v1;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v3 = v1[1];
  }
  v4 = 0;
  BYTE1(v4) = *v2;
  v5 = v3 - 1;
  v6 = v2 + 1;
  v39 = (unsigned __int16)v4;
  if ( !v5 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    {
      v6 = *v1;
      v4 = v39;
      v5 = v1[1];
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v7 = v5 - 1;
  v8 = *v6 + v4 - 2;
  v9 = v6 + 1;
  for ( i = v8; i > 0; v1 = v44 )
  {
    if ( !v7 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v9 = *v1;
      v7 = v1[1];
    }
    v10 = *v9;
    *(_DWORD *)(*a1 + 20) = 79;
    v11 = *a1;
    v12 = v7 - 1;
    ++v9;
    v50 = v10;
    *(_DWORD *)(v11 + 24) = v10;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    LOBYTE(v45) = 0;
    v42 = 0;
    for ( j = 1; j <= 16; ++j )
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v44[3])(a1) )
          return 0;
        v9 = *v44;
        v12 = v44[1];
      }
      v14 = *v9;
      *((_BYTE *)&v45 + j) = *v9;
      --v12;
      ++v9;
      v38 = v12;
      v42 += v14;
    }
    v15 = BYTE2(v45);
    v41 = i - 17;
    v16 = (_DWORD *)(*a1 + 24);
    *v16 = BYTE1(v45);
    v17 = HIBYTE(v45);
    v16[1] = v15;
    LOBYTE(v15) = v46;
    v16[2] = v17;
    v18 = BYTE1(v46);
    v16[3] = (unsigned __int8)v15;
    LOBYTE(v15) = BYTE2(v46);
    v16[4] = v18;
    v19 = HIBYTE(v46);
    v16[5] = (unsigned __int8)v15;
    LOBYTE(v15) = v47;
    v16[6] = v19;
    v16[7] = (unsigned __int8)v15;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v20 = BYTE2(v47);
    v21 = (_DWORD *)(*a1 + 24);
    *v21 = BYTE1(v47);
    v22 = HIBYTE(v47);
    v21[1] = v20;
    v23 = v48;
    v21[2] = v22;
    v24 = BYTE1(v48);
    v21[3] = v23;
    v25 = BYTE2(v48);
    v21[4] = v24;
    v26 = HIBYTE(v48);
    v21[5] = v25;
    v27 = v49;
    v21[6] = v26;
    v21[7] = v27;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v28 = v42;
    if ( v42 > 256 || v42 > v41 )
    {
      *(_DWORD *)(*a1 + 20) = 28;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v29 = 0;
    for ( k = 0; v29 < v28; k = v29 )
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v44[3])(a1) )
          return 0;
        v9 = *v44;
        v12 = v44[1];
        v29 = k;
      }
      v30 = *v9;
      --v12;
      ++v9;
      v51[v29++] = v30;
      v38 = v12;
    }
    v31 = v50;
    i = v41 - v28;
    if ( (v50 & 0x10) != 0 )
    {
      v31 = v50 - 16;
      v32 = (int)&a1[v50 + 28];
    }
    else
    {
      v32 = (int)&a1[v50 + 40];
    }
    if ( v31 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 29;
      *(_DWORD *)(*a1 + 24) = v31;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !*(_DWORD *)v32 )
      *(_DWORD *)v32 = sub_1003DD70(a1);
    v33 = *(_DWORD *)v32;
    v34 = v46;
    *(_DWORD *)v33 = v45;
    v35 = v47;
    *(_DWORD *)(v33 + 4) = v34;
    v36 = v48;
    *(_DWORD *)(v33 + 8) = v35;
    LOBYTE(v35) = v49;
    *(_DWORD *)(v33 + 12) = v36;
    *(_BYTE *)(v33 + 16) = v35;
    qmemcpy((void *)(*(_DWORD *)v32 + 17), v51, 0x100u);
    v7 = v38;
  }
  v1[1] = v7;
  *v1 = v9;
  return 1;
}

// sub_1003CCA0 @ 0x1003CCA0
char __cdecl sub_1003CCA0(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  int v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebp
  int v9; // eax
  unsigned __int8 *v10; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // eax
  int *v14; // esi
  unsigned __int8 **v15; // esi
  __int16 v16; // cx
  unsigned __int8 *v17; // ebp
  unsigned __int8 *v18; // ebx
  __int16 v19; // ax
  int v20; // ecx
  unsigned __int16 *v21; // esi
  _DWORD *v22; // eax
  int v23; // ecx
  unsigned __int8 **v25; // [esp+10h] [ebp-14h]
  __int16 v26; // [esp+14h] [ebp-10h]
  __int16 v27; // [esp+14h] [ebp-10h]
  int *v28; // [esp+18h] [ebp-Ch]
  int v29; // [esp+18h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-8h]
  int v31; // [esp+20h] [ebp-4h]
  int v32; // [esp+28h] [ebp+4h]
  int i; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  v25 = v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v32 = (unsigned __int16)v5;
  if ( !v6 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    {
      v7 = *v2;
      v6 = v2[1];
      v5 = v32;
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  for ( i = v9; i > 0; v2 = v25 )
  {
    if ( !v8 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v10 = *v2;
      v8 = v2[1];
    }
    v11 = *v10;
    *(_DWORD *)(*a1 + 20) = 80;
    --v8;
    ++v10;
    v12 = v11 & 0xF;
    *(_DWORD *)(*a1 + 24) = v12;
    *(_DWORD *)(*a1 + 28) = v11 >> 4;
    v30 = v11 >> 4;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    if ( v12 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 30;
      *(_DWORD *)(*a1 + 24) = v12;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !a1[v12 + 36] )
      a1[v12 + 36] = sub_1003DD50(a1);
    v13 = a1[v12 + 36];
    v14 = &dword_10050550;
    v31 = v13;
    v28 = &dword_10050550;
    do
    {
      if ( v30 )
      {
        if ( v8 )
        {
          v15 = v25;
        }
        else
        {
          v15 = v25;
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v25[3])(a1) )
            return 0;
          v10 = *v25;
          v8 = v25[1];
        }
        LOBYTE(v16) = 0;
        HIBYTE(v16) = *v10;
        v17 = v8 - 1;
        v18 = v10 + 1;
        v26 = v16;
        if ( !v17 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
            return 0;
          v18 = *v15;
          v17 = v15[1];
        }
        v14 = v28;
        v8 = v17 - 1;
        v27 = *v18 + v26;
        v10 = v18 + 1;
      }
      else
      {
        if ( !v8 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v25[3])(a1) )
            return 0;
          v10 = *v25;
          v8 = v25[1];
        }
        v19 = *v10;
        --v8;
        ++v10;
        v27 = v19;
      }
      v20 = *v14++;
      *(_WORD *)(v31 + 2 * v20) = v27;
      v28 = v14;
    }
    while ( (int)v14 < (int)dword_10050650 );
    if ( *(int *)(*a1 + 104) >= 2 )
    {
      v21 = (unsigned __int16 *)(v31 + 4);
      v29 = 8;
      do
      {
        v22 = (_DWORD *)(*a1 + 24);
        *v22 = *(v21 - 2);
        v22[1] = *(v21 - 1);
        v22[2] = *v21;
        v22[3] = v21[1];
        v22[4] = v21[2];
        v22[5] = v21[3];
        v22[6] = v21[4];
        v22[7] = v21[5];
        *(_DWORD *)(*a1 + 20) = 92;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
        v21 += 8;
        --v29;
      }
      while ( v29 );
    }
    v23 = i - 65;
    i -= 65;
    if ( v30 )
      i = v23 - 64;
  }
  *v2 = v10;
  v2[1] = v8;
  return 1;
}

// sub_1003CF10 @ 0x1003CF10
char __cdecl sub_1003CF10(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // eax
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned __int16 v11; // cx
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // ebx
  int v15; // [esp+14h] [ebp+4h]
  int v16; // [esp+14h] [ebp+4h]
  int v17; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v15 = (unsigned __int16)v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v5 = v15;
  }
  v8 = v6 - 1;
  v9 = *v7 + v5;
  v10 = v7 + 1;
  if ( v9 != 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  LOBYTE(v11) = 0;
  HIBYTE(v11) = *v10;
  v12 = v8 - 1;
  v13 = v10 + 1;
  v16 = v11;
  if ( v12 )
  {
LABEL_15:
    v17 = *v13 + v16;
    *(_DWORD *)(*a1 + 20) = 81;
    *(_DWORD *)(*a1 + 24) = v17;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    a1[63] = v17;
    v2[1] = v12 - 1;
    *v2 = v13 + 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v13 = *v2;
    v12 = v2[1];
    goto LABEL_15;
  }
  return 0;
}

// sub_1003D000 @ 0x1003D000
char __cdecl sub_1003D000(_DWORD *a1)
{
  char result; // al
  int v2; // eax

  if ( a1[94] || (result = sub_1003B660(a1)) != 0 )
  {
    v2 = *(_DWORD *)(a1[100] + 84);
    if ( a1[94] == v2 + 208 )
    {
      *(_DWORD *)(*a1 + 20) = 97;
      *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 84);
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
      a1[94] = 0;
LABEL_5:
      *(_DWORD *)(a1[100] + 84) = ((unsigned __int8)*(_DWORD *)(a1[100] + 84) + 1) & 7;
      return 1;
    }
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[5] + 20))(a1, v2);
    if ( result )
      goto LABEL_5;
  }
  return result;
}

// sub_1003D090 @ 0x1003D090
int __cdecl sub_1003D090(_DWORD *a1)
{
  int v1; // edx
  int result; // eax

  v1 = a1[100];
  a1[49] = 0;
  a1[31] = 0;
  a1[94] = 0;
  *(_BYTE *)(v1 + 80) = 0;
  *(_BYTE *)(a1[100] + 81) = 0;
  result = a1[100];
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// FUN_1003d0d0 @ 0x1003D0D0
// [binja] char* __fastcall sub_1003d0d0(int32_t arg1)
char *FUN_1003d0d0(int arg1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // ecx
  char *result; // eax
  int v6; // [esp+Ch] [ebp-4h] BYREF

  v1 = (_DWORD *)arg1;
  *(_DWORD *)(arg1 + 4) = 0;
  v6 = sub_1003E560();
  v2 = operator new(0x50u);
  if ( !v2 )
  {
    grim_noop();
    *(_DWORD *)(*v1 + 20) = 53;
    *(_DWORD *)(*v1 + 24) = 0;
    (*(void (__cdecl **)(_DWORD *, _DWORD *))*v1)(v1, v1);
  }
  *v2 = sub_1003D210;
  v2[1] = sub_1003D360;
  v2[2] = sub_1003D420;
  v2[3] = sub_1003D4D0;
  v2[4] = sub_1003D580;
  v2[5] = sub_1003D5F0;
  v2[6] = sub_1003D660;
  v2[7] = sub_1003D7E0;
  v2[8] = sub_1003D9D0;
  v2[9] = sub_1003DBC0;
  v2[10] = sub_1003DCC0;
  v2[11] = v6;
  v3 = v2 + 15;
  v4 = 2;
  do
  {
    *(v3 - 2) = 0;
    *v3-- = 0;
    --v4;
  }
  while ( v4 );
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 80;
  v1[1] = v2;
  result = getenv(VarName);
  if ( result )
  {
    LOBYTE(arg1) = 120;
    result = (char *)sscanf(result, "%ld%c", &v6, &arg1);
    if ( (int)result > 0 )
    {
      if ( (_BYTE)arg1 == 109 || (_BYTE)arg1 == 77 )
      {
        result = (char *)(1000000 * v6);
        v2[11] = 1000000 * v6;
      }
      else
      {
        result = (char *)(1000 * v6);
        v2[11] = 1000 * v6;
      }
    }
  }
  return result;
}

// sub_1003D210 @ 0x1003D210
int __cdecl sub_1003D210(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // edi
  _DWORD *i; // eax
  _DWORD *v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // esi
  int v9; // ecx
  int v11; // [esp+14h] [ebp+4h]

  v4 = a3;
  v11 = a1[1];
  if ( a3 > 0xFFE0 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 1;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (a3 & 7) != 0 )
  {
    v4 = 8 - (a3 & 7) + a3;
    a3 = v4;
  }
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  i = *(_DWORD **)(v11 + 4 * a2 + 48);
  v6 = 0;
  if ( i )
  {
    while ( i[2] < v4 )
    {
      v6 = i;
      i = (_DWORD *)*i;
      if ( !i )
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v7 = v4 + 16;
    if ( v6 )
      v8 = dword_10050548[a2];
    else
      v8 = dword_10050540[a2];
    if ( v8 > 65520 - v7 )
      v8 = 65520 - v7;
    for ( i = operator new(v8 + v7); !i; i = operator new(v8 + v7) )
    {
      v8 >>= 1;
      if ( v8 < 0x32 )
      {
        *(_DWORD *)(*a1 + 20) = 53;
        *(_DWORD *)(*a1 + 24) = 2;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    *(_DWORD *)(v11 + 72) += v8 + v7;
    *i = 0;
    i[1] = 0;
    i[2] = a3 + v8;
    if ( v6 )
      *v6 = i;
    else
      *(_DWORD *)(v11 + 4 * a2 + 48) = i;
    v4 = a3;
  }
  v9 = i[1];
  i[1] = v4 + v9;
  i[2] -= v4;
  return (int)i + v9 + 16;
}

// sub_1003D360 @ 0x1003D360
_DWORD *__cdecl sub_1003D360(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v4; // ebp
  _DWORD *v5; // esi
  int v6; // edx

  v3 = a3;
  v4 = a1[1];
  if ( a3 > 0xFFE0 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (a3 & 7) != 0 )
    v3 = 8 - (a3 & 7) + a3;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v5 = operator new(v3 + 16);
  if ( !v5 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  *(_DWORD *)(v4 + 72) += v3 + 16;
  v6 = *(_DWORD *)(v4 + 4 * a2 + 56);
  v5[1] = v3;
  *v5 = v6;
  v5[2] = 0;
  *(_DWORD *)(v4 + 4 * a2 + 56) = v5;
  return v5 + 4;
}

// sub_1003D420 @ 0x1003D420
int __cdecl sub_1003D420(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v5; // edi
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  unsigned int v11; // edx
  int v12; // [esp+1Ch] [ebp+Ch]

  v5 = a1[1];
  v6 = 0xFFE0 / a3;
  if ( (int)(0xFFE0 / a3) <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)v6 >= (int)a4 )
    v6 = a4;
  *(_DWORD *)(v5 + 76) = v6;
  result = sub_1003D210(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v6 >= a4 - v8 )
        v6 = a4 - v8;
      v9 = sub_1003D360(a1, a2, a3 * v6);
      if ( v6 )
      {
        v10 = (_DWORD *)(v12 + 4 * v8);
        v11 = v6;
        v8 += v6;
        do
        {
          *v10++ = v9;
          v9 = (_DWORD *)((char *)v9 + a3);
          --v11;
        }
        while ( v11 );
      }
    }
    while ( v8 < a4 );
    return v12;
  }
  return result;
}

// sub_1003D4D0 @ 0x1003D4D0
int __cdecl sub_1003D4D0(_DWORD *a1, unsigned int a2, int a3, signed int a4)
{
  int v4; // edi
  signed int v5; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  signed int v11; // edx
  int v12; // [esp+20h] [ebp+10h]

  v4 = a1[1];
  v5 = 0xFFE0u / (a3 << 7);
  if ( v5 <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( v5 >= a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  result = sub_1003D210(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v5 >= a4 - v8 )
        v5 = a4 - v8;
      v9 = sub_1003D360(a1, a2, (a3 * v5) << 7);
      if ( v5 )
      {
        v10 = (_DWORD *)(v12 + 4 * v8);
        v11 = v5;
        v8 += v5;
        do
        {
          *v10++ = v9;
          v9 += 32 * a3;
          --v11;
        }
        while ( v11 );
      }
    }
    while ( v8 < a4 );
    return v12;
  }
  return result;
}

// sub_1003D580 @ 0x1003D580
int __cdecl sub_1003D580(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1003D210(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 64);
  *(_DWORD *)(v6 + 64) = result;
  return result;
}

// sub_1003D5F0 @ 0x1003D5F0
int __cdecl sub_1003D5F0(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1003D210(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(v6 + 68) = result;
  return result;
}

// sub_1003D660 @ 0x1003D660
int __cdecl sub_1003D660(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // eax
  int v3; // esi
  int i; // edi
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  signed int v8; // edi
  int j; // esi
  int k; // esi

  v1 = (_DWORD *)a1[1];
  v2 = (_DWORD *)v1[16];
  v3 = 0;
  for ( i = 0; v2; v2 = (_DWORD *)v2[9] )
  {
    if ( !*v2 )
    {
      v5 = v2[2];
      v3 += v5 * v2[3];
      i += v5 * v2[1];
    }
  }
  for ( result = v1[17]; result; result = *(_DWORD *)(result + 36) )
  {
    if ( !*(_DWORD *)result )
    {
      v7 = *(_DWORD *)(result + 8);
      v3 += (v7 * *(_DWORD *)(result + 12)) << 7;
      i += (v7 * *(_DWORD *)(result + 4)) << 7;
    }
  }
  if ( v3 > 0 )
  {
    result = FUN_1003e530(a1, v3, i);
    if ( result < i )
    {
      result /= v3;
      v8 = result;
      if ( result <= 0 )
        v8 = 1;
    }
    else
    {
      v8 = 1000000000;
    }
    for ( j = v1[16]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( !*(_DWORD *)j )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(j + 4) - 1) / *(_DWORD *)(j + 12) + 1) > v8 )
        {
          *(_DWORD *)(j + 16) = v8 * *(_DWORD *)(j + 12);
          sub_1003E540(a1);
          *(_BYTE *)(j + 34) = 1;
        }
        else
        {
          *(_DWORD *)(j + 16) = *(_DWORD *)(j + 4);
        }
        *(_DWORD *)j = sub_1003D420(a1, 1u, *(_DWORD *)(j + 8), *(_DWORD *)(j + 16));
        result = 0;
        *(_DWORD *)(j + 20) = v1[19];
        *(_DWORD *)(j + 24) = 0;
        *(_DWORD *)(j + 28) = 0;
        *(_BYTE *)(j + 33) = 0;
      }
    }
    for ( k = v1[17]; k; k = *(_DWORD *)(k + 36) )
    {
      if ( !*(_DWORD *)k )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(k + 4) - 1) / *(_DWORD *)(k + 12) + 1) > v8 )
        {
          *(_DWORD *)(k + 16) = v8 * *(_DWORD *)(k + 12);
          sub_1003E540(a1);
          *(_BYTE *)(k + 34) = 1;
        }
        else
        {
          *(_DWORD *)(k + 16) = *(_DWORD *)(k + 4);
        }
        *(_DWORD *)k = sub_1003D4D0(a1, 1u, *(_DWORD *)(k + 8), *(_DWORD *)(k + 16));
        result = 0;
        *(_DWORD *)(k + 20) = v1[19];
        *(_DWORD *)(k + 24) = 0;
        *(_DWORD *)(k + 28) = 0;
        *(_BYTE *)(k + 33) = 0;
      }
    }
  }
  return result;
}

// sub_1003D7E0 @ 0x1003D7E0
int __cdecl sub_1003D7E0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebp
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // edi
  unsigned int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      FUN_1003d930(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    FUN_1003d930(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = *(_DWORD *)(a2 + 8);
    v11 = v8 - v9;
    for ( i = v5 - v9; v11 < i; ++v11 )
      sub_1003E510(*(_DWORD *)(*(_DWORD *)a2 + 4 * v11), v10);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// FUN_1003d930 @ 0x1003D930
// [binja] int32_t sub_1003d930(int32_t* arg1)
int FUN_1003d930(int *arg1)
{
  _DWORD *v1; // esi
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  int v5; // edi
  int v6; // ecx
  int v7; // ebp
  _DWORD *v8; // [esp+18h] [ebp+8h]
  int v9; // [esp+18h] [ebp+8h]
  char v10; // [esp+1Ch] [ebp+Ch]

  v1 = v8;
  v2 = v8[2];
  result = v8[4];
  v4 = v2 * v8[6];
  v5 = 0;
  v9 = v2;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v5;
      if ( v1[5] < result )
        result = v1[5];
      v6 = v5 + v1[6];
      if ( result >= v1[7] - v6 )
        result = v1[7] - v6;
      if ( result >= v1[1] - v6 )
        result = v1[1] - v6;
      if ( result <= 0 )
        break;
      v7 = v2 * result;
      if ( v10 )
        ((void (__cdecl *)(int *, _DWORD *, _DWORD, int, int))v1[11])(arg1, v1 + 10, *(_DWORD *)(*v1 + 4 * v5), v4, v7);
      else
        ((void (__cdecl *)(int *, _DWORD *, _DWORD, int, int))v1[10])(arg1, v1 + 10, *(_DWORD *)(*v1 + 4 * v5), v4, v7);
      result = v1[4];
      v5 += v1[5];
      v4 += v7;
      if ( v5 >= result )
        break;
      v2 = v9;
    }
  }
  return result;
}

// sub_1003D9D0 @ 0x1003D9D0
int __cdecl sub_1003D9D0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ebx
  int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      FUN_1003db20(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    FUN_1003db20(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = v8 - v9;
    v11 = v5 - v9;
    for ( i = *(_DWORD *)(a2 + 8) << 7; v10 < v11; ++v10 )
      sub_1003E510(*(_DWORD *)(*(_DWORD *)a2 + 4 * v10), i);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// FUN_1003db20 @ 0x1003DB20
// [binja] int32_t sub_1003db20(int32_t arg1)
int FUN_1003db20(int arg1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // ebp
  int v4; // ebx
  int v5; // edi
  int v6; // ecx
  int v7; // ebp
  _DWORD *v8; // [esp+18h] [ebp+8h]
  int v9; // [esp+18h] [ebp+8h]
  char v10; // [esp+1Ch] [ebp+Ch]

  v1 = v8;
  result = v8[4];
  v3 = v8[2] << 7;
  v4 = v8[6] * v3;
  v5 = 0;
  v9 = v3;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v5;
      if ( v1[5] < result )
        result = v1[5];
      v6 = v1[6] + v5;
      if ( result >= v1[7] - v6 )
        result = v1[7] - v6;
      if ( result >= v1[1] - v6 )
        result = v1[1] - v6;
      if ( result <= 0 )
        break;
      v7 = v3 * result;
      if ( v10 )
        ((void (__cdecl *)(int, _DWORD *, _DWORD, int, int))v1[11])(arg1, v1 + 10, *(_DWORD *)(*v1 + 4 * v5), v4, v7);
      else
        ((void (__cdecl *)(int, _DWORD *, _DWORD, int, int))v1[10])(arg1, v1 + 10, *(_DWORD *)(*v1 + 4 * v5), v4, v7);
      result = v1[4];
      v5 += v1[5];
      v4 += v7;
      if ( v5 >= result )
        break;
      v3 = v9;
    }
  }
  return result;
}

// sub_1003DBC0 @ 0x1003DBC0
_DWORD *__cdecl sub_1003DBC0(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // edi
  int i; // edi
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  int v8; // ebp
  _DWORD *result; // eax
  _DWORD *v10; // edi
  int v11; // ebp

  v2 = (_DWORD *)a1[1];
  v3 = a2;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 == 1 )
  {
    for ( i = v2[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( *(_BYTE *)(i + 34) )
      {
        *(_BYTE *)(i + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
      }
    }
    v5 = v2[17];
    for ( v2[16] = 0; v5; v5 = *(_DWORD *)(v5 + 36) )
    {
      if ( *(_BYTE *)(v5 + 34) )
      {
        *(_BYTE *)(v5 + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(v5 + 48))(a1, v5 + 40);
      }
    }
    v3 = a2;
    v2[17] = 0;
  }
  v6 = (_DWORD *)v2[v3 + 14];
  v2[v3 + 14] = 0;
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      v8 = v6[2] + v6[1] + 16;
      if ( v6 )
        operator delete(v6);
      v2[18] -= v8;
      v6 = v7;
    }
    while ( v7 );
    v3 = a2;
  }
  result = (_DWORD *)v2[v3 + 12];
  v2[v3 + 12] = 0;
  if ( result )
  {
    do
    {
      v10 = (_DWORD *)*result;
      v11 = result[2] + result[1] + 16;
      if ( result )
        operator delete(result);
      v2[18] -= v11;
      result = v10;
    }
    while ( v10 );
  }
  return result;
}

// sub_1003DCC0 @ 0x1003DCC0
void __cdecl sub_1003DCC0(int a1)
{
  signed int i; // esi

  for ( i = 1; i >= 0; --i )
    sub_1003DBC0((_DWORD *)a1, i);
  operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  grim_noop();
}

// sub_1003DD00 @ 0x1003DD00
int __cdecl sub_1003DD00(int a1)
{
  int result; // eax

  result = (*(int (__cdecl **)(int, int))(*(_DWORD *)(a1 + 4) + 36))(a1, 1);
  *(_DWORD *)(a1 + 16) = *(_BYTE *)(a1 + 12) != 0 ? 200 : 100;
  return result;
}

// sub_1003DD30 @ 0x1003DD30
int __cdecl sub_1003DD30(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = (*(int (__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

// sub_1003DD50 @ 0x1003DD50
int __cdecl sub_1003DD50(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

// sub_1003DD70 @ 0x1003DD70
int __cdecl sub_1003DD70(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

// sub_1003DD90 @ 0x1003DD90
int __cdecl sub_1003DD90(int a1)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  int i; // eax
  int v12; // ebx
  _DWORD *v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int result; // eax
  int v18; // [esp-10h] [ebp-18h]
  int v19; // [esp-10h] [ebp-18h]
  int v20; // [esp-10h] [ebp-18h]
  int v21; // [esp+Ch] [ebp+4h]

  if ( *(_DWORD *)(a1 + 16) != 202 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 48);
  if ( 8 * v2 > v3 )
  {
    if ( 4 * v2 > v3 )
    {
      if ( 2 * v2 > v3 )
      {
        v7 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 24);
        *(_DWORD *)(a1 + 96) = v7;
        *(_DWORD *)(a1 + 276) = 8;
      }
      else
      {
        v6 = sub_1003E460(*(_DWORD *)(a1 + 24), 2);
        v20 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = v6;
        *(_DWORD *)(a1 + 96) = sub_1003E460(v20, 2);
        *(_DWORD *)(a1 + 276) = 4;
      }
    }
    else
    {
      v5 = sub_1003E460(*(_DWORD *)(a1 + 24), 4);
      v19 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 92) = v5;
      *(_DWORD *)(a1 + 96) = sub_1003E460(v19, 4);
      *(_DWORD *)(a1 + 276) = 2;
    }
  }
  else
  {
    v4 = sub_1003E460(*(_DWORD *)(a1 + 24), 8);
    v18 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 92) = v4;
    *(_DWORD *)(a1 + 96) = sub_1003E460(v18, 8);
    *(_DWORD *)(a1 + 276) = 1;
  }
  v8 = *(_DWORD *)(a1 + 196);
  v21 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v9 = (_DWORD *)(v8 + 12);
    do
    {
      v10 = *(_DWORD *)(a1 + 276);
      for ( i = v10; i < 8; i *= 2 )
      {
        if ( 2 * i * *(v9 - 1) > v10 * *(_DWORD *)(a1 + 268) )
          break;
        if ( 2 * i * *v9 > v10 * *(_DWORD *)(a1 + 272) )
          break;
      }
      v9[6] = i;
      v9 += 21;
      ++v21;
    }
    while ( v21 < *(_DWORD *)(a1 + 32) );
  }
  v12 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v13 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    do
    {
      v14 = sub_1003E460(*(_DWORD *)(a1 + 24) * *v13 * *(v13 - 7), 8 * *(_DWORD *)(a1 + 268));
      v15 = *v13 * *(v13 - 6);
      v13[1] = v14;
      v13[2] = sub_1003E460(*(_DWORD *)(a1 + 28) * v15, 8 * *(_DWORD *)(a1 + 272));
      ++v12;
      v13 += 21;
    }
    while ( v12 < *(_DWORD *)(a1 + 32) );
  }
  switch ( *(_DWORD *)(a1 + 40) )
  {
    case 1:
      *(_DWORD *)(a1 + 100) = 1;
      break;
    case 2:
    case 3:
      *(_DWORD *)(a1 + 100) = 3;
      break;
    case 4:
    case 5:
      *(_DWORD *)(a1 + 100) = 4;
      break;
    default:
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      break;
  }
  v16 = 1;
  if ( !*(_BYTE *)(a1 + 74) )
    v16 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 104) = v16;
  result = sub_1003DFB0(a1);
  if ( (_BYTE)result )
  {
    result = *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 108) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 1;
  }
  return result;
}

// sub_1003DFB0 @ 0x1003DFB0
char __cdecl sub_1003DFB0(int a1)
{
  _DWORD *v1; // ecx
  char result; // al
  int v3; // edx

  if ( *(_BYTE *)(a1 + 72) )
    return 0;
  if ( *(_BYTE *)(a1 + 264) )
    return 0;
  if ( *(_DWORD *)(a1 + 36) != 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 32) != 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 40) != 2 )
    return 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
    return 0;
  v1 = *(_DWORD **)(a1 + 196);
  if ( v1[2] != 2 )
    return 0;
  result = 1;
  if ( v1[23] != 1 )
    return 0;
  if ( v1[44] != 1 )
    return 0;
  if ( (int)v1[3] > 2 )
    return 0;
  if ( v1[24] != 1 )
    return 0;
  if ( v1[45] != 1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 276);
  if ( v1[9] != v3 || v1[30] != v3 || v1[51] != v3 )
    return 0;
  return result;
}

// sub_1003E040 @ 0x1003E040
char __cdecl sub_1003E040(int a1)
{
  int v1; // ebp
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // edx
  char v7; // al
  char result; // al
  int v9; // ecx
  int v10; // eax

  v1 = a1;
  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 380) = v2;
  *(_DWORD *)v2 = sub_1003E2D0;
  *(_DWORD *)(v2 + 4) = sub_1003E430;
  *(_BYTE *)(v2 + 8) = 0;
  v3 = *(_DWORD *)(a1 + 380);
  sub_1003DD90(a1);
  v4 = (**(int (__cdecl ***)(int, int, int))(v1 + 4))(v1, 1, 1408) + 256;
  v5 = 0;
  *(_DWORD *)(a1 + 284) = v4;
  memset((void *)(v4 - 256), 0, 0x100u);
  do
  {
    *(_BYTE *)(v5 + v4) = v5;
    ++v5;
  }
  while ( v5 <= 255 );
  v6 = v4 + 128;
  memset((void *)(v6 + 128), 0xFFu, 0x180u);
  memset((void *)(v6 + 512), 0, 0x180u);
  qmemcpy((void *)(v6 + 896), *(const void **)(a1 + 284), 0x80u);
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(v3 + 16) = sub_1003DFB0(a1);
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  v7 = *(_BYTE *)(a1 + 74);
  if ( !v7 || !*(_BYTE *)(a1 + 64) )
  {
    *(_BYTE *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 89) = 0;
    *(_BYTE *)(a1 + 90) = 0;
  }
  if ( v7 )
  {
    if ( *(_BYTE *)(a1 + 65) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_DWORD *)(a1 + 100) == 3 )
    {
      if ( *(_DWORD *)(a1 + 116) )
      {
        *(_BYTE *)(a1 + 89) = 1;
      }
      else if ( *(_BYTE *)(a1 + 80) )
      {
        *(_BYTE *)(a1 + 90) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 88) = 1;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 88) = 1;
      *(_BYTE *)(a1 + 89) = 0;
      *(_BYTE *)(a1 + 90) = 0;
      *(_DWORD *)(a1 + 116) = 0;
    }
    if ( *(_BYTE *)(a1 + 88) )
    {
      sub_10044210(a1);
      *(_DWORD *)(v3 + 20) = *(_DWORD *)(a1 + 420);
    }
    if ( *(_BYTE *)(a1 + 90) || *(_BYTE *)(a1 + 89) )
    {
      sub_10042EA0(a1);
      *(_DWORD *)(v3 + 24) = *(_DWORD *)(a1 + 420);
    }
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(v3 + 16) )
    {
      sub_100428E0(a1);
    }
    else
    {
      sub_10042310(a1);
      sub_10041BA0(a1);
    }
    sub_10041850(a1, *(_BYTE *)(a1 + 90));
  }
  sub_10041590(a1);
  if ( *(_BYTE *)(a1 + 201) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 200) )
  {
    sub_100406A0(a1);
  }
  else
  {
    sub_10040070(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) || (LOBYTE(a1) = 0, *(_BYTE *)(v1 + 64)) )
    LOBYTE(a1) = 1;
  sub_1003EC50(v1, a1);
  if ( !*(_BYTE *)(v1 + 65) )
    sub_1003E570(v1, 0);
  (*(void (__cdecl **)(int))(*(_DWORD *)(v1 + 4) + 24))(v1);
  result = (*(int (__cdecl **)(int))(*(_DWORD *)(v1 + 396) + 8))(v1);
  v9 = *(_DWORD *)(v1 + 8);
  if ( v9 )
  {
    result = *(_BYTE *)(v1 + 64);
    if ( !result )
    {
      result = *(_BYTE *)(*(_DWORD *)(v1 + 396) + 16);
      if ( result )
      {
        v10 = *(_DWORD *)(v1 + 32);
        if ( *(_BYTE *)(v1 + 200) )
          v10 = 3 * v10 + 2;
        *(_DWORD *)(v9 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 8) = v10 * *(_DWORD *)(v1 + 280);
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 12) = 0;
        result = *(_BYTE *)(v1 + 90);
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = (result != 0) + 2;
        ++*(_DWORD *)(v3 + 12);
      }
    }
  }
  return result;
}

// sub_1003E2D0 @ 0x1003E2D0
char __cdecl sub_1003E2D0(int a1)
{
  int v1; // edi
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, 0);
    (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, 2);
    (**(void (__cdecl ***)(int, int))(a1 + 384))(a1, 2);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) && !*(_DWORD *)(a1 + 116) )
    {
      if ( *(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 90) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      }
      else if ( *(_BYTE *)(a1 + 88) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 20);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void (__cdecl ***)(int))(a1 + 408))(a1);
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 388) + 8))(a1);
    if ( !*(_BYTE *)(a1 + 65) )
    {
      if ( !*(_BYTE *)(v1 + 16) )
        (**(void (__cdecl ***)(int))(a1 + 416))(a1);
      (**(void (__cdecl ***)(int))(a1 + 412))(a1);
      if ( *(_BYTE *)(a1 + 74) )
        (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8 *)(v1 + 8));
      (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      (**(void (__cdecl ***)(int, _DWORD))(a1 + 384))(a1, 0);
    }
  }
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = *(_DWORD *)(v1 + 12) + (*(_BYTE *)(v1 + 8) != 0) + 1;
    LOBYTE(v2) = *(_BYTE *)(a1 + 64);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 396) + 17);
      if ( !(_BYTE)v2 )
      {
        v2 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(v2 + 16) += (*(_BYTE *)(a1 + 90) != 0) + 1;
      }
    }
  }
  return v2;
}

// sub_1003E430 @ 0x1003E430
int __cdecl sub_1003E430(int a1)
{
  int result; // eax
  int v2; // esi

  result = a1;
  v2 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(a1 + 74) )
    result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 420) + 8))(a1);
  ++*(_DWORD *)(v2 + 12);
  return result;
}

// sub_1003E460 @ 0x1003E460
int __cdecl sub_1003E460(int a1, int a2)
{
  return (a1 + a2 - 1) / a2;
}

// sub_1003E470 @ 0x1003E470
int __cdecl sub_1003E470(int a1, int a2)
{
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

// sub_1003E490 @ 0x1003E490
const void **__cdecl sub_1003E490(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // ebx
  const void **result; // eax
  void **v8; // edx

  v6 = a5;
  result = (const void **)(a1 + 4 * a2);
  v8 = (void **)(a3 + 4 * a4);
  if ( a5 > 0 )
  {
    do
    {
      qmemcpy(*v8++, *result++, a6);
      --v6;
    }
    while ( v6 );
  }
  return result;
}

// sub_1003E4E0 @ 0x1003E4E0
int __cdecl sub_1003E4E0(const void *a1, void *a2, int a3)
{
  qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
  return a3 << 7;
}

// sub_1003E510 @ 0x1003E510
int __cdecl sub_1003E510(void *a1, unsigned int a2)
{
  memset(a1, 0, a2);
  return 0;
}

// FUN_1003e530 @ 0x1003E530
// [binja] int32_t sub_1003e530(int32_t arg1) __pure
int FUN_1003e530(int arg1)
{
  int v2; // [esp+Ch] [ebp+Ch]

  return v2;
}

// sub_1003E540 @ 0x1003E540
int __cdecl sub_1003E540(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_1003E560 @ 0x1003E560
int sub_1003E560()
{
  return 0;
}

// sub_1003E570 @ 0x1003E570
int __cdecl sub_1003E570(int a1, char a2)
{
  _DWORD *v3; // eax
  int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v7; // ebx
  _DWORD *v8; // ebp
  int v9; // edi
  int v10; // eax
  int result; // eax
  int v12; // ebp
  _DWORD *v13; // edi
  _DWORD *v14; // ebx
  int v15; // [esp+10h] [ebp-8h]
  _DWORD *v16; // [esp+14h] [ebp-4h]
  int v17; // [esp+1Ch] [ebp+4h]
  int v18; // [esp+20h] [ebp+8h]
  int v19; // [esp+20h] [ebp+8h]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 384) = v3;
  v16 = v3;
  *v3 = sub_1003E6F0;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 412) + 8) )
  {
    if ( *(int *)(a1 + 276) < 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v4 = *(_DWORD *)(a1 + 384);
    v5 = *(_DWORD *)(a1 + 276);
    v15 = v4;
    v6 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD *)(a1 + 32));
    *(_DWORD *)(v4 + 56) = v6;
    *(_DWORD *)(v4 + 60) = v6 + 4 * *(_DWORD *)(a1 + 32);
    v7 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v18 = v5 + 4;
      v8 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 12);
      do
      {
        v9 = *v8 * v8[6] / *(_DWORD *)(a1 + 276) * v18;
        v17 = *v8 * v8[6] / *(_DWORD *)(a1 + 276);
        v10 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * v9) + 4 * v17;
        *(_DWORD *)(*(_DWORD *)(v15 + 56) + 4 * v7) = v10;
        *(_DWORD *)(*(_DWORD *)(v15 + 60) + 4 * v7++) = v10 + 4 * v9;
        v8 += 21;
      }
      while ( v7 < *(_DWORD *)(a1 + 32) );
    }
    v19 = *(_DWORD *)(a1 + 276) + 2;
  }
  else
  {
    v19 = *(_DWORD *)(a1 + 276);
  }
  result = *(_DWORD *)(a1 + 196);
  v12 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v13 = (_DWORD *)(result + 36);
    v14 = v16 + 2;
    do
    {
      *v14 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
               a1,
               1,
               *v13 * *(v13 - 2),
               v19 * (*v13 * *(v13 - 6) / *(_DWORD *)(a1 + 276)));
      result = *(_DWORD *)(a1 + 32);
      ++v12;
      ++v14;
      v13 += 21;
    }
    while ( v12 < result );
  }
  return result;
}

// sub_1003E6F0 @ 0x1003E6F0
int __cdecl sub_1003E6F0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ecx
  _DWORD *v6; // edx
  int v7; // eax
  _DWORD *v8; // ebp
  int v9; // edi
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ebp
  _DWORD *v13; // esi
  int v14; // ebp
  _DWORD *v15; // edx
  char *v16; // ecx
  int v17; // edi
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // eax
  int *v22; // [esp+8h] [ebp-20h]
  _DWORD *v23; // [esp+Ch] [ebp-1Ch]
  int v24; // [esp+10h] [ebp-18h]
  int v25; // [esp+14h] [ebp-14h]
  _DWORD *v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  char *v28; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]
  int v30; // [esp+30h] [ebp+8h]

  v2 = a1;
  result = a1[96];
  v4 = 0;
  v29 = result;
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      *(_DWORD *)(result + 4) = sub_1003EC20;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 4;
      return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  else if ( *(_BYTE *)(a1[103] + 8) )
  {
    *(_DWORD *)(result + 4) = sub_1003E930;
    v5 = (_DWORD *)a1[96];
    v25 = a1[69];
    v27 = v5;
    v30 = 0;
    if ( (int)a1[8] > 0 )
    {
      v6 = (_DWORD *)(a1[49] + 12);
      v23 = v6;
      v22 = v5 + 2;
      while ( 1 )
      {
        v7 = *v6 * v6[6] / v2[69];
        v8 = *(_DWORD **)(v5[14] + 4 * v4);
        v9 = *v22;
        v10 = *(_DWORD **)(v5[15] + 4 * v4);
        v26 = v8;
        if ( v7 * (v25 + 2) > 0 )
        {
          v11 = v10;
          v28 = (char *)((char *)v8 - (char *)v10);
          v24 = v7 * (v25 + 2);
          do
          {
            v12 = *(_DWORD *)((char *)v11 + v9 - (_DWORD)v10);
            *v11 = v12;
            *(_DWORD *)((char *)v11++ + (_DWORD)v28) = v12;
            --v24;
          }
          while ( v24 );
          v8 = v26;
          v4 = v30;
        }
        if ( 2 * v7 > 0 )
        {
          v13 = &v10[v25 * v7];
          v14 = v9 - (_DWORD)v10;
          v15 = (_DWORD *)(v9 + 4 * v7 * (v25 - 2));
          v16 = (char *)v10 - v9;
          v17 = 2 * v7;
          do
          {
            *(_DWORD *)((char *)v15 + (_DWORD)v16) = *(_DWORD *)((char *)v13 + v14);
            *v13++ = *v15++;
            --v17;
          }
          while ( v17 );
          v8 = v26;
          v4 = v30;
        }
        if ( v7 > 0 )
        {
          v18 = 0;
          v19 = 4 * v7;
          v20 = v7;
          do
          {
            v21 = v18 - v19;
            v18 += 4;
            --v20;
            *(_DWORD *)((char *)v8 + v21) = *v8;
          }
          while ( v20 );
        }
        v30 = ++v4;
        ++v22;
        v23 += 21;
        if ( v4 >= a1[8] )
          break;
        v2 = a1;
        v5 = v27;
        v6 = v23;
      }
      result = v29;
    }
    *(_DWORD *)(result + 64) = 0;
    *(_DWORD *)(result + 68) = 0;
    *(_DWORD *)(result + 76) = 0;
    *(_DWORD *)(result + 52) = 0;
    *(_BYTE *)(result + 48) = 0;
  }
  else
  {
    *(_DWORD *)(result + 52) = 0;
    *(_DWORD *)(result + 4) = sub_1003E8C0;
    *(_BYTE *)(result + 48) = 0;
  }
  return result;
}

// sub_1003E8C0 @ 0x1003E8C0
unsigned int __cdecl sub_1003E8C0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // esi
  unsigned int result; // eax
  unsigned int v6; // ebp

  v4 = a1[96];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[97] + 12))(a1, v4 + 8);
    if ( !result )
      return result;
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = a1[69];
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int, int, int, int))(a1[98] + 4))(
    a1,
    v4 + 8,
    v4 + 52,
    v6,
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 52);
  if ( result >= v6 )
  {
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = 0;
  }
  return result;
}

// sub_1003E930 @ 0x1003E930
unsigned int __cdecl sub_1003E930(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4)
{
  _DWORD *v4; // edi
  int v5; // ebx
  unsigned int result; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // ebp
  int v15; // esi
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  _DWORD *v19; // eax
  int v20; // esi
  signed int v21; // ecx
  _DWORD *v22; // edx
  int v23; // eax
  int v24; // ebp
  int v25; // esi
  int v26; // ecx
  _DWORD *v27; // edi
  int v28; // edx
  bool v29; // zf
  int v30; // [esp+10h] [ebp-18h]
  int v31; // [esp+10h] [ebp-18h]
  _DWORD *i; // [esp+14h] [ebp-14h]
  signed int v33; // [esp+14h] [ebp-14h]
  int v34; // [esp+18h] [ebp-10h]
  int v35; // [esp+18h] [ebp-10h]
  int v36; // [esp+1Ch] [ebp-Ch]
  int v37; // [esp+20h] [ebp-8h]
  int v38; // [esp+24h] [ebp-4h]
  _DWORD *v39; // [esp+30h] [ebp+8h]
  int v40; // [esp+34h] [ebp+Ch]
  _DWORD *v41; // [esp+38h] [ebp+10h]

  v4 = a1;
  v5 = a1[96];
  v38 = v5;
  if ( !*(_BYTE *)(v5 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[97] + 12))(a1, *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56));
    if ( !result )
      return result;
    v7 = *(_DWORD *)(v5 + 76) + 1;
    *(_BYTE *)(v5 + 48) = 1;
    *(_DWORD *)(v5 + 76) = v7;
  }
  v8 = *(_DWORD *)(v5 + 68);
  if ( !v8 )
  {
LABEL_9:
    v10 = *(_DWORD *)(v5 + 76);
    *(_DWORD *)(v5 + 52) = 0;
    *(_DWORD *)(v5 + 72) = a1[69] - 1;
    if ( v10 == a1[70] )
    {
      v11 = a1[49];
      v34 = a1[96];
      v30 = 0;
      if ( (int)a1[8] > 0 )
      {
        v12 = (_DWORD *)(v11 + 12);
        for ( i = (_DWORD *)(v11 + 12); ; v12 = i )
        {
          v13 = *v12 * v12[6];
          v14 = v13 / a1[69];
          v15 = v12[8] % (unsigned int)v13;
          if ( !v15 )
            v15 = v13;
          v16 = v30;
          if ( !v30 )
            *(_DWORD *)(v34 + 72) = (v15 - 1) / v14 + 1;
          v17 = 2 * v14;
          if ( 2 * v14 > 0 )
          {
            v18 = *(_DWORD *)(*(_DWORD *)(v34 + 4 * *(_DWORD *)(v34 + 64) + 56) + 4 * v30) + 4 * v15;
            v19 = (_DWORD *)v18;
            do
            {
              *v19++ = *(_DWORD *)(v18 - 4);
              --v17;
            }
            while ( v17 );
            v16 = v30;
          }
          v30 = v16 + 1;
          i += 21;
          if ( v16 + 1 >= a1[8] )
            break;
        }
      }
    }
    *(_DWORD *)(v5 + 68) = 1;
    goto LABEL_23;
  }
  v9 = v8 - 1;
  if ( v9 )
  {
    result = v9 - 1;
    if ( result )
      return result;
    (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
      a1,
      *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56),
      v5 + 52,
      *(_DWORD *)(v5 + 72),
      a2,
      a3,
      a4);
    result = *(_DWORD *)(v5 + 52);
    if ( result < *(_DWORD *)(v5 + 72) )
      return result;
    result = a4;
    *(_DWORD *)(v5 + 68) = 0;
    if ( *a3 >= a4 )
      return result;
    goto LABEL_9;
  }
LABEL_23:
  (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
    a1,
    *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56),
    v5 + 52,
    *(_DWORD *)(v5 + 72),
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v5 + 72);
  if ( *(_DWORD *)(v5 + 52) >= result )
  {
    if ( *(_DWORD *)(v5 + 76) == 1 )
    {
      v20 = a1[96];
      result = a1[49];
      v36 = a1[69];
      v21 = 0;
      v31 = v20;
      v33 = 0;
      if ( (int)a1[8] > 0 )
      {
        v22 = (_DWORD *)(result + 12);
        v41 = (_DWORD *)(result + 12);
        while ( 1 )
        {
          v23 = *v22 * v22[6] / v4[69];
          v24 = *(_DWORD *)(*(_DWORD *)(v20 + 56) + 4 * v21);
          v25 = *(_DWORD *)(*(_DWORD *)(v20 + 60) + 4 * v21);
          v37 = v24;
          if ( v23 > 0 )
          {
            v40 = 4 * v23;
            v26 = 0;
            v39 = (_DWORD *)(v25 + 4 * v23 * (v36 + 2));
            v27 = (_DWORD *)(v25 + 4 * v23 * (v36 + 1));
            v28 = v24 - v25;
            v35 = v23;
            while ( 1 )
            {
              *(_DWORD *)(v26 - v40 + v24) = *(_DWORD *)((char *)v27 + v28);
              *(_DWORD *)(v26 - v40 + v25) = *v27;
              *(_DWORD *)((char *)v39 + v28) = *(_DWORD *)(v28 + v26 + v25);
              *v39 = *(_DWORD *)(v26 + v25);
              v26 += 4;
              ++v27;
              v29 = v35 == 1;
              ++v39;
              --v35;
              if ( v29 )
                break;
              v24 = v37;
            }
            v21 = v33;
            v5 = v38;
            v4 = a1;
          }
          result = v4[8];
          v33 = ++v21;
          v41 += 21;
          if ( v21 >= (int)result )
            break;
          v22 = v41;
          v20 = v31;
        }
      }
    }
    *(_DWORD *)(v5 + 64) ^= 1u;
    *(_BYTE *)(v5 + 48) = 0;
    *(_DWORD *)(v5 + 52) = v4[69] + 1;
    *(_DWORD *)(v5 + 72) = v4[69] + 2;
    *(_DWORD *)(v5 + 68) = 2;
  }
  return result;
}

// sub_1003EC20 @ 0x1003EC20
int __cdecl sub_1003EC20(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD *)(a1 + 392) + 4))(
           a1,
           0,
           0,
           0,
           a2,
           a3,
           a4);
}

// sub_1003EC50 @ 0x1003EC50
char __cdecl sub_1003EC50(int a1, char a2)
{
  _DWORD *v3; // ebp
  int v4; // eax
  int *v5; // edi
  _DWORD *v6; // ebp
  int v7; // ecx
  int v8; // ebx
  int v9; // eax
  int *v10; // ecx
  int v11; // edx
  int v13; // [esp-Ch] [ebp-18h]
  int v14; // [esp-8h] [ebp-14h]
  _DWORD *v15; // [esp+10h] [ebp+4h]
  int v16; // [esp+14h] [ebp+8h]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 116);
  LOBYTE(v4) = a2;
  *(_DWORD *)(a1 + 388) = v3;
  v15 = v3;
  *v3 = sub_1003ED60;
  v3[2] = sub_1003EDC0;
  v3[28] = 0;
  if ( a2 )
  {
    v16 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v5 = (int *)(*(_DWORD *)(a1 + 196) + 12);
      v6 = v3 + 18;
      do
      {
        v7 = *v5;
        if ( *(_BYTE *)(a1 + 200) )
          v7 *= 3;
        v8 = *(_DWORD *)(a1 + 4);
        v14 = v7;
        v13 = sub_1003E470(v5[5], *v5);
        v9 = sub_1003E470(v5[4], *(v5 - 1));
        *v6 = (*(int (__cdecl **)(int, int, int, int, int, int))(v8 + 20))(a1, 1, 1, v9, v13, v14);
        LOBYTE(v4) = v16 + 1;
        ++v6;
        v5 += 21;
        ++v16;
      }
      while ( v16 < *(_DWORD *)(a1 + 32) );
      v3 = v15;
    }
    v3[1] = sub_1003F200;
    v3[3] = sub_1003F470;
    v3[4] = v3 + 18;
  }
  else
  {
    v4 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v10 = v3 + 8;
    v11 = 10;
    do
    {
      *v10++ = v4;
      v4 += 128;
      --v11;
    }
    while ( v11 );
    v3[4] = 0;
    v3[1] = sub_1003F1F0;
    v3[3] = sub_1003EF50;
  }
  return v4;
}

// sub_1003ED60 @ 0x1003ED60
_DWORD *__cdecl sub_1003ED60(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edi
  int v3; // ecx
  int v4; // ecx

  result = (_DWORD *)a1[97];
  v2 = a1[72];
  a1[32] = 0;
  if ( v2 <= 1 )
  {
    v3 = a1[73];
    if ( a1[70] == 1 )
      v4 = *(_DWORD *)(v3 + 72);
    else
      v4 = *(_DWORD *)(v3 + 12);
    result[7] = v4;
    result[5] = 0;
    result[6] = 0;
  }
  else
  {
    result[7] = 1;
    result[5] = 0;
    result[6] = 0;
  }
  return result;
}

// sub_1003EDC0 @ 0x1003EDC0
char __cdecl sub_1003EDC0(int a1)
{
  _DWORD *v2; // edi
  _WORD *v3; // eax
  int v4; // ebx
  int v5; // ebp
  int v6; // ecx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // edi
  int v11; // [esp+10h] [ebp-Ch]
  _WORD **v12; // [esp+14h] [ebp-8h]
  _DWORD *v13; // [esp+18h] [ebp-4h]
  char v14; // [esp+20h] [ebp+4h]

  v2 = *(_DWORD **)(a1 + 388);
  v3 = (_WORD *)v2[4];
  v4 = 0;
  v13 = v2;
  if ( v3 )
  {
    LOBYTE(v3) = *(_BYTE *)(a1 + 73);
    if ( (_BYTE)v3 )
    {
      LOBYTE(v3) = *(_BYTE *)(a1 + 200);
      v14 = 0;
      if ( (_BYTE)v3 )
      {
        if ( *(_DWORD *)(a1 + 140) )
        {
          if ( !v2[28] )
            v2[28] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD *)(a1 + 32));
          v5 = v2[28];
          v3 = *(_WORD **)(a1 + 196);
          if ( *(int *)(a1 + 32) > 0 )
          {
            v11 = 0;
            v12 = (_WORD **)(v3 + 38);
            while ( 1 )
            {
              v3 = *v12;
              if ( !*v12 )
                break;
              if ( !*v3 )
                break;
              if ( !v3[1] )
                break;
              if ( !v3[8] )
                break;
              if ( !v3[16] )
                break;
              if ( !v3[9] )
                break;
              if ( !v3[2] )
                break;
              v6 = *(_DWORD *)(a1 + 140);
              v3 = *(_WORD **)(v6 + v11);
              v7 = v11 + v6;
              if ( (int)v3 < 0 )
                break;
              v8 = (_DWORD *)(v7 + 4);
              v9 = 5;
              do
              {
                *(_DWORD *)((char *)v8 + v5 - v7) = *v8;
                if ( *v8 )
                  v14 = 1;
                ++v8;
                --v9;
              }
              while ( v9 );
              v5 += 24;
              ++v4;
              v11 += 256;
              v12 += 21;
              if ( v4 >= *(_DWORD *)(a1 + 32) )
              {
                LOBYTE(v3) = v14;
                if ( v14 )
                {
                  v13[3] = sub_1003F620;
                  *(_DWORD *)(a1 + 136) = 0;
                  return (char)v3;
                }
                v2 = v13;
                break;
              }
              v2 = v13;
            }
          }
        }
      }
    }
    v2[3] = sub_1003F470;
    *(_DWORD *)(a1 + 136) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 136) = 0;
  }
  return (char)v3;
}

// sub_1003EF50 @ 0x1003EF50
int __cdecl sub_1003EF50(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ebp
  int v3; // ebx
  unsigned int v4; // ecx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // ecx
  _DWORD *v8; // esi
  int v9; // edi
  int v10; // ebx
  int v11; // eax
  _DWORD *v12; // ebp
  bool v13; // cc
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // edx
  unsigned int v17; // ecx
  _DWORD *v18; // eax
  bool v20; // cf
  int v21; // ecx
  int v22; // edx
  int v23; // [esp+10h] [ebp-38h]
  unsigned int v24; // [esp+14h] [ebp-34h]
  int v25; // [esp+18h] [ebp-30h]
  _DWORD *v26; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v27; // [esp+20h] [ebp-28h]
  unsigned int v28; // [esp+24h] [ebp-24h]
  int v29; // [esp+28h] [ebp-20h]
  int v30; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int v32; // [esp+34h] [ebp-14h]
  int v33; // [esp+38h] [ebp-10h]
  unsigned int v34; // [esp+3Ch] [ebp-Ch]
  void (__cdecl *v35)(_DWORD *, _DWORD *, _DWORD, int, int); // [esp+40h] [ebp-8h]
  int v36; // [esp+44h] [ebp-4h]

  v2 = a1;
  v3 = a1[97];
  v4 = a1[77] - 1;
  v34 = a1[70] - 1;
  v5 = *(_DWORD *)(v3 + 24);
  v33 = v3;
  v28 = v4;
  v23 = v5;
  if ( v5 >= *(_DWORD *)(v3 + 28) )
  {
LABEL_25:
    v15 = v2[32];
    ++v2[34];
    v16 = v2[70];
    v17 = v15 + 1;
    v2[32] = v17;
    if ( v17 >= v16 )
    {
      (*(void (__cdecl **)(_DWORD *))(v2[99] + 12))(v2);
      return 4;
    }
    else
    {
      v18 = (_DWORD *)v2[97];
      if ( (int)v2[72] <= 1 )
      {
        v20 = v17 < v16 - 1;
        v21 = v2[73];
        if ( v20 )
          v22 = *(_DWORD *)(v21 + 12);
        else
          v22 = *(_DWORD *)(v21 + 72);
        v18[7] = v22;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
      else
      {
        v18[7] = 1;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 20);
      v24 = v6;
      if ( v6 <= v4 )
        break;
LABEL_24:
      v14 = *(_DWORD *)(v3 + 28);
      ++v5;
      *(_DWORD *)(v3 + 20) = 0;
      v23 = v5;
      if ( v5 >= v14 )
        goto LABEL_25;
    }
    while ( 1 )
    {
      sub_1003E510(*(void **)(v3 + 32), v2[79] << 7);
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, int))(v2[101] + 4))(v2, v3 + 32) )
        break;
      v7 = 0;
      v25 = 0;
      v32 = 0;
      if ( (int)v2[72] > 0 )
      {
        v27 = a2;
        v26 = v2 + 73;
        while ( 1 )
        {
          v8 = (_DWORD *)*v26;
          if ( *(_BYTE *)(*v26 + 48) )
          {
            v35 = *(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, int))(v2[102] + 4 * v8[1] + 4);
            if ( v6 >= v28 )
              v29 = v8[17];
            else
              v29 = v8[13];
            v9 = v24 * v8[16];
            v10 = *v27 + 4 * v23 * v8[9];
            v11 = 0;
            v36 = v9;
            for ( i = 0; v11 < v8[14]; i = v11 )
            {
              if ( (v2[32] < v34 || v11 + v23 < v8[18]) && v29 > 0 )
              {
                v12 = (_DWORD *)(v33 + 4 * v7 + 32);
                v30 = v29;
                do
                {
                  v35(a1, v8, *v12, v10, v9);
                  v9 += v8[9];
                  ++v12;
                  --v30;
                }
                while ( v30 );
                v11 = i;
                v9 = v36;
                v7 = v25;
                v2 = a1;
              }
              v7 += v8[13];
              v10 += 4 * v8[9];
              ++v11;
              v25 = v7;
            }
          }
          else
          {
            v7 += v8[15];
            v25 = v7;
          }
          v13 = ++v32 < v2[72];
          ++v26;
          ++v27;
          if ( !v13 )
            break;
          v6 = v24;
        }
        v3 = v33;
        v6 = v24;
      }
      v24 = ++v6;
      if ( v6 > v28 )
      {
        v4 = v28;
        v5 = v23;
        goto LABEL_24;
      }
    }
    *(_DWORD *)(v3 + 20) = v6;
    *(_DWORD *)(v3 + 24) = v23;
    return 0;
  }
}

// sub_1003F1F0 @ 0x1003F1F0
int sub_1003F1F0()
{
  return 0;
}

// sub_1003F200 @ 0x1003F200
int __cdecl sub_1003F200(_DWORD *a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int v3; // ebx
  int v4; // eax
  unsigned int v5; // ebp
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  _DWORD *v9; // ebp
  int v10; // eax
  int v11; // edx
  int *v12; // esi
  bool v13; // cc
  int v14; // ecx
  unsigned int v16; // edx
  unsigned int v17; // ecx
  _DWORD *v18; // eax
  bool v19; // cf
  int v20; // edx
  int v21; // ecx
  _DWORD *v22; // [esp+10h] [ebp-30h]
  int v23; // [esp+10h] [ebp-30h]
  _DWORD *v24; // [esp+14h] [ebp-2Ch]
  _DWORD *v25; // [esp+18h] [ebp-28h]
  _DWORD *v26; // [esp+18h] [ebp-28h]
  int v27; // [esp+1Ch] [ebp-24h]
  int v28; // [esp+20h] [ebp-20h]
  _DWORD *v29; // [esp+24h] [ebp-1Ch]
  int v30; // [esp+28h] [ebp-18h]
  int v31; // [esp+2Ch] [ebp-14h]
  _BYTE v32[16]; // [esp+30h] [ebp-10h] BYREF

  v1 = a1;
  v2 = (_DWORD *)a1[97];
  v3 = 0;
  v29 = v2;
  if ( (int)a1[72] > 0 )
  {
    v25 = v32;
    v22 = a1 + 73;
    do
    {
      *v25 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(a1[1] + 32))(
               a1,
               v2[*(_DWORD *)(*v22 + 4) + 18],
               *(_DWORD *)(*v22 + 12) * a1[32],
               *(_DWORD *)(*v22 + 12),
               1);
      ++v3;
      ++v22;
      ++v25;
    }
    while ( v3 < a1[72] );
  }
  v4 = v2[6];
  v23 = v4;
  if ( v4 >= v2[7] )
  {
LABEL_24:
    v16 = v1[70];
    v17 = v1[32] + 1;
    v1[32] = v17;
    if ( v17 >= v16 )
    {
      (*(void (__cdecl **)(_DWORD *))(v1[99] + 12))(v1);
      return 4;
    }
    else
    {
      v18 = (_DWORD *)v1[97];
      if ( (int)v1[72] <= 1 )
      {
        v19 = v17 < v16 - 1;
        v20 = v1[73];
        if ( v19 )
          v21 = *(_DWORD *)(v20 + 12);
        else
          v21 = *(_DWORD *)(v20 + 72);
        v18[5] = 0;
        v18[6] = 0;
        v18[7] = v21;
        return 3;
      }
      else
      {
        v18[7] = 1;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v5 = v2[5];
      v30 = v5;
      if ( v5 < v1[77] )
        break;
LABEL_21:
      v14 = v2[7];
      ++v4;
      v2[5] = 0;
      v23 = v4;
      if ( v4 >= v14 )
        goto LABEL_24;
    }
    while ( 1 )
    {
      v6 = 0;
      v28 = 0;
      if ( (int)v1[72] > 0 )
      {
        v26 = v32;
        v24 = v1 + 73;
        do
        {
          v7 = *v24;
          v8 = *(_DWORD *)(*v24 + 52);
          v27 = 0;
          if ( *(int *)(*v24 + 56) > 0 )
          {
            v31 = (v5 * *(_DWORD *)(*v24 + 52)) << 7;
            v9 = (_DWORD *)(*v26 + 4 * v23);
            do
            {
              v10 = v31 + *v9;
              v11 = 0;
              if ( v8 > 0 )
              {
                v12 = &v29[v6 + 8];
                do
                {
                  *v12 = v10;
                  v8 = *(_DWORD *)(v7 + 52);
                  ++v6;
                  ++v12;
                  v10 += 128;
                  ++v11;
                }
                while ( v11 < v8 );
                v1 = a1;
              }
              ++v9;
              ++v27;
            }
            while ( v27 < *(_DWORD *)(v7 + 56) );
            v5 = v30;
          }
          v13 = ++v28 < v1[72];
          ++v24;
          ++v26;
        }
        while ( v13 );
        v2 = v29;
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(v1[101] + 4))(v1, v2 + 8) )
        break;
      v30 = ++v5;
      if ( v5 >= v1[77] )
      {
        v4 = v23;
        goto LABEL_21;
      }
    }
    v2[5] = v5;
    v2[6] = v23;
    return 0;
  }
}

// sub_1003F470 @ 0x1003F470
int __cdecl sub_1003F470(int a1, _DWORD *a2)
{
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // ebp
  int v9; // eax
  int *v10; // ebp
  int v11; // edx
  int v12; // ebp
  int v13; // edi
  bool v14; // zf
  bool v15; // cc
  unsigned int v16; // edx
  unsigned int v17; // eax
  int v19; // [esp+8h] [ebp-20h]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  _DWORD *v22; // [esp+14h] [ebp-14h]
  _DWORD *v23; // [esp+18h] [ebp-10h]
  unsigned int v24; // [esp+1Ch] [ebp-Ch]
  int v25; // [esp+20h] [ebp-8h]
  void (__cdecl *v26)(int, int, int, int, int); // [esp+24h] [ebp-4h]
  int v27; // [esp+2Ch] [ebp+4h]
  unsigned int i; // [esp+30h] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 388);
  v24 = *(_DWORD *)(a1 + 280) - 1;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 124);
    v5 = *(_DWORD *)(a1 + 132);
    if ( v4 >= v5 && (v4 != v5 || *(_DWORD *)(a1 + 128) > *(_DWORD *)(a1 + 136)) )
      break;
    if ( !(**(int (__cdecl ***)(int))(a1 + 396))(a1) )
      return 0;
  }
  v6 = *(_DWORD *)(a1 + 196);
  v21 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = a2;
    v8 = (_DWORD *)(v3 + 72);
    v23 = a2;
    v22 = v8;
    v25 = 4 - (_DWORD)a2;
    do
    {
      if ( *(_BYTE *)(v6 + 48) )
      {
        v9 = (*(int (__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 4) + 32))(
               a1,
               *v8,
               *(_DWORD *)(v6 + 12) * *(_DWORD *)(a1 + 136),
               *(_DWORD *)(v6 + 12),
               0);
        v10 = (int *)v9;
        if ( *(_DWORD *)(a1 + 136) >= v24 )
        {
          v11 = *(_DWORD *)(v6 + 32) % *(_DWORD *)(v6 + 12);
          if ( !v11 )
            v11 = *(_DWORD *)(v6 + 12);
        }
        else
        {
          v11 = *(_DWORD *)(v6 + 12);
        }
        v26 = *(void (__cdecl **)(int, int, int, int, int))((char *)v7 + v25 + *(_DWORD *)(a1 + 408));
        v27 = *v7;
        if ( v11 > 0 )
        {
          v19 = v9;
          v20 = v11;
          do
          {
            v12 = *v10;
            v13 = 0;
            for ( i = 0; i < *(_DWORD *)(v6 + 28); ++i )
            {
              v26(a1, v6, v12, v27, v13);
              v13 += *(_DWORD *)(v6 + 36);
              v12 += 128;
            }
            v10 = (int *)(v19 + 4);
            v14 = v20 == 1;
            v27 += 4 * *(_DWORD *)(v6 + 36);
            v19 += 4;
            --v20;
          }
          while ( !v14 );
          v7 = v23;
        }
      }
      v8 = v22 + 1;
      ++v7;
      v6 += 84;
      v15 = ++v21 < *(_DWORD *)(a1 + 32);
      ++v22;
      v23 = v7;
    }
    while ( v15 );
  }
  v16 = *(_DWORD *)(a1 + 280);
  v17 = *(_DWORD *)(a1 + 136) + 1;
  *(_DWORD *)(a1 + 136) = v17;
  return 4 - (v17 < v16);
}

// sub_1003F620 @ 0x1003F620
int __cdecl sub_1003F620(_DWORD *a1, int *a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  unsigned int v6; // ebp
  int v7; // edx
  int v8; // ebx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // eax
  int v13; // esi
  unsigned __int16 *v14; // eax
  int v15; // eax
  __int16 *v16; // edx
  __int16 *v17; // ecx
  __int16 *v18; // eax
  int v19; // esi
  int v20; // edi
  int v21; // ebp
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // eax
  bool v42; // cc
  unsigned int v43; // edx
  unsigned int v44; // edi
  char v45; // [esp+12h] [ebp-102h]
  char v46; // [esp+13h] [ebp-101h]
  int v47; // [esp+14h] [ebp-100h]
  _DWORD *v48; // [esp+18h] [ebp-FCh]
  int v49; // [esp+1Ch] [ebp-F8h]
  _DWORD *v50; // [esp+20h] [ebp-F4h]
  int v51; // [esp+24h] [ebp-F0h]
  int v52; // [esp+28h] [ebp-ECh]
  __int16 *v53; // [esp+2Ch] [ebp-E8h]
  int v54; // [esp+30h] [ebp-E4h]
  int v55; // [esp+34h] [ebp-E0h]
  int v56; // [esp+38h] [ebp-DCh]
  int v57; // [esp+3Ch] [ebp-D8h]
  int v58; // [esp+40h] [ebp-D4h]
  unsigned int v59; // [esp+44h] [ebp-D0h]
  int v60; // [esp+48h] [ebp-CCh]
  int v61; // [esp+4Ch] [ebp-C8h]
  __int16 *v62; // [esp+50h] [ebp-C4h]
  int v63; // [esp+54h] [ebp-C0h]
  __int16 *v64; // [esp+58h] [ebp-BCh]
  int v65; // [esp+5Ch] [ebp-B8h]
  int v66; // [esp+60h] [ebp-B4h]
  int v68; // [esp+68h] [ebp-ACh]
  int v69; // [esp+6Ch] [ebp-A8h]
  int v70; // [esp+70h] [ebp-A4h]
  int v71; // [esp+74h] [ebp-A0h]
  unsigned int v72; // [esp+78h] [ebp-9Ch]
  int v73; // [esp+7Ch] [ebp-98h]
  int v74; // [esp+80h] [ebp-94h]
  int v75; // [esp+84h] [ebp-90h]
  void (__cdecl *v76)(_DWORD *, int, _BYTE *, int, int); // [esp+88h] [ebp-8Ch]
  unsigned int i; // [esp+8Ch] [ebp-88h]
  int v78; // [esp+90h] [ebp-84h]
  _BYTE v79[2]; // [esp+94h] [ebp-80h] BYREF
  __int16 v80; // [esp+96h] [ebp-7Eh]
  __int16 v81; // [esp+98h] [ebp-7Ch]
  __int16 v82; // [esp+A4h] [ebp-70h]
  __int16 v83; // [esp+A6h] [ebp-6Eh]
  __int16 v84; // [esp+B4h] [ebp-60h]

  v2 = a1;
  v3 = a1[31];
  v4 = a1[33];
  v5 = a1[97];
  v6 = a1[70] - 1;
  v75 = v5;
  for ( i = v6; v3 <= v4; v4 = a1[33] )
  {
    v7 = a1[99];
    if ( *(_BYTE *)(v7 + 17)
      || v3 == v4 && __PAIR64__(a1[32], a1[90]) >= __PAIR64__(a1[34], 1) && a1[32] != a1[34] + (a1[90] == 0) )
    {
      break;
    }
    if ( !(*(int (__cdecl **)(_DWORD *))v7)(a1) )
      return 0;
    v3 = a1[31];
  }
  v8 = a1[49];
  v69 = 0;
  v55 = v8;
  if ( (int)a1[8] > 0 )
  {
    v65 = 0;
    v48 = (_DWORD *)(v5 + 72);
    v78 = -68 - v5;
    do
    {
      if ( *(_BYTE *)(v8 + 48) )
      {
        v9 = v2[34];
        v10 = *(_DWORD *)(v8 + 12);
        if ( v9 >= v6 )
        {
          v11 = *(_DWORD *)(v8 + 32) % v10;
          v47 = v11;
          if ( !v11 )
          {
            v47 = *(_DWORD *)(v8 + 12);
            v11 = v47;
          }
          v45 = 1;
        }
        else
        {
          v47 = *(_DWORD *)(v8 + 12);
          v11 = 2 * v10;
          v45 = 0;
        }
        if ( v9 )
        {
          v13 = (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                  a1,
                  *v48,
                  v10 * (v9 - 1),
                  v10 + v11,
                  0)
              + 4 * *(_DWORD *)(v8 + 12);
          v57 = v13;
          v46 = 0;
        }
        else
        {
          v57 = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v48, 0, v11, 0);
          v46 = 1;
          v13 = v57;
        }
        v50 = (_DWORD *)(v65 + *(_DWORD *)(v75 + 112));
        v14 = *(unsigned __int16 **)(v8 + 76);
        v49 = *v14;
        v68 = v14[1];
        v70 = v14[8];
        v74 = v14[16];
        v73 = v14[9];
        v71 = v14[2];
        v76 = *(void (__cdecl **)(_DWORD *, int, _BYTE *, int, int))((char *)v48 + v78 + a1[102]);
        v61 = *a2;
        v15 = 0;
        v63 = 0;
        if ( v47 > 0 )
        {
          while ( 1 )
          {
            v16 = *(__int16 **)(v13 + 4 * v15);
            v53 = v16;
            if ( !v46 || (v17 = *(__int16 **)(v13 + 4 * v15), v15) )
              v17 = *(__int16 **)(v13 + 4 * v15 - 4);
            v18 = v45 && v15 == v47 - 1 ? *(__int16 **)(v13 + 4 * v15) : *(__int16 **)(v13 + 4 * v15 + 4);
            v19 = *v16;
            v20 = *v17;
            v21 = *v18;
            v58 = v20;
            v54 = v20;
            v51 = v19;
            v66 = v19;
            v60 = v21;
            v52 = v21;
            v56 = 0;
            v72 = *(_DWORD *)(v8 + 28) - 1;
            v59 = 0;
            v62 = v18 + 64;
            v64 = v17 + 64;
            do
            {
              sub_1003E4E0(v53, v79, 1);
              if ( v59 < v72 )
              {
                v19 = v53[64];
                v58 = *v64;
                v60 = *v62;
              }
              v22 = v50[1];
              if ( v22 && !v80 )
              {
                v23 = 36 * v49 * (v66 - v19);
                if ( v23 < 0 )
                {
                  v25 = ((v68 << 7) - v23) / (v68 << 8);
                  if ( v22 > 0 && v25 >= 1 << v22 )
                    v25 = (1 << v22) - 1;
                  v24 = -v25;
                }
                else
                {
                  v24 = (v23 + (v68 << 7)) / (v68 << 8);
                  if ( v22 > 0 && v24 >= 1 << v22 )
                    v24 = (1 << v22) - 1;
                }
                v8 = v55;
                v80 = v24;
              }
              v26 = v50[2];
              if ( v26 && !v82 )
              {
                v27 = 36 * v49 * (v54 - v52);
                if ( v27 < 0 )
                {
                  v29 = ((v70 << 7) - v27) / (v70 << 8);
                  if ( v26 > 0 && v29 >= 1 << v26 )
                    v29 = (1 << v26) - 1;
                  v28 = -v29;
                }
                else
                {
                  v28 = (v27 + (v70 << 7)) / (v70 << 8);
                  if ( v26 > 0 && v28 >= 1 << v26 )
                    v28 = (1 << v26) - 1;
                }
                v8 = v55;
                v82 = v28;
              }
              v30 = v50[3];
              if ( v30 && !v84 )
              {
                v31 = 9 * v49 * (v54 + v52 - 2 * v51);
                if ( v31 < 0 )
                {
                  v33 = ((v74 << 7) - v31) / (v74 << 8);
                  if ( v30 > 0 && v33 >= 1 << v30 )
                    v33 = (1 << v30) - 1;
                  v32 = -v33;
                }
                else
                {
                  v32 = (v31 + (v74 << 7)) / (v74 << 8);
                  if ( v30 > 0 && v32 >= 1 << v30 )
                    v32 = (1 << v30) - 1;
                }
                v8 = v55;
                v84 = v32;
              }
              v34 = v50[4];
              if ( v34 && !v83 )
              {
                v35 = 5 * v49 * (v20 + v60 - v21 - v58);
                if ( v35 < 0 )
                {
                  v37 = ((v73 << 7) - v35) / (v73 << 8);
                  if ( v34 > 0 && v37 >= 1 << v34 )
                    v37 = (1 << v34) - 1;
                  v36 = -v37;
                }
                else
                {
                  v36 = (v35 + (v73 << 7)) / (v73 << 8);
                  if ( v34 > 0 && v36 >= 1 << v34 )
                    v36 = (1 << v34) - 1;
                }
                v83 = v36;
              }
              v38 = v50[5];
              if ( v38 && !v81 )
              {
                v39 = 9 * v49 * (v66 + v19 - 2 * v51);
                if ( v39 < 0 )
                {
                  v41 = ((v71 << 7) - v39) / (v71 << 8);
                  if ( v38 > 0 && v41 >= 1 << v38 )
                    v41 = (1 << v38) - 1;
                  v40 = -v41;
                }
                else
                {
                  v40 = (v39 + (v71 << 7)) / (v71 << 8);
                  if ( v38 > 0 && v40 >= 1 << v38 )
                    v40 = (1 << v38) - 1;
                }
                v81 = v40;
              }
              v76(a1, v8, v79, v61, v56);
              v20 = v54;
              v21 = v52;
              v54 = v58;
              v52 = v60;
              v53 += 64;
              v66 = v51;
              v62 += 64;
              v56 += *(_DWORD *)(v8 + 36);
              v42 = v59 + 1 <= v72;
              v51 = v19;
              v64 += 64;
              ++v59;
            }
            while ( v42 );
            v61 += 4 * *(_DWORD *)(v8 + 36);
            if ( ++v63 >= v47 )
              break;
            v15 = v63;
            v13 = v57;
          }
        }
        v6 = i;
        v2 = a1;
      }
      v65 += 24;
      v8 += 84;
      v42 = ++v69 < v2[8];
      ++v48;
      ++a2;
      v55 = v8;
    }
    while ( v42 );
  }
  v43 = v2[70];
  v44 = v2[34] + 1;
  v2[34] = v44;
  return 4 - (v44 < v43);
}

// sub_1003FC90 @ 0x1003FC90
int __cdecl sub_1003FC90(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  int v4; // ebx
  int v5; // eax
  int i; // edx
  unsigned int v7; // ecx
  unsigned int v8; // esi
  _BYTE *v9; // edi
  char v10; // bp
  unsigned int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int j; // esi
  _DWORD *v16; // edx
  int v17; // ebp
  int v18; // esi
  int v19; // ecx
  _DWORD *v20; // eax
  int v21; // edx
  int result; // eax
  int v23; // ecx
  int v24; // ebp
  _BYTE *v25; // edi
  int v26; // ebx
  int v27; // eax
  _BYTE *v28; // edx
  int *v29; // eax
  int v30; // esi
  int v31; // [esp+10h] [ebp-51Ch]
  int v32; // [esp+10h] [ebp-51Ch]
  _DWORD *v33; // [esp+14h] [ebp-518h]
  int v34; // [esp+18h] [ebp-514h]
  int v35; // [esp+1Ch] [ebp-510h]
  _DWORD *v36; // [esp+20h] [ebp-50Ch]
  _BYTE v37[1288]; // [esp+24h] [ebp-508h] BYREF

  if ( !*a3 )
    *a3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1492);
  v3 = (_DWORD *)*a3;
  v4 = a2;
  v5 = 0;
  v36 = v3;
  v3[52] = a2;
  v31 = 0;
  for ( i = 1; i <= 16; ++i )
  {
    v7 = *(unsigned __int8 *)(i + v4);
    v8 = v7;
    if ( *(_BYTE *)(i + v4) )
    {
      v9 = &v37[v5];
      LOBYTE(v4) = i;
      BYTE1(v4) = i;
      v10 = v7;
      v11 = v7 >> 2;
      v12 = v4 << 16;
      LOWORD(v12) = v4;
      v4 = a2;
      memset32(v9, v12, v11);
      memset(&v9[4 * v11], v12, v10 & 3);
      v3 = v36;
      v5 = v8 + v31;
      v31 += v8;
    }
  }
  v37[v5] = 0;
  v13 = 0;
  v14 = 0;
  for ( j = v37[0]; v37[v14]; ++j )
  {
    if ( (char)v37[v14] == j )
    {
      v16 = &v37[4 * v14 + 260];
      do
      {
        v17 = (char)v37[++v14];
        *v16++ = v13++;
      }
      while ( v17 == j );
    }
    v13 *= 2;
  }
  v18 = 0;
  v19 = 1;
  v20 = v3 + 18;
  do
  {
    if ( *(_BYTE *)(v19 + v4) )
    {
      v21 = *(_DWORD *)&v37[4 * v18 + 260];
      v20[18] = v18;
      *(v20 - 17) = v21;
      v18 += *(unsigned __int8 *)(v19 + v4);
      *v20 = *(_DWORD *)&v37[4 * v18 + 256];
    }
    else
    {
      *v20 = -1;
    }
    ++v19;
    ++v20;
  }
  while ( v19 <= 16 );
  result = 0;
  v3[34] = 0xFFFFF;
  memset(v3 + 53, 0, 0x400u);
  v23 = 7;
  v32 = 0;
  v24 = 1;
  v35 = 7;
  do
  {
    v34 = 1;
    if ( *(_BYTE *)(v4 + v24) )
    {
      v25 = (_BYTE *)(result + a2 + 17);
      v26 = 1 << v23;
      v33 = &v37[4 * result + 260];
      do
      {
        v27 = *v33 << v23;
        if ( v26 > 0 )
        {
          v28 = (char *)v36 + v27 + 1236;
          v29 = &v36[v27 + 53];
          v30 = v26;
          do
          {
            *v29++ = v24;
            *v28++ = *v25;
            --v30;
          }
          while ( v30 );
          v23 = v35;
        }
        ++v32;
        ++v33;
        ++v25;
        ++v34;
      }
      while ( v34 <= *(unsigned __int8 *)(a2 + v24) );
      v4 = a2;
      result = v32;
    }
    ++v24;
    v35 = --v23;
  }
  while ( v23 >= 0 );
  return result;
}

// sub_1003FE80 @ 0x1003FE80
char __cdecl sub_1003FE80(unsigned __int8 **a1, int a2, int a3, int a4)
{
  int v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned __int8 **v7; // eax
  int v8; // eax
  unsigned __int8 **v9; // eax
  unsigned __int8 *v10; // eax

  v4 = a3;
  v5 = a1[1];
  v6 = *a1;
  if ( a3 >= 25 )
  {
LABEL_19:
    *a1 = v6;
    a1[1] = v5;
    a1[4] = (unsigned __int8 *)v4;
    a1[3] = (unsigned __int8 *)a2;
    return 1;
  }
  while ( 1 )
  {
    if ( a1[2] )
      goto LABEL_14;
    if ( !v5 )
      break;
LABEL_6:
    v8 = *v6;
    --v5;
    ++v6;
    if ( v8 == 255 )
    {
      do
      {
        if ( !v5 )
        {
          if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[5] + 5) + 12))(a1[5]) )
            return 0;
          v9 = (unsigned __int8 **)*((_DWORD *)a1[5] + 5);
          v6 = *v9;
          v5 = v9[1];
        }
        v10 = (unsigned __int8 *)*v6;
        --v5;
        ++v6;
      }
      while ( v10 == (unsigned __int8 *)255 );
      if ( v10 )
      {
        a1[2] = v10;
LABEL_14:
        if ( v4 >= a4 )
          goto LABEL_19;
        if ( !*a1[6] )
        {
          *(_DWORD *)(*(_DWORD *)a1[5] + 20) = 113;
          (*(void (__cdecl **)(unsigned __int8 *, int))(*(_DWORD *)a1[5] + 4))(a1[5], -1);
          *a1[6] = 1;
        }
        v8 = 0;
        goto LABEL_18;
      }
      v8 = 255;
    }
LABEL_18:
    v4 += 8;
    a2 = v8 | (a2 << 8);
    if ( v4 >= 25 )
      goto LABEL_19;
  }
  if ( (*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[5] + 5) + 12))(a1[5]) )
  {
    v7 = (unsigned __int8 **)*((_DWORD *)a1[5] + 5);
    v6 = *v7;
    v5 = v7[1];
    goto LABEL_6;
  }
  return 0;
}

// sub_1003FF80 @ 0x1003FF80
int __cdecl sub_1003FF80(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int *v10; // edi
  int v11; // esi
  int v12; // esi

  v5 = a3;
  if ( a3 >= a5 )
  {
    v7 = a2;
  }
  else
  {
    if ( !sub_1003FE80((unsigned __int8 **)a1, a2, a3, a5) )
      return -1;
    v7 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 16);
  }
  v8 = v5 - a5;
  v9 = a4;
  v10 = (int *)(a4 + 4 * a5 + 68);
  v11 = ((1 << a5) - 1) & (v7 >> v8);
  if ( v11 > *v10 )
  {
    do
    {
      v12 = 2 * v11;
      if ( v8 < 1 )
      {
        if ( !sub_1003FE80((unsigned __int8 **)a1, v7, v8, 1) )
          return -1;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(_DWORD *)(a1 + 16);
      }
      --v8;
      ++v10;
      v11 = (v7 >> v8) & 1 | v12;
      ++a5;
    }
    while ( v11 > *v10 );
    v9 = a4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 12) = v7;
  if ( a5 <= 16 )
    return *(unsigned __int8 *)(*(_DWORD *)(v9 + 208)
                              + *(_DWORD *)(v9 + 4 * a5 + 140)
                              - *(_DWORD *)(v9 + 4 * a5)
                              + v11
                              + 17);
  *(_DWORD *)(**(_DWORD **)(a1 + 20) + 20) = 114;
  (*(void (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 20) + 4))(*(_DWORD *)(a1 + 20), -1);
  return 0;
}

// sub_10040070 @ 0x10040070
_DWORD *__cdecl sub_10040070(int a1)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax
  int v3; // ecx

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 72);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_100400B0;
  v1[1] = sub_10040200;
  result = v1 + 10;
  v3 = 4;
  do
  {
    result[4] = 0;
    *result++ = 0;
    --v3;
  }
  while ( v3 );
  return result;
}

// sub_100400B0 @ 0x100400B0
int __cdecl sub_100400B0(_DWORD *a1)
{
  int v2; // ebx
  unsigned int v3; // edi
  unsigned int v4; // ebp
  int result; // eax
  int v6; // [esp+Ch] [ebp-8h]
  _DWORD *v7; // [esp+10h] [ebp-4h]
  _DWORD *v8; // [esp+18h] [ebp+4h]

  v2 = a1[101];
  if ( a1[90] || a1[91] != 63 || a1[92] || a1[93] )
  {
    *(_DWORD *)(*a1 + 20) = 118;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v6 = 0;
  if ( (int)a1[72] > 0 )
  {
    v7 = (_DWORD *)(v2 + 20);
    v8 = a1 + 73;
    do
    {
      v3 = *(_DWORD *)(*v8 + 20);
      v4 = *(_DWORD *)(*v8 + 24);
      if ( v3 >= 4 || !a1[v3 + 40] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v3;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      if ( v4 >= 4 || !a1[v4 + 44] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v4;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_1003FC90((int)a1, a1[v3 + 40], (_DWORD *)(v2 + 4 * v3 + 40));
      sub_1003FC90((int)a1, a1[v4 + 44], (_DWORD *)(v2 + 4 * v4 + 56));
      *v7++ = 0;
      ++v6;
      ++v8;
    }
    while ( v6 < a1[72] );
  }
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_BYTE *)(v2 + 16) = 0;
  result = a1[63];
  *(_DWORD *)(v2 + 36) = result;
  return result;
}

// sub_10040200 @ 0x10040200
char __cdecl sub_10040200(_DWORD *a1, _WORD **a2)
{
  _DWORD *v2; // esi
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // edx
  bool v12; // cc
  int v13; // ebp
  int v14; // esi
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // esi
  int v22; // ebp
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  int v26; // esi
  int v27; // ecx
  int v28; // esi
  int v29; // ebp
  int v30; // edx
  int v31; // ebp
  int v32; // ecx
  int v33; // edx
  int v34; // ecx
  int v35; // esi
  int v36; // ecx
  int v37; // esi
  int v38; // ebp
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int *v46; // [esp+14h] [ebp-40h]
  _WORD *v47; // [esp+18h] [ebp-3Ch]
  int v48; // [esp+1Ch] [ebp-38h]
  int v49; // [esp+20h] [ebp-34h]
  int v50; // [esp+24h] [ebp-30h]
  int v51; // [esp+28h] [ebp-2Ch]
  int v52; // [esp+2Ch] [ebp-28h]
  int v53; // [esp+30h] [ebp-24h]
  int v54; // [esp+34h] [ebp-20h]
  unsigned __int8 *v55; // [esp+38h] [ebp-1Ch] BYREF
  int v56; // [esp+3Ch] [ebp-18h]
  int v57; // [esp+40h] [ebp-14h]
  int v58; // [esp+44h] [ebp-10h]
  int v59; // [esp+48h] [ebp-Ch]
  _DWORD *v60; // [esp+4Ch] [ebp-8h]
  int v61; // [esp+50h] [ebp-4h]
  int v62; // [esp+5Ch] [ebp+8h]

  v2 = a1;
  v3 = a1[101];
  v49 = v3;
  if ( a1[63] && !*(_DWORD *)(v3 + 36) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 20);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 36) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = a1[5];
  v7 = a1[94];
  v60 = a1;
  v55 = *(unsigned __int8 **)v6;
  v8 = *(_DWORD *)(v6 + 4);
  v57 = v7;
  v56 = v8;
  v9 = *(_DWORD *)(v3 + 8);
  v10 = *(_DWORD *)(v3 + 12);
  v61 = v3 + 16;
  v51 = *(_DWORD *)(v3 + 20);
  v52 = *(_DWORD *)(v3 + 24);
  v11 = *(_DWORD *)(v3 + 28);
  v54 = *(_DWORD *)(v3 + 32);
  v12 = a1[79] <= 0;
  v53 = v11;
  v48 = 0;
  if ( v12 )
    goto LABEL_69;
  v46 = a1 + 80;
LABEL_10:
  v47 = *a2;
  v13 = v2[*v46 + 73];
  v50 = *v46;
  v14 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(v13 + 20) + 40);
  v15 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(v13 + 24) + 56);
  v62 = v15;
  if ( v10 < 8 )
  {
    if ( !sub_1003FE80(&v55, v9, v10, 0) )
      return 0;
    v10 = v59;
    v9 = v58;
    if ( v59 < 8 )
    {
      v16 = 1;
LABEL_17:
      v19 = sub_1003FF80((int)&v55, v9, v10, v14, v16);
      if ( v19 < 0 )
        return 0;
      v9 = v58;
      v10 = v59;
      goto LABEL_19;
    }
  }
  v17 = (unsigned __int8)(v9 >> (v10 - 8));
  v18 = *(_DWORD *)(v14 + 4 * v17 + 212);
  if ( !v18 )
  {
    v16 = 9;
    goto LABEL_17;
  }
  v10 -= v18;
  v19 = *(unsigned __int8 *)(v17 + v14 + 1236);
LABEL_19:
  if ( !v19 )
  {
LABEL_26:
    if ( *(_BYTE *)(v13 + 48) )
    {
      v21 = *(&v51 + v50) + v19;
      *(&v51 + v50) = v21;
      *v47 = v21;
      if ( *(int *)(v13 + 36) > 1 )
      {
        v22 = 1;
        while ( 1 )
        {
          if ( v10 < 8 )
          {
            if ( !sub_1003FE80(&v55, v9, v10, 0) )
              return 0;
            v10 = v59;
            v9 = v58;
            if ( v59 < 8 )
              break;
          }
          v24 = (unsigned __int8)(v9 >> (v10 - 8));
          v25 = *(_DWORD *)(v15 + 4 * v24 + 212);
          if ( !v25 )
          {
            v23 = 9;
            goto LABEL_36;
          }
          v10 -= v25;
          v26 = *(unsigned __int8 *)(v24 + v15 + 1236);
LABEL_38:
          v27 = v26 >> 4;
          v28 = v26 & 0xF;
          if ( v28 )
          {
            v29 = v27 + v22;
            if ( v10 < v28 )
            {
              if ( !sub_1003FE80(&v55, v9, v10, v28) )
                return 0;
              v9 = v58;
              v10 = v59;
            }
            v10 -= v28;
            v30 = (v9 >> v10) & ((1 << v28) - 1);
            if ( v30 >= dword_10050690[v28] )
              v28 = (v9 >> v10) & ((1 << v28) - 1);
            else
              LOWORD(v28) = v30 + dword_100506D0[v28];
            v15 = v62;
            v47[dword_10050550[v29]] = v28;
          }
          else
          {
            if ( v27 != 15 )
              goto LABEL_68;
            v29 = v22 + 15;
          }
          v22 = v29 + 1;
          if ( v22 >= 64 )
            goto LABEL_68;
        }
        v23 = 1;
LABEL_36:
        v26 = sub_1003FF80((int)&v55, v9, v10, v15, v23);
        if ( v26 < 0 )
          return 0;
        v9 = v58;
        v10 = v59;
        goto LABEL_38;
      }
    }
    v31 = 1;
    while ( 1 )
    {
      if ( v10 < 8 )
      {
        if ( !sub_1003FE80(&v55, v9, v10, 0) )
          return 0;
        v10 = v59;
        v9 = v58;
        if ( v59 < 8 )
          break;
      }
      v33 = (unsigned __int8)(v9 >> (v10 - 8));
      v34 = *(_DWORD *)(v15 + 4 * v33 + 212);
      if ( !v34 )
      {
        v32 = 9;
        goto LABEL_58;
      }
      v10 -= v34;
      v35 = *(unsigned __int8 *)(v33 + v15 + 1236);
LABEL_60:
      v36 = v35 >> 4;
      v37 = v35 & 0xF;
      if ( v37 )
      {
        v38 = v36 + v31;
        if ( v10 < v37 )
        {
          if ( !sub_1003FE80(&v55, v9, v10, v37) )
            return 0;
          v9 = v58;
          v10 = v59;
        }
        v10 -= v37;
      }
      else
      {
        if ( v36 != 15 )
          goto LABEL_68;
        v38 = v31 + 15;
      }
      v31 = v38 + 1;
      if ( v31 >= 64 )
      {
LABEL_68:
        ++v46;
        v3 = v49;
        v12 = ++v48 < a1[79];
        ++a2;
        v2 = a1;
        if ( !v12 )
        {
LABEL_69:
          *(_DWORD *)v2[5] = v55;
          *(_DWORD *)(v2[5] + 4) = v56;
          v39 = v51;
          v2[94] = v57;
          v40 = v53;
          *(_DWORD *)(v3 + 12) = v10;
          v41 = v52;
          *(_DWORD *)(v3 + 20) = v39;
          v42 = v54;
          *(_DWORD *)(v3 + 24) = v41;
          v43 = *(_DWORD *)(v3 + 36);
          *(_DWORD *)(v3 + 8) = v9;
          *(_DWORD *)(v3 + 28) = v40;
          *(_DWORD *)(v3 + 36) = v43 - 1;
          *(_DWORD *)(v3 + 32) = v42;
          return 1;
        }
        goto LABEL_10;
      }
    }
    v32 = 1;
LABEL_58:
    v35 = sub_1003FF80((int)&v55, v9, v10, v15, v32);
    if ( v35 < 0 )
      return 0;
    v9 = v58;
    v10 = v59;
    goto LABEL_60;
  }
  if ( v10 >= v19 )
  {
LABEL_23:
    v10 -= v19;
    v20 = (v9 >> v10) & ((1 << v19) - 1);
    if ( v20 >= dword_10050690[v19] )
      v19 = (v9 >> v10) & ((1 << v19) - 1);
    else
      v19 = v20 + dword_100506D0[v19];
    goto LABEL_26;
  }
  if ( sub_1003FE80(&v55, v9, v10, v19) )
  {
    v9 = v58;
    v10 = v59;
    goto LABEL_23;
  }
  return 0;
}

// sub_100406A0 @ 0x100406A0
int __cdecl sub_100406A0(int a1)
{
  _DWORD *v1; // eax
  int v2; // eax
  char *v3; // edx
  int result; // eax
  int i; // ebx
  void *v6; // edi

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_10040710;
  v1 += 11;
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v2 = (**(int (__cdecl ***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD *)(a1 + 32) << 8);
  *(_DWORD *)(a1 + 140) = v2;
  v3 = (char *)v2;
  result = *(_DWORD *)(a1 + 32);
  for ( i = 0; i < result; ++i )
  {
    v6 = v3;
    v3 += 256;
    memset(v6, 0xFFu, 0x100u);
    result = *(_DWORD *)(a1 + 32);
  }
  return result;
}

// sub_10040710 @ 0x10040710
int __cdecl sub_10040710(int *a1)
{
  int v2; // eax
  bool v3; // bl
  int v4; // edi
  char v5; // cl
  int v6; // edx
  int v7; // eax
  int v8; // ebx
  int *v9; // ebp
  int v10; // edi
  int *v11; // ebp
  bool v12; // cc
  int v13; // eax
  unsigned int v14; // edi
  unsigned int v15; // edi
  int result; // eax
  int v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+14h] [ebp-Ch]
  _DWORD *v20; // [esp+18h] [ebp-8h]
  int *v21; // [esp+18h] [ebp-8h]
  _DWORD *v22; // [esp+1Ch] [ebp-4h]
  bool v23; // [esp+24h] [ebp+4h]

  v2 = a1[90];
  v3 = v2 == 0;
  v4 = a1[101];
  v5 = 0;
  v17 = v4;
  v23 = v2 == 0;
  if ( v2 )
  {
    v6 = a1[91];
    if ( v2 > v6 || v6 >= 64 )
      v5 = 1;
    if ( a1[72] != 1 )
      goto LABEL_8;
  }
  else if ( a1[91] )
  {
LABEL_8:
    v5 = 1;
  }
  v7 = a1[92];
  if ( v7 && a1[93] != v7 - 1 )
    v5 = 1;
  if ( a1[93] > 13 || v5 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a1[90];
    *(_DWORD *)(*a1 + 28) = a1[91];
    *(_DWORD *)(*a1 + 32) = a1[92];
    *(_DWORD *)(*a1 + 36) = a1[93];
    (*(void (__cdecl **)(int *))*a1)(a1);
  }
  v18 = 0;
  if ( a1[72] > 0 )
  {
    v20 = a1 + 73;
    do
    {
      v8 = *(_DWORD *)(*v20 + 4);
      v9 = (int *)(a1[35] + (v8 << 8));
      if ( !v23 && *v9 < 0 )
      {
        *(_DWORD *)(*a1 + 20) = 111;
        *(_DWORD *)(*a1 + 24) = v8;
        *(_DWORD *)(*a1 + 28) = 0;
        (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
      }
      v10 = a1[90];
      if ( v10 <= a1[91] )
      {
        v11 = &v9[v10];
        do
        {
          if ( a1[92] != (*v11 < 0 ? 0 : *v11) )
          {
            *(_DWORD *)(*a1 + 20) = 111;
            *(_DWORD *)(*a1 + 24) = v8;
            *(_DWORD *)(*a1 + 28) = v10;
            (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
          }
          *v11 = a1[93];
          ++v10;
          ++v11;
        }
        while ( v10 <= a1[91] );
      }
      v12 = ++v18 < a1[72];
      ++v20;
    }
    while ( v12 );
    v4 = v17;
    v3 = v23;
  }
  if ( a1[92] )
  {
    if ( v3 )
      *(_DWORD *)(v4 + 4) = sub_10040F80;
    else
      *(_DWORD *)(v4 + 4) = sub_100410E0;
  }
  else if ( v3 )
  {
    *(_DWORD *)(v4 + 4) = sub_10040A10;
  }
  else
  {
    *(_DWORD *)(v4 + 4) = sub_10040CB0;
  }
  v19 = 0;
  if ( a1[72] > 0 )
  {
    v22 = (_DWORD *)(v4 + 24);
    v21 = a1 + 73;
    do
    {
      v13 = *v21;
      if ( v3 )
      {
        if ( !a1[92] )
        {
          v14 = *(_DWORD *)(v13 + 20);
          if ( v14 >= 4 || !a1[v14 + 40] )
          {
            *(_DWORD *)(*a1 + 20) = 49;
            *(_DWORD *)(*a1 + 24) = v14;
            (*(void (__cdecl **)(int *))*a1)(a1);
          }
          sub_1003FC90((int)a1, a1[v14 + 40], (_DWORD *)(v17 + 4 * v14 + 44));
          v4 = v17;
        }
      }
      else
      {
        v15 = *(_DWORD *)(v13 + 24);
        if ( v15 >= 4 || !a1[v15 + 44] )
        {
          *(_DWORD *)(*a1 + 20) = 49;
          *(_DWORD *)(*a1 + 24) = v15;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        sub_1003FC90((int)a1, a1[v15 + 44], (_DWORD *)(v17 + 4 * v15 + 44));
        v3 = v23;
        *(_DWORD *)(v17 + 60) = *(_DWORD *)(v17 + 4 * v15 + 44);
        v4 = v17;
      }
      *v22++ = 0;
      ++v19;
      ++v21;
    }
    while ( v19 < a1[72] );
  }
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  result = a1[63];
  *(_DWORD *)(v4 + 40) = result;
  return result;
}

// sub_10040A10 @ 0x10040A10
char __cdecl sub_10040A10(_DWORD *a1, _WORD **a2)
{
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // esi
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // edx
  _DWORD *v16; // ecx
  int v17; // esi
  bool v18; // cc
  int v19; // eax
  int *v21; // [esp+10h] [ebp-44h]
  int v22; // [esp+14h] [ebp-40h]
  int v23; // [esp+18h] [ebp-3Ch]
  int v24; // [esp+1Ch] [ebp-38h]
  _WORD *v25; // [esp+20h] [ebp-34h]
  _DWORD v26[5]; // [esp+24h] [ebp-30h] BYREF
  unsigned __int8 *v27; // [esp+38h] [ebp-1Ch] BYREF
  int v28; // [esp+3Ch] [ebp-18h]
  int v29; // [esp+40h] [ebp-14h]
  int v30; // [esp+44h] [ebp-10h]
  int v31; // [esp+48h] [ebp-Ch]
  _DWORD *v32; // [esp+4Ch] [ebp-8h]
  int v33; // [esp+50h] [ebp-4h]
  int v34; // [esp+58h] [ebp+4h]

  v3 = a1[101];
  v24 = a1[93];
  if ( a1[63] && !*(_DWORD *)(v3 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 24);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 40) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = a1[5];
  v32 = a1;
  v27 = *(unsigned __int8 **)v6;
  v7 = *(_DWORD *)(v6 + 4);
  v8 = a1[94];
  v28 = v7;
  v29 = v8;
  v9 = *(_DWORD *)(v3 + 12);
  v34 = *(_DWORD *)(v3 + 8);
  v33 = v3 + 16;
  qmemcpy(v26, (const void *)(v3 + 20), sizeof(v26));
  v22 = 0;
  if ( (int)a1[79] > 0 )
  {
    v21 = a1 + 80;
    while ( 1 )
    {
      v25 = *a2;
      v23 = *v21;
      v10 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(a1[*v21 + 73] + 20) + 44);
      if ( v9 < 8 )
      {
        if ( !sub_1003FE80(&v27, v34, v9, 0) )
          return 0;
        v9 = v31;
        v34 = v30;
        if ( v31 < 8 )
          break;
      }
      v12 = (unsigned __int8)(v34 >> (v9 - 8));
      v13 = *(_DWORD *)(v10 + 4 * v12 + 212);
      if ( !v13 )
      {
        v11 = 9;
        goto LABEL_17;
      }
      v9 -= v13;
      v14 = *(unsigned __int8 *)(v12 + v10 + 1236);
LABEL_19:
      if ( v14 )
      {
        if ( v9 < v14 )
        {
          if ( !sub_1003FE80(&v27, v34, v9, v14) )
            return 0;
          v9 = v31;
          v34 = v30;
        }
        v9 -= v14;
        v15 = (v34 >> v9) & ((1 << v14) - 1);
        if ( v15 >= dword_10050710[v14] )
          v14 = (v34 >> v9) & ((1 << v14) - 1);
        else
          v14 = v15 + dword_10050750[v14];
      }
      v16 = &v26[v23 + 1];
      v17 = *v16 + v14;
      *v16 = v17;
      *v25 = v17 << v24;
      v18 = ++v22 < a1[79];
      ++a2;
      ++v21;
      if ( !v18 )
        goto LABEL_27;
    }
    v11 = 1;
LABEL_17:
    v14 = sub_1003FF80((int)&v27, v34, v9, v10, v11);
    if ( v14 < 0 )
      return 0;
    v9 = v31;
    v34 = v30;
    goto LABEL_19;
  }
LABEL_27:
  *(_DWORD *)a1[5] = v27;
  *(_DWORD *)(a1[5] + 4) = v28;
  a1[94] = v29;
  *(_DWORD *)(v3 + 8) = v34;
  *(_DWORD *)(v3 + 12) = v9;
  v19 = *(_DWORD *)(v3 + 40);
  qmemcpy((void *)(v3 + 20), v26, 0x14u);
  *(_DWORD *)(v3 + 40) = v19 - 1;
  return 1;
}

// sub_10040CB0 @ 0x10040CB0
char __cdecl sub_10040CB0(_DWORD *a1, int *a2)
{
  int v3; // esi
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // ebp
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ebp
  int v18; // esi
  int v19; // edx
  int v20; // esi
  int v21; // esi
  int v22; // eax
  int v23; // [esp+10h] [ebp-30h]
  int v24; // [esp+14h] [ebp-2Ch]
  int v25; // [esp+18h] [ebp-28h]
  int v26; // [esp+1Ch] [ebp-24h]
  int v27; // [esp+20h] [ebp-20h]
  unsigned __int8 *v28; // [esp+24h] [ebp-1Ch] BYREF
  int v29; // [esp+28h] [ebp-18h]
  int v30; // [esp+2Ch] [ebp-14h]
  int v31; // [esp+30h] [ebp-10h]
  int v32; // [esp+34h] [ebp-Ch]
  _DWORD *v33; // [esp+38h] [ebp-8h]
  int v34; // [esp+3Ch] [ebp-4h]
  int v35; // [esp+44h] [ebp+4h]
  int v36; // [esp+44h] [ebp+4h]
  int v37; // [esp+48h] [ebp+8h]

  v3 = a1[101];
  v24 = a1[91];
  v25 = v3;
  v26 = a1[93];
  if ( a1[63] && !*(_DWORD *)(v3 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 24);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 40) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = *(_DWORD *)(v3 + 20);
  v23 = v6;
  if ( v6 )
  {
    --*(_DWORD *)(v3 + 40);
    *(_DWORD *)(v3 + 20) = v6 - 1;
    return 1;
  }
  v8 = a1[5];
  v33 = a1;
  v28 = *(unsigned __int8 **)v8;
  v9 = *(_DWORD *)(v8 + 4);
  v30 = a1[94];
  v29 = v9;
  v10 = *(_DWORD *)(v3 + 8);
  v11 = *(_DWORD *)(v3 + 12);
  v34 = v3 + 16;
  v12 = *(_DWORD *)(v3 + 60);
  v27 = *a2;
  v35 = a1[90];
  v37 = v12;
  if ( v35 > v24 )
    goto LABEL_42;
  while ( 1 )
  {
    if ( v11 >= 8 )
      goto LABEL_17;
    if ( !sub_1003FE80(&v28, v10, v11, 0) )
      return 0;
    v11 = v32;
    v10 = v31;
    if ( v32 >= 8 )
    {
LABEL_17:
      v14 = (unsigned __int8)(v10 >> (v11 - 8));
      v15 = *(_DWORD *)(v12 + 4 * v14 + 212);
      if ( v15 )
      {
        v11 -= v15;
        v16 = *(unsigned __int8 *)(v14 + v37 + 1236);
        goto LABEL_22;
      }
      v13 = 9;
    }
    else
    {
      v13 = 1;
    }
    v16 = sub_1003FF80((int)&v28, v10, v11, v12, v13);
    if ( v16 < 0 )
      return 0;
    v10 = v31;
    v11 = v32;
LABEL_22:
    v17 = v16 >> 4;
    v18 = v16 & 0xF;
    if ( !v18 )
      break;
    v36 = v17 + v35;
    if ( v11 < v18 )
    {
      if ( !sub_1003FE80(&v28, v10, v11, v18) )
        return 0;
      v10 = v31;
      v11 = v32;
    }
    v11 -= v18;
    v19 = (v10 >> v11) & ((1 << v18) - 1);
    if ( v19 >= dword_10050710[v18] )
      v20 = (v10 >> v11) & ((1 << v18) - 1);
    else
      v20 = v19 + dword_10050750[v18];
    *(_WORD *)(v27 + 2 * dword_10050550[v36]) = v20 << v26;
LABEL_32:
    v35 = v36 + 1;
    if ( v35 > v24 )
      goto LABEL_41;
    v12 = v37;
  }
  if ( v17 == 15 )
  {
    v36 = v35 + 15;
    goto LABEL_32;
  }
  v21 = 1 << v17;
  if ( v17 )
  {
    if ( v11 < v17 )
    {
      if ( !sub_1003FE80(&v28, v10, v11, v17) )
        return 0;
      v10 = v31;
      v11 = v32;
    }
    v11 -= v17;
    v21 += (v21 - 1) & (v10 >> v11);
  }
  v23 = v21 - 1;
LABEL_41:
  v3 = v25;
  v6 = v23;
LABEL_42:
  *(_DWORD *)a1[5] = v28;
  *(_DWORD *)(a1[5] + 4) = v29;
  a1[94] = v30;
  *(_DWORD *)(v3 + 12) = v11;
  v22 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(v3 + 8) = v10;
  *(_DWORD *)(v3 + 40) = v22 - 1;
  *(_DWORD *)(v3 + 20) = v6;
  return 1;
}

// sub_10040F80 @ 0x10040F80
char __cdecl sub_10040F80(_DWORD *a1, _WORD **a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  _WORD *v11; // ebp
  int v13; // [esp+10h] [ebp-20h]
  unsigned __int8 *v14; // [esp+14h] [ebp-1Ch] BYREF
  int v15; // [esp+18h] [ebp-18h]
  int v16; // [esp+1Ch] [ebp-14h]
  int v17; // [esp+20h] [ebp-10h]
  int v18; // [esp+24h] [ebp-Ch]
  _DWORD *v19; // [esp+28h] [ebp-8h]
  int v20; // [esp+2Ch] [ebp-4h]

  v3 = 0;
  v4 = a1[101];
  v13 = 1 << a1[93];
  if ( a1[63] && !*(_DWORD *)(v4 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v4 + 12) / 8;
    *(_DWORD *)(v4 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v5 = 0;
    if ( (int)a1[72] > 0 )
    {
      v6 = (_DWORD *)(v4 + 24);
      do
      {
        *v6 = 0;
        ++v5;
        ++v6;
      }
      while ( v5 < a1[72] );
    }
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 40) = a1[63];
    *(_BYTE *)(v4 + 16) = 0;
  }
  v7 = a1[5];
  v8 = a1[94];
  v19 = a1;
  v14 = *(unsigned __int8 **)v7;
  v15 = *(_DWORD *)(v7 + 4);
  v16 = v8;
  v9 = *(_DWORD *)(v4 + 8);
  v10 = *(_DWORD *)(v4 + 12);
  v20 = v4 + 16;
  if ( (int)a1[79] > 0 )
  {
    do
    {
      v11 = *a2;
      if ( v10 < 1 )
      {
        if ( !sub_1003FE80(&v14, v9, v10, 1) )
          return 0;
        v9 = v17;
        v10 = v18;
      }
      if ( ((v9 >> --v10) & 1) != 0 )
        *v11 |= v13;
      ++v3;
      ++a2;
    }
    while ( v3 < a1[79] );
  }
  *(_DWORD *)a1[5] = v14;
  *(_DWORD *)(a1[5] + 4) = v15;
  a1[94] = v16;
  *(_DWORD *)(v4 + 8) = v9;
  --*(_DWORD *)(v4 + 40);
  *(_DWORD *)(v4 + 12) = v10;
  return 1;
}

// sub_100410E0 @ 0x100410E0
char __cdecl sub_100410E0(_DWORD *a1, int *a2)
{
  _DWORD *v2; // ebx
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // ebp
  int v11; // esi
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  int v18; // ebx
  int v19; // edx
  __int16 *v20; // edi
  __int16 v21; // ax
  __int16 v22; // ax
  bool v23; // cc
  int v24; // eax
  int *v25; // ecx
  int v26; // edi
  __int16 *v27; // edi
  __int16 v28; // cx
  __int16 v29; // ax
  int v30; // eax
  int v32; // ecx
  _DWORD *v33; // eax
  int v34; // edx
  int *v35; // [esp+10h] [ebp-14Ch]
  int *v36; // [esp+10h] [ebp-14Ch]
  int v37; // [esp+14h] [ebp-148h]
  int v38; // [esp+18h] [ebp-144h]
  int v39; // [esp+1Ch] [ebp-140h]
  int v40; // [esp+20h] [ebp-13Ch]
  int v41; // [esp+24h] [ebp-138h]
  int v42; // [esp+28h] [ebp-134h]
  int v43; // [esp+2Ch] [ebp-130h]
  int v44; // [esp+30h] [ebp-12Ch]
  int v45; // [esp+34h] [ebp-128h]
  unsigned __int8 *v46; // [esp+38h] [ebp-124h] BYREF
  int v47; // [esp+3Ch] [ebp-120h]
  int v48; // [esp+40h] [ebp-11Ch]
  int v49; // [esp+44h] [ebp-118h]
  int v50; // [esp+48h] [ebp-114h]
  _DWORD *v51; // [esp+4Ch] [ebp-110h]
  int v52; // [esp+50h] [ebp-10Ch]
  int v53; // [esp+54h] [ebp-108h]
  int *v54; // [esp+58h] [ebp-104h]
  _DWORD v55[64]; // [esp+5Ch] [ebp-100h] BYREF

  v2 = a1;
  v3 = a1[93];
  v39 = a1[91];
  v4 = a1[101];
  v43 = 1 << v3;
  v42 = v4;
  v45 = -1 << v3;
  if ( a1[63] && !*(_DWORD *)(v4 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v4 + 12) / 8;
    *(_DWORD *)(v4 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v5 = 0;
    if ( (int)a1[72] > 0 )
    {
      v6 = (_DWORD *)(v4 + 24);
      do
      {
        *v6 = 0;
        ++v5;
        ++v6;
      }
      while ( v5 < a1[72] );
    }
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 40) = a1[63];
    *(_BYTE *)(v4 + 16) = 0;
  }
  v7 = a1[5];
  v51 = a1;
  v46 = *(unsigned __int8 **)v7;
  v8 = *(_DWORD *)(v7 + 4);
  v9 = a1[94];
  v47 = v8;
  v48 = v9;
  v10 = *(_DWORD *)(v4 + 8);
  v11 = *(_DWORD *)(v4 + 12);
  v52 = v4 + 16;
  v41 = *a2;
  v12 = a1[90];
  v38 = *(_DWORD *)(v4 + 20);
  v53 = *(_DWORD *)(v4 + 60);
  v44 = 0;
  v37 = v12;
  if ( v38 )
  {
LABEL_55:
    if ( v38 )
    {
      if ( v37 <= v39 )
      {
        v36 = &dword_10050550[v37];
        do
        {
          v27 = (__int16 *)(v41 + 2 * *v36);
          if ( *v27 )
          {
            if ( v11 < 1 )
            {
              if ( !sub_1003FE80(&v46, v10, v11, 1) )
                goto LABEL_71;
              v10 = v49;
              v11 = v50;
            }
            if ( ((v10 >> --v11) & 1) != 0 )
            {
              v28 = v43;
              v29 = *v27;
              if ( (*v27 & v43) == 0 )
              {
                if ( v29 < 0 )
                  v28 = v45;
                *v27 = v28 + v29;
              }
            }
          }
          v23 = ++v37 <= v39;
          ++v36;
        }
        while ( v23 );
        v4 = v42;
      }
      --v38;
    }
    goto LABEL_70;
  }
  if ( v12 > v39 )
  {
LABEL_70:
    *(_DWORD *)v2[5] = v46;
    *(_DWORD *)(v2[5] + 4) = v47;
    v2[94] = v48;
    v30 = *(_DWORD *)(v4 + 40) - 1;
    *(_DWORD *)(v4 + 8) = v10;
    *(_DWORD *)(v4 + 12) = v11;
    *(_DWORD *)(v4 + 40) = v30;
    *(_DWORD *)(v4 + 20) = v38;
    return 1;
  }
  v54 = v55;
  while ( 1 )
  {
    if ( v11 >= 8 )
      goto LABEL_15;
    if ( !sub_1003FE80(&v46, v10, v11, 0) )
      goto LABEL_71;
    v11 = v50;
    v10 = v49;
    if ( v50 >= 8 )
    {
LABEL_15:
      v14 = (unsigned __int8)(v10 >> (v11 - 8));
      v15 = *(_DWORD *)(v53 + 4 * v14 + 212);
      if ( v15 )
      {
        v11 -= v15;
        v16 = *(unsigned __int8 *)(v14 + v53 + 1236);
        goto LABEL_20;
      }
      v13 = 9;
    }
    else
    {
      v13 = 1;
    }
    v16 = sub_1003FF80((int)&v46, v10, v11, v53, v13);
    if ( v16 < 0 )
      goto LABEL_71;
    v10 = v49;
    v11 = v50;
LABEL_20:
    v17 = v16 >> 4;
    v18 = v16 & 0xF;
    v40 = v17;
    if ( !v18 )
      break;
    if ( v18 != 1 )
    {
      *(_DWORD *)(*a1 + 20) = 114;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    }
    if ( v11 < 1 )
    {
      if ( !sub_1003FE80(&v46, v10, v11, 1) )
        goto LABEL_71;
      v10 = v49;
      v11 = v50;
    }
    --v11;
    v19 = v37;
    if ( ((v10 >> v11) & 1) != 0 )
      v18 = v43;
    else
      v18 = v45;
    v17 = v40;
    v35 = &dword_10050550[v37];
    while ( 1 )
    {
LABEL_33:
      v20 = (__int16 *)(v41 + 2 * *v35);
      if ( *v20 )
      {
        if ( v11 < 1 )
        {
          if ( !sub_1003FE80(&v46, v10, v11, 1) )
            goto LABEL_71;
          v10 = v49;
          v11 = v50;
        }
        if ( ((v10 >> --v11) & 1) != 0 )
        {
          v21 = *v20;
          if ( (*v20 & v43) == 0 )
          {
            if ( v21 < 0 )
              v22 = v45 + v21;
            else
              v22 = v43 + v21;
            *v20 = v22;
          }
        }
      }
      else
      {
        v40 = v17 - 1;
        if ( v17 - 1 < 0 )
          break;
      }
      v19 = v37 + 1;
      v23 = ++v37 <= v39;
      ++v35;
      if ( !v23 )
        break;
      v17 = v40;
    }
    if ( v18 )
    {
      v24 = dword_10050550[v19];
      *(_WORD *)(v41 + 2 * v24) = v18;
      v25 = v54;
      *v54 = v24;
      ++v44;
      v54 = v25 + 1;
    }
    v37 = v19 + 1;
    if ( v19 + 1 > v39 )
    {
      v2 = a1;
      v4 = v42;
      goto LABEL_70;
    }
  }
  if ( v17 == 15 )
  {
    v19 = v37;
    v35 = &dword_10050550[v37];
    goto LABEL_33;
  }
  v26 = 1 << v17;
  v38 = 1 << v17;
  if ( !v17 )
    goto LABEL_54;
  if ( v11 >= v17 )
    goto LABEL_53;
  if ( sub_1003FE80(&v46, v10, v11, v17) )
  {
    v10 = v49;
    v11 = v50;
LABEL_53:
    v11 -= v40;
    v38 += (v26 - 1) & (v10 >> v11);
LABEL_54:
    v2 = a1;
    v4 = v42;
    goto LABEL_55;
  }
LABEL_71:
  v32 = v44;
  if ( v44 > 0 )
  {
    v33 = &v55[v44];
    do
    {
      v34 = *--v33;
      --v32;
      *(_WORD *)(v41 + 2 * v34) = 0;
    }
    while ( v32 );
  }
  return 0;
}

// sub_10041590 @ 0x10041590
_DWORD *__cdecl sub_10041590(int a1)
{
  _DWORD *result; // eax
  int v3; // ebx
  _DWORD *v4; // ebp
  void *v5; // eax
  _DWORD *v6; // [esp+Ch] [ebp+4h]

  result = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  *(_DWORD *)(a1 + 408) = result;
  *result = sub_10041610;
  v3 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 80);
    v4 = result + 11;
    do
    {
      v5 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
      *v6 = v5;
      memset(v5, 0, 0x100u);
      *v4 = -1;
      result = *(_DWORD **)(a1 + 32);
      ++v3;
      ++v4;
      v6 += 21;
    }
    while ( v3 < (int)result );
  }
  return result;
}

// sub_10041610 @ 0x10041610
int __cdecl sub_10041610(int *a1)
{
  int *v1; // edi
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int *v5; // ebp
  int v6; // eax
  int v7; // eax
  char *v8; // edx
  int v9; // edi
  char *v10; // ebx
  double *v11; // esi
  int v12; // edx
  unsigned __int16 *v13; // ecx
  double *v14; // eax
  unsigned __int16 v15; // bp
  int v16; // ecx
  __int16 *v17; // eax
  int v18; // edx
  int v19; // ebp
  unsigned __int16 v20; // bx
  int v21; // ecx
  char *v22; // eax
  int v23; // edx
  unsigned __int16 v24; // bp
  bool v25; // cc
  int v26; // [esp+Ch] [ebp-18h]
  int (*v27)(); // [esp+10h] [ebp-14h]
  int v28; // [esp+14h] [ebp-10h]
  int v29; // [esp+18h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-8h]

  v1 = a1;
  result = a1[102];
  v3 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if ( a1[8] > 0 )
  {
    v4 = a1[49] + 36;
    v5 = (int *)(result + 44);
    v30 = v4;
    v29 = result + 44;
    do
    {
      switch ( *(_DWORD *)v4 )
      {
        case 1:
          v3 = 0;
          v27 = sub_100463C0;
          v26 = 0;
          break;
        case 2:
          v3 = 0;
          v27 = (int (*)())sub_10046190;
          v26 = 0;
          break;
        case 4:
          v3 = 0;
          v27 = (int (*)())sub_10045D90;
          v26 = 0;
          break;
        case 8:
          v6 = v1[17];
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                v3 = 2;
                v27 = (int (*)())sub_10045930;
                v26 = 2;
              }
              else
              {
                *(_DWORD *)(*v1 + 20) = 47;
                (*(void (__cdecl **)(int *))*v1)(v1);
              }
            }
            else
            {
              v3 = 1;
              v27 = (int (*)())sub_100454A0;
              v26 = 1;
            }
          }
          else
          {
            v3 = 0;
            v27 = (int (*)())sub_10044E50;
            v26 = 0;
          }
          break;
        default:
          *(_DWORD *)(*v1 + 20) = 6;
          *(_DWORD *)(*v1 + 24) = *(_DWORD *)v4;
          (*(void (__cdecl **)(int *))*v1)(v1);
          break;
      }
      *(v5 - 10) = (int)v27;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( *v5 != v3 )
        {
          v8 = *(char **)(v4 + 40);
          if ( v8 )
          {
            *v5 = v3;
            if ( v3 )
            {
              if ( v3 == 1 )
              {
                v16 = *(_DWORD *)(v4 + 44);
                v17 = (__int16 *)&unk_10050790;
                v18 = v8 - (char *)&unk_10050790;
                do
                {
                  v19 = *v17;
                  v20 = *(__int16 *)((char *)v17++ + v18);
                  v16 += 4;
                  *(_DWORD *)(v16 - 4) = (v19 * v20 + 2048) >> 12;
                }
                while ( (int)v17 < (int)word_10050810 );
                v3 = v26;
              }
              else
              {
                v9 = *(_DWORD *)(v4 + 44);
                v10 = v8;
                v11 = (double *)word_10050810;
                do
                {
                  v12 = v9;
                  v13 = (unsigned __int16 *)v10;
                  v9 += 32;
                  v14 = (double *)word_10050810;
                  v10 += 16;
                  do
                  {
                    v15 = *v13;
                    ++v14;
                    ++v13;
                    v12 += 4;
                    *(float *)(v12 - 4) = (double)v15 * *(v14 - 1) * *v11;
                  }
                  while ( (int)v14 < (int)dbl_10050850 );
                  ++v11;
                }
                while ( (int)v11 < (int)dbl_10050850 );
                v4 = v30;
                v3 = v26;
                v1 = a1;
              }
            }
            else
            {
              v21 = *(_DWORD *)(v4 + 44);
              v22 = v8;
              v23 = 64;
              do
              {
                v24 = *(_WORD *)v22;
                v22 += 2;
                v21 += 4;
                --v23;
                *(_DWORD *)(v21 - 4) = v24;
              }
              while ( v23 );
            }
          }
        }
      }
      result = v28 + 1;
      v5 = (int *)(v29 + 4);
      v4 += 84;
      v25 = ++v28 < v1[8];
      v29 += 4;
      v30 = v4;
    }
    while ( v25 );
  }
  return result;
}

// sub_10041850 @ 0x10041850
char __cdecl sub_10041850(int a1, char a2)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v8; // [esp-8h] [ebp-10h]

  v2 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 392) = v2;
  *v2 = sub_100418E0;
  v2[2] = 0;
  v2[3] = 0;
  LOBYTE(v3) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v3 )
  {
    v4 = *(_DWORD *)(a1 + 272);
    v2[4] = v4;
    if ( a2 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      v8 = v4;
      v6 = sub_1003E470(*(_DWORD *)(a1 + 96), v4);
      v3 = (*(int (__cdecl **)(int, int, _DWORD, int, int, int))(v5 + 16))(
             a1,
             1,
             0,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v6,
             v8);
      v2[2] = v3;
    }
    else
    {
      v3 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
             a1,
             1,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v4);
      v2[3] = v3;
    }
  }
  return v3;
}

// sub_100418E0 @ 0x100418E0
int __cdecl sub_100418E0(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // esi
  int v4; // ecx

  result = a1;
  v3 = *(_DWORD **)(a1 + 392);
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10041b00;
      v3[6] = 0;
      v3[5] = 0;
    }
    else if ( a2 == 3 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10041a60;
      v3[6] = 0;
      v3[5] = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (**(int (__cdecl ***)(int))a1)(a1);
      v3[6] = 0;
      v3[5] = 0;
    }
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) )
    {
      v4 = v3[3];
      v3[1] = sub_100419E0;
      if ( !v4 )
      {
        result = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 4) + 28))(
                   a1,
                   v3[2],
                   0,
                   v3[4],
                   1);
        v3[3] = result;
        v3[6] = 0;
        v3[5] = 0;
        return result;
      }
    }
    else
    {
      result = *(_DWORD *)(a1 + 412);
      v3[1] = *(_DWORD *)(result + 4);
    }
    v3[6] = 0;
    v3[5] = 0;
  }
  return result;
}

// sub_100419E0 @ 0x100419E0
int __cdecl sub_100419E0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebx
  int v8; // esi
  int v9; // edi
  unsigned int v10; // eax
  int v11; // ecx
  int result; // eax

  v7 = a6;
  v8 = a1;
  v9 = *(_DWORD *)(a1 + 392);
  v10 = a7 - *a6;
  if ( v10 > *(_DWORD *)(v9 + 16) )
    v10 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD *)(a1 + 412);
  a1 = 0;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, int *, unsigned int))(v11 + 4))(
    v8,
    a2,
    a3,
    a4,
    *(_DWORD *)(v9 + 12),
    &a1,
    v10);
  (*(void (__cdecl **)(int, _DWORD, int, int))(*(_DWORD *)(v8 + 420) + 4))(v8, *(_DWORD *)(v9 + 12), a5 + 4 * *v7, a1);
  result = a1 + *v7;
  *v7 = result;
  return result;
}

// FUN_10041a60 @ 0x10041A60
// [binja] int32_t sub_10041a60(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, void** arg5)
int FUN_10041a60(void *arg1, int arg2, int arg3, int arg4, void **arg5)
{
  _DWORD *v6; // esi
  unsigned int *v7; // ebx
  unsigned int v8; // ebp
  unsigned int v9; // eax
  int result; // eax
  unsigned int arg1a; // [esp+10h] [ebp+4h]
  _DWORD *v12; // [esp+24h] [ebp+18h]

  v6 = (_DWORD *)*((_DWORD *)arg1 + 98);
  v7 = v6 + 6;
  if ( !v6[6] )
    v6[3] = (*(int (__cdecl **)(void *, _DWORD, _DWORD, _DWORD, int))(*((_DWORD *)arg1 + 1) + 28))(
              arg1,
              v6[2],
              v6[5],
              v6[4],
              1);
  v8 = *v7;
  (*(void (__cdecl **)(void *, int, int, int, _DWORD, _DWORD *, _DWORD))(*((_DWORD *)arg1 + 103) + 4))(
    arg1,
    arg2,
    arg3,
    arg4,
    v6[3],
    v6 + 6,
    v6[4]);
  v9 = *v7;
  if ( *v7 > v8 )
  {
    arg1a = v9 - v8;
    (*(void (__cdecl **)(void *, unsigned int, _DWORD, unsigned int))(*((_DWORD *)arg1 + 105) + 4))(
      arg1,
      v6[3] + 4 * v8,
      0,
      v9 - v8);
    *v12 += arg1a;
  }
  result = v6[4];
  if ( *v7 >= result )
  {
    v6[5] += result;
    *v7 = 0;
  }
  return result;
}

// FUN_10041b00 @ 0x10041B00
// [binja] int32_t sub_10041b00(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
int FUN_10041b00(void *arg1, int arg2, int *arg3, int arg4)
{
  _DWORD *v4; // esi
  unsigned int v5; // edi
  int result; // eax
  unsigned int v7; // ecx
  int v8; // [esp+24h] [ebp+14h]
  _DWORD *v9; // [esp+28h] [ebp+18h]
  int v10; // [esp+2Ch] [ebp+1Ch]

  v4 = (_DWORD *)*((_DWORD *)arg1 + 98);
  if ( !v4[6] )
    v4[3] = (*(int (__cdecl **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*((_DWORD *)arg1 + 1) + 28))(
              arg1,
              v4[2],
              v4[5],
              v4[4],
              0);
  v5 = v4[4] - v4[6];
  if ( v5 > v10 - *v9 )
    v5 = v10 - *v9;
  if ( v5 > *((_DWORD *)arg1 + 24) - v4[5] )
    v5 = *((_DWORD *)arg1 + 24) - v4[5];
  (*(void (__cdecl **)(void *, int, int, unsigned int))(*((_DWORD *)arg1 + 105) + 4))(
    arg1,
    v4[3] + 4 * v4[6],
    v8 + 4 * *v9,
    v5);
  *v9 += v5;
  result = v4[4];
  v7 = v5 + v4[6];
  v4[6] = v7;
  if ( v7 >= result )
  {
    v4[5] += result;
    v4[6] = 0;
  }
  return result;
}

// sub_10041BA0 @ 0x10041BA0
int __cdecl sub_10041BA0(int a1)
{
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  char v16; // [esp+24h] [ebp+4h]

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  *(_DWORD *)(a1 + 412) = v2;
  *(_DWORD *)v2 = sub_10041DA0;
  *(_DWORD *)(v2 + 4) = sub_10041DC0;
  *(_BYTE *)(v2 + 8) = 0;
  v13 = v2;
  if ( *(_BYTE *)(a1 + 264) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 23;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_BYTE *)(a1 + 72) || (v16 = 1, *(int *)(a1 + 276) <= 1) )
    v16 = 0;
  result = *(_DWORD *)(a1 + 32);
  v14 = 0;
  if ( result > 0 )
  {
    v4 = *(_DWORD *)(a1 + 196) + 36;
    v5 = (_DWORD *)(v2 + 52);
    do
    {
      v6 = *(_DWORD *)(a1 + 276);
      v15 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 28) / v6;
      v7 = *(_DWORD *)(a1 + 272);
      v8 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 24) / v6;
      v9 = *(_DWORD *)(a1 + 268);
      v5[12] = v8;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( v15 != v9 || v8 != v7 )
        {
          if ( 2 * v15 == v9 )
          {
            if ( v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
                *v5 = sub_100420E0;
              else
                *v5 = sub_10041FF0;
LABEL_29:
              v10 = *(_DWORD *)(a1 + 4);
              v12 = *(_DWORD *)(a1 + 272);
              v11 = sub_1003E470(*(_DWORD *)(a1 + 92), *(_DWORD *)(a1 + 268));
              *(v5 - 10) = (*(int (__cdecl **)(int, int, int, int))(v10 + 8))(a1, 1, v11, v12);
              goto LABEL_30;
            }
            if ( 2 * v15 == v9 && 2 * v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
              {
                *v5 = sub_100421B0;
                *(_BYTE *)(v13 + 8) = 1;
              }
              else
              {
                *v5 = sub_10042050;
              }
              goto LABEL_29;
            }
          }
          if ( v9 % v15 || v7 % v8 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 37;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            *v5 = sub_10041ED0;
            *(_BYTE *)(v14 + v13 + 140) = v9 / v15;
            *(_BYTE *)(v14 + v13 + 150) = v7 / v8;
          }
          goto LABEL_29;
        }
        *v5 = sub_10041EB0;
      }
      else
      {
        *v5 = sub_10041EC0;
      }
LABEL_30:
      result = v14 + 1;
      ++v5;
      v4 += 84;
      ++v14;
    }
    while ( v14 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10041DA0 @ 0x10041DA0
int __cdecl sub_10041DA0(_DWORD *a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1[103];
  *(_DWORD *)(v1 + 92) = a1[68];
  result = a1[24];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

// sub_10041DC0 @ 0x10041DC0
_DWORD *__cdecl sub_10041DC0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v8; // ebx
  int v9; // eax
  int v11; // esi
  bool v12; // cc
  unsigned int v13; // esi
  signed int v14; // ecx
  _DWORD *result; // eax
  int v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+18h] [ebp+4h]

  v8 = a1[103];
  if ( *(_DWORD *)(v8 + 92) >= a1[68] )
  {
    v9 = a1[8];
    v16 = 0;
    v17 = a1[49];
    if ( v9 > 0 )
    {
      v11 = v8 + 12;
      do
      {
        (*(void (__cdecl **)(_DWORD *, int, int, int))(v11 + 40))(a1, v17, *a2 + 4 * *a3 * *(_DWORD *)(v11 + 88), v11);
        v11 += 4;
        ++a2;
        v12 = ++v16 < a1[8];
        v17 += 84;
      }
      while ( v12 );
    }
    *(_DWORD *)(v8 + 92) = 0;
  }
  v13 = a1[68] - *(_DWORD *)(v8 + 92);
  if ( v13 > *(_DWORD *)(v8 + 96) )
    v13 = *(_DWORD *)(v8 + 96);
  if ( v13 > a7 - *a6 )
    v13 = a7 - *a6;
  (*(void (__cdecl **)(_DWORD *, int, _DWORD, int, unsigned int))(a1[104] + 4))(
    a1,
    v8 + 12,
    *(_DWORD *)(v8 + 92),
    a5 + 4 * *a6,
    v13);
  *a6 += v13;
  v14 = v13 + *(_DWORD *)(v8 + 92);
  *(_DWORD *)(v8 + 96) -= v13;
  *(_DWORD *)(v8 + 92) = v14;
  result = (_DWORD *)a1[68];
  if ( v14 >= (int)result )
  {
    ++*a3;
    return a3;
  }
  return result;
}

// sub_10041EB0 @ 0x10041EB0
_DWORD *__cdecl sub_10041EB0(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = a3;
  return a4;
}

// sub_10041EC0 @ 0x10041EC0
_DWORD *__cdecl sub_10041EC0(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = 0;
  return a4;
}

// sub_10041ED0 @ 0x10041ED0
int __cdecl sub_10041ED0(int a1, int a2, char **a3, int *a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // edi
  int v7; // edx
  int result; // eax
  char *v9; // esi
  char *v10; // ecx
  unsigned int v11; // ebp
  char v12; // al
  int v13; // eax
  void **v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+10h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-8h]
  int v17; // [esp+18h] [ebp-4h]
  int v18; // [esp+24h] [ebp+8h]

  v4 = a1;
  v5 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a1 + 412);
  v17 = *a4;
  v6 = *(unsigned __int8 *)(v5 + 140);
  v7 = *(unsigned __int8 *)(v5 + 150);
  result = 0;
  v16 = v6;
  v18 = 0;
  v15 = v7;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v14 = (void **)*a4;
    do
    {
      v9 = (char *)*v14;
      v10 = *a3;
      v11 = (unsigned int)*v14 + *(_DWORD *)(v4 + 92);
      if ( (unsigned int)*v14 < v11 )
      {
        do
        {
          v12 = *v10++;
          if ( v6 > 0 )
          {
            LOBYTE(v4) = v12;
            BYTE1(v4) = v12;
            v13 = v4 << 16;
            LOWORD(v13) = v4;
            v4 = a1;
            memset32(v9, v13, (unsigned int)v6 >> 2);
            v7 = v15;
            memset(&v9[4 * ((unsigned int)v6 >> 2)], v13, v6 & 3);
            v6 = v16;
            v9 += v16;
          }
        }
        while ( (unsigned int)v9 < v11 );
        result = v18;
      }
      if ( v7 > 1 )
      {
        sub_1003E490(v17, result, v17, result + 1, v7 - 1, *(_DWORD *)(v4 + 92));
        v7 = v15;
        result = v18;
      }
      ++a3;
      result += v7;
      v18 = result;
      v14 += v7;
    }
    while ( result < *(_DWORD *)(v4 + 272) );
  }
  return result;
}

// sub_10041FF0 @ 0x10041FF0
int __cdecl sub_10041FF0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v4; // edi
  int result; // eax
  int v6; // ebp
  _BYTE *v7; // eax
  char *v8; // esi
  unsigned int v9; // ecx
  char v10; // dl
  _BYTE *v11; // eax
  int v12; // [esp+18h] [ebp+10h]

  v4 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v12 = 0;
  if ( result > 0 )
  {
    v6 = a3 - (_DWORD)v4;
    do
    {
      v7 = *v4;
      v8 = *(_BYTE **)((char *)v4 + v6);
      v9 = (unsigned int)&(*v4)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v4 < v9 )
      {
        do
        {
          v10 = *v8++;
          *v7 = v10;
          v11 = v7 + 1;
          *v11 = v10;
          v7 = v11 + 1;
        }
        while ( (unsigned int)v7 < v9 );
      }
      result = v12 + 1;
      ++v4;
      ++v12;
    }
    while ( v12 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_10042050 @ 0x10042050
int __cdecl sub_10042050(int a1, int a2, char **a3, int *a4)
{
  int v5; // ebp
  int result; // eax
  int v7; // esi
  _BYTE *v8; // eax
  char *v9; // edi
  unsigned int v10; // ecx
  char v11; // dl
  _BYTE *v12; // eax
  _BYTE **v13; // [esp+10h] [ebp+4h]

  v5 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v7 = 0;
  if ( result > 0 )
  {
    v13 = (_BYTE **)*a4;
    do
    {
      v8 = *v13;
      v9 = *a3;
      v10 = (unsigned int)&(*v13)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v13 < v10 )
      {
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v12 = v8 + 1;
          *v12 = v11;
          v8 = v12 + 1;
        }
        while ( (unsigned int)v8 < v10 );
      }
      sub_1003E490(v5, v7, v5, v7 + 1, 1, *(_DWORD *)(a1 + 92));
      result = *(_DWORD *)(a1 + 272);
      v7 += 2;
      ++a3;
      v13 += 2;
    }
    while ( v7 < result );
  }
  return result;
}

// sub_100420E0 @ 0x100420E0
int __cdecl sub_100420E0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v4; // edi
  int result; // eax
  int v6; // esi
  unsigned __int8 *v7; // ecx
  _BYTE *v8; // eax
  int v9; // edx
  unsigned __int8 *v10; // ecx
  _BYTE *v11; // eax
  int v12; // ebp
  int v13; // edx
  _BYTE *v14; // eax
  int v15; // edx
  int v16; // [esp+10h] [ebp+Ch]
  int v17; // [esp+14h] [ebp+10h]

  v4 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v17 = 0;
  if ( result > 0 )
  {
    v6 = a3 - (_DWORD)v4;
    v16 = a3 - (_DWORD)v4;
    do
    {
      v7 = *(_BYTE **)((char *)v4 + v6);
      v8 = *v4;
      v9 = *v7;
      *v8 = v9;
      v10 = v7 + 1;
      *++v8 = (3 * v9 + *v10 + 2) >> 2;
      v11 = v8 + 1;
      if ( *(_DWORD *)(a2 + 40) != 2 )
      {
        v12 = *(_DWORD *)(a2 + 40) - 2;
        do
        {
          v13 = *v10++;
          *v11 = (*(v10 - 2) + 3 * v13 + 1) >> 2;
          v14 = v11 + 1;
          *v14 = (*v10 + 3 * v13 + 2) >> 2;
          v11 = v14 + 1;
          --v12;
        }
        while ( v12 );
        v6 = v16;
      }
      v15 = *v10;
      ++v4;
      *v11 = (*(v10 - 1) + 3 * v15 + 1) >> 2;
      v11[1] = v15;
      result = ++v17;
    }
    while ( v17 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_100421B0 @ 0x100421B0
int __cdecl sub_100421B0(int a1, int a2, int a3, int *a4)
{
  int result; // eax
  int v5; // esi
  int v6; // edi
  int v7; // ecx
  _BYTE **i; // eax
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // edi
  _BYTE *v11; // ecx
  int v12; // esi
  int v13; // eax
  unsigned __int8 *v14; // edi
  unsigned __int8 *v15; // ebp
  _BYTE *v16; // ecx
  int v17; // edx
  int v18; // esi
  _BYTE *v19; // ecx
  int v20; // [esp+4h] [ebp-14h]
  int v21; // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+10h] [ebp-8h]
  _BYTE **v24; // [esp+14h] [ebp-4h]
  int v25; // [esp+28h] [ebp+10h]

  v23 = *a4;
  result = 0;
  v5 = 0;
  v20 = 0;
  v25 = 0;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v6 = a3;
    do
    {
      v7 = 0;
      v22 = 0;
      for ( i = (_BYTE **)(v23 + 4 * result); ; i = v24 )
      {
        v9 = *(unsigned __int8 **)(v6 + 4 * v5);
        v10 = v7 ? *(unsigned __int8 **)(v6 + 4 * v5 + 4) : *(unsigned __int8 **)(v6 + 4 * v5 - 4);
        v11 = *i;
        v24 = i + 1;
        ++v20;
        v12 = *v10 + 3 * *v9;
        v13 = v10[1] + 3 * v9[1];
        *v11 = (4 * v12 + 8) >> 4;
        v14 = v10 + 2;
        v15 = v9 + 2;
        *++v11 = (v12 + v13 + 2 * v12 + 7) >> 4;
        v16 = v11 + 1;
        v17 = v12;
        v18 = v13;
        if ( *(_DWORD *)(a2 + 40) == 2 )
        {
          v5 = v25;
          v6 = a3;
        }
        else
        {
          v21 = *(_DWORD *)(a2 + 40) - 2;
          do
          {
            v13 = *v14 + 3 * *v15;
            *v16 = (3 * v18 + v17 + 8) >> 4;
            ++v14;
            ++v15;
            v19 = v16 + 1;
            *v19 = (3 * v18 + v13 + 7) >> 4;
            v16 = v19 + 1;
            v17 = v18;
            v18 = v13;
            --v21;
          }
          while ( v21 );
          v6 = a3;
          v5 = v25;
        }
        *v16 = (v13 + v17 + 2 * v13 + 8) >> 4;
        v16[1] = (4 * v13 + 7) >> 4;
        v7 = ++v22;
        if ( v22 >= 2 )
          break;
      }
      result = v20;
      v25 = ++v5;
    }
    while ( v20 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_10042310 @ 0x10042310
char __cdecl sub_10042310(int a1)
{
  void (**v1)(); // edi
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // eax

  v1 = (void (**)())(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 416) = v1;
  *v1 = nullsub_4;
  switch ( *(_DWORD *)(a1 + 36) )
  {
    case 1:
      if ( *(_DWORD *)(a1 + 32) != 1 )
        goto LABEL_9;
      break;
    case 2:
    case 3:
      if ( *(_DWORD *)(a1 + 32) != 3 )
        goto LABEL_9;
      break;
    case 4:
    case 5:
      if ( *(_DWORD *)(a1 + 32) != 4 )
        goto LABEL_9;
      break;
    default:
      if ( *(int *)(a1 + 32) < 1 )
      {
LABEL_9:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      break;
  }
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    if ( *(_DWORD *)(a1 + 40) == 2 )
    {
      v3 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 3;
      if ( v3 == 3 )
      {
        v1[1] = (void (*)())sub_10042590;
        sub_100424D0(a1);
        goto LABEL_31;
      }
      if ( v3 == 2 )
      {
        v1[1] = (void (*)())sub_100426C0;
        goto LABEL_31;
      }
    }
    else if ( *(_DWORD *)(a1 + 40) == 4 )
    {
      v2 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 4;
      if ( v2 == 5 )
      {
        v1[1] = (void (*)())sub_10042780;
        sub_100424D0(a1);
        goto LABEL_31;
      }
      if ( v2 == 4 )
      {
        v1[1] = (void (*)())sub_100426C0;
        goto LABEL_31;
      }
    }
    else if ( *(_DWORD *)(a1 + 40) == *(_DWORD *)(a1 + 36) )
    {
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      v1[1] = (void (*)())sub_100426C0;
      goto LABEL_31;
    }
    goto LABEL_27;
  }
  v4 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 100) = 1;
  if ( v4 != 1 && v4 != 3 )
  {
LABEL_27:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void (__cdecl ***)(int))a1)(a1);
    goto LABEL_31;
  }
  v1[1] = (void (*)())sub_10042750;
  v5 = 1;
  if ( *(int *)(a1 + 32) > 1 )
  {
    v6 = 84;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 196) + v6 + 48) = 0;
      ++v5;
      v6 += 84;
    }
    while ( v5 < *(_DWORD *)(a1 + 32) );
  }
LABEL_31:
  LOBYTE(v7) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v7 )
  {
    *(_DWORD *)(a1 + 104) = 1;
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 104) = v7;
  }
  return v7;
}

// sub_100424D0 @ 0x100424D0
int __cdecl sub_100424D0(int a1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // edi
  int v4; // edx
  int v5; // ecx
  int v6; // [esp+14h] [ebp+4h]

  v1 = *(_DWORD **)(a1 + 416);
  v1[2] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[3] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v6 = 5990656;
  v3 = -14831872;
  v4 = -11728000;
  v5 = 2919680;
  do
  {
    *(_DWORD *)(result + v1[2]) = v4 >> 16;
    *(_DWORD *)(result + v1[3]) = v3 >> 16;
    *(_DWORD *)(result + v1[4]) = v6;
    *(_DWORD *)(result + v1[5]) = v5;
    v5 -= 22554;
    v4 += 91881;
    v3 += 116130;
    result += 4;
    v6 -= 46802;
  }
  while ( v5 >= -2831590 );
  return result;
}

// sub_10042590 @ 0x10042590
unsigned __int8 *__cdecl sub_10042590(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned __int8 *result; // eax
  _DWORD *v9; // esi
  int v10; // edi
  int v11; // ebp
  int v12; // ecx
  int v13; // esi
  int v14; // ebp
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // [esp+0h] [ebp-20h]
  int v19; // [esp+4h] [ebp-1Ch]
  int v20; // [esp+8h] [ebp-18h]
  int v21; // [esp+Ch] [ebp-14h]
  int v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+18h] [ebp-8h]
  int v25; // [esp+1Ch] [ebp-4h]
  int v26; // [esp+24h] [ebp+4h]
  int v27; // [esp+24h] [ebp+4h]
  int v28; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[104];
  v18 = a1[23];
  v6 = a1[71];
  v20 = v5[2];
  v24 = v5[3];
  v7 = v5[4];
  v21 = v5[5];
  result = (unsigned __int8 *)(a5 - 1);
  v23 = v6;
  v22 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = a2;
    v10 = 4 * a3;
    do
    {
      v11 = *(_DWORD *)(*v9 + v10);
      result = *(unsigned __int8 **)(v10 + v9[1]);
      v26 = *(_DWORD *)(v9[2] + v10);
      v12 = *a4++;
      v10 += 4;
      v25 = v10;
      if ( v18 )
      {
        v13 = v11 - (_DWORD)result;
        v14 = v26 - (_DWORD)result;
        v28 = v13;
        v19 = v26 - (_DWORD)result;
        v27 = v18;
        while ( 1 )
        {
          v12 += 3;
          v15 = result[v13];
          v16 = *result;
          v17 = result[v14];
          *(_BYTE *)(v12 - 3) = *(_BYTE *)(v15 + *(_DWORD *)(v20 + 4 * v17) + v6);
          v6 = v23;
          *(_BYTE *)(v12 - 2) = *(_BYTE *)(v15 + ((*(_DWORD *)(v22 + 4 * v17) + *(_DWORD *)(v21 + 4 * v16)) >> 16) + v23);
          *(_BYTE *)(v12 - 1) = *(_BYTE *)(v15 + *(_DWORD *)(v24 + 4 * v16) + v23);
          ++result;
          if ( !--v27 )
            break;
          v13 = v28;
          v14 = v19;
        }
        v9 = a2;
        v10 = v25;
      }
      --a5;
    }
    while ( a5 );
  }
  return result;
}

// sub_100426C0 @ 0x100426C0
int __cdecl sub_100426C0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5)
{
  int v5; // edx
  int v6; // edi
  int result; // eax
  int v8; // esi
  _DWORD *v9; // ebp
  _BYTE *v10; // ecx
  _BYTE *v11; // eax
  bool v12; // zf
  int v13; // [esp+4h] [ebp-4h]
  int v14; // [esp+Ch] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 32);
  v6 = *(_DWORD *)(a1 + 92);
  result = a5 - 1;
  v13 = v6;
  if ( a5 - 1 >= 0 )
  {
    v14 = 4 * a3;
    do
    {
      v8 = 0;
      if ( v5 > 0 )
      {
        v9 = a2;
        do
        {
          v10 = *(_BYTE **)(*v9 + v14);
          v11 = (_BYTE *)(v8 + *a4);
          if ( v6 )
          {
            do
            {
              *v11 = *v10++;
              v11 += v5;
              --v6;
            }
            while ( v6 );
            v6 = v13;
          }
          ++v8;
          ++v9;
        }
        while ( v8 < v5 );
      }
      result = a5 - 1;
      v12 = a5 == 1;
      v14 += 4;
      ++a4;
      --a5;
    }
    while ( !v12 );
  }
  return result;
}

// sub_10042750 @ 0x10042750
const void **__cdecl sub_10042750(int a1, int *a2, int a3, int a4, int a5)
{
  return sub_1003E490(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 92));
}

// sub_10042780 @ 0x10042780
unsigned __int8 *__cdecl sub_10042780(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned __int8 *result; // eax
  _DWORD *v9; // edi
  int v10; // esi
  int v11; // ebp
  int v12; // ecx
  int v13; // esi
  int v14; // ebp
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // [esp+0h] [ebp-24h]
  int v19; // [esp+4h] [ebp-20h]
  int v20; // [esp+8h] [ebp-1Ch]
  int v21; // [esp+Ch] [ebp-18h]
  int v22; // [esp+10h] [ebp-14h]
  int v23; // [esp+14h] [ebp-10h]
  int v24; // [esp+18h] [ebp-Ch]
  int v25; // [esp+1Ch] [ebp-8h]
  int v26; // [esp+20h] [ebp-4h]
  int v27; // [esp+28h] [ebp+4h]
  int v28; // [esp+28h] [ebp+4h]
  int v29; // [esp+30h] [ebp+Ch]
  int v30; // [esp+30h] [ebp+Ch]

  v5 = (_DWORD *)a1[104];
  v18 = a1[23];
  v6 = a1[71];
  v21 = v5[2];
  v25 = v5[3];
  v7 = v5[4];
  v22 = v5[5];
  result = (unsigned __int8 *)(a5 - 1);
  v24 = v6;
  v23 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = a2;
    v10 = 4 * a3;
    do
    {
      v11 = *(_DWORD *)(*v9 + v10);
      result = *(unsigned __int8 **)(v10 + v9[1]);
      v27 = *(_DWORD *)(v9[2] + v10);
      v29 = *(_DWORD *)(v10 + v9[3]);
      v12 = *a4++;
      v10 += 4;
      v26 = v10;
      if ( v18 )
      {
        v13 = v11 - (_DWORD)result;
        v14 = v27 - (_DWORD)result;
        v19 = v13;
        v20 = v27 - (_DWORD)result;
        v30 = v29 - (_DWORD)result;
        v28 = v18;
        while ( 1 )
        {
          v12 += 4;
          v15 = result[v13];
          v16 = *result;
          v17 = result[v14];
          *(_BYTE *)(v12 - 4) = *(_BYTE *)(v6 - *(_DWORD *)(v21 + 4 * v17) - v15 + 255);
          v6 = v24;
          *(_BYTE *)(v12 - 3) = *(_BYTE *)(v24
                                         - ((*(_DWORD *)(v23 + 4 * v17) + *(_DWORD *)(v22 + 4 * v16)) >> 16)
                                         - v15
                                         + 255);
          *(_BYTE *)(v12 - 2) = *(_BYTE *)(v24 - *(_DWORD *)(v25 + 4 * v16) - v15 + 255);
          *(_BYTE *)(v12 - 1) = (result++)[v30];
          if ( !--v28 )
            break;
          v13 = v19;
          v14 = v20;
        }
        v9 = a2;
        v10 = v26;
      }
      --a5;
    }
    while ( a5 );
  }
  return result;
}

// sub_100428E0 @ 0x100428E0
int __cdecl sub_100428E0(int a1)
{
  int v1; // esi
  int v2; // ecx
  _DWORD *v3; // esi
  int result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // [esp+14h] [ebp+4h]

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 412) = v1;
  *(_DWORD *)v1 = sub_10042A10;
  *(_BYTE *)(v1 + 8) = 0;
  v2 = *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100);
  *(_DWORD *)(v1 + 40) = v2;
  if ( *(_DWORD *)(a1 + 272) == 2 )
  {
    *(_DWORD *)(v1 + 4) = sub_10042A30;
    *(_DWORD *)(v1 + 12) = sub_10042C90;
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v2);
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_10042B00;
    *(_DWORD *)(v1 + 12) = sub_10042B40;
    *(_DWORD *)(v1 + 32) = 0;
  }
  v3 = *(_DWORD **)(a1 + 412);
  v3[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[6] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[7] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v8 = 5990656;
  v5 = -14831872;
  v6 = -11728000;
  v7 = 2919680;
  do
  {
    *(_DWORD *)(result + v3[4]) = v6 >> 16;
    *(_DWORD *)(result + v3[5]) = v5 >> 16;
    *(_DWORD *)(result + v3[6]) = v8;
    *(_DWORD *)(result + v3[7]) = v7;
    v7 -= 22554;
    v6 += 91881;
    v5 += 116130;
    result += 4;
    v8 -= 46802;
  }
  while ( v7 >= -2831590 );
  return result;
}

// sub_10042A10 @ 0x10042A10
int __cdecl sub_10042A10(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 412);
  *(_BYTE *)(result + 36) = 0;
  *(_DWORD *)(result + 44) = *(_DWORD *)(a1 + 96);
  return result;
}

// sub_10042A30 @ 0x10042A30
char __cdecl sub_10042A30(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebp
  int v8; // esi
  _DWORD *v9; // ebx
  unsigned int v10; // edi
  int v11; // eax
  char result; // al
  int v13; // [esp+10h] [ebp-8h] BYREF
  int v14; // [esp+14h] [ebp-4h]

  v7 = a3;
  v8 = *(_DWORD *)(a1 + 412);
  if ( *(_BYTE *)(v8 + 36) )
  {
    v9 = a6;
    sub_1003E490(v8 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v8 + 40));
    v10 = 1;
    *(_BYTE *)(v8 + 36) = 0;
  }
  else
  {
    v10 = 2;
    if ( *(_DWORD *)(v8 + 44) < 2u )
      v10 = *(_DWORD *)(v8 + 44);
    v9 = a6;
    v11 = *a6;
    if ( v10 > a7 - *a6 )
      v10 = a7 - *a6;
    v13 = *(_DWORD *)(a5 + 4 * v11);
    if ( v10 <= 1 )
    {
      v14 = *(_DWORD *)(v8 + 32);
      *(_BYTE *)(v8 + 36) = 1;
    }
    else
    {
      v14 = *(_DWORD *)(a5 + 4 * v11 + 4);
    }
    v7 = a3;
    (*(void (__cdecl **)(int, int, _DWORD, int *))(v8 + 12))(a1, a2, *a3, &v13);
  }
  *v9 += v10;
  result = *(_BYTE *)(v8 + 36);
  *(_DWORD *)(v8 + 44) -= v10;
  if ( !result )
    ++*v7;
  return result;
}

// sub_10042B00 @ 0x10042B00
int __cdecl sub_10042B00(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax

  result = (*(int (__cdecl **)(int, int, _DWORD, int))(*(_DWORD *)(a1 + 412) + 12))(a1, a2, *a3, a5 + 4 * *a6);
  ++*a6;
  ++*a3;
  return result;
}

// sub_10042B40 @ 0x10042B40
_BYTE *__cdecl sub_10042B40(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4)
{
  _DWORD *v4; // ebp
  _DWORD *v5; // eax
  int v6; // ecx
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // esi
  _BYTE *result; // eax
  int v11; // ebp
  int v12; // edx
  int v13; // esi
  int v14; // edx
  int v15; // ebx
  unsigned __int8 *v16; // edi
  int v17; // ebx
  int v18; // ebp
  int v19; // ebp
  int v20; // esi
  int v21; // edx
  int v22; // ebp
  int v23; // esi
  int v24; // edi
  unsigned __int8 *v25; // [esp+10h] [ebp-14h]
  int v26; // [esp+14h] [ebp-10h]
  int v27; // [esp+18h] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-8h]
  int v29; // [esp+20h] [ebp-4h]
  int v30; // [esp+2Ch] [ebp+8h]
  int v31; // [esp+30h] [ebp+Ch]
  unsigned __int8 *v32; // [esp+34h] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[103];
  v6 = a1[71];
  v29 = v5[4];
  v28 = v5[5];
  v27 = v5[6];
  v26 = v5[7];
  v7 = *(unsigned __int8 **)(*a2 + 4 * a3);
  v8 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  v9 = *(unsigned __int8 **)(a2[1] + 4 * a3);
  result = *a4;
  if ( a1[23] >> 1 )
  {
    v30 = a1[23] >> 1;
    do
    {
      v25 = v9 + 1;
      result += 6;
      v11 = *v9;
      v12 = *v8;
      v32 = v8 + 1;
      v31 = *(_DWORD *)(v29 + 4 * v12);
      v13 = *(_DWORD *)(v27 + 4 * v12) + *(_DWORD *)(v26 + 4 * v11);
      v14 = *(_DWORD *)(v28 + 4 * v11);
      v15 = *v7;
      v13 >>= 16;
      v16 = v7 + 1;
      *(result - 6) = *(_BYTE *)(v15 + v31 + v6);
      *(result - 5) = *(_BYTE *)(v13 + v15 + v6);
      *(result - 4) = *(_BYTE *)(v6 + v14 + v15);
      v17 = *v16;
      v7 = v16 + 1;
      v18 = v17;
      *(result - 3) = *(_BYTE *)(v17 + v31 + v6);
      LOBYTE(v17) = *(_BYTE *)(v17 + v13 + v6);
      v9 = v25;
      *(result - 2) = v17;
      v8 = v32;
      *(result - 1) = *(_BYTE *)(v6 + v14 + v18);
      --v30;
    }
    while ( v30 );
    v4 = a1;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v19 = *v9;
    v20 = *(_DWORD *)(v26 + 4 * v19);
    v21 = *v8;
    v22 = *(_DWORD *)(v28 + 4 * v19);
    v23 = (*(_DWORD *)(v27 + 4 * v21) + v20) >> 16;
    v24 = *v7;
    *result = *(_BYTE *)(v24 + *(_DWORD *)(v29 + 4 * v21) + v6);
    result[1] = *(_BYTE *)(v24 + v23 + v6);
    result[2] = *(_BYTE *)(v22 + v24 + v6);
  }
  return result;
}

// sub_10042C90 @ 0x10042C90
char __cdecl sub_10042C90(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  _DWORD *v5; // ecx
  int v6; // eax
  unsigned __int8 **v8; // esi
  unsigned __int8 *v9; // edi
  int v10; // esi
  unsigned __int8 *v11; // ebp
  unsigned __int8 *v12; // edi
  _BYTE *v13; // ecx
  _BYTE *v14; // esi
  int v15; // ebx
  int v16; // edx
  int v17; // ebp
  int v18; // edi
  int v19; // edx
  _BYTE *v20; // esi
  int v21; // edx
  int v22; // edx
  int v23; // edx
  int v24; // ebx
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // ebp
  int v29; // ecx
  int v31; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v32; // [esp+14h] [ebp-18h]
  unsigned __int8 *v33; // [esp+18h] [ebp-14h]
  int v34; // [esp+1Ch] [ebp-10h]
  int v35; // [esp+20h] [ebp-Ch]
  int v36; // [esp+24h] [ebp-8h]
  int v37; // [esp+28h] [ebp-4h]
  int v38; // [esp+30h] [ebp+4h]
  unsigned __int8 *v39; // [esp+34h] [ebp+8h]
  unsigned __int8 *v40; // [esp+38h] [ebp+Ch]
  int v41; // [esp+3Ch] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[103];
  v34 = v5[4];
  v6 = a1[71];
  v37 = v5[5];
  v35 = v5[7];
  v36 = v5[6];
  v8 = (unsigned __int8 **)(*a2 + 8 * a3);
  v9 = *v8;
  v40 = v8[1];
  v10 = a2[1];
  v11 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  v39 = v9;
  v12 = *(unsigned __int8 **)(v10 + 4 * a3);
  v13 = *(_BYTE **)a4;
  v14 = *(_BYTE **)(a4 + 4);
  if ( a1[23] >> 1 )
  {
    v31 = a1[23] >> 1;
    while ( 1 )
    {
      v15 = *v12;
      v16 = *v11;
      v32 = v12 + 1;
      v33 = v11 + 1;
      v17 = *(_DWORD *)(v34 + 4 * v16);
      v18 = *(_DWORD *)(v36 + 4 * v16) + *(_DWORD *)(v35 + 4 * v15);
      v41 = *(_DWORD *)(v37 + 4 * v15);
      v19 = *v39;
      v18 >>= 16;
      v13 += 6;
      v20 = v14 + 3;
      *(v13 - 6) = *(_BYTE *)(v19 + v17 + v6);
      *(v13 - 5) = *(_BYTE *)(v19 + v18 + v6);
      *(v13 - 4) = *(_BYTE *)(v41 + v19 + v6);
      v21 = v39[1];
      v39 += 2;
      *(v13 - 3) = *(_BYTE *)(v21 + v17 + v6);
      *(v13 - 2) = *(_BYTE *)(v21 + v18 + v6);
      *(v13 - 1) = *(_BYTE *)(v41 + v21 + v6);
      v22 = *v40;
      *(v20 - 3) = *(_BYTE *)(v22 + v17 + v6);
      *(v20 - 2) = *(_BYTE *)(v22 + v18 + v6);
      *(v20 - 1) = *(_BYTE *)(v41 + v22 + v6);
      v23 = v40[1];
      v40 += 2;
      *v20 = *(_BYTE *)(v23 + v17 + v6);
      v20[1] = *(_BYTE *)(v23 + v18 + v6);
      v20[2] = *(_BYTE *)(v41 + v23 + v6);
      v14 = v20 + 3;
      if ( !--v31 )
        break;
      v12 = v32;
      v11 = v33;
    }
    v4 = a1;
    v12 = v32;
    v11 = v33;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v24 = *v11;
    v25 = *v12;
    v38 = *(_DWORD *)(v34 + 4 * v24);
    v26 = *(_DWORD *)(v36 + 4 * v24) + *(_DWORD *)(v35 + 4 * v25);
    v27 = *(_DWORD *)(v37 + 4 * v25);
    v26 >>= 16;
    v28 = *v39;
    *v13 = *(_BYTE *)(v28 + v38 + v6);
    v13[1] = *(_BYTE *)(v26 + v28 + v6);
    v13[2] = *(_BYTE *)(v6 + v27 + v28);
    v29 = *v40;
    *v14 = *(_BYTE *)(v29 + v38 + v6);
    v14[1] = *(_BYTE *)(v29 + v26 + v6);
    LOBYTE(v6) = *(_BYTE *)(v27 + v29 + v6);
    v14[2] = v6;
  }
  return v6;
}

// sub_10042EA0 @ 0x10042EA0
int __cdecl sub_10042EA0(int a1)
{
  int v1; // edi
  int i; // ebp
  int v3; // ebp
  int result; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 420) = v1;
  *(_DWORD *)v1 = sub_10043070;
  *(_DWORD *)(v1 + 12) = sub_10044200;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v1 + 24) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  for ( i = 0; i < 128; i += 4 )
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + i) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 4096);
  *(_BYTE *)(v1 + 28) = 1;
  if ( *(_BYTE *)(a1 + 90) )
  {
    v3 = *(_DWORD *)(a1 + 84);
    if ( v3 < 8 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 55;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( v3 > 256 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(v1 + 16) = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, v3, 3);
    *(_DWORD *)(v1 + 20) = v3;
  }
  else
  {
    *(_DWORD *)(v1 + 16) = 0;
  }
  result = *(_DWORD *)(a1 + 76);
  if ( result )
    *(_DWORD *)(a1 + 76) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                             a1,
                             1,
                             6 * (*(_DWORD *)(a1 + 92) + 2));
    return sub_10042FD0(a1);
  }
  return result;
}

// sub_10042FD0 @ 0x10042FD0
_DWORD *__cdecl sub_10042FD0(int a1)
{
  int v1; // esi
  _DWORD *result; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // ebx
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  int v8; // edx
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // edi
  int v12; // esi

  v1 = *(_DWORD *)(a1 + 420);
  result = (_DWORD *)((**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020);
  v3 = 16;
  *(_DWORD *)(v1 + 40) = result;
  v4 = 0;
  v5 = 0;
  v6 = result;
  v7 = result;
  v8 = 16;
  do
  {
    *v6 = v4;
    *v7 = v5;
    ++v6;
    --v7;
    ++v4;
    --v5;
    --v3;
  }
  while ( v3 );
  v9 = result + 16;
  v10 = result - 16;
  do
  {
    *v9 = v4;
    *v10 = -v4;
    ++v8;
    ++v9;
    --v10;
    v4 += (v8 & 1) == 0;
  }
  while ( v8 < 48 );
  if ( v8 <= 255 )
  {
    v11 = &result[v8];
    result -= v8;
    v12 = 256 - v8;
    do
    {
      *v11 = v4;
      *result = -v4;
      ++v11;
      --result;
      --v12;
    }
    while ( v12 );
  }
  return result;
}

// sub_10043070 @ 0x10043070
char __cdecl sub_10043070(_DWORD *a1, char a2)
{
  int v3; // edi
  int v4; // ebp
  unsigned int v5; // ebp
  char result; // al
  void **v7; // esi
  int v8; // ebp
  void **v9; // [esp+10h] [ebp+4h]

  v3 = a1[105];
  v9 = *(void ***)(v3 + 24);
  if ( a1[19] )
    a1[19] = 2;
  if ( a2 )
  {
    *(_DWORD *)(v3 + 4) = sub_10043190;
    *(_DWORD *)(v3 + 8) = sub_10043A20;
    *(_BYTE *)(v3 + 28) = 1;
  }
  else
  {
    if ( a1[19] == 2 )
      *(_DWORD *)(v3 + 4) = sub_10043740;
    else
      *(_DWORD *)(v3 + 4) = sub_10043210;
    *(_DWORD *)(v3 + 8) = nullsub_4;
    v4 = a1[28];
    if ( v4 < 1 )
    {
      *(_DWORD *)(*a1 + 20) = 55;
      *(_DWORD *)(*a1 + 24) = 1;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( v4 > 256 )
    {
      *(_DWORD *)(*a1 + 20) = 56;
      *(_DWORD *)(*a1 + 24) = 256;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( a1[19] == 2 )
    {
      v5 = 6 * (a1[23] + 2);
      if ( !*(_DWORD *)(v3 + 32) )
        *(_DWORD *)(v3 + 32) = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, 6 * (a1[23] + 2));
      sub_1003E510(*(void **)(v3 + 32), v5);
      if ( !*(_DWORD *)(v3 + 40) )
        sub_10042FD0((int)a1);
      *(_BYTE *)(v3 + 36) = 0;
    }
  }
  result = *(_BYTE *)(v3 + 28);
  if ( result )
  {
    v7 = v9;
    v8 = 32;
    do
    {
      result = sub_1003E510(*v7++, 0x1000u);
      --v8;
    }
    while ( v8 );
    *(_BYTE *)(v3 + 28) = 0;
  }
  return result;
}

// sub_10043190 @ 0x10043190
int __cdecl sub_10043190(int a1, unsigned __int8 **a2, int a3, int a4)
{
  int v4; // ebp
  int result; // eax
  int v6; // esi
  unsigned __int8 *v8; // ecx
  int v9; // edi
  int v10; // edx
  int v11; // eax
  _WORD *v12; // eax
  int v13; // [esp+Ch] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 92);
  result = a4;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  if ( a4 > 0 )
  {
    v13 = a4;
    do
    {
      v8 = *a2;
      if ( v4 )
      {
        v9 = v4;
        do
        {
          v10 = (v8[2] >> 3) + 32 * (v8[1] >> 2);
          v11 = *(_DWORD *)(v6 + 4 * (*v8 >> 3));
          ++*(_WORD *)(v11 + 2 * v10);
          v12 = (_WORD *)(v11 + 2 * v10);
          if ( !*v12 )
            *v12 = -1;
          v8 += 3;
          --v9;
        }
        while ( v9 );
      }
      ++a2;
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

// sub_10043210 @ 0x10043210
_DWORD *__cdecl sub_10043210(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax
  int v5; // edx
  int v6; // ecx
  unsigned __int8 *v7; // esi
  _BYTE *v8; // ebp
  unsigned int v9; // ecx
  int v10; // eax
  unsigned __int8 *v11; // esi
  unsigned int v12; // ecx
  int v13; // edx
  _WORD *v14; // edi
  bool v15; // zf
  int v16; // [esp+4h] [ebp-Ch]
  int v17; // [esp+8h] [ebp-8h]
  int v18; // [esp+Ch] [ebp-4h]
  int v19; // [esp+18h] [ebp+8h]
  int v20; // [esp+20h] [ebp+10h]

  result = a1;
  v16 = *(_DWORD *)(a1[105] + 24);
  v5 = a1[23];
  v17 = v5;
  if ( a4 > 0 )
  {
    result = a3;
    v6 = a2 - (_DWORD)a3;
    v18 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      v7 = *(unsigned __int8 **)((char *)result + v6);
      v8 = (_BYTE *)*result;
      if ( v5 )
      {
        v20 = v5;
        do
        {
          v9 = v7[1];
          v10 = *v7 >> 3;
          v11 = v7 + 1;
          v12 = v9 >> 2;
          v13 = v11[1] >> 3;
          v14 = (_WORD *)(*(_DWORD *)(v16 + 4 * v10) + 2 * (v13 + 32 * v12));
          v7 = v11 + 2;
          if ( !*v14 )
            sub_100432E0(a1, v10, v12, v13);
          *v8++ = *(_BYTE *)v14 - 1;
          --v20;
        }
        while ( v20 );
        v5 = v17;
        result = a3;
        v6 = v18;
      }
      ++result;
      v15 = v19 == 1;
      a3 = result;
      --v19;
    }
    while ( !v15 );
  }
  return result;
}

// sub_100432E0 @ 0x100432E0
int __cdecl sub_100432E0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // edx
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int *v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // ebx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // ebx
  int v23; // eax
  bool v24; // cc
  unsigned __int8 *v25; // edx
  _DWORD *v26; // ebx
  int v27; // ecx
  int v28; // edi
  int v29; // eax
  int v30; // esi
  int result; // eax
  int v32; // [esp+10h] [ebp-5B0h]
  int v33; // [esp+10h] [ebp-5B0h]
  int v34; // [esp+14h] [ebp-5ACh]
  int v35; // [esp+14h] [ebp-5ACh]
  int *v36; // [esp+18h] [ebp-5A8h]
  int *v37; // [esp+18h] [ebp-5A8h]
  int v38; // [esp+1Ch] [ebp-5A4h]
  int v39; // [esp+1Ch] [ebp-5A4h]
  int v40; // [esp+24h] [ebp-59Ch]
  int v41; // [esp+28h] [ebp-598h]
  int v42; // [esp+2Ch] [ebp-594h]
  int v43; // [esp+30h] [ebp-590h]
  int v44; // [esp+34h] [ebp-58Ch]
  int v45; // [esp+3Ch] [ebp-584h]
  _BYTE v46[128]; // [esp+40h] [ebp-580h] BYREF
  _BYTE v47[256]; // [esp+C0h] [ebp-500h] BYREF
  _BYTE v48[1024]; // [esp+1C0h] [ebp-400h] BYREF
  int v49; // [esp+5C8h] [ebp+8h]
  int v50; // [esp+5CCh] [ebp+Ch]
  int v51; // [esp+5CCh] [ebp+Ch]
  int v52; // [esp+5D0h] [ebp+10h]
  int v53; // [esp+5D0h] [ebp+10h]

  v50 = a3 >> 3;
  v4 = a2 >> 2;
  v5 = 32 * v50 + 2;
  v43 = *(_DWORD *)(a1[105] + 24);
  v6 = a1[28];
  v52 = a4 >> 2;
  v7 = 32 * v52 + 4;
  v8 = 32 * (a2 >> 2) + 4;
  v9 = (2 * v8 + 24) >> 1;
  v49 = a2 >> 2;
  v34 = v7;
  v41 = v6;
  v40 = (2 * v7 + 24) >> 1;
  v38 = 0x7FFFFFFF;
  v32 = 0;
  if ( v6 > 0 )
  {
    v36 = (int *)v48;
    v10 = (int *)a1[29];
    v45 = *v10;
    v42 = v10[1];
    v44 = v10[2];
    while ( 1 )
    {
      v11 = *(unsigned __int8 *)(v45 + v32);
      if ( v11 < v8 )
      {
        v12 = 2 * (v11 - v8) * 2 * (v11 - v8);
        v13 = v11 - (v8 + 24);
        goto LABEL_9;
      }
      v14 = v8 + 24;
      if ( v11 > v8 + 24 )
        break;
      v12 = 0;
      if ( v11 > v9 )
        goto LABEL_8;
      v13 = v11 - v14;
LABEL_9:
      v15 = *(unsigned __int8 *)(v42 + v32);
      v16 = 2 * v13 * 2 * v13;
      if ( v15 < v5 )
      {
        v12 += 3 * (v15 - v5) * 3 * (v15 - v5);
        v17 = v15 - (32 * v50 + 30);
        goto LABEL_16;
      }
      v18 = 32 * v50 + 30;
      if ( v15 > v18 )
      {
        v12 += 3 * (v15 - v18) * 3 * (v15 - v18);
LABEL_15:
        v17 = v15 - v5;
        goto LABEL_16;
      }
      if ( v15 > (2 * v5 + 28) >> 1 )
        goto LABEL_15;
      v17 = v15 - v18;
LABEL_16:
      v19 = 3 * v17 * 3 * v17 + v16;
      v20 = *(unsigned __int8 *)(v44 + v32);
      v7 = 32 * v52 + 4;
      if ( v20 < v34 )
      {
        v12 += (v20 - v34) * (v20 - v34);
        v7 = 32 * v52 + 4;
        v21 = v20 - (32 * v52 + 28);
        goto LABEL_23;
      }
      v22 = 32 * v52 + 28;
      if ( v20 > v22 )
      {
        v7 = 32 * v52 + 4;
        v12 += (v20 - v22) * (v20 - v22);
LABEL_22:
        v21 = v20 - v7;
        goto LABEL_23;
      }
      if ( v20 > v40 )
        goto LABEL_22;
      v21 = v20 - v22;
LABEL_23:
      *v36 = v12;
      v23 = v21 * v21 + v19;
      if ( v23 < v38 )
        v38 = v23;
      ++v36;
      v6 = v41;
      if ( ++v32 >= v41 )
      {
        v4 = v49;
        goto LABEL_27;
      }
      v9 = (2 * v8 + 24) >> 1;
    }
    v12 = 2 * (v11 - v14) * 2 * (v11 - v14);
LABEL_8:
    v13 = v11 - v8;
    goto LABEL_9;
  }
LABEL_27:
  v35 = 0;
  v33 = 0;
  if ( v6 > 0 )
  {
    v37 = (int *)v48;
    do
    {
      if ( *v37 <= v38 )
        v47[v35++] = v33;
      v24 = ++v33 < v6;
      ++v37;
    }
    while ( v24 );
  }
  sub_100435E0(a1, v8, v5, v7, v35, v47, v46);
  v53 = 4 * v52;
  v51 = 8 * v50;
  v25 = v46;
  v26 = (_DWORD *)(v43 + 16 * v4);
  v39 = 4;
  do
  {
    v27 = 2 * (v53 + 32 * v51);
    v28 = 8;
    do
    {
      v29 = v27 + *v26;
      v30 = 4;
      do
      {
        v29 += 2;
        *(_WORD *)(v29 - 2) = *v25++ + 1;
        --v30;
      }
      while ( v30 );
      v27 += 64;
      --v28;
    }
    while ( v28 );
    ++v26;
    result = --v39;
  }
  while ( v39 );
  return result;
}

// sub_100435E0 @ 0x100435E0
int __cdecl sub_100435E0(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7)
{
  int result; // eax
  int v8; // edx
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  int v12; // ebp
  int v13; // ecx
  int v14; // edi
  _BYTE *v15; // ebx
  int *v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // ebp
  bool v20; // zf
  int v21; // [esp+4h] [ebp-220h]
  int v22; // [esp+8h] [ebp-21Ch]
  int i; // [esp+Ch] [ebp-218h]
  int v24; // [esp+10h] [ebp-214h]
  int v25; // [esp+14h] [ebp-210h]
  int v26; // [esp+18h] [ebp-20Ch]
  int v27; // [esp+1Ch] [ebp-208h]
  int v28; // [esp+20h] [ebp-204h]
  _DWORD v29[128]; // [esp+24h] [ebp-200h] BYREF

  memset32(v29, 0x7FFFFFFF, 0x80u);
  result = 0;
  for ( i = 0; i < a5; ++i )
  {
    v8 = *(unsigned __int8 *)(result + a6);
    v9 = *(_DWORD **)(a1 + 116);
    v21 = 4;
    v10 = 2 * (a2 - *(unsigned __int8 *)(v8 + *v9));
    v11 = 3 * (a3 - *(unsigned __int8 *)(v9[1] + v8));
    v12 = 8 * (9 * (a3 - *(unsigned __int8 *)(v9[1] + v8)) + 18);
    v27 = v12;
    v13 = a4 - *(unsigned __int8 *)(v9[2] + v8);
    v14 = v10 * v10 + v11 * v11 + v13 * v13;
    v15 = a7;
    v28 = 16 * (v13 + 4);
    v16 = v29;
    v26 = 32 * (v10 + 8);
    while ( 1 )
    {
      v17 = v14;
      v22 = v14;
      v25 = v12;
      v24 = 8;
      do
      {
        v18 = v28;
        v19 = 4;
        do
        {
          if ( v17 < *v16 )
          {
            *v16 = v17;
            *v15 = v8;
          }
          v17 += v18;
          v18 += 128;
          ++v16;
          ++v15;
          --v19;
        }
        while ( v19 );
        v17 = v25 + v22;
        v25 += 288;
        v20 = v24 == 1;
        v22 = v17;
        --v24;
      }
      while ( !v20 );
      v14 += v26;
      v26 += 512;
      if ( !--v21 )
        break;
      v12 = v27;
    }
    result = i + 1;
  }
  return result;
}

// sub_10043740 @ 0x10043740
int __cdecl sub_10043740(_DWORD *a1, int a2, _BYTE **a3, int a4)
{
  int v4; // esi
  int v5; // ecx
  int *v6; // eax
  int result; // eax
  _BYTE **v8; // ebx
  int v9; // ebp
  unsigned __int8 *v10; // eax
  _WORD *v11; // ebx
  int v12; // esi
  int v13; // ebp
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // ecx
  int v19; // edx
  bool v20; // zf
  unsigned __int16 *v21; // ecx
  int v22; // eax
  int v23; // edi
  int v24; // ecx
  int v25; // ebp
  int v26; // eax
  int v27; // edi
  int v28; // eax
  int v29; // ebp
  __int16 v30; // dx
  int v31; // [esp+4h] [ebp-58h]
  __int16 v32; // [esp+8h] [ebp-54h]
  __int16 v33; // [esp+Ch] [ebp-50h]
  __int16 v34; // [esp+10h] [ebp-4Ch]
  int v35; // [esp+14h] [ebp-48h]
  __int16 v36; // [esp+18h] [ebp-44h]
  __int16 v37; // [esp+1Ch] [ebp-40h]
  __int16 v38; // [esp+20h] [ebp-3Ch]
  int v39; // [esp+24h] [ebp-38h]
  int v40; // [esp+28h] [ebp-34h]
  int v41; // [esp+2Ch] [ebp-30h]
  _BYTE **v42; // [esp+30h] [ebp-2Ch]
  int v43; // [esp+34h] [ebp-28h]
  int v44; // [esp+38h] [ebp-24h]
  int v45; // [esp+3Ch] [ebp-20h]
  unsigned __int16 *v46; // [esp+48h] [ebp-14h]
  int v47; // [esp+4Ch] [ebp-10h]
  int v48; // [esp+50h] [ebp-Ch]
  int v49; // [esp+54h] [ebp-8h]
  int v50; // [esp+58h] [ebp-4h]
  _BYTE *v51; // [esp+64h] [ebp+8h]
  int v52; // [esp+68h] [ebp+Ch]
  int v53; // [esp+6Ch] [ebp+10h]

  v4 = a1[105];
  v35 = a1[71];
  v45 = *(_DWORD *)(v4 + 24);
  v5 = a1[23];
  v6 = (int *)a1[29];
  v31 = *(_DWORD *)(v4 + 40);
  v47 = *v6;
  v48 = v6[1];
  v49 = v6[2];
  result = a4;
  v41 = v4;
  v50 = v5;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v42 = a3;
    v44 = a2 - (_DWORD)a3;
    v43 = a4;
    while ( 1 )
    {
      v10 = *(_BYTE **)((char *)v8 + v9);
      v52 = (int)v10;
      v51 = *v8;
      if ( *(_BYTE *)(v4 + 36) )
      {
        v52 = (int)&v10[2 * v5 - 3 + v5];
        v51 = &(*v8)[v5 - 1];
        v11 = (_WORD *)(*(_DWORD *)(v4 + 32) + 2 * (3 * v5 + 3));
        v10 = (unsigned __int8 *)v52;
        v39 = -1;
        v53 = -3;
        *(_BYTE *)(v4 + 36) = 0;
      }
      else
      {
        v11 = *(_WORD **)(v4 + 32);
        v39 = 1;
        v53 = 3;
        *(_BYTE *)(v4 + 36) = 1;
      }
      v12 = 0;
      v38 = 0;
      v37 = 0;
      v36 = 0;
      v13 = 0;
      v14 = 0;
      v34 = 0;
      v33 = 0;
      v32 = 0;
      if ( v5 )
      {
        v40 = v5;
        while ( 1 )
        {
          v15 = *(unsigned __int8 *)(*v10 + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53] + v12 + 8) >> 4)) + v35);
          v16 = *(unsigned __int8 *)(v10[1] + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53 + 1] + v14 + 8) >> 4)) + v35);
          v17 = *(unsigned __int8 *)(v10[2] + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53 + 2] + v13 + 8) >> 4)) + v35);
          v18 = (v17 >> 3) + 32 * (v16 >> 2);
          v19 = *(_DWORD *)(v45 + 4 * (v15 >> 3));
          v20 = *(_WORD *)(v19 + 2 * v18) == 0;
          v21 = (unsigned __int16 *)(v19 + 2 * v18);
          v46 = v21;
          if ( v20 )
          {
            sub_100432E0(a1, v15 >> 3, v16 >> 2, v17 >> 3);
            v21 = v46;
          }
          v22 = *v21 - 1;
          *v51 = v22;
          v23 = v16 - *(unsigned __int8 *)(v22 + v48);
          v24 = v15 - *(unsigned __int8 *)(v22 + v47);
          v25 = v17 - *(unsigned __int8 *)(v22 + v49);
          *v11 = 3 * v24 + v32;
          v32 = 5 * v24 + v36;
          v12 = 7 * v24;
          v36 = v24;
          LOWORD(v24) = v23;
          v26 = 2 * v23;
          v23 *= 3;
          v11[1] = v23 + v33;
          v27 = v26 + v23;
          v33 = v27 + v37;
          v14 = v26 + v27;
          v37 = v24;
          LOWORD(v24) = v25;
          v28 = 2 * v25;
          v25 *= 3;
          v11[2] = v25 + v34;
          v29 = v28 + v25;
          v30 = v29 + v38;
          v38 = v24;
          v13 = v28 + v29;
          v34 = v30;
          v52 += v53;
          v11 += v53;
          v20 = v40 == 1;
          v51 += v39;
          --v40;
          if ( v20 )
            break;
          v10 = (unsigned __int8 *)v52;
        }
        v5 = v50;
        v4 = v41;
      }
      else
      {
        v4 = v41;
      }
      *v11 = v32;
      v11[1] = v33;
      v11[2] = v34;
      v8 = v42 + 1;
      result = v43 - 1;
      v20 = v43 == 1;
      ++v42;
      --v43;
      if ( v20 )
        break;
      v9 = v44;
    }
  }
  return result;
}

// sub_10043A20 @ 0x10043A20
int __cdecl sub_10043A20(_DWORD *a1)
{
  _DWORD *v1; // ebp
  int (__cdecl **v2)(_DWORD *, int, int); // ecx
  int v3; // edi
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // eax
  _DWORD *v7; // edi
  int v8; // esi
  int *v9; // ecx
  int *v10; // eax
  int v11; // esi
  int *v12; // eax
  int v13; // esi
  int v14; // ebp
  int v15; // ebp
  int v16; // eax
  int v17; // eax
  int v18; // eax
  bool v19; // cc
  int i; // esi
  int v21; // ecx
  int result; // eax
  int v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  int v25; // [esp+14h] [ebp-14h]
  int v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  int v28; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]

  v1 = a1;
  v2 = (int (__cdecl **)(_DWORD *, int, int))a1[1];
  v3 = a1[105];
  a1[29] = *(_DWORD *)(v3 + 16);
  v4 = *(_DWORD *)(v3 + 20);
  v28 = v3;
  v29 = v4;
  v5 = (_DWORD *)(*v2)(a1, 1, 32 * v4);
  v27 = v5;
  *v5 = 0;
  v5[1] = 31;
  v5[2] = 0;
  v5[3] = 63;
  v5[4] = 0;
  v5[5] = 31;
  sub_10043C40(a1, v5);
  v23 = 1;
  if ( v4 > 1 )
  {
    v6 = 2;
    v26 = 2;
    v7 = v5 + 11;
    do
    {
      if ( v6 > v4 )
      {
        v11 = 0;
        v9 = 0;
        if ( v6 > 0 )
        {
          v12 = v5 + 6;
          v25 = v23;
          do
          {
            if ( *v12 > v11 )
            {
              v9 = v12 - 6;
              v11 = *v12;
            }
            v12 += 8;
            --v25;
          }
          while ( v25 );
        }
      }
      else
      {
        v8 = 0;
        v9 = 0;
        if ( v6 > 0 )
        {
          v10 = v5 + 7;
          v24 = v23;
          do
          {
            if ( *v10 > v8 && *(v10 - 1) > 0 )
            {
              v9 = v10 - 7;
              v8 = *v10;
            }
            v10 += 8;
            --v24;
          }
          while ( v24 );
        }
      }
      if ( !v9 )
        break;
      *(v7 - 2) = v9[1];
      *v7 = v9[3];
      v7[2] = v9[5];
      *(v7 - 3) = *v9;
      *(v7 - 1) = v9[2];
      v7[1] = v9[4];
      v13 = 12 * (v9[3] - v9[2]);
      v14 = 1;
      if ( 16 * (v9[1] - *v9) > v13 )
      {
        v13 = 16 * (v9[1] - *v9);
        v14 = 0;
      }
      if ( 8 * (v9[5] - v9[4]) > v13 )
        v14 = 2;
      if ( v14 )
      {
        v15 = v14 - 1;
        if ( v15 )
        {
          if ( v15 == 1 )
          {
            v16 = (v9[5] + v9[4]) / 2;
            v9[5] = v16;
            v7[1] = v16 + 1;
          }
        }
        else
        {
          v17 = (v9[2] + v9[3]) / 2;
          v9[3] = v17;
          *(v7 - 1) = v17 + 1;
        }
      }
      else
      {
        v18 = (*v9 + v9[1]) / 2;
        v9[1] = v18;
        *(v7 - 3) = v18 + 1;
      }
      v1 = a1;
      sub_10043C40(a1, v9);
      sub_10043C40(a1, v7 - 3);
      v4 = v29;
      v5 = v27;
      v6 = v26 + 2;
      v7 += 8;
      v19 = ++v23 < v29;
      v26 += 2;
    }
    while ( v19 );
    v3 = v28;
  }
  for ( i = 0; i < v23; v5 += 8 )
    sub_10044070(v1, v5, i++);
  v21 = *v1;
  v1[28] = v23;
  *(_DWORD *)(v21 + 20) = 95;
  *(_DWORD *)(*v1 + 24) = v23;
  result = (*(int (__cdecl **)(_DWORD *, int))(*v1 + 4))(v1, 1);
  *(_BYTE *)(v3 + 28) = 1;
  return result;
}

// sub_10043C40 @ 0x10043C40
int __cdecl sub_10043C40(int a1, int *a2)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // edx
  int v7; // edi
  int v8; // edx
  _WORD *v9; // ecx
  int v10; // eax
  _DWORD *v12; // ecx
  int v13; // edx
  _WORD *v14; // ecx
  int v15; // eax
  bool v17; // cc
  int v18; // esi
  int v19; // edi
  _DWORD *v20; // edx
  int v21; // ecx
  _WORD *v22; // eax
  int v24; // esi
  int v25; // edi
  _DWORD *v26; // edx
  _WORD *v27; // eax
  int v28; // ecx
  int v30; // eax
  int v31; // edi
  int v32; // edx
  _DWORD *v33; // esi
  int v34; // ecx
  _WORD *v35; // eax
  int v36; // eax
  int v37; // edi
  int v38; // edx
  _DWORD *v39; // esi
  _WORD *v40; // eax
  int v41; // ecx
  int v42; // ebx
  int result; // eax
  int v44; // ebp
  int v45; // edx
  _WORD *v46; // eax
  int v47; // ecx
  bool v48; // zf
  int v49; // [esp+10h] [ebp-20h]
  int v50; // [esp+14h] [ebp-1Ch]
  int v51; // [esp+18h] [ebp-18h]
  int v52; // [esp+1Ch] [ebp-14h]
  int v53; // [esp+20h] [ebp-10h]
  int v54; // [esp+20h] [ebp-10h]
  int v55; // [esp+20h] [ebp-10h]
  int v56; // [esp+20h] [ebp-10h]
  int v57; // [esp+20h] [ebp-10h]
  int v58; // [esp+20h] [ebp-10h]
  int v59; // [esp+20h] [ebp-10h]
  int v60; // [esp+24h] [ebp-Ch]
  int v61; // [esp+24h] [ebp-Ch]
  int v62; // [esp+28h] [ebp-8h]
  _DWORD *v63; // [esp+2Ch] [ebp-4h]
  _DWORD *v64; // [esp+2Ch] [ebp-4h]
  _DWORD *v65; // [esp+2Ch] [ebp-4h]
  int v66; // [esp+34h] [ebp+4h]

  v2 = a2[1];
  v3 = a2[5];
  v4 = a2[4];
  v5 = a2[2];
  v60 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v6 = *a2;
  v7 = a2[3];
  v49 = *a2;
  v50 = v2;
  v66 = v5;
  v51 = v7;
  v52 = v4;
  v62 = v3;
  if ( *a2 < v2 )
  {
    v53 = *a2;
    if ( *a2 <= v2 )
    {
      v63 = (_DWORD *)(v60 + 4 * v6);
      while ( v5 > v7 )
      {
LABEL_12:
        ++v53;
        ++v63;
        if ( v53 > v2 )
          goto LABEL_15;
      }
      v8 = *v63 + 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v9 = (_WORD *)v8;
        v10 = a2[4];
        if ( v4 <= v3 )
          break;
LABEL_10:
        ++v5;
        v8 += 64;
        if ( v5 > v7 )
        {
          v6 = *a2;
          v2 = a2[1];
          v5 = a2[2];
          goto LABEL_12;
        }
      }
      while ( !*v9++ )
      {
        if ( ++v10 > v3 )
        {
          v7 = a2[3];
          goto LABEL_10;
        }
      }
      v7 = a2[3];
      v5 = a2[2];
      *a2 = v53;
      v2 = v50;
      v49 = v53;
      v6 = v53;
    }
LABEL_15:
    if ( v2 > v6 )
    {
      v54 = v2;
      v12 = (_DWORD *)(v60 + 4 * v2);
      v64 = v12;
      while ( v5 > v7 )
      {
LABEL_25:
        v12 = v64 - 1;
        v17 = --v54 < v6;
        --v64;
        if ( v17 )
          goto LABEL_28;
      }
      v13 = *v12 + 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v14 = (_WORD *)v13;
        v15 = v4;
        if ( v4 <= v3 )
          break;
LABEL_23:
        ++v5;
        v13 += 64;
        if ( v5 > v7 )
        {
          v6 = v49;
          v5 = v66;
          goto LABEL_25;
        }
      }
      while ( !*v14++ )
      {
        if ( ++v15 > v3 )
        {
          v7 = v51;
          goto LABEL_23;
        }
      }
      v7 = v51;
      v5 = v66;
      v50 = v54;
      a2[1] = v54;
    }
  }
LABEL_28:
  if ( v5 < v7 )
  {
    v55 = v5;
    if ( v5 <= v7 )
    {
      v18 = 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v19 = v49;
        if ( v49 <= v50 )
          break;
LABEL_37:
        v18 += 64;
        if ( ++v55 > v51 )
          goto LABEL_40;
      }
      v20 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v21 = v4;
        v22 = (_WORD *)(v18 + *v20);
        if ( v52 <= v3 )
          break;
LABEL_36:
        v4 = v52;
        ++v19;
        ++v20;
        if ( v19 > v50 )
          goto LABEL_37;
      }
      while ( !*v22++ )
      {
        if ( ++v21 > v3 )
          goto LABEL_36;
      }
      v4 = v52;
      v66 = v55;
      a2[2] = v55;
LABEL_40:
      v7 = v51;
      v5 = v66;
    }
    if ( v7 > v5 )
    {
      v56 = v7;
      v24 = 2 * (v4 + 32 * v7);
      while ( 1 )
      {
        v25 = v49;
        if ( v49 <= v50 )
          break;
LABEL_49:
        v24 -= 64;
        if ( --v56 < v66 )
          goto LABEL_52;
      }
      v26 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v27 = (_WORD *)(*v26 + v24);
        v28 = v4;
        if ( v52 <= v3 )
          break;
LABEL_48:
        v4 = v52;
        ++v25;
        ++v26;
        if ( v25 > v50 )
          goto LABEL_49;
      }
      while ( !*v27++ )
      {
        if ( ++v28 > v3 )
          goto LABEL_48;
      }
      v4 = v52;
      v51 = v56;
      a2[3] = v56;
    }
  }
LABEL_52:
  if ( v4 < v3 )
  {
    v30 = v4;
    v57 = v4;
    if ( v4 <= v3 )
    {
      while ( 1 )
      {
        v31 = v49;
        if ( v49 <= v50 )
          break;
LABEL_61:
        v57 = ++v30;
        if ( v30 > v3 )
          goto LABEL_64;
      }
      v32 = 2 * (v30 + 32 * v66);
      v33 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v34 = v66;
        v35 = (_WORD *)(v32 + *v33);
        if ( v66 <= v51 )
          break;
LABEL_59:
        ++v31;
        ++v33;
        if ( v31 > v50 )
        {
          v3 = v62;
          v30 = v57;
          goto LABEL_61;
        }
      }
      while ( !*v35 )
      {
        ++v34;
        v35 += 32;
        if ( v34 > v51 )
          goto LABEL_59;
      }
      v4 = v57;
      v3 = v62;
      v52 = v57;
      a2[4] = v57;
    }
LABEL_64:
    if ( v3 > v4 )
    {
      v36 = v3;
      v58 = v3;
      while ( 1 )
      {
        v37 = v49;
        if ( v49 <= v50 )
          break;
LABEL_73:
        v58 = --v36;
        if ( v36 < v4 )
          goto LABEL_76;
      }
      v38 = 2 * (v36 + 32 * v66);
      v39 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v40 = (_WORD *)(*v39 + v38);
        v41 = v66;
        if ( v66 <= v51 )
          break;
LABEL_71:
        ++v37;
        ++v39;
        if ( v37 > v50 )
        {
          v3 = v62;
          v36 = v58;
          goto LABEL_73;
        }
      }
      while ( !*v40 )
      {
        ++v41;
        v40 += 32;
        if ( v41 > v51 )
          goto LABEL_71;
      }
      v3 = v58;
      v62 = v58;
      a2[5] = v58;
    }
  }
LABEL_76:
  v42 = v3 - v4;
  a2[6] = 16 * (v50 - v49) * 16 * (v50 - v49) + 12 * (v51 - v66) * 12 * (v51 - v66) + 8 * v42 * 8 * v42;
  result = v49;
  v44 = 0;
  if ( v49 > v50 )
  {
    a2[7] = 0;
  }
  else
  {
    v65 = (_DWORD *)(v60 + 4 * v49);
    v59 = v50 - v49 + 1;
    do
    {
      if ( v66 <= v51 )
      {
        v45 = *v65 + 2 * (v52 + 32 * v66);
        v61 = v51 - v66 + 1;
        do
        {
          v46 = (_WORD *)v45;
          if ( v52 <= v62 )
          {
            v47 = v42 + 1;
            do
            {
              if ( *v46 )
                ++v44;
              ++v46;
              --v47;
            }
            while ( v47 );
          }
          v45 += 64;
          --v61;
        }
        while ( v61 );
      }
      result = v59 - 1;
      v48 = v59 == 1;
      ++v65;
      --v59;
    }
    while ( !v48 );
    a2[7] = v44;
  }
  return result;
}

// sub_10044070 @ 0x10044070
int __cdecl sub_10044070(int a1, int *a2, int a3)
{
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // edi
  unsigned __int16 *v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  bool v15; // zf
  int result; // eax
  int v17; // [esp+10h] [ebp-30h]
  int v18; // [esp+14h] [ebp-2Ch]
  int v19; // [esp+18h] [ebp-28h]
  int v20; // [esp+1Ch] [ebp-24h]
  int v21; // [esp+20h] [ebp-20h]
  unsigned __int16 *v22; // [esp+24h] [ebp-1Ch]
  int v23; // [esp+28h] [ebp-18h]
  int v24; // [esp+2Ch] [ebp-14h]
  int v25; // [esp+30h] [ebp-10h]
  int v26; // [esp+34h] [ebp-Ch]
  int v27; // [esp+3Ch] [ebp-4h]
  _DWORD *v28; // [esp+48h] [ebp+8h]

  v3 = a1;
  v4 = a2[4];
  v5 = a2[2];
  v6 = a2[1];
  v25 = a2[3];
  v7 = *a2;
  v8 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v27 = v5;
  v26 = v4;
  v21 = a2[5];
  if ( *a2 <= v6 )
  {
    v17 = 8 * v7 + 4;
    v28 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 420) + 24) + 4 * v7);
    v24 = v6 - v7 + 1;
    do
    {
      if ( v5 <= v25 )
      {
        v9 = (unsigned __int16 *)(*v28 + 2 * (v4 + 32 * v5));
        v10 = v25 - v5 + 1;
        v11 = 4 * v5 + 2;
        v22 = v9;
        v23 = v10;
        do
        {
          if ( v4 <= v21 )
          {
            v12 = 8 * v4 + 4;
            v13 = v21 - v4 + 1;
            do
            {
              v14 = *v9++;
              if ( (_WORD)v14 )
              {
                v18 += v14 * v17;
                v8 += v14;
                v19 += v14 * v11;
                v4 = v26;
                v20 += v14 * v12;
              }
              v12 += 8;
              --v13;
            }
            while ( v13 );
            v10 = v23;
            v5 = v27;
          }
          v9 = v22 + 32;
          v11 += 4;
          --v10;
          v22 += 32;
          v23 = v10;
        }
        while ( v10 );
        v3 = a1;
      }
      v15 = v24 == 1;
      ++v28;
      v17 += 8;
      --v24;
    }
    while ( !v15 );
  }
  *(_BYTE *)(**(_DWORD **)(v3 + 116) + a3) = ((v8 >> 1) + v18) / v8;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 4) + a3) = ((v8 >> 1) + v19) / v8;
  result = ((v8 >> 1) + v20) / v8;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 8) + a3) = result;
  return result;
}

// sub_10044200 @ 0x10044200
int __cdecl sub_10044200(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 420) + 28) = 1;
  return a1;
}

// sub_10044210 @ 0x10044210
int __cdecl sub_10044210(_DWORD *a1)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  int v4; // ebp
  _DWORD *v5; // eax
  int v6; // eax
  int v7; // esi
  _DWORD *v8; // ebx
  int v9; // ecx
  int v10; // ebp
  int v11; // eax
  int v12; // eax
  int i; // edx
  int j; // ecx
  int v15; // ebp
  bool v16; // zf
  bool v17; // cc
  int result; // eax
  int v19; // ebp
  int v20; // esi
  _DWORD *v21; // ebx
  int v22; // [esp+10h] [ebp-28h]
  int v23; // [esp+14h] [ebp-24h]
  int *v24; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  int v26; // [esp+20h] [ebp-18h]
  int v27; // [esp+24h] [ebp-14h]
  _DWORD *v28; // [esp+28h] [ebp-10h]
  int v29; // [esp+2Ch] [ebp-Ch]
  int v30; // [esp+30h] [ebp-8h]
  int v31; // [esp+34h] [ebp-4h]
  int v32; // [esp+3Ch] [ebp+4h]

  v2 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 88);
  a1[105] = v2;
  *v2 = sub_10044690;
  v2[2] = nullsub_4;
  v2[3] = sub_10044E30;
  v2[17] = 0;
  v2[13] = 0;
  if ( (int)a1[25] > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[21] > 256 )
  {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = (_DWORD *)a1[105];
  v28 = v3;
  v4 = sub_10044450(a1, v3 + 8);
  v23 = v4;
  if ( a1[25] == 3 )
  {
    v5 = (_DWORD *)(*a1 + 24);
    *v5 = v4;
    v5[1] = v3[8];
    v5[2] = v3[9];
    v5[3] = v3[10];
    *(_DWORD *)(*a1 + 20) = 93;
  }
  else
  {
    *(_DWORD *)(*a1 + 20) = 94;
    *(_DWORD *)(*a1 + 24) = v4;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v6 = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v4, a1[25]);
  v7 = v4;
  v31 = v6;
  v26 = v4;
  v27 = 0;
  if ( (int)a1[25] > 0 )
  {
    v8 = (_DWORD *)v6;
    v24 = v28 + 8;
    do
    {
      v9 = *v24;
      v7 /= *v24;
      if ( *v24 > 0 )
      {
        v10 = v9 - 1;
        v11 = (v9 - 1) / 2;
        v29 = v9 - 1;
        v30 = v11;
        v22 = 0;
        v32 = 0;
        v25 = *v24;
        while ( 1 )
        {
          v12 = (v32 + v11) / v10;
          for ( i = v22; i < v23; i += v26 )
          {
            for ( j = 0; j < v7; *(_BYTE *)(i + v15) = v12 )
            {
              v15 = j + *v8;
              ++j;
            }
          }
          v16 = v25 == 1;
          v32 += 255;
          v22 += v7;
          --v25;
          if ( v16 )
            break;
          v10 = v29;
          v11 = v30;
        }
        v4 = v23;
      }
      ++v24;
      ++v8;
      v17 = v27 + 1 < a1[25];
      v26 = v7;
      ++v27;
    }
    while ( v17 );
    v6 = v31;
    v3 = v28;
  }
  v3[4] = v6;
  v3[5] = v4;
  sub_10044540(a1);
  result = a1[19];
  if ( result == 2 )
  {
    result = a1[105];
    v19 = 2 * a1[23] + 4;
    v20 = 0;
    if ( (int)a1[25] > 0 )
    {
      v21 = (_DWORD *)(result + 68);
      do
      {
        *v21 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v19);
        result = a1[25];
        ++v20;
        ++v21;
      }
      while ( v20 < result );
    }
  }
  return result;
}

// sub_10044450 @ 0x10044450
int __cdecl sub_10044450(_DWORD *a1, void *a2)
{
  signed int v2; // esi
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // ebx
  signed int v8; // edx
  signed int v9; // ebp
  int v10; // esi
  int v11; // edi
  char v13; // [esp+13h] [ebp-Dh]
  signed int *v14; // [esp+14h] [ebp-Ch]
  signed int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]

  v2 = a1[25];
  v15 = v2;
  v16 = a1[21];
  v3 = 1;
  do
  {
    v4 = ++v3;
    if ( v2 > 1 )
    {
      v5 = v2 - 1;
      do
      {
        v4 *= v3;
        --v5;
      }
      while ( v5 );
    }
  }
  while ( v4 <= a1[21] );
  v6 = v3 - 1;
  if ( v6 < 2 )
  {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = v4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v7 = 1;
  if ( v2 > 0 )
  {
    v8 = v2;
    memset32(a2, v6, v2);
    do
    {
      v7 *= v6;
      --v8;
    }
    while ( v8 );
  }
  while ( 2 )
  {
    v9 = 0;
    v13 = 0;
    if ( v2 > 0 )
    {
      v14 = (signed int *)&dbl_10050950;
      while ( 1 )
      {
        v10 = a1[10] == 2 ? *v14 : v9;
        v11 = *((_DWORD *)a2 + v10);
        if ( (v11 + 1) * (v7 / v11) > v16 )
          break;
        *((_DWORD *)a2 + v10) = v11 + 1;
        v7 = (v11 + 1) * (v7 / v11);
        ++v9;
        v13 = 1;
        ++v14;
        if ( v9 >= v15 )
          goto LABEL_12;
      }
      if ( v13 )
      {
LABEL_12:
        v2 = v15;
        continue;
      }
    }
    return v7;
  }
}

// sub_10044540 @ 0x10044540
int __cdecl sub_10044540(_DWORD *a1)
{
  int v1; // esi
  int result; // eax
  int v3; // ecx
  int v4; // edi
  _BYTE *v5; // ebp
  int v6; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  _BYTE *v11; // edx
  int v12; // [esp+8h] [ebp-18h]
  int *v13; // [esp+Ch] [ebp-14h]
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+18h] [ebp-8h]
  _BYTE *v17; // [esp+1Ch] [ebp-4h]

  v1 = a1[105];
  v16 = v1;
  if ( a1[19] == 1 )
  {
    v12 = 510;
    *(_BYTE *)(v1 + 28) = 1;
  }
  else
  {
    v12 = 0;
    *(_BYTE *)(v1 + 28) = 0;
  }
  *(_DWORD *)(v1 + 24) = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v12 + 256, a1[25]);
  result = *(_DWORD *)(v1 + 20);
  v3 = 0;
  v15 = 0;
  if ( (int)a1[25] > 0 )
  {
    v13 = (int *)(v1 + 32);
    while ( 1 )
    {
      v4 = *v13;
      v14 = result / *v13;
      if ( v12 )
        *(_DWORD *)(*(_DWORD *)(v1 + 24) + 4 * v3) += 255;
      v5 = *(_BYTE **)(*(_DWORD *)(v1 + 24) + 4 * v3);
      v6 = 0;
      v17 = v5;
      v7 = 0;
      v8 = (v4 + 254) / (2 * v4 - 2);
      do
      {
        if ( v7 > v8 )
        {
          v9 = 510 * v6;
          do
          {
            v9 += 510;
            ++v6;
            v8 = (v9 + v4 + 254) / (2 * v4 - 2);
          }
          while ( v7 > v8 );
          v3 = v15;
          v5 = v17;
        }
        v5[v7++] = v6 * v14;
      }
      while ( v7 <= 255 );
      if ( v12 )
      {
        v10 = 1;
        v11 = v5 - 1;
        do
        {
          *v11 = *v5;
          v5[v10 + 255] = v5[255];
          ++v10;
          --v11;
        }
        while ( v10 <= 255 );
      }
      result = (int)a1;
      v15 = ++v3;
      ++v13;
      if ( v3 >= a1[25] )
        break;
      result = v14;
      v1 = v16;
    }
  }
  return result;
}

// sub_10044690 @ 0x10044690
int __cdecl sub_10044690(_DWORD *a1)
{
  int v2; // esi
  int result; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  void **v7; // ecx
  int v8; // esi
  _DWORD *v9; // ebp
  int v10; // edi
  unsigned int v11; // ebp
  void **v12; // esi
  char v13; // al
  int v14; // ebp
  int v15; // ecx
  int *v16; // edi
  int v17; // esi
  int v18; // eax
  _DWORD *v19; // edx
  int v20; // eax
  int v21; // esi
  double *v22; // ebp
  int v23; // edi
  int i; // ecx
  int v25; // eax
  int *v26; // [esp+10h] [ebp-Ch]
  int v27; // [esp+14h] [ebp-8h]
  int v28; // [esp+18h] [ebp-4h]
  void **v29; // [esp+20h] [ebp+4h]
  int v30; // [esp+20h] [ebp+4h]

  v2 = a1[105];
  a1[29] = *(_DWORD *)(v2 + 16);
  result = a1[19];
  v4 = 0;
  a1[28] = *(_DWORD *)(v2 + 20);
  if ( result )
  {
    v5 = result - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = *(_DWORD *)(v2 + 68);
        v7 = (void **)(v2 + 68);
        *(_DWORD *)(v2 + 4) = sub_10044C70;
        *(_BYTE *)(v2 + 84) = 0;
        v29 = (void **)(v2 + 68);
        if ( !v6 )
        {
          v8 = 2 * a1[23] + 4;
          if ( (int)a1[25] > 0 )
          {
            v9 = (_DWORD *)(a1[105] + 68);
            do
            {
              *v9 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v8);
              ++v4;
              ++v9;
            }
            while ( v4 < a1[25] );
            v7 = v29;
          }
        }
        result = a1[25];
        v10 = 0;
        v11 = 2 * a1[23] + 4;
        if ( result > 0 )
        {
          v12 = v7;
          do
          {
            sub_1003E510(*v12, v11);
            result = a1[25];
            ++v10;
            ++v12;
          }
          while ( v10 < result );
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 47;
        return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      if ( a1[25] == 3 )
        *(_DWORD *)(v2 + 4) = sub_10044B40;
      else
        *(_DWORD *)(v2 + 4) = sub_10044A10;
      v13 = *(_BYTE *)(v2 + 28);
      *(_DWORD *)(v2 + 48) = 0;
      if ( !v13 )
        sub_10044540(a1);
      result = *(_DWORD *)(v2 + 52);
      if ( !result )
      {
        result = a1[25];
        v14 = a1[105];
        v15 = 0;
        v28 = v14;
        v30 = 0;
        if ( result > 0 )
        {
          v16 = (int *)(v14 + 52);
          v26 = (int *)(v14 + 52);
          do
          {
            v17 = *(v16 - 5);
            v18 = 0;
            if ( v15 <= 0 )
              goto LABEL_28;
            v19 = (_DWORD *)(v14 + 32);
            while ( v17 != *v19 )
            {
              ++v18;
              ++v19;
              if ( v18 >= v15 )
                goto LABEL_28;
            }
            v20 = *(_DWORD *)(v14 + 4 * v18 + 52);
            if ( !v20 )
            {
LABEL_28:
              v27 = (*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 1024);
              v21 = (v17 << 9) - 512;
              v22 = dbl_10050850;
              v23 = v27;
              do
              {
                for ( i = 0; i < 16; ++i )
                {
                  v23 += 4;
                  v25 = (65025 - 510 * *((unsigned __int8 *)v22 + i)) / v21;
                  *(_DWORD *)(v23 - 4) = v25;
                }
                v22 += 2;
              }
              while ( (int)v22 < (int)&dbl_10050950 );
              v20 = v27;
              v16 = v26;
              v14 = v28;
              v15 = v30;
            }
            *v16 = v20;
            result = a1[25];
            ++v15;
            ++v16;
            v30 = v15;
            v26 = v16;
          }
          while ( v15 < result );
        }
      }
    }
  }
  else if ( a1[25] == 3 )
  {
    *(_DWORD *)(v2 + 4) = sub_10044950;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = sub_10044890;
  }
  return result;
}

// sub_10044890 @ 0x10044890
int __cdecl sub_10044890(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  int result; // eax
  _DWORD *v7; // edx
  int v8; // ebx
  unsigned __int8 *v9; // esi
  char v10; // cl
  int *v11; // eax
  int v12; // ebx
  bool v13; // zf
  int *v14; // [esp+8h] [ebp-10h]
  int v15; // [esp+Ch] [ebp-Ch]
  int v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]
  _BYTE *v18; // [esp+1Ch] [ebp+4h]
  int v19; // [esp+20h] [ebp+8h]
  int v20; // [esp+28h] [ebp+10h]

  v4 = a1[23];
  v5 = a1[25];
  result = a4;
  v14 = *(int **)(a1[105] + 24);
  v17 = v4;
  v15 = v5;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a2 - (_DWORD)a3;
    v16 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v7 + v8);
      v18 = (_BYTE *)*v7;
      if ( v4 )
      {
        v20 = v4;
        do
        {
          v10 = 0;
          if ( v5 > 0 )
          {
            v11 = v14;
            do
            {
              v12 = *v11++;
              v10 += *(_BYTE *)(v12 + *v9++);
              --v5;
            }
            while ( v5 );
            v5 = v15;
          }
          *v18++ = v10;
          --v20;
        }
        while ( v20 );
        v8 = v16;
        v7 = a3;
        v4 = v17;
      }
      ++v7;
      result = v19 - 1;
      v13 = v19 == 1;
      a3 = v7;
      --v19;
    }
    while ( !v13 );
  }
  return result;
}

// sub_10044950 @ 0x10044950
int __cdecl sub_10044950(int a1, int a2, _DWORD *a3, int a4)
{
  int *v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // edi
  _DWORD *v8; // ecx
  int v9; // edx
  unsigned __int8 *v10; // eax
  _BYTE *v11; // esi
  char v12; // cl
  int v13; // edx
  unsigned __int8 *v14; // eax
  char v15; // bl
  bool v16; // zf
  int v17; // [esp+4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]
  _DWORD *v21; // [esp+18h] [ebp+4h]
  int v22; // [esp+20h] [ebp+Ch]

  v4 = *(int **)(*(_DWORD *)(a1 + 420) + 24);
  v17 = *v4;
  v5 = v4[1];
  v19 = v4[2];
  result = a4;
  v7 = *(_DWORD *)(a1 + 92);
  v18 = v5;
  v20 = v7;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v21 = a3;
    v22 = a2 - (_DWORD)a3;
    do
    {
      v10 = *(unsigned __int8 **)((char *)v8 + v9);
      v11 = (_BYTE *)*v8;
      if ( v7 )
      {
        do
        {
          v12 = *(_BYTE *)(*v10 + v17);
          v13 = v10[1];
          v14 = v10 + 1;
          v15 = *(_BYTE *)(v14[1] + v19);
          v10 = v14 + 2;
          *v11++ = v15 + *(_BYTE *)(v13 + v18) + v12;
          --v7;
        }
        while ( v7 );
        v7 = v20;
        v8 = v21;
        v9 = v22;
      }
      ++v8;
      result = a4 - 1;
      v16 = a4 == 1;
      v21 = v8;
      --a4;
    }
    while ( !v16 );
  }
  return result;
}

// sub_10044A10 @ 0x10044A10
int __cdecl sub_10044A10(_DWORD *a1, int a2, void **a3, int a4)
{
  _DWORD *v4; // edi
  int result; // eax
  void **v6; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // esi
  int v10; // ebp
  _BYTE *v11; // ecx
  int v12; // edi
  int v13; // esi
  unsigned __int8 *v14; // eax
  bool v15; // zf
  int v16; // [esp+4h] [ebp-1Ch]
  _DWORD *v17; // [esp+8h] [ebp-18h]
  void **v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  char v22; // [esp+1Ch] [ebp-4h]
  unsigned int v23; // [esp+24h] [ebp+4h]
  int v24; // [esp+28h] [ebp+8h]
  unsigned int v25; // [esp+2Ch] [ebp+Ch]
  _DWORD *v26; // [esp+30h] [ebp+10h]

  v4 = (_DWORD *)a1[105];
  result = a4;
  v17 = v4;
  v16 = a1[25];
  v23 = a1[23];
  if ( a4 > 0 )
  {
    v6 = a3;
    v18 = a3;
    v21 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      sub_1003E510(*v6, v23);
      v7 = v4[12];
      v8 = 0;
      v22 = v7;
      v24 = 0;
      if ( v16 > 0 )
      {
        v9 = v7 << 6;
        v20 = v9;
        v26 = v4 + 13;
        while ( 1 )
        {
          v10 = *(_DWORD *)(v4[6] + 4 * v8);
          v11 = *v6;
          v12 = v9 + *v26;
          v13 = 0;
          v14 = (unsigned __int8 *)(*(char **)((char *)v6 + v21) + v8);
          if ( v23 )
          {
            v25 = v23;
            do
            {
              *v11 += *(_BYTE *)(*v14 + *(_DWORD *)(v12 + 4 * v13) + v10);
              v14 += v16;
              ++v11;
              v13 = ((_BYTE)v13 + 1) & 0xF;
              --v25;
            }
            while ( v25 );
            v8 = v24;
            v6 = v18;
          }
          v24 = ++v8;
          ++v26;
          if ( v8 >= v16 )
            break;
          v9 = v20;
          v4 = v17;
        }
        v4 = v17;
        LOBYTE(v7) = v22;
      }
      ++v6;
      result = v19 - 1;
      v15 = v19 == 1;
      v4[12] = ((_BYTE)v7 + 1) & 0xF;
      v18 = v6;
      --v19;
    }
    while ( !v15 );
  }
  return result;
}

// sub_10044B40 @ 0x10044B40
int __cdecl sub_10044B40(int a1, int a2, _BYTE **a3, int a4)
{
  _DWORD *v4; // edx
  int *v5; // eax
  int v6; // esi
  int result; // eax
  _BYTE **v8; // ebx
  int v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // ebp
  int v12; // edi
  int v13; // esi
  char v14; // cl
  int v15; // edx
  unsigned __int8 *v16; // eax
  int v17; // ebx
  bool v18; // zf
  int v19; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  _DWORD *v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+24h] [ebp-4h]
  _BYTE *v28; // [esp+2Ch] [ebp+4h]
  int v29; // [esp+30h] [ebp+8h]
  int v30; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD **)(a1 + 420);
  v5 = (int *)v4[6];
  v22 = *v5;
  v6 = v5[1];
  result = v5[2];
  v20 = *(_DWORD *)(a1 + 92);
  v26 = v4;
  v23 = v6;
  v25 = result;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v19 = a2 - (_DWORD)a3;
    v29 = a4;
    while ( 1 )
    {
      v10 = *(_BYTE **)((char *)v8 + v9);
      v28 = *v8;
      v27 = v4[12];
      v11 = (v27 << 6) + v4[14];
      v12 = (v27 << 6) + v4[13];
      v24 = (v27 << 6) + v4[15];
      v13 = 0;
      v21 = v11;
      if ( v20 )
      {
        v30 = v20;
        while ( 1 )
        {
          v14 = *(_BYTE *)(*v10 + *(_DWORD *)(v12 + 4 * v13) + v22);
          v15 = v10[1];
          v16 = v10 + 1;
          v17 = v16[1] + *(_DWORD *)(v24 + 4 * v13);
          v10 = v16 + 2;
          *v28 = *(_BYTE *)(v17 + v25) + *(_BYTE *)(v15 + *(_DWORD *)(v11 + 4 * v13) + v23) + v14;
          v13 = ((_BYTE)v13 + 1) & 0xF;
          v18 = v30 == 1;
          ++v28;
          --v30;
          if ( v18 )
            break;
          v11 = v21;
        }
        v4 = v26;
        v8 = a3;
      }
      v4[12] = ((_BYTE)v27 + 1) & 0xF;
      ++v8;
      result = v29 - 1;
      v18 = v29 == 1;
      a3 = v8;
      --v29;
      if ( v18 )
        break;
      v9 = v19;
    }
  }
  return result;
}

// sub_10044C70 @ 0x10044C70
int __cdecl sub_10044C70(_DWORD *a1, int a2, void **a3, int a4)
{
  int v4; // edx
  int v5; // ebx
  int v6; // esi
  int result; // eax
  void **v8; // edi
  int v9; // edx
  _BYTE *v10; // ebp
  unsigned __int8 *v11; // ecx
  int v12; // edi
  _WORD *v13; // esi
  int v14; // eax
  __int16 v15; // bx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  bool v20; // zf
  int v21; // [esp+8h] [ebp-30h]
  void **v22; // [esp+Ch] [ebp-2Ch]
  __int16 v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  unsigned int v25; // [esp+18h] [ebp-20h]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+24h] [ebp-14h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+2Ch] [ebp-Ch]
  int v31; // [esp+30h] [ebp-8h]
  int v32; // [esp+34h] [ebp-4h]
  unsigned int v33; // [esp+3Ch] [ebp+4h]
  __int16 v34; // [esp+40h] [ebp+8h]
  unsigned __int8 *v35; // [esp+44h] [ebp+Ch]
  _DWORD *v36; // [esp+48h] [ebp+10h]

  v4 = a1[71];
  v5 = a1[105];
  v6 = a1[25];
  result = a4;
  v27 = v5;
  v21 = v6;
  v33 = a1[23];
  v30 = v4;
  if ( a4 > 0 )
  {
    v8 = a3;
    v22 = a3;
    v29 = a2 - (_DWORD)a3;
    v28 = a4;
    do
    {
      sub_1003E510(*v8, v33);
      v9 = 0;
      v26 = 0;
      if ( v6 > 0 )
      {
        v36 = (_DWORD *)(v5 + 68);
        do
        {
          v10 = *v8;
          v11 = (unsigned __int8 *)(*(char **)((char *)v8 + v29) + v9);
          v35 = v11;
          if ( *(_BYTE *)(v5 + 84) )
          {
            v10 += v33 - 1;
            v11 += v6 * (v33 - 1);
            v12 = -1;
            v24 = -v6;
            v35 = v11;
            v13 = (_WORD *)(*v36 + 2 * v33 + 2);
          }
          else
          {
            v24 = v6;
            v13 = (_WORD *)*v36;
            v12 = 1;
          }
          v31 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * v9);
          v14 = *(_DWORD *)(*(_DWORD *)(v5 + 16) + 4 * v9);
          v15 = 0;
          v32 = v14;
          v16 = 0;
          v34 = 0;
          v23 = 0;
          if ( v33 )
          {
            v25 = v33;
            do
            {
              v17 = *(unsigned __int8 *)(*v11 + (((__int16)v13[v12] + v16 + 8) >> 4) + v30);
              v18 = *(unsigned __int8 *)(v17 + v31);
              *v10 += v18;
              v10 += v12;
              v19 = v17 - *(unsigned __int8 *)(v18 + v32);
              *v13 = 3 * v19 + v34;
              v15 = 5 * v19 + v23;
              v23 = v19;
              v16 = 7 * v19;
              v11 = &v35[v24];
              v20 = v25 == 1;
              v34 = v15;
              v35 += v24;
              v13 += v12;
              --v25;
            }
            while ( !v20 );
            v9 = v26;
          }
          v8 = v22;
          ++v9;
          *v13 = v15;
          v5 = v27;
          v26 = v9;
          ++v36;
          v6 = v21;
        }
        while ( v9 < v21 );
      }
      *(_BYTE *)(v5 + 84) = *(_BYTE *)(v5 + 84) == 0;
      ++v8;
      result = v28 - 1;
      v20 = v28 == 1;
      v22 = v8;
      --v28;
    }
    while ( !v20 );
  }
  return result;
}

// sub_10044E30 @ 0x10044E30
int __cdecl sub_10044E30(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_10044E50 @ 0x10044E50
int __cdecl sub_10044E50(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // edx
  __int16 *v6; // ebx
  int v7; // ebp
  int *v8; // ecx
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // di
  __int16 v12; // bp
  int v13; // esi
  int v14; // ebp
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // edi
  int v22; // esi
  int v23; // ebx
  __int16 *v24; // esi
  int v25; // edi
  int v26; // ebx
  _BYTE *v27; // ecx
  char v28; // al
  int v29; // edx
  int v30; // ebp
  int v31; // edi
  int v32; // eax
  int v33; // esi
  int v34; // edx
  int v35; // esi
  int v36; // edi
  int v37; // eax
  int v38; // ebp
  int v39; // eax
  int v40; // eax
  bool v41; // zf
  int result; // eax
  __int16 v43; // [esp+Ch] [ebp-138h]
  int v44; // [esp+Ch] [ebp-138h]
  int v45; // [esp+Ch] [ebp-138h]
  __int16 v46; // [esp+10h] [ebp-134h]
  __int16 v47; // [esp+10h] [ebp-134h]
  int v48; // [esp+10h] [ebp-134h]
  int v49; // [esp+10h] [ebp-134h]
  int v50; // [esp+10h] [ebp-134h]
  int v51; // [esp+14h] [ebp-130h]
  int v52; // [esp+14h] [ebp-130h]
  __int16 *v53; // [esp+14h] [ebp-130h]
  int v54; // [esp+18h] [ebp-12Ch]
  int v55; // [esp+18h] [ebp-12Ch]
  int v56; // [esp+1Ch] [ebp-128h]
  __int16 v57; // [esp+20h] [ebp-124h]
  int v58; // [esp+20h] [ebp-124h]
  __int16 v60; // [esp+24h] [ebp-120h]
  int v61; // [esp+24h] [ebp-120h]
  int v62; // [esp+24h] [ebp-120h]
  __int16 *v63; // [esp+28h] [ebp-11Ch]
  int v64; // [esp+28h] [ebp-11Ch]
  int v65; // [esp+2Ch] [ebp-118h]
  int v66; // [esp+2Ch] [ebp-118h]
  __int16 v67; // [esp+30h] [ebp-114h]
  int v68; // [esp+30h] [ebp-114h]
  int v69; // [esp+34h] [ebp-110h]
  int v70; // [esp+34h] [ebp-110h]
  int v71; // [esp+38h] [ebp-10Ch]
  int v72; // [esp+38h] [ebp-10Ch]
  int v73; // [esp+3Ch] [ebp-108h]
  int v74; // [esp+3Ch] [ebp-108h]
  int v75; // [esp+40h] [ebp-104h]
  _BYTE v76[256]; // [esp+44h] [ebp-100h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  v6 = a3;
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v75 = v7;
  v63 = a3;
  v8 = (int *)v76;
  v65 = 8;
  do
  {
    v46 = v6[40];
    v57 = v6[32];
    v60 = v6[24];
    v43 = v6[56];
    v9 = v6[48];
    v67 = v6[8];
    if ( (unsigned __int16)v43 | (unsigned __int16)(v9 | v46 | v57 | v60 | v6[16] | v67) )
    {
      v11 = v6[16] * v5[16];
      v12 = v9 * v5[48];
      v13 = 4433 * (__int16)(v11 + v12);
      v14 = v13 - 15137 * v12;
      v51 = v13 + 6270 * v11;
      v15 = v57 * v5[32];
      v16 = *v5 * *v6;
      v17 = v15 + v16;
      v18 = (v16 - v15) << 13;
      v17 <<= 13;
      v19 = v17 + v51;
      v73 = v17 - v51;
      v69 = v18 - v14;
      v71 = v18 + v14;
      LOWORD(v17) = v43 * v5[56];
      v58 = v19;
      LOWORD(v15) = v46 * v5[40];
      LOWORD(v18) = v60 * v5[24];
      v52 = v67 * v5[8];
      LOWORD(v14) = v17 + v18;
      v47 = v18;
      v61 = 9633 * (__int16)(v17 + v18 + v15 + v52);
      v54 = -7373 * (__int16)(v17 + v52);
      v20 = -20995 * (__int16)(v15 + v18);
      v44 = v61 - 16069 * (__int16)v14;
      v56 = v61 - 3196 * (__int16)(v15 + v52);
      v21 = v20 + v56 + 16819 * (__int16)v15;
      v48 = v20 + v44 + 25172 * v47;
      v22 = v44 + v54 + 2446 * (__int16)v17;
      v23 = v54 + (__int16)v52 + v56 + 12298 * (__int16)v52;
      v8[56] = (v58 - v23 + 1024) >> 11;
      *v8 = (v58 + v23 + 1024) >> 11;
      v8[48] = (v71 - v48 + 1024) >> 11;
      v8[8] = (v71 + v48 + 1024) >> 11;
      v7 = v75;
      v8[40] = (v69 - v21 + 1024) >> 11;
      v8[16] = (v69 + v21 + 1024) >> 11;
      v6 = v63 + 1;
      v8[24] = (v73 + v22 + 1024) >> 11;
      v8[32] = (v73 - v22 + 1024) >> 11;
    }
    else
    {
      v10 = 4 * *v5 * *v6++;
      *v8 = v10;
      v8[8] = v10;
      v8[16] = v10;
      v8[24] = v10;
      v8[32] = v10;
      v8[40] = v10;
      v8[48] = v10;
      v8[56] = v10;
    }
    ++v5;
    v63 = v6;
    ++v8;
    --v65;
  }
  while ( v65 );
  v24 = (__int16 *)v76;
  v53 = (__int16 *)v76;
  v68 = 8;
  do
  {
    v25 = *((_DWORD *)v24 + 6);
    v26 = *((_DWORD *)v24 + 7);
    v27 = (_BYTE *)(a5 + *a4);
    v66 = *((_DWORD *)v24 + 4);
    v64 = *((_DWORD *)v24 + 5);
    v45 = *((_DWORD *)v24 + 3);
    v49 = *((_DWORD *)v24 + 1);
    if ( v26 | v25 | v64 | v66 | v45 | *((_DWORD *)v24 + 2) | v49 )
    {
      v29 = 4433 * (__int16)(v25 + *((_DWORD *)v24 + 2));
      v30 = v29 - 15137 * (__int16)v25;
      v31 = v29 + 6270 * v24[4];
      v32 = (*(_DWORD *)v24 - v66) << 13;
      v33 = (*(_DWORD *)v24 + v66) << 13;
      v34 = v33 + v31;
      v35 = v33 - v31;
      v36 = v32 + v30;
      v70 = v32 - v30;
      v62 = 9633 * (__int16)(v26 + v45 + v49 + v64);
      v55 = -7373 * (__int16)(v26 + v49);
      v37 = -20995 * (__int16)(v45 + v64);
      v72 = v62 - 16069 * (__int16)(v26 + v45) + v55 + 2446 * v53[14];
      v74 = v37 + v62 - 3196 * (__int16)(v49 + v64) + 16819 * v53[10];
      v38 = v62 - 3196 * (__int16)(v49 + v64);
      v50 = v37 + v62 - 16069 * (__int16)(v26 + v45) + 25172 * v53[6];
      v39 = v53[2] + v38 + 12298 * v53[2];
      v7 = v75;
      v40 = v55 + v39;
      *v27 = *(_BYTE *)((((v34 + v40 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[7] = *(_BYTE *)((((v34 - v40 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[1] = *(_BYTE *)((((v36 + v50 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[6] = *(_BYTE *)((((v36 - v50 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[2] = *(_BYTE *)((((v70 + v74 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[5] = *(_BYTE *)((((v70 - v74 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[3] = *(_BYTE *)((((v35 + v72 + 0x20000) >> 18) & 0x3FF) + v75);
      LOBYTE(v40) = *(_BYTE *)((((v35 - v72 + 0x20000) >> 18) & 0x3FF) + v75);
      v24 = v53;
      v27[4] = v40;
    }
    else
    {
      v28 = *(_BYTE *)((((*(_DWORD *)v24 + 16) >> 5) & 0x3FF) + v7);
      *v27 = v28;
      v27[1] = v28;
      v27[2] = v28;
      v27[3] = v28;
      v27[4] = v28;
      v27[5] = v28;
      v27[6] = v28;
      v27[7] = v28;
    }
    v24 += 16;
    result = v68 - 1;
    v41 = v68 == 1;
    v53 = v24;
    ++a4;
    --v68;
  }
  while ( !v41 );
  return result;
}

// sub_100454A0 @ 0x100454A0
int __cdecl sub_100454A0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  __int16 *v5; // edx
  _DWORD *v6; // ecx
  int v7; // esi
  int *v8; // eax
  __int16 v9; // bx
  int v10; // edi
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  int v15; // ebp
  int v16; // edx
  int v17; // edi
  int v18; // esi
  int v19; // ebx
  int v20; // ebp
  int v21; // edi
  int v22; // edx
  int v23; // edi
  int v24; // esi
  int v25; // ebx
  int v26; // ebp
  int v27; // esi
  int v28; // ebp
  int v29; // edi
  int v30; // ebx
  int v31; // edx
  int v32; // esi
  int v33; // ebp
  int v34; // ebx
  int v35; // edi
  int *v36; // ecx
  int v37; // edi
  _BYTE *v38; // eax
  int v39; // edx
  char v40; // dl
  int v41; // ecx
  int v42; // ebp
  int v43; // edx
  int v44; // ebx
  int v45; // ecx
  int v46; // edi
  int v47; // ebp
  int v48; // ecx
  int v49; // edx
  int v50; // ecx
  int v51; // edx
  bool v52; // zf
  int result; // eax
  __int16 *v54; // [esp+10h] [ebp-130h]
  int v55; // [esp+10h] [ebp-130h]
  int v56; // [esp+10h] [ebp-130h]
  int v57; // [esp+14h] [ebp-12Ch]
  int v58; // [esp+14h] [ebp-12Ch]
  int v59; // [esp+18h] [ebp-128h]
  int v60; // [esp+18h] [ebp-128h]
  int v61; // [esp+18h] [ebp-128h]
  __int16 v62; // [esp+1Ch] [ebp-124h]
  int v63; // [esp+1Ch] [ebp-124h]
  int v64; // [esp+1Ch] [ebp-124h]
  __int16 v65; // [esp+20h] [ebp-120h]
  int v66; // [esp+20h] [ebp-120h]
  __int16 v68; // [esp+24h] [ebp-11Ch]
  int *v69; // [esp+24h] [ebp-11Ch]
  __int16 v70; // [esp+28h] [ebp-118h]
  int v71; // [esp+28h] [ebp-118h]
  int v72; // [esp+28h] [ebp-118h]
  __int16 v73; // [esp+2Ch] [ebp-114h]
  int v74; // [esp+2Ch] [ebp-114h]
  int v75; // [esp+2Ch] [ebp-114h]
  __int16 v76; // [esp+30h] [ebp-110h]
  int v77; // [esp+30h] [ebp-110h]
  int v78; // [esp+30h] [ebp-110h]
  int v79; // [esp+34h] [ebp-10Ch]
  int v80; // [esp+34h] [ebp-10Ch]
  int v81; // [esp+38h] [ebp-108h]
  int v82; // [esp+38h] [ebp-108h]
  int v83; // [esp+3Ch] [ebp-104h]
  int v84; // [esp+3Ch] [ebp-104h]
  _BYTE v85[256]; // [esp+40h] [ebp-100h] BYREF

  v5 = a3;
  v6 = *(_DWORD **)(a2 + 80);
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v81 = v7;
  v54 = a3;
  v8 = (int *)v85;
  v59 = 8;
  do
  {
    v9 = v5[48];
    v62 = v5[56];
    v73 = v5[40];
    v65 = v5[32];
    v68 = v5[24];
    v70 = v5[8];
    v76 = v5[16];
    if ( (unsigned __int16)v62 | (unsigned __int16)(v9 | v73 | v65 | v68 | v76 | v70) )
    {
      v11 = *v6 * *v5;
      v12 = v76 * v6[16];
      v13 = v65 * v6[32];
      v14 = v9 * v6[48];
      v15 = v13 + v11;
      v16 = v11 - v13;
      v17 = v14 + v12;
      v18 = ((362 * (v12 - v14)) >> 8) - (v14 + v12);
      v19 = v17 + v15;
      v20 = v15 - v17;
      v21 = v18 + v16;
      v79 = v16 - v18;
      v22 = v70 * v6[8];
      v77 = v19;
      v83 = v21;
      v23 = v68 * v6[24];
      v24 = v73 * v6[40];
      v66 = v20;
      v25 = v62 * v6[56];
      v26 = v24 + v23;
      v27 = v24 - v23;
      v63 = v26;
      v28 = v25 + v22;
      v29 = v22 - v25;
      v57 = v25 + v22 + v63;
      v30 = (473 * (v22 - v25 + v27)) >> 8;
      v31 = v30 + ((-669 * v27) >> 8) - v57;
      v74 = v30;
      v32 = ((362 * (v28 - v63)) >> 8) - v31;
      *v8 = v77 + v57;
      v8[56] = v77 - v57;
      v33 = v31 + v83;
      v8[48] = v83 - v31;
      v34 = v32 + v79;
      v8[40] = v79 - v32;
      v35 = v32 + ((277 * v29) >> 8) - v74;
      v8[24] = v66 - v35;
      v5 = v54 + 1;
      v8[32] = v35 + v66;
      v7 = v81;
      v8[8] = v33;
      v8[16] = v34;
    }
    else
    {
      v10 = *v6 * *v5++;
      *v8 = v10;
      v8[8] = v10;
      v8[16] = v10;
      v8[24] = v10;
      v8[32] = v10;
      v8[40] = v10;
      v8[48] = v10;
      v8[56] = v10;
    }
    ++v6;
    v54 = v5;
    ++v8;
    --v59;
  }
  while ( v59 );
  v36 = (int *)v85;
  v69 = (int *)v85;
  v78 = 8;
  do
  {
    v37 = v36[2];
    v38 = (_BYTE *)(a5 + *a4);
    v58 = v36[7];
    v71 = v36[1];
    v55 = v36[6];
    v60 = v36[5];
    v39 = v36[4];
    v82 = v36[3];
    if ( v58 | v55 | v60 | v39 | v82 | v37 | v71 )
    {
      v41 = *v36;
      v42 = v41 + v39;
      v43 = v41 - v39;
      v44 = v37 + v55;
      v45 = 181 * (v37 - v55);
      v46 = v37 + v55 + v42;
      v47 = v42 - v44;
      v48 = (char)(v45 >> 7) - v44;
      v84 = v48 + v43;
      v80 = v43 - v48;
      v49 = v60 - v82;
      v64 = v82 + v60;
      v61 = v71 + v58;
      v72 = v71 - v58;
      v75 = (473 * (v49 + v72)) >> 8;
      v50 = v75 + ((-669 * v49) >> 8) - (v64 + v61);
      v56 = ((362 * (v61 - v64)) >> 8) - v50;
      v51 = v56 + ((277 * v72) >> 8) - v75;
      *v38 = *(_BYTE *)((((v46 + v64 + v61) >> 5) & 0x3FF) + v7);
      v38[7] = *(_BYTE *)((((v46 - (v64 + v61)) >> 5) & 0x3FF) + v7);
      v38[1] = *(_BYTE *)((((v50 + v84) >> 5) & 0x3FF) + v7);
      v38[6] = *(_BYTE *)((((v84 - v50) >> 5) & 0x3FF) + v7);
      v38[2] = *(_BYTE *)((((v80 + v56) >> 5) & 0x3FF) + v7);
      v38[5] = *(_BYTE *)((((v80 - v56) >> 5) & 0x3FF) + v7);
      v38[4] = *(_BYTE *)((((v51 + v47) >> 5) & 0x3FF) + v7);
      v36 = v69;
      v38[3] = *(_BYTE *)(v7 + (((v47 - v51) >> 5) & 0x3FF));
    }
    else
    {
      v40 = *(_BYTE *)(((*v36 >> 5) & 0x3FF) + v7);
      *v38 = v40;
      v38[1] = v40;
      v38[2] = v40;
      v38[3] = v40;
      v38[4] = v40;
      v38[5] = v40;
      v38[6] = v40;
      v38[7] = v40;
    }
    v36 += 8;
    result = v78 - 1;
    v52 = v78 == 1;
    v69 = v36;
    ++a4;
    --v78;
  }
  while ( !v52 );
  return result;
}

// sub_10045930 @ 0x10045930
int __cdecl sub_10045930(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  float *v6; // ecx
  int v7; // ebx
  float *v8; // eax
  __int16 v9; // si
  __int16 v10; // di
  double v11; // st7
  double v12; // st6
  double v13; // st7
  double v14; // st6
  double v15; // st7
  double v16; // st6
  double v17; // st5
  double v18; // st4
  double v19; // st6
  double v20; // st5
  float *v22; // esi
  double v23; // st7
  _BYTE *v24; // edi
  double v25; // st6
  double v26; // st7
  double v27; // st6
  double v28; // st5
  double v29; // st4
  int result; // eax
  float v31; // [esp+10h] [ebp-124h]
  float v32; // [esp+10h] [ebp-124h]
  float v33; // [esp+14h] [ebp-120h]
  float v34; // [esp+14h] [ebp-120h]
  float v35; // [esp+14h] [ebp-120h]
  float v36; // [esp+14h] [ebp-120h]
  float v37; // [esp+14h] [ebp-120h]
  float v38; // [esp+14h] [ebp-120h]
  float v39; // [esp+18h] [ebp-11Ch]
  float v40; // [esp+18h] [ebp-11Ch]
  float v41; // [esp+18h] [ebp-11Ch]
  float v42; // [esp+18h] [ebp-11Ch]
  float v43; // [esp+1Ch] [ebp-118h]
  float v44; // [esp+1Ch] [ebp-118h]
  float v45; // [esp+1Ch] [ebp-118h]
  float v46; // [esp+20h] [ebp-114h]
  float v47; // [esp+20h] [ebp-114h]
  float v48; // [esp+20h] [ebp-114h]
  int v49; // [esp+24h] [ebp-110h]
  float v50; // [esp+24h] [ebp-110h]
  float v51; // [esp+24h] [ebp-110h]
  float v52; // [esp+28h] [ebp-10Ch]
  float v53; // [esp+28h] [ebp-10Ch]
  int v54; // [esp+28h] [ebp-10Ch]
  float v55; // [esp+2Ch] [ebp-108h]
  float v56; // [esp+2Ch] [ebp-108h]
  float v57; // [esp+30h] [ebp-104h]
  float v58; // [esp+30h] [ebp-104h]
  char v59; // [esp+34h] [ebp-100h] BYREF
  char v60; // [esp+3Ch] [ebp-F8h] BYREF

  v6 = *(float **)(a2 + 80);
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v8 = (float *)&v59;
  v49 = 8;
  do
  {
    v9 = a3[56];
    v10 = a3[48];
    v11 = (double)*a3 * *v6;
    if ( (unsigned __int16)v9 | (unsigned __int16)(v10 | a3[40] | a3[32] | a3[24] | a3[16] | a3[8]) )
    {
      v52 = v6[16] * (double)a3[16];
      v12 = v6[32] * (double)a3[32];
      v46 = v6[48] * (double)v10;
      v39 = v12 + v11;
      v13 = v11 - v12;
      v14 = v46 + v52;
      v33 = (v52 - v46) * 1.4142135 - v14;
      v57 = v14 + v39;
      v47 = v39 - v14;
      v53 = v33 + v13;
      v15 = v13 - v33;
      v16 = v6[8] * (double)a3[8];
      v17 = v6[24] * (double)a3[24];
      v18 = v6[40] * (double)a3[40];
      v43 = v6[56] * (double)v9;
      v31 = v18 + v17;
      v40 = v18 - v17;
      v34 = v43 + v16;
      v19 = v16 - v43;
      v44 = v34 + v31;
      v20 = (v19 + v40) * 1.847759;
      v55 = v20 - v40 * 2.613126 - v44;
      v35 = (v34 - v31) * 1.4142135 - v55;
      v41 = v19 * 1.0823922 - v20 + v35;
      *v8 = v44 + v57;
      v8[56] = v57 - v44;
      v8[8] = v55 + v53;
      v8[48] = v53 - v55;
      v8[16] = v35 + v15;
      v8[40] = v15 - v35;
      v8[32] = v41 + v47;
      v8[24] = v47 - v41;
    }
    else
    {
      *v8 = v11;
      v8[8] = v11;
      v8[16] = v11;
      v8[24] = v11;
      v8[32] = v11;
      v8[40] = v11;
      v8[48] = v11;
      v8[56] = v11;
    }
    ++a3;
    ++v6;
    ++v8;
    --v49;
  }
  while ( v49 );
  v22 = (float *)&v60;
  v54 = 8;
  do
  {
    v23 = v22[2] + *(v22 - 2);
    v24 = (_BYTE *)(a5 + *a4);
    v50 = *(v22 - 2) - v22[2];
    v25 = v22[4] + *v22;
    v36 = (*v22 - v22[4]) * 1.4142135 - v25;
    v58 = v25 + v23;
    v26 = v23 - v25;
    v27 = v36 + v50;
    v48 = v50 - v36;
    v28 = v22[3] + v22[1];
    v29 = v22[3] - v22[1];
    v37 = v22[5] + *(v22 - 1);
    v51 = *(v22 - 1) - v22[5];
    v45 = v37 + v28;
    v32 = (v51 + v29) * 1.847759;
    v56 = v32 - v29 * 2.613126 - v45;
    v38 = (v37 - v28) * 1.4142135 - v56;
    v42 = v51 * 1.0823922 - v32 + v38;
    *v24 = *(_BYTE *)((((int)((__int64)(v45 + v58) + 4) >> 3) & 0x3FF) + v7);
    v24[7] = *(_BYTE *)((((int)((__int64)(v58 - v45) + 4) >> 3) & 0x3FF) + v7);
    v24[1] = *(_BYTE *)((((int)((__int64)(v56 + v27) + 4) >> 3) & 0x3FF) + v7);
    v24[6] = *(_BYTE *)((((int)((__int64)(v27 - v56) + 4) >> 3) & 0x3FF) + v7);
    v24[2] = *(_BYTE *)((((int)((__int64)(v38 + v48) + 4) >> 3) & 0x3FF) + v7);
    v24[5] = *(_BYTE *)((((int)((__int64)(v48 - v38) + 4) >> 3) & 0x3FF) + v7);
    v24[4] = *(_BYTE *)((((int)((__int64)(v42 + v26) + 4) >> 3) & 0x3FF) + v7);
    v24[3] = *(_BYTE *)((((int)((__int64)(v26 - v42) + 4) >> 3) & 0x3FF) + v7);
    v22 += 8;
    ++a4;
    result = --v54;
  }
  while ( v54 );
  return result;
}

// sub_10045D90 @ 0x10045D90
_BYTE *__cdecl sub_10045D90(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // edi
  int v6; // ebp
  _WORD *v7; // eax
  int v8; // edx
  int *v9; // ecx
  unsigned __int16 v10; // si
  __int16 v11; // dx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ebx
  __int16 v16; // bp
  int v17; // edx
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  bool v21; // cc
  _BYTE *result; // eax
  int v23; // edi
  int v24; // ebx
  _BYTE *v25; // ecx
  char v26; // dl
  int v27; // esi
  int v28; // eax
  int v29; // edx
  int v30; // esi
  int v31; // ebx
  int v32; // eax
  bool v33; // zf
  __int16 v34; // [esp+10h] [ebp-A0h]
  int v35; // [esp+10h] [ebp-A0h]
  __int16 v37; // [esp+14h] [ebp-9Ch]
  int v38; // [esp+14h] [ebp-9Ch]
  int v39; // [esp+14h] [ebp-9Ch]
  __int16 v40; // [esp+18h] [ebp-98h]
  int v41; // [esp+18h] [ebp-98h]
  __int16 v42; // [esp+1Ch] [ebp-94h]
  _BYTE *v43; // [esp+1Ch] [ebp-94h]
  int *v44; // [esp+20h] [ebp-90h]
  int v45; // [esp+20h] [ebp-90h]
  int v46; // [esp+24h] [ebp-8Ch]
  int v47; // [esp+24h] [ebp-8Ch]
  _WORD *v48; // [esp+28h] [ebp-88h]
  int v49; // [esp+2Ch] [ebp-84h]
  _BYTE v50[32]; // [esp+30h] [ebp-80h] BYREF
  _BYTE v51[96]; // [esp+50h] [ebp-60h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (_WORD *)(a3 + 96);
  v8 = 8;
  v9 = (int *)v51;
  v49 = v6;
  v46 = 8;
  v48 = (_WORD *)(a3 + 96);
  v44 = (int *)v51;
  do
  {
    if ( v8 != 4 )
    {
      v10 = v7[8];
      v42 = *(v7 - 24);
      v34 = *(v7 - 32);
      v37 = *(v7 - 40);
      v40 = *v7;
      v11 = *(v7 - 8);
      if ( v10 | (unsigned __int16)(v11 | v42 | v37 | *v7 | v34) )
      {
        v13 = (*v5 * (__int16)*(v7 - 48)) << 14;
        v14 = 15137 * (__int16)(v34 * v5[16]) - 6270 * (__int16)(v40 * v5[48]);
        v15 = v14 + v13;
        v35 = v13 - v14;
        LOWORD(v13) = v11 * v5[40];
        v16 = v37 * v5[8];
        v38 = (__int16)(v10 * v5[56]);
        v17 = (__int16)(v42 * v5[24]);
        v18 = v16;
        v19 = 8697 * v16 + 11893 * (__int16)v13 - 17799 * v17 - 1730 * v38;
        v6 = v49;
        v20 = 20995 * v18 + 7373 * v17 - 4926 * (__int16)v13 - 4176 * v38;
        v9 = v44;
        *(v44 - 8) = (v15 + v20 + 2048) >> 12;
        v44[8] = (v35 - v19 + 2048) >> 12;
        v7 = v48;
        v44[16] = (v15 - v20 + 2048) >> 12;
        *v44 = (v35 + v19 + 2048) >> 12;
      }
      else
      {
        v12 = 4 * *v5 * (__int16)*(v7 - 48);
        *(v9 - 8) = v12;
        *v9 = v12;
        v9[8] = v12;
        v9[16] = v12;
      }
    }
    ++v7;
    ++v9;
    ++v5;
    v8 = v46 - 1;
    v21 = v46 - 1 <= 0;
    v48 = v7;
    v44 = v9;
    --v46;
  }
  while ( !v21 );
  result = v50;
  v43 = v50;
  v45 = 4;
  do
  {
    v23 = *((_DWORD *)result + 3);
    v24 = *((_DWORD *)result + 7);
    v25 = (_BYTE *)(*a4 + a5);
    v47 = *((_DWORD *)result + 5);
    v41 = *((_DWORD *)result + 1);
    if ( *((_DWORD *)result + 6) | v24 | v47 | v23 | v41 | *((_DWORD *)result + 2) )
    {
      v27 = *(_DWORD *)result;
      v28 = 15137 * *((__int16 *)result + 4) - 6270 * *((__int16 *)result + 12);
      v39 = (__int16)v24;
      v27 <<= 14;
      v29 = v28 + v27;
      v30 = v27 - v28;
      v31 = 8697 * (__int16)v41 + 11893 * (__int16)v47 - 17799 * (__int16)v23 - 1730 * (__int16)v24;
      v6 = v49;
      v32 = 20995 * (__int16)v41 + 7373 * (__int16)v23 - 4926 * (__int16)v47 - 4176 * v39;
      *v25 = *(_BYTE *)((((v29 + v32 + 0x40000) >> 19) & 0x3FF) + v49);
      v25[3] = *(_BYTE *)((((v29 - v32 + 0x40000) >> 19) & 0x3FF) + v49);
      result = v43;
      v25[1] = *(_BYTE *)((((v30 + v31 + 0x40000) >> 19) & 0x3FF) + v49);
      v25[2] = *(_BYTE *)((((v30 - v31 + 0x40000) >> 19) & 0x3FF) + v49);
    }
    else
    {
      v26 = *(_BYTE *)((((*(_DWORD *)result + 16) >> 5) & 0x3FF) + v6);
      *v25 = v26;
      v25[1] = v26;
      v25[2] = v26;
      v25[3] = v26;
    }
    result += 32;
    v33 = v45 == 1;
    v43 = result;
    ++a4;
    --v45;
  }
  while ( !v33 );
  return result;
}

// sub_10046190 @ 0x10046190
int __cdecl sub_10046190(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // ecx
  int v6; // eax
  _WORD *v7; // edi
  _BYTE *v8; // ebx
  __int16 v9; // bp
  __int16 v10; // dx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  _BYTE *v15; // ecx
  _BYTE *v16; // edi
  char v17; // al
  int v18; // eax
  int v19; // esi
  bool v20; // zf
  int result; // eax
  int v22; // [esp+10h] [ebp-44h]
  _BYTE v23[64]; // [esp+14h] [ebp-40h] BYREF
  int v24; // [esp+58h] [ebp+4h]
  int v26; // [esp+5Ch] [ebp+8h]

  v5 = *(_DWORD **)(a2 + 80);
  v22 = *(_DWORD *)(a1 + 284) + 128;
  v6 = 8;
  v24 = 8;
  v7 = (_WORD *)(a3 + 48);
  v8 = (_BYTE *)(v23 - (_BYTE *)v5);
  do
  {
    if ( v6 != 6 && v6 != 4 && v6 != 2 )
    {
      v9 = v7[32];
      v10 = v7[16];
      v11 = (__int16)*(v7 - 24);
      if ( *v7 | (unsigned __int16)(*(v7 - 16) | v10 | v9) )
      {
        v13 = (*v5 * v11) << 15;
        v14 = 6967 * (__int16)(v10 * v5[40])
            - 5906 * (__int16)(v9 * v5[56])
            - 10426 * (__int16)(*v7 * v5[24])
            + 29692 * (__int16)(*(v7 - 16) * v5[8]);
        *(_DWORD *)((char *)v5 + (_DWORD)v8) = (v14 + v13 + 4096) >> 13;
        v12 = (v13 - v14 + 4096) >> 13;
      }
      else
      {
        v12 = 4 * *v5 * v11;
        *(_DWORD *)((char *)v5 + (_DWORD)v8) = v12;
      }
      *(_DWORD *)((char *)v5 + (_DWORD)v8 + 32) = v12;
      v6 = v24;
    }
    ++v7;
    ++v5;
    v24 = --v6;
  }
  while ( v6 > 0 );
  v15 = v23;
  v26 = 2;
  do
  {
    v16 = (_BYTE *)(*a4 + a5);
    if ( *((_DWORD *)v15 + 7) | *((_DWORD *)v15 + 5) | *((_DWORD *)v15 + 1) | *((_DWORD *)v15 + 3) )
    {
      v18 = *(_DWORD *)v15 << 15;
      v19 = 6967 * *((__int16 *)v15 + 10)
          + 29692 * *((__int16 *)v15 + 2)
          - 5906 * *((__int16 *)v15 + 14)
          - 10426 * *((__int16 *)v15 + 6);
      *v16 = *(_BYTE *)((((v19 + v18 + 0x80000) >> 20) & 0x3FF) + v22);
      v17 = *(_BYTE *)((((v18 - v19 + 0x80000) >> 20) & 0x3FF) + v22);
    }
    else
    {
      v17 = *(_BYTE *)((((*(_DWORD *)v15 + 16) >> 5) & 0x3FF) + v22);
      *v16 = v17;
    }
    v16[1] = v17;
    v15 += 32;
    result = v26 - 1;
    v20 = v26 == 1;
    ++a4;
    --v26;
  }
  while ( !v20 );
  return result;
}

// sub_100463C0 @ 0x100463C0
char __cdecl sub_100463C0(int a1, int a2, unsigned __int16 *a3, _DWORD *a4, int a5)
{
  char result; // al

  result = *(_BYTE *)((((*a3 * **(_DWORD **)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD *)(a1 + 284) + 128);
  *(_BYTE *)(*a4 + a5) = result;
  return result;
}

// sub_10046400 @ 0x10046400
int __cdecl sub_10046400(int a1, int *a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // esi
  _DWORD v7[14]; // [esp+8h] [ebp-38h] BYREF

  v7[1] = a4;
  v7[0] = a3;
  v4 = *a2;
  v7[3] = a1;
  v7[4] = v4;
  v7[8] = 0;
  v7[9] = 0;
  result = sub_100475B0(v7, a113_0, 56);
  if ( !result )
  {
    v6 = sub_100475D0(v7, 4);
    if ( v6 == 1 )
    {
      *a2 = v7[5];
      return sub_100473F0(v7);
    }
    else
    {
      sub_100473F0(v7);
      result = -5;
      if ( v6 )
        return v6;
    }
  }
  return result;
}

// sub_100464A0 @ 0x100464A0
int __cdecl sub_100464A0(_DWORD *a1, int a2)
{
  unsigned int v2; // eax
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // esi
  unsigned int v11; // edx
  int v12; // ecx
  int v13; // ecx
  unsigned int v14; // edi
  _DWORD *v15; // eax
  int v16; // edx
  unsigned int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // esi
  unsigned int v21; // edx
  int v22; // ecx
  int v23; // ecx
  unsigned int v24; // edi
  _DWORD *v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // eax
  int v29; // esi
  unsigned int v30; // edx
  int v31; // ecx
  int v32; // ecx
  unsigned int v33; // edi
  _DWORD *v34; // eax
  int v36; // eax
  int v37; // [esp+10h] [ebp-4h]

  v37 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v37 = a1[3] - 5;
  while ( 1 )
  {
    v2 = a1[27];
    if ( v2 <= 1 )
    {
      sub_10046740(a1);
      v2 = a1[27];
      if ( !v2 )
        break;
    }
    v3 = a1[25];
    a1[27] = 0;
    v4 = v2 + v3 == 0;
    a1[25] = v2 + v3;
    v5 = a1[21];
    v6 = a1[25];
    v7 = v5 + v37;
    if ( !v4 && v6 < v7 )
      goto LABEL_43;
    a1[25] = v7;
    a1[27] = v6 - v7;
    if ( v5 < 0 )
      v8 = 0;
    else
      v8 = v5 + a1[12];
    sub_10047B90(a1, v8, v37, 0);
    v9 = *a1;
    a1[21] = a1[25];
    v10 = *(_DWORD *)(v9 + 28);
    v11 = *(_DWORD *)(v10 + 20);
    if ( v11 > *(_DWORD *)(v9 + 16) )
      v11 = *(_DWORD *)(v9 + 16);
    if ( v11 )
    {
      qmemcpy(*(void **)(v9 + 12), *(const void **)(v10 + 16), v11);
      v12 = *(_DWORD *)(v9 + 28);
      *(_DWORD *)(v9 + 12) += v11;
      *(_DWORD *)(v12 + 16) += v11;
      v13 = *(_DWORD *)(v9 + 28);
      v14 = *(_DWORD *)(v9 + 16) - v11;
      *(_DWORD *)(v9 + 20) += v11;
      *(_DWORD *)(v9 + 16) = v14;
      *(_DWORD *)(v13 + 20) -= v11;
      v15 = *(_DWORD **)(v9 + 28);
      if ( !v15[5] )
        v15[4] = v15[2];
    }
    if ( *(_DWORD *)(*a1 + 16) )
    {
LABEL_43:
      v16 = a1[21];
      v17 = a1[25] - v16;
      if ( v17 < a1[9] - 262 )
        continue;
      if ( v16 < 0 )
        v18 = 0;
      else
        v18 = v16 + a1[12];
      sub_10047B90(a1, v18, v17, 0);
      v19 = *a1;
      a1[21] = a1[25];
      v20 = *(_DWORD *)(v19 + 28);
      v21 = *(_DWORD *)(v20 + 20);
      if ( v21 > *(_DWORD *)(v19 + 16) )
        v21 = *(_DWORD *)(v19 + 16);
      if ( v21 )
      {
        qmemcpy(*(void **)(v19 + 12), *(const void **)(v20 + 16), v21);
        v22 = *(_DWORD *)(v19 + 28);
        *(_DWORD *)(v19 + 12) += v21;
        *(_DWORD *)(v22 + 16) += v21;
        v23 = *(_DWORD *)(v19 + 28);
        v24 = *(_DWORD *)(v19 + 16) - v21;
        *(_DWORD *)(v19 + 20) += v21;
        *(_DWORD *)(v19 + 16) = v24;
        *(_DWORD *)(v23 + 20) -= v21;
        v25 = *(_DWORD **)(v19 + 28);
        if ( !v25[5] )
          v25[4] = v25[2];
      }
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v26 = a1[21];
  if ( v26 < 0 )
    v27 = 0;
  else
    v27 = v26 + a1[12];
  sub_10047B90(a1, v27, a1[25] - v26, a2 == 4);
  a1[21] = a1[25];
  v28 = *a1;
  v29 = *(_DWORD *)(*a1 + 28);
  v30 = *(_DWORD *)(v29 + 20);
  if ( v30 > *(_DWORD *)(*a1 + 16) )
    v30 = *(_DWORD *)(*a1 + 16);
  if ( v30 )
  {
    qmemcpy(*(void **)(v28 + 12), *(const void **)(v29 + 16), v30);
    v31 = *(_DWORD *)(v28 + 28);
    *(_DWORD *)(v28 + 12) += v30;
    *(_DWORD *)(v31 + 16) += v30;
    v32 = *(_DWORD *)(v28 + 28);
    v33 = *(_DWORD *)(v28 + 16) - v30;
    *(_DWORD *)(v28 + 20) += v30;
    *(_DWORD *)(v28 + 16) = v33;
    *(_DWORD *)(v32 + 20) -= v30;
    v34 = *(_DWORD **)(v28 + 28);
    if ( !v34[5] )
      v34[4] = v34[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v36 = -(a2 != 4);
  LOBYTE(v36) = v36 & 0xFE;
  return v36 + 3;
}

// sub_10046740 @ 0x10046740
unsigned int __cdecl sub_10046740(int a1)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  int v4; // esi
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // esi
  int v9; // ecx
  _WORD *v10; // ecx
  __int16 v11; // ax
  unsigned int v12; // esi
  _WORD *v13; // ecx
  __int16 v14; // ax
  _DWORD *v15; // ebp
  unsigned int result; // eax
  char *v17; // edi
  unsigned int v18; // esi
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // ecx
  int v22; // esi
  char v23; // al
  char *v24; // edi
  const void *v25; // esi
  int v26; // ecx
  unsigned int v27; // ebp
  unsigned __int8 *v28; // edi
  int v29; // esi
  int v30; // ecx
  unsigned int v31; // [esp+10h] [ebp-4h]
  unsigned int v32; // [esp+18h] [ebp+4h]
  int v33; // [esp+18h] [ebp+4h]
  unsigned int v34; // [esp+18h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 36);
  v31 = v2;
  do
  {
    v3 = *(_DWORD *)(a1 + 100);
    v4 = *(_DWORD *)(a1 + 108);
    v5 = *(_DWORD *)(a1 + 52) - v3 - v4;
    v32 = v5;
    if ( v5 )
    {
      if ( v5 == -1 )
      {
        v33 = -2;
        goto LABEL_20;
      }
    }
    else if ( !v3 && !v4 )
    {
      v33 = v2;
LABEL_20:
      v5 = v33;
      goto LABEL_21;
    }
    if ( v3 >= v2 + *(_DWORD *)(a1 + 36) - 262 )
    {
      qmemcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + v2), v2);
      v6 = *(_DWORD *)(a1 + 84);
      v7 = *(_DWORD *)(a1 + 100) - v2;
      *(_DWORD *)(a1 + 104) -= v2;
      v8 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 100) = v7;
      v9 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 84) = v6 - v2;
      v10 = (_WORD *)(v9 + 2 * v8);
      do
      {
        if ( (unsigned __int16)*--v10 < v2 )
          v11 = 0;
        else
          v11 = *v10 - v2;
        --v8;
        *v10 = v11;
      }
      while ( v8 );
      v12 = v2;
      v13 = (_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v2);
      do
      {
        if ( (unsigned __int16)*--v13 < v2 )
          v14 = 0;
        else
          v14 = *v13 - v2;
        --v12;
        *v13 = v14;
      }
      while ( v12 );
      v33 = v2 + v32;
      goto LABEL_20;
    }
LABEL_21:
    v15 = *(_DWORD **)a1;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
    if ( !result )
      break;
    v17 = (char *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 108));
    v18 = v15[1];
    v34 = v18;
    if ( v18 > v5 )
    {
      v34 = v5;
      v18 = v5;
    }
    if ( v18 )
    {
      v19 = v15[7];
      v15[1] -= v18;
      if ( !*(_DWORD *)(v19 + 24) )
      {
        v20 = sub_10049190(v15[12], *v15, v18);
        v2 = v31;
        v15[12] = v20;
      }
      v21 = v18;
      v22 = *v15;
      v23 = v21;
      v21 >>= 2;
      qmemcpy(v17, (const void *)*v15, 4 * v21);
      v25 = (const void *)(v22 + 4 * v21);
      v24 = &v17[4 * v21];
      LOBYTE(v21) = v23;
      result = v34;
      qmemcpy(v24, v25, v21 & 3);
      v26 = v15[2];
      *v15 += v34;
      v15[2] = v34 + v26;
    }
    else
    {
      result = 0;
    }
    v27 = result + *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 108) = v27;
    if ( v27 >= 3 )
    {
      v28 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      v29 = *v28;
      v30 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)(a1 + 64) = v29;
      result = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a1 + 64) = result & (v28[1] ^ (v29 << v30));
    }
    if ( v27 >= 0x106 )
      break;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  while ( result );
  return result;
}

// sub_100468E0 @ 0x100468E0
int __cdecl sub_100468E0(_DWORD *a1, int a2)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  char v7; // cl
  __int16 v8; // ax
  unsigned __int16 v9; // ax
  int v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // ebx
  BOOL v15; // esi
  int v16; // edi
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // ecx
  int v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  int v28; // eax
  int v29; // eax
  int v30; // esi
  unsigned int v31; // edx
  int v32; // ecx
  int v33; // ecx
  unsigned int v34; // edi
  _DWORD *v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // eax
  int v39; // esi
  unsigned int v40; // edx
  int v41; // ecx
  int v42; // ecx
  unsigned int v43; // edi
  _DWORD *v44; // eax
  int v46; // eax
  int v47; // [esp+10h] [ebp-8h]

  v2 = 0;
  v47 = 0;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 < 0x106 )
    {
      sub_10046740((int)a1);
      v3 = a1[27];
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = a1[25];
      HIWORD(v2) = 0;
      v5 = a1[15];
      v6 = a1[19] & (*(unsigned __int8 *)(a1[12] + v4 + 2) ^ (a1[16] << a1[20]));
      a1[16] = v6;
      LOWORD(v2) = *(_WORD *)(v5 + 2 * v6);
      v47 = (unsigned __int16)v2;
      *(_WORD *)(a1[14] + 2 * (v4 & a1[11])) = v2;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    if ( v2 && a1[25] - v2 <= (unsigned int)(a1[9] - 262) && a1[32] != 2 )
      a1[22] = sub_10046D00(a1, v2);
    if ( a1[22] < 3u )
    {
      v26 = *(_BYTE *)(a1[25] + a1[12]);
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v26;
      ++LOWORD(a1[v26 + 35]);
      v15 = a1[1446] == a1[1445] - 1;
      --a1[27];
    }
    else
    {
      v7 = a1[22];
      v8 = *((_WORD *)a1 + 50) - *((_WORD *)a1 + 52);
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v8;
      v9 = v8 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v7 - 3;
      v10 = (unsigned __int8)byte_10051268[(unsigned __int8)(v7 - 3)];
      ++LOWORD(a1[v10 + 292]);
      if ( v9 >= 0x100u )
        v11 = (unsigned __int8)byte_10051168[v9 >> 7];
      else
        v11 = (unsigned __int8)byte_10051068[v9];
      ++LOWORD(a1[v11 + 608]);
      v12 = a1[22];
      v13 = a1[30];
      v14 = a1[27] - v12;
      v15 = a1[1446] == a1[1445] - 1;
      a1[27] = v14;
      if ( v12 > v13 || v14 < 3 )
      {
        v22 = v12 + a1[25];
        v23 = (unsigned __int8 *)(v22 + a1[12]);
        a1[25] = v22;
        v24 = a1[20];
        a1[22] = 0;
        v25 = *v23;
        a1[16] = v25;
        a1[16] = a1[19] & (v23[1] ^ (v25 << v24));
        goto LABEL_24;
      }
      a1[22] = v12 - 1;
      do
      {
        v16 = a1[16];
        v17 = a1[25] + 1;
        a1[25] = v17;
        v18 = v17;
        v19 = a1[15];
        v20 = a1[19] & ((v16 << a1[20]) ^ *(unsigned __int8 *)(v17 + a1[12] + 2));
        HIWORD(v2) = 0;
        a1[16] = v20;
        LOWORD(v2) = *(_WORD *)(v19 + 2 * v20);
        v47 = (unsigned __int16)v2;
        *(_WORD *)(a1[14] + 2 * (a1[11] & v18)) = v2;
        *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        v21 = a1[22] - 1;
        a1[22] = v21;
      }
      while ( v21 );
    }
    ++a1[25];
LABEL_24:
    if ( v15 )
    {
      v27 = a1[21];
      if ( v27 < 0 )
        v28 = 0;
      else
        v28 = a1[12] + v27;
      sub_10047B90(a1, v28, a1[25] - v27, 0);
      a1[21] = a1[25];
      v29 = *a1;
      v30 = *(_DWORD *)(*a1 + 28);
      v31 = *(_DWORD *)(v30 + 20);
      if ( v31 > *(_DWORD *)(*a1 + 16) )
        v31 = *(_DWORD *)(*a1 + 16);
      if ( v31 )
      {
        qmemcpy(*(void **)(v29 + 12), *(const void **)(v30 + 16), v31);
        v32 = *(_DWORD *)(v29 + 28);
        *(_DWORD *)(v29 + 12) += v31;
        *(_DWORD *)(v32 + 16) += v31;
        v33 = *(_DWORD *)(v29 + 28);
        v34 = *(_DWORD *)(v29 + 16) - v31;
        *(_DWORD *)(v29 + 20) += v31;
        *(_DWORD *)(v29 + 16) = v34;
        *(_DWORD *)(v33 + 20) -= v31;
        v35 = *(_DWORD **)(v29 + 28);
        if ( !v35[5] )
          v35[4] = v35[2];
        v2 = v47;
      }
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
  }
  v36 = a1[21];
  if ( v36 < 0 )
    v37 = 0;
  else
    v37 = v36 + a1[12];
  sub_10047B90(a1, v37, a1[25] - v36, a2 == 4);
  a1[21] = a1[25];
  v38 = *a1;
  v39 = *(_DWORD *)(*a1 + 28);
  v40 = *(_DWORD *)(v39 + 20);
  if ( v40 > *(_DWORD *)(*a1 + 16) )
    v40 = *(_DWORD *)(*a1 + 16);
  if ( v40 )
  {
    qmemcpy(*(void **)(v38 + 12), *(const void **)(v39 + 16), v40);
    v41 = *(_DWORD *)(v38 + 28);
    *(_DWORD *)(v38 + 12) += v40;
    *(_DWORD *)(v41 + 16) += v40;
    v42 = *(_DWORD *)(v38 + 28);
    v43 = *(_DWORD *)(v38 + 16) - v40;
    *(_DWORD *)(v38 + 20) += v40;
    *(_DWORD *)(v38 + 16) = v43;
    *(_DWORD *)(v42 + 20) -= v40;
    v44 = *(_DWORD **)(v38 + 28);
    if ( !v44[5] )
      v44[4] = v44[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v46 = -(a2 != 4);
  LOBYTE(v46) = v46 & 0xFE;
  return v46 + 3;
}

// sub_10046D00 @ 0x10046D00
unsigned int __cdecl sub_10046D00(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // ebx
  _BYTE *v10; // edx
  char v11; // al
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // edx
  char v15; // al
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // edx
  char v19; // al
  _BYTE *v20; // edx
  char v21; // al
  _BYTE *v22; // edx
  char v23; // al
  _BYTE *v24; // edx
  char v25; // al
  _BYTE *v26; // edx
  char v27; // al
  _BYTE *v28; // edx
  char v29; // al
  _BYTE *v30; // edx
  int v31; // edx
  unsigned int result; // eax
  char v33; // [esp+13h] [ebp-11h]
  unsigned int v34; // [esp+14h] [ebp-10h]
  int v35; // [esp+18h] [ebp-Ch]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]
  char v38; // [esp+28h] [ebp+4h]

  v3 = a1[9];
  v4 = a1[25];
  v5 = a1[28];
  v34 = a1[29];
  v6 = a1[34];
  v7 = (_BYTE *)(v4 + a1[12]);
  v35 = v6;
  if ( v4 <= v3 - 262 )
    v36 = 0;
  else
    v36 = v4 - v3 + 262;
  v8 = v7 + 258;
  v38 = v7[v5 - 1];
  v33 = v7[v5];
  if ( v5 >= a1[33] )
    v34 >>= 2;
  v37 = a1[27];
  if ( v6 > v37 )
    v35 = a1[27];
  do
  {
    v10 = (_BYTE *)(a2 + a1[12]);
    if ( v10[v5] == v33 && v10[v5 - 1] == v38 && *v10 == *v7 )
    {
      v11 = v10[1];
      v12 = v10 + 1;
      if ( v11 == v7[1] )
      {
        v13 = v7 + 2;
        v14 = v12 + 1;
        do
        {
          v15 = *++v13;
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *++v13;
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *++v13;
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *++v13;
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *++v13;
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *++v13;
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *++v13;
          v28 = v26 + 1;
          if ( v27 != *v28 )
            break;
          v29 = *++v13;
          v14 = v28 + 1;
          if ( v29 != *v14 )
            break;
        }
        while ( v13 < v8 );
        v30 = v13;
        v7 = v8 - 258;
        v31 = v30 - v8 + 258;
        if ( v31 > (int)v5 )
        {
          a1[26] = a2;
          v5 = v31;
          if ( v31 >= v35 )
            break;
          v38 = v7[v31 - 1];
          v33 = v7[v31];
        }
      }
    }
    a2 = *(unsigned __int16 *)(a1[14] + 2 * (a2 & a1[11]));
    if ( (unsigned __int16)a2 <= v36 )
      break;
    --v34;
  }
  while ( v34 );
  result = v37;
  if ( v5 <= v37 )
    return v5;
  return result;
}

// sub_10046E70 @ 0x10046E70
int __cdecl sub_10046E70(_DWORD *a1, int a2)
{
  unsigned int v3; // eax
  int v4; // esi
  int v5; // edx
  int v6; // eax
  unsigned __int16 v7; // cx
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // edi
  __int16 v12; // ax
  unsigned __int16 v13; // ax
  int v14; // eax
  int v15; // eax
  BOOL v16; // ebp
  unsigned int v17; // ecx
  unsigned int v18; // esi
  int v19; // edx
  int v20; // eax
  unsigned __int16 v21; // cx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  int v27; // eax
  int v28; // esi
  unsigned int v29; // edx
  int v30; // ecx
  int v31; // ecx
  unsigned int v32; // edi
  _DWORD *v33; // eax
  unsigned __int8 v34; // al
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // esi
  unsigned int v39; // edx
  int v40; // ecx
  int v41; // ecx
  unsigned int v42; // edi
  _DWORD *v43; // eax
  int v44; // ecx
  int v45; // edx
  int v46; // ecx
  int v47; // eax
  int v48; // esi
  int v49; // eax
  int v50; // eax
  int v51; // esi
  unsigned int v52; // edx
  int v53; // ecx
  int v54; // ecx
  unsigned int v55; // edi
  _DWORD *v56; // eax
  int v58; // eax
  int v59; // [esp+10h] [ebp-8h]
  unsigned __int8 v60; // [esp+1Ch] [ebp+4h]
  unsigned __int8 v61; // [esp+1Ch] [ebp+4h]

  v59 = 0;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 < 0x106 )
    {
      sub_10046740((int)a1);
      v3 = a1[27];
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = a1[25];
      v5 = a1[15];
      v6 = a1[19] & (*(unsigned __int8 *)(a1[12] + v4 + 2) ^ (a1[16] << a1[20]));
      a1[16] = v6;
      v7 = *(_WORD *)(v5 + 2 * v6);
      v59 = v7;
      *(_WORD *)(a1[14] + 2 * (v4 & a1[11])) = v7;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    v8 = a1[26];
    a1[28] = a1[22];
    a1[23] = v8;
    a1[22] = 2;
    if ( v59 && a1[28] < a1[30] && a1[25] - v59 <= (unsigned int)(a1[9] - 262) )
    {
      if ( a1[32] != 2 )
        a1[22] = sub_10046D00(a1, v59);
      v9 = a1[22];
      if ( v9 <= 5 && (a1[32] == 1 || v9 == 3 && (unsigned int)(a1[25] - a1[26]) > 0x1000) )
        a1[22] = 2;
    }
    v10 = a1[28];
    if ( v10 < 3 || a1[22] > v10 )
    {
      if ( a1[24] )
      {
        v34 = *(_BYTE *)(a1[25] + a1[12] - 1);
        *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
        *(_BYTE *)(a1[1444] + a1[1446]++) = v34;
        ++LOWORD(a1[v34 + 35]);
        if ( a1[1446] == a1[1445] - 1 )
        {
          v35 = a1[21];
          if ( v35 < 0 )
            v36 = 0;
          else
            v36 = a1[12] + v35;
          sub_10047B90(a1, v36, a1[25] - v35, 0);
          a1[21] = a1[25];
          v37 = *a1;
          v38 = *(_DWORD *)(*a1 + 28);
          v39 = *(_DWORD *)(v38 + 20);
          if ( v39 > *(_DWORD *)(*a1 + 16) )
            v39 = *(_DWORD *)(*a1 + 16);
          if ( v39 )
          {
            qmemcpy(*(void **)(v37 + 12), *(const void **)(v38 + 16), v39);
            v40 = *(_DWORD *)(v37 + 28);
            *(_DWORD *)(v37 + 12) += v39;
            *(_DWORD *)(v40 + 16) += v39;
            v41 = *(_DWORD *)(v37 + 28);
            v42 = *(_DWORD *)(v37 + 16) - v39;
            *(_DWORD *)(v37 + 20) += v39;
            *(_DWORD *)(v37 + 16) = v42;
            *(_DWORD *)(v41 + 20) -= v39;
            v43 = *(_DWORD **)(v37 + 28);
            if ( !v43[5] )
              v43[4] = v43[2];
          }
        }
        v44 = a1[27] - 1;
        ++a1[25];
        v45 = *a1;
        a1[27] = v44;
        if ( !*(_DWORD *)(v45 + 16) )
          return 0;
      }
      else
      {
        v46 = a1[25] + 1;
        v47 = a1[27] - 1;
        a1[24] = 1;
        a1[25] = v46;
        a1[27] = v47;
      }
    }
    else
    {
      v11 = a1[25] + a1[27] - 3;
      v60 = v10 - 3;
      v12 = *((_WORD *)a1 + 50) - *((_WORD *)a1 + 46) - 1;
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v12;
      v13 = v12 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v60;
      ++LOWORD(a1[(unsigned __int8)byte_10051268[v60] + 292]);
      if ( v13 >= 0x100u )
        v14 = (unsigned __int8)byte_10051168[v13 >> 7];
      else
        v14 = (unsigned __int8)byte_10051068[v13];
      ++LOWORD(a1[v14 + 608]);
      v15 = a1[28];
      v16 = a1[1446] == a1[1445] - 1;
      a1[27] += 1 - v15;
      a1[28] = v15 - 2;
      do
      {
        v17 = a1[25] + 1;
        v18 = v17;
        a1[25] = v17;
        if ( v17 <= v11 )
        {
          v19 = a1[15];
          v20 = a1[19] & (*(unsigned __int8 *)(a1[12] + v17 + 2) ^ (a1[16] << a1[20]));
          a1[16] = v20;
          v21 = *(_WORD *)(v19 + 2 * v20);
          v59 = v21;
          *(_WORD *)(a1[14] + 2 * (v18 & a1[11])) = v21;
          *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        }
        v22 = a1[28] - 1;
        a1[28] = v22;
      }
      while ( v22 );
      v23 = a1[25];
      a1[24] = 0;
      ++v23;
      a1[22] = 2;
      a1[25] = v23;
      v24 = v23;
      if ( v16 )
      {
        v25 = a1[21];
        if ( v25 < 0 )
          v26 = 0;
        else
          v26 = v25 + a1[12];
        sub_10047B90(a1, v26, v24 - v25, 0);
        a1[21] = a1[25];
        v27 = *a1;
        v28 = *(_DWORD *)(*a1 + 28);
        v29 = *(_DWORD *)(v28 + 20);
        if ( v29 > *(_DWORD *)(*a1 + 16) )
          v29 = *(_DWORD *)(*a1 + 16);
        if ( v29 )
        {
          qmemcpy(*(void **)(v27 + 12), *(const void **)(v28 + 16), v29);
          v30 = *(_DWORD *)(v27 + 28);
          *(_DWORD *)(v27 + 12) += v29;
          *(_DWORD *)(v30 + 16) += v29;
          v31 = *(_DWORD *)(v27 + 28);
          v32 = *(_DWORD *)(v27 + 16) - v29;
          *(_DWORD *)(v27 + 20) += v29;
          *(_DWORD *)(v27 + 16) = v32;
          *(_DWORD *)(v31 + 20) -= v29;
          v33 = *(_DWORD **)(v27 + 28);
          if ( !v33[5] )
            v33[4] = v33[2];
        }
        if ( !*(_DWORD *)(*a1 + 16) )
          return 0;
      }
    }
  }
  if ( a1[24] )
  {
    v61 = *(_BYTE *)(a1[25] + a1[12] - 1);
    *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
    *(_BYTE *)(a1[1444] + a1[1446]++) = v61;
    ++LOWORD(a1[v61 + 35]);
    a1[24] = 0;
  }
  v48 = a1[21];
  if ( v48 < 0 )
    v49 = 0;
  else
    v49 = v48 + a1[12];
  sub_10047B90(a1, v49, a1[25] - v48, a2 == 4);
  a1[21] = a1[25];
  v50 = *a1;
  v51 = *(_DWORD *)(*a1 + 28);
  v52 = *(_DWORD *)(v51 + 20);
  if ( v52 > *(_DWORD *)(*a1 + 16) )
    v52 = *(_DWORD *)(*a1 + 16);
  if ( v52 )
  {
    qmemcpy(*(void **)(v50 + 12), *(const void **)(v51 + 16), v52);
    v53 = *(_DWORD *)(v50 + 28);
    *(_DWORD *)(v50 + 12) += v52;
    *(_DWORD *)(v53 + 16) += v52;
    v54 = *(_DWORD *)(v50 + 28);
    v55 = *(_DWORD *)(v50 + 16) - v52;
    *(_DWORD *)(v50 + 20) += v52;
    *(_DWORD *)(v50 + 16) = v55;
    *(_DWORD *)(v54 + 20) -= v52;
    v56 = *(_DWORD **)(v50 + 28);
    if ( !v56[5] )
      v56[4] = v56[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v58 = -(a2 != 4);
  LOBYTE(v58) = v58 & 0xFE;
  return v58 + 3;
}

// sub_100473F0 @ 0x100473F0
int __cdecl sub_100473F0(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 || !a1[9] )
    return -2;
  v2 = *(_DWORD *)(v1 + 20);
  if ( v2 )
    sub_1004A100(v2, a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

// sub_10047440 @ 0x10047440
int __cdecl sub_10047440(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  void (__cdecl *v9)(_DWORD, _DWORD); // ecx
  int v10; // eax
  int v11; // eax

  if ( !a3 || *a3 != a113_0[0] || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v5 = a1[8];
  a1[6] = 0;
  if ( !v5 )
  {
    a1[8] = FUN_10047a00;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = FUN_10047a20;
  v6 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  a1[7] = v6;
  if ( !v6 )
    return -4;
  v7 = a2;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    v7 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( v7 < 8 || v7 > 15 )
  {
    v10 = a1[7];
    if ( v10 && a1[9] )
    {
      v11 = *(_DWORD *)(v10 + 20);
      if ( v11 )
        sub_1004A100(v11, a1);
      ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
      a1[7] = 0;
    }
    return -2;
  }
  else
  {
    *(_DWORD *)(a1[7] + 16) = v7;
    *(_DWORD *)(a1[7] + 20) = sub_10049340(a1, *(_DWORD *)(a1[7] + 12) == 0 ? sub_10049190 : 0, 1 << v7);
    v8 = (_DWORD *)a1[7];
    if ( v8[5] )
    {
      if ( v8 )
      {
        a1[5] = 0;
        a1[2] = 0;
        a1[6] = 0;
        *v8 = v8[3] != 0 ? 7 : 0;
        sub_100492C0(*(_DWORD *)(a1[7] + 20), a1, 0);
      }
      return 0;
    }
    else
    {
      if ( v8 )
      {
        v9 = (void (__cdecl *)(_DWORD, _DWORD))a1[9];
        if ( v9 )
        {
          v9(a1[10], a1[7]);
          a1[7] = 0;
        }
      }
      return -4;
    }
  }
}

// sub_100475B0 @ 0x100475B0
int __cdecl sub_100475B0(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_10047440(a1, 15, a2, a3);
}

// sub_100475D0 @ 0x100475D0
int __cdecl sub_100475D0(unsigned __int8 **a1, int a2)
{
  int v2; // edi
  unsigned int v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // eax
  int v7; // ecx
  unsigned __int8 *v8; // edx
  unsigned __int8 *v9; // edx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // ebx
  int v12; // ecx
  unsigned __int8 *v13; // eax
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // edx
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // ecx
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // ecx
  int v24; // edx
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // edx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v30; // ecx
  unsigned __int8 *v31; // ecx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // edx
  unsigned __int8 *v34; // edx
  unsigned __int8 *v35; // eax
  unsigned __int8 *v36; // ecx
  unsigned __int8 *v37; // eax
  unsigned __int8 *v38; // ecx
  int v39; // edx
  unsigned __int8 *v40; // eax
  unsigned __int8 *v41; // eax
  unsigned __int8 *v42; // eax
  unsigned int v43; // [esp+18h] [ebp+8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  v2 = -5;
  v3 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v43 = v3;
  while ( 2 )
  {
    v4 = a1[7];
    switch ( *(_DWORD *)v4 )
    {
      case 0:
        v5 = a1[1];
        if ( !v5 )
          return v2;
        a1[1] = v5 - 1;
        v2 = v3;
        ++a1[2];
        *((_DWORD *)v4 + 1) = **a1;
        v6 = a1[7];
        v7 = *((_DWORD *)v6 + 1) & 0xF;
        ++*a1;
        if ( (_BYTE)v7 != 8 )
        {
          *(_DWORD *)v6 = 13;
          v8 = a1[7];
          a1[6] = (unsigned __int8 *)aUnknownCompres_1;
          *((_DWORD *)v8 + 1) = 5;
          continue;
        }
        if ( (unsigned int)((*((_DWORD *)v6 + 1) >> 4) + 8) > *((_DWORD *)v6 + 4) )
        {
          *(_DWORD *)v6 = 13;
          v9 = a1[7];
          a1[6] = (unsigned __int8 *)aInvalidWindowS_0;
          *((_DWORD *)v9 + 1) = 5;
          continue;
        }
        *(_DWORD *)v6 = 1;
LABEL_12:
        v10 = a1[1];
        if ( !v10 )
          return v2;
        a1[1] = v10 - 1;
        v2 = v3;
        v11 = a1[7];
        ++a1[2];
        v12 = *(*a1)++;
        if ( (v12 + (*((_DWORD *)v11 + 1) << 8)) % 0x1Fu )
        {
          *(_DWORD *)v11 = 13;
          v13 = a1[7];
          v3 = v43;
          a1[6] = (unsigned __int8 *)aIncorrectHeade_0;
          *((_DWORD *)v13 + 1) = 5;
          continue;
        }
        if ( (v12 & 0x20) == 0 )
        {
          *(_DWORD *)v11 = 7;
          v3 = v43;
          continue;
        }
        v3 = v43;
        *(_DWORD *)a1[7] = 2;
LABEL_35:
        v28 = a1[1];
        if ( !v28 )
          return v2;
        v30 = *a1;
        ++a1[2];
        a1[1] = v28 - 1;
        v2 = v3;
        *((_DWORD *)a1[7] + 2) = *v30 << 24;
        v31 = a1[7];
        ++*a1;
        *(_DWORD *)v31 = 3;
LABEL_38:
        v32 = a1[1];
        if ( !v32 )
          return v2;
        v33 = *a1;
        a1[1] = v32 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v33 << 16;
        v34 = a1[7];
        ++*a1;
        *(_DWORD *)v34 = 4;
LABEL_41:
        v35 = a1[1];
        if ( !v35 )
          return v2;
        v36 = *a1;
        a1[1] = v35 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v36 << 8;
        ++*a1;
        *(_DWORD *)a1[7] = 5;
LABEL_44:
        v37 = a1[1];
        if ( !v37 )
          return v2;
        v38 = *a1;
        v39 = (int)(a1[2] + 1);
        a1[1] = v37 - 1;
        v40 = a1[7];
        a1[2] = (unsigned __int8 *)v39;
        *((_DWORD *)v40 + 2) += *v38;
        ++*a1;
        v41 = a1[7];
        a1[12] = (unsigned __int8 *)*((_DWORD *)v41 + 2);
        *(_DWORD *)v41 = 6;
        return 2;
      case 1:
        goto LABEL_12;
      case 2:
        goto LABEL_35;
      case 3:
        goto LABEL_38;
      case 4:
        goto LABEL_41;
      case 5:
        goto LABEL_44;
      case 6:
        *(_DWORD *)a1[7] = 13;
        v42 = a1[7];
        a1[6] = (unsigned __int8 *)aNeedDictionary_0;
        *((_DWORD *)v42 + 1) = 0;
        return -2;
      case 7:
        v14 = sub_10049400(*((_DWORD *)v4 + 5), a1, v2);
        v2 = v14;
        if ( v14 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
        }
        else
        {
          if ( !v14 )
            v2 = v3;
          if ( v2 != 1 )
            return v2;
          v2 = v3;
          sub_100492C0(*((_DWORD *)a1[7] + 5), a1, a1[7] + 4);
          v15 = a1[7];
          if ( *((_DWORD *)v15 + 3) )
          {
            *(_DWORD *)v15 = 12;
          }
          else
          {
            *(_DWORD *)v15 = 8;
LABEL_25:
            v16 = a1[1];
            if ( !v16 )
              return v2;
            v17 = a1[7];
            a1[1] = v16 - 1;
            ++a1[2];
            v2 = v3;
            *((_DWORD *)v17 + 2) = *(*a1)++ << 24;
            *(_DWORD *)a1[7] = 9;
LABEL_27:
            v18 = a1[1];
            if ( !v18 )
              return v2;
            v19 = *a1;
            ++a1[2];
            a1[1] = v18 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v19 << 16;
            ++*a1;
            *(_DWORD *)a1[7] = 10;
LABEL_29:
            v20 = a1[1];
            if ( !v20 )
              return v2;
            v21 = *a1;
            ++a1[2];
            a1[1] = v20 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v21 << 8;
            ++*a1;
            *(_DWORD *)a1[7] = 11;
LABEL_31:
            v22 = a1[1];
            if ( !v22 )
              return v2;
            v23 = *a1;
            v24 = (int)(a1[2] + 1);
            a1[1] = v22 - 1;
            v25 = a1[7];
            a1[2] = (unsigned __int8 *)v24;
            v2 = v3;
            *((_DWORD *)v25 + 2) += *v23;
            ++*a1;
            v26 = a1[7];
            if ( *((_DWORD *)v26 + 1) == *((_DWORD *)v26 + 2) )
            {
              *(_DWORD *)a1[7] = 12;
              return 1;
            }
            *(_DWORD *)v26 = 13;
            v27 = a1[7];
            a1[6] = (unsigned __int8 *)aIncorrectDataC_0;
            *((_DWORD *)v27 + 1) = 5;
          }
        }
        continue;
      case 8:
        goto LABEL_25;
      case 9:
        goto LABEL_27;
      case 0xA:
        goto LABEL_29;
      case 0xB:
        goto LABEL_31;
      case 0xC:
        return 1;
      case 0xD:
        return -3;
      default:
        return -2;
    }
  }
}

// FUN_10047a00 @ 0x10047A00
// [binja] int32_t sub_10047a00(uint32_t arg1, uint32_t arg2)
int FUN_10047a00(uint arg1, uint arg2)
{
  size_t Size; // [esp+Ch] [ebp+Ch]

  return (int)calloc(arg2, Size);
}

// FUN_10047a20 @ 0x10047A20
// [binja] int32_t sub_10047a20(int32_t arg1)
int FUN_10047a20(int arg1)
{
  int result; // eax
  void *Block; // [esp+8h] [ebp+8h]

  free(Block);
  return result;
}

// sub_10047A30 @ 0x10047A30
int __cdecl sub_10047A30(int a1, _BYTE *a2, int a3, int a4)
{
  int result; // eax
  int v5; // ecx
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int v9; // esi
  int v10; // esi
  int v11; // ecx
  int v13; // esi
  int v14; // edx
  int v15; // edx
  int v16; // esi
  int v17; // ebx
  int v18; // esi
  int v19; // ebx
  int v20; // edx
  int v21; // edx
  int v22; // ebx
  int v23; // edx
  int v24; // esi
  int v25; // ecx

  result = a1;
  v5 = *(_DWORD *)(a1 + 5812);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << v5;
    *(_DWORD *)(a1 + 5812) = v5 + 3;
  }
  else
  {
    v6 = a4 << v5;
    v7 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v8 = *(_DWORD *)(a1 + 8);
    LOBYTE(v7) = *(_BYTE *)(a1 + 5809);
    v9 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v9;
    *(_BYTE *)(v8 + v9) = v7;
    v10 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v10 - 13;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a4 >> (16 - v10);
  }
  v11 = *(_DWORD *)(a1 + 5812);
  if ( v11 <= 8 )
  {
    if ( v11 <= 0 )
      goto LABEL_9;
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v13 + v14) = *(_BYTE *)(a1 + 5809);
  }
  ++*(_DWORD *)(a1 + 20);
LABEL_9:
  v15 = *(_DWORD *)(a1 + 8);
  v16 = *(_DWORD *)(a1 + 20);
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  *(_BYTE *)(v15 + v16) = a3;
  v17 = *(_DWORD *)(a1 + 8);
  v18 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v18;
  *(_BYTE *)(v17 + v18) = BYTE1(a3);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v20;
  *(_BYTE *)(v19 + v20) = ~(_BYTE)a3;
  v21 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v21;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + v21) = ~BYTE1(a3);
  v22 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v22;
  v23 = v22;
  if ( a3 )
  {
    v24 = a3;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + v23) = *a2;
      v25 = *(_DWORD *)(a1 + 20) + 1;
      ++a2;
      --v24;
      *(_DWORD *)(a1 + 20) = v25;
      v23 = v25;
    }
    while ( v24 );
  }
  return result;
}

// sub_10047B90 @ 0x10047B90
int __cdecl sub_10047B90(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int v6; // ebx
  int v7; // edi
  unsigned int v8; // edx
  unsigned __int16 *v9; // eax
  int v10; // ecx
  unsigned __int16 v11; // di
  unsigned __int16 *v12; // eax
  int v13; // ecx
  unsigned __int16 v14; // bp
  unsigned __int16 *v15; // ecx
  int v16; // eax
  unsigned __int16 v17; // di
  int i; // eax
  int v19; // edx
  unsigned int v20; // ecx
  unsigned int v21; // eax
  bool v22; // zf
  int v23; // ecx
  int v24; // edi
  int v25; // edi
  int v26; // edx
  int v27; // edx
  int v28; // edx
  int v29; // ecx
  int v30; // ebx
  int v31; // edx
  int v32; // edx
  int v33; // ecx
  int v34; // ebp
  int v35; // ebx
  int v36; // eax
  int v37; // edi
  int v38; // edi
  int v39; // edx
  int v40; // edx
  int v41; // ecx
  int v42; // eax
  int v43; // edi
  int v44; // edi
  int v45; // edx
  int v46; // edx
  int v47; // ecx
  int v48; // edi
  int v49; // edi
  int v50; // edx
  int v51; // edx
  int j; // edi
  int v53; // ecx
  unsigned __int16 v54; // ax
  int v55; // edx
  int v56; // ecx
  int v57; // ebx
  int v58; // edx
  int v59; // edx
  _WORD *v60; // eax
  int v61; // ecx
  _WORD *v62; // eax
  int v63; // ecx
  _WORD *v64; // eax
  int v65; // ecx
  int result; // eax
  int v67; // [esp+14h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+Ch]

  v4 = a3;
  v6 = 0;
  v7 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v21 = a3 + 5;
LABEL_16:
    v20 = v21;
    goto LABEL_17;
  }
  if ( *(_BYTE *)(a1 + 28) == 2 )
  {
    v8 = 0;
    v9 = (unsigned __int16 *)(a1 + 140);
    v10 = 7;
    do
    {
      v11 = *v9;
      v9 += 2;
      v8 += v11;
      --v10;
    }
    while ( v10 );
    v12 = (unsigned __int16 *)(a1 + 168);
    v13 = 121;
    do
    {
      v14 = *v12;
      v12 += 2;
      v6 += v14;
      --v13;
    }
    while ( v13 );
    v15 = (unsigned __int16 *)(a1 + 652);
    v16 = 128;
    do
    {
      v17 = *v15;
      v15 += 2;
      v8 += v17;
      --v16;
    }
    while ( v16 );
    v4 = a3;
    *(_BYTE *)(a1 + 28) = v8 <= v6 >> 2;
  }
  sub_100480F0(a1, a1 + 2832);
  sub_100480F0(a1, a1 + 2844);
  sub_10048660(a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_10048660(a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_100480F0(a1, a1 + 2856);
  for ( i = 18; i >= 3; --i )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[i] + 2678) )
      break;
  }
  v19 = 3 * i + 17 + *(_DWORD *)(a1 + 5792);
  v7 = i;
  v20 = (unsigned int)(v19 + 10) >> 3;
  v21 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  *(_DWORD *)(a1 + 5792) = v19;
  if ( v21 <= v20 )
    goto LABEL_16;
LABEL_17:
  if ( v4 + 4 <= v20 && a2 )
  {
    sub_10047A30(a1, a2, v4, a4);
  }
  else
  {
    v22 = v21 == v20;
    v23 = *(_DWORD *)(a1 + 5812);
    if ( v22 )
    {
      if ( v23 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= (a4 + 2) << v23;
        *(_DWORD *)(a1 + 5812) = v23 + 3;
      }
      else
      {
        v24 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= (a4 + 2) << v23;
        *(_BYTE *)(v24 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v25 = *(_DWORD *)(a1 + 8);
        v26 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v26;
        *(_BYTE *)(v26 + v25) = *(_BYTE *)(a1 + 5809);
        v27 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v27 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(a4 + 2) >> (16 - v27);
      }
      sub_10048CD0(a1, &unk_10050B70, &unk_10050FF0);
    }
    else
    {
      if ( v23 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= (a4 + 4) << v23;
        *(_DWORD *)(a1 + 5812) = v23 + 3;
      }
      else
      {
        v28 = (a4 + 4) << v23;
        v29 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v28;
        *(_BYTE *)(v29 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v30 = *(_DWORD *)(a1 + 8);
        v31 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v31;
        *(_BYTE *)(v31 + v30) = *(_BYTE *)(a1 + 5809);
        v32 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v32 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(a4 + 4) >> (16 - v32);
      }
      v33 = *(_DWORD *)(a1 + 5812);
      v34 = *(_DWORD *)(a1 + 2848) + 1;
      v35 = *(_DWORD *)(a1 + 2836) + 1;
      v68 = v7 + 1;
      v67 = v35;
      v36 = *(_DWORD *)(a1 + 2836) - 256;
      if ( v33 <= 11 )
      {
        *(_WORD *)(a1 + 5808) |= v36 << v33;
        *(_DWORD *)(a1 + 5812) = v33 + 5;
      }
      else
      {
        v37 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v36 << v33;
        *(_BYTE *)(v37 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v38 = *(_DWORD *)(a1 + 8);
        v39 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v39;
        *(_BYTE *)(v39 + v38) = *(_BYTE *)(a1 + 5809);
        v40 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v40 - 11;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v36 >> (16 - v40);
      }
      v41 = *(_DWORD *)(a1 + 5812);
      v42 = v34 - 1;
      if ( v41 <= 11 )
      {
        *(_WORD *)(a1 + 5808) |= v42 << v41;
        *(_DWORD *)(a1 + 5812) = v41 + 5;
      }
      else
      {
        v43 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v42 << v41;
        *(_BYTE *)(v43 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v44 = *(_DWORD *)(a1 + 8);
        v45 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v45;
        *(_BYTE *)(v45 + v44) = *(_BYTE *)(a1 + 5809);
        v46 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v46 - 11;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v42 >> (16 - v46);
      }
      v47 = *(_DWORD *)(a1 + 5812);
      if ( v47 <= 12 )
      {
        *(_WORD *)(a1 + 5808) |= (v68 - 4) << v47;
        *(_DWORD *)(a1 + 5812) = v47 + 4;
      }
      else
      {
        v48 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= (v68 - 4) << v47;
        *(_BYTE *)(v48 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v49 = *(_DWORD *)(a1 + 8);
        v50 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v50;
        *(_BYTE *)(v50 + v49) = *(_BYTE *)(a1 + 5809);
        v51 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v51 - 12;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(v68 - 4) >> (16 - v51);
      }
      for ( j = 0; j < v68; ++j )
      {
        v53 = *(_DWORD *)(a1 + 5812);
        if ( v53 <= 13 )
        {
          *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[j] + 2678) << v53;
          *(_DWORD *)(a1 + 5812) = v53 + 3;
        }
        else
        {
          v54 = *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[j] + 2678);
          v55 = v54 << v53;
          v56 = *(_DWORD *)(a1 + 20);
          *(_WORD *)(a1 + 5808) |= v55;
          *(_BYTE *)(v56 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
          v57 = *(_DWORD *)(a1 + 8);
          v58 = *(_DWORD *)(a1 + 20) + 1;
          *(_DWORD *)(a1 + 20) = v58;
          *(_BYTE *)(v58 + v57) = *(_BYTE *)(a1 + 5809);
          v59 = *(_DWORD *)(a1 + 5812);
          ++*(_DWORD *)(a1 + 20);
          v35 = v67;
          *(_DWORD *)(a1 + 5812) = v59 - 13;
          *(_WORD *)(a1 + 5808) = v54 >> (16 - v59);
        }
      }
      sub_10048750(a1, a1 + 140, v35 - 1);
      sub_10048750(a1, a1 + 2432, v34 - 1);
      sub_10048CD0(a1, a1 + 140, a1 + 2432);
    }
  }
  v60 = (_WORD *)(a1 + 140);
  v61 = 286;
  do
  {
    *v60 = 0;
    v60 += 2;
    --v61;
  }
  while ( v61 );
  v62 = (_WORD *)(a1 + 2432);
  v63 = 30;
  do
  {
    *v62 = 0;
    v62 += 2;
    --v63;
  }
  while ( v63 );
  v64 = (_WORD *)(a1 + 2676);
  v65 = 19;
  do
  {
    *v64 = 0;
    v64 += 2;
    --v65;
  }
  while ( v65 );
  result = a4;
  *(_WORD *)(a1 + 1164) = 1;
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  if ( a4 )
    return sub_10049110(a1);
  return result;
}

// sub_100480F0 @ 0x100480F0
unsigned int __cdecl sub_100480F0(_DWORD *a1, int a2)
{
  int v2; // edi
  int *v4; // eax
  _WORD *v5; // edx
  int v6; // ebx
  int v7; // ebp
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int i; // edi
  _WORD *v14; // ebx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  char v20; // cl
  int v21; // ecx
  int v22; // eax
  _WORD *v23; // ebx
  int *v24; // eax
  int v25; // edx
  int v26; // ebp
  int v27; // edx
  int v28; // eax
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  int v32; // edi
  int v33; // edx
  bool v34; // zf
  int v35; // edi
  int v36; // eax
  _WORD *j; // ecx
  int v38; // edi
  _WORD *v39; // ebp
  int v40; // eax
  int v41; // ebp
  int v42; // ecx
  _WORD *v43; // edx
  int v44; // eax
  __int16 *v45; // ecx
  __int16 v46; // ax
  char *v47; // edx
  int v48; // esi
  __int16 v49; // di
  unsigned int result; // eax
  _WORD *v51; // edi
  int v52; // ebx
  int v53; // edx
  unsigned int v54; // ecx
  int v55; // esi
  _WORD *v56; // [esp+10h] [ebp-48h]
  int v57; // [esp+14h] [ebp-44h]
  int v58; // [esp+18h] [ebp-40h]
  int v59; // [esp+1Ch] [ebp-3Ch]
  int v60; // [esp+20h] [ebp-38h]
  _WORD *v61; // [esp+20h] [ebp-38h]
  int v62; // [esp+24h] [ebp-34h]
  int v63; // [esp+28h] [ebp-30h]
  int v64; // [esp+2Ch] [ebp-2Ch]
  int v65; // [esp+30h] [ebp-28h]
  __int16 *v66; // [esp+34h] [ebp-24h]
  __int16 v67; // [esp+38h] [ebp-20h]
  char v68; // [esp+3Ah] [ebp-1Eh] BYREF
  int *v69; // [esp+5Ch] [ebp+4h]
  int v70; // [esp+5Ch] [ebp+4h]
  int v71; // [esp+60h] [ebp+8h]

  v2 = a2;
  v57 = -1;
  v4 = *(int **)(a2 + 8);
  v5 = *(_WORD **)a2;
  v56 = *(_WORD **)a2;
  v6 = *v4;
  v7 = v4[3];
  v8 = 0;
  a1[1299] = 573;
  for ( a1[1298] = 0; v8 < v7; v5 += 2 )
  {
    if ( *v5 )
    {
      v57 = v8;
      v9 = a1[1298] + 1;
      a1[1298] = v9;
      a1[v9 + 725] = v8;
      *((_BYTE *)a1 + v8 + 5200) = 0;
    }
    else
    {
      v5[1] = 0;
    }
    ++v8;
  }
  v10 = a1[1298];
  if ( v10 < 2 )
  {
    do
    {
      if ( v57 >= 2 )
        v11 = 0;
      else
        v11 = ++v57;
      v12 = v10 + 1;
      a1[1298] = v12;
      a1[v12 + 725] = v11;
      v56[2 * v11] = 1;
      *((_BYTE *)a1 + v11 + 5200) = 0;
      --a1[1448];
      if ( v6 )
        a1[1449] -= *(unsigned __int16 *)(v6 + 4 * v11 + 2);
      v10 = a1[1298];
    }
    while ( v10 < 2 );
    v2 = a2;
  }
  *(_DWORD *)(v2 + 4) = v57;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_10048580(a1, v56, i);
  v14 = &v56[2 * v7];
  do
  {
    v15 = a1[1298];
    v16 = a1[726];
    a1[726] = a1[v15 + 725];
    a1[1298] = v15 - 1;
    sub_10048580(a1, v56, 1);
    v17 = a1[726];
    v18 = a1[1299] - 1;
    a1[1299] = v18;
    a1[v18 + 725] = v16;
    v19 = a1[1299] - 1;
    a1[1299] = v19;
    a1[v19 + 725] = v17;
    *v14 = v56[2 * v16] + v56[2 * v17];
    if ( *((_BYTE *)a1 + v16 + 5200) < *((_BYTE *)a1 + v17 + 5200) )
      v20 = *((_BYTE *)a1 + v17 + 5200);
    else
      v20 = *((_BYTE *)a1 + v16 + 5200);
    *((_BYTE *)a1 + v7 + 5200) = v20 + 1;
    v56[2 * v17 + 1] = v7;
    v56[2 * v16 + 1] = v7;
    a1[726] = v7++;
    v14 += 2;
    sub_10048580(a1, v56, 1);
  }
  while ( (int)a1[1298] >= 2 );
  v21 = a1[726];
  v22 = a1[1299] - 1;
  a1[1299] = v22;
  v66 = (__int16 *)(a1 + 717);
  a1[v22 + 725] = v21;
  v23 = *(_WORD **)a2;
  v24 = *(int **)(a2 + 8);
  v62 = *(_DWORD *)(a2 + 4);
  v25 = v24[1];
  v26 = v24[4];
  v59 = *v24;
  v63 = v24[2];
  memset(a1 + 717, 0, 0x20u);
  v64 = v25;
  v65 = v26;
  v58 = 0;
  v23[2 * a1[a1[1299] + 725] + 1] = 0;
  v27 = a1[1299] + 1;
  if ( v27 < 573 )
  {
    v69 = &a1[v27 + 725];
    v28 = 573 - v27;
    v29 = 573;
    v60 = v28;
    v71 = 573;
    do
    {
      v30 = *v69;
      v31 = (unsigned __int16)v23[2 * (unsigned __int16)v23[2 * *v69 + 1] + 1] + 1;
      if ( v31 > v26 )
      {
        v31 = v26;
        ++v58;
      }
      v23[2 * v30 + 1] = v31;
      if ( v30 <= v62 )
      {
        ++*((_WORD *)a1 + v31 + 1434);
        v32 = 0;
        if ( v30 >= v63 )
          v32 = *(_DWORD *)(v64 + 4 * (v30 - v63));
        v33 = (unsigned __int16)v23[2 * v30];
        a1[1448] += v33 * (v32 + v31);
        if ( v59 )
        {
          v26 = v65;
          a1[1449] += v33 * (v32 + *(unsigned __int16 *)(v59 + 4 * v30 + 2));
        }
        v29 = 573;
      }
      v34 = v60 == 1;
      ++v69;
      --v60;
    }
    while ( !v34 );
    v35 = v58;
    if ( v58 )
    {
      do
      {
        v36 = v26 - 1;
        for ( j = (_WORD *)a1 + v26 + 1433; !*j; --v36 )
          --j;
        --*((_WORD *)a1 + v36 + 1434);
        *((_WORD *)a1 + v36 + 1435) += 2;
        --*((_WORD *)a1 + v26 + 1434);
        v35 -= 2;
      }
      while ( v35 > 0 );
      v38 = v26;
      if ( v26 )
      {
        v39 = (_WORD *)a1 + v26 + 1434;
        v61 = v39;
        do
        {
          v40 = (unsigned __int16)*v39;
          v70 = v40;
          if ( *v39 )
          {
            v41 = (int)&a1[v29 + 725];
            do
            {
              v42 = *(_DWORD *)(v41 - 4);
              v41 -= 4;
              --v71;
              if ( v42 <= v62 )
              {
                v43 = &v23[2 * v42 + 1];
                HIWORD(v44) = 0;
                if ( (unsigned __int16)*v43 != v38 )
                {
                  LOWORD(v44) = *v43;
                  a1[1448] += (unsigned __int16)v23[2 * v42] * (v38 - v44);
                  *v43 = v38;
                }
                v40 = --v70;
              }
            }
            while ( v40 );
            v29 = v71;
          }
          --v38;
          v39 = --v61;
        }
        while ( v38 );
      }
    }
  }
  v45 = v66;
  v46 = 0;
  v47 = &v68;
  v48 = 15;
  do
  {
    v49 = *v45++;
    v47 += 2;
    v46 = 2 * (v46 + v49);
    --v48;
    *((_WORD *)v47 - 1) = v46;
  }
  while ( v48 );
  result = v57;
  if ( v57 >= 0 )
  {
    v51 = v56;
    v52 = v57 + 1;
    do
    {
      v53 = (unsigned __int16)v51[1];
      if ( (_WORD)v53 )
      {
        result = (unsigned __int16)(*(&v67 + v53))++;
        v54 = 0;
        do
        {
          v55 = result & 1;
          result >>= 1;
          v54 = 2 * (v55 | v54);
          --v53;
        }
        while ( v53 > 0 );
        *v51 = v54 >> 1;
      }
      v51 += 2;
      --v52;
    }
    while ( v52 );
  }
  return result;
}

// sub_10048580 @ 0x10048580
int __cdecl sub_10048580(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // ecx
  bool v7; // cc
  int v8; // esi
  int v9; // ebp
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // bx
  int v12; // esi
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // bx
  int v15; // edx
  int v16; // edx
  int v17; // [esp+14h] [ebp+4h]

  result = a1;
  v4 = *(_DWORD *)(a1 + 5192);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  v6 = 2 * a3;
  v7 = 2 * a3 < v4;
  v17 = v5;
  if ( 2 * a3 > v4 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  else
  {
    while ( 1 )
    {
      if ( v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v6 + 2904);
        v9 = *(_DWORD *)(result + 4 * v6 + 2900);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 5200) <= *(_BYTE *)(result + v9 + 5200) )
          ++v6;
        v5 = v17;
      }
      v12 = *(_DWORD *)(result + 4 * v6 + 2900);
      v13 = *(_WORD *)(a2 + 4 * v5);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v5;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v5 + 5200) <= *(_BYTE *)(v12 + result + 5200) )
        break;
      v15 = a3;
      a3 = v6;
      v6 *= 2;
      *(_DWORD *)(result + 4 * v15 + 2900) = v12;
      v16 = *(_DWORD *)(result + 5192);
      v7 = v6 < v16;
      if ( v6 > v16 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  return result;
}

// sub_10048660 @ 0x10048660
int __cdecl sub_10048660(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned __int16 *v8; // ebp
  int v9; // eax
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+18h] [ebp+8h]

  result = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = 0;
  v10 = -1;
  v6 = 7;
  v7 = 4;
  if ( !(_WORD)v4 )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  if ( a3 >= 0 )
  {
    v11 = a3 + 1;
    v8 = (unsigned __int16 *)(result + 6);
    do
    {
      v9 = v4;
      v4 = *v8;
      if ( ++v5 >= v6 || v9 != v4 )
      {
        if ( v5 >= v7 )
        {
          if ( v9 )
          {
            if ( v9 != v10 )
              ++a1[2 * v9 + 1338];
            ++a1[1370];
          }
          else if ( v5 > 10 )
          {
            ++a1[1374];
          }
          else
          {
            ++a1[1372];
          }
        }
        else
        {
          a1[2 * v9 + 1338] += v5;
        }
        v5 = 0;
        v10 = v9;
        if ( v4 )
        {
          if ( v9 == v4 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v8 += 2;
      result = --v11;
    }
    while ( v11 );
  }
  return result;
}

// sub_10048750 @ 0x10048750
int __cdecl sub_10048750(int a1, unsigned int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // ebx
  int v28; // edi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // esi
  int v36; // ecx
  int v37; // ecx
  int v38; // esi
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // edi
  int v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // esi
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // ebx
  int v55; // edi
  int v56; // edi
  int v57; // ecx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // esi
  bool v63; // zf
  int v65; // [esp+Ch] [ebp-8h]
  int v66; // [esp+10h] [ebp-4h]
  int v67; // [esp+18h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+8h]
  unsigned __int16 *v69; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v65 = -1;
  v5 = 7;
  v6 = 4;
  if ( !(_WORD)v4 )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v7 = a3 + 1;
    v69 = (unsigned __int16 *)(a2 + 6);
    LODWORD(v3) = a1;
    v66 = v7;
    do
    {
      v8 = v4;
      ++HIDWORD(v3);
      v4 = *v69;
      v67 = v4;
      v68 = HIDWORD(v3);
      if ( SHIDWORD(v3) < v5 && v8 == v4 )
        goto LABEL_44;
      if ( SHIDWORD(v3) < v6 )
      {
        do
        {
          v9 = *(_DWORD *)(v3 + 5812);
          v10 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v9 <= 16 - (unsigned __int16)v10 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v9;
            *(_DWORD *)(v3 + 5812) = v10 + v9;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v11 = WORD2(v3) << v9;
            v12 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v11;
            *(_BYTE *)(v12 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v13 = *(_DWORD *)(v3 + 8);
            LOBYTE(v12) = *(_BYTE *)(v3 + 5809);
            v14 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v14;
            *(_BYTE *)(v14 + v13) = v12;
            v15 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v15);
            *(_DWORD *)(v3 + 5812) = v15 + v10 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        while ( HIDWORD(v3) );
        goto LABEL_39;
      }
      if ( v8 )
      {
        if ( v8 != v65 )
        {
          v16 = *(_DWORD *)(v3 + 5812);
          v17 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v16 <= 16 - (unsigned __int16)v17 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v16;
            *(_DWORD *)(v3 + 5812) = v17 + v16;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v18 = WORD2(v3) << v16;
            v19 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v18;
            *(_BYTE *)(v19 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v20 = *(_DWORD *)(v3 + 8);
            LOBYTE(v19) = *(_BYTE *)(v3 + 5809);
            v21 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v21;
            *(_BYTE *)(v21 + v20) = v19;
            v22 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v22);
            *(_DWORD *)(v3 + 5812) = v22 + v17 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        v23 = *(_DWORD *)(v3 + 5812);
        v24 = *(unsigned __int16 *)(v3 + 2742);
        if ( v23 <= 16 - (unsigned __int16)v24 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2740) << v23;
          *(_DWORD *)(v3 + 5812) = v24 + v23;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2740);
          v25 = WORD2(v3) << v23;
          v26 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v25;
          *(_BYTE *)(v26 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v27 = *(_DWORD *)(v3 + 8);
          LOBYTE(v26) = *(_BYTE *)(v3 + 5809);
          v28 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v28;
          *(_BYTE *)(v28 + v27) = v26;
          v29 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v29);
          *(_DWORD *)(v3 + 5812) = v29 + v24 - 16;
          HIDWORD(v3) = v68;
        }
        v30 = *(_DWORD *)(v3 + 5812);
        if ( v30 > 14 )
        {
          HIDWORD(v3) -= 3;
          v31 = HIDWORD(v3) << v30;
          v32 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v31;
          *(_BYTE *)(v32 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v33 = *(_DWORD *)(v3 + 8);
          LOBYTE(v32) = *(_BYTE *)(v3 + 5809);
          v34 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v34;
          *(_BYTE *)(v34 + v33) = v32;
          v35 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v35 - 14;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v35);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v30;
        v36 = v30 + 2;
      }
      else if ( SHIDWORD(v3) > 10 )
      {
        v50 = *(_DWORD *)(v3 + 5812);
        v51 = *(unsigned __int16 *)(v3 + 2750);
        if ( v50 <= 16 - (unsigned __int16)v51 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2748) << v50;
          *(_DWORD *)(v3 + 5812) = v51 + v50;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2748);
          v52 = WORD2(v3) << v50;
          v53 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v52;
          *(_BYTE *)(v53 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v54 = *(_DWORD *)(v3 + 8);
          LOBYTE(v53) = *(_BYTE *)(v3 + 5809);
          v55 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v55;
          *(_BYTE *)(v55 + v54) = v53;
          v56 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v56);
          *(_DWORD *)(v3 + 5812) = v56 + v51 - 16;
          HIDWORD(v3) = v68;
        }
        v57 = *(_DWORD *)(v3 + 5812);
        if ( v57 > 9 )
        {
          HIDWORD(v3) -= 11;
          v58 = HIDWORD(v3) << v57;
          v59 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v58;
          *(_BYTE *)(v59 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v60 = *(_DWORD *)(v3 + 8);
          LOBYTE(v59) = *(_BYTE *)(v3 + 5809);
          v61 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v61;
          *(_BYTE *)(v61 + v60) = v59;
          v62 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v62 - 9;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v62);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 11) << v57;
        v36 = v57 + 7;
      }
      else
      {
        v37 = *(_DWORD *)(v3 + 5812);
        v38 = *(unsigned __int16 *)(v3 + 2746);
        if ( v37 <= 16 - (unsigned __int16)v38 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2744) << v37;
          *(_DWORD *)(v3 + 5812) = v38 + v37;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2744);
          v39 = WORD2(v3) << v37;
          v40 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v39;
          *(_BYTE *)(v40 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v41 = *(_DWORD *)(v3 + 8);
          LOBYTE(v40) = *(_BYTE *)(v3 + 5809);
          v42 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v42;
          *(_BYTE *)(v42 + v41) = v40;
          v43 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v43);
          *(_DWORD *)(v3 + 5812) = v43 + v38 - 16;
          HIDWORD(v3) = v68;
        }
        v44 = *(_DWORD *)(v3 + 5812);
        if ( v44 > 13 )
        {
          HIDWORD(v3) -= 3;
          v45 = HIDWORD(v3) << v44;
          v46 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v45;
          *(_BYTE *)(v46 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v47 = *(_DWORD *)(v3 + 8);
          LOBYTE(v46) = *(_BYTE *)(v3 + 5809);
          v48 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v48;
          *(_BYTE *)(v48 + v47) = v46;
          v49 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v49 - 13;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v49);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v44;
        v36 = v44 + 3;
      }
      *(_DWORD *)(v3 + 5812) = v36;
LABEL_39:
      v4 = v67;
      HIDWORD(v3) = 0;
      v65 = v8;
      if ( v67 )
      {
        if ( v8 == v67 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v63 = v66 == 1;
      v69 += 2;
      --v66;
    }
    while ( !v63 );
  }
  return v3;
}

// sub_10048CD0 @ 0x10048CD0
int __cdecl sub_10048CD0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // si
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // ebp
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  __int16 v24; // si
  int v25; // ecx
  __int16 v26; // bp
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // ebp
  int v32; // ebx
  char v33; // cl
  int v34; // ebx
  unsigned int v35; // edi
  int v36; // ebx
  int v37; // ecx
  int v38; // esi
  unsigned __int16 v39; // dx
  int v40; // ebp
  int v41; // ebx
  char v42; // cl
  int v43; // ebx
  int v44; // edx
  int v45; // edx
  unsigned int v46; // edi
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // ecx
  int v50; // ebx
  int v51; // esi
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  unsigned __int16 v55; // dx
  int v56; // edi
  int v57; // ecx
  int v58; // ebx
  int v59; // edi
  int v60; // edi
  int v61; // [esp+10h] [ebp-8h]
  unsigned int v62; // [esp+14h] [ebp-4h]
  int v63; // [esp+1Ch] [ebp+4h]
  int v64; // [esp+1Ch] [ebp+4h]

  result = a1;
  v4 = 0;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    while ( 1 )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v7 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v62 = v4 + 1;
      if ( !(_WORD)v6 )
        break;
      v16 = *(_DWORD *)(result + 5812);
      v17 = (unsigned __int8)byte_10051268[v7];
      v63 = v17;
      v18 = *(unsigned __int16 *)(v5 + 4 * v17 + 1030);
      v61 = (unsigned __int16)v18;
      if ( v16 <= 16 - (unsigned __int16)v18 )
      {
        v26 = *(_WORD *)(a2 + 4 * v17 + 1028) << v16;
        v27 = *(_DWORD *)(result + 5812);
        *(_WORD *)(result + 5808) |= v26;
        v25 = v18 + v27;
      }
      else
      {
        v19 = *(_WORD *)(a2 + 4 * v17 + 1028);
        v20 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v19 << v16;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v20) = *(_BYTE *)(result + 5808);
        v21 = *(_DWORD *)(result + 20) + 1;
        v22 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v21;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v21) = v22;
        v23 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v24 = v19 >> (16 - v23);
        v25 = v23 + v61 - 16;
        v17 = v63;
        *(_WORD *)(result + 5808) = v24;
      }
      *(_DWORD *)(result + 5812) = v25;
      v28 = dword_10050A24[v17];
      if ( v28 )
      {
        v29 = v7 - dword_10051368[v17];
        v30 = *(_DWORD *)(result + 5812);
        if ( v30 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_DWORD *)(result + 5812) = v28 + v30;
        }
        else
        {
          v31 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_BYTE *)(*(_DWORD *)(result + 20) + v31) = *(_BYTE *)(result + 5808);
          v32 = *(_DWORD *)(result + 20) + 1;
          v33 = *(_BYTE *)(result + 5809);
          *(_DWORD *)(result + 20) = v32;
          *(_BYTE *)(*(_DWORD *)(result + 8) + v32) = v33;
          v34 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_WORD *)(result + 5808) = (unsigned __int16)v29 >> (16 - v34);
          *(_DWORD *)(result + 5812) = v34 + v28 - 16;
        }
      }
      v35 = v6 - 1;
      if ( v35 >= 0x100 )
        v36 = (unsigned __int8)byte_10051168[v35 >> 7];
      else
        v36 = (unsigned __int8)byte_10051068[v35];
      v37 = *(_DWORD *)(result + 5812);
      v38 = *(unsigned __int16 *)(a3 + 4 * v36 + 2);
      v64 = v36;
      if ( v37 <= 16 - (unsigned __int16)v38 )
      {
        v5 = a2;
        *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v36) << v37;
        *(_DWORD *)(result + 5812) = v38 + v37;
      }
      else
      {
        v39 = *(_WORD *)(a3 + 4 * v36);
        v40 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v39 << v37;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v40) = *(_BYTE *)(result + 5808);
        v41 = *(_DWORD *)(result + 20) + 1;
        v42 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v41;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v41) = v42;
        v43 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v5 = a2;
        *(_WORD *)(result + 5808) = v39 >> (16 - v43);
        v44 = v43 + v38 - 16;
        v36 = v64;
        *(_DWORD *)(result + 5812) = v44;
      }
      v45 = dword_10050A98[v36];
      if ( !v45 )
        goto LABEL_24;
      v46 = v35 - dword_100513DC[v36];
      v47 = *(_DWORD *)(result + 5812);
      if ( v47 <= 16 - v45 )
      {
        *(_WORD *)(result + 5808) |= v46 << v47;
        v15 = v45 + v47;
LABEL_23:
        *(_DWORD *)(result + 5812) = v15;
        goto LABEL_24;
      }
      v48 = v46 << v47;
      v49 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v48;
      *(_BYTE *)(v49 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v50 = *(_DWORD *)(result + 8);
      LOBYTE(v49) = *(_BYTE *)(result + 5809);
      v51 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v51;
      *(_BYTE *)(v51 + v50) = v49;
      v52 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v52 + v45 - 16;
      *(_WORD *)(result + 5808) = (unsigned __int16)v46 >> (16 - v52);
LABEL_24:
      v4 = v62;
      if ( v62 >= *(_DWORD *)(result + 5784) )
        goto LABEL_25;
    }
    LOWORD(v6) = *(_WORD *)(v5 + 4 * v7 + 2);
    v8 = *(_DWORD *)(result + 5812);
    if ( v8 <= 16 - (unsigned __int16)v6 )
    {
      *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 4 * v7) << v8;
      v15 = v6 + v8;
    }
    else
    {
      v9 = *(_WORD *)(v5 + 4 * v7);
      v10 = v9 << v8;
      v11 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v10;
      *(_BYTE *)(v11 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v12 = *(_DWORD *)(result + 8);
      v13 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v13;
      *(_BYTE *)(v13 + v12) = *(_BYTE *)(result + 5809);
      v14 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      v15 = v14 + v6 - 16;
      *(_WORD *)(result + 5808) = v9 >> (16 - v14);
    }
    goto LABEL_23;
  }
LABEL_25:
  v53 = *(_DWORD *)(result + 5812);
  v54 = *(unsigned __int16 *)(v5 + 1026);
  if ( v53 <= 16 - (unsigned __int16)v54 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 1024) << v53;
    *(_DWORD *)(result + 5812) = v54 + v53;
  }
  else
  {
    v55 = *(_WORD *)(v5 + 1024);
    v56 = v55 << v53;
    v57 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v56;
    *(_BYTE *)(v57 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v58 = *(_DWORD *)(result + 8);
    LOBYTE(v57) = *(_BYTE *)(result + 5809);
    v59 = *(_DWORD *)(result + 20) + 1;
    *(_DWORD *)(result + 20) = v59;
    *(_BYTE *)(v59 + v58) = v57;
    v60 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = v55 >> (16 - v60);
    *(_DWORD *)(result + 5812) = v60 + v54 - 16;
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v5 + 1026);
  return result;
}

// sub_10049110 @ 0x10049110
int __cdecl sub_10049110(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 <= 8 )
  {
    if ( v2 > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  return result;
}

// sub_10049190 @ 0x10049190
int __cdecl sub_10049190(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // ebx
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // edi
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( i = a3; i; v5 %= 0xFFF1u )
  {
    v8 = i;
    if ( i >= 0x15B0 )
      v8 = 5552;
    i -= v8;
    if ( v8 >= 16 )
    {
      v9 = (unsigned int)v8 >> 4;
      v8 += -16 * ((unsigned int)v8 >> 4);
      do
      {
        v10 = *v3;
        v3 += 16;
        v11 = v10 + v4;
        v12 = v11 + v5;
        v13 = *(v3 - 15) + v11;
        v14 = v13 + v12;
        v15 = *(v3 - 14) + v13;
        v16 = v15 + v14;
        v17 = *(v3 - 13) + v15;
        v18 = v17 + v16;
        v19 = *(v3 - 12) + v17;
        v20 = v19 + v18;
        v21 = *(v3 - 11) + v19;
        v22 = v21 + v20;
        v23 = *(v3 - 10) + v21;
        v24 = v23 + v22;
        v25 = *(v3 - 9) + v23;
        v26 = v25 + v24;
        v27 = *(v3 - 8) + v25;
        v28 = v27 + v26;
        v29 = *(v3 - 7) + v27;
        v30 = v29 + v28;
        v31 = *(v3 - 6) + v29;
        v32 = v31 + v30;
        v33 = *(v3 - 5) + v31;
        v34 = v33 + v32;
        v35 = *(v3 - 4) + v33;
        v36 = v35 + v34;
        v37 = *(v3 - 3) + v35;
        v38 = v37 + v36;
        v39 = *(v3 - 2) + v37;
        v40 = v39 + v38;
        v4 = *(v3 - 1) + v39;
        v5 = v4 + v40;
        --v9;
      }
      while ( v9 );
    }
    for ( ; v8; --v8 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

// sub_100492C0 @ 0x100492C0
int (__cdecl *__cdecl sub_100492C0(_DWORD *a1, int a2, _DWORD *a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax

  if ( a3 )
    *a3 = a1[15];
  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    sub_1004A980(a1[1], a2);
  v3 = a1[10];
  *a1 = 0;
  a1[13] = v3;
  a1[12] = v3;
  result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  a1[7] = 0;
  a1[8] = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    a1[15] = result;
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

// sub_10049340 @ 0x10049340
int __cdecl sub_10049340(int a1, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  int result; // eax
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  v4 = (_DWORD *)result;
  if ( result )
  {
    v5 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
    v4[9] = v5;
    if ( v5 )
    {
      v6 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
      v4[10] = v6;
      if ( v6 )
      {
        *v4 = 0;
        v4[11] = v6 + a3;
        v4[14] = a2;
        v4[7] = 0;
        v4[8] = 0;
        v4[13] = v6;
        v4[12] = v6;
        if ( a2 )
        {
          v7 = a2(0, 0, 0);
          v4[15] = v7;
          *(_DWORD *)(a1 + 48) = v7;
        }
        return (int)v4;
      }
      else
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v4[9]);
        (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
        return 0;
      }
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
      return 0;
    }
  }
  return result;
}

// sub_10049400 @ 0x10049400
int __cdecl sub_10049400(_DWORD *a1, unsigned __int8 **a2, int a3)
{
  unsigned int v4; // ebp
  char *v5; // ecx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // edi
  int v11; // edx
  unsigned int v12; // ebp
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // esi
  unsigned __int8 *v16; // edi
  unsigned __int8 *v17; // eax
  int v18; // edx
  unsigned int v19; // edi
  unsigned int v20; // ecx
  char *v21; // ecx
  char *v22; // edx
  unsigned int v23; // eax
  unsigned int v24; // esi
  int v25; // eax
  char *v26; // edx
  unsigned int v27; // esi
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // edi
  unsigned __int8 *v33; // esi
  unsigned __int8 *v34; // eax
  int v35; // edx
  unsigned int v36; // eax
  unsigned int v37; // ecx
  unsigned __int8 **v38; // esi
  int v39; // eax
  unsigned int v40; // edi
  unsigned __int8 *v41; // eax
  char v42; // cl
  int v43; // eax
  unsigned int v44; // edx
  unsigned int v45; // ecx
  unsigned int v46; // eax
  int v47; // edx
  int v48; // ecx
  int v49; // eax
  int v50; // edx
  unsigned int v51; // eax
  int v52; // eax
  int v53; // ecx
  int v54; // eax
  int v55; // eax
  int v56; // edx
  unsigned int v57; // edi
  int v58; // eax
  int v59; // ecx
  unsigned int v60; // eax
  int v61; // eax
  unsigned __int8 *v62; // edi
  unsigned __int8 *v63; // edx
  int v64; // eax
  char *v65; // ecx
  unsigned __int8 *v66; // edi
  unsigned int v67; // eax
  int v68; // eax
  int v69; // ebp
  int result; // eax
  unsigned __int8 *v71; // ebp
  unsigned __int8 *v72; // ebp
  unsigned __int8 *v73; // esi
  unsigned __int8 *v74; // ebp
  int v75; // ebp
  unsigned __int8 *v76; // ebp
  unsigned __int8 *v77; // edx
  unsigned __int8 *v78; // ebp
  unsigned __int8 *v79; // esi
  unsigned __int8 *v80; // esi
  unsigned __int8 *v81; // ebp
  unsigned __int8 *v82; // edi
  unsigned __int8 *v83; // edx
  unsigned __int8 *v84; // esi
  unsigned __int8 *v85; // ebp
  unsigned __int8 *v86; // ecx
  unsigned __int8 *v87; // edx
  bool v88; // zf
  unsigned __int8 *v89; // edi
  unsigned __int8 *v90; // ecx
  unsigned __int8 *v91; // edi
  unsigned __int8 *v92; // ecx
  unsigned __int8 *v93; // edi
  char *v94; // ecx
  unsigned __int8 *v95; // ebp
  unsigned __int8 *v96; // ebp
  unsigned __int8 *v97; // esi
  unsigned __int8 *v98; // ebp
  unsigned __int8 *v99; // esi
  unsigned __int8 *v100; // ebp
  int v101; // [esp-1Ch] [ebp-5Ch]
  int v102; // [esp-14h] [ebp-54h]
  int v103; // [esp-8h] [ebp-48h]
  int v104; // [esp-8h] [ebp-48h]
  unsigned __int8 *v105; // [esp+10h] [ebp-30h]
  unsigned __int8 *v106; // [esp+14h] [ebp-2Ch]
  unsigned int v107; // [esp+18h] [ebp-28h]
  int v108; // [esp+18h] [ebp-28h]
  int v109; // [esp+18h] [ebp-28h]
  int v110; // [esp+18h] [ebp-28h]
  int v111; // [esp+1Ch] [ebp-24h] BYREF
  unsigned int v112; // [esp+20h] [ebp-20h] BYREF
  int v113; // [esp+24h] [ebp-1Ch] BYREF
  int v114; // [esp+28h] [ebp-18h] BYREF
  int v115; // [esp+2Ch] [ebp-14h] BYREF
  int v116; // [esp+30h] [ebp-10h] BYREF
  unsigned int v117; // [esp+34h] [ebp-Ch]
  int v118; // [esp+38h] [ebp-8h] BYREF
  int v119; // [esp+3Ch] [ebp-4h] BYREF
  char *v120; // [esp+44h] [ebp+4h]
  int v121; // [esp+4Ch] [ebp+Ch]

  v4 = a1[7];
  v105 = *a2;
  v5 = (char *)a1[13];
  v107 = a1[8];
  v6 = a1[12];
  v106 = a2[1];
  v120 = v5;
  if ( (unsigned int)v5 >= v6 )
    v7 = a1[11] - (_DWORD)v5;
  else
    v7 = v6 - (_DWORD)v5 - 1;
  v111 = v7;
  while ( 2 )
  {
    switch ( *a1 )
    {
      case 0:
        v8 = v107;
        if ( v4 >= 3 )
        {
          v10 = v105;
LABEL_12:
          a1[6] = v8 & 1;
          switch ( (unsigned __int8)(v8 & 7) >> 1 )
          {
            case 0:
              v12 = v4 - 3;
              *a1 = 1;
              v13 = v12 & 7;
              v4 = v12 - v13;
              v107 = v8 >> 3 >> v13;
              continue;
            case 1:
              inflate_trees_fixed(&v116, &v115, &v114, &v113);
              v14 = sub_1004A190(v116, v115, v114, v113, a2);
              a1[1] = v14;
              if ( v14 )
              {
                v107 = v8 >> 3;
                v4 -= 3;
                *a1 = 6;
                continue;
              }
              a1[8] = v8;
              a1[7] = v4;
              v71 = a2[2];
              a2[1] = v106;
              a2[2] = &v71[v10 - *a2];
              *a2 = v10;
              a1[13] = v120;
              result = sub_1004B0E0(a1, a2, -4);
              break;
            case 2:
              v107 = v8 >> 3;
              v4 -= 3;
              *a1 = 3;
              continue;
            case 3:
              *a1 = 9;
              a2[6] = (unsigned __int8 *)aInvalidBlockTy_0;
              a1[8] = v8 >> 3;
              a1[7] = v4 - 3;
              v72 = a2[2];
              a2[1] = v106;
              a2[2] = &v72[v10 - *a2];
              *a2 = v10;
              a1[13] = v120;
              return sub_1004B0E0(a1, a2, -3);
            default:
              continue;
          }
        }
        else
        {
          v9 = v106;
          v10 = v105;
          while ( v9 )
          {
            --v9;
            a3 = 0;
            v11 = *v10 << v4;
            v4 += 8;
            v106 = v9;
            v8 |= v11;
            ++v10;
            v107 = v8;
            v105 = v10;
            if ( v4 >= 3 )
              goto LABEL_12;
          }
          a1[8] = v8;
          a1[7] = v4;
          v69 = (int)&a2[2][v10 - *a2];
          a2[1] = 0;
          a2[2] = (unsigned __int8 *)v69;
          *a2 = v10;
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, a3);
        }
        return result;
      case 1:
        v15 = v107;
        v16 = v106;
        v17 = v105;
        if ( v4 >= 0x20 )
          goto LABEL_20;
        do
        {
          if ( !v16 )
          {
            a1[8] = v15;
            a1[7] = v4;
            v73 = *a2;
            v74 = a2[2];
            a2[1] = 0;
            *a2 = v17;
            a2[2] = &v74[v17 - v73];
            a1[13] = v120;
            return sub_1004B0E0(a1, a2, a3);
          }
          a3 = 0;
          --v16;
          v18 = *v17 << v4;
          v4 += 8;
          v106 = v16;
          v15 |= v18;
          v105 = ++v17;
        }
        while ( v4 < 0x20 );
LABEL_20:
        if ( (unsigned __int16)v15 != ~v15 >> 16 )
        {
          *a1 = 9;
          a2[6] = (unsigned __int8 *)aInvalidStoredB_0;
          a1[8] = v15;
          a1[7] = v4;
          v75 = (int)&a2[2][v17 - *a2];
          *a2 = v17;
          a2[1] = v16;
          a2[2] = (unsigned __int8 *)v75;
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -3);
        }
        v4 = 0;
        a1[1] = (unsigned __int16)v15;
        v107 = 0;
        if ( (_WORD)v15 )
        {
          *a1 = 2;
          continue;
        }
LABEL_47:
        *a1 = a1[6] != 0 ? 7 : 0;
        continue;
      case 2:
        v19 = (unsigned int)v106;
        if ( !v106 )
        {
          a1[8] = v107;
          a1[7] = v4;
          v76 = a2[2];
          v77 = (unsigned __int8 *)(v105 - *a2);
          *a2 = v105;
          a2[1] = 0;
          a2[2] = &v76[(_DWORD)v77];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, a3);
        }
        v20 = v111;
        if ( v111 )
          goto LABEL_42;
        v21 = (char *)a1[11];
        v22 = v120;
        if ( v120 == v21 )
        {
          v23 = a1[12];
          v24 = a1[10];
          if ( v23 != v24 )
          {
            v22 = (char *)a1[10];
            v120 = v22;
            v20 = v24 >= v23 ? (unsigned int)&v21[-v24] : v23 - v24 - 1;
            v111 = v20;
            if ( v20 )
              goto LABEL_42;
          }
        }
        a1[13] = v22;
        v25 = sub_1004B0E0(a1, a2, a3);
        v26 = (char *)a1[13];
        v27 = a1[12];
        v121 = v25;
        v120 = v26;
        if ( (unsigned int)v26 >= v27 )
          v20 = a1[11] - (_DWORD)v26;
        else
          v20 = v27 - (_DWORD)v26 - 1;
        v28 = a1[11];
        v111 = v20;
        v112 = v28;
        if ( v26 == (char *)v28 )
        {
          v29 = a1[10];
          if ( v27 != v29 )
          {
            v26 = (char *)a1[10];
            v120 = v26;
            if ( v29 >= v27 )
              v20 = v112 - v29;
            else
              v20 = v27 - v29 - 1;
            v111 = v20;
          }
        }
        if ( !v20 )
        {
          a1[8] = v107;
          a1[7] = v4;
          v78 = *a2;
          v79 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v79[v105 - v78];
          a1[13] = v26;
          return sub_1004B0E0(a1, a2, v121);
        }
        v19 = (unsigned int)v106;
LABEL_42:
        v30 = a1[1];
        a3 = 0;
        if ( v30 > v19 )
          v30 = v19;
        if ( v30 > v20 )
          v30 = v20;
        qmemcpy(v120, v105, v30);
        v105 += v30;
        v31 = a1[1] - v30;
        v106 -= v30;
        v120 += v30;
        v111 -= v30;
        a1[1] = v31;
        if ( !v31 )
          goto LABEL_47;
        continue;
      case 3:
        v32 = v107;
        if ( v4 >= 0xE )
          goto LABEL_52;
        v33 = v106;
        v34 = v105;
        do
        {
          if ( !v33 )
          {
            a1[8] = v32;
            a1[7] = v4;
            v80 = *a2;
            v81 = a2[2];
            *a2 = v105;
            a2[1] = 0;
            a2[2] = &v81[v105 - v80];
            a1[13] = v120;
            return sub_1004B0E0(a1, a2, a3);
          }
          --v33;
          a3 = 0;
          v35 = *v34 << v4;
          v4 += 8;
          v106 = v33;
          v32 |= v35;
          v105 = ++v34;
        }
        while ( v4 < 0xE );
LABEL_52:
        v36 = v32 & 0x3FFF;
        a1[1] = v36;
        v37 = v32 & 0x1F;
        if ( v37 > 0x1D || (v32 & 0x3E0) > 0x3A0 )
        {
          *a1 = 9;
          a2[6] = (unsigned __int8 *)aTooManyLengthO_0;
          a1[8] = v32;
          a1[7] = v4;
          v84 = *a2;
          v85 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v85[v105 - v84];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -3);
        }
        v38 = a2;
        v39 = ((int (__cdecl *)(unsigned __int8 *, unsigned int, int))a2[8])(a2[10], ((v36 >> 5) & 0x1F) + v37 + 258, 4);
        a1[3] = v39;
        if ( !v39 )
        {
          a1[8] = v32;
          a1[7] = v4;
          v82 = *a2;
          v83 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v83[v105 - v82];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -4);
        }
        v40 = v32 >> 14;
        v4 -= 14;
        a1[2] = 0;
        *a1 = 4;
LABEL_57:
        if ( a1[2] < (unsigned int)((a1[1] >> 10) + 4) )
        {
          while ( v4 >= 3 )
          {
LABEL_62:
            v43 = v40 & 7;
            v4 -= 3;
            v40 >>= 3;
            *(_DWORD *)(a1[3] + 4 * dword_10051454[a1[2]]) = v43;
            v44 = a1[2] + 1;
            a1[2] = v44;
            if ( v44 >= (a1[1] >> 10) + 4 )
              goto LABEL_63;
          }
          v41 = v105;
          while ( v106 )
          {
            --v106;
            v42 = v4;
            v4 += 8;
            a3 = 0;
            v40 |= *v41++ << v42;
            v105 = v41;
            if ( v4 >= 3 )
              goto LABEL_62;
          }
          goto LABEL_107;
        }
LABEL_63:
        if ( a1[2] < 0x13u )
        {
          do
          {
            *(_DWORD *)(a1[3] + 4 * dword_10051454[a1[2]]) = 0;
            v45 = a1[2] + 1;
            a1[2] = v45;
          }
          while ( v45 < 0x13 );
        }
        v103 = a1[9];
        v102 = a1[3];
        a1[4] = 7;
        v108 = sub_1004A9A0(v102, a1 + 4, a1 + 5, v103, v38);
        if ( v108 )
        {
          ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
          v88 = v108 == -3;
LABEL_112:
          if ( v88 )
            *a1 = 9;
          a1[8] = v40;
          a1[7] = v4;
          v91 = *v38;
          v38[1] = v106;
          v92 = v38[2];
          *v38 = v105;
          v38[2] = &v92[v105 - v91];
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, v108);
        }
        a1[2] = 0;
        *a1 = 5;
LABEL_68:
        if ( a1[2] < ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
        {
          while ( 1 )
          {
            v46 = a1[4];
            if ( v4 < v46 )
              break;
LABEL_72:
            v48 = a1[5];
            v49 = v40 & dword_10059608[v46];
            v50 = *(unsigned __int8 *)(v48 + 8 * v49 + 1);
            v109 = v50;
            v51 = *(_DWORD *)(v48 + 8 * v49 + 4);
            v117 = v51;
            if ( v51 >= 0x10 )
            {
              v53 = 7;
              if ( v51 != 18 )
                v53 = v51 - 14;
              v111 = v53;
              v54 = -(v51 != 18);
              LOBYTE(v54) = v54 & 0xF8;
              v112 = v50 + v53;
              v55 = v54 + 11;
              if ( v4 < v50 + v53 )
              {
                while ( v106 )
                {
                  a3 = 0;
                  --v106;
                  v56 = *v105 << v4;
                  v4 += 8;
                  v40 |= v56;
                  ++v105;
                  if ( v4 >= v112 )
                  {
                    v50 = v109;
                    goto LABEL_80;
                  }
                }
                goto LABEL_107;
              }
LABEL_80:
              v57 = v40 >> v50;
              v58 = (v57 & dword_10059608[v111]) + v55;
              v40 = v57 >> v111;
              v110 = v58;
              v4 -= v50 + v111;
              v111 = a1[2];
              if ( v111 + v58 > ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
                goto LABEL_110;
              if ( v117 == 16 )
              {
                v52 = v111;
                if ( !v111 )
                {
LABEL_110:
                  ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
                  *a1 = 9;
                  v38[6] = (unsigned __int8 *)aInvalidBitLeng_0;
                  a1[8] = v40;
                  a1[7] = v4;
                  v89 = *v38;
                  v38[1] = v106;
                  v90 = v38[2];
                  *v38 = v105;
                  v38[2] = &v90[v105 - v89];
                  a1[13] = v120;
                  return sub_1004B0E0(a1, v38, -3);
                }
                v59 = *(_DWORD *)(a1[3] + 4 * v111 - 4);
              }
              else
              {
                v52 = v111;
                v59 = 0;
              }
              do
              {
                ++v52;
                *(_DWORD *)(a1[3] + 4 * v52 - 4) = v59;
                --v110;
              }
              while ( v110 );
            }
            else
            {
              v4 -= v50;
              v40 >>= v50;
              *(_DWORD *)(a1[3] + 4 * a1[2]) = v51;
              v52 = a1[2] + 1;
            }
            a1[2] = v52;
            if ( a1[2] >= ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
              goto LABEL_87;
          }
          while ( v106 )
          {
            a3 = 0;
            --v106;
            v47 = *v105 << v4;
            v4 += 8;
            v40 |= v47;
            ++v105;
            if ( v4 >= v46 )
              goto LABEL_72;
          }
LABEL_107:
          a1[8] = v40;
          a1[7] = v4;
          v86 = v38[2];
          v87 = (unsigned __int8 *)(v105 - *v38);
          *v38 = v105;
          v38[2] = &v86[(_DWORD)v87];
          v38[1] = 0;
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, a3);
        }
LABEL_87:
        v60 = a1[1];
        v104 = a1[9];
        v101 = a1[3];
        a1[5] = 0;
        v112 = 9;
        v111 = 6;
        v108 = sub_1004AF20((v60 & 0x1F) + 257, ((v60 >> 5) & 0x1F) + 1, v101, &v112, &v111, &v119, &v118, v104, v38);
        ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
        if ( v108 )
        {
          v88 = v108 == -3;
          goto LABEL_112;
        }
        v61 = sub_1004A190(v112, v111, v119, v118, v38);
        if ( !v61 )
        {
          a1[8] = v40;
          a1[7] = v4;
          v93 = *v38;
          v38[1] = v106;
          v38[2] += v105 - v93;
          *v38 = v105;
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, -4);
        }
        a1[1] = v61;
        *a1 = 6;
LABEL_91:
        a1[8] = v40;
        a1[7] = v4;
        v62 = *v38;
        v38[1] = v106;
        v63 = v38[2];
        *v38 = v105;
        v38[2] = &v63[v105 - v62];
        a1[13] = v120;
        v64 = sub_1004A1D0(a1, v38, a3);
        if ( v64 != 1 )
          return sub_1004B0E0(a1, v38, v64);
        a3 = 0;
        sub_1004A980(a1[1], v38);
        v65 = (char *)a1[13];
        v66 = *v38;
        v4 = a1[7];
        v107 = a1[8];
        v67 = a1[12];
        v105 = *v38;
        v106 = v38[1];
        v120 = v65;
        if ( (unsigned int)v65 >= v67 )
          v68 = a1[11] - (_DWORD)v65;
        else
          v68 = v67 - (_DWORD)v65 - 1;
        v111 = v68;
        if ( !a1[6] )
        {
          *a1 = 0;
          continue;
        }
        *a1 = 7;
LABEL_118:
        a1[13] = v65;
        v64 = sub_1004B0E0(a1, v38, a3);
        v94 = (char *)a1[13];
        if ( (char *)a1[12] != v94 )
        {
          a1[7] = v4;
          a1[8] = v107;
          v95 = *v38;
          v38[1] = v106;
          *v38 = v66;
          v38[2] += v66 - v95;
          a1[13] = v94;
          return sub_1004B0E0(a1, v38, v64);
        }
        *a1 = 8;
LABEL_123:
        a1[8] = v107;
        a1[7] = v4;
        v96 = *v38;
        v38[1] = v106;
        v38[2] += v66 - v96;
        *v38 = v66;
        a1[13] = v94;
        return sub_1004B0E0(a1, v38, 1);
      case 4:
        v40 = v107;
        v38 = a2;
        goto LABEL_57;
      case 5:
        v40 = v107;
        v38 = a2;
        goto LABEL_68;
      case 6:
        v40 = v107;
        v38 = a2;
        goto LABEL_91;
      case 7:
        v65 = v120;
        v38 = a2;
        v66 = v105;
        goto LABEL_118;
      case 8:
        v94 = v120;
        v38 = a2;
        v66 = v105;
        goto LABEL_123;
      case 9:
        a1[8] = v107;
        a1[7] = v4;
        v97 = *a2;
        v98 = a2[2];
        a2[1] = v106;
        *a2 = v105;
        a2[2] = &v98[v105 - v97];
        a1[13] = v120;
        return sub_1004B0E0(a1, a2, -3);
      default:
        a1[8] = v107;
        a1[7] = v4;
        v99 = *a2;
        v100 = a2[2];
        a2[1] = v106;
        *a2 = v105;
        a2[2] = &v100[v105 - v99];
        a1[13] = v120;
        return sub_1004B0E0(a1, a2, -2);
    }
  }
}

// sub_1004A100 @ 0x1004A100
int __cdecl sub_1004A100(_DWORD *a1, int a2)
{
  int v2; // eax
  int (__cdecl *v3)(_DWORD, _DWORD, _DWORD); // eax
  int v4; // eax

  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    sub_1004A980(a1[1], a2);
  v2 = a1[10];
  a1[13] = v2;
  a1[12] = v2;
  v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  *a1 = 0;
  a1[7] = 0;
  a1[8] = 0;
  if ( v3 )
  {
    v4 = v3(0, 0, 0);
    a1[15] = v4;
    *(_DWORD *)(a2 + 48) = v4;
  }
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[10]);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[9]);
  (*(void (__cdecl **)(_DWORD, _DWORD *))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

// sub_1004A190 @ 0x1004A190
int __cdecl sub_1004A190(char a1, char a2, int a3, int a4, int a5)
{
  int result; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( result )
  {
    *(_BYTE *)(result + 16) = a1;
    *(_BYTE *)(result + 17) = a2;
    *(_DWORD *)result = 0;
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
  }
  return result;
}

// sub_1004A1D0 @ 0x1004A1D0
int __cdecl sub_1004A1D0(_DWORD *a1, unsigned __int8 **a2, int a3)
{
  _DWORD *v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // ecx
  int v13; // eax
  unsigned int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  unsigned int v17; // eax
  char v18; // cl
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  unsigned int v23; // eax
  char v24; // cl
  int v25; // ecx
  int v26; // ecx
  unsigned int v27; // eax
  char v28; // cl
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  unsigned int v32; // eax
  char v33; // cl
  int v34; // ecx
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ecx
  int v38; // eax
  int v39; // eax
  unsigned int v40; // eax
  int v41; // ecx
  unsigned int v42; // ecx
  int v43; // eax
  int v44; // ecx
  unsigned int v45; // eax
  unsigned int v46; // ecx
  int v47; // eax
  int v48; // eax
  unsigned int v49; // eax
  int v50; // ecx
  unsigned int v51; // ecx
  int v52; // eax
  unsigned __int8 *v53; // eax
  unsigned __int8 *v54; // ecx
  unsigned __int8 *v56; // ebx
  unsigned __int8 *v57; // ebx
  unsigned __int8 *v58; // ecx
  int v59; // eax
  unsigned __int8 *v60; // ebx
  unsigned __int8 *v61; // ebx
  unsigned __int8 *v62; // ebx
  _DWORD *v63; // [esp+10h] [ebp-10h]
  unsigned int v64; // [esp+14h] [ebp-Ch]
  unsigned int v65; // [esp+18h] [ebp-8h]
  unsigned __int8 *v66; // [esp+18h] [ebp-8h]
  unsigned int v67; // [esp+18h] [ebp-8h]
  unsigned int v68; // [esp+18h] [ebp-8h]
  unsigned int v69; // [esp+18h] [ebp-8h]
  _BYTE *v70; // [esp+1Ch] [ebp-4h]
  unsigned int v71; // [esp+24h] [ebp+4h]
  unsigned int v72; // [esp+28h] [ebp+8h]
  int v73; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[1];
  v6 = *a2;
  v7 = a1[7];
  v72 = (unsigned int)a2[1];
  v8 = a1[12];
  v71 = a1[8];
  v9 = (_BYTE *)a1[13];
  v63 = v5;
  if ( (unsigned int)v9 >= v8 )
    v10 = a1[11] - (_DWORD)v9;
  else
    v10 = v8 - (_DWORD)v9 - 1;
  v64 = v10;
  while ( 2 )
  {
    switch ( *v5 )
    {
      case 0:
        if ( v64 >= 0x102 && v72 >= 0xA )
        {
          a1[8] = v71;
          a1[7] = v7;
          v11 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          v12 = a2[2];
          *a2 = v6;
          a2[2] = &v12[v6 - v11];
          a1[13] = v9;
          v13 = sub_1004B220(*((unsigned __int8 *)v63 + 16), *((unsigned __int8 *)v63 + 17), v63[5], v63[6], a1, a2);
          v6 = *a2;
          v7 = a1[7];
          v72 = (unsigned int)a2[1];
          v14 = a1[12];
          v71 = a1[8];
          v9 = (_BYTE *)a1[13];
          a3 = v13;
          v15 = (unsigned int)v9 >= v14 ? a1[11] - (_DWORD)v9 : v14 - (_DWORD)v9 - 1;
          v64 = v15;
          if ( v13 )
          {
            *v63 = v13 != 1 ? 9 : 7;
            v5 = v63;
            continue;
          }
        }
        v5 = v63;
        v16 = *((unsigned __int8 *)v63 + 16);
        *v63 = 1;
        v63[3] = v16;
        v63[2] = v63[5];
        goto LABEL_14;
      case 1:
LABEL_14:
        v17 = v5[3];
        v65 = v17;
        if ( v7 >= v17 )
          goto LABEL_17;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v18 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v19 = (*v6 << v18) | v71;
          v17 = v65;
          ++v6;
          v71 = v19;
        }
        while ( v7 < v65 );
LABEL_17:
        v66 = (unsigned __int8 *)(v63[2] + 8 * (v71 & dword_10059608[v17]));
        v20 = v66[1];
        v71 >>= v20;
        v7 -= v20;
        v21 = *v66;
        if ( *v66 )
        {
          if ( (v21 & 0x10) != 0 )
          {
            v5 = v63;
            v63[2] = v21 & 0xF;
            v22 = *((_DWORD *)v66 + 1);
            *v63 = 2;
            v63[1] = v22;
          }
          else
          {
            if ( (v21 & 0x40) == 0 )
              goto LABEL_22;
            v5 = v63;
            if ( (v21 & 0x20) == 0 )
            {
              *v63 = 9;
              a2[6] = (unsigned __int8 *)aInvalidLiteral_0;
LABEL_88:
              a1[8] = v71;
              a1[7] = v7;
              v56 = *a2;
              a2[1] = (unsigned __int8 *)v72;
              a2[2] += v6 - v56;
              *a2 = v6;
              a1[13] = v9;
              return sub_1004B0E0(a1, a2, -3);
            }
            *v63 = 7;
          }
        }
        else
        {
          v5 = v63;
          v63[2] = *((_DWORD *)v66 + 1);
          *v63 = 6;
        }
        continue;
      case 2:
        v23 = v5[2];
        v67 = v23;
        if ( v7 >= v23 )
          goto LABEL_28;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v24 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v25 = (*v6 << v24) | v71;
          v23 = v67;
          ++v6;
          v71 = v25;
        }
        while ( v7 < v67 );
LABEL_28:
        v63[1] += v71 & dword_10059608[v23];
        v71 >>= v67;
        v7 -= v67;
        v5 = v63;
        v26 = *((unsigned __int8 *)v63 + 17);
        *v63 = 3;
        v63[3] = v26;
        v63[2] = v63[6];
LABEL_29:
        v27 = v5[3];
        v68 = v27;
        if ( v7 < v27 )
        {
          while ( v72 )
          {
            v28 = v7;
            --v72;
            v7 += 8;
            a3 = 0;
            v29 = (*v6 << v28) | v71;
            v27 = v68;
            ++v6;
            v71 = v29;
            if ( v7 >= v68 )
              goto LABEL_32;
          }
LABEL_86:
          a1[7] = v7;
          a1[8] = v71;
          v53 = a2[2];
          v54 = (unsigned __int8 *)(v6 - *a2);
          a2[1] = 0;
          *a2 = v6;
          a2[2] = &v53[(_DWORD)v54];
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, a3);
        }
LABEL_32:
        v66 = (unsigned __int8 *)(v63[2] + 8 * (v71 & dword_10059608[v27]));
        v30 = v66[1];
        v7 -= v30;
        v71 >>= v30;
        v21 = *v66;
        if ( (v21 & 0x10) != 0 )
        {
          v5 = v63;
          v63[2] = v21 & 0xF;
          v31 = *((_DWORD *)v66 + 1);
          *v63 = 4;
          v63[3] = v31;
        }
        else
        {
          if ( (v21 & 0x40) != 0 )
          {
            *v63 = 9;
            a2[6] = (unsigned __int8 *)aInvalidDistanc_0;
            goto LABEL_88;
          }
LABEL_22:
          v63[3] = v21;
          v5 = v63;
          v63[2] = &v66[8 * *((_DWORD *)v66 + 1)];
        }
        continue;
      case 3:
        goto LABEL_29;
      case 4:
        v32 = v5[2];
        v69 = v32;
        if ( v7 >= v32 )
          goto LABEL_39;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v33 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v34 = (*v6 << v33) | v71;
          v32 = v69;
          ++v6;
          v71 = v34;
        }
        while ( v7 < v69 );
LABEL_39:
        v63[3] += v71 & dword_10059608[v32];
        v71 >>= v69;
        v7 -= v69;
        *v63 = 5;
LABEL_40:
        v35 = v63[3];
        if ( (unsigned int)&v9[-a1[10]] >= v35 )
          v70 = &v9[-v35];
        else
          v70 = &v9[a1[11] - a1[10] - v63[3]];
        v5 = v63;
        if ( !v63[1] )
        {
LABEL_65:
          *v5 = 0;
          continue;
        }
        while ( v64 )
        {
LABEL_62:
          ++v9;
          a3 = 0;
          *(v9 - 1) = *v70++;
          --v64;
          if ( v70 == (_BYTE *)a1[11] )
            v70 = (_BYTE *)a1[10];
          v44 = v5[1] - 1;
          v5[1] = v44;
          if ( !v44 )
            goto LABEL_65;
        }
        if ( v9 == (_BYTE *)a1[11] )
        {
          v36 = a1[12];
          v37 = a1[10];
          if ( v36 != v37 )
          {
            v9 = (_BYTE *)a1[10];
            v38 = v37 >= v36 ? a1[11] - v37 : v36 - v37 - 1;
            v64 = v38;
            if ( v38 )
              goto LABEL_61;
          }
        }
        a1[13] = v9;
        v39 = sub_1004B0E0(a1, a2, a3);
        v9 = (_BYTE *)a1[13];
        v73 = v39;
        v40 = a1[12];
        if ( (unsigned int)v9 >= v40 )
          v41 = a1[11] - (_DWORD)v9;
        else
          v41 = v40 - (_DWORD)v9 - 1;
        v64 = v41;
        if ( v9 == (_BYTE *)a1[11] )
        {
          v42 = a1[10];
          if ( v40 != v42 )
          {
            v9 = (_BYTE *)a1[10];
            if ( v42 >= v40 )
              v43 = a1[11] - v42;
            else
              v43 = v40 - v42 - 1;
            v64 = v43;
          }
        }
        if ( v64 )
        {
LABEL_61:
          v5 = v63;
          goto LABEL_62;
        }
LABEL_89:
        a1[8] = v71;
        a1[7] = v7;
        v57 = *a2;
        a2[1] = (unsigned __int8 *)v72;
        v58 = a2[2];
        *a2 = v6;
        a2[2] = &v58[v6 - v57];
        a1[13] = v9;
        return sub_1004B0E0(a1, a2, v73);
      case 5:
        goto LABEL_40;
      case 6:
        if ( v64 )
          goto LABEL_84;
        if ( v9 != (_BYTE *)a1[11]
          || (v45 = a1[12], v46 = a1[10], v45 == v46)
          || ((v9 = (_BYTE *)a1[10], v46 >= v45) ? (v47 = a1[11] - v46) : (v47 = v45 - v46 - 1), (v64 = v47) == 0) )
        {
          a1[13] = v9;
          v48 = sub_1004B0E0(a1, a2, a3);
          v9 = (_BYTE *)a1[13];
          v73 = v48;
          v49 = a1[12];
          if ( (unsigned int)v9 >= v49 )
            v50 = a1[11] - (_DWORD)v9;
          else
            v50 = v49 - (_DWORD)v9 - 1;
          v64 = v50;
          if ( v9 == (_BYTE *)a1[11] )
          {
            v51 = a1[10];
            if ( v49 != v51 )
            {
              v9 = (_BYTE *)a1[10];
              if ( v51 >= v49 )
                v52 = a1[11] - v51;
              else
                v52 = v49 - v51 - 1;
              v64 = v52;
            }
          }
          if ( !v64 )
            goto LABEL_89;
        }
        v5 = v63;
LABEL_84:
        a3 = 0;
        *v9++ = *((_BYTE *)v5 + 8);
        --v64;
        *v5 = 0;
        continue;
      case 7:
        if ( v7 > 7 )
        {
          v7 -= 8;
          --v6;
          ++v72;
        }
        a1[13] = v9;
        v59 = sub_1004B0E0(a1, a2, a3);
        v9 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] == v9 )
        {
          *v63 = 8;
LABEL_95:
          a1[8] = v71;
          a1[7] = v7;
          v61 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          a2[2] += v6 - v61;
          *a2 = v6;
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, 1);
        }
        else
        {
          a1[7] = v7;
          a1[8] = v71;
          v60 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          a2[2] += v6 - v60;
          *a2 = v6;
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, v59);
        }
      case 8:
        goto LABEL_95;
      case 9:
        goto LABEL_88;
      default:
        a1[8] = v71;
        a1[7] = v7;
        v62 = *a2;
        a2[1] = (unsigned __int8 *)v72;
        a2[2] += v6 - v62;
        *a2 = v6;
        a1[13] = v9;
        return sub_1004B0E0(a1, a2, -2);
    }
  }
}

// sub_1004A980 @ 0x1004A980
int __cdecl sub_1004A980(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

// sub_1004A9A0 @ 0x1004A9A0
int __cdecl sub_1004A9A0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // [esp-10h] [ebp-1Ch]
  int v10; // [esp+8h] [ebp-4h] BYREF

  v10 = 0;
  v5 = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v5 )
    return -4;
  v7 = sub_1004AA50(a1, 19, 19, 0, 0, a3, a2, a4, &v10, v5);
  v8 = v7;
  if ( v7 == -3 )
  {
    v9 = *(_DWORD *)(a5 + 40);
    *(_DWORD *)(a5 + 24) = aOversubscribed_2;
    (*(void (__cdecl **)(int, int))(a5 + 36))(v9, v5);
    return -3;
  }
  else
  {
    if ( v7 == -5 || !*a2 )
    {
      *(_DWORD *)(a5 + 24) = aIncompleteDyna_0;
      v8 = -3;
    }
    (*(void (__cdecl **)(_DWORD, int))(a5 + 36))(*(_DWORD *)(a5 + 40), v5);
    return v8;
  }
}

// sub_1004AA50 @ 0x1004AA50
int __cdecl sub_1004AA50(
        int *a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        int a5,
        _DWORD *a6,
        unsigned int *a7,
        int a8,
        unsigned int *a9,
        unsigned int *a10)
{
  int *v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // edx
  int v13; // eax
  unsigned int v15; // ecx
  _DWORD *v16; // eax
  unsigned int v17; // ebp
  signed int v18; // eax
  unsigned int v19; // edx
  int *v20; // esi
  int v21; // esi
  _DWORD *v22; // ebx
  int v23; // esi
  int v24; // ebx
  int v25; // esi
  int v26; // ecx
  unsigned int v27; // edx
  int v28; // ebx
  int *v29; // edx
  unsigned int v30; // ebx
  int v31; // ecx
  int v32; // edx
  int v33; // ebx
  unsigned int v34; // esi
  int v35; // edx
  unsigned int v36; // ecx
  unsigned int v37; // edx
  unsigned int v38; // ecx
  unsigned int v39; // eax
  _DWORD *v40; // ebp
  unsigned int v41; // eax
  unsigned int v42; // edi
  unsigned int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // edx
  int v46; // eax
  unsigned int v47; // eax
  int v48; // ecx
  char v49; // dl
  int v50; // esi
  int v51; // edx
  unsigned int v52; // eax
  _DWORD *v53; // ecx
  unsigned int i; // eax
  int v55; // edx
  _DWORD *v56; // eax
  int v57; // edx
  unsigned int v58; // [esp+10h] [ebp-100h]
  signed int v59; // [esp+14h] [ebp-FCh]
  int v60; // [esp+18h] [ebp-F8h]
  int *v61; // [esp+1Ch] [ebp-F4h]
  unsigned int *v62; // [esp+1Ch] [ebp-F4h]
  unsigned int v63; // [esp+20h] [ebp-F0h]
  char v64; // [esp+20h] [ebp-F0h]
  int v65; // [esp+24h] [ebp-ECh]
  _DWORD *v66; // [esp+28h] [ebp-E8h]
  signed int v67; // [esp+2Ch] [ebp-E4h]
  int v68; // [esp+30h] [ebp-E0h]
  unsigned int v69; // [esp+34h] [ebp-DCh]
  unsigned int v70; // [esp+38h] [ebp-D8h]
  unsigned int v71; // [esp+3Ch] [ebp-D4h]
  int v72; // [esp+40h] [ebp-D0h]
  int v73; // [esp+44h] [ebp-CCh]
  signed int v74; // [esp+48h] [ebp-C8h]
  _DWORD *v75; // [esp+4Ch] [ebp-C4h]
  unsigned int v76; // [esp+50h] [ebp-C0h]
  int v77; // [esp+54h] [ebp-BCh] BYREF
  _DWORD v78[14]; // [esp+58h] [ebp-B8h] BYREF
  int v79; // [esp+90h] [ebp-80h] BYREF
  int v80; // [esp+94h] [ebp-7Ch] BYREF
  _DWORD v81[15]; // [esp+98h] [ebp-78h]
  _DWORD v82[15]; // [esp+D4h] [ebp-3Ch] BYREF
  int v83; // [esp+118h] [ebp+8h]

  v10 = a1;
  v11 = 0;
  v12 = a2;
  v77 = 0;
  memset(v78, 0, sizeof(v78));
  v79 = 0;
  do
  {
    v13 = *v10++;
    --v12;
    ++v78[v13 - 1];
  }
  while ( v12 );
  if ( v77 == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    return 0;
  }
  v15 = 1;
  v16 = v78;
  v17 = *a7;
  v58 = *a7;
  do
  {
    if ( *v16 )
      break;
    ++v15;
    ++v16;
  }
  while ( v15 <= 0xF );
  v18 = v15;
  v59 = v15;
  if ( v17 < v15 )
  {
    v58 = v15;
    v17 = v15;
  }
  v19 = 15;
  v20 = &v79;
  do
  {
    if ( *v20 )
      break;
    --v19;
    --v20;
  }
  while ( v19 );
  v67 = v19;
  if ( v17 > v19 )
  {
    v58 = v19;
    v17 = v19;
  }
  *a7 = v17;
  v21 = 1 << v15;
  if ( v15 < v19 )
  {
    v22 = &v78[v15 - 1];
    do
    {
      v23 = v21 - *v22;
      if ( v23 < 0 )
        return -3;
      ++v15;
      ++v22;
      v21 = 2 * v23;
    }
    while ( v15 < v19 );
  }
  v63 = v19;
  v24 = v78[v19 - 1];
  v25 = v21 - v24;
  v73 = v25;
  if ( v25 < 0 )
    return -3;
  v81[0] = 0;
  v78[v19 - 1] = v25 + v24;
  v26 = 0;
  v27 = v19 - 1;
  if ( v27 )
  {
    v28 = 0;
    do
    {
      v26 += v78[v28++];
      --v27;
      v81[v28] = v26;
    }
    while ( v27 );
  }
  v29 = a1;
  v30 = 0;
  do
  {
    v31 = *v29++;
    v61 = v29;
    if ( v31 )
    {
      v32 = v81[v31 - 1];
      a10[v32] = v30;
      v25 = v73;
      v81[v31 - 1] = v32 + 1;
      v29 = v61;
    }
    ++v30;
  }
  while ( v30 < a2 );
  v33 = -v17;
  v62 = a10;
  v83 = v81[v63 - 1];
  v70 = 0;
  v80 = 0;
  v60 = -1;
  v82[0] = 0;
  v72 = 0;
  v71 = 0;
  if ( v18 > v67 )
  {
LABEL_66:
    if ( !v25 || v67 == 1 )
      return 0;
    return -5;
  }
  else
  {
    v34 = v69;
    v64 = v18 - 1;
    v66 = &v78[v18 - 1];
    while ( 1 )
    {
      v35 = *v66 - 1;
      v65 = v35;
      if ( *v66 )
        break;
LABEL_64:
      ++v18;
      ++v66;
      v59 = v18;
      ++v64;
      if ( v18 > v67 )
      {
        v25 = v73;
        goto LABEL_66;
      }
    }
    while ( 1 )
    {
      v36 = v33 + v17;
      if ( v18 > (int)(v33 + v17) )
        break;
LABEL_49:
      BYTE1(v68) = v18 - v33;
      if ( v62 < &a10[v83] )
      {
        v34 = *v62;
        if ( *v62 >= a3 )
        {
          v50 = 4 * (v34 - a3);
          v49 = *(_BYTE *)(v50 + a5) + 80;
          v34 = *(_DWORD *)(v50 + a4);
        }
        else
        {
          v49 = v34 < 0x100 ? 0 : 96;
        }
        LOBYTE(v68) = v49;
        ++v62;
      }
      else
      {
        LOBYTE(v68) = -64;
      }
      v51 = 1 << (v18 - v33);
      v52 = v11 >> v33;
      if ( v11 >> v33 < v71 )
      {
        v53 = (_DWORD *)(v72 + 8 * v52);
        do
        {
          v52 += v51;
          *v53 = v68;
          v53[1] = v34;
          v53 += 2 * v51;
        }
        while ( v52 < v71 );
      }
      for ( i = 1 << v64; (i & v11) != 0; i >>= 1 )
        v11 ^= i;
      v55 = v60;
      v11 ^= i;
      v56 = &v81[v60 - 1];
      v70 = v11;
      if ( (v11 & ((1 << v33) - 1)) != *v56 )
      {
        do
        {
          --v55;
          v33 -= v58;
          --v56;
        }
        while ( (v11 & ((1 << v33) - 1)) != *v56 );
        v60 = v55;
      }
      v17 = v58;
      v57 = v65--;
      v18 = v59;
      if ( !v57 )
        goto LABEL_64;
      v35 = v65;
    }
    v76 = v35 + 1;
    while ( 1 )
    {
      v33 += v17;
      ++v60;
      v37 = v67 - v33;
      v74 = v17 + v36;
      if ( v67 - v33 > v17 )
        v37 = v17;
      v38 = v18 - v33;
      v39 = 1 << (v18 - v33);
      if ( v39 > v76 )
      {
        v40 = v66;
        v41 = -1 - v65 + v39;
        if ( v38 < v37 && ++v38 < v37 )
        {
          do
          {
            v42 = v40[1];
            ++v40;
            v43 = 2 * v41;
            if ( v43 <= v42 )
              break;
            v41 = v43 - v42;
            ++v38;
          }
          while ( v38 < v37 );
        }
      }
      v44 = *a9;
      v71 = 1 << v38;
      v45 = *a9 + (1 << v38);
      if ( v45 > 0x5A0 )
        return -4;
      *a9 = v45;
      v46 = a8 + 8 * v44;
      v72 = v46;
      v75 = &v82[v60];
      *v75 = v46;
      v11 = v70;
      if ( v60 )
      {
        LOBYTE(v68) = v38;
        v81[v60 - 1] = v70;
        BYTE1(v68) = v58;
        v47 = v70 >> (v33 - v58);
        v48 = *(v75 - 1);
        v34 = ((v72 - v48) >> 3) - v47;
        *(_DWORD *)(v48 + 8 * v47) = v68;
        *(_DWORD *)(v48 + 8 * v47 + 4) = v34;
      }
      else
      {
        *a6 = v46;
      }
      v36 = v74;
      LOBYTE(v18) = v59;
      if ( v59 <= v74 )
        goto LABEL_49;
      v17 = v58;
      v18 = v59;
    }
  }
}

// sub_1004AF20 @ 0x1004AF20
int __cdecl sub_1004AF20(
        unsigned int a1,
        unsigned int a2,
        int *a3,
        unsigned int *a4,
        unsigned int *a5,
        _DWORD *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // [esp-Ch] [ebp-20h]
  int v15; // [esp-8h] [ebp-1Ch]
  int v16; // [esp-8h] [ebp-1Ch]
  int v17; // [esp-8h] [ebp-1Ch]
  unsigned int v18; // [esp+10h] [ebp-4h] BYREF

  v14 = *(_DWORD *)(a9 + 40);
  v18 = 0;
  v9 = (unsigned int *)(*(int (__cdecl **)(int, int, int))(a9 + 32))(v14, 288, 4);
  if ( !v9 )
    return -4;
  v11 = sub_1004AA50(a3, a1, 0x101u, (int)&unk_100514D0, (int)&unk_1005154C, a6, a4, a8, &v18, v9);
  v12 = v11;
  if ( v11 )
  {
    if ( v11 == -3 )
    {
      v17 = *(_DWORD *)(a9 + 40);
      *(_DWORD *)(a9 + 24) = aOversubscribed_4;
      (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v17, v9);
      return -3;
    }
    if ( v11 == -4 )
      goto LABEL_20;
LABEL_19:
    *(_DWORD *)(a9 + 24) = aIncompleteLite_0;
    v12 = -3;
    goto LABEL_20;
  }
  if ( !*a4 )
    goto LABEL_19;
  v13 = sub_1004AA50(&a3[a1], a2, 0, (int)&unk_100515C8, (int)&unk_10051640, a7, a5, a8, &v18, v9);
  v12 = v13;
  if ( v13 )
  {
    switch ( v13 )
    {
      case -3:
        v15 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aOversubscribed_3;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v15, v9);
        return -3;
      case -5:
        v16 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aIncompleteDist_0;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v16, v9);
        return -3;
      case -4:
        goto LABEL_20;
    }
  }
  else if ( *a5 || a1 <= 0x101 )
  {
    (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
    return 0;
  }
  *(_DWORD *)(a9 + 24) = aEmptyDistanceT_0;
  v12 = -3;
LABEL_20:
  (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
  return v12;
}

// inflate_trees_fixed @ 0x1004B0B0
// zlib (internal): return fixed Huffman trees
int inflate_trees_fixed(unsigned int *bl, unsigned int *bd, void **tl, void **td, void *z)
{
  *bl = dword_10058410;
  *bd = dword_10058414;
  *tl = &unk_10058418;
  *td = &unk_10059418;
  return 0;
}

// sub_1004B0E0 @ 0x1004B0E0
int __cdecl sub_1004B0E0(_DWORD *a1, _DWORD *a2, int a3)
{
  unsigned int v3; // ebp
  char *v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edx
  int (__cdecl *v8)(_DWORD, char *, unsigned int); // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // ecx
  char *v12; // esi
  unsigned int v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // edx
  int (__cdecl *v16)(_DWORD, char *, unsigned int); // eax
  int v17; // eax
  char *v18; // edi
  char *v20; // [esp+10h] [ebp-4h]
  char *v21; // [esp+10h] [ebp-4h]

  v3 = a1[13];
  v4 = (char *)a1[12];
  v20 = (char *)a2[3];
  if ( (unsigned int)v4 > v3 )
    v3 = a1[11];
  v5 = a2[4];
  v6 = v3 - (_DWORD)v4;
  if ( v6 > v5 )
    v6 = a2[4];
  if ( v6 && a3 == -5 )
    a3 = 0;
  v7 = v6 + a2[5];
  a2[4] = v5 - v6;
  a2[5] = v7;
  v8 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
  if ( v8 )
  {
    v9 = v8(a1[15], v4, v6);
    a1[15] = v9;
    a2[12] = v9;
  }
  qmemcpy(v20, v4, v6);
  v10 = &v4[v6];
  v11 = (char *)a1[11];
  v21 = &v20[v6];
  if ( &v4[v6] == v11 )
  {
    v12 = (char *)a1[10];
    if ( (char *)a1[13] == v11 )
      a1[13] = v12;
    v13 = a1[13] - (_DWORD)v12;
    v14 = a2[4];
    if ( v13 > v14 )
      v13 = a2[4];
    if ( v13 && a3 == -5 )
      a3 = 0;
    v15 = v13 + a2[5];
    a2[4] = v14 - v13;
    a2[5] = v15;
    v16 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
    if ( v16 )
    {
      v17 = v16(a1[15], v12, v13);
      a1[15] = v17;
      a2[12] = v17;
    }
    qmemcpy(v21, v12, 4 * (v13 >> 2));
    v18 = &v21[4 * (v13 >> 2)];
    v21 += v13;
    v10 = &v12[v13];
    qmemcpy(v18, &v12[4 * (v13 >> 2)], v13 & 3);
  }
  a2[3] = v21;
  a1[12] = v10;
  return a3;
}

// sub_1004B220 @ 0x1004B220
int __cdecl sub_1004B220(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6)
{
  _BYTE *v6; // ebx
  unsigned int v7; // esi
  unsigned int v8; // edx
  unsigned __int8 **v9; // edi
  unsigned __int8 *v10; // ebp
  unsigned int v11; // eax
  int v12; // esi
  int v13; // ebx
  _BYTE *v14; // esi
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ebx
  unsigned int v19; // eax
  unsigned int i; // edx
  int v21; // esi
  int v22; // ebx
  int v23; // esi
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  unsigned int j; // ebx
  char v28; // cl
  unsigned int v29; // edi
  int v30; // esi
  _BYTE *v31; // ecx
  _BYTE *v32; // esi
  unsigned int v33; // edi
  int v34; // ecx
  unsigned int v35; // ebx
  unsigned int v36; // ecx
  unsigned int v37; // esi
  unsigned int v38; // ecx
  unsigned __int8 *v39; // ebp
  unsigned __int8 *v40; // edx
  int v41; // ecx
  unsigned int v43; // ecx
  unsigned __int8 *v44; // ebp
  unsigned __int8 *v45; // edx
  unsigned __int8 *v46; // ecx
  unsigned __int8 *v47; // ebp
  unsigned __int8 *v48; // edx
  unsigned __int8 *v49; // ecx
  unsigned int v50; // [esp+10h] [ebp-14h]
  _BYTE *v51; // [esp+14h] [ebp-10h]
  unsigned int v52; // [esp+18h] [ebp-Ch]
  int v53; // [esp+1Ch] [ebp-8h]
  int v54; // [esp+20h] [ebp-4h]
  unsigned int v55; // [esp+28h] [ebp+4h]

  v6 = (_BYTE *)a5[13];
  v7 = a5[12];
  v8 = a5[8];
  v9 = a6;
  v51 = v6;
  v10 = *a6;
  v50 = (unsigned int)a6[1];
  v11 = a5[7];
  if ( (unsigned int)v6 >= v7 )
    v52 = a5[11] - (_DWORD)v6;
  else
    v52 = v7 - (_DWORD)v6 - 1;
  v53 = dword_10059608[a1];
  v54 = dword_10059608[a2];
  while ( 1 )
  {
    for ( ; v11 < 0x14; ++v10 )
    {
      --v50;
      v12 = *v10 << v11;
      v11 += 8;
      v8 |= v12;
    }
    v13 = *(unsigned __int8 *)(a3 + 8 * (v8 & v53));
    v14 = (_BYTE *)(a3 + 8 * (v8 & v53));
    if ( *v14 )
      break;
LABEL_27:
    v34 = (unsigned __int8)v14[1];
    v8 >>= v34;
    v11 -= v34;
    *v51++ = v14[4];
    --v52;
LABEL_28:
    if ( v52 < 0x102 || v50 < 0xA )
    {
      v38 = (unsigned int)&v9[1][-v50];
      if ( v11 >> 3 < v38 )
        v38 = v11 >> 3;
      v39 = &v10[-v38];
      a5[8] = v8;
      a5[7] = v11 - 8 * v38;
      v40 = *v9;
      v9[1] = (unsigned __int8 *)(v50 + v38);
      v41 = (int)&v9[2][v39 - v40];
      *v9 = v39;
      v9[2] = (unsigned __int8 *)v41;
      a5[13] = v51;
      return 0;
    }
  }
  v15 = (unsigned __int8)v14[1];
  v8 >>= v15;
  v11 -= v15;
  if ( (v13 & 0x10) != 0 )
  {
LABEL_12:
    v18 = v13 & 0xF;
    v19 = v11 - v18;
    v55 = *((_DWORD *)v14 + 1) + (v8 & dword_10059608[v18]);
    for ( i = v8 >> v18; v19 < 0xF; ++v10 )
    {
      --v50;
      v21 = *v10 << v19;
      v19 += 8;
      i |= v21;
    }
    v22 = *(unsigned __int8 *)(a4 + 8 * (i & v54));
    v23 = a4 + 8 * (i & v54);
    v24 = *(unsigned __int8 *)(v23 + 1);
    v8 = i >> v24;
    v11 = v19 - v24;
    if ( (v22 & 0x10) == 0 )
    {
      while ( (v22 & 0x40) == 0 )
      {
        v25 = *(_DWORD *)(v23 + 4) + (v8 & dword_10059608[v22]);
        v22 = *(unsigned __int8 *)(v23 + 8 * v25);
        v23 += 8 * v25;
        v26 = *(unsigned __int8 *)(v23 + 1);
        v8 >>= v26;
        v11 -= v26;
        if ( (v22 & 0x10) != 0 )
          goto LABEL_17;
      }
      v35 = v50;
      v36 = (unsigned int)&v9[1][-v50];
      v37 = v11 >> 3;
      v9[6] = (unsigned __int8 *)aInvalidDistanc_0;
      if ( v11 >> 3 < v36 )
LABEL_41:
        v36 = v37;
LABEL_42:
      v47 = &v10[-v36];
      a5[8] = v8;
      a5[7] = v11 - 8 * v36;
      v48 = *v9;
      v9[1] = (unsigned __int8 *)(v35 + v36);
      v49 = v9[2];
      *v9 = v47;
      v9[2] = &v49[v47 - v48];
      a5[13] = v51;
      return -3;
    }
LABEL_17:
    for ( j = v22 & 0xF; v11 < j; ++v10 )
    {
      --v50;
      v28 = v11;
      v11 += 8;
      v8 |= *v10 << v28;
    }
    v29 = *(_DWORD *)(v23 + 4) + (v8 & dword_10059608[j]);
    v8 >>= j;
    v11 -= j;
    v52 -= v55;
    v30 = a5[10];
    v31 = v51;
    if ( (unsigned int)&v51[-v30] < v29 )
    {
      v33 = v29 + v30 - (_DWORD)v51;
      v32 = (_BYTE *)(a5[11] - v33);
      if ( v55 > v33 )
      {
        v55 -= v33;
        do
        {
          *v31++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = (_BYTE *)a5[10];
      }
    }
    else
    {
      *v51 = v51[-v29];
      v31 = v51 + 2;
      v32 = &v51[-v29 + 2];
      v51[1] = v51[-v29 + 1];
      v55 -= 2;
    }
    do
    {
      *v31++ = *v32++;
      --v55;
    }
    while ( v55 );
    v9 = a6;
    v51 = v31;
    goto LABEL_28;
  }
  while ( (v13 & 0x40) == 0 )
  {
    v16 = *((_DWORD *)v14 + 1) + (v8 & dword_10059608[v13]);
    v13 = (unsigned __int8)v14[8 * v16];
    v14 += 8 * v16;
    if ( !v13 )
      goto LABEL_27;
    v17 = (unsigned __int8)v14[1];
    v8 >>= v17;
    v11 -= v17;
    if ( (v13 & 0x10) != 0 )
      goto LABEL_12;
  }
  if ( (v13 & 0x20) == 0 )
  {
    v35 = v50;
    v36 = (unsigned int)&v9[1][-v50];
    v37 = v11 >> 3;
    v9[6] = (unsigned __int8 *)aInvalidLiteral_0;
    if ( v11 >> 3 < v36 )
      goto LABEL_41;
    goto LABEL_42;
  }
  v43 = (unsigned int)&v9[1][-v50];
  if ( v11 >> 3 < v43 )
    v43 = v11 >> 3;
  v44 = &v10[-v43];
  a5[8] = v8;
  a5[7] = v11 - 8 * v43;
  v45 = *v9;
  v9[1] = (unsigned __int8 *)(v50 + v43);
  v46 = v9[2];
  *v9 = v44;
  v9[2] = &v46[v44 - v45];
  a5[13] = v51;
  return 1;
}
