
// nullsub_11 @ 0x10001030
void nullsub_11()
{
  ;
}

// nullsub_12 @ 0x10001050
void nullsub_12()
{
  ;
}

// nullsub_13 @ 0x10001070
void nullsub_13()
{
  ;
}

// nullsub_14 @ 0x10001090
void nullsub_14()
{
  ;
}

// nullsub_15 @ 0x100010B0
void nullsub_15()
{
  ;
}

// nullsub_16 @ 0x100010D0
void nullsub_16()
{
  ;
}

// nullsub_17 @ 0x100010F0
void nullsub_17()
{
  ;
}

// nullsub_18 @ 0x10001110
void nullsub_18()
{
  ;
}

// nullsub_19 @ 0x10001130
void nullsub_19()
{
  ;
}

// sub_10001140 @ 0x10001140
char sub_10001140()
{
  grim_error_text = (int)aSystemNoFrameF;
  return 0;
}

// grim_noop @ 0x10001160
// debug stub (no-op)
void nullsub_1()
{
  ;
}

// sub_10001170 @ 0x10001170
INT_PTR __stdcall sub_10001170(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  INT_PTR result; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND DlgItem; // eax
  int v14; // eax
  HWND v15; // eax
  int v16; // eax
  HWND v17; // eax
  int v18; // eax
  HWND v19; // eax
  int v20; // eax
  HWND v21; // eax
  int v22; // eax
  HWND v23; // eax
  HWND v24; // eax
  HWND v25; // eax
  HWND v26; // eax
  HWND v27; // eax
  HWND v28; // eax
  HWND v29; // eax
  HWND v30; // eax
  HWND v31; // eax
  HWND v32; // eax
  HWND v33; // eax
  WPARAM v34; // [esp-8h] [ebp-18h]
  WPARAM v35; // [esp-8h] [ebp-18h]
  WPARAM v36; // [esp-8h] [ebp-18h]

  if ( a2 == 16 )
  {
    EndDialog(hDlg, (unsigned __int16)a3);
    return 0;
  }
  if ( a2 == 272 )
  {
    SendMessageA(hDlg, 0x80u, 1u, lParam);
    SendMessageA(hDlg, 0x80u, 0, lParam);
    dword_1005BC18[0] = 0;
    dword_1005D80C = 1;
    DlgItem = GetDlgItem(hDlg, 1026);
    SendMessageA(DlgItem, 0x143u, 0, (LPARAM)aAutodetectSele);
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           21) >= 0 )
    {
      v14 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 21;
      dword_1005D80C = v14 + 1;
      v15 = GetDlgItem(hDlg, 1026);
      SendMessageA(v15, 0x143u, 0, (LPARAM)a32BitA8r8g8b8H);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           29) >= 0 )
    {
      v16 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 29;
      dword_1005D80C = v16 + 1;
      v17 = GetDlgItem(hDlg, 1026);
      SendMessageA(v17, 0x143u, 0, (LPARAM)a16BitA8r3g3b2);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           26) >= 0 )
    {
      v18 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 26;
      dword_1005D80C = v18 + 1;
      v19 = GetDlgItem(hDlg, 1026);
      SendMessageA(v19, 0x143u, 0, (LPARAM)a16BitA4r4g4b4);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           861165636) >= 0 )
    {
      v20 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 861165636;
      dword_1005D80C = v20 + 1;
      v21 = GetDlgItem(hDlg, 1026);
      SendMessageA(v21, 0x143u, 0, (LPARAM)aDxt3Compressed);
    }
    if ( (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8_probe + 40))(
           grim_d3d8_probe,
           wParam,
           1,
           grim_texture_format,
           0,
           3,
           894720068) >= 0 )
    {
      v22 = dword_1005D80C;
      dword_1005BC18[dword_1005D80C] = 894720068;
      dword_1005D80C = v22 + 1;
      v23 = GetDlgItem(hDlg, 1026);
      SendMessageA(v23, 0x143u, 0, (LPARAM)aDxt5Compressed);
    }
    v24 = GetDlgItem(hDlg, 1026);
    SendMessageA(v24, 0x14Eu, 0, 0);
    v25 = GetDlgItem(hDlg, 1032);
    SendMessageA(v25, 0x143u, 0, (LPARAM)aDoubleSlowest4);
    v26 = GetDlgItem(hDlg, 1032);
    SendMessageA(v26, 0x143u, 0, (LPARAM)aFullDefault);
    v27 = GetDlgItem(hDlg, 1032);
    SendMessageA(v27, 0x143u, 0, (LPARAM)aHalfFaster4xLe);
    v28 = GetDlgItem(hDlg, 1032);
    SendMessageA(v28, 0x143u, 0, (LPARAM)aNoneStaticText);
    v29 = GetDlgItem(hDlg, 1032);
    SendMessageA(v29, 0x14Eu, 1u, 0);
    if ( *(float *)&dword_1005D118 == 0.5 )
    {
      v34 = 0;
LABEL_33:
      v30 = GetDlgItem(hDlg, 1032);
      SendMessageA(v30, 0x14Eu, v34, 0);
      byte_1005D400 = byte_1005D0C8;
      if ( byte_1005D0C8 )
      {
        v31 = GetDlgItem(hDlg, 1032);
        SendMessageA(v31, 0x14Eu, 3u, 0);
      }
      v35 = byte_1005D0B8 == 1;
      v32 = GetDlgItem(hDlg, 1029);
      SendMessageA(v32, 0xF1u, v35, 0);
      v36 = (_BYTE)dword_1005D108 != 0;
      v33 = GetDlgItem(hDlg, 1028);
      SendMessageA(v33, 0xF1u, v36, 0);
      return 1;
    }
    if ( *(float *)&dword_1005D118 != 1.0 )
    {
      if ( *(float *)&dword_1005D118 == 2.0 )
      {
        v34 = 2;
        goto LABEL_33;
      }
      if ( *(float *)&dword_1005D118 == 4.0 )
      {
        v34 = 3;
        goto LABEL_33;
      }
      dword_1005D118 = 1065353216;
    }
    v34 = 1;
    goto LABEL_33;
  }
  if ( a2 != 273 )
    return 0;
  if ( (unsigned __int16)a3 == 1001 )
  {
    EndDialog(hDlg, 1001);
    return 0;
  }
  if ( (unsigned __int16)a3 != 1027 )
  {
    if ( (unsigned __int16)a3 == 1030 )
    {
      byte_1005D0B8 = 0;
      v4 = GetDlgItem(hDlg, 1029);
      SendMessageA(v4, 0xF1u, 0, 0);
      LOBYTE(dword_1005D108) = 1;
      v5 = GetDlgItem(hDlg, 1028);
      SendMessageA(v5, 0xF1u, 1u, 0);
      dword_1005D118 = 1065353216;
      v6 = GetDlgItem(hDlg, 1032);
      SendMessageA(v6, 0x14Eu, 1u, 0);
      v7 = GetDlgItem(hDlg, 1026);
      SendMessageA(v7, 0x14Eu, 0, 0);
      return 0;
    }
    return 0;
  }
  v9 = GetDlgItem(hDlg, 1028);
  LOBYTE(dword_1005D108) = SendMessageA(v9, 0xF0u, 0, 0) != 0;
  v10 = GetDlgItem(hDlg, 1026);
  grim_preferred_texture_format = dword_1005BC18[SendMessageA(v10, 0x147u, 0, 0)];
  v11 = GetDlgItem(hDlg, 1029);
  byte_1005D0B8 = SendMessageA(v11, 0xF0u, 0, 0) != 0;
  byte_1005D400 = 0;
  v12 = GetDlgItem(hDlg, 1032);
  switch ( SendMessageA(v12, 0x147u, 0, 0) )
  {
    case 0:
      dword_1005D118 = 1056964608;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    case 2:
      dword_1005D118 = 0x40000000;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    case 3:
      byte_1005D400 = 1;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
    default:
      dword_1005D118 = 1065353216;
      EndDialog(hDlg, 1027);
      result = 0;
      break;
  }
  return result;
}

// sub_10001710 @ 0x10001710
int sub_10001710()
{
  int v0; // ebx
  int v1; // ebp
  char *v3; // [esp+10h] [ebp-4h]

  dword_1005C48C = 0;
  dword_1005C490 = 0;
  byte_1005C860 = 0;
  byte_1005C861 = 1;
  dword_1005C864 = 0;
  dword_1005C88C = 1056964608;
  dword_1005C868 = 1;
  dword_1005C890 = 257;
  dword_1005C894 = 258;
  byte_1005C886 = 0;
  dword_1005C488 = 1065353216;
  byte_1005C885 = 0;
  byte_1005C494 = 0;
  v0 = 0;
  v3 = (char *)&unk_1005C4C0;
  v1 = 34;
  do
  {
    grim_config_blob[v1++] = v0;
    strcpy(v3, aDefault);
    ++v0;
    v3 += 27;
  }
  while ( v1 < 42 );
  HIWORD(grim_config_blob[0]) = 0;
  memset(byte_1005C598, 0, 0x20u);
  strcpy(byte_1005C598, a10tons);
  dword_1005C49C = 1;
  dword_1005C498 = 0;
  LOWORD(grim_config_blob[0]) = 0;
  byte_1005C884 = 0;
  byte_1005C878 = 1;
  dword_1005C5C0 = 0;
  dword_1005C5C4 = 0;
  dword_1005C484 = 0;
  dword_1005C5D0 = 32;
  byte_1005C5DC = 0;
  dword_1005C430 = 1;
  byte_1005C426 = 1;
  byte_1005C427 = 0;
  byte_1005C428 = 1;
  dword_1005C434 = 2;
  dword_1005C438 = 2;
  dword_1005C45C = 0;
  dword_1005C460 = 0;
  byte_1005C429 = 1;
  dword_1005C42C = 1;
  dword_1005C5EC = 32;
  dword_1005C888 = 5;
  dword_1005C5C8 = 9000;
  dword_1005C5CC = 27000;
  dword_1005C5BC = 100;
  dword_1005C5D4 = 800;
  dword_1005C5D8 = 600;
  dword_1005C87C = 1065353216;
  dword_1005C880 = 1065353216;
  dword_1005C5E0 = 17;
  dword_1005C5E4 = 31;
  dword_1005C5E8 = 30;
  dword_1005C5F0 = 256;
  dword_1005C5F4 = 382;
  dword_1005C5F8 = 382;
  dword_1005C5FC = 16;
  dword_1005C600 = 18;
  dword_1005C604 = 319;
  dword_1005C608 = 320;
  dword_1005C60C = 321;
  dword_1005C610 = 339;
  dword_1005C614 = 382;
  dword_1005C618 = 382;
  dword_1005C61C = 382;
  dword_1005C620 = 200;
  dword_1005C624 = 208;
  dword_1005C628 = 203;
  dword_1005C62C = 205;
  dword_1005C630 = 157;
  dword_1005C634 = 382;
  dword_1005C638 = 382;
  dword_1005C63C = 211;
  dword_1005C640 = 209;
  dword_1005C644 = 319;
  dword_1005C648 = 320;
  dword_1005C64C = 321;
  dword_1005C650 = 339;
  dword_1005C654 = 382;
  dword_1005C658 = 382;
  dword_1005C65C = 382;
  word_1005C41C = 257;
  return 382;
}

// sub_100019F0 @ 0x100019F0
char sub_100019F0()
{
  FILE *v0; // eax
  FILE *v1; // esi

  v0 = fopen(FileName, Mode);
  v1 = v0;
  if ( v0 )
  {
    fwrite(grim_config_blob, 0x480u, 1u, v0);
    fclose(v1);
  }
  return 1;
}

// sub_10001A30 @ 0x10001A30
char sub_10001A30()
{
  FILE *v0; // esi

  v0 = fopen(FileName, aRb);
  if ( !v0 )
  {
    sub_100019F0();
    v0 = fopen(FileName, aRb);
    if ( !v0 )
      return 0;
  }
  fseek(v0, 0, 2);
  if ( ftell(v0) == 1152 )
  {
    fseek(v0, 0, 0);
    fread(grim_config_blob, 0x480u, 1u, v0);
    fclose(v0);
  }
  else
  {
    fclose(v0);
    sub_100019F0();
  }
  return 1;
}

// DialogFunc @ 0x10001AD0
INT_PTR __stdcall DialogFunc(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  unsigned int v12; // edx
  char v13; // bl
  HWND DlgItem; // eax
  HWND v15; // eax
  HWND v16; // eax
  WPARAM v17; // [esp-8h] [ebp-18h]
  WPARAM v18; // [esp-8h] [ebp-18h]
  WPARAM v19; // [esp-8h] [ebp-18h]
  const CHAR *v20; // [esp-4h] [ebp-14h]
  const CHAR *v21; // [esp-4h] [ebp-14h]
  const CHAR *v22; // [esp-4h] [ebp-14h]
  const CHAR *v23; // [esp-4h] [ebp-14h]

  switch ( a2 )
  {
    case 0x10u:
      EndDialog(hDlg, (unsigned __int16)a3);
      return 0;
    case 0x110u:
      SendMessageA(hDlg, 0x80u, 1u, lParam);
      SendMessageA(hDlg, 0x80u, 0, lParam);
      if ( byte_1005C884 )
      {
        v22 = lpString;
        DlgItem = GetDlgItem(hDlg, 1034);
        SetWindowTextA(DlgItem, v22);
        v19 = 1;
      }
      else
      {
        v23 = off_1005306C;
        v15 = GetDlgItem(hDlg, 1034);
        SetWindowTextA(v15, v23);
        v19 = 0;
      }
      v16 = GetDlgItem(hDlg, 1024);
      SendMessageA(v16, 0xF1u, v19, 0);
      return 1;
    case 0x111u:
      if ( (unsigned __int16)a3 <= 0x403u )
      {
        switch ( (unsigned __int16)a3 )
        {
          case 0x403u:
            EndDialog(hDlg, 1027);
            return 0;
          case 2u:
            EndDialog(hDlg, 2);
            return 0;
          case 0x400u:
            v17 = byte_1005C884 != 0;
            v4 = GetDlgItem(hDlg, 1024);
            SendMessageA(v4, 0xF1u, v17, 0);
            if ( byte_1005C884 )
            {
              if ( (_BYTE)dword_1005C48C )
              {
                DialogBoxParamA(grim_module_handle, (LPCSTR)0x8B, hDlg, DialogFunc, 0);
              }
              else
              {
                byte_1005C884 = 0;
                sub_100019F0();
              }
            }
            else
            {
              DialogBoxParamA(grim_module_handle, (LPCSTR)0x8C, hDlg, DialogFunc, 0);
            }
            if ( byte_1005C884 )
            {
              v20 = lpString;
              v5 = GetDlgItem(hDlg, 1034);
              SetWindowTextA(v5, v20);
              v18 = 1;
            }
            else
            {
              v21 = off_1005306C;
              v6 = GetDlgItem(hDlg, 1034);
              SetWindowTextA(v6, v21);
              v18 = 0;
            }
            v7 = GetDlgItem(hDlg, 1024);
            SendMessageA(v7, 0xF1u, v18, 0);
            return 0;
        }
        return 0;
      }
      if ( (unsigned __int16)a3 == 1032 )
      {
        v11 = GetDlgItem(hDlg, 1031);
        GetWindowTextA(v11, dword_1005BCFC, 255);
        v12 = 0;
        v13 = 1;
        if ( !strlen((const char *)&dword_1005C48C) )
          goto LABEL_33;
        do
        {
          if ( *((_BYTE *)&dword_1005C48C + v12) != dword_1005BCFC[v12] )
            v13 = 0;
          ++v12;
        }
        while ( v12 < strlen((const char *)&dword_1005C48C) );
        if ( v13 )
        {
LABEL_33:
          byte_1005C884 = 0;
          LOBYTE(dword_1005C48C) = 0;
          sub_100019F0();
          EndDialog(hDlg, 1032);
          return 0;
        }
        else
        {
          MessageBoxA(hDlg, aPasswordIsInco, aAboutPassword, 0x30u);
          return 0;
        }
      }
      else
      {
        if ( (unsigned __int16)a3 != 1033 )
          return 0;
        v9 = GetDlgItem(hDlg, 1031);
        GetWindowTextA(v9, dword_1005BCFC, 255);
        v10 = GetDlgItem(hDlg, 1035);
        GetWindowTextA(v10, byte_1005BDFC, 255);
        if ( !strcmp(dword_1005BCFC, byte_1005BDFC) )
        {
          if ( dword_1005BCFC[0] )
          {
            dword_1005C48C = *(_DWORD *)dword_1005BCFC;
            dword_1005C490 = dword_1005BD00;
            byte_1005C494 = 0;
            byte_1005C884 = 1;
            sub_100019F0();
            EndDialog(hDlg, 1033);
          }
          else
          {
            MessageBoxA(hDlg, aPleaseGiveAPas, aAboutPassword, 0x30u);
          }
          return 0;
        }
        else
        {
          MessageBoxA(hDlg, aGivenPasswords, aAboutPasswords, 0x30u);
          return 0;
        }
      }
    default:
      return 0;
  }
}

// sub_10001E90 @ 0x10001E90
LRESULT sub_10001E90()
{
  HWND DlgItem; // eax
  HWND v1; // eax
  HWND v2; // eax
  HWND v3; // eax
  HWND v4; // eax
  HWND v5; // eax
  HWND v6; // eax
  HWND v7; // eax
  HWND v8; // eax
  HWND v9; // eax
  HWND v10; // eax
  HWND v11; // eax
  HWND v12; // eax
  HWND v13; // eax
  int v14; // eax
  int v15; // eax
  HWND v16; // eax
  WPARAM v18; // [esp-8h] [ebp-10h]
  WPARAM v19; // [esp-8h] [ebp-10h]

  v18 = (unsigned __int8)dword_1005CEC8;
  byte_10053064 = (dword_1005A4A4 & 0x80000) != 0;
  DlgItem = GetDlgItem(hDlg, 1005);
  SendMessageA(DlgItem, 0xF1u, v18, 0);
  byte_1005D400 = byte_1005D0C8;
  byte_10053065 = (*(int (__stdcall **)(int, _DWORD, int, int, int, _DWORD))(*(_DWORD *)grim_d3d8_probe + 36))(
                    grim_d3d8_probe,
                    0,
                    1,
                    22,
                    22,
                    0) >= 0;
  v1 = GetDlgItem(hDlg, 1017);
  SendMessageA(v1, 0x14Bu, 0, 0);
  if ( byte_10053064 )
  {
    v2 = GetDlgItem(hDlg, 1017);
    SendMessageA(v2, 0x143u, 0, (LPARAM)a640x480Windowe);
    v3 = GetDlgItem(hDlg, 1017);
    SendMessageA(v3, 0x143u, 0, (LPARAM)a800x600Windowe);
    v4 = GetDlgItem(hDlg, 1017);
    SendMessageA(v4, 0x143u, 0, (LPARAM)a960x600WideWin);
    v5 = GetDlgItem(hDlg, 1017);
    SendMessageA(v5, 0x143u, 0, (LPARAM)a1024x768Window);
  }
  v6 = GetDlgItem(hDlg, 1017);
  SendMessageA(v6, 0x143u, 0, (LPARAM)a640x480x16);
  v7 = GetDlgItem(hDlg, 1017);
  SendMessageA(v7, 0x143u, 0, (LPARAM)a800x600x16);
  v8 = GetDlgItem(hDlg, 1017);
  SendMessageA(v8, 0x143u, 0, (LPARAM)a960x600x16Wide);
  v9 = GetDlgItem(hDlg, 1017);
  SendMessageA(v9, 0x143u, 0, (LPARAM)a1024x768x16);
  if ( byte_10053065 )
  {
    v10 = GetDlgItem(hDlg, 1017);
    SendMessageA(v10, 0x143u, 0, (LPARAM)a640x480x32);
    v11 = GetDlgItem(hDlg, 1017);
    SendMessageA(v11, 0x143u, 0, (LPARAM)a800x600x32);
    v12 = GetDlgItem(hDlg, 1017);
    SendMessageA(v12, 0x143u, 0, (LPARAM)a960x600x32Wide);
    v13 = GetDlgItem(hDlg, 1017);
    SendMessageA(v13, 0x143u, 0, (LPARAM)a1024x768x32);
  }
  switch ( dword_1005CE18 )
  {
    case 640:
      v14 = 0;
      break;
    case 800:
      v14 = 1;
      break;
    case 960:
      v14 = 2;
      break;
    case 1024:
      v14 = 3;
      break;
    default:
      v15 = -(dword_1005CE18 != 1680);
      LOBYTE(v15) = v15 & 0xFD;
      v14 = v15 + 4;
      break;
  }
  if ( (_BYTE)dword_1005CC08 != 1 || !byte_10053064 )
  {
    if ( dword_1005CE38 == 16 )
    {
      v14 += 4;
    }
    else if ( dword_1005CE38 == 32 )
    {
      v14 += 8;
    }
    if ( !byte_10053064 )
      v14 -= 4;
  }
  v19 = v14;
  v16 = GetDlgItem(hDlg, 1017);
  return SendMessageA(v16, 0x14Eu, v19, 0);
}

// grim_config_dialog_proc @ 0x10002120
// dialog procedure for the Grim2D config UI
INT_PTR __stdcall sub_10002120(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)
{
  HWND v4; // eax
  INT_PTR result; // eax
  HWND v6; // eax
  HWND DlgItem; // eax
  HWND v8; // eax
  HWND v9; // eax
  char *v10; // eax
  const char *v11; // edi
  char *v12; // eax
  int v13; // eax
  HWND v14; // eax
  HWND v15; // eax
  HWND v16; // eax
  int v17; // eax
  int v18; // edi
  HWND v19; // eax
  HWND v20; // eax
  HWND v21; // eax
  HWND v22; // eax
  LRESULT v23; // [esp+2Ch] [ebp-420h]
  WPARAM v24; // [esp+2Ch] [ebp-420h]
  int v25; // [esp+34h] [ebp-418h]
  int i; // [esp+44h] [ebp-408h]
  char *String; // [esp+48h] [ebp-404h]
  char lParam[512]; // [esp+4Ch] [ebp-400h] BYREF
  LPARAM v29; // [esp+24Ch] [ebp-200h] BYREF
  char Buffer[508]; // [esp+250h] [ebp-1FCh] BYREF

  if ( a2 == 16 )
  {
    grim_config_dialog_canceled = 1;
    EndDialog(hDlg, (unsigned __int16)a3);
    return 0;
  }
  if ( a2 != 272 )
  {
    if ( a2 == 273 )
    {
      switch ( (__int16)a3 )
      {
        case 1000:
          DlgItem = GetDlgItem(hDlg, 1007);
          byte_1005D0C8 = SendMessageA(DlgItem, 0xF0u, 0, 0) != 0;
          v8 = GetDlgItem(hDlg, 1017);
          memset(lParam, 0, sizeof(lParam));
          v23 = SendMessageA(v8, 0x147u, 0, 0);
          v9 = GetDlgItem(hDlg, 1017);
          SendMessageA(v9, 0x148u, v23, (LPARAM)lParam);
          byte_1005B280 = strstr(lParam, SubStr) != 0;
          v10 = strchr(lParam, 120);
          *v10 = 0;
          v11 = v10 + 1;
          v12 = strchr(v10 + 1, 120);
          if ( v12 )
          {
            *v12 = 0;
            String = v12 + 1;
            v12[4] = 0;
          }
          else
          {
            String = a32;
          }
          dword_10053054 = atoi(lParam);
          dword_10053058 = atoi(v11);
          dword_1005CE28 = dword_10053058;
          dword_1005CE18 = dword_10053054;
          LOBYTE(dword_1005B2B8) = atoi(String) == 16;
          v13 = -(unsigned __int8)dword_1005B2B8;
          LOBYTE(v13) = v13 & 0xF0;
          dword_1005CE38 = v13 + 32;
          sprintf(lParam, "w: %d h %d bpp %d\n", dword_10053054, dword_10053058, (unsigned __int8)dword_1005B2B8);
          grim_config_dialog_canceled = 0;
          v14 = GetDlgItem(hDlg, 1009);
          wParam = SendMessageA(v14, 0x147u, 0, 0);
          EndDialog(hDlg, (unsigned __int16)a3);
          return 0;
        case 1001:
          grim_config_dialog_canceled = 1;
          EndDialog(hDlg, (unsigned __int16)a3);
          return 0;
        case 1009:
          v4 = GetDlgItem(hDlg, 1009);
          wParam = SendMessageA(v4, 0x147u, 0, 0);
          sub_10001E90();
          result = 0;
          break;
        case 1010:
          if ( HlinkNavigateString(0, szTarget) >= 0 )
            return 0;
          MessageBoxA(0, aFailedToOpenBr, aCrimsonland, 0x30u);
          result = 0;
          break;
        case 1013:
          if ( WinExec(CmdLine, 3u) > 0x1F )
            return 0;
          MessageBoxA(0, aFailedToOpenTh, aCrimsonland, 0x30u);
          result = 0;
          break;
        case 1019:
          if ( sub_10001A30() )
            DialogBoxParamA(grim_module_handle, (LPCSTR)0x89, hDlg, DialogFunc, 0);
          else
            MessageBoxA(hDlg, aUnableToLoadCo, aParentalLockPr, 0x40u);
          result = 0;
          break;
        case 1020:
          v6 = GetDlgItem(hDlg, 1009);
          wParam = SendMessageA(v6, 0x147u, 0, 0);
          DialogBoxParamA(grim_module_handle, (LPCSTR)0x8A, hDlg, sub_10001170, 0);
          result = 0;
          break;
        default:
          return 0;
      }
      return result;
    }
    return 0;
  }
  ::hDlg = hDlg;
  v15 = GetDlgItem(hDlg, 1010);
  ShowWindow(v15, 5);
  v16 = GetDlgItem(hDlg, 1035);
  ShowWindow(v16, 0);
  SendMessageA(hDlg, 0x80u, 1u, ::lParam);
  SendMessageA(hDlg, 0x80u, 0, ::lParam);
  GetLocalTime(&SystemTime);
  v17 = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d8_probe + 16))(grim_d3d8_probe);
  v18 = 0;
  byte_1005BDFC[256] = 0;
  for ( i = v17; v18 < i; ++v18 )
  {
    (*(void (__stdcall **)(int, int, int, void *, int))(*(_DWORD *)grim_d3d8_probe + 20))(
      grim_d3d8_probe,
      v18,
      2,
      &unk_10059788,
      v25);
    if ( v18 )
      sprintf(Buffer, "%s", &unk_10059988);
    else
      sprintf(Buffer, "%s (default)", &unk_10059988);
    v25 = 0;
    if ( (*(int (__stdcall **)(int, int, int, int, int))(*(_DWORD *)grim_d3d8_probe + 36))(
           grim_d3d8_probe,
           v18,
           1,
           23,
           23) >= 0
      || (*(int (__stdcall **)(int, int, int, int, int, _DWORD))(*(_DWORD *)grim_d3d8_probe + 36))(
           grim_d3d8_probe,
           v18,
           1,
           22,
           22,
           0) >= 0 )
    {
      v19 = GetDlgItem(hDlg, 1009);
      SendMessageA(v19, 0x143u, 0, (LPARAM)&v29);
      byte_1005BDFC[256] = 1;
    }
  }
  v24 = wParam;
  v20 = GetDlgItem(hDlg, 1009);
  SendMessageA(v20, 0x14Eu, v24, 0);
  v21 = GetDlgItem(hDlg, 1009);
  wParam = SendMessageA(v21, 0x147u, 0, 0);
  sub_10001E90();
  if ( !byte_1005BDFC[256] )
  {
    v22 = GetDlgItem(hDlg, 1009);
    SendMessageA(v22, 0x143u, 0, (LPARAM)aNoSupportedDis);
    if ( MessageBoxA(hDlg, aNoSupportedDis_0, aCrimsonland, 0x33u) != 6 )
    {
      grim_config_dialog_canceled = 1;
      EndDialog(hDlg, (unsigned __int16)a3);
    }
  }
  return 1;
}

// grim_window_create @ 0x10002680
// registers the window class and creates the main game window
char sub_10002680()
{
  CHAR *ModuleHandleA; // eax
  HWND Window; // eax
  int v2; // esi
  int SystemMetrics; // eax
  int v5; // [esp-20h] [ebp-30h]
  int v6; // [esp-1Ch] [ebp-2Ch]
  HWND v7; // [esp-18h] [ebp-28h]
  HWND DesktopWindow; // [esp-18h] [ebp-28h]
  HINSTANCE v9; // [esp-10h] [ebp-20h]
  HINSTANCE v10; // [esp-10h] [ebp-20h]
  struct tagRECT Rect; // [esp+0h] [ebp-10h] BYREF

  ModuleHandleA = (CHAR *)lpModuleName;
  if ( !lpModuleName )
  {
    ModuleHandleA = (CHAR *)GetModuleHandleA(0);
    lpModuleName = ModuleHandleA;
  }
  stru_10059DC8.hInstance = (HINSTANCE)ModuleHandleA;
  stru_10059DC8.cbSize = 48;
  stru_10059DC8.style = 3;
  stru_10059DC8.lpfnWndProc = sub_100033B0;
  stru_10059DC8.cbClsExtra = 0;
  stru_10059DC8.cbWndExtra = 0;
  stru_10059DC8.hIcon = (HICON)lParam;
  stru_10059DC8.hCursor = LoadCursorA(0, (LPCSTR)0x7F00);
  stru_10059DC8.hbrBackground = (HBRUSH)GetStockObject(4);
  stru_10059DC8.lpszMenuName = 0;
  stru_10059DC8.lpszClassName = aCrimson;
  stru_10059DC8.hIconSm = (HICON)lParam;
  RegisterClassExA(&stru_10059DC8);
  if ( (_BYTE)dword_1005CC08 )
  {
    v2 = GetSystemMetrics(0) / 2;
    SystemMetrics = GetSystemMetrics(1);
    Rect.right = v2 + ((unsigned int)grim_backbuffer_width >> 1);
    SystemMetrics /= 2;
    Rect.left = v2 - ((unsigned int)grim_backbuffer_width >> 1);
    Rect.top = SystemMetrics - ((unsigned int)grim_backbuffer_height >> 1);
    Rect.bottom = SystemMetrics + ((unsigned int)grim_backbuffer_height >> 1);
    AdjustWindowRectEx(&Rect, 0xCB0000u, 0, 0x40000u);
    v10 = (HINSTANCE)lpModuleName;
    DesktopWindow = GetDesktopWindow();
    Window = CreateWindowExA(
               0x40000u,
               stru_10059DC8.lpszClassName,
               lpWindowName,
               0xCB0000u,
               Rect.left,
               Rect.top,
               Rect.right - Rect.left,
               Rect.bottom - Rect.top,
               DesktopWindow,
               0,
               v10,
               0);
  }
  else
  {
    v9 = (HINSTANCE)lpModuleName;
    v7 = GetDesktopWindow();
    v6 = GetSystemMetrics(1);
    v5 = GetSystemMetrics(0);
    Window = CreateWindowExA(8u, stru_10059DC8.lpszClassName, lpWindowName, 0x80000000, 0, 0, v5, v6, v7, 0, v9, 0);
  }
  hWnd = Window;
  if ( Window )
  {
    ShowWindow(Window, 1);
    UpdateWindow(hWnd);
    SetFocus(hWnd);
    ShowWindow(hWnd, 1);
    UpdateWindow(hWnd);
    return 1;
  }
  else
  {
    grim_error_text = (int)aWinCouldNotCre;
    grim_window_destroy();
    return 0;
  }
}

// grim_window_destroy @ 0x10002880
// posts quit and destroys the main window
BOOL sub_10002880()
{
  HWND v0; // eax

  PostQuitMessage(0);
  v0 = hWnd;
  if ( hWnd )
  {
    DestroyWindow(hWnd);
    v0 = hWnd;
  }
  if ( dword_1005D3FC )
    DestroyWindow(v0);
  return UnregisterClassA(stru_10059DC8.lpszClassName, stru_10059DC8.hInstance);
}

// grim_backup_textures @ 0x100028D0
// backup texture surfaces before device reset
char sub_100028D0()
{
  int v1; // edi
  void **v2; // esi
  int v3; // ebp
  int v4; // ecx
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+40h] [ebp-14h] BYREF
  int v9; // [esp+44h] [ebp-10h]
  int v10; // [esp+48h] [ebp-Ch]
  int v11; // [esp+4Ch] [ebp-8h]
  int v12; // [esp+50h] [ebp-4h]

  grim_noop();
  if ( byte_1005D810 )
  {
    grim_noop();
    if ( byte_1005D810 )
      return 1;
  }
  v1 = 0;
  v8 = 0;
  if ( dword_1005305C < 0 )
  {
LABEL_15:
    byte_1005D810 = 1;
    return 1;
  }
  v2 = &grim_texture_slots;
  while ( 1 )
  {
    if ( !*v2 || !*((_BYTE *)*v2 + 8) )
      goto LABEL_14;
    grim_noop();
    if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 108))(
           grim_d3d_device,
           *((_DWORD *)*v2 + 3),
           *((_DWORD *)*v2 + 4),
           grim_texture_format,
           (int)*v2 + 20) < 0 )
    {
      grim_error_text = (int)aD3dUnableToBac;
      grim_noop();
      grim_noop();
      return 0;
    }
    if ( (*(int (__stdcall **)(_DWORD, _DWORD, int *))(**((_DWORD **)*v2 + 1) + 60))(*((_DWORD *)*v2 + 1), 0, &v8) < 0 )
      break;
    v3 = (*(int (__stdcall **)(int, int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 112))(
           grim_d3d_device,
           v8,
           0,
           0,
           *((_DWORD *)*v2 + 5),
           0);
    if ( v3 < 0 )
    {
      v6 = (int)*(&grim_texture_slots + v1);
      v7 = *(_DWORD *)(v6 + 20);
      if ( v7 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(_DWORD *)(v6 + 20)) )
        *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
      if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
        v8 = 0;
      grim_error_text = (int)aD3dUnableToBac_1;
      grim_noop();
      LOBYTE(v9) = 1;
      dword_1005D0F8 = v9;
      dword_1005D0FC = v10;
      qword_1005D100 = v11;
      MEMORY[0x1005D104] = v12;
      grim_noop();
      return 0;
    }
    if ( v8 )
    {
      if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
        v8 = 0;
    }
LABEL_14:
    ++v1;
    ++v2;
    if ( v1 > dword_1005305C )
      goto LABEL_15;
  }
  v4 = (int)*(&grim_texture_slots + v1);
  v5 = *(_DWORD *)(v4 + 20);
  if ( v5 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(*(_DWORD *)(v4 + 20)) )
    *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
  grim_error_text = (int)aD3dUnableToBac_0;
  grim_noop();
  grim_noop();
  return 0;
}

// grim_restore_textures @ 0x10002B40
// restore texture surfaces after device reset
char sub_10002B40()
{
  int v1; // edi
  void **v2; // esi
  _BYTE *v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edx
  int v7; // eax
  int v8; // [esp+28h] [ebp-14h] BYREF
  int v9; // [esp+2Ch] [ebp-10h]
  int v10; // [esp+30h] [ebp-Ch]
  int v11; // [esp+34h] [ebp-8h]
  int v12; // [esp+38h] [ebp-4h]

  if ( byte_1005D804 )
    return 0;
  grim_noop();
  if ( !byte_1005D810 )
  {
    grim_noop();
    if ( !byte_1005D810 )
      return 0;
  }
  v1 = 0;
  v8 = 0;
  if ( dword_1005305C < 0 )
  {
LABEL_21:
    byte_1005D810 = 0;
    return 1;
  }
  v2 = &grim_texture_slots;
  while ( 1 )
  {
    v3 = *v2;
    if ( *v2 )
    {
      if ( v3[8] && *((_DWORD *)v3 + 5) )
        break;
    }
LABEL_20:
    ++v1;
    ++v2;
    if ( v1 > dword_1005305C )
      goto LABEL_21;
  }
  grim_noop();
  v4 = *((_DWORD *)*v2 + 1);
  if ( v4 && (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v4 + 60))(v4, 0, &v8) < 0 )
  {
    grim_error_text = (int)aD3dUnableToRec;
    grim_noop();
    return 0;
  }
  if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 112))(
         grim_d3d_device,
         *((_DWORD *)*v2 + 5),
         0,
         0,
         v8,
         0) >= 0 )
  {
    if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
      v8 = 0;
    v5 = *((_DWORD *)*v2 + 5);
    if ( v5 )
    {
      if ( !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v5 + 8))(*((_DWORD *)*v2 + 5)) )
        *((_DWORD *)*v2 + 5) = 0;
    }
    goto LABEL_20;
  }
  if ( v8 && !(*(int (__stdcall **)(int))(*(_DWORD *)v8 + 8))(v8) )
    v8 = 0;
  v6 = (int)*(&grim_texture_slots + v1);
  v7 = *(_DWORD *)(v6 + 20);
  if ( v7 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(_DWORD *)(v6 + 20)) )
    *((_DWORD *)*(&grim_texture_slots + v1) + 5) = 0;
  LOBYTE(v9) = 1;
  dword_1005D0F8 = v9;
  byte_1005D810 = 0;
  grim_error_text = (int)aD3dUnableToRes;
  dword_1005D0FC = v10;
  qword_1005D100 = v11;
  MEMORY[0x1005D104] = v12;
  grim_noop();
  return 0;
}

// sub_10002CF0 @ 0x10002CF0
int sub_10002CF0()
{
  int v0; // edi
  void **v1; // esi
  _DWORD *v2; // eax
  int v3; // eax
  int v4; // edi
  void **v5; // esi
  _DWORD *v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // edi
  void **v10; // esi
  _BYTE *v11; // eax
  int v13; // [esp+1Ch] [ebp-10h]
  int v14; // [esp+20h] [ebp-Ch]
  int v15; // [esp+24h] [ebp-8h]
  int v16; // [esp+28h] [ebp-4h]

  grim_noop();
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  v0 = 0;
  if ( dword_1005305C >= 0 )
  {
    v1 = &grim_texture_slots;
    do
    {
      v2 = *v1;
      if ( *v1 )
      {
        if ( *((_BYTE *)v2 + 8) )
        {
          v3 = v2[1];
          if ( v3 )
          {
            if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3) )
              *((_DWORD *)*v1 + 1) = 0;
          }
        }
      }
      ++v0;
      ++v1;
    }
    while ( v0 <= dword_1005305C );
  }
  while ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)grim_d3d_device + 56))(grim_d3d_device, &grim_present_width) )
  {
    ++dword_1005D808;
    Sleep(0x1F4u);
    if ( dword_1005D808 >= 4 )
    {
      grim_error_text = (int)aD3dUnableToRes_0;
      if ( MessageBoxA(hWnd, aD3dUnableToRes_0, Caption, 5u) == 2 )
      {
        grim_noop();
        return -2005530519;
      }
      v4 = 0;
      if ( dword_1005305C >= 0 )
      {
        v5 = &grim_texture_slots;
        do
        {
          v6 = *v5;
          if ( *v5 && *((_BYTE *)v6 + 8) )
          {
            v7 = v6[5];
            if ( v7 && !(*(int (__stdcall **)(int))(*(_DWORD *)v7 + 8))(v7) )
              *((_DWORD *)*v5 + 5) = 0;
            v8 = *((_DWORD *)*v5 + 1);
            if ( v8 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v8 + 8))(*((_DWORD *)*v5 + 1)) )
              *((_DWORD *)*v5 + 1) = 0;
            LOBYTE(v13) = 1;
            dword_1005D0F8 = v13;
            dword_1005D0FC = v14;
            qword_1005D100 = v15;
            MEMORY[0x1005D104] = v16;
          }
          ++v4;
          ++v5;
        }
        while ( v4 <= dword_1005305C );
      }
    }
  }
  sub_10004520();
  v9 = 0;
  if ( dword_1005305C >= 0 )
  {
    v10 = &grim_texture_slots;
    do
    {
      v11 = *v10;
      if ( *v10
        && v11[8]
        && (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d_device + 80))(
             grim_d3d_device,
             *((_DWORD *)v11 + 3),
             *((_DWORD *)v11 + 4),
             1,
             1,
             grim_texture_format,
             0,
             v11 + 4) < 0 )
      {
        grim_error_text = (int)aD3dUnableToRec_0;
        grim_noop();
        *((_DWORD *)*v10 + 1) = 0;
        Sleep(0xC8u);
      }
      ++v9;
      ++v10;
    }
    while ( v9 <= dword_1005305C );
  }
  if ( !grim_restore_textures() )
    grim_noop();
  grim_noop();
  dword_1005D808 = 0;
  return 0;
}

// FUN_10002f60 @ 0x10002F60
// [binja] BOOL __fastcall sub_10002f60(void* arg1)
int __thiscall sub_10002F60(HGDIOBJ *this)
{
  int result; // eax

  result = (int)*(this + 7);
  if ( result )
  {
    result = DeleteObject(*(this + 7));
    *(this + 7) = 0;
  }
  return result;
}

// FUN_10002f80 @ 0x10002F80
// [binja] uint32_t __fastcall sub_10002f80(void* arg1)
char __thiscall sub_10002F80(int *this)
{
  DWORD Time; // eax
  int v3; // edx
  int v5; // edx

  Time = timeGetTime();
  v3 = *(this + 1);
  if ( v3 >= 0 )
  {
    *(this + 1) = Time;
    v5 = Time - v3 + *(this + 2);
    *(this + 2) = v5;
    if ( v5 >= 30 )
    {
      *(this + 2) = v5 % 30;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    *(this + 1) = Time;
    return 0;
  }
}

// FUN_10002fc0 @ 0x10002FC0
// [binja] int32_t __fastcall sub_10002fc0(char* arg1)
char __thiscall sub_10002FC0(_DWORD *this)
{
  LONG bottom; // eax
  struct tagRECT Rect; // [esp+Ch] [ebp-10h] BYREF

  grim_noop();
  *(_BYTE *)this = 0;
  *(this + 1) = -1;
  *(this + 2) = 0;
  *(this + 7) = 0;
  *(this + 9) = 0;
  *((_BYTE *)this + 41) = 0;
  *((_BYTE *)this + 40) = 0;
  *(this + 5) = 0;
  GetClientRect(hWnd, &Rect);
  bottom = Rect.bottom;
  *(this + 4) = Rect.right;
  *(this + 3) = bottom;
  *(this + 4) = grim_backbuffer_width;
  *(this + 3) = grim_backbuffer_height;
  memset(DstBuf, 0, 0x104u);
  getcwd(DstBuf, 260);
  LOBYTE(Rect.left) = 0;
  xmmword_1005D1C8 = (__int128)Rect;
  return 1;
}

// FUN_10003090 @ 0x10003090
// [binja] int32_t sub_10003090()
void __thiscall sub_10003090(int *this)
{
  if ( FUN_10002f80(this) )
    grim_noop();
}

// sub_100030B0 @ 0x100030B0
char sub_100030B0()
{
  int v0; // eax
  int v1; // edi
  void **v2; // esi
  _DWORD *v3; // eax
  int v4; // eax
  int v5; // esi
  void **v6; // edi
  _BYTE *v7; // eax
  _DWORD *v8; // ecx
  int v10; // edi
  void **v11; // esi
  _DWORD *v12; // eax
  int v13; // eax
  int v14; // eax
  int v15; // edi
  void **v16; // esi
  _DWORD *v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // [esp+28h] [ebp-10h]
  int v21; // [esp+2Ch] [ebp-Ch]
  int v22; // [esp+30h] [ebp-8h]
  int v23; // [esp+34h] [ebp-4h]

  if ( !grim_d3d_device )
    return 0;
  v0 = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
  byte_1005C898 = v0 == 0;
  if ( v0 != -2005530519 )
    return 1;
  Sleep(0x64u);
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  v1 = 0;
  if ( dword_1005305C >= 0 )
  {
    v2 = &grim_texture_slots;
    do
    {
      v3 = *v2;
      if ( *v2 )
      {
        if ( *((_BYTE *)v3 + 8) )
        {
          v4 = v3[1];
          if ( v4 )
          {
            if ( !(*(int (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4) )
              *((_DWORD *)*v2 + 1) = 0;
          }
        }
      }
      ++v1;
      ++v2;
    }
    while ( v1 <= dword_1005305C );
  }
  if ( (*(int (__stdcall **)(int, int *))(*(_DWORD *)grim_d3d_device + 56))(grim_d3d_device, &grim_present_width) )
  {
    ++dword_1005D808;
    Sleep(0x1F4u);
    if ( dword_1005D808 == 5 )
    {
      v10 = 0;
      if ( dword_1005305C < 0 )
        return 1;
      v11 = &grim_texture_slots;
      do
      {
        v12 = *v11;
        if ( *v11 && *((_BYTE *)v12 + 8) )
        {
          v13 = v12[5];
          if ( v13 && !(*(int (__stdcall **)(int))(*(_DWORD *)v13 + 8))(v13) )
            *((_DWORD *)*v11 + 5) = 0;
          v14 = *((_DWORD *)*v11 + 1);
          if ( v14 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v14 + 8))(*((_DWORD *)*v11 + 1)) )
            *((_DWORD *)*v11 + 1) = 0;
          LOBYTE(v20) = 1;
          dword_1005D0FC = v21;
          dword_1005D0F8 = v20;
          qword_1005D100 = v22;
          MEMORY[0x1005D104] = v23;
        }
        ++v10;
        ++v11;
      }
      while ( v10 <= dword_1005305C );
    }
    if ( dword_1005D808 > 6 )
    {
      grim_error_text = (int)aD3dUnableToRes_0;
      if ( MessageBoxA(hWnd, aD3dUnableToRes_0, Caption, 5u) != 2 )
      {
        v15 = 0;
        if ( dword_1005305C >= 0 )
        {
          v16 = &grim_texture_slots;
          do
          {
            v17 = *v16;
            if ( *v16 && *((_BYTE *)v17 + 8) )
            {
              v18 = v17[5];
              if ( v18 && !(*(int (__stdcall **)(int))(*(_DWORD *)v18 + 8))(v18) )
                *((_DWORD *)*v16 + 5) = 0;
              v19 = *((_DWORD *)*v16 + 1);
              if ( v19 && !(*(int (__stdcall **)(_DWORD))(*(_DWORD *)v19 + 8))(*((_DWORD *)*v16 + 1)) )
                *((_DWORD *)*v16 + 1) = 0;
              LOBYTE(v20) = 1;
              dword_1005D0FC = v21;
              dword_1005D0F8 = v20;
              qword_1005D100 = v22;
              MEMORY[0x1005D104] = v23;
            }
            ++v15;
            ++v16;
          }
          while ( v15 <= dword_1005305C );
        }
        return 1;
      }
      return 0;
    }
    return 1;
  }
  sub_10004520();
  v5 = 0;
  if ( dword_1005305C >= 0 )
  {
    v6 = &grim_texture_slots;
    do
    {
      v7 = *v6;
      if ( *v6
        && v7[8]
        && (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d_device + 80))(
             grim_d3d_device,
             *((_DWORD *)v7 + 3),
             *((_DWORD *)v7 + 4),
             1,
             1,
             grim_texture_format,
             0,
             v7 + 4) < 0 )
      {
        v8 = *v6;
        grim_error_text = (int)aD3dUnableToRec_0;
        v8[1] = 0;
        grim_noop();
        grim_noop();
      }
      ++v5;
      ++v6;
    }
    while ( v5 <= dword_1005305C );
  }
  grim_restore_textures();
  dword_1005D808 = 0;
  return 1;
}

// sub_100033B0 @ 0x100033B0
int __stdcall sub_100033B0(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int result; // eax
  int v5; // eax
  struct tagPAINTSTRUCT Paint; // [esp+Ch] [ebp-40h] BYREF

  grim_noop();
  if ( byte_1005D804 )
  {
    switch ( Msg )
    {
      case 2u:
      case 0x10u:
        byte_1005D804 = 0;
        byte_1005BC00 = 0;
        goto LABEL_19;
      case 6u:
        if ( !(_WORD)wParam || HIWORD(wParam) )
        {
          grim_noop();
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
          byte_1005A470 = 1;
          dword_1005D3A8();
          grim_backup_textures();
          byte_1005C898 = 0;
          return 0;
        }
        grim_noop();
        sub_100030B0();
        if ( !grim_d3d_device )
          goto LABEL_12;
        goto LABEL_10;
      case 0xFu:
        BeginPaint(::hWnd, &Paint);
        EndPaint(::hWnd, &Paint);
        byte_1005BC01 = 1;
        LOBYTE(dword_1005D0F8) = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x14u:
        goto LABEL_74;
      case 0x1Cu:
        if ( !wParam )
        {
          grim_noop();
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
          (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
          byte_1005A470 = 1;
          if ( !byte_1005C898 )
            goto LABEL_41;
          dword_1005D3A8();
          grim_backup_textures();
          byte_1005C898 = 0;
          return 0;
        }
        grim_noop();
        sub_100030B0();
        if ( !byte_1005C898 )
          goto LABEL_12;
LABEL_10:
        grim_restore_textures();
        sub_10004520();
        break;
      case 0x1Fu:
        grim_noop();
        grim_backup_textures();
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
LABEL_11:
    byte_1005D811 = 0;
    byte_1005A470 = 0;
    return 0;
  }
  if ( Msg > 0x200 )
  {
    switch ( Msg )
    {
      case 0x201u:
        if ( (_BYTE)grim_input_cached )
          grim_mouse_button_cache = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x202u:
        if ( (_BYTE)grim_input_cached )
          grim_mouse_button_cache = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x204u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A045 = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x205u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A045 = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x207u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A046 = 1;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x208u:
        if ( (_BYTE)grim_input_cached )
          byte_1005A046 = 0;
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x20Au:
        if ( (_BYTE)grim_input_cached )
          flt_1005D3B8 = (float)SHIWORD(wParam);
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x231u:
LABEL_40:
        byte_1005A470 = 1;
LABEL_41:
        byte_1005C898 = 0;
        result = 0;
        break;
      case 0x232u:
        goto LABEL_52;
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
  }
  else if ( Msg == 512 )
  {
    if ( (_BYTE)grim_input_cached )
    {
      grim_mouse_x_cached = (float)(__int16)lParam;
      grim_mouse_y_cached = (float)SHIWORD(lParam);
    }
    return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  else if ( Msg > 0x1C )
  {
    switch ( Msg )
    {
      case 0x1Fu:
        grim_noop();
        grim_backup_textures();
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x102u:
        if ( (_BYTE)wParam != 0xA7 && (_BYTE)wParam != 9 )
        {
          v5 = dword_1005D3E4;
          if ( dword_1005D3E4 < 7 )
          {
            dword_1005D3C4[dword_1005D3E4] = wParam;
            dword_1005D3E4 = v5 + 1;
          }
          if ( wParam == 8 )
          {
            if ( *(int *)off_1005304C <= 0 )
            {
              *(_BYTE *)off_10053048 = 0;
            }
            else
            {
              --*(_DWORD *)off_1005304C;
              *((_BYTE *)off_10053048 + *(_DWORD *)off_1005304C) = 0;
            }
          }
          else if ( wParam != 13 && *(_DWORD *)off_1005304C < dword_10053050 - 1 )
          {
            *((_BYTE *)off_10053048 + (*(_DWORD *)off_1005304C)++) = wParam;
            *((_BYTE *)off_10053048 + *(_DWORD *)off_1005304C) = 0;
          }
        }
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
      case 0x104u:
      case 0x105u:
        goto LABEL_74;
      case 0x112u:
        if ( wParam > 0xF030 )
        {
          if ( wParam != 61760 && wParam != 61808 )
            return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        else if ( wParam != 61488 && wParam != 61440 && wParam != 61456 )
        {
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        }
        if ( (_BYTE)dword_1005CC08 )
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
LABEL_74:
        result = 1;
        break;
      default:
        return DefWindowProcA(hWnd, Msg, wParam, lParam);
    }
  }
  else
  {
    if ( Msg != 28 )
    {
      switch ( Msg )
      {
        case 1u:
          SendMessageA(::hWnd, 0x80u, 1u, ::lParam);
          SendMessageA(::hWnd, 0x80u, 0, ::lParam);
          ::hWnd = hWnd;
          SetFocus(hWnd);
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        case 5u:
          if ( wParam == 4 || wParam == 1 )
          {
            byte_1005A470 = 1;
            byte_1005C898 = 0;
          }
          else
          {
            byte_1005A470 = 0;
          }
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
        case 6u:
          if ( !(_WORD)wParam || HIWORD(wParam) )
          {
            grim_noop();
            if ( !byte_1005C898 )
              grim_noop();
            if ( grim_d3d_device )
            {
              grim_backup_textures();
              dword_1005D3A8();
            }
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
            (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
            goto LABEL_40;
          }
          grim_noop();
          if ( !byte_1005C898 )
          {
            grim_noop();
            if ( !byte_1005C898 )
            {
LABEL_12:
              byte_1005D811 = 1;
              byte_1005A470 = 0;
              return 0;
            }
          }
          grim_restore_textures();
          sub_10004520();
          dword_10059770();
          break;
        case 0x10u:
LABEL_19:
          PostQuitMessage(0);
          return 0;
        default:
          return DefWindowProcA(hWnd, Msg, wParam, lParam);
      }
      goto LABEL_11;
    }
    if ( wParam )
    {
      grim_noop();
      if ( byte_1005C898 || (grim_noop(), byte_1005C898) )
      {
        grim_restore_textures();
        sub_10004520();
        dword_10059770();
        byte_1005D811 = 0;
        byte_1005A470 = 0;
        return 0;
      }
      else
      {
        byte_1005D811 = 1;
LABEL_52:
        byte_1005A470 = 0;
        return 0;
      }
    }
    else
    {
      grim_noop();
      if ( !byte_1005C898 )
        grim_noop();
      if ( grim_d3d_device )
      {
        grim_backup_textures();
        dword_1005D3A8();
      }
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
      byte_1005A470 = 1;
      byte_1005C898 = 0;
      return 0;
    }
  }
  return result;
}

// sub_10003C00 @ 0x10003C00
int sub_10003C00()
{
  float *v0; // ecx
  double v1; // st7
  int v2; // eax
  int v3; // eax
  struct tagMSG Msg; // [esp+0h] [ebp-1Ch] BYREF

  memset(&Msg, 0, sizeof(Msg));
  PeekMessageA(&Msg, 0, 0, 0, 0);
  sub_10004920();
  sub_10004970();
  sub_10004920();
  sub_10004970();
  sub_10004970();
  FUN_10002fc0(dword_1005BBD8);
  SetFocus(hWnd);
  SetForegroundWindow(hWnd);
  if ( hWnd && Msg.message != 18 )
  {
    do
    {
      if ( PeekMessageA(&Msg, 0, 0, 0, 1u) )
      {
        TranslateMessage(&Msg);
        DispatchMessageA(&Msg);
      }
      else
      {
        if ( !byte_1005D804 )
          sub_10004970();
        if ( !grim_paused_flag && !byte_1005D804 && byte_1005C898 && !byte_1005A470 )
        {
          if ( (_BYTE)dword_1005CC38 )
          {
            grim_keyboard_poll();
            v0 = &flt_1005A058;
            do
            {
              v1 = *v0 - grim_frame_dt;
              *v0 = v1;
              if ( v1 < 0.0 )
                *v0 = 0.0;
              ++v0;
            }
            while ( (int)v0 < (int)&ElementSize );
          }
          grim_joystick_poll();
          dword_1005CF14 = (int)&String[8];
          if ( !(_BYTE)grim_input_cached )
          {
            grim_mouse_x_cached = *(float *)&String[796];
            grim_mouse_y_cached = *(float *)&String[800];
            grim_mouse_poll();
          }
        }
        byte_1005C898 = 0;
        if ( byte_1005D804 )
        {
          byte_1005A470 = 1;
          FUN_10003090((int *)dword_1005BBD8);
        }
        if ( byte_1005A470 )
        {
          if ( !byte_1005D804 )
            Sleep(0x32u);
        }
        else if ( !byte_1005D804 && grim_d3d_device )
        {
          v2 = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
          byte_1005C898 = v2 == 0;
          if ( v2 )
          {
            Sleep(0x1F4u);
            v3 = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 12))(grim_d3d_device);
            byte_1005C898 = v3 == 0;
            if ( v3 == -2005530519 && sub_10002CF0() == -2005530519 )
              break;
          }
          else
          {
            if ( byte_1005D811 )
            {
              dword_10059770();
              byte_1005D811 = 0;
            }
            if ( !(unsigned __int8)dword_1005977C() )
              break;
            if ( dword_1005D3B4 )
              (*(void (__thiscall **)(int))(*(_DWORD *)dword_1005D3B4 + 20))(dword_1005D3B4);
            if ( !grim_render_disabled )
              (*(void (__stdcall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 60))(
                grim_d3d_device,
                0,
                0,
                0,
                0);
          }
        }
      }
    }
    while ( Msg.message != 18 );
  }
  timeEndPeriod(1u);
  j_FUN_10002f60(dword_1005BBD8);
  if ( (_BYTE)grim_input_cached )
    ShowCursor(1);
  grim_window_destroy();
  return 0;
}

// grim_d3d_init @ 0x10003E60
// creates the Direct3D8 interface, configures display mode, and opens the window
char sub_10003E60()
{
  int v0; // eax
  char result; // al
  bool v2; // bl
  char *v3; // eax
  HRSRC ResourceA; // esi
  HGLOBAL Resource; // eax
  LPVOID v6; // edi
  DWORD v7; // eax
  HRSRC v8; // esi
  HGLOBAL v9; // eax
  LPVOID v10; // edi
  DWORD v11; // eax
  _BYTE v12[12]; // [esp+20h] [ebp-43Ch] BYREF
  int v13; // [esp+2Ch] [ebp-430h]
  _BYTE v14[512]; // [esp+30h] [ebp-42Ch] BYREF
  char Str[556]; // [esp+230h] [ebp-22Ch] BYREF

  byte_1005C898 = 0;
  grim_d3d8 = 0;
  grim_d3d_device = 0;
  dword_1005B2B4 = 1;
  if ( (_BYTE)dword_1005CEC8 == 1 )
    dword_1005B2B4 = 2;
  v0 = Direct3DCreate8(220);
  grim_d3d8 = v0;
  if ( !v0 )
  {
    grim_error_text = (int)Text;
    return 0;
  }
  (*(void (__stdcall **)(int, WPARAM, int, void *))(*(_DWORD *)v0 + 52))(v0, wParam, dword_1005B2B4, &unk_1005A498);
  v2 = 0;
  (*(void (__stdcall **)(int, WPARAM, int, _BYTE *))(*(_DWORD *)grim_d3d8 + 20))(grim_d3d8, wParam, 2, v14);
  v3 = strchr(Str, 86);
  if ( v3 && v3[1] == 111 && v3[2] == 111 && v3[3] == 100 && v3[4] == 111 && v3[5] == 111 )
    v2 = v3[6] == 51;
  if ( (*(int (__stdcall **)(int, _DWORD, _BYTE *))(*(_DWORD *)grim_d3d8 + 32))(grim_d3d8, 0, v12) >= 0 )
  {
    result = grim_window_create();
    if ( !result )
      return result;
    memset(&grim_present_width, 0, 0x34u);
    dword_10059E04 = dword_1005CEB8;
    if ( (_BYTE)dword_1005CC08 == 1 )
    {
      dword_10059E14 = 1;
      dword_10059E0C = 1;
      grim_texture_format = v13;
    }
    else
    {
      dword_10059E14 = 0;
      dword_10059E24 = 0;
      dword_10059E0C = v2 + 1;
      dword_10059E28 = 0x80000000;
    }
    grim_present_height = grim_backbuffer_height;
    grim_present_width = grim_backbuffer_width;
    dword_10059E00 = grim_texture_format;
    dword_10059E08 = 0;
    dword_10059E20 = 1;
    dword_10059E18 = byte_1005CED8 != 0;
    dword_10059E1C = 80;
    dword_10059E10 = dword_1005D3FC;
    if ( !dword_1005D3FC )
      dword_10059E10 = (int)hWnd;
    if ( (*(int (__stdcall **)(int, WPARAM, int, HWND, int, int *, int *))(*(_DWORD *)grim_d3d8 + 60))(
           grim_d3d8,
           wParam,
           dword_1005B2B4,
           hWnd,
           32,
           &grim_present_width,
           &grim_d3d_device) < 0 )
    {
      grim_error_text = (int)aD3dCouldNotSet;
      MessageBoxA(0, aD3dCouldNotSet, Caption, 0);
      sub_10004280();
      grim_window_destroy();
      return 0;
    }
    (*(void (__stdcall **)(int, WPARAM, int, void *))(*(_DWORD *)grim_d3d8 + 52))(
      grim_d3d8,
      wParam,
      dword_1005B2B4,
      &unk_1005A498);
    if ( !(unsigned __int8)sub_10004350() )
    {
      sub_10004280();
      grim_window_destroy();
      return 0;
    }
    memset(&grim_texture_slots, 0, 0x400u);
    if ( grim_preferred_texture_format )
    {
      if ( (unsigned __int8)grim_is_texture_format_supported(grim_preferred_texture_format) )
      {
        if ( grim_preferred_texture_format )
        {
LABEL_33:
          sub_10004520();
          ResourceA = FindResourceA(grim_module_handle, (LPCSTR)0x6F, (LPCSTR)0xA);
          Resource = LoadResource(grim_module_handle, ResourceA);
          v6 = LockResource(Resource);
          v7 = SizeofResource(grim_module_handle, ResourceA);
          if ( (int)FUN_1000cb5c(
                      grim_d3d_device,
                      v6,
                      v7,
                      -1,
                      -1,
                      1,
                      0,
                      grim_preferred_texture_format,
                      1,
                      -1,
                      -1,
                      0,
                      0,
                      0,
                      &grim_font_texture) >= 0 )
          {
            v8 = FindResourceA(grim_module_handle, (LPCSTR)0x71, (LPCSTR)0xA);
            v9 = LoadResource(grim_module_handle, v8);
            v10 = LockResource(v9);
            v11 = SizeofResource(grim_module_handle, v8);
            if ( (int)FUN_1000cb5c(
                        grim_d3d_device,
                        v10,
                        v11,
                        -1,
                        -1,
                        1,
                        0,
                        grim_preferred_texture_format,
                        1,
                        -1,
                        -1,
                        0,
                        0,
                        0,
                        &dword_1005D3F0) >= 0 )
            {
              grim_backbuffer_surface = 0;
              grim_render_target_surface = 0;
              dword_1005D094 = grim_d3d8;
              dword_1005D0A4 = grim_d3d_device;
              byte_1005C898 = 1;
              return 1;
            }
            else
            {
              grim_error_text = (int)aD3dUnableToLoa_0;
              return 0;
            }
          }
          else
          {
            grim_error_text = (int)aD3dUnableToLoa;
            return 0;
          }
        }
      }
      else
      {
        grim_preferred_texture_format = 0;
      }
    }
    if ( !(unsigned __int8)grim_select_texture_format() )
    {
      grim_error_text = (int)aD3dCouldNotFin;
      sub_10004280();
      grim_window_destroy();
    }
    goto LABEL_33;
  }
  grim_error_text = (int)aD3dErrorGettin;
  if ( grim_d3d8 )
  {
    if ( !(*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d8 + 8))(grim_d3d8) )
      grim_d3d8 = 0;
  }
  return 0;
}

// sub_10004280 @ 0x10004280
int sub_10004280()
{
  void **v0; // edi
  void *v1; // esi
  int result; // eax

  if ( grim_backbuffer_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface) )
  {
    grim_backbuffer_surface = 0;
  }
  if ( grim_render_target_surface
    && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface) )
  {
    grim_render_target_surface = 0;
  }
  if ( grim_font_texture && !(*(int (__stdcall **)(int))(*(_DWORD *)grim_font_texture + 8))(grim_font_texture) )
    grim_font_texture = 0;
  if ( dword_1005D3F0 && !(*(int (__stdcall **)(int))(*(_DWORD *)dword_1005D3F0 + 8))(dword_1005D3F0) )
    dword_1005D3F0 = 0;
  v0 = &grim_texture_slots;
  do
  {
    v1 = *v0;
    if ( *v0 )
    {
      grim_texture_release(*v0);
      operator delete(v1);
      *v0 = 0;
    }
    ++v0;
  }
  while ( (int)v0 < (int)&byte_1005D804 );
  sub_100044E0();
  if ( grim_d3d_device )
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 8))(grim_d3d_device);
  result = grim_d3d8;
  grim_d3d_device = 0;
  if ( grim_d3d8 )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d8 + 8))(grim_d3d8);
  grim_d3d8 = 0;
  return result;
}

// sub_10004350 @ 0x10004350
char sub_10004350()
{
  int v1; // eax
  __int16 v2; // cx
  __int16 v3; // di

  grim_vertex_capacity = 256;
  if ( (*(int (__stdcall **)(int, int, int, _DWORD, int, int *))(*(_DWORD *)grim_d3d_device + 92))(
         grim_d3d_device,
         7168,
         536,
         0,
         2,
         &grim_vertex_buffer) >= 0 )
  {
    if ( (*(int (__stdcall **)(int, int, int, int, int, int *))(*(_DWORD *)grim_d3d_device + 96))(
           grim_d3d_device,
           12 * grim_vertex_capacity,
           536,
           101,
           2,
           &dword_10059BB8) >= 0 )
    {
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)dword_10059BB8 + 44))(
             dword_10059BB8,
             0,
             0,
             &dword_1005B2C0,
             0x2000) >= 0 )
      {
        if ( grim_vertex_capacity )
        {
          v1 = 2;
          do
          {
            v2 = v1 - 2;
            *(_WORD *)dword_1005B2C0 = v1 - 2;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1 - 1;
            v3 = v1 + 1;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v1;
            v1 += 4;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v3;
            dword_1005B2C0 += 2;
            *(_WORD *)dword_1005B2C0 = v2;
            dword_1005B2C0 += 2;
          }
          while ( (unsigned __int16)(v1 - 2) < (unsigned int)grim_vertex_capacity );
        }
        (*(void (__stdcall **)(int))(*(_DWORD *)dword_10059BB8 + 48))(dword_10059BB8);
        (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 332))(
          grim_d3d_device,
          0,
          grim_vertex_buffer,
          28);
        (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 340))(grim_d3d_device, dword_10059BB8, 0);
        return 1;
      }
      else
      {
        byte_1005C898 = 0;
        return 0;
      }
    }
    else
    {
      grim_error_text = (int)aD3dInternalCou_0;
      sub_100044E0();
      return 0;
    }
  }
  else
  {
    grim_error_text = (int)aD3dInternalCou;
    return 0;
  }
}

// sub_100044E0 @ 0x100044E0
int sub_100044E0()
{
  int result; // eax

  if ( grim_vertex_buffer )
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 8))(grim_vertex_buffer);
  result = dword_10059BB8;
  grim_vertex_buffer = 0;
  if ( dword_10059BB8 )
    result = (*(int (__stdcall **)(int))(*(_DWORD *)dword_10059BB8 + 8))(dword_10059BB8);
  dword_10059BB8 = 0;
  return result;
}

// sub_10004520 @ 0x10004520
int sub_10004520()
{
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 137, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 29, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 7, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 14, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 28, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 143, 0);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 22, 1);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 9, 2);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
    grim_d3d_device,
    26,
    (unsigned __int8)dword_1005D108);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 15, 1);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 25, 7);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 24, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 17, 2);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 16, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 18, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
  (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
  (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
  (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 11, 0);
  (*(void (__stdcall **)(int, int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 11, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 128, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 129, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 130, 0);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 131, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 332))(
    grim_d3d_device,
    0,
    grim_vertex_buffer,
    28);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 340))(grim_d3d_device, dword_10059BB8, 0);
  (*(void (__stdcall **)(int, int))(*(_DWORD *)grim_d3d_device + 304))(grim_d3d_device, 324);
  (*(void (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
    grim_d3d_device,
    27,
    (unsigned __int8)dword_1005CCA8);
  (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 19, dword_1005CCB8);
  return (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 20, dword_1005CCC8);
}

// grim_is_texture_format_supported @ 0x100047F0
// checks device support for a texture format
bool __cdecl sub_100047F0(int a1)
{
  return (*(int (__stdcall **)(int, WPARAM, int, int, _DWORD, int, int))(*(_DWORD *)grim_d3d8 + 40))(
           grim_d3d8,
           wParam,
           dword_1005B2B4,
           grim_texture_format,
           0,
           3,
           a1) >= 0;
}

// grim_select_texture_format @ 0x10004830
// chooses the first supported texture format
char sub_10004830()
{
  if ( grim_is_texture_format_supported(21) )
  {
    grim_preferred_texture_format = 21;
    return 1;
  }
  else if ( grim_is_texture_format_supported(861165636) )
  {
    grim_preferred_texture_format = 861165636;
    return 1;
  }
  else if ( grim_is_texture_format_supported(26) )
  {
    grim_preferred_texture_format = 26;
    return 1;
  }
  else if ( grim_is_texture_format_supported(25) )
  {
    grim_preferred_texture_format = 25;
    return 1;
  }
  else if ( grim_is_texture_format_supported(20) )
  {
    grim_preferred_texture_format = 20;
    return 1;
  }
  else if ( grim_is_texture_format_supported(22) )
  {
    grim_preferred_texture_format = 22;
    return 1;
  }
  else if ( grim_is_texture_format_supported(20) )
  {
    grim_preferred_texture_format = 20;
    return 1;
  }
  else if ( grim_is_texture_format_supported(23) )
  {
    grim_preferred_texture_format = 23;
    return 1;
  }
  else
  {
    grim_error_text = (int)aD3dNoSupported;
    return 0;
  }
}

// sub_10004920 @ 0x10004920
MMRESULT sub_10004920()
{
  dword_1005D3B0 = 981668463;
  dword_1005BAD4 = timeGetTime();
  grim_fps = 0;
  grim_frame_dt = 0.0;
  grim_time_ms = 0;
  dword_10059DC4 = dword_1005BAD4;
  dword_1005BAD0 = dword_1005BAD4;
  byte_1005A470 = 0;
  return timeBeginPeriod(1u);
}

// sub_10004970 @ 0x10004970
int sub_10004970()
{
  int v0; // eax
  int result; // eax
  double v2; // st7
  __int64 v3; // [esp+4h] [ebp-8h]
  __int64 v4; // [esp+4h] [ebp-8h]

  dword_10059DC4 = dword_1005BAD0;
  do
  {
    dword_1005BAD0 = timeGetTime();
    v0 = dword_1005BAD0 - dword_10059DC4;
  }
  while ( (unsigned int)(dword_1005BAD0 - dword_10059DC4) <= 1 );
  if ( byte_1005A470 )
  {
    grim_frame_dt = 0.0;
    dword_1005BAD4 += v0;
  }
  else
  {
    grim_time_ms += v0;
    ++dword_1005D814;
    dword_1005D818 += v0;
    grim_frame_dt = (double)(unsigned int)v0 * *(float *)&dword_1005D3B0;
  }
  result = dword_1005D818;
  if ( (unsigned int)dword_1005D818 > 0x1F4 )
  {
    v3 = (unsigned int)dword_1005D814;
    dword_1005D814 = 0;
    v2 = (double)v3;
    v4 = (unsigned int)dword_1005D818;
    result = dword_1005D818 - 500;
    dword_1005D818 -= 500;
    *(float *)&grim_fps = v2 / ((double)v4 * *(float *)&dword_1005D3B0);
  }
  return result;
}

// grim_texture_init @ 0x10004A50
// allocates/copies texture name and zeroes fields
char **__thiscall sub_10004A50(char **this, const char *a2)
{
  char *v3; // edx

  v3 = (char *)operator new(strlen(a2) + 1);
  *this = v3;
  strcpy(v3, a2);
  *(this + 1) = 0;
  *((_BYTE *)this + 8) = 0;
  *(this + 5) = 0;
  return this;
}

// grim_texture_release @ 0x10004AB0
// releases COM objects and frees texture name
void __thiscall sub_10004AB0(void **this)
{
  int v2; // eax
  int v3; // eax
  void *v4; // eax

  v2 = (int)*(this + 1);
  if ( v2 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 8))(v2);
  v3 = (int)*(this + 5);
  *(this + 1) = 0;
  if ( v3 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v3 + 8))(v3);
  v4 = *this;
  *(this + 5) = 0;
  if ( v4 )
    operator delete(v4);
  *this = 0;
}

// sub_10004B00 @ 0x10004B00
bool __cdecl sub_10004B00(const char *a1, const char *a2)
{
  signed int v2; // edx
  signed int v3; // esi
  char v4; // cl
  char v5; // al
  int v6; // esi
  int v7; // edx
  bool result; // al

  v2 = strlen(a1) - 3;
  v3 = strlen(a2) - 3;
  result = v2 >= 0
        && v3 >= 0
        && (v4 = a2[v3], v5 = a1[v2], v6 = v3 + 1, v7 = v2 + 1, v5 == v4)
        && a1[v7] == a2[v6]
        && a1[v7 + 1] == a2[v6 + 1];
  return result;
}

// FUN_10004b70 @ 0x10004B70
// [binja] char* sub_10004b70(char* arg1, void** arg2, int32_t* arg3, int32_t* arg4)
char *__cdecl sub_10004B70(int a1, int a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  int *v5; // eax
  int v6; // edx
  char *v7; // eax
  unsigned int *v9; // ebx
  unsigned int v10; // ecx
  unsigned int v11; // edx
  char *v12; // esi
  _DWORD *v13; // edi
  unsigned int v14; // edx
  int v15; // ecx
  int v16; // eax
  char v17; // bl
  char *v18; // esi
  int v19; // edx
  void *v20; // ecx
  int v21; // ebx
  int v22; // edi
  char *v23; // edx
  int v24; // eax
  int v25; // ecx
  int v26; // edx
  int v27; // eax
  int v28; // ecx
  unsigned int v29; // [esp-28h] [ebp-2D4h]
  void (__cdecl __noreturn *v30[33])(int); // [esp+Ch] [ebp-2A0h] BYREF
  char v31[64]; // [esp+90h] [ebp-21Ch] BYREF
  _DWORD v32[23]; // [esp+D0h] [ebp-1DCh] BYREF
  unsigned int v33; // [esp+12Ch] [ebp-180h]
  unsigned int v34; // [esp+130h] [ebp-17Ch]
  int v35; // [esp+138h] [ebp-174h]
  unsigned int v36; // [esp+148h] [ebp-164h]
  char v37[4]; // [esp+278h] [ebp-34h] BYREF
  int v38; // [esp+27Ch] [ebp-30h]
  _DWORD *v39; // [esp+280h] [ebp-2Ch]
  char *v40; // [esp+284h] [ebp-28h]
  int v41; // [esp+288h] [ebp-24h]
  int v42; // [esp+28Ch] [ebp-20h]
  void *v43; // [esp+290h] [ebp-1Ch]
  int v44; // [esp+294h] [ebp-18h]
  void *v45; // [esp+298h] [ebp-14h]
  char v46[4]; // [esp+29Ch] [ebp-10h] BYREF
  int v47; // [esp+2A8h] [ebp-4h]

  FUN_1000a810((Iostream_init *)v46);
  v47 = 0;
  v45 = 0;
  v5 = (int *)FUN_1000a880(a1, v37);
  v43 = v5;
  *a4 = 0;
  *a5 = 0;
  v6 = *v5;
  v39 = v5 + 1;
  v41 = v6;
  if ( v5 == (int *)-4 )
    goto LABEL_7;
  v32[0] = sub_1003AB10(v30);
  v30[0] = sub_10004E90;
  if ( setjmp3(v31, 3, &_CxxLongjmpUnwind, v47, &stru_100516E8) )
  {
    sub_10009B20(v32);
    if ( v45 )
      operator delete(v45);
    goto LABEL_7;
  }
  sub_10009A50(v32, 61, 424);
  sub_1003A990(v32, v39, v41);
  sub_10009B30(v32, 1);
  sub_10009EC0(v32);
  v29 = 4 * v33 * v34 + 18;
  *a3 = v29;
  v7 = (char *)operator new(v29);
  v45 = v7;
  if ( !v7 )
  {
    sub_10009B20(v32);
LABEL_7:
    v47 = -1;
    grim_noop();
    return 0;
  }
  v9 = a4;
  v10 = v33;
  v11 = v34;
  v12 = v7 + 18;
  *a4 = v33;
  v45 = v7 + 18;
  *a5 = v11;
  v13 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, unsigned int, int))(v32[1] + 8))(v32, 1, v10 * v35, 1);
  while ( v36 < v34 )
  {
    sub_1000A070(v32, v13, 1);
    v14 = 0;
    if ( *v9 )
    {
      v15 = 0;
      v16 = (int)&v12[4 * *v9 * (*a5 - v36) + 2];
      do
      {
        *(_BYTE *)(v16 + 1) = -1;
        ++v14;
        v16 += 4;
        v17 = *(_BYTE *)(*v13 + v15);
        v15 += 3;
        *(_BYTE *)(v16 - 4) = v17;
        *(_BYTE *)(v16 - 5) = *(_BYTE *)(*v13 + v15 - 2);
        *(_BYTE *)(v16 - 6) = *(_BYTE *)(*v13 + v15 - 1);
        v9 = a4;
      }
      while ( v14 < *a4 );
    }
  }
  v18 = v12 - 18;
  v45 = v18;
  sub_10009E00(v32);
  sub_10009B20(v32);
  *v18 = 0;
  v18[1] = 0;
  v18[2] = 2;
  *(_DWORD *)(v18 + 3) = 0;
  v18[7] = 0;
  *((_WORD *)v18 + 4) = 0;
  *((_WORD *)v18 + 5) = 0;
  *((_WORD *)v18 + 6) = *(_WORD *)v9;
  v19 = v41;
  *((_WORD *)v18 + 7) = *(_WORD *)a5;
  v20 = v43;
  v21 = 0;
  v22 = 0;
  v23 = (char *)v43 + v19 + 4;
  v24 = *((unsigned __int16 *)v18 + 7) - 1;
  v18[16] = 32;
  v18[17] = 8;
  v40 = v23;
  v42 = 0;
  v44 = v24;
  if ( v24 >= 0 )
  {
    v25 = v38;
    do
    {
      v26 = 0;
      v27 = *((unsigned __int16 *)v18 + 6);
      if ( (_WORD)v27 )
      {
        do
        {
          if ( v22 <= 0 )
          {
            v28 = (unsigned __int8)v40[v21];
            v21 += 2;
            v22 = v28;
            v25 = (unsigned __int8)v40[v21 - 1];
            v42 = v21;
            --v26;
          }
          else
          {
            v21 = v42;
            --v22;
            v18[4 * v26 + 21 + 4 * v44 * v27] = v25;
          }
          ++v26;
          v27 = *((unsigned __int16 *)v18 + 6);
        }
        while ( v26 < (unsigned __int16)v27 );
      }
      --v44;
    }
    while ( v44 >= 0 );
    v38 = v25;
    v20 = v43;
  }
  if ( v20 )
    operator delete(v20);
  v47 = -1;
  grim_noop();
  return v18;
}

// sub_10004E90 @ 0x10004E90
void __cdecl __noreturn sub_10004E90(int *a1)
{
  int v1; // esi
  _BYTE v2[200]; // [esp+4h] [ebp-C8h] BYREF

  v1 = *a1;
  (*(void (__cdecl **)(int *, _BYTE *))(*a1 + 12))(a1, v2);
  longjmp((int *)(v1 + 132), 1);
}

// grim_texture_load_file @ 0x10004EC0
// loads texture data from file path
char __thiscall sub_10004EC0(_DWORD *this, char *FileName)
{
  int v4; // eax
  _DWORD *v5; // ebx
  void *v6; // edi
  int v7; // ebp
  FILE *v8; // eax
  FILE *v9; // esi
  char *v10; // eax
  _DWORD *v11; // ecx
  int v12; // eax
  int v13; // edx
  int v14; // ecx
  bool v15; // [esp+13h] [ebp-2Dh]
  unsigned int v16; // [esp+14h] [ebp-2Ch] BYREF
  _DWORD *v17; // [esp+18h] [ebp-28h]
  unsigned int v18; // [esp+1Ch] [ebp-24h] BYREF
  unsigned int v19; // [esp+20h] [ebp-20h] BYREF
  int v20; // [esp+24h] [ebp-1Ch] BYREF
  int v21; // [esp+28h] [ebp-18h]

  v17 = this;
  if ( !FileName )
    return 0;
  v4 = *(this + 1);
  v5 = this + 1;
  if ( v4 )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v4 + 8))(*(this + 1));
  *v5 = 0;
  v6 = 0;
  v15 = 0;
  if ( byte_1005BC14 )
  {
    v6 = (void *)sub_10005AE0(FileName);
    v15 = v6 != 0;
  }
  if ( sub_10004B00(FileName, aJaz) )
  {
    if ( byte_1005BC14 && v15 )
    {
      v7 = sub_10005B80(FileName);
    }
    else
    {
      v8 = fopen(FileName, aRb);
      v9 = v8;
      if ( !v8 )
        return 0;
      fseek(v8, 0, 2);
      v7 = ftell(v9);
      fseek(v9, 0, 0);
      v6 = operator new(v7);
      fread(v6, v7, 1u, v9);
      fclose(v9);
    }
    v10 = FUN_10004b70((int)v6, v7, &v19, &v16, &v18);
    if ( v10
      && (v11 = v17,
          v17[3] = v16,
          v11[4] = v18,
          (int)FUN_1000cb5c(
                 grim_d3d_device,
                 v10,
                 v19,
                 -1,
                 -1,
                 1,
                 0,
                 grim_preferred_texture_format,
                 1,
                 -1,
                 -1,
                 0,
                 &v20,
                 0,
                 v5) < 0) )
    {
      *v5 = 0;
      return 0;
    }
    else
    {
      return 1;
    }
  }
  else if ( byte_1005BC14 && v15 )
  {
    v12 = sub_10005B80(FileName);
    if ( (int)FUN_1000cb5c(
                grim_d3d_device,
                v6,
                v12,
                -1,
                -1,
                1,
                0,
                grim_preferred_texture_format,
                1,
                -1,
                -1,
                0,
                &v20,
                0,
                this + 1) >= 0 )
    {
      v13 = v21;
      *(this + 3) = v20;
      *(this + 4) = v13;
      return 1;
    }
    else
    {
      *v5 = 0;
      return 0;
    }
  }
  else if ( FUN_1000cb9c(
              grim_d3d_device,
              (LPCWCH)FileName,
              -1,
              -1,
              1,
              0,
              grim_preferred_texture_format,
              1,
              -1,
              -1,
              0,
              (int)&v20,
              0,
              (int)(this + 1)) >= 0 )
  {
    v14 = v21;
    *(this + 3) = v20;
    *(this + 4) = v14;
    return 1;
  }
  else
  {
    *v5 = 0;
    return 0;
  }
}

// grim_texture_name_equals @ 0x10005110
// compares stored texture name
bool __thiscall sub_10005110(const char **this, const char *a2)
{
  return *this && a2 && strcmp(*this, a2) == 0;
}

// grim_find_texture_by_name @ 0x10005170
// returns texture handle index for name
int __cdecl sub_10005170(const char *a1)
{
  int v1; // esi
  const char ***i; // edi

  v1 = 0;
  if ( dword_1005305C + 1 <= 0 )
    return -1;
  for ( i = (const char ***)&grim_texture_slots; !*i || !grim_texture_name_equals(*i, a1); ++i )
  {
    if ( ++v1 >= dword_1005305C + 1 )
      return -1;
  }
  return v1;
}

// grim_find_free_texture_slot @ 0x100051C0
// finds the first free texture slot
int sub_100051C0()
{
  int result; // eax
  void **v1; // ecx

  result = 0;
  v1 = &grim_texture_slots;
  while ( *v1 )
  {
    ++v1;
    ++result;
    if ( (int)v1 >= (int)&byte_1005D804 )
      return -1;
  }
  return result;
}

// grim_load_texture_internal @ 0x100051E0
// allocates texture slot and loads file
char __cdecl sub_100051E0(const char *a1, char *FileName)
{
  int v2; // edi
  char **v4; // eax
  char **v5; // esi
  int v6; // eax

  v2 = grim_find_free_texture_slot();
  if ( v2 == -1 )
  {
    grim_error_text = (int)aAllTextureSlot;
    return 0;
  }
  else if ( grim_find_texture_by_name(a1) == -1 )
  {
    v4 = (char **)operator new(0x18u);
    if ( v4 )
      v5 = grim_texture_init(v4, a1);
    else
      v5 = 0;
    if ( grim_texture_load_file(v5, FileName) )
    {
      v6 = dword_1005305C;
      *(&grim_texture_slots + v2) = v5;
      if ( v2 > v6 )
        dword_1005305C = v2;
      return 1;
    }
    else
    {
      grim_error_text = (int)aD3dCouldNotLoa;
      if ( v5 )
      {
        grim_texture_release((void **)v5);
        operator delete(v5);
      }
      return 0;
    }
  }
  else
  {
    grim_error_text = (int)aD3dTextureSlot;
    return 0;
  }
}

// sub_100052F0 @ 0x100052F0
float *sub_100052F0()
{
  int v0; // edx
  int v1; // eax
  int v2; // esi
  int *v3; // edx
  int v4; // ecx
  int *v5; // eax
  double v6; // st6
  int v7; // eax
  int v8; // esi
  float *v9; // edx
  int v10; // ecx
  float *v11; // eax
  double v12; // st6
  int v13; // esi
  float *v14; // edx
  int v15; // ecx
  float *v16; // eax
  double v17; // st6
  int v18; // esi
  float *v19; // edx
  int v20; // ecx
  float *v21; // eax
  double v22; // st6
  int v23; // esi
  float *v24; // edx
  int v25; // ecx
  float *result; // eax
  double v27; // st6
  int v28; // [esp+Ch] [ebp-14h]
  int v29; // [esp+Ch] [ebp-14h]
  int v30; // [esp+Ch] [ebp-14h]
  int v31; // [esp+Ch] [ebp-14h]
  int v32; // [esp+Ch] [ebp-14h]
  int v33; // [esp+10h] [ebp-10h]
  int v34; // [esp+10h] [ebp-10h]
  int v35; // [esp+10h] [ebp-10h]
  int v36; // [esp+10h] [ebp-10h]
  int v37; // [esp+10h] [ebp-10h]
  int v38; // [esp+10h] [ebp-10h]
  int v39; // [esp+14h] [ebp-Ch]
  __int64 v40; // [esp+18h] [ebp-8h]

  dword_1005A47C = 0;
  grim_config_var1_table = 0;
  dword_1005A480 = 0;
  grim_config_var0_table = 0;
  grim_config_var2_table = 0;
  grim_config_var3_table = 0;
  qmemcpy(&unk_1005CB98, &grim_config_var0_table, 0x7F0u);
  dword_1005A484 = 0;
  dword_1005A478 = 0;
  dword_1005CE5C = v39;
  dword_1005CE58 = v33;
  dword_1005CE64 = (int)sub_10001140;
  dword_1005CBE8 = v33;
  dword_1005CE60 = v40;
  dword_1005CBF4 = (int)std::codecvt_base::do_always_noconv;
  dword_1005CBF0 = v40;
  dword_1005CBEC = v39;
  dword_1005CBE4 = (int)std::codecvt_base::do_always_noconv;
  dword_1005CBDC = v39;
  v0 = v33;
  dword_1005CBD8 = v33;
  dword_1005CC04 = (int)Caption;
  LOBYTE(v33) = 0;
  dword_1005CBE0 = v40;
  dword_1005CBF8 = v0;
  dword_1005CC08 = v33;
  dword_1005CBFC = v39;
  dword_1005CC00 = v40;
  dword_1005CC0C = v39;
  qword_1005CC10 = v40;
  dword_1005CE28 = 480;
  dword_1005CE2C = v39;
  qword_1005CE30 = v40;
  dword_1005CE18 = 16;
  dword_1005CE1C = v39;
  qword_1005CE20 = v40;
  dword_1005CC38 = v33;
  dword_1005CC3C = v39;
  LOBYTE(v33) = 0;
  dword_1005CC48 = v33;
  qword_1005CC50 = v40;
  qword_1005CC40 = v40;
  dword_1005CC6C = v39;
  qword_1005CC70 = v40;
  dword_1005CC4C = v39;
  v1 = v33;
  dword_1005CEBC = v39;
  qword_1005CEC0 = v40;
  LOBYTE(v33) = 0;
  grim_input_cached = v33;
  dword_1005CC5C = v39;
  dword_1005CC68 = v1;
  qword_1005CC60 = v40;
  dword_1005D0F8 = v33;
  dword_1005D0FC = v39;
  qword_1005D100 = v40;
  LOBYTE(v33) = 1;
  dword_1005D108 = v33;
  dword_1005D10C = v39;
  qword_1005D110 = v40;
  dword_1005D118 = 1065353216;
  dword_1005D11C = v39;
  qword_1005D120 = v40;
  grim_font_texture_bound = 1065353216;
  dword_1005CCFC = v39;
  qword_1005CD00 = v40;
  dword_1005CD08 = 1065353216;
  dword_1005CEB8 = 1;
  dword_1005CD0C = v39;
  qword_1005CD10 = v40;
  DWORD1(xmmword_1005D1C8) = v39;
  dword_1005CCAC = v39;
  LODWORD(xmmword_1005D1C8) = 1065353217;
  dword_1005CCB8 = 5;
  *((_QWORD *)&xmmword_1005D1C8 + 1) = v40;
  qword_1005CCB0 = v40;
  dword_1005CCBC = v39;
  dword_1005CCA8 = 1065353217;
  qword_1005CCC0 = v40;
  dword_1005CCC8 = 6;
  dword_1005CCCC = v39;
  qword_1005CCD0 = v40;
  dword_1005B288 = 1056964608;
  dword_1005B28C = 1065353216;
  grim_uv_v0 = 0;
  grim_uv_u1 = 1065353216;
  dword_1005D138 = 1120403456;
  dword_1005D148 = 0;
  dword_1005D158 = 0;
  grim_error_text = (int)String;
  byte_1005D3AC = 0;
  byte_1005BC14 = 0;
  dword_1005A670 = 0;
  ElementSize = 0;
  grim_backbuffer_width = 640;
  grim_backbuffer_height = 480;
  grim_texture_format = 23;
  grim_preferred_texture_format = 0;
  hWnd = 0;
  grim_color_slot0 = -1;
  grim_color_slot3 = -1;
  dword_1005BC0C = -1;
  dword_1005BC08 = -1;
  grim_uv_u0 = 0;
  grim_uv_v1 = 0;
  dword_1005B2A0 = 1065353216;
  dword_1005B2A4 = 1065353216;
  dword_1005B2A8 = 0;
  grim_mouse_button_latch = 0;
  dword_1005B2AC = 1065353216;
  dword_1005C8EC = 0;
  lpWindowName = strcpy((char *)operator new(strlen(aGrimNoTitle) + 1), aGrimNoTitle);
  memset(&flt_1005A058, 0, 0x400u);
  dword_1005977C = (int (*)(void))sub_10001140;
  dword_10059770 = (int (*)(void))std::codecvt_base::do_always_noconv;
  dword_1005D3A8 = (int (*)(void))std::codecvt_base::do_always_noconv;
  dword_1005CC94 = (int)strdup(String);
  v2 = 0;
  memset(&grim_font2_glyph_widths, 0, 0x100u);
  v28 = 0;
  v3 = &grim_font2_uv_v;
  do
  {
    v4 = 0;
    v5 = v3;
    v34 = 0;
    v3 += 32;
    do
    {
      v6 = (double)v34;
      v5 += 2;
      v34 = ++v4;
      *((float *)v5 - 3) = v6 * 0.0625;
      *((float *)v5 - 2) = (double)v28 * 0.0625;
    }
    while ( v4 < 16 );
    v28 = ++v2;
  }
  while ( v2 < 16 );
  v7 = 0;
  memset(&grim_subrect_ptr_table, 0, 0x40u);
  do
  {
    grim_font2_char_map[v7] = v7;
    ++v7;
  }
  while ( v7 < 256 );
  v8 = 0;
  byte_1005A654 = -28;
  byte_1005A666 = -10;
  byte_1005A634 = -60;
  byte_1005A646 = -42;
  byte_1005A635 = -59;
  byte_1005A655 = -27;
  grim_subrect_ptr0 = (int)&grim_subrect_table_0;
  grim_subrect_ptr1 = (int)&grim_subrect_table_1;
  grim_subrect_ptr2 = (int)&grim_subrect_table_2;
  grim_subrect_ptr3 = (int)&grim_subrect_table;
  v29 = 0;
  v9 = (float *)&unk_1005D38C;
  do
  {
    v10 = 0;
    v11 = v9;
    v35 = 0;
    v9 += 4;
    do
    {
      v12 = (double)v35;
      v11 += 2;
      v35 = ++v10;
      *(v11 - 3) = v12 * 0.5;
      *(v11 - 2) = (double)v29 * 0.5;
    }
    while ( v10 < 2 );
    v29 = ++v8;
  }
  while ( v8 < 2 );
  v13 = 0;
  v14 = (float *)&unk_1005CB0C;
  v30 = 0;
  do
  {
    v15 = 0;
    v16 = v14;
    v36 = 0;
    v14 += 8;
    do
    {
      v17 = (double)v36;
      v16 += 2;
      v36 = ++v15;
      *(v16 - 3) = v17 * 0.25;
      *(v16 - 2) = (double)v30 * 0.25;
    }
    while ( v15 < 4 );
    v30 = ++v13;
  }
  while ( v13 < 4 );
  v18 = 0;
  v19 = (float *)&unk_1005C90C;
  v31 = 0;
  do
  {
    v20 = 0;
    v21 = v19;
    v37 = 0;
    v19 += 16;
    do
    {
      v22 = (double)v37;
      v21 += 2;
      v37 = ++v20;
      *(v21 - 3) = v22 * 0.125;
      *(v21 - 2) = (double)v31 * 0.125;
    }
    while ( v20 < 8 );
    v31 = ++v18;
  }
  while ( v18 < 8 );
  v23 = 0;
  v24 = (float *)&unk_1005A67C;
  v32 = 0;
  do
  {
    v25 = 0;
    result = v24;
    v38 = 0;
    v24 += 32;
    do
    {
      v27 = (double)v38;
      result += 2;
      v38 = ++v25;
      *(result - 3) = v27 * 0.0625;
      *(result - 2) = (double)v32 * 0.0625;
    }
    while ( v25 < 16 );
    v32 = ++v23;
  }
  while ( v23 < 16 );
  return result;
}

// sub_10005A40 @ 0x10005A40
char __cdecl sub_10005A40(char *FileName)
{
  FILE *v1; // eax
  FILE *v2; // esi

  v1 = fopen(FileName, aRb);
  v2 = v1;
  if ( v1 )
  {
    fseek(v1, 0, 2);
    ElementSize = ftell(v2);
    fseek(v2, 0, 0);
    dword_1005A670 = operator new(ElementSize + 1);
    fread(dword_1005A670, ElementSize, 1u, v2);
    fclose(v2);
    return 1;
  }
  else
  {
    byte_1005BC14 = 0;
    if ( dword_1005A670 )
      operator delete(dword_1005A670);
    dword_1005A670 = 0;
    return 0;
  }
}

// sub_10005AE0 @ 0x10005AE0
char *__cdecl sub_10005AE0(const char *a1)
{
  signed int v1; // ebp
  unsigned int v2; // kr08_4

  v1 = strlen(off_10053040) + 1;
  if ( v1 >= (int)ElementSize )
    return 0;
  while ( 1 )
  {
    v2 = strlen((const char *)dword_1005A670 + v1) + 1;
    if ( !strcmp((const char *)dword_1005A670 + v1, a1) )
      break;
    v1 += v2 - 1 + *(_DWORD *)((char *)dword_1005A670 + v2 + v1) + 5;
    if ( v1 >= (int)ElementSize )
      return 0;
  }
  return (char *)dword_1005A670 + v2 + v1 + 4;
}

// sub_10005B80 @ 0x10005B80
int __cdecl sub_10005B80(const char *a1)
{
  signed int v1; // ebp
  unsigned int v2; // kr08_4

  v1 = strlen(off_10053040) + 1;
  if ( v1 >= (int)ElementSize )
    return 0;
  while ( 1 )
  {
    v2 = strlen((const char *)dword_1005A670 + v1) + 1;
    if ( !strcmp((const char *)dword_1005A670 + v1, a1) )
      break;
    v1 += v2 - 1 + *(_DWORD *)((char *)dword_1005A670 + v2 + v1) + 5;
    if ( v1 >= (int)ElementSize )
      return 0;
  }
  return *(_DWORD *)((char *)dword_1005A670 + v2 + v1);
}

// grim_set_key_char_buffer @ 0x10005C20
// Grim2D vtable 0x54 (provisional): set input character ring buffer
void *__stdcall sub_10005C20(void *a1, void *a2, int a3)
{
  off_10053048 = a1;
  off_1005304C = a2;
  dword_10053050 = a3;
  return a1;
}

// grim_get_key_char @ 0x10005C40
// Grim2D vtable 0x50 (provisional)
int sub_10005C40()
{
  int v0; // edx
  int result; // eax
  int *v2; // ecx
  int v3; // esi

  v0 = dword_1005D3E4;
  if ( !dword_1005D3E4 )
    return 0;
  result = dword_1005D3C4[0];
  if ( dword_1005D3E4 > 0 )
  {
    v2 = dword_1005D3C4;
    v3 = dword_1005D3E4;
    do
    {
      *v2 = v2[1];
      ++v2;
      --v3;
    }
    while ( v3 );
  }
  dword_1005D3E4 = v0 - 1;
  return result;
}

// grim_set_paused @ 0x10005C90
// Grim2D vtable 0x4 (provisional): pause game tick update
char __stdcall sub_10005C90(char a1)
{
  grim_paused_flag = a1;
  return a1;
}

// grim_get_version @ 0x10005CA0
// Grim2D vtable 0x8 (provisional): engine version constant
double sub_10005CA0()
{
  return 1.21;
}

// grim_check_device @ 0x10005CB0
// Grim2D vtable 0xc: device creation test
char __userpurge sub_10005CB0@<al>(int a1, const WCHAR *lpWideCharStr)
{
  int v3; // [esp+1Ch] [ebp-4h] BYREF
  int retaddr; // [esp+20h] [ebp+0h]

  v3 = 0;
  if ( (*(int (__stdcall **)(int, int, int, int, int *))(*(_DWORD *)grim_d3d_device + 108))(
         grim_d3d_device,
         grim_present_width,
         grim_present_height,
         21,
         &v3) < 0 )
    return 0;
  if ( (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 120))(grim_d3d_device, v3, v3) < 0
    || FUN_1000ae52(lpWideCharStr, 0, retaddr, 0, 0) < 0 )
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)retaddr + 8))(retaddr);
    return 0;
  }
  else
  {
    (*(void (__cdecl **)(int))(*(_DWORD *)retaddr + 8))(retaddr);
    return 1;
  }
}

// grim_apply_config @ 0x10005D40
// Grim2D vtable 0x10: opens D3D config dialog and applies settings
bool __thiscall sub_10005D40(void *this)
{
  int v2; // eax
  int v4; // [esp-10h] [ebp-14h]
  int v5; // [esp-10h] [ebp-14h]
  int v6; // [esp-10h] [ebp-14h]
  int v7; // [esp-10h] [ebp-14h]
  int v8; // [esp-10h] [ebp-14h]
  int v9; // [esp-Ch] [ebp-10h]
  int v10; // [esp-Ch] [ebp-10h]
  int v11; // [esp-Ch] [ebp-10h]
  int v12; // [esp-Ch] [ebp-10h]
  int v13; // [esp-Ch] [ebp-10h]
  int v14; // [esp-Ch] [ebp-10h]
  int v15; // [esp-Ch] [ebp-10h]
  int v16; // [esp-Ch] [ebp-10h]
  int v17; // [esp-8h] [ebp-Ch]
  int v18; // [esp-8h] [ebp-Ch]
  int v19; // [esp-8h] [ebp-Ch]
  int v20; // [esp-8h] [ebp-Ch]
  int v21; // [esp-8h] [ebp-Ch]
  int v22; // [esp-8h] [ebp-Ch]
  int v23; // [esp-8h] [ebp-Ch]
  int v24; // [esp-8h] [ebp-Ch]
  int v25; // [esp-4h] [ebp-8h]
  int v26; // [esp-4h] [ebp-8h]
  int v27; // [esp-4h] [ebp-8h]
  int v28; // [esp-4h] [ebp-8h]
  int v29; // [esp-4h] [ebp-8h]
  int v30; // [esp-4h] [ebp-8h]
  int v31; // [esp-4h] [ebp-8h]
  int v32; // [esp-4h] [ebp-8h]

  if ( !lParam )
    lParam = (LPARAM)LoadIconA(grim_module_handle, (LPCSTR)0x72);
  grim_config_dialog_canceled = 0;
  v2 = Direct3DCreate8(220);
  grim_d3d8_probe = v2;
  if ( v2 )
  {
    (*(void (__stdcall **)(int, _DWORD, int, void *))(*(_DWORD *)v2 + 52))(v2, 0, 1, &unk_1005A498);
    DialogBoxParamA(grim_module_handle, (LPCSTR)0x74, 0, grim_config_dialog_proc, 0);
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_d3d8_probe + 8))(grim_d3d8_probe);
    if ( !grim_config_dialog_canceled )
    {
      LOBYTE(v4) = byte_1005D400;
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 84, v4, v9, v17, v25);
      if ( (_BYTE)dword_1005B2B8 )
        (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 43, 16, v10, v18, v26);
      else
        (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 43, 32, v10, v18, v26);
      LOBYTE(v5) = byte_1005D400;
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 84, v5, v11, v19, v27);
      LOBYTE(v6) = byte_1005B280;
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 8, v6, v12, v20, v28);
      LOBYTE(v7) = 0;
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 52, v7, v13, v21, v29);
      LOBYTE(v8) = byte_1005B280;
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(this, 8, v8, v14, v22, v30);
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(
        this,
        41,
        dword_10053054,
        v15,
        v23,
        v31);
      (*(void (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(
        this,
        42,
        dword_10053058,
        v16,
        v24,
        v32);
    }
    return grim_config_dialog_canceled == 0;
  }
  else
  {
    grim_error_text = (int)Text;
    MessageBoxA(0, Text, Caption, 0);
    return 0;
  }
}

// grim_init_system @ 0x10005EB0
// Grim2D vtable 0x14: Grim2D init; returns success
char __thiscall sub_10005EB0(void *this)
{
  char result; // al
  char *v3; // eax
  int v4; // [esp-10h] [ebp-18h]
  int v5; // [esp-Ch] [ebp-14h]
  int v6; // [esp-8h] [ebp-10h]

  memset(DstBuf, 0, 0x104u);
  getcwd(DstBuf, 260);
  result = grim_d3d_init();
  if ( result )
  {
    if ( (_BYTE)dword_1005CC48 != 1 || (_BYTE)grim_input_cached || (unsigned __int8)grim_mouse_init(hWnd) )
    {
      if ( (_BYTE)dword_1005CC38 != 1 || (unsigned __int8)grim_keyboard_init(hWnd) )
      {
        if ( (_BYTE)dword_1005CC68 == 1 && !(unsigned __int8)grim_joystick_init(hWnd) )
        {
          grim_error_text = (int)aDi8CouldNotIni_1;
          LOBYTE(dword_1005CC68) = 0;
        }
        sub_10004920();
        sub_10004970();
        (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 32))(this, 21, 2);
        dword_1005D0B4 = (int)&hWnd;
        (*(void (__thiscall **)(void *, int, int, int, int, char *))(*(_DWORD *)this + 32))(
          this,
          16,
          v4,
          v5,
          v6,
          aCrimsonPaq);
        v3 = sub_10005AE0(aLoadSmallfntDa);
        if ( v3 )
          qmemcpy(&grim_font2_glyph_widths, v3, 0x100u);
        return 1;
      }
      else
      {
        grim_error_text = (int)aDi8CouldNotIni_0;
        grim_mouse_shutdown();
        grim_keyboard_shutdown();
        sub_10004280();
        grim_window_destroy();
        return 0;
      }
    }
    else
    {
      grim_error_text = (int)aDi8CouldNotIni;
      grim_mouse_shutdown();
      sub_10004280();
      grim_window_destroy();
      return 0;
    }
  }
  return result;
}

// grim_shutdown @ 0x10005FF0
// Grim2D vtable 0x18 (provisional): Grim2D shutdown
BOOL sub_10005FF0()
{
  sub_10005A40(String);
  grim_mouse_shutdown();
  grim_keyboard_shutdown();
  sub_1000A330();
  sub_10004280();
  return grim_window_destroy();
}

// grim_apply_settings @ 0x10006020
// Grim2D vtable 0x1c: apply Grim2D settings after config load
char sub_10006020()
{
  sub_10003C00();
  return 1;
}

// sub_10006030 @ 0x10006030
char __cdecl sub_10006030(int a1)
{
  char result; // al

  switch ( a1 )
  {
    case 0:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      result = 1;
      break;
    case 1:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      result = 1;
      break;
    case 2:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 4);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 4);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 5, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 6, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 4, 1);
      result = 1;
      break;
    case 3:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 7);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 7);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 6, 0);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 4);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 4);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 5, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 6, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 4, 1);
      result = 1;
      break;
    case 4:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 24);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 3);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 5, 2);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      result = 1;
      break;
    case 5:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 24);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, _DWORD))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 3, 0);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      result = 1;
      break;
    case 6:
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 2);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 2, 2);
      (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 1, 24);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 2, 2);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 3, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 1, 4, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 1, 1);
      (*(void (__stdcall **)(int, int, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 2, 4, 1);
      result = 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

// grim_set_config_var @ 0x10006580
// Grim2D vtable 0x20: config/state dispatcher; updates config tables, some IDs map to D3D render/texture state; extra args for some IDs
char __stdcall sub_10006580(int a1, int a2, float a3, float a4, char *String)
{
  unsigned int v5; // eax
  int *v6; // ebx
  int *v7; // ebx
  int v8; // edi
  char *v9; // esi
  __int64 v10; // rax
  int *v11; // ebx
  int *v12; // ebx
  int v14; // [esp+Ch] [ebp-604h]
  int v15; // [esp+Ch] [ebp-604h]
  _BYTE v16[512]; // [esp+10h] [ebp-600h] BYREF
  char v17; // [esp+210h] [ebp-400h] BYREF

  LOBYTE(v5) = a1 - 5;
  switch ( a1 )
  {
    case 5:
      dword_1005D3A8 = (int (*)(void))String;
      return v5;
    case 6:
      dword_10059770 = (int (*)(void))String;
      LOBYTE(v5) = (_BYTE)String;
      return v5;
    case 7:
      if ( lpWindowName )
        operator delete((void *)lpWindowName);
      lpWindowName = (LPCSTR)operator new(strlen(String) + 1);
      v5 = strlen(String) + 1;
      qmemcpy((void *)lpWindowName, String, v5);
      grim_config_var3_table[4 * a1] = (int)lpWindowName;
      return v5;
    case 11:
    case 12:
    case 14:
    case 66:
      LOBYTE(grim_config_var0_table[4 * a1]) = a2;
      return v5;
    case 13:
      LOBYTE(grim_config_var0_table[4 * a1]) = a2;
      LOBYTE(v5) = grim_input_cached;
      if ( (_BYTE)grim_input_cached )
        LOBYTE(dword_1005CC48) = 1;
      return v5;
    case 16:
      if ( !strcmp(String, ::String) )
      {
        if ( grim_config_var3_table[4 * a1] )
          operator delete((void *)grim_config_var3_table[4 * a1]);
        dword_1005CC94 = (int)strdup(::String);
        byte_1005BC14 = 0;
      }
      byte_1005BC14 = sub_10005A40(String);
      if ( grim_config_var3_table[4 * a1] )
        operator delete((void *)grim_config_var3_table[4 * a1]);
      grim_config_var3_table[4 * a1] = (int)strdup(String);
      LOBYTE(v5) = byte_1005BC14;
      LOBYTE(grim_config_var0_table[4 * a1]) = byte_1005BC14;
      return v5;
    case 18:
      LOBYTE(v5) = grim_config_var0_table[4 * a1];
      if ( (_BYTE)v5 != (_BYTE)a2 )
      {
        LOBYTE(v5) = (*(int (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 200))(
                       grim_d3d_device,
                       27,
                       (unsigned __int8)a2);
        LOBYTE(grim_config_var0_table[4 * a1]) = a2;
      }
      return v5;
    case 19:
      v5 = grim_config_var0_table[4 * a1];
      if ( v5 != a2 )
      {
        LOBYTE(v5) = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 19, a2);
        grim_config_var0_table[4 * a1] = a2;
      }
      return v5;
    case 20:
      v5 = grim_config_var0_table[4 * a1];
      if ( v5 != a2 )
      {
        LOBYTE(v5) = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 20, a2);
        grim_config_var0_table[4 * a1] = a2;
      }
      return v5;
    case 21:
      if ( a2 <= 0 )
        return v5;
      if ( a2 <= 2 )
        goto LABEL_44;
      if ( a2 == 3 )
      {
        if ( grim_config_var0_table[4 * a1] != 3 )
          (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 21, 3);
LABEL_44:
        if ( grim_config_var0_table[4 * a1] == 3 )
          (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 21, 1);
        (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 17, a2);
        LOBYTE(v5) = (*(int (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(
                       grim_d3d_device,
                       0,
                       16,
                       a2);
        grim_config_var0_table[4 * a1] = a2;
      }
      return v5;
    case 26:
      LOBYTE(v5) = sub_10006030(a2);
      if ( (_BYTE)v5 )
      {
        v6 = &grim_config_var0_table[4 * a1];
        *v6 = a2;
        goto LABEL_50;
      }
      return v5;
    case 27:
      v7 = &grim_config_var0_table[4 * a1];
      *v7 = a2;
      *((float *)v7 + 1) = a3;
      *((float *)v7 + 2) = a4;
      v7[3] = (int)String;
      HIWORD(v14) = (unsigned __int8)(__int64)(*(float *)&a2 * 127.0 + 128.0);
      BYTE1(v14) = (__int64)(a3 * 127.0 + 128.0);
      LOBYTE(v14) = (__int64)(a4 * 127.0 + 128.0);
      LOBYTE(v5) = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 200))(grim_d3d_device, 60, v14);
      return v5;
    case 28:
      v8 = 0;
      v9 = &v17;
      v15 = 0;
      do
      {
        v10 = (__int64)((double)v15 * *(float *)&a2 * 257.0);
        if ( (int)v10 <= 0xFFFF )
        {
          if ( (int)v10 < 0 )
            LOWORD(v10) = 0;
        }
        else
        {
          LOWORD(v10) = -1;
        }
        *((_WORD *)v9 - 256) = v10;
        *(_WORD *)v9 = v10;
        *((_WORD *)v9 + 256) = v10;
        ++v8;
        v9 += 2;
        v15 = v8;
      }
      while ( v8 < 256 );
      (*(void (__stdcall **)(int, int, _BYTE *))(*(_DWORD *)grim_d3d_device + 72))(grim_d3d_device, 1, v16);
      v11 = &grim_config_var0_table[4 * a1];
      *v11 = a2;
      *((float *)v11 + 1) = a3;
      *((float *)v11 + 2) = a4;
      v11[3] = (int)String;
      LOBYTE(v5) = (_BYTE)String;
      return v5;
    case 41:
      grim_backbuffer_width = a2;
      grim_config_var0_table[4 * a1] = a2;
      LOBYTE(v5) = a2;
      return v5;
    case 42:
      grim_backbuffer_height = a2;
      grim_config_var0_table[4 * a1] = a2;
      LOBYTE(v5) = a2;
      return v5;
    case 43:
      grim_config_var0_table[4 * a1] = a2;
      grim_texture_format = (a2 != 32) + 22;
      LOBYTE(v5) = a2;
      return v5;
    case 45:
      dword_1005977C = (int (*)(void))String;
      return v5;
    case 52:
      LOBYTE(grim_config_var0_table[4 * a1]) = a2;
      LOBYTE(v5) = a2;
      return v5;
    case 54:
      LOBYTE(v5) = (*(int (__stdcall **)(int, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 60))(
                     grim_d3d_device,
                     0,
                     0,
                     0,
                     0);
      return v5;
    case 82:
      v12 = &grim_config_var0_table[4 * a1];
      *v12 = a2;
      *((float *)v12 + 1) = a3;
      *((float *)v12 + 2) = a4;
      v12[3] = (int)String;
      dword_1005D3FC = *(_DWORD *)String;
      LOBYTE(v5) = (_BYTE)String;
      return v5;
    case 85:
      grim_render_disabled = a2;
      LOBYTE(v5) = a2;
      return v5;
    default:
      v6 = &grim_config_var0_table[4 * a1];
      *v6 = a2;
LABEL_50:
      *((float *)v6 + 1) = a3;
      *((float *)v6 + 2) = a4;
      v6[3] = (int)String;
      LOBYTE(v5) = LOBYTE(a4);
      return v5;
  }
}

// grim_get_config_var @ 0x10006C30
// Grim2D vtable 0x24 (provisional): fills 4 dwords for config entry (id 0..0x7f)
int *__stdcall sub_10006C30(int *a1, unsigned int a2)
{
  int *v2; // ecx

  if ( a2 >= 0x80 )
  {
    *a1 = dword_1005A478;
    a1[1] = dword_1005A47C;
    a1[2] = dword_1005A480;
    a1[3] = dword_1005A484;
    return a1;
  }
  else
  {
    v2 = &grim_config_var0_table[4 * a2];
    *a1 = *v2;
    a1[1] = v2[1];
    a1[2] = v2[2];
    a1[3] = v2[3];
    return a1;
  }
}

// grim_get_error_text @ 0x10006CA0
// Grim2D vtable 0x28: error string for MessageBox
int sub_10006CA0()
{
  return grim_error_text;
}

// grim_clear_color @ 0x10006CB0
// Grim2D vtable 0x2c: packs RGBA into device clear color
char __stdcall sub_10006CB0(float a1, float a2, float a3, float a4)
{
  char result; // al

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = byte_1005C898;
    if ( byte_1005C898 )
      return (*(int (__stdcall **)(int, _DWORD, _DWORD, int, unsigned int, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device
                                                                                          + 144))(
               grim_d3d_device,
               0,
               0,
               1,
               (unsigned __int8)(__int64)(a3 * 255.0)
             | (((unsigned __int8)(__int64)(a2 * 255.0)
               | ((((unsigned int)(__int64)(a4 * 255.0) << 8) | (unsigned __int8)(__int64)(a1 * 255.0)) << 8)) << 8),
               0,
               0);
  }
  return result;
}

// grim_set_render_target @ 0x10006D50
// Grim2D vtable 0x30 (provisional): set render target; -1 resets
char __stdcall sub_10006D50(int a1)
{
  int v2; // [esp-Ch] [ebp-14h]

  if ( grim_render_disabled )
    return 1;
  if ( a1 < 0 )
  {
    if ( grim_backbuffer_surface )
    {
      if ( grim_render_target_surface )
        (*(void (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
      grim_render_target_surface = 0;
      if ( (*(int (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 124))(
             grim_d3d_device,
             grim_backbuffer_surface,
             0) < 0 )
        return 0;
      if ( grim_backbuffer_surface )
        (*(void (__stdcall **)(int))(*(_DWORD *)grim_backbuffer_surface + 8))(grim_backbuffer_surface);
      grim_backbuffer_surface = 0;
    }
    return 1;
  }
  if ( grim_render_target_surface )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
    grim_render_target_surface = 0;
  }
  if ( !grim_backbuffer_surface )
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)grim_d3d_device + 128))(grim_d3d_device, &grim_backbuffer_surface);
  v2 = *((_DWORD *)*(&grim_texture_slots + a1) + 1);
  if ( (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)v2 + 60))(v2, 0, &grim_render_target_surface) < 0 )
    return 0;
  if ( (*(int (__stdcall **)(int, int, _DWORD))(*(_DWORD *)grim_d3d_device + 124))(
         grim_d3d_device,
         grim_render_target_surface,
         0) >= 0 )
    return 1;
  if ( grim_render_target_surface )
    (*(void (__stdcall **)(int))(*(_DWORD *)grim_render_target_surface + 8))(grim_render_target_surface);
  grim_render_target_surface = 0;
  return 0;
}

// grim_get_time_ms @ 0x10006E40
// Grim2D vtable 0x34: accumulated time (ms)
int sub_10006E40()
{
  return grim_time_ms;
}

// grim_set_time_ms @ 0x10006E50
// Grim2D vtable 0x38: set accumulated time
int __stdcall sub_10006E50(int a1)
{
  grim_time_ms = a1;
  return a1;
}

// grim_get_frame_dt @ 0x10006E60
// Grim2D vtable 0x3c: clamped frame delta
double sub_10006E60()
{
  if ( grim_frame_dt <= 0.1 )
    return grim_frame_dt;
  else
    return 0.1;
}

// grim_get_fps @ 0x10006E90
// Grim2D vtable 0x40: frames per second
double sub_10006E90()
{
  return *(float *)&grim_fps;
}

// sub_10006EA0 @ 0x10006EA0
BOOL sub_10006EA0()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D158;
  v2 = *(float *)&dword_1005D138;
  return -v2 > (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 156))(grim_interface_instance)
             - v1;
}

// sub_10006EF0 @ 0x10006EF0
BOOL sub_10006EF0()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D158;
  v2 = *(float *)&dword_1005D138;
  return (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 156))(grim_interface_instance) - v1 > v2;
}

// sub_10006F40 @ 0x10006F40
BOOL sub_10006F40()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D148;
  v2 = *(float *)&dword_1005D138;
  return -v2 > (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 152))(grim_interface_instance)
             - v1;
}

// sub_10006F90 @ 0x10006F90
BOOL sub_10006F90()
{
  float v1; // [esp+4h] [ebp-8h]
  float v2; // [esp+8h] [ebp-4h]

  v1 = *(float *)&dword_1005D148;
  v2 = *(float *)&dword_1005D138;
  return (double)(*(int (__thiscall **)(int))(*(_DWORD *)grim_interface_instance + 152))(grim_interface_instance) - v1 > v2;
}

// grim_is_key_active @ 0x10006FE0
// Grim2D vtable 0x80: routes key/mouse/joystick IDs
char __thiscall sub_10006FE0(void *this, int a2)
{
  int i; // eax
  double v4; // st7
  int v5; // ebx
  int v6; // esi
  int v7; // eax
  int v8; // edx

  if ( a2 <= 255 )
    return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 68))(this, a2);
  switch ( a2 )
  {
    case 256:
      return (*(int (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 88))(this, 0);
    case 257:
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 88))(this, 1);
    case 258:
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 88))(this, 2);
    case 259:
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 88))(this, 3);
    case 260:
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 88))(this, 4);
  }
  for ( i = 1; i <= 12; ++i )
  {
    if ( a2 == i + 286 )
      return (*(int (__thiscall **)(void *, int))(*(_DWORD *)this + 168))(this, i - 1);
  }
  switch ( a2 )
  {
    case 305:
      return sub_10006EA0();
    case 306:
      return sub_10006EF0();
    case 307:
      return sub_10006F40();
    case 308:
      return sub_10006F90();
    case 319:
      v4 = (double)*(int *)&String[8];
      return fabs(v4 * 0.001) > 0.5;
    case 320:
      v4 = (double)*(int *)&String[12];
      return fabs(v4 * 0.001) > 0.5;
    case 321:
      v4 = (double)*(int *)&String[16];
      return fabs(v4 * 0.001) > 0.5;
    case 339:
      v4 = (double)*(int *)&String[20];
      return fabs(v4 * 0.001) > 0.5;
    case 340:
      v4 = (double)*(int *)&String[24];
      return fabs(v4 * 0.001) > 0.5;
    case 341:
      v4 = (double)*(int *)&String[28];
      return fabs(v4 * 0.001) > 0.5;
  }
  if ( !dword_1005D3B4 )
    return 0;
  v5 = 0;
  v6 = 365;
  while ( 2 )
  {
    v7 = 0;
    v8 = v6;
    do
    {
      if ( a2 == v8 )
        return (*(int (__stdcall **)(int, int))(*(_DWORD *)dword_1005D3B4 + 12))(v5, v7);
      ++v7;
      ++v8;
    }
    while ( v7 < 5 );
    v6 += 5;
    ++v5;
    if ( v6 < 380 )
      continue;
    break;
  }
  return 0;
}

// grim_get_config_float @ 0x100071B0
// Grim2D vtable 0x84: config float lookup (scaled)
double __thiscall sub_100071B0(void *this, int a2)
{
  double result; // st7
  int v3; // esi
  int v4; // eax

  if ( a2 <= 255 )
    return 0.0;
  switch ( a2 )
  {
    case 319:
      return (double)*(int *)&String[8] * 0.001;
    case 320:
      return (double)*(int *)&String[12] * 0.001;
    case 321:
      return (double)*(int *)&String[16] * 0.001;
    case 339:
      return (double)*(int *)&String[20] * 0.001;
    case 340:
      return (double)*(int *)&String[24] * 0.001;
    case 341:
      return (double)*(int *)&String[28] * 0.001;
    case 351:
      (*(void (__thiscall **)(void *))(*(_DWORD *)this + 112))(this);
      break;
    case 352:
      (*(void (__thiscall **)(void *))(*(_DWORD *)this + 116))(this);
      break;
    default:
      v3 = 0;
      v4 = 360;
      while ( 1 )
      {
        if ( a2 == v4 - 5 )
        {
          (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 120))(this, v3);
          return result;
        }
        if ( a2 == v4 )
          break;
        ++v3;
        if ( ++v4 >= 363 )
          return 0.0;
      }
      (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 124))(this, v3);
      break;
  }
  return result;
}

// grim_get_slot_float @ 0x100072C0
// Grim2D vtable 0x88 (provisional): float slot accessor
double __stdcall sub_100072C0(int a1)
{
  return *(float *)&byte_1005BDFC[4 * a1 + 772];
}

// grim_get_slot_int @ 0x100072D0
// Grim2D vtable 0x8c (provisional): int slot accessor
int __stdcall sub_100072D0(int a1)
{
  return *(_DWORD *)&byte_1005BDFC[4 * a1 + 260];
}

// grim_set_slot_float @ 0x100072E0
// Grim2D vtable 0x90 (provisional): float slot setter
int __stdcall sub_100072E0(int a1, float a2)
{
  *(float *)&byte_1005BDFC[4 * a1 + 772] = a2;
  return a1;
}

// grim_set_slot_int @ 0x10007300
// Grim2D vtable 0x94 (provisional): int slot setter
int __stdcall sub_10007300(int a1, int a2)
{
  *(_DWORD *)&byte_1005BDFC[4 * a1 + 260] = a2;
  return a2;
}

// grim_is_key_down @ 0x10007320
// Grim2D vtable 0x44 (provisional)
int __stdcall sub_10007320(int a1)
{
  return grim_keyboard_key_down(a1);
}

// grim_flush_input @ 0x10007330
// Grim2D vtable 0x4c (provisional): clear buffered input/device state
int sub_10007330()
{
  int v0; // esi
  int v1; // eax
  int v3; // [esp+14h] [ebp-4h] BYREF

  v3 = 10;
  memset(&String[512], 0, 0x100u);
  v0 = 0;
  do
  {
    (*(void (__stdcall **)(_DWORD, int, char *, int *, _DWORD))(**(_DWORD **)&String[508] + 40))(
      *(_DWORD *)&String[508],
      20,
      &String[304],
      &v3,
      0);
    v1 = v0++;
  }
  while ( v1 < 100 && v3 );
  dword_1005D3E4 = 0;
  memset(&String[512], 0, 0x100u);
  return 0;
}

// grim_was_key_pressed @ 0x10007390
// Grim2D vtable 0x48 (provisional)
char __stdcall sub_10007390(int a1)
{
  double v1; // st7

  if ( !(unsigned __int8)grim_keyboard_key_down(a1) )
  {
    flt_1005A058[(unsigned __int8)a1] = 0.0;
    DstBuf[(unsigned __int8)a1 + 264] = 1;
    return 0;
  }
  if ( flt_1005A058[(unsigned __int8)a1] != 0.0 )
    return 0;
  v1 = flt_10053044;
  if ( !DstBuf[(unsigned __int8)a1 + 264] )
    v1 = v1 * 0.2;
  flt_1005A058[(unsigned __int8)a1] = v1;
  DstBuf[(unsigned __int8)a1 + 264] = 0;
  return 1;
}

// grim_is_mouse_button_down @ 0x10007410
// Grim2D vtable 0x58: cached mouse button state or poll
char __stdcall sub_10007410(int a1)
{
  if ( (_BYTE)grim_input_cached )
    return grim_mouse_button_cache[a1];
  else
    return grim_mouse_button_down(a1);
}

// grim_was_mouse_button_pressed @ 0x10007440
// Grim2D vtable 0x5c (provisional): edge-triggered mouse button
char __userpurge sub_10007440@<al>(int a1@<ecx>, int a2@<edi>, int a3)
{
  char v4; // dl
  bool v6; // bl

  if ( (_BYTE)grim_input_cached )
  {
    v4 = grim_mouse_button_cache[a3];
    if ( v4 && *((_BYTE *)&grim_mouse_button_latch + a3) )
    {
      *((_BYTE *)&grim_mouse_button_latch + a3) = v4 == 0;
      return 1;
    }
    else
    {
      *((_BYTE *)&grim_mouse_button_latch + a3) = v4 == 0;
      return 0;
    }
  }
  else
  {
    v6 = (*(unsigned __int8 (__thiscall **)(int, int, int))(*(_DWORD *)a1 + 88))(a1, a3, a2)
      && *((_BYTE *)&grim_mouse_button_latch + a3);
    *((_BYTE *)&grim_mouse_button_latch + a3) = (*(unsigned __int8 (__thiscall **)(int))(*(_DWORD *)a1 + 88))(a1) == 0;
    return v6;
  }
}

// grim_get_mouse_dx @ 0x100074D0
// Grim2D vtable 0x70: cached mouse delta X
double sub_100074D0()
{
  return *(float *)&String[808];
}

// grim_get_mouse_dy @ 0x100074E0
// Grim2D vtable 0x74: cached mouse delta Y
double sub_100074E0()
{
  return *(float *)&String[812];
}

// grim_get_mouse_dx_indexed @ 0x100074F0
// Grim2D vtable 0x78: alias of get_mouse_dx
int __thiscall sub_100074F0(void *this, int a2)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 112))(this);
}

// grim_get_mouse_dy_indexed @ 0x10007500
// Grim2D vtable 0x7c: alias of get_mouse_dy
int __thiscall sub_10007500(void *this, int a2)
{
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 116))(this);
}

// grim_get_mouse_x @ 0x10007510
// Grim2D vtable 0x68: cached mouse X position
double sub_10007510()
{
  return grim_mouse_x_cached;
}

// grim_get_mouse_y @ 0x10007520
// Grim2D vtable 0x6c: cached mouse Y position
double sub_10007520()
{
  return grim_mouse_y_cached;
}

// grim_set_mouse_pos @ 0x10007530
// Grim2D vtable 0x64: set cached mouse position
int __stdcall sub_10007530(float a1, float a2)
{
  *(float *)&String[796] = a1;
  *(float *)&String[800] = a2;
  grim_mouse_x_cached = a1;
  grim_mouse_y_cached = a2;
  return LODWORD(a2);
}

// grim_get_mouse_wheel_delta @ 0x10007560
// Grim2D vtable 0x60 (provisional)
double sub_10007560()
{
  if ( (_BYTE)grim_input_cached )
    return flt_1005D3B8;
  else
    return *(float *)&String[816];
}

// grim_get_joystick_x @ 0x10007580
// Grim2D vtable 0x98 (provisional): joystick axis X
int sub_10007580()
{
  return *(_DWORD *)&String[8];
}

// grim_get_joystick_y @ 0x10007590
// Grim2D vtable 0x9c (provisional): joystick axis Y
int sub_10007590()
{
  return *(_DWORD *)&String[12];
}

// grim_get_joystick_z @ 0x100075A0
// Grim2D vtable 0xa0 (provisional): joystick axis Z
int sub_100075A0()
{
  return *(_DWORD *)&String[16];
}

// grim_get_joystick_pov @ 0x100075B0
// Grim2D vtable 0xa4 (provisional): joystick POV hat value
int __stdcall sub_100075B0(int a1)
{
  return *(_DWORD *)&String[4 * a1 + 40];
}

// grim_is_joystick_button_down @ 0x100075C0
// Grim2D vtable 0xa8 (provisional): joystick button state
int __stdcall sub_100075C0(int a1)
{
  return sub_1000A310(a1);
}

// grim_create_texture @ 0x100075D0
// Grim2D vtable 0xac: create blank texture in a free slot
char __stdcall sub_100075D0(const char *a1, int a2, int a3)
{
  int v3; // esi
  char **v5; // eax
  char **v6; // eax
  char *v7; // edx
  _DWORD v8[4]; // [esp+20h] [ebp-10h] BYREF

  v3 = grim_find_free_texture_slot();
  if ( v3 < 0 )
    return 0;
  if ( (*(int (__stdcall **)(int, int, int, int, int, int, _DWORD, _DWORD *))(*(_DWORD *)grim_d3d_device + 80))(
         grim_d3d_device,
         a2,
         a3,
         1,
         1,
         grim_texture_format,
         0,
         v8) >= 0 )
  {
    v5 = (char **)operator new(0x18u);
    v8[3] = 0;
    if ( v5 )
      v6 = grim_texture_init(v5, a1);
    else
      v6 = 0;
    v7 = (char *)v8[0];
    *(&grim_texture_slots + v3) = v6;
    v6[1] = v7;
    *((_BYTE *)*(&grim_texture_slots + v3) + 8) = 1;
    *((_DWORD *)*(&grim_texture_slots + v3) + 3) = a2;
    *((_DWORD *)*(&grim_texture_slots + v3) + 4) = a3;
    if ( v3 > dword_1005305C )
      dword_1005305C = v3;
    return 1;
  }
  else
  {
    grim_error_text = (int)aD3dCouldNotCre;
    return 0;
  }
}

// grim_load_texture @ 0x100076E0
// Grim2D vtable 0xb4 (provisional)
char __stdcall sub_100076E0(const char *a1, char *FileName)
{
  return grim_load_texture_internal(a1, FileName);
}

// grim_destroy_texture @ 0x10007700
// Grim2D vtable 0xbc (provisional): release texture handle
void __stdcall sub_10007700(int a1)
{
  void *v1; // esi
  int v2; // eax
  bool v3; // zf

  v1 = *(&grim_texture_slots + a1);
  if ( v1 )
  {
    grim_texture_release((void **)*(&grim_texture_slots + a1));
    operator delete(v1);
    v2 = dword_1005305C;
    v3 = a1 == dword_1005305C;
    *(&grim_texture_slots + a1) = 0;
    if ( v3 )
      dword_1005305C = v2 - 1;
  }
}

// grim_get_texture_handle @ 0x10007740
// Grim2D vtable 0xc0: lookup texture handle by name
int __stdcall sub_10007740(const char *a1)
{
  return grim_find_texture_by_name(a1);
}

// grim_validate_texture @ 0x10007750
// Grim2D vtable 0xb8: validate texture handle/device
bool __stdcall sub_10007750(int a1, LPCWCH lpWideCharStr)
{
  int v2; // eax

  v2 = (int)*(&grim_texture_slots + a1);
  return v2 && FUN_1000c1e8(lpWideCharStr, 2, *(_DWORD *)(v2 + 4), 0) >= 0;
}

// grim_recreate_texture @ 0x10007790
// Grim2D vtable 0xb0: recreate D3D texture surface
char __stdcall sub_10007790(int a1)
{
  int v1; // esi
  int v2; // eax
  int v4; // [esp-4h] [ebp-8h]

  v1 = a1;
  v2 = (int)*(&grim_texture_slots + a1);
  if ( !v2 )
    return 0;
  if ( (int)FUN_1000b297(
              grim_d3d_device,
              *(_DWORD *)(v2 + 12),
              *(_DWORD *)(v2 + 16),
              1,
              0,
              grim_preferred_texture_format,
              1,
              &a1) < 0 )
    return 0;
  if ( FUN_1000b3fe(a1, *((_DWORD *)*(&grim_texture_slots + v1) + 1), 0, 0, 16, 1.0) >= 0 )
  {
    v4 = *((_DWORD *)*(&grim_texture_slots + v1) + 1);
    (*(void (__stdcall **)(int))(*(_DWORD *)v4 + 8))(v4);
    *((_DWORD *)*(&grim_texture_slots + v1) + 1) = a1;
    return 1;
  }
  else
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
    return 0;
  }
}

// grim_bind_texture @ 0x10007830
// Grim2D vtable 0xc4: bind texture handle to stage
void __stdcall sub_10007830(int a1, int a2)
{
  int v2; // eax
  int v3; // eax

  if ( a1 >= 0 )
  {
    v2 = (int)*(&grim_texture_slots + a1);
    if ( v2 )
    {
      v3 = *(_DWORD *)(v2 + 4);
      if ( v3 )
      {
        (*(void (__stdcall **)(int, int, int))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, a2, v3);
        grim_bound_texture_handle = a1;
      }
    }
  }
}

// grim_draw_fullscreen_quad @ 0x10007870
// Grim2D vtable 0xc8: full-screen quad with current texture
int __thiscall sub_10007870(void *this, int a2)
{
  float v4; // [esp+4h] [ebp-14h]
  float v5; // [esp+8h] [ebp-10h]

  (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 252))(this, 0);
  (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
  v5 = (float)(unsigned int)grim_backbuffer_height;
  v4 = (float)(unsigned int)grim_backbuffer_width;
  (*(void (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 284))(
    this,
    0,
    0,
    LODWORD(v4),
    LODWORD(v5));
  return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 240))(this);
}

// grim_draw_rect_filled @ 0x100078E0
// Grim2D vtable 0xd0: UI panel fill/quad
void __thiscall sub_100078E0(void *this, _DWORD *a2, int a3, int a4, int a5)
{
  if ( *(float *)(a5 + 12) > 0.0 )
  {
    (*(void (__stdcall **)(int, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
    (*(void (__thiscall **)(void *, int))(*(_DWORD *)this + 272))(this, a5);
    (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 252))(this, 0);
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, int))(*(_DWORD *)this + 284))(this, *a2, a2[1], a3, a4);
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 240))(this);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  }
}

// grim_draw_fullscreen_color @ 0x100079B0
// Grim2D vtable 0xcc: fullscreen color/fade overlay
void __thiscall sub_100079B0(void *this, int a2, int a3, int a4, float a5)
{
  float v6; // [esp+40h] [ebp-14h]
  float v7; // [esp+44h] [ebp-10h]

  if ( a5 > 0.0 )
  {
    (*(void (__stdcall **)(int, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
    (*(void (__thiscall **)(void *, int, int, int, _DWORD))(*(_DWORD *)this + 276))(this, a2, a3, a4, LODWORD(a5));
    (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 252))(this, 0);
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
    v7 = (float)(unsigned int)grim_backbuffer_height;
    v6 = (float)(unsigned int)grim_backbuffer_width;
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 284))(
      this,
      0,
      0,
      LODWORD(v6),
      LODWORD(v7));
    (*(void (__thiscall **)(void *))(*(_DWORD *)this + 240))(this);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
    (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
  }
}

// grim_begin_batch @ 0x10007AC0
// Grim2D vtable 0xe8 (provisional): begin draw batch
char sub_10007AC0()
{
  int v0; // eax

  LOBYTE(v0) = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    LOBYTE(v0) = grim_batch_active;
    if ( !grim_batch_active )
    {
      LOBYTE(v0) = byte_1005C898;
      grim_batch_active = 1;
      if ( byte_1005C898 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
        v0 = (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
               grim_vertex_buffer,
               0,
               0,
               &grim_vertex_write_ptr,
               10240);
        if ( v0 < 0 )
          byte_1005C898 = 0;
        LOWORD(grim_vertex_count) = 0;
      }
    }
  }
  return v0;
}

// grim_end_batch @ 0x10007B20
// Grim2D vtable 0xf0 (provisional): end draw batch/flush
char sub_10007B20()
{
  char result; // al

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = grim_batch_active;
    if ( grim_batch_active )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      result = byte_1005C898;
      if ( byte_1005C898 )
      {
        if ( (_WORD)grim_vertex_count )
          (*(void (__stdcall **)(int, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)grim_d3d_device + 284))(
            grim_d3d_device,
            4,
            0,
            (unsigned __int16)grim_vertex_count,
            0,
            (unsigned __int16)grim_vertex_count >> 1);
        result = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
  return result;
}

// grim_draw_circle_filled @ 0x10007B90
// Grim2D vtable 0xd8 (provisional): triangle fan circle fill
char __userpurge sub_10007B90@<al>(int a1@<edi>, int a2, float a3, float a4, float a5)
{
  char result; // al
  int v6; // edx
  double v7; // st7
  __int64 v8; // rax
  long double v9; // st6
  int v10; // [esp+28h] [ebp-20h]
  _BYTE v11[24]; // [esp+30h] [ebp-18h] BYREF

  result = grim_batch_active;
  if ( !grim_batch_active )
  {
    result = byte_1005C898;
    grim_batch_active = 1;
    if ( byte_1005C898 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240) < 0 )
        byte_1005C898 = 0;
      *(_DWORD *)&v11[4] = dword_1005B288;
      *(_DWORD *)&v11[16] = grim_uv_u0;
      LOWORD(grim_vertex_count) = 0;
      *(_DWORD *)&v11[8] = dword_1005B28C;
      *(_DWORD *)&v11[12] = grim_color_slot0;
      v6 = *(_DWORD *)grim_d3d_device;
      *(_DWORD *)&v11[20] = grim_uv_v0;
      (*(void (__stdcall **)(int, _DWORD, _DWORD, int))(v6 + 244))(grim_d3d_device, 0, 0, a1);
      *(float *)&v11[4] = a4;
      *(float *)v11 = a3;
      v7 = a5 * 0.125 + 12.0;
      qmemcpy((void *)grim_vertex_write_ptr, v11, 0x1Cu);
      LOWORD(grim_vertex_count) = grim_vertex_count + 1;
      grim_vertex_write_ptr += 28;
      v8 = (__int64)v7;
      HIDWORD(v8) = 0;
      v10 = 0;
      if ( (int)(__int64)v7 >= 0 )
      {
        do
        {
          v9 = (double)v10 * 6.2831855 / (double)(int)(__int64)v7;
          *(float *)v11 = cos(v9) * a5 + a3;
          *(float *)&v11[4] = sin(v9) * a5 + a4;
          qmemcpy((void *)grim_vertex_write_ptr, v11, 0x1Cu);
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          ++HIDWORD(v8);
          grim_vertex_write_ptr += 28;
          v10 = HIDWORD(v8);
        }
        while ( SHIDWORD(v8) <= (int)v8 );
      }
      (*(void (__cdecl **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      result = byte_1005C898;
      if ( byte_1005C898 )
      {
        (*(void (__stdcall **)(int, int, _DWORD, int))(*(_DWORD *)grim_d3d_device + 280))(
          grim_d3d_device,
          6,
          0,
          (unsigned __int16)grim_vertex_count - 2);
        result = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
  return result;
}

// grim_draw_circle_outline @ 0x10007D40
// Grim2D vtable 0xdc (provisional): triangle strip ring/outline
char __stdcall sub_10007D40(float a1, float a2, float a3)
{
  char result; // al
  __int64 v4; // rax
  double v5; // st6
  long double v6; // st5
  long double v7; // st4
  long double v8; // st5
  int v9; // [esp+18h] [ebp-24h]
  float v10; // [esp+18h] [ebp-24h]
  float v11[7]; // [esp+20h] [ebp-1Ch] BYREF

  result = grim_batch_active;
  if ( !grim_batch_active )
  {
    result = byte_1005C898;
    grim_batch_active = 1;
    if ( byte_1005C898 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 136))(grim_d3d_device);
      if ( (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240) < 0 )
        byte_1005C898 = 0;
      LODWORD(v11[2]) = dword_1005B288;
      LODWORD(v11[3]) = dword_1005B28C;
      LOWORD(grim_vertex_count) = 0;
      LODWORD(v11[4]) = grim_color_slot0;
      LODWORD(v11[5]) = grim_uv_u0;
      LODWORD(v11[6]) = grim_uv_v0;
      v4 = (__int64)(a3 * 0.2 + 14.0);
      HIDWORD(v4) = 0;
      v9 = 0;
      if ( (int)v4 >= 0 )
      {
        v5 = a3 + 2.0;
        do
        {
          v11[6] = 0.0;
          v6 = (double)v9 * 6.2831855 / (double)(int)(__int64)(a3 * 0.2 + 14.0);
          v7 = cos(v6);
          v10 = v7;
          v11[0] = v7 * a3 + a1;
          v8 = sin(v6);
          v11[1] = v8 * a3 + a2;
          qmemcpy((void *)grim_vertex_write_ptr, v11, 0x1Cu);
          v11[0] = v5 * v10 + a1;
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          v11[1] = v5 * v8 + a2;
          grim_vertex_write_ptr += 28;
          v11[6] = 1.0;
          qmemcpy((void *)grim_vertex_write_ptr, v11, 0x1Cu);
          LOWORD(grim_vertex_count) = grim_vertex_count + 1;
          ++HIDWORD(v4);
          grim_vertex_write_ptr += 28;
          v9 = HIDWORD(v4);
        }
        while ( SHIDWORD(v4) <= (int)v4 );
      }
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      result = byte_1005C898;
      if ( byte_1005C898 )
      {
        (*(void (__stdcall **)(int, int, _DWORD, int))(*(_DWORD *)grim_d3d_device + 280))(
          grim_d3d_device,
          5,
          0,
          (unsigned __int16)grim_vertex_count - 2);
        result = (*(int (__stdcall **)(int))(*(_DWORD *)grim_d3d_device + 140))(grim_d3d_device);
        grim_batch_active = 0;
      }
    }
  }
  return result;
}

// nullsub_20 @ 0x10007F20
void nullsub_20()
{
  ;
}

// grim_set_rotation @ 0x10007F30
// Grim2D vtable 0xfc: precompute sin/cos (+45deg) for rotation matrix
int __stdcall sub_10007F30(int a1)
{
  long double v1; // st7

  v1 = *(float *)&a1 + 0.78539819;
  grim_rotation_radians = a1;
  grim_rotation_cos = cos(v1);
  dword_1005A460 = LODWORD(grim_rotation_cos);
  dword_1005A46C = LODWORD(grim_rotation_cos);
  *(float *)&DstBuf[260] = sin(v1);
  flt_1005A468 = -*(float *)&DstBuf[260];
  dword_1005A464 = *(_DWORD *)&DstBuf[260];
  return LODWORD(grim_rotation_cos);
}

// grim_set_color @ 0x10007F90
// Grim2D vtable 0x114 (provisional)
int __stdcall sub_10007F90(float a1, float a2, float a3, float a4)
{
  double v4; // st7
  int result; // eax

  v4 = a4;
  if ( a4 <= 1.0 )
  {
    if ( v4 < 0.0 )
      v4 = 0.0;
  }
  else
  {
    v4 = 1.0;
  }
  result = (unsigned __int8)(__int64)(a3 * 255.0);
  grim_color_slot0 = result
                   | (((unsigned __int8)(__int64)(a2 * 255.0)
                     | ((((unsigned int)(__int64)(v4 * 255.0) << 8) | (unsigned __int8)(__int64)(a1 * 255.0)) << 8)) << 8);
  grim_color_slot3 = grim_color_slot0;
  dword_1005BC0C = grim_color_slot0;
  dword_1005BC08 = grim_color_slot0;
  return result;
}

// grim_set_color_ptr @ 0x10008040
// Grim2D vtable 0x110: set color from float[4]
int __stdcall sub_10008040(float *a1)
{
  double v2; // st7
  int v4; // [esp+8h] [ebp+4h]

  v2 = *a1 * 255.0;
  HIBYTE(v4) = (__int64)(a1[3] * 255.0);
  BYTE2(v4) = (__int64)v2;
  BYTE1(v4) = (__int64)(a1[1] * 255.0);
  LOBYTE(v4) = (__int64)(a1[2] * 255.0);
  grim_color_slot0 = v4;
  grim_color_slot3 = v4;
  dword_1005BC0C = v4;
  dword_1005BC08 = v4;
  return v4;
}

// grim_draw_line @ 0x100080B0
// Grim2D vtable 0xe0 (provisional): builds line quad from endpoints
int __thiscall sub_100080B0(void *this, float *a2, float *a3, float a4)
{
  double v5; // st7

  if ( (byte_10059BB4 & 1) == 0 )
  {
    byte_10059BB4 |= 1u;
    atexit(nullsub_5);
  }
  grim_line_dx = *a3 - *a2;
  grim_line_dy = a3[1] - a2[1];
  sub_1000CC39(&grim_line_dx, &grim_line_dx);
  v5 = grim_line_dy * a4;
  grim_line_dx = v5;
  grim_line_dy = v5 * a4;
  return (*(int (__thiscall **)(void *, float *, float *, float *))(*(_DWORD *)this + 228))(this, a2, a3, &grim_line_dx);
}

// nullsub_5 @ 0x10008140
void __cdecl nullsub_5()
{
  ;
}

// grim_draw_line_quad @ 0x10008150
// Grim2D vtable 0xe4 (provisional): line quad from endpoints + half-width vector
int __thiscall sub_10008150(void *this, float *a2, float *a3, float *a4)
{
  float v5; // [esp+0h] [ebp-28h]
  float v6; // [esp+4h] [ebp-24h]
  float v7; // [esp+8h] [ebp-20h]
  float v8; // [esp+Ch] [ebp-1Ch]
  float v9; // [esp+10h] [ebp-18h]
  float v10; // [esp+14h] [ebp-14h]
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+1Ch] [ebp-Ch]

  v12 = a3[1] - a4[1];
  v11 = *a3 - *a4;
  v10 = a3[1] + a4[1];
  v9 = *a3 + *a4;
  v8 = a2[1] + a4[1];
  v7 = *a2 + *a4;
  v6 = a2[1] - a4[1];
  v5 = *a2 - *a4;
  return (*(int (__stdcall **)(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 312))(
           LODWORD(v5),
           LODWORD(v6),
           LODWORD(v7),
           LODWORD(v8),
           LODWORD(v9),
           LODWORD(v10),
           LODWORD(v11),
           LODWORD(v12));
}

// grim_set_color_slot @ 0x100081C0
// Grim2D vtable 0x118 (provisional): set color slot
int __stdcall sub_100081C0(int a1, float a2, float a3, float a4, float a5)
{
  grim_color_slot0[a1] = (unsigned __int8)(__int64)(a4 * 255.0)
                       | (((unsigned __int8)(__int64)(a3 * 255.0)
                         | ((((unsigned int)(__int64)(a5 * 255.0) << 8) | (unsigned __int8)(__int64)(a2 * 255.0)) << 8)) << 8);
  return a1;
}

// grim_set_atlas_frame @ 0x10008230
// Grim2D vtable 0x104 (provisional)
int __stdcall sub_10008230(int a1, int a2)
{
  double v2; // st7
  int v3; // edx
  int v5; // [esp+4h] [ebp-4h]

  v2 = 1.0 / (double)a1;
  v3 = grim_subrect_ptr_table[a1];
  v5 = *(int *)(v3 + 8 * a2 + 4);
  dword_1005B2A8 = *(_DWORD *)(v3 + 8 * a2);
  grim_uv_v1 = v5;
  grim_uv_u0 = dword_1005B2A8;
  grim_uv_v0 = v5;
  *(float *)&grim_uv_u1 = *(float *)&dword_1005B2A8 + v2;
  dword_1005B2A0 = grim_uv_u1;
  *(float *)&dword_1005B2A4 = *(float *)&v5 + v2;
  *(float *)&dword_1005B2AC = *(float *)&v5 + v2;
  return dword_1005B2A8;
}

// grim_set_sub_rect @ 0x100082C0
// Grim2D vtable 0x108: atlas sub-rect from grid table
int __stdcall sub_100082C0(int a1, int a2, int a3, int a4)
{
  double v4; // st7
  int v5; // edx
  int v7; // [esp+4h] [ebp-4h]

  v4 = 1.0 / (double)a1;
  v5 = grim_subrect_ptr_table[a1];
  v7 = *(int *)(v5 + 8 * a4 + 4);
  dword_1005B2A8 = *(_DWORD *)(v5 + 8 * a4);
  grim_uv_v1 = v7;
  grim_uv_u0 = dword_1005B2A8;
  grim_uv_v0 = v7;
  *(float *)&grim_uv_u1 = (double)a2 * v4 + *(float *)&dword_1005B2A8;
  dword_1005B2A0 = grim_uv_u1;
  *(float *)&dword_1005B2A4 = v4 * (double)a3 + *(float *)&v7;
  dword_1005B2AC = dword_1005B2A4;
  return dword_1005B2A8;
}

// grim_set_uv @ 0x10008350
// Grim2D vtable 0x100 (provisional)
int __stdcall sub_10008350(int a1, int a2, int a3, int a4)
{
  grim_uv_u0 = a1;
  grim_uv_v0 = a2;
  grim_uv_u1 = a3;
  grim_uv_v1 = a2;
  dword_1005B2A0 = a3;
  dword_1005B2A4 = a4;
  dword_1005B2A8 = a1;
  dword_1005B2AC = a4;
  return a1;
}

// grim_set_uv_point @ 0x100083A0
// Grim2D vtable 0x10c: set UV point
int __stdcall sub_100083A0(int a1, int a2, int a3)
{
  grim_uv_u0[2 * a1] = a2;
  grim_uv_v0[2 * a1] = a3;
  return a1;
}

// grim_flush_batch @ 0x100083C0
// Grim2D vtable 0xec: flush batch when vertex buffer fills
char sub_100083C0()
{
  int v0; // eax

  LOBYTE(v0) = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    LOBYTE(v0) = grim_batch_active;
    if ( grim_batch_active )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)grim_vertex_buffer + 48))(grim_vertex_buffer);
      (*(void (__stdcall **)(int, int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)grim_d3d_device + 284))(
        grim_d3d_device,
        4,
        0,
        (unsigned __int16)grim_vertex_count,
        0,
        (unsigned __int16)grim_vertex_count >> 1);
      v0 = (*(int (__stdcall **)(int, _DWORD, _DWORD, int *, int))(*(_DWORD *)grim_vertex_buffer + 44))(
             grim_vertex_buffer,
             0,
             0,
             &grim_vertex_write_ptr,
             10240);
      if ( v0 >= 0 )
        LOWORD(grim_vertex_count) = 0;
    }
  }
  return v0;
}

// grim_submit_vertices_offset_color @ 0x10008430
// Grim2D vtable 0x130: translate + apply color
char __thiscall sub_10008430(void *this, const void *a2, int a3, float *a4, _DWORD *a5)
{
  char result; // al
  int v6; // edx
  int v7; // eax

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, a2, 4 * ((unsigned int)(28 * a3) >> 2));
    if ( a3 > 0 )
    {
      v6 = a3;
      do
      {
        v7 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *a4 + *(float *)grim_vertex_write_ptr;
        *(float *)(v7 + 4) = a4[1] + *(float *)(v7 + 4);
        *(_DWORD *)(grim_vertex_write_ptr + 16) = *a5;
        --v6;
        grim_vertex_write_ptr += 28;
      }
      while ( v6 );
    }
    LOWORD(grim_vertex_count) = a3 + grim_vertex_count;
    result = grim_vertex_capacity;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
  }
  return result;
}

// grim_submit_vertices_transform_color @ 0x100084E0
// Grim2D vtable 0x134: rotate + translate + apply color
int __thiscall sub_100084E0(void *this, const void *a2, int a3, float *a4, float *a5, _DWORD *a6)
{
  int result; // eax
  int v7; // esi
  float *v8; // eax
  double v9; // st7
  int v10; // eax

  result = (int)this;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, a2, 4 * ((unsigned int)(28 * a3) >> 2));
    if ( a3 > 0 )
    {
      v7 = a3;
      do
      {
        v8 = (float *)grim_vertex_write_ptr;
        v9 = *(float *)(grim_vertex_write_ptr + 4) * a5[1] + *(float *)grim_vertex_write_ptr * *a5;
        *(float *)(grim_vertex_write_ptr + 4) = *(float *)(grim_vertex_write_ptr + 4) * a5[3]
                                              + *(float *)grim_vertex_write_ptr * a5[2];
        *v8 = v9;
        v10 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *a4 + *(float *)grim_vertex_write_ptr;
        *(float *)(v10 + 4) = a4[1] + *(float *)(v10 + 4);
        *(_DWORD *)(grim_vertex_write_ptr + 16) = *a6;
        --v7;
        grim_vertex_write_ptr += 28;
      }
      while ( v7 );
      result = (int)this;
    }
    LOWORD(grim_vertex_count) = a3 + grim_vertex_count;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      return (*(int (__thiscall **)(int))(*(_DWORD *)result + 236))(result);
  }
  return result;
}

// grim_submit_vertices_transform @ 0x100085C0
// Grim2D vtable 0x128: copy verts, rotate, translate
char __thiscall sub_100085C0(void *this, const void *a2, int a3, float *a4, float *a5)
{
  char result; // al
  int v6; // esi
  float *v7; // eax
  double v8; // st7
  int v9; // eax

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, a2, 4 * ((unsigned int)(28 * a3) >> 2));
    if ( a3 > 0 )
    {
      v6 = a3;
      do
      {
        v7 = (float *)grim_vertex_write_ptr;
        v8 = *(float *)(grim_vertex_write_ptr + 4) * a5[1] + *a5 * *(float *)grim_vertex_write_ptr;
        *(float *)(grim_vertex_write_ptr + 4) = *(float *)(grim_vertex_write_ptr + 4) * a5[3]
                                              + *(float *)grim_vertex_write_ptr * a5[2];
        *v7 = v8;
        v9 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *a4 + *(float *)grim_vertex_write_ptr;
        *(float *)(v9 + 4) = a4[1] + *(float *)(v9 + 4);
        --v6;
        grim_vertex_write_ptr += 28;
      }
      while ( v6 );
    }
    LOWORD(grim_vertex_count) = a3 + grim_vertex_count;
    result = grim_vertex_capacity;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
  }
  return result;
}

// grim_submit_vertices_offset @ 0x10008680
// Grim2D vtable 0x12c: copy verts, translate
char __thiscall sub_10008680(void *this, const void *a2, int a3, float *a4)
{
  char result; // al
  int v5; // edx
  int v6; // eax

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, a2, 4 * ((unsigned int)(28 * a3) >> 2));
    if ( a3 > 0 )
    {
      v5 = a3;
      do
      {
        v6 = grim_vertex_write_ptr;
        *(float *)grim_vertex_write_ptr = *(float *)grim_vertex_write_ptr + *a4;
        *(float *)(v6 + 4) = a4[1] + *(float *)(v6 + 4);
        --v5;
        grim_vertex_write_ptr += 28;
      }
      while ( v5 );
    }
    LOWORD(grim_vertex_count) = a3 + grim_vertex_count;
    result = grim_vertex_capacity;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
  }
  return result;
}

// grim_draw_quad_xy @ 0x10008720
// Grim2D vtable 0x120: draw quad from xy pointer
int __thiscall sub_10008720(void *this, _DWORD *a2, int a3, int a4)
{
  return (*(int (__thiscall **)(void *, _DWORD, _DWORD, int, int))(*(_DWORD *)this + 284))(this, *a2, a2[1], a3, a4);
}

// grim_draw_quad_rotated_matrix @ 0x10008750
// Grim2D vtable 0x124 (provisional): quad with rotation matrix
char __thiscall sub_10008750(void *this, float a2, float a3, float a4, float a5)
{
  char result; // al
  double v7; // st7
  double v8; // st6
  double v9; // st6
  double v10; // st6
  double v11; // st6
  float v12; // [esp+4h] [ebp-28h]
  float v13; // [esp+8h] [ebp-24h]
  float v14; // [esp+Ch] [ebp-20h]
  float v15; // [esp+10h] [ebp-1Ch]
  float v16; // [esp+14h] [ebp-18h]
  float v17; // [esp+14h] [ebp-18h]
  float v18; // [esp+18h] [ebp-14h]
  float v19; // [esp+1Ch] [ebp-10h]
  float v20; // [esp+20h] [ebp-Ch]
  float v21; // [esp+24h] [ebp-8h]
  float v22; // [esp+28h] [ebp-4h]
  float v23; // [esp+30h] [ebp+4h]
  float v24; // [esp+30h] [ebp+4h]
  float v25; // [esp+34h] [ebp+8h]
  float v26; // [esp+34h] [ebp+8h]
  float v27; // [esp+34h] [ebp+8h]
  float v28; // [esp+38h] [ebp+Ch]

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = byte_1005C898;
    if ( byte_1005C898 )
    {
      if ( !grim_batch_active )
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
      if ( *(float *)&grim_rotation_radians == 0.0 )
      {
        v14 = a2;
        v15 = a3;
        v18 = a3;
        v16 = a2 + a4;
        v19 = v16;
        v21 = a2;
        v20 = a3 + a5;
        v22 = v20;
      }
      else
      {
        v7 = a4 * 0.5;
        v12 = v7 + a2;
        v8 = a5 * 0.5;
        v23 = v8;
        v13 = v8 + a3;
        v28 = a4 * -0.5;
        v9 = a5 * -0.5;
        v25 = *(float *)&dword_1005A464 * v9 + *(float *)&dword_1005A460 * v28;
        v14 = v25 + v12;
        v15 = v13 + v9 * *(float *)&dword_1005A46C + flt_1005A468 * v28;
        v17 = v7;
        v26 = *(float *)&dword_1005A464 * v9 + *(float *)&dword_1005A460 * v17;
        v10 = v9 * *(float *)&dword_1005A46C + flt_1005A468 * v17;
        v16 = v26 + v12;
        v18 = v13 + v10;
        v27 = *(float *)&dword_1005A464 * v23 + *(float *)&dword_1005A460 * v7;
        v19 = v27 + v12;
        v20 = v13 + *(float *)&dword_1005A46C * v23 + flt_1005A468 * v7;
        v11 = v23;
        v24 = *(float *)&dword_1005A464 * v23 + *(float *)&dword_1005A460 * v28;
        v21 = v24 + v12;
        v22 = v13 + *(float *)&dword_1005A46C * v11 + flt_1005A468 * v28;
      }
      *(float *)grim_vertex_write_ptr = v14;
      *(float *)(grim_vertex_write_ptr + 4) = v15;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v16;
      *(float *)(grim_vertex_write_ptr + 4) = v18;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v19;
      *(float *)(grim_vertex_write_ptr + 4) = v20;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v21;
      *(float *)(grim_vertex_write_ptr + 4) = v22;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
      LOWORD(grim_vertex_count) = grim_vertex_count + 4;
      grim_vertex_write_ptr += 28;
      result = grim_vertex_capacity;
      if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
        return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
    }
  }
  return result;
}

// grim_draw_quad @ 0x10008B10
// Grim2D vtable 0x11c (provisional)
char __thiscall sub_10008B10(void *this, float a2, float a3, float a4, float a5)
{
  char result; // al
  double v7; // st7
  double v8; // st7
  double v9; // st6
  double v10; // st6
  double v11; // st6
  float v12; // [esp+4h] [ebp-28h]
  float v13; // [esp+8h] [ebp-24h]
  float v14; // [esp+Ch] [ebp-20h]
  float v15; // [esp+10h] [ebp-1Ch]
  float v16; // [esp+14h] [ebp-18h]
  float v17; // [esp+18h] [ebp-14h]
  float v18; // [esp+1Ch] [ebp-10h]
  float v19; // [esp+20h] [ebp-Ch]
  float v20; // [esp+28h] [ebp-4h]
  int v21; // [esp+30h] [ebp+4h]
  float v22; // [esp+30h] [ebp+4h]

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = byte_1005C898;
    if ( byte_1005C898 )
    {
      if ( !grim_batch_active )
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
      if ( *(float *)&grim_rotation_radians == 0.0 )
      {
        v12 = a2;
        v13 = a3;
        v15 = a3;
        v14 = a2 + a4;
        v16 = v14;
        v7 = a3 + a5;
        v18 = a2;
        v17 = v7;
      }
      else
      {
        v8 = a4 * 0.5 + a2;
        v20 = a5 * 0.5 + a3;
        v9 = a4 * a4 + a5 * a5;
        *(float *)&v21 = v9;
        v10 = v9
            * ((1.5 - v9 * 0.5 * COERCE_FLOAT(1597463007 - (v21 >> 1)) * COERCE_FLOAT(1597463007 - (v21 >> 1)))
             * COERCE_FLOAT(1597463007 - (v21 >> 1)))
            * 0.5;
        v22 = grim_rotation_cos * v10;
        v11 = v10 * *(float *)&DstBuf[260];
        v12 = v8 - v22;
        v13 = v20 - v11;
        v14 = v8 + v11;
        v15 = v20 - v22;
        v16 = v8 + v22;
        v17 = v20 + v11;
        v18 = v8 - v11;
        v7 = v20 + v22;
      }
      *(float *)grim_vertex_write_ptr = v12;
      v19 = v7;
      *(float *)(grim_vertex_write_ptr + 4) = v13;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v14;
      *(float *)(grim_vertex_write_ptr + 4) = v15;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v16;
      *(float *)(grim_vertex_write_ptr + 4) = v17;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
      grim_vertex_write_ptr += 28;
      *(float *)grim_vertex_write_ptr = v18;
      *(float *)(grim_vertex_write_ptr + 4) = v19;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
      LOWORD(grim_vertex_count) = grim_vertex_count + 4;
      grim_vertex_write_ptr += 28;
      result = grim_vertex_capacity;
      if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
        return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
    }
  }
  return result;
}

// grim_submit_vertex_raw @ 0x10008E30
// Grim2D vtable 0xf4: push 1 raw vertex (7 floats)
char __thiscall sub_10008E30(void *this, const void *a2)
{
  char result; // al

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = byte_1005C898;
    if ( byte_1005C898 )
    {
      if ( !grim_batch_active )
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
      qmemcpy((void *)grim_vertex_write_ptr, a2, 0x1Cu);
      result = grim_vertex_capacity;
      LOWORD(grim_vertex_count) = grim_vertex_count + 1;
      grim_vertex_write_ptr += 28;
      if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
        return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
    }
  }
  return result;
}

// grim_submit_quad_raw @ 0x10008EB0
// Grim2D vtable 0xf8: push 4 raw vertices (28 floats)
int __thiscall sub_10008EB0(void *this, const void *a2)
{
  int result; // eax

  result = (int)this;
  if ( !grim_render_disabled )
  {
    qmemcpy((void *)grim_vertex_write_ptr, a2, 0x70u);
    LOWORD(grim_vertex_count) = grim_vertex_count + 4;
    grim_vertex_write_ptr += 112;
    if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
      return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
  }
  return result;
}

// grim_draw_rect_outline @ 0x10008F10
// Grim2D vtable 0xd4: UI panel outline/frame (4 edge quads)
int __thiscall sub_10008F10(void *this, float *a2, int a3, float a4)
{
  float v6; // [esp+60h] [ebp-1Ch]
  float v7; // [esp+64h] [ebp-18h]
  float v8; // [esp+68h] [ebp-14h]

  (*(void (__stdcall **)(int, _DWORD, _DWORD))(*(_DWORD *)grim_d3d_device + 244))(grim_d3d_device, 0, 0);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 3);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 3);
  (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 252))(this, 0);
  (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
  if ( a4 == 1.0 )
  {
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, int))(*(_DWORD *)this + 284))(
      this,
      *(_DWORD *)a2,
      *((_DWORD *)a2 + 1),
      a3,
      1065353216);
  }
  else if ( *(float *)&a3 == 1.0 )
  {
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)this + 284))(
      this,
      *(_DWORD *)a2,
      *((_DWORD *)a2 + 1),
      1065353216,
      LODWORD(a4));
  }
  else
  {
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, int))(*(_DWORD *)this + 284))(
      this,
      *(_DWORD *)a2,
      *((_DWORD *)a2 + 1),
      a3,
      1065353216);
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)this + 284))(
      this,
      *(_DWORD *)a2,
      *((_DWORD *)a2 + 1),
      1065353216,
      LODWORD(a4));
    v8 = *(float *)&a3 + 1.0;
    v7 = a4 + a2[1];
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)this + 284))(
      this,
      *(_DWORD *)a2,
      LODWORD(v7),
      LODWORD(v8),
      1065353216);
    v6 = *(float *)&a3 + *a2;
    (*(void (__thiscall **)(void *, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)this + 284))(
      this,
      LODWORD(v6),
      *((_DWORD *)a2 + 1),
      1065353216,
      LODWORD(a4));
  }
  (*(void (__thiscall **)(void *))(*(_DWORD *)this + 240))(this);
  (*(void (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 1, 4);
  return (*(int (__stdcall **)(int, _DWORD, int, int))(*(_DWORD *)grim_d3d_device + 252))(grim_d3d_device, 0, 4, 4);
}

// grim_draw_quad_points @ 0x10009080
// Grim2D vtable 0x138 (provisional): push quad using 4 points
char __thiscall sub_10009080(void *this, int a2, int a3, int a4, int a5, int a6, int a7, int a8, int a9)
{
  char result; // al

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    result = byte_1005C898;
    if ( byte_1005C898 )
    {
      if ( !grim_batch_active )
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
      *(_DWORD *)grim_vertex_write_ptr = a2;
      *(_DWORD *)(grim_vertex_write_ptr + 4) = a3;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u0[0];
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v0[0];
      grim_vertex_write_ptr += 28;
      *(_DWORD *)grim_vertex_write_ptr = a4;
      *(_DWORD *)(grim_vertex_write_ptr + 4) = a5;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC08;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = grim_uv_u1;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = grim_uv_v1;
      grim_vertex_write_ptr += 28;
      *(_DWORD *)grim_vertex_write_ptr = a6;
      *(_DWORD *)(grim_vertex_write_ptr + 4) = a7;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = dword_1005BC0C;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A0;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2A4;
      grim_vertex_write_ptr += 28;
      *(_DWORD *)grim_vertex_write_ptr = a8;
      *(_DWORD *)(grim_vertex_write_ptr + 4) = a9;
      *(_DWORD *)(grim_vertex_write_ptr + 8) = dword_1005B288;
      *(_DWORD *)(grim_vertex_write_ptr + 12) = dword_1005B28C;
      *(_DWORD *)(grim_vertex_write_ptr + 16) = grim_color_slot3;
      *(_DWORD *)(grim_vertex_write_ptr + 20) = dword_1005B2A8;
      *(_DWORD *)(grim_vertex_write_ptr + 24) = dword_1005B2AC;
      LOWORD(grim_vertex_count) = grim_vertex_count + 4;
      result = grim_vertex_count;
      grim_vertex_write_ptr += 28;
      if ( (unsigned __int16)grim_vertex_count >= (unsigned int)grim_vertex_capacity )
        return (*(int (__thiscall **)(void *))(*(_DWORD *)this + 236))(this);
    }
  }
  return result;
}

// grim_draw_text_mono @ 0x100092B0
// Grim2D vtable 0x13c: fixed 16px mono text
char __userpurge sub_100092B0@<al>(int *a1@<ecx>, float a2@<ebp>, float a3@<edi>, float a4, int a5, const char *a6)
{
  char result; // al
  const char *v8; // ebx
  float v9; // ebp
  signed int v10; // eax
  unsigned int v11; // kr04_4
  char v12; // al
  int v13; // eax
  double v14; // st7
  float v17; // [esp+34h] [ebp-64h]
  float v18; // [esp+38h] [ebp-60h]
  float v19; // [esp+3Ch] [ebp-5Ch]
  float v20; // [esp+40h] [ebp-58h]
  signed int v21; // [esp+44h] [ebp-54h]
  int v22; // [esp+58h] [ebp-40h]
  float v24; // [esp+60h] [ebp-38h]
  float v25; // [esp+64h] [ebp-34h]
  float v26; // [esp+68h] [ebp-30h]
  float v27; // [esp+6Ch] [ebp-2Ch]
  float v28; // [esp+70h] [ebp-28h]
  float v29; // [esp+74h] [ebp-24h]
  float v30; // [esp+78h] [ebp-20h]
  float v31; // [esp+7Ch] [ebp-1Ch]
  float v32; // [esp+80h] [ebp-18h]
  float v33; // [esp+84h] [ebp-14h]
  float v34; // [esp+88h] [ebp-10h]
  float v35; // [esp+8Ch] [ebp-Ch]
  float v36; // [esp+90h] [ebp-8h]
  float v37; // [esp+94h] [ebp-4h]
  float retaddr; // [esp+98h] [ebp+0h]
  char v39; // [esp+A0h] [ebp+8h]

  result = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    v8 = a6;
    if ( a6 )
    {
      if ( !(_BYTE)grim_font_texture_bound )
        (*(void (__stdcall **)(int, _DWORD, int))(*(_DWORD *)grim_d3d_device + 244))(
          grim_d3d_device,
          0,
          grim_font_texture);
      v20 = *(float *)&dword_1005CD08;
      v9 = a4;
      *(float *)&v22 = a4;
      (*(void (__thiscall **)(int *, _DWORD))(*a1 + 252))(a1, 0);
      (*(void (__thiscall **)(int *))(*a1 + 232))(a1);
      v10 = 0;
      v11 = strlen(a6) + 1;
      v39 = 0;
      v21 = 0;
      if ( (int)(v11 - 1) > 0 )
      {
        while ( 1 )
        {
          v12 = v8[v10];
          if ( v12 == 10 )
          {
            *(float *)&v22 = a4;
            v9 = a4;
            *(float *)&a5 = v20 * 28.0 + *(float *)&a5;
            goto LABEL_24;
          }
          if ( v12 == -89 )
          {
            v39 = 1;
            goto LABEL_24;
          }
          if ( v12 == -27 )
            break;
          if ( v12 == -28 )
          {
            v28 = *(float *)&dword_1005B5D0 + 0.0625;
            v29 = *(float *)&dword_1005B5D4 + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*a1 + 256))(
              a1,
              dword_1005B5D0,
              dword_1005B5D4,
              LODWORD(v28),
              LODWORD(v29),
              COERCE_FLOAT(LODWORD(a3)),
              COERCE_FLOAT(LODWORD(a2)),
              COERCE_FLOAT(LODWORD(v17)),
              COERCE_FLOAT(LODWORD(v18)));
            v9 = v26;
            (*(void (__thiscall **)(int *))(*a1 + 284))(a1);
            v22 = dword_1005B3D8;
            a5 = dword_1005B3DC;
            v34 = *(float *)&dword_1005B3D8 + 0.0625;
            v35 = *(float *)&dword_1005B3DC + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD))(*a1 + 256))(
              a1,
              dword_1005B3D8,
              dword_1005B3DC,
              LODWORD(v34),
              LODWORD(v35));
            v13 = *a1;
            v18 = v20 * 32.0;
            v17 = v18;
            a2 = v27;
          }
          else
          {
            if ( v12 != -10 )
            {
              if ( v39 )
              {
                v39 = 0;
              }
              else
              {
                v19 = v20 * 16.0;
                *(float *)&v22 = *(float *)&v22 + v19;
                v9 = *(float *)&v22;
              }
              v36 = *(float *)&grim_font2_uv_u[2 * v12] + 0.0625;
              v37 = grim_font2_uv_v[2 * v12] + 0.0625;
              (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*a1 + 256))(
                a1,
                grim_font2_uv_u[2 * v12],
                LODWORD(grim_font2_uv_v[2 * v12]),
                LODWORD(v36),
                LODWORD(v37),
                COERCE_FLOAT(LODWORD(a3)),
                COERCE_FLOAT(LODWORD(a2)),
                COERCE_FLOAT(LODWORD(v17)),
                COERCE_FLOAT(LODWORD(v18)));
              v13 = *a1;
              v18 = v20 * 32.0;
              v14 = v27 + 1.0;
              v17 = v18;
              goto LABEL_22;
            }
            v32 = *(float *)&dword_1005B640 + 0.0625;
            v33 = *(float *)&dword_1005B644 + 0.0625;
            (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*a1 + 256))(
              a1,
              dword_1005B640,
              dword_1005B644,
              LODWORD(v32),
              LODWORD(v33),
              COERCE_FLOAT(LODWORD(a3)),
              COERCE_FLOAT(LODWORD(a2)),
              COERCE_FLOAT(LODWORD(v17)),
              COERCE_FLOAT(LODWORD(v18)));
            v9 = v26;
            (*(void (__thiscall **)(int *))(*a1 + 284))(a1);
            v22 = dword_1005B3D8;
            a5 = dword_1005B3DC;
            retaddr = *(float *)&dword_1005B3D8 + 0.0625;
            a4 = *(float *)&dword_1005B3DC + 0.0625;
            (*(void (__thiscall **)(int *, int, int, float, float))(*a1 + 256))(
              a1,
              dword_1005B3D8,
              dword_1005B3DC,
              COERCE_FLOAT(LODWORD(retaddr)),
              COERCE_FLOAT(LODWORD(a4)));
            v13 = *a1;
            v18 = v20 * 32.0;
            v17 = v18;
            a2 = v27;
          }
LABEL_23:
          a3 = v9;
          (*(void (__thiscall **)(int *))(v13 + 284))(a1);
LABEL_24:
          v10 = ++v21;
          if ( v21 >= (int)(v11 - 1) )
            return (*(int (__thiscall **)(int *))(*a1 + 240))(a1);
          v8 = a6;
        }
        v24 = *(float *)&dword_1005B5D0 + 0.0625;
        v25 = *(float *)&dword_1005B5D4 + 0.0625;
        (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD, float, float, float, float))(*a1 + 256))(
          a1,
          dword_1005B5D0,
          dword_1005B5D4,
          LODWORD(v24),
          LODWORD(v25),
          COERCE_FLOAT(LODWORD(a3)),
          COERCE_FLOAT(LODWORD(a2)),
          COERCE_FLOAT(LODWORD(v17)),
          COERCE_FLOAT(LODWORD(v18)));
        v9 = v26;
        (*(void (__thiscall **)(int *))(*a1 + 284))(a1);
        v22 = dword_1005B438;
        a5 = dword_1005B43C;
        v30 = *(float *)&dword_1005B438 + 0.0625;
        v31 = *(float *)&dword_1005B43C + 0.0625;
        (*(void (__thiscall **)(int *, int, int, _DWORD, _DWORD))(*a1 + 256))(
          a1,
          dword_1005B438,
          dword_1005B43C,
          LODWORD(v30),
          LODWORD(v31));
        v13 = *a1;
        v18 = v20 * 32.0;
        v14 = v27 - 6.0;
        v17 = v18;
LABEL_22:
        a2 = v14;
        goto LABEL_23;
      }
      return (*(int (__thiscall **)(int *))(*a1 + 240))(a1);
    }
  }
  return result;
}

// grim_measure_text_width @ 0x100096C0
// Grim2D vtable 0x14c: small font width metric (handles newlines)
int __stdcall sub_100096C0(const char *a1)
{
  int result; // eax
  int v2; // esi
  unsigned int v3; // kr04_4
  signed int v4; // edi

  if ( !a1 )
    return 0;
  result = 0;
  v2 = 0;
  v3 = strlen(a1) + 1;
  v4 = 0;
  if ( (int)(v3 - 1) > 0 )
  {
    do
    {
      if ( a1[v4] == 10 )
      {
        if ( v2 > result )
          result = v2;
        v2 = 0;
      }
      else
      {
        v2 += (unsigned __int8)grim_font2_glyph_widths[(unsigned __int8)grim_font2_char_map[(unsigned __int8)a1[v4]]];
      }
      ++v4;
    }
    while ( v4 < (int)(v3 - 1) );
    if ( v2 > result )
      return v2;
  }
  return result;
}

// grim_draw_text_small @ 0x10009730
// Grim2D vtable 0x144: small font draw (GRIM_Font2)
char __thiscall sub_10009730(void *this, float a2, float a3, const char *a4)
{
  int v4; // eax
  unsigned int v7; // kr04_4
  signed int i; // edi
  int v9; // eax
  int v11; // [esp+28h] [ebp-3Ch]
  int v12; // [esp+2Ch] [ebp-38h]
  int v13; // [esp+30h] [ebp-34h]
  float v14; // [esp+44h] [ebp-20h]
  float v15; // [esp+48h] [ebp-1Ch]
  float v16; // [esp+4Ch] [ebp-18h]
  float v17; // [esp+50h] [ebp-14h]
  float v18; // [esp+54h] [ebp-10h]
  float v19; // [esp+58h] [ebp-Ch]
  float v20; // [esp+60h] [ebp-4h]
  float v21; // [esp+68h] [ebp+4h]
  float v22; // [esp+6Ch] [ebp+8h]
  float v23; // [esp+6Ch] [ebp+8h]
  int v24; // [esp+70h] [ebp+Ch]

  LOBYTE(v4) = grim_render_disabled;
  if ( !grim_render_disabled )
  {
    if ( a4 )
    {
      v21 = (float)(__int64)a2;
      v4 = grim_font2_texture_handle;
      v22 = (float)(__int64)a3;
      if ( grim_font2_texture_handle != -1
        || (v4 = (*(int (__thiscall **)(void *, char *))(*(_DWORD *)this + 192))(this, aGrimFont2),
            grim_font2_texture_handle = v4,
            v4 != -1) )
      {
        (*(void (__thiscall **)(void *, int, _DWORD))(*(_DWORD *)this + 196))(this, v4, 0);
        v15 = v22;
        v14 = v21;
        v24 = dword_1005CCD8;
        if ( dword_1005CCD8 != 1 )
          (*(void (__thiscall **)(void *, int, int))(*(_DWORD *)this + 32))(this, 21, 1);
        (*(void (__thiscall **)(void *, _DWORD))(*(_DWORD *)this + 252))(this, 0);
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 232))(this);
        v7 = strlen(a4) + 1;
        for ( i = 0; i < (int)(v7 - 1); ++i )
        {
          v9 = (unsigned __int8)grim_font2_char_map[(unsigned __int8)a4[i]];
          if ( a4[i] == 10 )
          {
            v14 = v21;
            v15 = v15 + 16.0;
          }
          else
          {
            v23 = (float)(unsigned __int8)grim_font2_glyph_widths[v9];
            v16 = *(float *)&grim_font2_uv_u[2 * v9] + 0.001953125;
            v17 = grim_font2_uv_v[2 * v9] + 0.001953125;
            v20 = v17 + 0.0625;
            v18 = v23 * 0.00390625 + v16 - 0.001953125;
            v19 = v20 - 0.001953125;
            (*(void (__thiscall **)(void *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)this + 256))(
              this,
              LODWORD(v16),
              LODWORD(v17),
              LODWORD(v18),
              LODWORD(v19));
            (*(void (__thiscall **)(void *, float, float, _DWORD, int))(*(_DWORD *)this + 284))(
              this,
              COERCE_FLOAT(LODWORD(v14)),
              COERCE_FLOAT(LODWORD(v15)),
              LODWORD(v23),
              1098907648);
            v14 = v23 + v14;
          }
        }
        (*(void (__thiscall **)(void *))(*(_DWORD *)this + 240))(this);
        LOBYTE(v4) = (*(int (__thiscall **)(void *, int, int, int, int, int))(*(_DWORD *)this + 32))(
                       this,
                       21,
                       v24,
                       v11,
                       v12,
                       v13);
      }
    }
  }
  return v4;
}

// grim_draw_text_mono_fmt @ 0x10009940
// Grim2D vtable 0x140: printf-style wrapper around draw_text_mono
int sub_10009940(int a1, int a2, int a3, char *Format, ...)
{
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  vsprintf(grim_printf_buffer, Format, va);
  return (*(int (__thiscall **)(int, int, int, char *))(*(_DWORD *)a1 + 316))(a1, a2, a3, grim_printf_buffer);
}

// grim_draw_text_small_fmt @ 0x10009980
// Grim2D vtable 0x148: formatted small-font text (vsprintf + vtable 0x144)
int sub_10009980(int a1, int a2, int a3, char *Format, ...)
{
  va_list va; // [esp+14h] [ebp+14h] BYREF

  va_start(va, Format);
  vsprintf(grim_printf_buffer_alt, Format, va);
  return (*(int (__thiscall **)(int, int, int, char *))(*(_DWORD *)a1 + 324))(a1, a2, a3, grim_printf_buffer_alt);
}

// GRIM__GetInterface @ 0x100099C0
_DWORD *GRIM__GetInterface()
{
  int v0; // eax
  _DWORD *result; // eax

  v0 = Direct3DCreate8(220);
  grim_d3d8_probe = v0;
  if ( v0 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v0 + 8))(v0);
    sub_100052F0();
    result = operator new(4u);
    if ( result )
    {
      *result = &grim_interface_vtable;
      grim_interface_instance = (int)result;
    }
    else
    {
      grim_interface_instance = 0;
      return 0;
    }
  }
  else
  {
    grim_error_text = (int)Text;
    MessageBoxA(0, Text, Caption, 0);
    return 0;
  }
  return result;
}

// FUN_10009a20 @ 0x10009A20
// [binja] int32_t __stdcall sub_10009a20(HINSTANCE arg1, int32_t arg2)
BOOL __stdcall DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
  if ( fdwReason == 1 )
  {
    grim_module_handle = hinstDLL;
    lParam = (LPARAM)LoadIconA(hinstDLL, (LPCSTR)0x72);
  }
  return 1;
}

// sub_10009A50 @ 0x10009A50
int __cdecl sub_10009A50(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax

  a1[1] = 0;
  if ( a2 != 61 )
  {
    *(_DWORD *)(*a1 + 20) = 10;
    *(_DWORD *)(*a1 + 24) = 61;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 424 )
  {
    *(_DWORD *)(*a1 + 20) = 19;
    *(_DWORD *)(*a1 + 24) = 424;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  memset(a1, 0, 0x1A8u);
  *a1 = v3;
  *((_BYTE *)a1 + 12) = 1;
  FUN_1003d0d0(a1);
  a1[2] = 0;
  a1[5] = 0;
  a1[36] = 0;
  v4 = 4;
  a1[37] = 0;
  a1[38] = 0;
  a1[39] = 0;
  v5 = a1 + 44;
  do
  {
    *(v5 - 4) = 0;
    *v5++ = 0;
    --v4;
  }
  while ( v4 );
  sub_1003B770(a1);
  result = sub_1003ACD0(a1);
  a1[4] = 200;
  return result;
}

// sub_10009B20 @ 0x10009B20
int __cdecl sub_10009B20(int a1)
{
  return sub_1003DD30(a1);
}

// sub_10009B30 @ 0x10009B30
int __cdecl sub_10009B30(_DWORD *a1, char a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[4];
  if ( v2 != 200 && v2 != 201 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*a1 + 24) = a1[4];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_10009BA0(a1);
  if ( result == 1 )
    return 1;
  if ( result == 2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(*a1 + 20) = 50;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_1003DD00(a1);
    return 2;
  }
  return result;
}

// sub_10009BA0 @ 0x10009BA0
int __cdecl sub_10009BA0(_DWORD *a1)
{
  int v1; // edi
  int result; // eax

  v1 = 0;
  switch ( a1[4] )
  {
    case 0xC8:
      (*(void (__cdecl **)(_DWORD *))(a1[99] + 4))(a1);
      (*(void (__cdecl **)(_DWORD *))(a1[5] + 8))(a1);
      a1[4] = 201;
      goto LABEL_3;
    case 0xC9:
LABEL_3:
      v1 = (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
      if ( v1 != 1 )
        goto LABEL_8;
      sub_10009C60(a1);
      a1[4] = 202;
      result = 1;
      break;
    case 0xCA:
      return 1;
    case 0xCB:
    case 0xCC:
    case 0xCD:
    case 0xCE:
    case 0xCF:
    case 0xD0:
    case 0xD2:
      return (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
    default:
      *(_DWORD *)(*a1 + 20) = 18;
      *(_DWORD *)(*a1 + 24) = a1[4];
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
LABEL_8:
      result = v1;
      break;
  }
  return result;
}

// sub_10009C60 @ 0x10009C60
int __cdecl sub_10009C60(int a1)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax

  switch ( *(_DWORD *)(a1 + 32) )
  {
    case 1:
      *(_DWORD *)(a1 + 36) = 1;
      *(_DWORD *)(a1 + 40) = 1;
      break;
    case 3:
      if ( !*(_BYTE *)(a1 + 256) )
      {
        if ( *(_BYTE *)(a1 + 262) )
        {
          if ( *(_BYTE *)(a1 + 263) )
          {
            if ( *(_BYTE *)(a1 + 263) != 1 )
            {
              *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
              *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
              (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
            }
            goto LABEL_25;
          }
LABEL_23:
          *(_DWORD *)(a1 + 36) = 2;
          *(_DWORD *)(a1 + 40) = 2;
          break;
        }
        v1 = *(int **)(a1 + 196);
        v2 = *v1;
        v3 = v1[21];
        v4 = v1[42];
        if ( *v1 == 1 )
        {
          if ( v3 == 2 && v4 == 3 )
          {
            *(_DWORD *)(a1 + 36) = 3;
            *(_DWORD *)(a1 + 40) = 2;
            break;
          }
        }
        else if ( v2 == 82 && v3 == 71 && v4 == 66 )
        {
          goto LABEL_23;
        }
        v5 = *(_DWORD **)a1;
        v5[6] = v2;
        v5 += 6;
        v5[1] = v3;
        v5[2] = v4;
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 107;
        (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
      }
LABEL_25:
      *(_DWORD *)(a1 + 36) = 3;
      *(_DWORD *)(a1 + 40) = 2;
      break;
    case 4:
      if ( *(_BYTE *)(a1 + 262) && *(_BYTE *)(a1 + 263) )
      {
        if ( *(_BYTE *)(a1 + 263) != 2 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 36) = 5;
        *(_DWORD *)(a1 + 40) = 4;
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 4;
        *(_DWORD *)(a1 + 40) = 4;
      }
      break;
    default:
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 40) = 0;
      break;
  }
  *(_DWORD *)(a1 + 56) = 0;
  *(_DWORD *)(a1 + 44) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_DWORD *)(a1 + 60) = 1072693248;
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 73) = 1;
  *(_BYTE *)(a1 + 74) = 0;
  *(_DWORD *)(a1 + 76) = 2;
  *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 256;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 89) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  return 1;
}

// sub_10009E00 @ 0x10009E00
char __cdecl sub_10009E00(int a1)
{
  int v1; // eax
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( (v1 == 205 || v1 == 206) && !*(_BYTE *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 120) < *(_DWORD *)(a1 + 96) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 66;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 == 207 )
  {
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 != 210 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 396);
  if ( *(_BYTE *)(v2 + 17) )
  {
LABEL_14:
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 20) + 24))(a1);
    sub_1003DD00(a1);
    return 1;
  }
  else
  {
    while ( (*(int (__cdecl **)(int))v2)(a1) )
    {
      v2 = *(_DWORD *)(a1 + 396);
      if ( *(_BYTE *)(v2 + 17) )
        goto LABEL_14;
    }
    return 0;
  }
}

// sub_10009EC0 @ 0x10009EC0
char __cdecl sub_10009EC0(int a1)
{
  int v2; // eax
  void (__cdecl **v3)(int); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx

  if ( *(_DWORD *)(a1 + 16) == 202 )
  {
    sub_1003E040(a1);
    if ( *(_BYTE *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 16) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 16) = 203;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 == 203 )
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) )
    {
      while ( 1 )
      {
        v3 = *(void (__cdecl ***)(int))(a1 + 8);
        if ( v3 )
          (*v3)(a1);
        v4 = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
        if ( !v4 )
          return 0;
        if ( v4 == 2 )
          goto LABEL_17;
        v5 = *(_DWORD *)(a1 + 8);
        if ( v5 && (v4 == 3 || v4 == 1) )
        {
          ++*(_DWORD *)(v5 + 4);
          v6 = *(_DWORD *)(a1 + 8);
          v7 = *(_DWORD *)(v6 + 8);
          if ( *(_DWORD *)(v6 + 4) >= v7 )
            *(_DWORD *)(v6 + 8) = v7 + *(_DWORD *)(a1 + 280);
        }
      }
    }
    else
    {
LABEL_17:
      *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 124);
      return sub_10009FA0(a1);
    }
  }
  else
  {
    if ( v2 != 204 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    return sub_10009FA0(a1);
  }
}

// sub_10009FA0 @ 0x10009FA0
char __cdecl sub_10009FA0(int a1)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // ebx
  int v5; // edx

  if ( *(_DWORD *)(a1 + 16) != 204 )
  {
    (**(void (__cdecl ***)(int))(a1 + 380))(a1);
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 16) = 204;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
  {
    v1 = (unsigned int *)(a1 + 120);
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 < *(_DWORD *)(a1 + 96) )
        break;
LABEL_10:
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
      (**(void (__cdecl ***)(int))(a1 + 380))(a1);
      v5 = *(_DWORD *)(a1 + 380);
      *v1 = 0;
      if ( !*(_BYTE *)(v5 + 8) )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = v2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 96);
        (**(void (__cdecl ***)(int))(a1 + 8))(a1);
      }
      v4 = *v1;
      (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(*(_DWORD *)(a1 + 384) + 4))(a1, 0, a1 + 120, 0);
      v2 = *v1;
      if ( *v1 == v4 )
        return 0;
      if ( v2 >= *(_DWORD *)(a1 + 96) )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_11:
    *(_DWORD *)(a1 + 16) = (*(_BYTE *)(a1 + 65) != 0) + 205;
    return 1;
  }
}

// sub_1000A070 @ 0x1000A070
_DWORD *__cdecl sub_1000A070(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // eax
  int v7; // eax
  _DWORD *v8; // [esp-4h] [ebp-8h]

  v3 = a1;
  if ( a1[4] != 205 )
  {
    v8 = a1;
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*v3 + 24) = v3[4];
    (*(void (__cdecl **)(_DWORD *))*v3)(v8);
  }
  v4 = v3[30];
  if ( v4 < v3[24] )
  {
    v6 = v3[2];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = v4;
      *(_DWORD *)(v3[2] + 8) = v3[24];
      (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
    }
    v7 = v3[96];
    a1 = 0;
    (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, a3);
    result = a1;
    v3[30] += a1;
  }
  else
  {
    *(_DWORD *)(*v3 + 20) = 119;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
    return 0;
  }
  return result;
}

// sub_1000A110 @ 0x1000A110
int __stdcall sub_1000A110(int a1, int a2)
{
  if ( (*(int (__stdcall **)(_DWORD, int, char *, _DWORD))(**(_DWORD **)&String[280] + 12))(
         *(_DWORD *)&String[280],
         a1 + 4,
         &String[284],
         0) < 0 )
    return 1;
  String[288] = 1;
  return 0;
}

// sub_1000A150 @ 0x1000A150
BOOL __stdcall sub_1000A150(int a1, int a2)
{
  BOOL result; // eax
  _DWORD v3[6]; // [esp+0h] [ebp-18h] BYREF

  result = 1;
  if ( (*(_DWORD *)(a1 + 24) & 3) != 0 )
  {
    v3[2] = *(_DWORD *)(a1 + 24);
    v3[0] = 24;
    v3[1] = 16;
    v3[3] = 2;
    v3[4] = -1000;
    v3[5] = 1000;
    if ( (*(int (__stdcall **)(_DWORD, int, _DWORD *))(**(_DWORD **)&String[284] + 24))(*(_DWORD *)&String[284], 4, v3) < 0 )
      return 0;
  }
  return result;
}

// grim_joystick_init @ 0x1000A1C0
// initializes DirectInput joystick device and acquires it
char __cdecl sub_1000A1C0(int a1)
{
  int v1; // eax
  HMODULE ModuleHandleA; // eax

  if ( !a1 && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = *(_DWORD *)&String[280];
  if ( !*(_DWORD *)&String[280] )
  {
    ModuleHandleA = GetModuleHandleA(0);
    if ( DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&String[280], 0) < 0 )
    {
      *(_DWORD *)&String[280] = 0;
      return 0;
    }
    v1 = *(_DWORD *)&String[280];
  }
  if ( !*(_DWORD *)&String[284] )
  {
    if ( (*(int (__stdcall **)(int, int, int (__stdcall *)(int, int), _DWORD, int))(*(_DWORD *)v1 + 16))(
           v1,
           4,
           sub_1000A110,
           0,
           1) < 0 )
      return 0;
    if ( !String[288] )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, void *))(**(_DWORD **)&String[284] + 44))(*(_DWORD *)&String[284], &unk_1004FE74) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)&String[284] + 52))(*(_DWORD *)&String[284], a1, 5) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, BOOL (__stdcall *)(int, int), int, _DWORD))(**(_DWORD **)&String[284] + 16))(
           *(_DWORD *)&String[284],
           sub_1000A150,
           a1,
           0) < 0 )
      return 0;
    if ( *(_DWORD *)&String[284] )
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 28))(*(_DWORD *)&String[284]);
  }
  grim_joystick_poll();
  return 1;
}

// grim_joystick_poll @ 0x1000A2B0
// polls the joystick device and updates cached state
bool sub_1000A2B0()
{
  bool v0; // sf
  int v1; // edx

  if ( !*(_DWORD *)&String[280] || !*(_DWORD *)&String[284] )
    return 0;
  v0 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 100))(*(_DWORD *)&String[284]) < 0;
  v1 = **(_DWORD **)&String[284];
  if ( v0 )
  {
    if ( (*(int (__stdcall **)(_DWORD))(v1 + 28))(*(_DWORD *)&String[284]) == -2147024866 )
    {
      while ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 28))(*(_DWORD *)&String[284]) == -2147024866 )
        ;
    }
    return 0;
  }
  return (*(int (__stdcall **)(_DWORD, int, char *))(v1 + 36))(*(_DWORD *)&String[284], 272, &String[8]) >= 0;
}

// sub_1000A310 @ 0x1000A310
char __cdecl sub_1000A310(unsigned __int8 a1)
{
  return (unsigned __int8)String[a1 + 56] >> 7;
}

// sub_1000A330 @ 0x1000A330
int sub_1000A330()
{
  int result; // eax

  if ( *(_DWORD *)&String[284] )
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 32))(*(_DWORD *)&String[284]);
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[284] + 8))(*(_DWORD *)&String[284]);
    *(_DWORD *)&String[284] = 0;
  }
  result = *(_DWORD *)&String[280];
  if ( *(_DWORD *)&String[280] )
  {
    result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[280] + 8))(*(_DWORD *)&String[280]);
    *(_DWORD *)&String[280] = 0;
  }
  return result;
}

// grim_keyboard_key_down @ 0x1000A370
// reads the cached key state array
char __cdecl sub_1000A370(unsigned __int8 a1)
{
  return (unsigned __int8)String[a1 + 512] >> 7;
}

// grim_keyboard_init @ 0x1000A390
// initializes DirectInput keyboard device and acquires it
char __cdecl sub_1000A390(int a1)
{
  int v1; // eax
  HMODULE ModuleHandleA; // eax
  _DWORD v4[5]; // [esp+24h] [ebp-14h] BYREF

  if ( !a1 && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = *(_DWORD *)&String[504];
  if ( !*(_DWORD *)&String[504] )
  {
    ModuleHandleA = GetModuleHandleA(0);
    if ( DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&String[504], 0) < 0 )
    {
      *(_DWORD *)&String[504] = 0;
      return 0;
    }
    v1 = *(_DWORD *)&String[504];
  }
  if ( !*(_DWORD *)&String[508] )
  {
    if ( (*(int (__stdcall **)(int, void *, char *, _DWORD))(*(_DWORD *)v1 + 12))(v1, &unk_1005029C, &String[508], 0) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, void *))(**(_DWORD **)&String[508] + 44))(*(_DWORD *)&String[508], &unk_1005007C) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, int, int))(**(_DWORD **)&String[508] + 52))(*(_DWORD *)&String[508], a1, 22) < 0 )
      return 0;
    v4[0] = 20;
    v4[1] = 16;
    v4[2] = 0;
    v4[3] = 0;
    v4[4] = 10;
    (*(void (__stdcall **)(_DWORD, int, _DWORD *))(**(_DWORD **)&String[508] + 24))(*(_DWORD *)&String[508], 1, v4);
    if ( *(_DWORD *)&String[508] )
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 28))(*(_DWORD *)&String[508]);
  }
  grim_keyboard_poll();
  return 1;
}

// grim_keyboard_poll @ 0x1000A4A0
// polls the keyboard device and updates cached key state
char __fastcall sub_1000A4A0(int a1)
{
  int v1; // eax
  int v2; // ecx
  char *v3; // eax
  int v4; // edx
  char v5; // bl
  int v7; // [esp+24h] [ebp-4h] BYREF

  v7 = a1;
  if ( !*(_DWORD *)&String[508] )
    return 0;
  do
  {
    do
      v1 = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 28))(*(_DWORD *)&String[508]);
    while ( v1 == -2147024866 );
  }
  while ( v1 == -2147024891 );
  if ( v1 < 0 )
    return 0;
  memset(&String[512], 0, 0x100u);
  (*(void (__stdcall **)(_DWORD, int, char *))(**(_DWORD **)&String[508] + 36))(
    *(_DWORD *)&String[508],
    256,
    &String[512]);
  v7 = 10;
  if ( (*(int (__stdcall **)(_DWORD, int, char *, int *, _DWORD))(**(_DWORD **)&String[508] + 40))(
         *(_DWORD *)&String[508],
         20,
         &String[304],
         &v7,
         0) >= 0 )
  {
    v2 = v7;
    if ( v7 > 0 )
    {
      v3 = &String[304];
      do
      {
        v4 = *(_DWORD *)v3;
        v5 = v3[4];
        v3 += 20;
        --v2;
        String[v4 + 512] = v5;
      }
      while ( v2 );
    }
  }
  return 1;
}

// grim_keyboard_shutdown @ 0x1000A550
// releases DirectInput keyboard objects
int sub_1000A550()
{
  int result; // eax

  if ( *(_DWORD *)&String[508] )
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 32))(*(_DWORD *)&String[508]);
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[508] + 8))(*(_DWORD *)&String[508]);
    *(_DWORD *)&String[508] = 0;
  }
  result = *(_DWORD *)&String[504];
  if ( *(_DWORD *)&String[504] )
  {
    result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[504] + 8))(*(_DWORD *)&String[504]);
    *(_DWORD *)&String[504] = 0;
  }
  return result;
}

// grim_mouse_button_down @ 0x1000A590
// reads the cached mouse button state
char __cdecl sub_1000A590(int a1)
{
  return (unsigned __int8)String[a1 + 788] >> 7;
}

// grim_mouse_init @ 0x1000A5A0
// initializes DirectInput mouse device and acquires it
char sub_1000A5A0()
{
  HWND v0; // esi
  int v1; // eax
  HMODULE ModuleHandleA; // eax

  v0 = hWnd;
  if ( !hWnd && !GetForegroundWindow() )
    GetDesktopWindow();
  v1 = *(_DWORD *)&String[768];
  if ( !*(_DWORD *)&String[768] )
  {
    ModuleHandleA = GetModuleHandleA(0);
    if ( DirectInput8Create(ModuleHandleA, 0x800u, &riidltf, (LPVOID *)&String[768], 0) < 0 )
    {
      *(_DWORD *)&String[768] = 0;
      return 0;
    }
    v1 = *(_DWORD *)&String[768];
  }
  if ( !*(_DWORD *)&String[772] )
  {
    if ( (*(int (__stdcall **)(int, void *, char *, _DWORD))(*(_DWORD *)v1 + 12))(v1, &unk_100502AC, &String[772], 0) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, void *))(**(_DWORD **)&String[772] + 44))(*(_DWORD *)&String[772], &unk_10050284) < 0 )
      return 0;
    if ( (*(int (__stdcall **)(_DWORD, HWND, int))(**(_DWORD **)&String[772] + 52))(*(_DWORD *)&String[772], v0, 5) < 0 )
      return 0;
    if ( *(_DWORD *)&String[772] )
      (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 28))(*(_DWORD *)&String[772]);
  }
  grim_mouse_poll();
  return 1;
}

// grim_mouse_poll @ 0x1000A670
// polls the mouse device and updates cached position/delta
char sub_1000A670()
{
  int v0; // esi
  int v1; // eax

  if ( !*(_DWORD *)&String[772] )
    return 1;
  v0 = 0;
  *(_DWORD *)&String[776] = 0;
  *(_DWORD *)&String[816] = 0;
  *(_DWORD *)&String[780] = 0;
  *(_DWORD *)&String[812] = 0;
  *(_DWORD *)&String[784] = 0;
  *(_DWORD *)&String[808] = 0;
  *(_DWORD *)&String[788] = 0;
  *(_DWORD *)&String[792] = 0;
  if ( (*(int (__stdcall **)(_DWORD, int, char *))(**(_DWORD **)&String[772] + 36))(
         *(_DWORD *)&String[772],
         20,
         &String[776]) >= 0 )
  {
    while ( 1 )
    {
      v1 = v0++;
      *(float *)&String[808] = (double)*(int *)&String[776] + *(float *)&String[808];
      *(float *)&String[812] = (double)*(int *)&String[780] + *(float *)&String[812];
      *(float *)&String[816] = (double)*(int *)&String[784] + *(float *)&String[816];
      if ( v1 >= 100 || !*(_DWORD *)&String[776] && !*(_DWORD *)&String[780] && !*(_DWORD *)&String[784] )
        break;
      *(_DWORD *)&String[776] = 0;
      *(_DWORD *)&String[780] = 0;
      *(_DWORD *)&String[784] = 0;
      *(_DWORD *)&String[788] = 0;
      *(_DWORD *)&String[792] = 0;
      if ( (*(int (__stdcall **)(_DWORD, int, char *))(**(_DWORD **)&String[772] + 36))(
             *(_DWORD *)&String[772],
             20,
             &String[776]) < 0 )
        goto LABEL_8;
    }
    if ( v0 > 2 )
      grim_noop();
    *(float *)&String[796] = *(float *)&String[796] + *(float *)&String[808];
    *(float *)&String[800] = *(float *)&String[800] + *(float *)&String[812];
    *(float *)&String[804] = *(float *)&String[804] + *(float *)&String[816];
    return 1;
  }
LABEL_8:
  if ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 28))(*(_DWORD *)&String[772]) != -2147024866 )
    return 1;
  while ( (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 28))(*(_DWORD *)&String[772]) == -2147024866 )
    ;
  return 1;
}

// grim_mouse_shutdown @ 0x1000A7D0
// releases DirectInput mouse objects
int sub_1000A7D0()
{
  int result; // eax

  if ( *(_DWORD *)&String[772] )
  {
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 32))(*(_DWORD *)&String[772]);
    (*(void (__stdcall **)(_DWORD))(**(_DWORD **)&String[772] + 8))(*(_DWORD *)&String[772]);
    *(_DWORD *)&String[772] = 0;
  }
  result = *(_DWORD *)&String[768];
  if ( *(_DWORD *)&String[768] )
  {
    result = (*(int (__stdcall **)(_DWORD))(**(_DWORD **)&String[768] + 8))(*(_DWORD *)&String[768]);
    *(_DWORD *)&String[768] = 0;
  }
  return result;
}

// sub_1000A820 @ 0x1000A820
bool __cdecl sub_1000A820(unsigned int a1)
{
  return a1 > 2;
}

// FUN_1000a840 @ 0x1000A840
// [binja] bool __stdcall sub_1000a840(int32_t* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
bool __stdcall sub_1000A840(_DWORD *a1, unsigned int a2, int a3, int a4)
{
  unsigned int v4; // esi
  void *v5; // eax
  unsigned int v6; // eax
  int v8; // [esp-8h] [ebp-Ch]

  v4 = a2;
  v5 = operator new(a2);
  v8 = a4;
  *a1 = v5;
  a2 = v4;
  v6 = sub_10046400(v5, &a2, a3, v8);
  return !sub_1000A820(v6);
}

// FUN_1000a880 @ 0x1000A880
// [binja] char* __stdcall sub_1000a880(char* arg1, uint32_t* arg2)
int __stdcall sub_1000A880(int a1, unsigned int *a2)
{
  int v3; // esi
  unsigned int v4; // [esp-14h] [ebp-14h]
  int v5; // [esp-10h] [ebp-10h]

  if ( *(_BYTE *)a1 != 1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 1);
  v5 = a1 + 9;
  v4 = *(_DWORD *)(a1 + 5);
  *a2 = v4;
  a1 = 0;
  FUN_1000a840(&a1, v4, v5, v3);
  return a1;
}

// grim_format_info_lookup @ 0x1000AAA6
// returns pointer to the D3D format descriptor entry (fallbacks to default)
_DWORD *__cdecl sub_1000AAA6(int a1)
{
  _DWORD *result; // eax

  result = &unk_1004C3B0;
  if ( off_10053C50 <= &unk_1004C3B0 )
    return &unk_1004C388;
  while ( a1 != *result )
  {
    result += 9;
    if ( result >= (_DWORD *)off_10053C50 )
      return &unk_1004C388;
  }
  return result;
}

// FUN_1000aaca @ 0x1000AACA
// [binja] int32_t __fastcall sub_1000aaca(void* arg1, int32_t arg2)
unsigned int __fastcall sub_1000AACA(int a1, int a2)
{
  unsigned int result; // eax
  unsigned int *v3; // esi
  int v4; // edi
  int v5; // ebx
  unsigned int v6; // ecx
  unsigned int v7; // edx
  int v8; // [esp+4h] [ebp-4h]

  result = 0;
  if ( !dword_1004C9C0[5 * *(_DWORD *)(a1 + 4) + *(_DWORD *)(a2 + 4)] )
    return -1;
  v8 = 0;
  v3 = (unsigned int *)(a1 + 12);
  v4 = a2 - a1;
  v5 = 5;
  do
  {
    v6 = *v3;
    if ( *v3 )
      ++v8;
    v7 = *(unsigned int *)((char *)v3 + v4);
    if ( v6 >= v7 )
    {
      if ( v6 > v7 )
      {
        if ( v7 )
          result += (v6 - v7) << 16;
        else
          result += 0x1000000;
      }
    }
    else if ( v6 )
    {
      result += v7 - v6;
    }
    else
    {
      result += 256;
    }
    ++v3;
    --v5;
  }
  while ( v5 );
  if ( v8 == HIBYTE(result) )
    return -1;
  return result;
}

// sub_1000AB3F @ 0x1000AB3F
int __cdecl sub_1000AB3F(int *a1, int a2, int a3)
{
  int *v3; // eax
  unsigned int v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // esi
  unsigned int v7; // eax
  int v8; // eax

  v3 = a1;
  v4 = -1;
  v5 = &unk_1004C388;
  while ( 1 )
  {
    v8 = *v3;
    if ( !v8 )
      return *v5;
    v6 = grim_format_info_lookup(v8);
    if ( *v6 )
    {
      if ( v6[1] != 1 || a2 )
        break;
    }
LABEL_11:
    v3 = ++a1;
  }
  if ( *(_DWORD *)a3 != *v6 )
  {
    v7 = FUN_1000aaca(a3, (int)v6);
    if ( v7 != -1 && v7 <= v4 && (v7 != v4 || v6[2] < v5[2]) )
    {
      v4 = v7;
      v5 = v6;
    }
    goto LABEL_11;
  }
  return *(_DWORD *)a3;
}

// sub_1000ABAD @ 0x1000ABAD
int __cdecl sub_1000ABAD(int a1, int a2, int a3, _DWORD *a4)
{
  unsigned int v4; // ebx
  _DWORD *v5; // edi
  _DWORD *v6; // esi
  unsigned int v7; // eax
  _DWORD v9[53]; // [esp+Ch] [ebp-E8h] BYREF
  _BYTE v10[12]; // [esp+E0h] [ebp-14h] BYREF
  int v11; // [esp+ECh] [ebp-8h]
  int v12; // [esp+F0h] [ebp-4h] BYREF

  v12 = 0;
  grim_d3d_debug_set_mute(1);
  if ( a1 )
  {
    (*(void (__stdcall **)(int, int *))(*(_DWORD *)a1 + 24))(a1, &v12);
    (*(void (__stdcall **)(int, _DWORD *))(*(_DWORD *)a1 + 28))(a1, v9);
    (*(void (__stdcall **)(int, _BYTE *))(*(_DWORD *)a1 + 32))(a1, v10);
  }
  v4 = -1;
  v5 = &unk_1004C388;
  v6 = &unk_1004C3B0;
  if ( off_10053C50 > &unk_1004C3B0 )
  {
    do
    {
      if ( *v6
        && (!a1
         || (*(int (__stdcall **)(int, _DWORD, _DWORD, int, int, int, _DWORD))(*(_DWORD *)v12 + 40))(
              v12,
              v9[1],
              v9[0],
              v11,
              a2,
              a3,
              *v6) >= 0) )
      {
        if ( *a4 == *v6 )
        {
          v5 = v6;
          break;
        }
        if ( v6[8] )
        {
          v7 = FUN_1000aaca((int)a4, (int)v6);
          if ( v7 != -1 && v7 <= v4 && (v7 != v4 || v6[2] < v5[2]) )
          {
            v4 = v7;
            v5 = v6;
          }
        }
      }
      v6 += 9;
    }
    while ( v6 < (_DWORD *)off_10053C50 );
  }
  if ( v12 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v12 + 8))(v12);
    v12 = 0;
  }
  grim_d3d_debug_set_mute(0);
  return *v5;
}

// sub_1000AC8F @ 0x1000AC8F
int __cdecl sub_1000AC8F(int a1)
{
  switch ( a1 )
  {
    case 909200416:
      return 50;
    case 909200449:
      return 51;
    case 909201952:
      return 20;
    case 909201985:
      return 21;
  }
  return a1;
}

// FUN_1000acc0 @ 0x1000ACC0
// [binja] int32_t __stdcall sub_1000acc0(int32_t* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t* arg8, int32_t arg9, int32_t arg10)
int __stdcall sub_1000ACC0(int a1, int a2, int a3, int a4, int a5, int a6, int a7, _DWORD *a8, int a9, int a10)
{
  int v10; // ebx
  int v11; // eax
  _BYTE v13[76]; // [esp+4h] [ebp-64h] BYREF
  _DWORD v14[4]; // [esp+50h] [ebp-18h] BYREF
  _DWORD v15[6]; // [esp+60h] [ebp-8h] BYREF
  _BYTE v16[24]; // [esp+78h] [ebp+10h] BYREF
  int v17; // [esp+94h] [ebp+2Ch]
  int v18; // [esp+98h] [ebp+30h]
  _BYTE v19[16]; // [esp+9Ch] [ebp+34h] BYREF
  _BYTE v20[12]; // [esp+ACh] [ebp+44h] BYREF

  FUN_1001284c(v20);
  FUN_10016121(v19);
  v10 = 0;
  if ( a1 )
  {
    if ( a4 && a8 )
    {
      if ( a9 == -1 )
        a9 = 524292;
      v11 = FUN_100161bb(v13, a1, a2, a3, 0, 0);
      if ( v11 < 0 )
        goto LABEL_10;
      v14[1] = a5;
      v14[0] = a4;
      v14[2] = a6;
      v14[3] = 0;
      v15[0] = *a8;
      v15[1] = a8[1];
      v15[2] = a8[2];
      v15[3] = a8[3];
      v15[4] = 0;
      v15[5] = 1;
      qmemcpy(v16, v15, sizeof(v16));
      v17 = a10;
      v18 = a7;
      v11 = FUN_10016007(v13, v14, a9);
      if ( v11 < 0 )
LABEL_10:
        v10 = v11;
    }
    else
    {
      v10 = -2005530516;
    }
  }
  else
  {
    v10 = -2005530516;
  }
  FUN_100161b6(v19);
  FUN_10012856(v20);
  return v10;
}

// FUN_1000ad9f @ 0x1000AD9F
// [binja] int32_t sub_1000ad9f(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t* arg6)
int __cdecl sub_1000AD9F(LPCWCH lpWideCharStr, int a2, int a3, int a4, int a5, LPSTR lpMultiByteStr)
{
  int v6; // esi
  int v7; // eax
  _BYTE v9[76]; // [esp+8h] [ebp-BCh] BYREF
  _BYTE v10[84]; // [esp+54h] [ebp-70h] BYREF
  _BYTE v11[16]; // [esp+A8h] [ebp-1Ch] BYREF
  int v12; // [esp+C0h] [ebp-4h]

  FUN_10010285(v10);
  v12 = 0;
  FUN_10016121(v11);
  LOBYTE(v12) = 1;
  if ( lpWideCharStr && a3 )
  {
    v7 = FUN_100161bb(v9, a3, a4, a5, 0, 1);
    if ( v7 < 0 || (v7 = FUN_10010313(v9), v7 < 0) || (v7 = FUN_1001237e(lpWideCharStr, a2, lpMultiByteStr), v7 < 0) )
      v6 = v7;
    else
      v6 = 0;
  }
  else
  {
    v6 = -2005530516;
  }
  LOBYTE(v12) = 0;
  FUN_100161b6(v11);
  v12 = -1;
  FUN_1001029e(v10);
  return v6;
}

// sub_1000AE4F @ 0x1000AE4F
void *__thiscall sub_1000AE4F(void *this)
{
  return this;
}

// FUN_1000ae52 @ 0x1000AE52
// [binja] int32_t __stdcall sub_1000ae52(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5)
int __stdcall sub_1000AE52(LPCWCH lpWideCharStr, int a2, int a3, int a4, int a5)
{
  return FUN_1000ad9f(lpWideCharStr, a2, a3, a4, a5, 0);
}

// FUN_1000ae72 @ 0x1000AE72
// [binja] int32_t __stdcall sub_1000ae72(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11)
int __stdcall sub_1000AE72(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        int a7,
        int a8,
        const void *a9,
        int a10,
        int a11)
{
  int v11; // esi
  int v12; // eax
  _BYTE v14[76]; // [esp+4h] [ebp-5Ch] BYREF
  _DWORD v15[4]; // [esp+50h] [ebp-10h] BYREF
  _BYTE v16[24]; // [esp+60h] [ebp+0h] BYREF
  _BYTE v17[24]; // [esp+78h] [ebp+18h] BYREF
  int v18; // [esp+94h] [ebp+34h]
  int v19; // [esp+98h] [ebp+38h]
  _BYTE v20[12]; // [esp+9Ch] [ebp+3Ch] BYREF
  _BYTE v21[4]; // [esp+A8h] [ebp+48h] BYREF

  FUN_1001284c(v20);
  FUN_1001619a(v21);
  if ( a1 && a4 && a9 )
  {
    if ( a10 == -1 )
      a10 = 524292;
    v12 = FUN_100165d3(v14, a1, a2, a3, 0, 0);
    if ( v12 < 0 )
      goto LABEL_8;
    v15[1] = a5;
    v15[2] = a6;
    v15[0] = a4;
    v15[3] = a7;
    qmemcpy(v16, a9, sizeof(v16));
    qmemcpy(v17, a9, sizeof(v17));
    v18 = a11;
    v19 = a8;
    v12 = FUN_10016007(v14, v15, a10);
    if ( v12 < 0 )
LABEL_8:
      v11 = v12;
    else
      v11 = 0;
  }
  else
  {
    v11 = -2005530516;
  }
  j_FUN_100161a0(v21);
  FUN_10012856(v20);
  return v11;
}

// sub_1000AF45 @ 0x1000AF45
int __usercall sub_1000AF45@<eax>(
        int a1@<edx>,
        int a2,
        unsigned int *a3,
        unsigned int *a4,
        unsigned int *a5,
        unsigned int *a6,
        int *a7,
        unsigned int a8,
        int a9)
{
  int v10; // esi
  _DWORD *v12; // eax
  unsigned int v13; // ebx
  unsigned int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  bool v18; // cc
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // edx
  int v22; // eax
  unsigned int v23; // edi
  unsigned int v24; // eax
  unsigned int v25; // esi
  unsigned int v26; // ecx
  unsigned int i; // eax
  unsigned int v28; // eax
  unsigned int j; // edx
  unsigned int v30; // eax
  char v31[60]; // [esp+Ch] [ebp-DCh] BYREF
  int v32; // [esp+48h] [ebp-A0h]
  unsigned int v33; // [esp+64h] [ebp-84h]
  unsigned int v34; // [esp+68h] [ebp-80h]
  unsigned int v35; // [esp+6Ch] [ebp-7Ch]
  int v36; // [esp+74h] [ebp-74h]
  int v37; // [esp+E0h] [ebp-8h]
  unsigned int v38; // [esp+E4h] [ebp-4h]
  unsigned int v39; // [esp+F0h] [ebp+8h]

  v10 = a1;
  if ( !a2 )
    return -2005530516;
  if ( a1 == -1 )
    v10 = 0;
  if ( v10 != (v10 & 0x20B) || a8 >= 4 )
    return -2005530516;
  if ( a7 )
    v37 = *a7;
  else
    v37 = 0;
  if ( a8 == 3 )
  {
    if ( !v37 )
      v37 = 21;
  }
  else
  {
    v12 = grim_format_info_lookup(v37);
    v37 = sub_1000ABAD(a2, v10, a9, v12);
    if ( !v37 )
      return -2005530518;
  }
  if ( a3 )
    v39 = *a3;
  else
    v39 = -1;
  if ( a4 )
    v13 = *a4;
  else
    v13 = -1;
  if ( a5 )
    v38 = *a5;
  else
    v38 = -1;
  if ( v39 == -1 )
  {
    if ( v13 == -1 )
    {
      v13 = 256;
      v39 = 256;
      goto LABEL_34;
    }
    v39 = v13;
  }
  else if ( v13 == -1 )
  {
    v13 = v39;
  }
  if ( !v39 )
    v39 = 1;
  if ( !v13 )
    v13 = 1;
LABEL_34:
  if ( a9 == 5 )
  {
    if ( v39 > v13 )
      v13 = v39;
    v39 = v13;
  }
  if ( v38 == -1 || !v38 )
    v38 = 1;
  if ( a8 == 3 )
    goto LABEL_75;
  (*(void (__stdcall **)(int, char *))(*(_DWORD *)a2 + 28))(a2, v31);
  if ( a9 == 4 )
  {
    v14 = v35;
    if ( v38 > v35 )
      v38 = v35;
    if ( v39 > v35 )
      v39 = v35;
  }
  else
  {
    if ( v39 > v33 )
      v39 = v33;
    if ( v13 > v34 )
      v13 = v34;
    if ( a9 != 3 )
      goto LABEL_61;
    v15 = (v32 & 0x20) != 0 ? 1 : v36;
    if ( !v15 )
      goto LABEL_61;
    if ( v39 > v13 * v15 )
      v39 = v13 * v15;
    v14 = v39 * v15;
  }
  if ( v13 > v14 )
    v13 = v14;
LABEL_61:
  switch ( a9 )
  {
    case 3:
      v16 = 2;
      break;
    case 4:
      v16 = 0x40000;
      break;
    case 5:
      v16 = 0x20000;
      break;
    default:
      v16 = v39;
      break;
  }
  if ( (v16 & v32) != 0 )
  {
    v17 = v39;
    v18 = v39 <= 1;
    v39 = 1;
    if ( !v18 )
    {
      do
        v39 *= 2;
      while ( v39 < v17 );
    }
    v19 = v13;
    v18 = v13 <= 1;
    v13 = 1;
    if ( !v18 )
    {
      do
        v13 *= 2;
      while ( v13 < v19 );
    }
    v20 = v38;
    v18 = v38 <= 1;
    v38 = 1;
    if ( !v18 )
    {
      do
        v38 *= 2;
      while ( v38 < v20 );
    }
  }
LABEL_75:
  if ( v37 == 827611204 || v37 == 844388420 || v37 == 861165636 || v37 == 877942852 || v37 == 894720068 )
  {
    v21 = (v39 + 3) & 0xFFFFFFFC;
    v39 = v21;
    v13 = (v13 + 3) & 0xFFFFFFFC;
  }
  else
  {
    v21 = v39;
  }
  switch ( a9 )
  {
    case 3:
      v22 = 0x4000;
      break;
    case 4:
      v22 = 0x8000;
      break;
    case 5:
      v22 = 0x10000;
      break;
    default:
      v22 = v39;
      break;
  }
  if ( a6 )
    v23 = *a6;
  else
    v23 = -1;
  if ( a8 != 3
    && ((v22 & v32) == 0
     || (v32 & 0x100) != 0 && (((v21 - 1) & v21) != 0 || ((v13 - 1) & v13) != 0 || ((v38 - 1) & v38) != 0)) )
  {
    v23 = 1;
  }
  else
  {
    v24 = v39;
    v25 = 0;
    while ( v24 )
    {
      v24 >>= 1;
      ++v25;
    }
    v26 = 0;
    for ( i = v13; i; ++v26 )
      i >>= 1;
    v28 = v38;
    for ( j = 0; v28; ++j )
      v28 >>= 1;
    v30 = v25;
    if ( v25 <= v26 )
      v30 = v26;
    if ( a9 == 4 && j > v30 )
      v30 = j;
    if ( v23 > v30 || !v23 )
      v23 = v30;
  }
  if ( a3 )
    *a3 = v39;
  if ( a4 )
    *a4 = v13;
  if ( a5 )
    *a5 = v38;
  if ( a6 )
    *a6 = v23;
  if ( a7 )
    *a7 = v37;
  return 0;
}

// FUN_1000b26f @ 0x1000B26F
// [binja] int32_t __stdcall sub_1000b26f(int32_t** arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, int32_t arg5, int32_t arg6, int32_t arg7)
int __stdcall sub_1000B26F(
        int a1,
        unsigned int *a2,
        unsigned int *a3,
        unsigned int *a4,
        int a5,
        int *a6,
        unsigned int a7)
{
  return sub_1000AF45(a5, a1, a2, a3, 0, a4, a6, a7, 3);
}

// FUN_1000b297 @ 0x1000B297
// [binja] int32_t __stdcall sub_1000b297(int32_t** arg1, int32_t arg2, int32_t arg3, int32_t arg4)
int __stdcall sub_1000B297(int a1, int a2, int a3, int a4, int a5, int a6, unsigned int a7, int a8)
{
  int result; // eax
  int v9; // edi

  if ( !a1 || !a8 )
    return -2005530516;
  v9 = a5;
  if ( a5 == -1 )
    v9 = 0;
  result = FUN_1000b26f(a1, (unsigned int *)&a2, (unsigned int *)&a3, (unsigned int *)&a4, v9, &a6, a7);
  if ( result >= 0 )
  {
    result = (*(int (__stdcall **)(int, int, int, int, int, int, unsigned int, int))(*(_DWORD *)a1 + 80))(
               a1,
               a2,
               a3,
               a4,
               v9,
               a6,
               a7,
               a8);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// sub_1000B2FD @ 0x1000B2FD
char *__thiscall sub_1000B2FD(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    FUN_1004b5cf(this, 0x10u, *((_DWORD *)this - 1), FUN_100161b6);
    if ( (a2 & 1) != 0 )
      operator delete(this - 4);
    return this - 4;
  }
  else
  {
    FUN_100161b6(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

// sub_1000B348 @ 0x1000B348
char *__thiscall sub_1000B348(char *this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    FUN_1004b5cf(this, 4u, *((_DWORD *)this - 1), j_FUN_100161a0);
    if ( (a2 & 1) != 0 )
      operator delete(this - 4);
    return this - 4;
  }
  else
  {
    j_FUN_100161a0(this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

// sub_1000B393 @ 0x1000B393
int __stdcall sub_1000B393(int a1, int a2, int a3, int (__thiscall *a4)(int))
{
  int result; // eax
  int v6; // edi

  result = a3 - 1;
  if ( a3 - 1 >= 0 )
  {
    v6 = a3;
    do
    {
      result = a4(a1);
      a1 += a2;
      --v6;
    }
    while ( v6 );
  }
  return result;
}

// sub_1000B3B5 @ 0x1000B3B5
double __usercall sub_1000B3B5@<st0>(float *a1@<eax>, int a2@<ecx>)
{
  int v2; // ecx
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx

  v2 = a2 - 1;
  if ( !v2 )
    return *a1;
  v3 = v2 - 1;
  if ( !v3 )
    return a1[2];
  v4 = v3 - 2;
  if ( !v4 )
    return a1[1];
  v5 = v4 - 4;
  if ( !v5 )
    return a1[3];
  if ( v5 == 8 )
    return a1[2] * 0.072099999 + a1[1] * 0.71539998 + *a1 * 0.21250001;
  return 0.0;
}

// FUN_1000b3fe @ 0x1000B3FE
// [binja] int32_t __stdcall sub_1000b3fe(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, float arg5)
int __userpurge sub_1000B3FE@<eax>(int a1@<esi>, int a2, int a3, int a4, int a5, int a6, float a7)
{
  int v7; // ebx
  unsigned int v8; // eax
  _DWORD *v9; // esi
  _DWORD *v10; // eax
  unsigned int v11; // esi
  int v12; // esi
  int v13; // eax
  int v14; // edi
  void *v15; // eax
  void *v16; // ebx
  int v17; // edi
  void *v18; // eax
  void *v19; // ebx
  int v20; // edi
  void *v21; // eax
  void *v22; // ebx
  int v23; // edi
  void *v24; // eax
  void *v25; // ebx
  void *v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // ebx
  int v30; // eax
  void (__thiscall ***v31)(_DWORD, int); // edi
  float *v32; // edi
  int v33; // eax
  float *v34; // ebx
  double v35; // st7
  float *v36; // edi
  double v37; // st7
  double v38; // st7
  int v39; // edx
  double v40; // st7
  float *v41; // esi
  char *v42; // edi
  char *v43; // edx
  float *v44; // esi
  double v45; // st7
  double v46; // st7
  int v47; // ebx
  int v48; // edx
  int v49; // edi
  double v50; // st7
  float *v51; // edx
  double v52; // st7
  int v53; // ecx
  double v54; // st6
  float *v55; // eax
  double v56; // st6
  int v57; // ecx
  double v58; // st7
  int v59; // eax
  float *v60; // ecx
  int v61; // esi
  int v62; // esi
  double v63; // st7
  double v64; // st6
  int i; // edx
  float *v66; // ecx
  double v67; // st5
  double v68; // st5
  double v69; // st7
  long double v70; // st6
  double v71; // st6
  float *v72; // eax
  float v73; // ecx
  double v74; // st6
  void *v75; // eax
  void *v76; // ecx
  _BYTE v79[76]; // [esp+8h] [ebp-13Ch] BYREF
  _BYTE v80[76]; // [esp+54h] [ebp-F0h] BYREF
  int v81[8]; // [esp+A0h] [ebp-A4h] BYREF
  _BYTE v82[16]; // [esp+C0h] [ebp-84h] BYREF
  _BYTE v83[16]; // [esp+D0h] [ebp-74h] BYREF
  char v84[24]; // [esp+E0h] [ebp-64h] BYREF
  int v85; // [esp+F8h] [ebp-4Ch]
  _DWORD v86[8]; // [esp+100h] [ebp-44h] BYREF
  float v87; // [esp+120h] [ebp-24h]
  float v88; // [esp+124h] [ebp-20h]
  float v89; // [esp+128h] [ebp-1Ch]
  int v90; // [esp+12Ch] [ebp-18h]
  int v91; // [esp+130h] [ebp-14h]
  int v92; // [esp+134h] [ebp-10h]
  int v93[6]; // [esp+138h] [ebp-Ch] BYREF
  int v94; // [esp+150h] [ebp+Ch]
  int v95; // [esp+154h] [ebp+10h]
  float v96; // [esp+158h] [ebp+14h] BYREF
  float v97; // [esp+15Ch] [ebp+18h]
  float v98; // [esp+160h] [ebp+1Ch]
  unsigned int v99; // [esp+164h] [ebp+20h]
  void *v100; // [esp+168h] [ebp+24h]
  void *v101; // [esp+16Ch] [ebp+28h]
  void (__thiscall ***v102)(_DWORD, int); // [esp+170h] [ebp+2Ch]
  float v103; // [esp+174h] [ebp+30h]
  int v104; // [esp+178h] [ebp+34h]
  void *v105; // [esp+17Ch] [ebp+38h]
  void *v106; // [esp+180h] [ebp+3Ch]
  void *v107; // [esp+184h] [ebp+40h]
  void *v108; // [esp+188h] [ebp+44h]
  int v109; // [esp+18Ch] [ebp+48h] BYREF
  int v110; // [esp+190h] [ebp+4Ch] BYREF
  float v111; // [esp+194h] [ebp+50h]
  int v112; // [esp+198h] [ebp+54h]
  void *v113; // [esp+19Ch] [ebp+58h]
  int v114; // [esp+1A0h] [ebp+5Ch]

  v104 = 0;
  v102 = 0;
  v110 = 0;
  v109 = 0;
  FUN_10016121(v83);
  FUN_10016121(v82);
  if ( a2 )
  {
    if ( !a3 )
      goto LABEL_118;
    if ( a5 == -1 )
      a5 = 0;
    if ( (a5 & 0xFFE4FFFF) != 0 )
      goto LABEL_118;
    v8 = a6;
    if ( a6 == -1 )
    {
      v8 = 1;
      a6 = 1;
    }
    if ( !v8 || v8 > 2 && v8 != 4 && v8 != 8 && v8 != 16 )
      goto LABEL_118;
    if ( (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)a2 + 56))(a2, 0, v81) < 0
      || (*(int (__stdcall **)(int, _DWORD, int *))(*(_DWORD *)a3 + 56))(a3, 0, v93) < 0 )
    {
      v7 = -2147467259;
      goto LABEL_119;
    }
    if ( (v9 = grim_format_info_lookup(v93[0]), v10 = grim_format_info_lookup(v81[0]), !*v9)
      || !*v10
      || (v11 = v9[1], v11 > 2) && v11 != 4
      || v10[1]
      || v10[5] < 2u
      || v10[6] < 2u
      || v10[7] < 2u
      || v94 != v81[6]
      || v95 != v81[7]
      || (v12 = (*(int (__stdcall **)(int))(*(_DWORD *)a3 + 52))(a3),
          v99 = (*(int (__stdcall **)(int))(*(_DWORD *)a2 + 52))(a2),
          v12 != v99) )
    {
LABEL_118:
      v7 = -2005530516;
      goto LABEL_119;
    }
    v13 = (*(int (__stdcall **)(int, _DWORD, char *))(*(_DWORD *)a2 + 56))(a2, 0, v84);
    if ( v13 >= 0 )
    {
      v14 = v85;
      v15 = operator new(16 * v85);
      v16 = v15;
      if ( v15 )
      {
        sub_1000B393((int)v15, 16, v14, (int (__thiscall *)(int))sub_1000AE4F);
        v106 = v16;
      }
      else
      {
        v106 = 0;
      }
      v17 = v85;
      v18 = operator new(16 * v85);
      v19 = v18;
      if ( v18 )
      {
        sub_1000B393((int)v18, 16, v17, (int (__thiscall *)(int))sub_1000AE4F);
        v101 = v19;
      }
      else
      {
        v101 = 0;
      }
      v20 = v85;
      v21 = operator new(16 * v85);
      v22 = v21;
      if ( v21 )
      {
        sub_1000B393((int)v21, 16, v20, (int (__thiscall *)(int))sub_1000AE4F);
        v100 = v22;
      }
      else
      {
        v100 = 0;
      }
      v23 = v85;
      v24 = operator new(16 * v85);
      v25 = v24;
      if ( v24 )
      {
        sub_1000B393((int)v24, 16, v23, (int (__thiscall *)(int))sub_1000AE4F);
        v105 = v25;
        v7 = 0;
      }
      else
      {
        v7 = 0;
        v105 = 0;
      }
      v108 = operator new(4 * v85 + 8);
      v113 = operator new(4 * v85 + 8);
      v26 = operator new(4 * v85 + 8);
      v107 = v26;
      if ( v101 && v100 && v105 && v106 && v108 && v113 && v26 )
      {
        v112 = 0;
        if ( v99 )
        {
          while ( 1 )
          {
            (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 60))(a2, v112, &v109);
            (*(void (__stdcall **)(int, int, int *))(*(_DWORD *)a3 + 60))(a3, v112, &v110);
            v27 = v112 ? FUN_100161bb(v79, v109, 0, 0, 0, 0) : FUN_100161bb(v79, v109, 0, 0, 0, 0x20000);
            v7 = v27;
            if ( v27 < 0 )
              break;
            v28 = a2 == a3 ? FUN_100161bb(v80, v110, 0, 0, 0, 65537) : FUN_100161bb(v80, v110, 0, 0, 0, 1);
            v7 = v28;
            if ( v28 < 0 )
              break;
            v7 = (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)a2 + 56))(a2, v112, v81);
            if ( v7 < 0 )
              break;
            v7 = (*(int (__stdcall **)(int, int, int *))(*(_DWORD *)a3 + 56))(a3, v112, v93);
            if ( v7 < 0 )
              break;
            v29 = grim_pixel_format_create(v80);
            v104 = v29;
            v30 = grim_pixel_format_create(v79);
            v31 = (void (__thiscall ***)(_DWORD, int))v30;
            v102 = (void (__thiscall ***)(_DWORD, int))v30;
            if ( !v29 || !v30 )
            {
              v7 = -2147467259;
              goto LABEL_109;
            }
            v32 = (float *)v106;
            (*(void (__thiscall **)(int, int, _DWORD, void *, int))(*(_DWORD *)v29 + 4))(v29, v95 - 1, 0, v106, a1);
            v33 = *(_DWORD *)v29;
            v34 = (float *)v101;
            (*(void (__thiscall **)(int, _DWORD, _DWORD, void *))(v33 + 4))(v104, 0, 0, v101);
            v35 = sub_1000B3B5(&v32[4 * v94 - 4], a6);
            v36 = (float *)v108;
            *(float *)v108 = v35;
            v37 = sub_1000B3B5(&v34[4 * v94 - 4], a6);
            *(float *)v113 = v37;
            v38 = sub_1000B3B5((float *)v106, a6);
            v36[v94 + 1] = v38;
            v40 = sub_1000B3B5(v34, a6);
            *(float *)(v39 + 4 * v94 + 4) = v40;
            v114 = 0;
            if ( v94 > 0 )
            {
              v41 = (float *)(v39 + 4);
              v42 = (char *)v36 - v39;
              v43 = (char *)((_BYTE *)v106 - (_BYTE *)v34);
              do
              {
                *(float *)((char *)v41 + (_DWORD)v42) = sub_1000B3B5((float *)((char *)v34 + (_DWORD)v43), a6);
                *v41 = sub_1000B3B5(v34, a6);
                ++v114;
                v34 += 4;
                ++v41;
              }
              while ( v114 < v94 );
            }
            v114 = 0;
            if ( v95 > 0 )
            {
              do
              {
                v91 = v114 + 1;
                v44 = (float *)v100;
                (*(void (__thiscall **)(int, unsigned int, _DWORD, void *))(*(_DWORD *)v104 + 4))(
                  v104,
                  (v114 + 1) % (unsigned int)v95,
                  0,
                  v100);
                v45 = sub_1000B3B5(&v44[4 * v94 - 4], a6);
                *(float *)v107 = v45;
                v46 = sub_1000B3B5(v44, a6);
                v47 = 0;
                *(float *)(v48 + 4 * v94 + 4) = v46;
                v49 = 0;
                if ( v94 > 0 )
                {
                  do
                  {
                    v50 = sub_1000B3B5(v44, a6);
                    *v51 = v50;
                    ++v49;
                    v44 += 4;
                  }
                  while ( v49 < v94 );
                  if ( v94 > 0 )
                  {
                    v89 = 1.0;
                    v52 = 0.5;
                    v92 = a5 & 0x100000;
                    v90 = a5 & 0x80000;
                    do
                    {
                      v53 = 0;
                      v54 = 0.0;
                      if ( !v47 && (a5 & 0x10000) != 0 )
                      {
                        v55 = (float *)v113;
                      }
                      else
                      {
                        v55 = (float *)v113;
                        v54 = *((float *)v113 + v47 + 1) + *((float *)v113 + v47);
                        v53 = 1;
                      }
                      if ( v47 < v94 - 1 || (a5 & 0x10000) == 0 )
                      {
                        ++v53;
                        v54 = v54 - (v55[v47 + 2] + v55[v47 + 1]);
                      }
                      v56 = v54 * a7;
                      if ( v53 != 1 )
                        v56 = v56 * v52;
                      v111 = v56;
                      v57 = 0;
                      v103 = 0.0;
                      if ( v114 || (a5 & 0x20000) == 0 )
                      {
                        v57 = 1;
                        v103 = v55[v47 + 1] + *((float *)v108 + v47 + 1);
                      }
                      if ( v114 < v95 - 1 || (a5 & 0x20000) == 0 )
                      {
                        ++v57;
                        v103 = v103 - (*((float *)v107 + v47 + 1) + v55[v47 + 1]);
                      }
                      if ( v57 == 1 )
                        v58 = v103 * a7;
                      else
                        v58 = v52 * (v103 * a7);
                      v87 = 0.0 * v58 - v111 * -1.0;
                      v88 = v111 * 0.0 - v58 * -1.0;
                      v96 = v87;
                      v97 = v88;
                      v98 = v89;
                      sub_1000CE76(&v96, &v96);
                      v111 = 1.0;
                      if ( v92 )
                      {
                        v86[0] = *((_DWORD *)v108 + v47);
                        v86[1] = *((_DWORD *)v108 + v47 + 1);
                        v59 = 4 * v47 + 8;
                        v60 = (float *)((char *)v113 + 4 * v47);
                        v61 = *(_DWORD *)v60;
                        *(float *)&v86[2] = *(float *)((char *)v108 + v59);
                        *(float *)&v86[4] = *(float *)((char *)v113 + v59);
                        v86[3] = v61;
                        v62 = *((_DWORD *)v107 + v47);
                        *(float *)&v86[7] = *(float *)((char *)v107 + v59);
                        v86[5] = v62;
                        v63 = 0.0;
                        v64 = v60[1];
                        v86[6] = *((_DWORD *)v107 + v47 + 1);
                        for ( i = 0; i < 8; ++i )
                        {
                          v66 = (float *)&v86[i];
                          v67 = *v66 - v64;
                          *v66 = v67;
                          if ( v67 < 0.0 )
                            *v66 = 0.0;
                          v68 = v63 + *v66;
                          v63 = v68;
                        }
                        v69 = v68 * a7 * 0.125;
                        if ( v69 > 0.0 )
                        {
                          v70 = sqrt(v69 * v69 + 1.0);
                          v111 = (v70 - v69) / v70;
                        }
                      }
                      v52 = 0.5;
                      v71 = v96;
                      v72 = (float *)((char *)v105 + 16 * v47);
                      v73 = v111;
                      if ( v90 )
                      {
                        *v72 = 0.5 - v71 * 0.5;
                        v72[1] = 0.5 - v97 * 0.5;
                        v74 = 0.5 - v98 * 0.5;
                      }
                      else
                      {
                        *v72 = (v71 + 1.0) * 0.5;
                        v72[1] = (v97 + 1.0) * 0.5;
                        v74 = (v98 + 1.0) * 0.5;
                      }
                      ++v47;
                      v72[2] = v74;
                      v72[3] = v73;
                    }
                    while ( v47 < v94 );
                  }
                }
                ((void (__thiscall *)(void (__thiscall ***)(_DWORD, int), int, _DWORD, void *))(*v102)[2])(
                  v102,
                  v114,
                  0,
                  v105);
                v75 = v108;
                v108 = v113;
                v76 = v107;
                v107 = v75;
                v113 = v76;
                v114 = v91;
              }
              while ( v91 < v95 );
            }
            a1 = 1;
            (**(void (__thiscall ***)(int))v104)(v104);
            (**v102)(v102, 1);
            if ( v110 )
            {
              (*(void (__stdcall **)(int))(*(_DWORD *)v110 + 8))(v110);
              v110 = 0;
            }
            if ( v109 )
            {
              (*(void (__stdcall **)(int))(*(_DWORD *)v109 + 8))(v109);
              v109 = 0;
            }
            if ( ++v112 >= v99 )
            {
              v7 = 0;
              break;
            }
          }
        }
      }
      else
      {
        v31 = v102;
        v7 = -2147024882;
LABEL_109:
        if ( v104 )
          (**(void (__thiscall ***)(int, int))v104)(v104, 1);
        if ( v31 )
          (**v31)(v31, 1);
      }
      if ( v110 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v110 + 8))(v110);
        v110 = 0;
      }
      if ( v109 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v109 + 8))(v109);
        v109 = 0;
      }
      operator delete(v106);
      operator delete(v101);
      operator delete(v100);
      operator delete(v105);
      operator delete(v108);
      operator delete(v113);
      operator delete(v107);
    }
    else
    {
      v7 = v13;
    }
  }
  else
  {
    v7 = -2005530516;
  }
LABEL_119:
  FUN_100161b6(v82);
  FUN_100161b6(v83);
  return v7;
}

// FUN_1000bbfc @ 0x1000BBFC
// [binja] int32_t __stdcall sub_1000bbfc(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5, int32_t arg6, int32_t arg7)
int __stdcall sub_1000BBFC(int a1, const void *a2, int *a3, int a4, const void *a5, int *a6, int a7, int a8)
{
  int v8; // esi
  int v9; // ebx
  int v10; // edx
  int v11; // ecx
  int v12; // eax
  int v13; // esi
  int v14; // eax
  int v15; // eax
  int v17[10]; // [esp+4h] [ebp-44h] BYREF
  _DWORD v18[9]; // [esp+2Ch] [ebp-1Ch] BYREF
  _BYTE v19[24]; // [esp+50h] [ebp+8h] BYREF
  int v20; // [esp+68h] [ebp+20h]
  int v21; // [esp+6Ch] [ebp+24h]
  _BYTE v22[16]; // [esp+70h] [ebp+28h] BYREF
  int v23; // [esp+80h] [ebp+38h] BYREF
  int v24; // [esp+84h] [ebp+3Ch]
  int v25; // [esp+88h] [ebp+40h]
  int v26; // [esp+8Ch] [ebp+44h]
  int v27; // [esp+90h] [ebp+48h] BYREF
  int v28; // [esp+94h] [ebp+4Ch]
  int v29; // [esp+98h] [ebp+50h]
  int v30; // [esp+9Ch] [ebp+54h]

  FUN_10016121(v22);
  if ( a1 )
  {
    v9 = a4;
    if ( a4 )
    {
      if ( (unsigned __int16)a7 != 5 && !a8 && (a2 == a5 || a2 && a5 && !memcmp(a2, a5, 0x400u)) )
      {
        if ( a3 )
        {
          v27 = *a3;
          v28 = a3[1];
          v29 = a3[2];
          v30 = a3[3];
          v10 = v29;
        }
        else
        {
          (*(void (__stdcall **)(int, _BYTE *))(*(_DWORD *)a1 + 32))(a1, v19);
          v10 = v20;
          v27 = 0;
          v28 = 0;
          v29 = v20;
          v30 = v21;
        }
        if ( a6 )
        {
          v23 = *a6;
          v24 = a6[1];
          v25 = a6[2];
          v26 = a6[3];
          v11 = v26;
          v12 = v25;
        }
        else
        {
          (*(void (__stdcall **)(int, _BYTE *))(*(_DWORD *)v9 + 32))(v9, v19);
          v12 = v20;
          v11 = v21;
          v23 = 0;
          v24 = 0;
          v10 = v29;
          v25 = v20;
          v26 = v21;
        }
        if ( v10 - v27 == v12 - v23 && v30 - v28 == v11 - v24 )
        {
          (*(void (__stdcall **)(int, int *))(*(_DWORD *)v9 + 12))(v9, &a4);
          grim_d3d_debug_set_mute(1);
          v13 = (*(int (__stdcall **)(int, int, int *, int, int, int *))(*(_DWORD *)a4 + 112))(
                  a4,
                  v9,
                  &v23,
                  1,
                  a1,
                  &v27);
          grim_d3d_debug_set_mute(0);
          (*(void (__stdcall **)(int))(*(_DWORD *)a4 + 8))(a4);
          if ( v13 >= 0 )
            goto LABEL_25;
        }
      }
      v14 = 1;
      if ( a1 == v9 )
        v14 = 65537;
      v15 = FUN_100161bb(v17, v9, a5, a6, 0, v14);
      if ( v15 >= 0
        && (v15 = FUN_1000acc0(a1, (int)a2, (int)a3, v17[0], v17[1], v17[2], (int)a5, v18, a7, a8), v15 >= 0) )
      {
LABEL_25:
        v8 = 0;
      }
      else
      {
        v8 = v15;
      }
    }
    else
    {
      v8 = -2005530516;
    }
  }
  else
  {
    v8 = -2005530516;
  }
  FUN_100161b6(v22);
  return v8;
}

// FUN_1000bda2 @ 0x1000BDA2
// [binja] int32_t __stdcall sub_1000bda2(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8)
int __stdcall sub_1000BDA2(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8; // esi
  int v9; // eax
  int v10; // eax
  int v12[10]; // [esp+4h] [ebp-50h] BYREF
  _BYTE v13[36]; // [esp+2Ch] [ebp-28h] BYREF
  _BYTE v14[4]; // [esp+50h] [ebp-4h] BYREF

  FUN_1001619a(v14);
  v8 = 0;
  if ( a1 && a4 )
  {
    v9 = 1;
    if ( a1 == a4 )
      v9 = 65537;
    v10 = FUN_100165d3(v12, a4, a5, a6, 0, v9);
    if ( v10 < 0 || (v10 = FUN_1000ae72(a1, a2, a3, v12[0], v12[1], v12[2], v12[3], a5, v13, a7, a8), v10 < 0) )
      v8 = v10;
  }
  else
  {
    v8 = -2005530516;
  }
  j_FUN_100161a0(v14);
  return v8;
}

// sub_1000BE28 @ 0x1000BE28
int __cdecl sub_1000BE28(LPCWCH lpWideCharStr, int a2, int a3, LPSTR lpMultiByteStr)
{
  int v4; // ecx
  int v5; // esi
  int v6; // esi
  int v7; // edi
  int v8; // eax
  unsigned int v9; // ebx
  void *v10; // esi
  unsigned int *v11; // eax
  void *v12; // eax
  unsigned int v13; // ecx
  void *v14; // edi
  int v15; // edi
  void *v16; // ecx
  int v17; // eax
  unsigned int *v18; // eax
  void *v19; // esi
  void *v20; // eax
  void *v21; // ecx
  void *v22; // eax
  int v23; // esi
  int v24; // eax
  void *v25; // edx
  int v26; // eax
  unsigned int v27; // esi
  _DWORD *v28; // edi
  unsigned int v29; // esi
  _DWORD *v30; // edi
  _BYTE v32[76]; // [esp+4h] [ebp-E4h] BYREF
  _BYTE v33[84]; // [esp+50h] [ebp-98h] BYREF
  void *v34; // [esp+A4h] [ebp-44h]
  int v35; // [esp+A8h] [ebp-40h]
  int v36; // [esp+ACh] [ebp-3Ch]
  _DWORD *v37; // [esp+B0h] [ebp-38h]
  void *v38; // [esp+B4h] [ebp-34h]
  unsigned int v39; // [esp+B8h] [ebp-30h]
  void *v40; // [esp+BCh] [ebp-2Ch]
  void *v41; // [esp+C0h] [ebp-28h]
  int v42; // [esp+C4h] [ebp-24h]
  unsigned int v43; // [esp+C8h] [ebp-20h]
  unsigned int v44; // [esp+CCh] [ebp-1Ch]
  void *v45; // [esp+D0h] [ebp-18h]
  void *v46; // [esp+D4h] [ebp-14h]
  int v47; // [esp+D8h] [ebp-10h]
  int v48; // [esp+E4h] [ebp-4h]

  v5 = v4;
  FUN_10010285(v33);
  v48 = 0;
  if ( !lpWideCharStr || !v5 )
  {
    v6 = -2005530516;
    goto LABEL_77;
  }
  v7 = (*(int (__stdcall **)(int))(*(_DWORD *)v5 + 40))(v5);
  v35 = v7;
  if ( v7 != 3 && (unsigned int)(v7 - 4) >= 2 )
  {
    v6 = -2005530516;
    goto LABEL_77;
  }
  v42 = v5;
  if ( a2 == 4 )
  {
    v39 = v7 != 5 ? 1 : 6;
    v8 = (*(int (__stdcall **)(int))(*(_DWORD *)v5 + 52))(v5);
  }
  else
  {
    v8 = 1;
    v39 = 1;
  }
  v9 = v39 * v8;
  v10 = 0;
  v43 = v8;
  v46 = 0;
  v45 = 0;
  v40 = 0;
  v38 = 0;
  if ( v7 == 3 )
    goto LABEL_13;
  if ( v7 != 4 )
  {
    if ( v7 != 5 )
    {
LABEL_19:
      v37 = v33;
      v44 = 0;
      if ( v39 )
      {
        v36 = 0;
        do
        {
          v15 = 0;
          if ( v44 )
          {
            v16 = operator new(0x54u);
            v41 = v16;
            LOBYTE(v48) = 3;
            if ( v16 )
              v17 = FUN_10010285(v16);
            else
              v17 = 0;
            LOBYTE(v48) = 0;
            if ( !v17 )
              goto LABEL_79;
            v37[20] = v17;
            v37 = (_DWORD *)v17;
          }
          v41 = v37;
          if ( v43 )
          {
            while ( 1 )
            {
              if ( v15 )
              {
                v21 = operator new(0x54u);
                v34 = v21;
                LOBYTE(v48) = 4;
                if ( v21 )
                  v22 = (void *)FUN_10010285(v21);
                else
                  v22 = 0;
                LOBYTE(v48) = 0;
                if ( !v22 )
                  goto LABEL_79;
                *((_DWORD *)v41 + 19) = v22;
                v41 = v22;
              }
              v23 = v36 + v15;
              if ( v35 == 3 )
                break;
              if ( v35 == 4 )
              {
                v25 = v45;
LABEL_46:
                v24 = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)v42 + 60))(v42, v15, (int)v25 + 4 * v23);
                goto LABEL_47;
              }
              if ( v35 != 5 )
                goto LABEL_48;
              v24 = (*(int (__stdcall **)(int, unsigned int, int, char *))(*(_DWORD *)v42 + 60))(
                      v42,
                      v44,
                      v15,
                      (char *)v46 + 4 * v23);
LABEL_47:
              v47 = v24;
LABEL_48:
              if ( v47 < 0 )
                goto LABEL_60;
              switch ( v35 )
              {
                case 3:
LABEL_52:
                  v26 = FUN_100161bb(v32, *((_DWORD *)v46 + v23), a3, 0, 0, 1);
LABEL_53:
                  v47 = v26;
                  break;
                case 4:
                  v26 = FUN_100165d3(v32, *((_DWORD *)v45 + v23), a3, 0, 0, 1);
                  goto LABEL_53;
                case 5:
                  goto LABEL_52;
              }
              if ( v47 < 0 )
                goto LABEL_60;
              v47 = FUN_10010313(v32);
              if ( v47 < 0 )
                goto LABEL_60;
              if ( ++v15 >= v43 )
                goto LABEL_57;
            }
            v25 = v46;
            goto LABEL_46;
          }
LABEL_57:
          ++v44;
          v36 += v43;
        }
        while ( v44 < v39 );
      }
      v47 = FUN_1001237e(lpWideCharStr, a2, lpMultiByteStr);
      if ( v47 >= 0 )
        v47 = 0;
      goto LABEL_60;
    }
LABEL_13:
    v11 = (unsigned int *)operator new(16 * v9 + 4);
    v40 = v11;
    LOBYTE(v48) = 1;
    if ( v11 )
    {
      v10 = v11 + 1;
      *v11 = v9;
      FUN_1004b6c3(v11 + 1, 0x10u, v9, FUN_10016121, FUN_100161b6);
    }
    LOBYTE(v48) = 0;
    v40 = v10;
    if ( v10 )
    {
      v12 = operator new(4 * v9);
      v46 = v12;
      if ( v12 )
      {
        v13 = 4 * v9;
        v14 = v12;
LABEL_18:
        memset(v14, 0, v13);
        goto LABEL_19;
      }
    }
    goto LABEL_79;
  }
  v18 = (unsigned int *)operator new(4 * v9 + 4);
  v38 = v18;
  LOBYTE(v48) = 2;
  if ( v18 )
  {
    v19 = v18 + 1;
    *v18 = v9;
    FUN_1004b6c3(v18 + 1, 4u, v9, FUN_1001619a, j_FUN_100161a0);
  }
  else
  {
    v19 = 0;
  }
  LOBYTE(v48) = 0;
  v38 = v19;
  if ( v19 )
  {
    v20 = operator new(4 * v9);
    v45 = v20;
    if ( v20 )
    {
      v13 = 4 * v9;
      v14 = v20;
      goto LABEL_18;
    }
  }
LABEL_79:
  v47 = -2147024882;
LABEL_60:
  v27 = 0;
  if ( v40 )
    sub_1000B2FD((char *)v40, 3);
  if ( v38 )
    sub_1000B348((char *)v38, 3);
  if ( v46 )
  {
    if ( v9 )
    {
      do
      {
        v28 = (char *)v46 + 4 * v27;
        if ( *v28 )
        {
          (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v28 + 8))(*v28);
          *v28 = 0;
        }
        ++v27;
      }
      while ( v27 < v9 );
    }
    operator delete(v46);
  }
  v29 = 0;
  if ( v45 )
  {
    if ( v9 )
    {
      do
      {
        v30 = (char *)v45 + 4 * v29;
        if ( *v30 )
        {
          (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*v30 + 8))(*v30);
          *v30 = 0;
        }
        ++v29;
      }
      while ( v29 < v9 );
    }
    operator delete(v45);
  }
  v6 = v47;
LABEL_77:
  v48 = -1;
  FUN_1001029e(v33);
  return v6;
}

// FUN_1000c1e8 @ 0x1000C1E8
// [binja] void* __stdcall sub_1000c1e8(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
int __stdcall sub_1000C1E8(LPCWCH lpWideCharStr, int a2, int a3, int a4)
{
  return sub_1000BE28(lpWideCharStr, a2, a4, 0);
}

// FUN_1000c205 @ 0x1000C205
// [binja] int32_t __stdcall sub_1000c205(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4)
int __stdcall sub_1000C205(int a1, const void *a2, unsigned int a3, int a4)
{
  int v4; // esi
  int v6; // eax
  unsigned int v7; // eax
  int v8; // esi
  int v9; // eax
  int *v10; // edx
  unsigned int v11; // edi
  int v12; // eax
  int *v13; // edx
  int v14; // eax
  char v15[20]; // [esp+8h] [ebp-64h] BYREF
  int v16; // [esp+1Ch] [ebp-50h]
  int v17; // [esp+20h] [ebp-4Ch]
  int v18; // [esp+24h] [ebp-48h]
  _BYTE v19[24]; // [esp+28h] [ebp-44h] BYREF
  int v20; // [esp+40h] [ebp-2Ch]
  int v21; // [esp+44h] [ebp-28h]
  unsigned int v22; // [esp+48h] [ebp-24h]
  unsigned int v23; // [esp+4Ch] [ebp-20h]
  int v24; // [esp+50h] [ebp-1Ch]
  int v25; // [esp+54h] [ebp-18h]
  unsigned int v26; // [esp+58h] [ebp-14h]
  int v27; // [esp+5Ch] [ebp-10h]
  int v28; // [esp+60h] [ebp-Ch] BYREF
  int v29; // [esp+64h] [ebp-8h] BYREF
  int v30; // [esp+68h] [ebp-4h] BYREF

  v4 = a1;
  if ( !a1 )
    return -2005530516;
  v27 = (*(int (__stdcall **)(int))(*(_DWORD *)a1 + 40))(a1);
  if ( v27 != 3 && (unsigned int)(v27 - 4) >= 2 )
    return -2005530516;
  v25 = v4;
  if ( a4 != -1 )
    goto LABEL_16;
  if ( v27 == 3 )
  {
    (*(void (__stdcall **)(int, _DWORD, _BYTE *))(*(_DWORD *)v25 + 56))(v25, 0, v19);
    if ( ((v20 - 1) & v20) == 0 && ((v21 - 1) & v21) == 0 )
      goto LABEL_26;
    a4 = 0;
    goto LABEL_25;
  }
  if ( v27 == 4 )
  {
    (*(void (__stdcall **)(int, _DWORD, char *))(*(_DWORD *)v25 + 56))(v25, 0, v15);
    if ( ((v16 - 1) & v16) != 0 || ((v17 - 1) & v17) != 0 )
      goto LABEL_15;
    v6 = v18;
LABEL_14:
    if ( ((v6 - 1) & v6) != 0 )
      goto LABEL_15;
LABEL_26:
    a4 = 5;
    goto LABEL_16;
  }
  if ( v27 != 5 )
  {
LABEL_25:
    if ( !a4 )
      goto LABEL_15;
    goto LABEL_26;
  }
  (*(void (__stdcall **)(int, _DWORD, _BYTE *))(*(_DWORD *)v25 + 56))(v25, 0, v19);
  if ( ((v20 - 1) & v20) == 0 )
  {
    v6 = v21;
    goto LABEL_14;
  }
LABEL_15:
  a4 = 524292;
LABEL_16:
  if ( v27 == 5 )
    BYTE2(a4) |= 7u;
  v7 = (*(int (__stdcall **)(int))(*(_DWORD *)v4 + 52))(v4);
  v23 = v7;
  if ( a3 == -1 )
    a3 = 0;
  if ( a3 >= v7 )
    return -2005530516;
  a1 = 0;
  v29 = 0;
  v30 = 0;
  v28 = 0;
  v22 = v27 != 5 ? 1 : 6;
  if ( (unsigned __int8)a4 == 2 || (v24 = 0, (unsigned __int8)a4 == 5) )
    v24 = 1;
  v26 = 0;
  v8 = a4;
  do
  {
    switch ( v27 )
    {
      case 3:
        v10 = &a1;
        goto LABEL_37;
      case 4:
        v10 = &v29;
LABEL_37:
        v9 = (*(int (__stdcall **)(int, unsigned int, int *))(*(_DWORD *)v25 + 60))(v25, a3, v10);
        goto LABEL_38;
      case 5:
        v9 = (*(int (__stdcall **)(int, unsigned int, unsigned int, int *))(*(_DWORD *)v25 + 60))(v25, v26, a3, &a1);
LABEL_38:
        v8 = v9;
        break;
    }
    if ( v8 < 0 )
      goto LABEL_75;
    v11 = a3;
    while ( ++v11 < v23 )
    {
      if ( v27 == 3 )
      {
        v13 = &v30;
        goto LABEL_47;
      }
      if ( v27 == 4 )
      {
        v13 = &v28;
LABEL_47:
        v12 = (*(int (__stdcall **)(int, unsigned int, int *))(*(_DWORD *)v25 + 60))(v25, v11, v13);
        goto LABEL_48;
      }
      if ( v27 != 5 )
        goto LABEL_49;
      v12 = (*(int (__stdcall **)(int, unsigned int, unsigned int, int *))(*(_DWORD *)v25 + 60))(v25, v26, v11, &v30);
LABEL_48:
      v8 = v12;
LABEL_49:
      if ( v8 < 0 )
        goto LABEL_75;
      switch ( v27 )
      {
        case 3:
LABEL_53:
          v14 = FUN_1000bbfc(v30, a2, 0, a1, a2, 0, a4, 0);
LABEL_54:
          v8 = v14;
          break;
        case 4:
          v14 = FUN_1000bda2(v28, (int)a2, 0, v29, (int)a2, 0, a4, 0);
          goto LABEL_54;
        case 5:
          goto LABEL_53;
      }
      if ( v8 < 0 )
        goto LABEL_75;
      if ( v24 )
      {
        if ( a1 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
          a1 = 0;
        }
        if ( v29 )
          (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
        a1 = v30;
        v30 = 0;
        v29 = v28;
LABEL_67:
        v28 = 0;
      }
      else
      {
        if ( v30 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
          v30 = 0;
        }
        if ( v28 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
          goto LABEL_67;
        }
      }
    }
    if ( a1 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
      a1 = 0;
    }
    if ( v29 )
    {
      (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
      v29 = 0;
    }
    ++v26;
  }
  while ( v26 < v22 );
  v8 = 0;
LABEL_75:
  if ( a1 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)a1 + 8))(a1);
    a1 = 0;
  }
  if ( v29 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
    v29 = 0;
  }
  if ( v30 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v30 + 8))(v30);
    v30 = 0;
  }
  if ( v28 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v28 + 8))(v28);
  return v8;
}

// FUN_1000c4e9 @ 0x1000C4E9
// [binja] int32_t sub_1000c4e9(int32_t** arg1, void* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, void* arg9, int32_t arg10, int32_t arg11, int32_t** arg12)
int __cdecl sub_1000C4E9(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        int a6,
        unsigned int a7,
        int a8,
        int a9,
        unsigned int a10,
        int a11,
        int a12,
        int a13,
        char *a14,
        void *a15,
        int a16,
        int *a17)
{
  char *v17; // esi
  int v18; // edi
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // esi
  _DWORD *v23; // eax
  int v24; // eax
  unsigned int v25; // eax
  unsigned int v26; // ecx
  int v27; // esi
  int v28; // eax
  int v29; // esi
  int v30; // ebx
  int v31; // eax
  int v32; // eax
  int v33; // ebx
  int *v34; // esi
  int v35; // eax
  int *v36; // ecx
  int v37; // eax
  int v38; // eax
  int *v39; // ecx
  int v40; // eax
  int v41; // ecx
  _DWORD v43[256]; // [esp+Ch] [ebp-4CCh] BYREF
  char v44; // [esp+40Ch] [ebp-CCh] BYREF
  _DWORD v45[9]; // [esp+428h] [ebp-B0h] BYREF
  int v46[2]; // [esp+44Ch] [ebp-8Ch] BYREF
  int v47; // [esp+454h] [ebp-84h]
  int v48; // [esp+458h] [ebp-80h]
  int v49; // [esp+45Ch] [ebp-7Ch]
  int v50; // [esp+460h] [ebp-78h]
  int v51; // [esp+498h] [ebp-40h]
  int v52; // [esp+49Ch] [ebp-3Ch]
  int *v53; // [esp+4A0h] [ebp-38h]
  int v54; // [esp+4A4h] [ebp-34h]
  int v55; // [esp+4A8h] [ebp-30h]
  unsigned int v56; // [esp+4ACh] [ebp-2Ch]
  unsigned int v57; // [esp+4B0h] [ebp-28h]
  unsigned int v58; // [esp+4B4h] [ebp-24h]
  int v59; // [esp+4B8h] [ebp-20h] BYREF
  int v60; // [esp+4BCh] [ebp-1Ch] BYREF
  int v61; // [esp+4C0h] [ebp-18h] BYREF
  int v62; // [esp+4C4h] [ebp-14h] BYREF
  unsigned int v63; // [esp+4C8h] [ebp-10h]
  int v64; // [esp+4D4h] [ebp-4h]

  v17 = a14;
  FUN_10010285(v46);
  v64 = 0;
  v61 = 0;
  v62 = 0;
  v60 = 0;
  v59 = 0;
  if ( !a1 || !a2 || !a3 || !a17 )
  {
    v18 = -2005530516;
    goto LABEL_148;
  }
  if ( !v17 && a16 == -1 )
    v17 = &v44;
  v19 = FUN_10012677(a2, a3, v17, 1);
  if ( v19 < 0 )
  {
    v18 = v19;
    goto LABEL_148;
  }
  if ( a16 == -1 )
    a16 = *((_DWORD *)v17 + 5);
  v20 = v51;
  v58 = 1;
  while ( v20 )
  {
    ++v58;
    v20 = *(_DWORD *)(v20 + 76);
  }
  v57 = 1;
  if ( a16 == 5 )
  {
    v21 = v52;
    if ( !v52 )
      goto LABEL_20;
    do
    {
      v21 = *(_DWORD *)(v21 + 80);
      ++v57;
    }
    while ( v21 );
    if ( v57 != 6 )
    {
LABEL_20:
      v18 = -2147467259;
      goto LABEL_148;
    }
  }
  if ( !a4 || a4 == -1 )
    a4 = v48;
  if ( !a5 || a5 == -1 )
    a5 = v49;
  if ( !a6 || a6 == -1 )
    a6 = v50;
  if ( a11 == -1 )
    a11 = 524292;
  if ( a12 == -1 )
    a12 = 5;
  if ( a16 == 5 )
  {
    a11 |= 0x70000u;
    a12 |= 0x70000u;
  }
  if ( (_BYTE)a11 == 1 || (unsigned __int8)a12 == 2 || (v55 = 0, (unsigned __int8)a12 == 5) )
    v55 = 1;
  if ( !a9 )
  {
    v22 = v46[0];
    if ( a13 )
    {
      v23 = grim_format_info_lookup(v46[0]);
      if ( v23[1] <= 2u && !v23[4] )
      {
        qmemcpy(v45, v23, sizeof(v45));
        v45[0] = 0;
        v45[4] = 1;
        v22 = sub_1000ABAD(0, a8, a16, v45);
        if ( !v22 )
          v22 = v46[0];
      }
    }
    v24 = sub_1000AC8F(v22);
    a9 = v24;
    if ( a10 != 3 && v24 == 20 )
      a9 = 22;
  }
  if ( v47 )
  {
    v25 = a13 & 0xFF00FF00 | ((unsigned __int8)a13 << 16) | BYTE2(a13);
    v26 = 0;
    v27 = v47 - (_DWORD)v43;
    do
    {
      v43[v26] = v25 != *(_DWORD *)((char *)&v43[v26] + v27) ? *(_DWORD *)((char *)&v43[v26] + v27) : 0;
      ++v26;
    }
    while ( v26 < 0x100 );
    a13 = 0;
  }
  else
  {
    memset(v43, 0xFFu, sizeof(v43));
  }
  if ( !a15 )
  {
    if ( a9 != 40 )
    {
      if ( a9 != 41 )
        goto LABEL_63;
      a9 = 22;
      v28 = 0;
      while ( HIBYTE(v43[v28]) == 0xFF )
      {
        if ( (unsigned int)++v28 >= 0x100 )
          goto LABEL_63;
      }
    }
    a9 = 21;
    goto LABEL_63;
  }
  qmemcpy(a15, v43, 0x400u);
LABEL_63:
  if ( a10 || (v54 = 1, (a8 & 0x200) != 0) )
    v54 = 0;
  v18 = sub_1000AF45(a8, a1, (unsigned int *)&a4, (unsigned int *)&a5, (unsigned int *)&a6, &a7, &a9, a10, a16);
  if ( v18 < 0 )
    goto LABEL_140;
  v29 = a9;
  v30 = a4;
  switch ( a16 )
  {
    case 3:
      v31 = (*(int (__stdcall **)(int, int, int, unsigned int, int, int, unsigned int, int *))(*(_DWORD *)a1 + 80))(
              a1,
              a4,
              a5,
              a7,
              a8,
              a9,
              a10,
              &v60);
      break;
    case 4:
      v31 = (*(int (__stdcall **)(int, int, int, int, unsigned int, int, int, unsigned int, int *))(*(_DWORD *)a1 + 84))(
              a1,
              a4,
              a5,
              a6,
              a7,
              a8,
              a9,
              a10,
              &v60);
      break;
    case 5:
      v31 = (*(int (__stdcall **)(int, int, unsigned int, int, int, unsigned int, int *))(*(_DWORD *)a1 + 88))(
              a1,
              a4,
              a7,
              a8,
              a9,
              a10,
              &v60);
      break;
    default:
      goto LABEL_74;
  }
  v18 = v31;
LABEL_74:
  if ( v18 < 0 )
    goto LABEL_140;
  if ( !v54 )
  {
    v33 = v60;
    goto LABEL_86;
  }
  switch ( a16 )
  {
    case 3:
      v32 = (*(int (__stdcall **)(int, int, int, unsigned int, _DWORD, int, int, int *))(*(_DWORD *)a1 + 80))(
              a1,
              v30,
              a5,
              a7,
              0,
              v29,
              2,
              &v59);
      break;
    case 4:
      v32 = (*(int (__stdcall **)(int, int, int, int, unsigned int, _DWORD, int, int, int *))(*(_DWORD *)a1 + 84))(
              a1,
              v30,
              a5,
              a6,
              a7,
              0,
              v29,
              2,
              &v59);
      break;
    case 5:
      v32 = (*(int (__stdcall **)(int, int, unsigned int, _DWORD, int, int, int *))(*(_DWORD *)a1 + 88))(
              a1,
              v30,
              a7,
              0,
              v29,
              2,
              &v59);
      break;
    default:
      goto LABEL_83;
  }
  v18 = v32;
LABEL_83:
  if ( v18 >= 0 )
  {
    v33 = v59;
LABEL_86:
    v56 = 0;
    v34 = v46;
    v53 = v46;
    if ( v57 )
    {
      while ( 1 )
      {
        v63 = 0;
        if ( v58 )
        {
          while ( 1 )
          {
            if ( v63 >= a7 )
              goto LABEL_111;
            if ( a16 == 3 )
              break;
            if ( a16 == 4 )
            {
              v36 = &v61;
LABEL_95:
              v35 = (*(int (__stdcall **)(int, unsigned int, int *))(*(_DWORD *)v33 + 60))(v33, v63, v36);
              goto LABEL_96;
            }
            if ( a16 != 5 )
              goto LABEL_97;
            v35 = (*(int (__stdcall **)(int, unsigned int, unsigned int, int *))(*(_DWORD *)v33 + 60))(
                    v33,
                    v56,
                    v63,
                    &v62);
LABEL_96:
            v18 = v35;
LABEL_97:
            if ( v18 < 0 )
              goto LABEL_140;
            if ( a16 != 3 )
            {
              if ( a16 == 4 )
              {
                v37 = FUN_1000ae72(v61, (int)a15, 0, v34[1], *v34, v34[12], v34[13], (int)v43, v34 + 6, a11, a13);
                goto LABEL_102;
              }
              if ( a16 != 5 )
                goto LABEL_103;
            }
            v37 = FUN_1000acc0(v62, (int)a15, 0, v34[1], *v34, v34[12], (int)v43, v34 + 6, a11, a13);
LABEL_102:
            v18 = v37;
LABEL_103:
            if ( v18 < 0 )
              goto LABEL_140;
            if ( v61 )
            {
              (*(void (__stdcall **)(int))(*(_DWORD *)v61 + 8))(v61);
              v61 = 0;
            }
            if ( v62 )
            {
              (*(void (__stdcall **)(int))(*(_DWORD *)v62 + 8))(v62);
              v62 = 0;
            }
            if ( ++v63 >= v58 )
              goto LABEL_111;
            v34 = (int *)v34[19];
          }
          v36 = &v62;
          goto LABEL_95;
        }
LABEL_111:
        if ( !v55 && v63 < a7 )
          break;
LABEL_133:
        ++v56;
        v34 = (int *)v53[20];
        v53 = v34;
        if ( v56 >= v57 )
          goto LABEL_134;
      }
      while ( a16 != 3 )
      {
        if ( a16 == 4 )
        {
          v39 = &v61;
LABEL_119:
          v38 = (*(int (__stdcall **)(int, unsigned int, int *))(*(_DWORD *)v33 + 60))(v33, v63, v39);
          goto LABEL_120;
        }
        if ( a16 != 5 )
          goto LABEL_121;
        v38 = (*(int (__stdcall **)(int, unsigned int, unsigned int, int *))(*(_DWORD *)v33 + 60))(v33, v56, v63, &v62);
LABEL_120:
        v18 = v38;
LABEL_121:
        if ( v18 < 0 )
          goto LABEL_140;
        switch ( a16 )
        {
          case 3:
LABEL_125:
            v40 = FUN_1000acc0(v62, (int)a15, 0, v34[1], *v34, v34[12], (int)v43, v34 + 6, a11, a13);
LABEL_126:
            v18 = v40;
            break;
          case 4:
            v40 = FUN_1000ae72(v61, (int)a15, 0, v34[1], *v34, v34[12], v34[13], (int)v43, v34 + 6, a11, a13);
            goto LABEL_126;
          case 5:
            goto LABEL_125;
        }
        if ( v18 < 0 )
          goto LABEL_140;
        if ( v61 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)v61 + 8))(v61);
          v61 = 0;
        }
        if ( v62 )
        {
          (*(void (__stdcall **)(int))(*(_DWORD *)v62 + 8))(v62);
          v62 = 0;
        }
        if ( ++v63 >= a7 )
          goto LABEL_133;
      }
      v39 = &v62;
      goto LABEL_119;
    }
LABEL_134:
    if ( !v55 || v58 >= a7 || (v18 = FUN_1000c205(v33, v43, v58 - 1, a12), v18 >= 0) )
    {
      if ( !v54 || (v18 = (*(int (__stdcall **)(int, int, int))(*(_DWORD *)a1 + 116))(a1, v59, v60), v18 >= 0) )
      {
        v41 = v60;
        v60 = 0;
        *a17 = v41;
        v18 = 0;
      }
    }
  }
LABEL_140:
  if ( v61 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v61 + 8))(v61);
    v61 = 0;
  }
  if ( v62 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v62 + 8))(v62);
    v62 = 0;
  }
  if ( v60 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v60 + 8))(v60);
    v60 = 0;
  }
  if ( v59 )
  {
    (*(void (__stdcall **)(int))(*(_DWORD *)v59 + 8))(v59);
    v59 = 0;
  }
LABEL_148:
  v64 = -1;
  FUN_1001029e(v46);
  return v18;
}

// FUN_1000cb5c @ 0x1000CB5C
// [binja] int32_t __stdcall sub_1000cb5c(int32_t** arg1, void* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, void* arg8, int32_t arg9, int32_t arg10, int32_t** arg11, int32_t arg12, int32_t arg13, int32_t arg14, int32_t arg15)
int __stdcall sub_1000CB5C(
        int a1,
        int a2,
        int a3,
        int a4,
        int a5,
        unsigned int a6,
        int a7,
        int a8,
        unsigned int a9,
        int a10,
        int a11,
        int a12,
        char *a13,
        void *a14,
        int *a15)
{
  return FUN_1000c4e9(a1, a2, a3, a4, a5, 1, a6, a7, a8, a9, a10, a11, a12, a13, a14, 3, a15);
}

// FUN_1000cb9c @ 0x1000CB9C
// [binja] int32_t __stdcall sub_1000cb9c(int32_t** arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, void* arg7, int32_t arg8, int32_t arg9, int32_t** arg10, int32_t arg11, int32_t arg12, int32_t arg13, int32_t arg14)
int __stdcall sub_1000CB9C(
        int a1,
        LPCWCH lpWideCharStr,
        int a3,
        int a4,
        unsigned int a5,
        int a6,
        int a7,
        unsigned int a8,
        int a9,
        int a10,
        int a11,
        char *a12,
        void *a13,
        int *a14)
{
  int v14; // eax
  int v15; // esi
  _BYTE v17[8]; // [esp+4h] [ebp-10h] BYREF
  int v18; // [esp+Ch] [ebp-8h]
  int v19; // [esp+10h] [ebp-4h]

  FUN_1001bca5(v17);
  v14 = FUN_1001bcb7(lpWideCharStr, 0);
  if ( v14 >= 0 )
    v14 = FUN_1000cb5c(a1, v18, v19, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14);
  v15 = v14;
  FUN_1001bed2(v17);
  return v15;
}

// float_near_equal @ 0x1000CBFF
// returns 1 when |a-b| < 1.1920929e-07 (FLT_EPSILON)
BOOL __cdecl sub_1000CBFF(float a1, float a2)
{
  double v2; // st7

  v2 = a1 - a2;
  return v2 >= -0.00000011920929 && v2 <= 0.00000011920929;
}

// sub_1000CC2C @ 0x1000CC2C
int sub_1000CC2C()
{
  grim_select_renderer_backend(1u);
  return off_10053D10();
}

// FUN_1000cc3f @ 0x1000CC3F
// [binja] int32_t __stdcall sub_1000cc3f(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000CC3F(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053C9C(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cc69 @ 0x1000CC69
// [binja] float* __stdcall sub_1000cc69(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000CC69(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float v12; // [esp+24h] [ebp+1Ch]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v10 = v8 + v8 - v6 * 3.0 + 1.0;
  v11 = v8 - (v6 + v6) + a6;
  v12 = v6 * 3.0 - (v8 + v8);
  v9 = v8 - v6;
  *a1 = v10 * *a2 + v11 * *a3 + v12 * *a4 + v9 * *a5;
  a1[1] = v9 * a5[1] + v12 * a4[1] + v11 * a3[1] + v10 * a2[1];
  return a1;
}

// FUN_1000ccf7 @ 0x1000CCF7
// [binja] int32_t __stdcall sub_1000ccf7(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000CCF7(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D14(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cd21 @ 0x1000CD21
// [binja] float* __stdcall sub_1000cd21(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000CD21(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float v12; // [esp+24h] [ebp+1Ch]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v10 = v6 * 2.0 - v8 - a6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  v12 = v6 * 4.0 - v8 * 3.0 + a6;
  v9 = v8 - v6;
  *a1 = (v10 * *a2 + v11 * *a3 + v12 * *a4 + v9 * *a5) * 0.5;
  a1[1] = (v9 * a5[1] + v12 * a4[1] + v11 * a3[1] + v10 * a2[1]) * 0.5;
  return a1;
}

// FUN_1000cdd0 @ 0x1000CDD0
// [binja] int32_t __stdcall sub_1000cdd0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int __stdcall sub_1000CDD0(int a1, int a2, int a3, int a4, float a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D18(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cdff @ 0x1000CDFF
// [binja] float* __stdcall sub_1000cdff(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *__stdcall sub_1000CDFF(float *a1, float *a2, float *a3, float *a4, float a5, float a6)
{
  *a1 = (*a3 - *a2) * a5 + (*a4 - *a2) * a6 + *a2;
  a1[1] = (a3[1] - a2[1]) * a5 + (a4[1] - a2[1]) * a6 + a2[1];
  return a1;
}

// sub_1000CE42 @ 0x1000CE42
int sub_1000CE42()
{
  grim_select_renderer_backend(1u);
  return off_10053C58();
}

// sub_1000CE69 @ 0x1000CE69
int sub_1000CE69()
{
  grim_select_renderer_backend(1u);
  return off_10053C74();
}

// sub_1000CE7C @ 0x1000CE7C
int __stdcall sub_1000CE7C(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D1C(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cea6 @ 0x1000CEA6
// [binja] float* __stdcall sub_1000cea6(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000CEA6(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float v12; // [esp+24h] [ebp+1Ch]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v10 = v8 + v8 - v6 * 3.0 + 1.0;
  v11 = v8 - (v6 + v6) + a6;
  v12 = v6 * 3.0 - (v8 + v8);
  v9 = v8 - v6;
  *a1 = v10 * *a2 + v11 * *a3 + v12 * *a4 + v9 * *a5;
  a1[1] = v9 * a5[1] + v12 * a4[1] + v11 * a3[1] + v10 * a2[1];
  a1[2] = v9 * a5[2] + v12 * a4[2] + v11 * a3[2] + v10 * a2[2];
  return a1;
}

// FUN_1000cf54 @ 0x1000CF54
// [binja] int32_t __stdcall sub_1000cf54(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000CF54(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D20(a1, a2, a3, a4, a5, a6);
}

// FUN_1000cf7e @ 0x1000CF7E
// [binja] float* __stdcall sub_1000cf7e(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000CF7E(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float v12; // [esp+24h] [ebp+1Ch]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v10 = v6 * 2.0 - v8 - a6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  v12 = v6 * 4.0 - v8 * 3.0 + a6;
  v9 = v8 - v6;
  *a1 = (v10 * *a2 + v11 * *a3 + v12 * *a4 + v9 * *a5) * 0.5;
  a1[1] = (v9 * a5[1] + v12 * a4[1] + v11 * a3[1] + v10 * a2[1]) * 0.5;
  a1[2] = (v9 * a5[2] + v12 * a4[2] + v11 * a3[2] + v10 * a2[2]) * 0.5;
  return a1;
}

// FUN_1000d04f @ 0x1000D04F
// [binja] int32_t __stdcall sub_1000d04f(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int __stdcall sub_1000D04F(int a1, int a2, int a3, int a4, float a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D24(a1, a2, a3, a4, a5, a6);
}

// FUN_1000d07e @ 0x1000D07E
// [binja] float* __stdcall sub_1000d07e(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *__stdcall sub_1000D07E(float *a1, float *a2, float *a3, float *a4, float a5, float a6)
{
  *a1 = (*a3 - *a2) * a5 + (*a4 - *a2) * a6 + *a2;
  a1[1] = (a3[1] - a2[1]) * a5 + (a4[1] - a2[1]) * a6 + a2[1];
  a1[2] = (a3[2] - a2[2]) * a5 + (a4[2] - a2[2]) * a6 + a2[2];
  return a1;
}

// sub_1000D0E8 @ 0x1000D0E8
float *__stdcall sub_1000D0E8(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[4] * a2[1] + *a2 * *a3 + a3[12];
  v5 = a3[9] * a2[2] + a3[5] * a2[1] + a3[1] * *a2 + a3[13];
  v6 = a3[10] * a2[2] + a3[6] * a2[1] + a3[2] * *a2 + a3[14];
  v7 = a3[11] * a2[2] + a3[7] * a2[1] + a3[3] * *a2 + a3[15];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// sub_1000D173 @ 0x1000D173
int sub_1000D173()
{
  grim_select_renderer_backend(1u);
  return off_10053C80();
}

// sub_1000D193 @ 0x1000D193
float *__stdcall sub_1000D193(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-Ch]
  float v5; // [esp+Ch] [ebp-8h]
  float v6; // [esp+10h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[4] * a2[1] + *a2 * *a3;
  v5 = a3[9] * a2[2] + a3[5] * a2[1] + a3[1] * *a2;
  v6 = a3[10] * a2[2] + a3[6] * a2[1] + a3[2] * *a2;
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  return a1;
}

// sub_1000D1F9 @ 0x1000D1F9
int sub_1000D1F9()
{
  grim_select_renderer_backend(1u);
  return off_10053C90();
}

// sub_1000D20A @ 0x1000D20A
int sub_1000D20A()
{
  grim_select_renderer_backend(1u);
  return off_10053C94();
}

// sub_1000D228 @ 0x1000D228
float *__stdcall sub_1000D228(float *a1, float *a2, float *a3, float *a4)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  double v10; // st6
  float v12; // [esp+8h] [ebp-1Ch]
  float v13; // [esp+Ch] [ebp-18h]
  float v14; // [esp+10h] [ebp-14h]
  float v15; // [esp+14h] [ebp-10h]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  float v18; // [esp+20h] [ebp-4h]
  float v19; // [esp+30h] [ebp+Ch]
  float v20; // [esp+34h] [ebp+10h]
  float v21; // [esp+38h] [ebp+14h]

  v6 = a4[3] * a3[2];
  v8 = a3[3] * a4[2];
  v20 = a4[3] * a3[1] - a3[3] * a4[1];
  v17 = a3[1] * a4[2];
  v18 = a3[2] * a4[1];
  v12 = (v6 - v8) * a2[1] - v20 * a2[2] + (v17 - v18) * a2[3];
  v19 = a3[3] * *a4;
  v21 = a4[3] * *a3;
  v16 = *a4 * a3[2] - *a3 * a4[2];
  v13 = (v8 - v6) * *a2 - (v19 - v21) * a2[2] + v16 * a2[3];
  v9 = *a3 * a4[1];
  v10 = *a4 * a3[1];
  v14 = v20 * *a2 - (v21 - v19) * a2[1] + (v9 - v10) * a2[3];
  v15 = (v18 - v17) * *a2 - v16 * a2[1] + (v10 - v9) * a2[2];
  *a1 = v12;
  a1[1] = v13;
  a1[2] = v14;
  a1[3] = v15;
  return a1;
}

// sub_1000D325 @ 0x1000D325
int __stdcall sub_1000D325(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D28(a1, a2, a3, a4, a5, a6);
}

// FUN_1000d34f @ 0x1000D34F
// [binja] float* __stdcall sub_1000d34f(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000D34F(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st6
  double v10; // st5
  double v11; // st4
  double v12; // st3
  float v13; // [esp+0h] [ebp-Ch]
  float v14; // [esp+4h] [ebp-8h]
  float v15; // [esp+8h] [ebp-4h]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v15 = v8;
  v13 = v8 + v8;
  v14 = 3.0 * v6;
  v9 = v13 - v14 + 1.0;
  v10 = v15 - (v6 + v6) + a6;
  v11 = v14 - v13;
  v12 = v15 - v6;
  *a1 = v9 * *a2 + v10 * *a3 + v11 * *a4 + v12 * *a5;
  a1[1] = v12 * a5[1] + v11 * a4[1] + v10 * a3[1] + v9 * a2[1];
  a1[2] = v12 * a5[2] + v11 * a4[2] + v10 * a3[2] + v9 * a2[2];
  a1[3] = v12 * a5[3] + v11 * a4[3] + v10 * a3[3] + v9 * a2[3];
  return a1;
}

// FUN_1000d420 @ 0x1000D420
// [binja] int32_t __stdcall sub_1000d420(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000D420(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D2C(a1, a2, a3, a4, a5, a6);
}

// FUN_1000d44a @ 0x1000D44A
// [binja] float* __stdcall sub_1000d44a(float* arg1, float* arg2, float* arg3, float* arg4, float* arg5, float arg6)
float *__stdcall sub_1000D44A(float *a1, float *a2, float *a3, float *a4, float *a5, float a6)
{
  double v6; // st7
  double v8; // st6
  double v9; // st7
  float v10; // [esp+0h] [ebp-8h]
  float v11; // [esp+4h] [ebp-4h]
  float v12; // [esp+24h] [ebp+1Ch]

  v6 = a6 * a6;
  v8 = a6 * v6;
  v10 = v6 * 2.0 - v8 - a6;
  v11 = v8 * 3.0 - v6 * 5.0 + 2.0;
  v12 = v6 * 4.0 - v8 * 3.0 + a6;
  v9 = v8 - v6;
  *a1 = (v10 * *a2 + v11 * *a3 + v12 * *a4 + v9 * *a5) * 0.5;
  a1[1] = (v9 * a5[1] + v12 * a4[1] + v11 * a3[1] + v10 * a2[1]) * 0.5;
  a1[2] = (v9 * a5[2] + v12 * a4[2] + v11 * a3[2] + v10 * a2[2]) * 0.5;
  a1[3] = (v9 * a5[3] + v12 * a4[3] + v11 * a3[3] + v10 * a2[3]) * 0.5;
  return a1;
}

// FUN_1000d53d @ 0x1000D53D
// [binja] int32_t __stdcall sub_1000d53d(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
int __stdcall sub_1000D53D(int a1, int a2, int a3, int a4, float a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D30(a1, a2, a3, a4, a5, a6);
}

// FUN_1000d56c @ 0x1000D56C
// [binja] float* __stdcall sub_1000d56c(float* arg1, float* arg2, float* arg3, float* arg4, float arg5, float arg6)
float *__stdcall sub_1000D56C(float *a1, float *a2, float *a3, float *a4, float a5, float a6)
{
  *a1 = (*a3 - *a2) * a5 + (*a4 - *a2) * a6 + *a2;
  a1[1] = (a3[1] - a2[1]) * a5 + (a4[1] - a2[1]) * a6 + a2[1];
  a1[2] = (a3[2] - a2[2]) * a5 + (a4[2] - a2[2]) * a6 + a2[2];
  a1[3] = (a3[3] - a2[3]) * a5 + (a4[3] - a2[3]) * a6 + a2[3];
  return a1;
}

// sub_1000D5F0 @ 0x1000D5F0
float *__stdcall sub_1000D5F0(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[12] * a2[3] + a3[4] * a2[1] + a3[8] * a2[2] + *a2 * *a3;
  v5 = a3[13] * a2[3] + a3[5] * a2[1] + a3[1] * *a2 + a3[9] * a2[2];
  v6 = a3[14] * a2[3] + a3[6] * a2[1] + a3[2] * *a2 + a3[10] * a2[2];
  v7 = a3[15] * a2[3] + a3[7] * a2[1] + a3[3] * *a2 + a3[11] * a2[2];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// sub_1000D69C @ 0x1000D69C
double __stdcall sub_1000D69C(float *a1)
{
  double v2; // st7
  double v3; // st6
  double v4; // st5
  double v5; // st4
  double v6; // st3
  float v8; // [esp+8h] [ebp+8h]

  v2 = a1[10] * a1[15] - a1[14] * a1[11];
  v3 = a1[15] * a1[9] - a1[13] * a1[11];
  v4 = a1[14] * a1[9] - a1[10] * a1[13];
  v5 = a1[8] * a1[15] - a1[12] * a1[11];
  v6 = a1[14] * a1[8] - a1[12] * a1[10];
  v8 = a1[8] * a1[13] - a1[12] * a1[9];
  return (v2 * a1[5] - v3 * a1[6] + v4 * a1[7]) * *a1
       - (v2 * a1[4] - v5 * a1[6] + v6 * a1[7]) * a1[1]
       + (v3 * a1[4] - v5 * a1[5] + v8 * a1[7]) * a1[2]
       - (v4 * a1[4] - v6 * a1[5] + v8 * a1[6]) * a1[3];
}

// sub_1000D766 @ 0x1000D766
int sub_1000D766()
{
  grim_select_renderer_backend(1u);
  return off_10053C64();
}

// sub_1000D779 @ 0x1000D779
float *__stdcall sub_1000D779(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // esi
  char v5; // [esp+4h] [ebp-40h] BYREF

  result = a1;
  if ( a1 == a2 || (v4 = a1, a1 == a3) )
    v4 = (float *)&v5;
  *v4 = a2[3] * a3[12] + *a2 * *a3 + a2[2] * a3[8] + a3[4] * a2[1];
  v4[1] = a2[1] * a3[5] + a2[3] * a3[13] + a2[2] * a3[9] + a3[1] * *a2;
  v4[2] = a2[3] * a3[14] + a3[2] * *a2 + a2[2] * a3[10] + a3[6] * a2[1];
  v4[3] = a2[3] * a3[15] + a3[11] * a2[2] + *a2 * a3[3] + a3[7] * a2[1];
  v4[4] = a2[7] * a3[12] + a2[4] * *a3 + a3[4] * a2[5] + a2[6] * a3[8];
  v4[5] = a2[6] * a3[9] + a2[7] * a3[13] + a3[5] * a2[5] + a3[1] * a2[4];
  v4[6] = a3[6] * a2[5] + a2[7] * a3[14] + a3[2] * a2[4] + a2[6] * a3[10];
  v4[7] = a3[7] * a2[5] + a2[7] * a3[15] + a2[6] * a3[11] + a2[4] * a3[3];
  v4[8] = a2[11] * a3[12] + a2[8] * *a3 + a3[4] * a2[9] + a2[10] * a3[8];
  v4[9] = a2[11] * a3[13] + a2[10] * a3[9] + a3[5] * a2[9] + a3[1] * a2[8];
  v4[10] = a3[6] * a2[9] + a3[2] * a2[8] + a2[11] * a3[14] + a2[10] * a3[10];
  v4[11] = a2[11] * a3[15] + a2[10] * a3[11] + a3[7] * a2[9] + a2[8] * a3[3];
  v4[12] = a2[15] * a3[12] + a2[12] * *a3 + a3[4] * a2[13] + a2[14] * a3[8];
  v4[13] = a2[15] * a3[13] + a2[14] * a3[9] + a3[5] * a2[13] + a3[1] * a2[12];
  v4[14] = a3[6] * a2[13] + a3[2] * a2[12] + a2[15] * a3[14] + a2[14] * a3[10];
  v4[15] = a2[15] * a3[15] + a2[14] * a3[11] + a3[7] * a2[13] + a2[12] * a3[3];
  if ( v4 != a1 )
    qmemcpy(a1, v4, 0x40u);
  return result;
}

// sub_1000D9AF @ 0x1000D9AF
int sub_1000D9AF()
{
  grim_select_renderer_backend(1u);
  return off_10053CEC();
}

// sub_1000D9C2 @ 0x1000D9C2
int __stdcall sub_1000D9C2(int a1, int a2)
{
  double v2; // st7
  int result; // eax
  double v4; // st7
  double v5; // st7
  double v6; // st7
  double v7; // st7
  double v8; // st7

  v2 = *(float *)(a2 + 4);
  result = a1;
  *(float *)(a1 + 4) = *(float *)(a2 + 16);
  *(float *)(a1 + 16) = v2;
  v4 = *(float *)(a2 + 8);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 32);
  *(float *)(a1 + 32) = v4;
  v5 = *(float *)(a2 + 12);
  *(_DWORD *)(a1 + 12) = *(_DWORD *)(a2 + 48);
  *(float *)(a1 + 48) = v5;
  v6 = *(float *)(a2 + 24);
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 36);
  *(float *)(a1 + 36) = v6;
  v7 = *(float *)(a2 + 28);
  *(_DWORD *)(a1 + 28) = *(_DWORD *)(a2 + 52);
  *(float *)(a1 + 52) = v7;
  v8 = *(float *)(a2 + 44);
  *(_DWORD *)(a1 + 44) = *(_DWORD *)(a2 + 56);
  *(float *)(a1 + 56) = v8;
  if ( a1 != a2 )
  {
    *(_DWORD *)a1 = *(_DWORD *)a2;
    *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 20);
    *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 40);
    *(_DWORD *)(a1 + 60) = *(_DWORD *)(a2 + 60);
  }
  return result;
}

// sub_1000DA3C @ 0x1000DA3C
float *__stdcall sub_1000DA3C(float *a1, float *a2, float *a3)
{
  float *result; // eax
  float *v4; // esi
  char v5; // [esp+4h] [ebp-40h] BYREF

  result = a1;
  if ( a1 == a2 || (v4 = a1, a1 == a3) )
    v4 = (float *)&v5;
  *v4 = a2[3] * a3[12] + *a2 * *a3 + a2[2] * a3[8] + a3[4] * a2[1];
  v4[1] = a2[4] * *a3 + a3[12] * a2[7] + a3[8] * a2[6] + a3[4] * a2[5];
  v4[2] = a2[10] * a3[8] + a2[9] * a3[4] + a3[12] * a2[11] + a2[8] * *a3;
  v4[3] = a2[13] * a3[4] + a2[15] * a3[12] + *a3 * a2[12] + a2[14] * a3[8];
  v4[4] = a3[9] * a2[2] + a3[1] * *a2 + a3[13] * a2[3] + a2[1] * a3[5];
  v4[5] = a3[13] * a2[7] + a3[9] * a2[6] + a2[5] * a3[5] + a2[4] * a3[1];
  v4[6] = a2[9] * a3[5] + a3[13] * a2[11] + a3[9] * a2[10] + a2[8] * a3[1];
  v4[7] = a2[13] * a3[5] + a3[13] * a2[15] + a3[9] * a2[14] + a3[1] * a2[12];
  v4[8] = a3[10] * a2[2] + a3[2] * *a2 + a2[1] * a3[6] + a3[14] * a2[3];
  v4[9] = a3[14] * a2[7] + a3[10] * a2[6] + a2[5] * a3[6] + a2[4] * a3[2];
  v4[10] = a2[9] * a3[6] + a3[14] * a2[11] + a3[10] * a2[10] + a2[8] * a3[2];
  v4[11] = a2[13] * a3[6] + a3[14] * a2[15] + a3[10] * a2[14] + a3[2] * a2[12];
  v4[12] = a3[11] * a2[2] + a3[3] * *a2 + a2[1] * a3[7] + a3[15] * a2[3];
  v4[13] = a3[15] * a2[7] + a3[11] * a2[6] + a2[5] * a3[7] + a2[4] * a3[3];
  v4[14] = a2[9] * a3[7] + a3[15] * a2[11] + a3[11] * a2[10] + a2[8] * a3[3];
  v4[15] = a2[13] * a3[7] + a3[15] * a2[15] + a3[11] * a2[14] + a3[3] * a2[12];
  if ( v4 != a1 )
    qmemcpy(a1, v4, 0x40u);
  return result;
}

// sub_1000DC72 @ 0x1000DC72
int sub_1000DC72()
{
  grim_select_renderer_backend(1u);
  return off_10053CA0();
}

// sub_1000DC85 @ 0x1000DC85
int __stdcall sub_1000DC85(float *a1, float *a2, float *a3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st7
  double v7; // st7
  double v8; // st6
  double v9; // st5
  double v10; // st4
  double v11; // st3
  double v12; // st2
  double v13; // st7
  double v14; // st6
  double v15; // st5
  double v16; // st3
  double v17; // st4
  double v18; // st3
  double v19; // st2
  double v20; // st7
  int result; // eax
  float v22; // [esp+8h] [ebp-54h]
  float v23; // [esp+Ch] [ebp-50h]
  float v24; // [esp+10h] [ebp-4Ch]
  float v25; // [esp+14h] [ebp-48h]
  float v26; // [esp+18h] [ebp-44h]
  float v27; // [esp+1Ch] [ebp-40h]
  float v28; // [esp+20h] [ebp-3Ch]
  float v29; // [esp+24h] [ebp-38h]
  float v30; // [esp+28h] [ebp-34h]
  float v31; // [esp+28h] [ebp-34h]
  float v32; // [esp+2Ch] [ebp-30h]
  float v33; // [esp+2Ch] [ebp-30h]
  float v34; // [esp+30h] [ebp-2Ch]
  float v35; // [esp+30h] [ebp-2Ch]
  float v36; // [esp+34h] [ebp-28h]
  float v37; // [esp+34h] [ebp-28h]
  float v38; // [esp+38h] [ebp-24h]
  float v39; // [esp+38h] [ebp-24h]
  float v40; // [esp+3Ch] [ebp-20h]
  float v41; // [esp+3Ch] [ebp-20h]
  float v42; // [esp+3Ch] [ebp-20h]
  float v43; // [esp+40h] [ebp-1Ch]
  float v44; // [esp+40h] [ebp-1Ch]
  float v45; // [esp+44h] [ebp-18h]
  float v46; // [esp+44h] [ebp-18h]
  float v47; // [esp+48h] [ebp-14h]
  float v48; // [esp+48h] [ebp-14h]
  float v49; // [esp+4Ch] [ebp-10h]
  float v50; // [esp+4Ch] [ebp-10h]
  float v51; // [esp+50h] [ebp-Ch]
  float v52; // [esp+50h] [ebp-Ch]
  float v53; // [esp+54h] [ebp-8h]
  float v54; // [esp+54h] [ebp-8h]
  float v55; // [esp+54h] [ebp-8h]
  float v56; // [esp+58h] [ebp-4h]
  float v57; // [esp+58h] [ebp-4h]
  float v58; // [esp+58h] [ebp-4h]
  float v59; // [esp+58h] [ebp-4h]
  float v60; // [esp+6Ch] [ebp+10h]
  float v61; // [esp+6Ch] [ebp+10h]
  float v62; // [esp+6Ch] [ebp+10h]
  float v63; // [esp+6Ch] [ebp+10h]

  v4 = *a3;
  v5 = a3[1];
  v43 = a3[4];
  v40 = a3[5];
  v45 = a3[8];
  v56 = a3[9];
  v47 = a3[12];
  v60 = a3[13];
  v51 = v40 * v4 - v43 * v5;
  v49 = a3[14];
  v53 = v56 * v4 - v45 * v5;
  v34 = v60 * v4 - v47 * v5;
  v29 = v56 * v43 - v45 * v40;
  v30 = v60 * v43 - v47 * v40;
  v6 = v60;
  v61 = a3[15];
  v32 = v6 * v45 - v47 * v56;
  v7 = a3[2];
  v8 = a3[3];
  v9 = a3[6];
  v36 = a3[6];
  v10 = a3[7];
  v41 = a3[7];
  v11 = a3[10];
  v38 = a3[10];
  v12 = a3[11];
  v57 = a3[11];
  v22 = v7 * v29 - v9 * v53 + v11 * v51;
  v23 = v9 * v34 - v49 * v51 - v7 * v30;
  v24 = v7 * v32 - v11 * v34 + v49 * v53;
  v25 = v11 * v30 - v49 * v29 - v9 * v32;
  v26 = v53 * v10 - v51 * v12 - v29 * v8;
  v27 = v30 * v8 - v34 * v10 + v51 * v61;
  v28 = v34 * v12 - v53 * v61 - v32 * v8;
  v35 = v32 * v10 - v30 * v12 + v29 * v61;
  v52 = v7 * v10 - v9 * v8;
  v54 = v7 * v57 - v38 * v8;
  v13 = v7 * v61 - v49 * v8;
  v44 = a3[4];
  v46 = a3[8];
  v14 = v36 * v57 - v38 * v41;
  v15 = v36 * v61 - v49 * v41;
  v16 = v49 * v57;
  v58 = a3[9];
  v48 = a3[12];
  v17 = v38 * v61 - v16;
  v18 = a3[1];
  v19 = a3[5];
  v62 = a3[13];
  v50 = v54 * v19 - v52 * v58 - v14 * v18;
  v39 = v15 * v18 - v13 * v19 + v52 * v62;
  v37 = v13 * v58 - v54 * v62 - v17 * v18;
  v31 = v17 * v19 - v15 * v58 + v14 * v62;
  v63 = v14 * *a3 - v54 * v44 + v52 * v46;
  v59 = v13 * v44 - v52 * v48 - v15 * *a3;
  v42 = *a3 * v17 - v13 * v46 + v54 * v48;
  v20 = v50 * v48 + v39 * v46 + v37 * v44 + v31 * *a3;
  if ( a2 )
    *a2 = v20;
  v55 = 1.0 / v20;
  result = finite(v55);
  if ( result )
  {
    *a1 = v31 * v55;
    a1[1] = v37 * v55;
    a1[2] = v39 * v55;
    a1[3] = v50 * v55;
    v33 = v15 * v46 - v14 * v48 - v17 * v44;
    a1[4] = v33 * v55;
    a1[5] = v42 * v55;
    a1[6] = v59 * v55;
    a1[7] = v63 * v55;
    a1[8] = v35 * v55;
    a1[9] = v28 * v55;
    a1[10] = v27 * v55;
    a1[11] = v26 * v55;
    a1[12] = v25 * v55;
    a1[13] = v24 * v55;
    a1[14] = v23 * v55;
    a1[15] = v22 * v55;
    return (int)a1;
  }
  return result;
}

// FUN_1000e012 @ 0x1000E012
// [binja] int32_t __stdcall sub_1000e012(float arg1, float arg2, float arg3)
int __stdcall sub_1000E012(int a1, float a2, float a3, float a4)
{
  grim_select_renderer_backend(1u);
  return off_10053CDC(a1, a2, a3, a4);
}

// sub_1000E040 @ 0x1000E040
int __stdcall sub_1000E040(int a1, int a2, int a3, int a4)
{
  *(float *)(a1 + 56) = 0.0;
  *(_DWORD *)a1 = a2;
  *(float *)(a1 + 52) = 0.0;
  *(_DWORD *)(a1 + 20) = a3;
  *(float *)(a1 + 48) = 0.0;
  *(_DWORD *)(a1 + 40) = a4;
  *(float *)(a1 + 44) = 0.0;
  *(float *)(a1 + 36) = 0.0;
  *(float *)(a1 + 32) = 0.0;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 16) = 0.0;
  *(float *)(a1 + 12) = 0.0;
  *(float *)(a1 + 8) = 0.0;
  *(float *)(a1 + 4) = 0.0;
  *(float *)(a1 + 60) = 1.0;
  return a1;
}

// FUN_1000e09c @ 0x1000E09C
// [binja] int32_t __stdcall sub_1000e09c(float arg1, float arg2, float arg3)
int __stdcall sub_1000E09C(int a1, float a2, float a3, float a4)
{
  grim_select_renderer_backend(1u);
  return off_10053CC0(a1, a2, a3, a4);
}

// sub_1000E0CA @ 0x1000E0CA
int __stdcall sub_1000E0CA(int a1, int a2, int a3, int a4)
{
  *(float *)(a1 + 44) = 0.0;
  *(_DWORD *)(a1 + 48) = a2;
  *(float *)(a1 + 36) = 0.0;
  *(_DWORD *)(a1 + 52) = a3;
  *(float *)(a1 + 32) = 0.0;
  *(_DWORD *)(a1 + 56) = a4;
  *(float *)(a1 + 28) = 0.0;
  *(float *)(a1 + 24) = 0.0;
  *(float *)(a1 + 16) = 0.0;
  *(float *)(a1 + 12) = 0.0;
  *(float *)(a1 + 8) = 0.0;
  *(float *)(a1 + 4) = 0.0;
  *(float *)(a1 + 60) = 1.0;
  *(float *)(a1 + 40) = 1.0;
  *(float *)(a1 + 20) = 1.0;
  *(float *)a1 = 1.0;
  return a1;
}

// FUN_1000e126 @ 0x1000E126
// [binja] int32_t __stdcall sub_1000e126(float arg1)
int __stdcall sub_1000E126(int a1, float a2)
{
  grim_select_renderer_backend(1u);
  return off_10053CD0(a1, a2);
}

// FUN_1000e142 @ 0x1000E142
// [binja] float* __stdcall sub_1000e142(float* arg1, float arg2)
float *__stdcall sub_1000E142(float *a1, float a2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v3 = cos(a2);
  v4 = sin(a2);
  *a1 = 1.0;
  a1[1] = 0.0;
  a1[6] = v4;
  a1[2] = 0.0;
  a1[3] = 0.0;
  a1[4] = 0.0;
  a1[5] = v3;
  a1[7] = 0.0;
  a1[8] = 0.0;
  a1[9] = -v4;
  a1[10] = v3;
  a1[11] = 0.0;
  a1[12] = 0.0;
  a1[13] = 0.0;
  a1[14] = 0.0;
  a1[15] = 1.0;
  return a1;
}

// FUN_1000e1bc @ 0x1000E1BC
// [binja] int32_t __stdcall sub_1000e1bc(float arg1)
int __stdcall sub_1000E1BC(int a1, float a2)
{
  grim_select_renderer_backend(1u);
  return off_10053CD4(a1, a2);
}

// FUN_1000e1d8 @ 0x1000E1D8
// [binja] float* __stdcall sub_1000e1d8(float* arg1, float arg2)
float *__stdcall sub_1000E1D8(float *a1, float a2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v4 = cos(a2);
  v3 = sin(a2);
  *a1 = v4;
  a1[1] = 0.0;
  a1[2] = -v3;
  a1[3] = 0.0;
  a1[4] = 0.0;
  a1[5] = 1.0;
  a1[6] = 0.0;
  a1[7] = 0.0;
  a1[8] = v3;
  a1[9] = 0.0;
  a1[10] = v4;
  a1[11] = 0.0;
  a1[12] = 0.0;
  a1[13] = 0.0;
  a1[14] = 0.0;
  a1[15] = 1.0;
  return a1;
}

// FUN_1000e253 @ 0x1000E253
// [binja] int32_t __stdcall sub_1000e253(float arg1)
int __stdcall sub_1000E253(int a1, float a2)
{
  grim_select_renderer_backend(1u);
  return off_10053CD8(a1, a2);
}

// FUN_1000e26f @ 0x1000E26F
// [binja] float* __stdcall sub_1000e26f(float* arg1, float arg2)
float *__stdcall sub_1000E26F(float *a1, float a2)
{
  float v3; // [esp+8h] [ebp-8h]
  float v4; // [esp+Ch] [ebp-4h]

  v3 = cos(a2);
  v4 = sin(a2);
  *a1 = v3;
  a1[1] = v4;
  a1[2] = 0.0;
  a1[3] = 0.0;
  a1[4] = -v4;
  a1[5] = v3;
  a1[6] = 0.0;
  a1[7] = 0.0;
  a1[8] = 0.0;
  a1[9] = 0.0;
  a1[10] = 1.0;
  a1[11] = 0.0;
  a1[12] = 0.0;
  a1[13] = 0.0;
  a1[14] = 0.0;
  a1[15] = 1.0;
  return a1;
}

// FUN_1000e2eb @ 0x1000E2EB
// [binja] int32_t __stdcall sub_1000e2eb(int32_t arg1, float arg2)
int __stdcall sub_1000E2EB(int a1, int a2, float a3)
{
  grim_select_renderer_backend(1u);
  return off_10053D00(a1, a2, a3);
}

// FUN_1000e30b @ 0x1000E30B
// [binja] float* __stdcall sub_1000e30b(float* arg1, float arg2, float arg3)
float *__stdcall sub_1000E30B(float *a1, float *a2, float a3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  double v8; // st3
  double v9; // st2
  double v10; // st3
  float v11; // [esp+8h] [ebp-1Ch] BYREF
  float v12; // [esp+Ch] [ebp-18h]
  float v13; // [esp+10h] [ebp-14h]
  float *v14; // [esp+14h] [ebp-10h]
  float *v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+1Ch] [ebp-8h] BYREF
  float v17; // [esp+20h] [ebp-4h] BYREF
  float v18; // [esp+30h] [ebp+Ch]
  float v19; // [esp+34h] [ebp+10h]
  float v20; // [esp+34h] [ebp+10h]

  v15 = &v17;
  v14 = &v16;
  v17 = cos(a3);
  v16 = sin(a3);
  v11 = *a2;
  v19 = 1.0 - v17;
  v12 = a2[1];
  v13 = a2[2];
  sub_1000CE76(&v11, &v11);
  v4 = v19;
  v20 = v12 * v11 * v19;
  v5 = v13;
  v6 = v12 * v13 * v4;
  v7 = v13 * v11 * v4;
  *a1 = v11 * v11 * v4 + v17;
  v8 = v5 * v16;
  a1[1] = v20 + v8;
  v9 = v12 * v16;
  v18 = v9;
  a1[2] = v7 - v9;
  a1[3] = 0.0;
  a1[4] = v20 - v8;
  a1[5] = v12 * v12 * v4 + v17;
  v10 = v11 * v16;
  a1[6] = v10 + v6;
  a1[7] = 0.0;
  a1[8] = v18 + v7;
  a1[9] = v6 - v10;
  a1[10] = v5 * v5 * v4 + v17;
  a1[11] = 0.0;
  a1[12] = 0.0;
  a1[13] = 0.0;
  a1[14] = 0.0;
  a1[15] = 1.0;
  return a1;
}

// sub_1000E40D @ 0x1000E40D
int sub_1000E40D()
{
  grim_select_renderer_backend(1u);
  return off_10053CF0();
}

// sub_1000E420 @ 0x1000E420
float *__stdcall sub_1000E420(float *a1, float *a2)
{
  double v3; // st7
  double v4; // st6
  double v5; // st5
  double v6; // st4
  double v7; // st3
  float *result; // eax
  double v9; // st2
  float v10; // [esp+0h] [ebp-10h]
  float v11; // [esp+4h] [ebp-Ch]
  float v12; // [esp+8h] [ebp-8h]
  float v13; // [esp+Ch] [ebp-4h]
  float v14; // [esp+Ch] [ebp-4h]
  float v15; // [esp+18h] [ebp+8h]
  float v16; // [esp+1Ch] [ebp+Ch]
  float v17; // [esp+1Ch] [ebp+Ch]

  v13 = *a2 * 2.0;
  v16 = a2[1] * 2.0;
  v3 = 2.0 * a2[2];
  v4 = v13 * a2[3];
  v5 = v16 * a2[3];
  v6 = v3 * a2[3];
  v10 = v13 * *a2;
  v14 = v16 * *a2;
  v12 = v3 * *a2;
  v11 = v16 * a2[1];
  v17 = v3 * a2[1];
  v7 = v3 * a2[2];
  result = a1;
  *a1 = 1.0 - v11 - v7;
  a1[1] = v14 + v6;
  a1[2] = v12 - v5;
  a1[3] = 0.0;
  a1[4] = v14 - v6;
  v9 = 1.0 - v10;
  v15 = v9;
  result[5] = v9 - v7;
  result[6] = v17 + v4;
  result[7] = 0.0;
  result[8] = v12 + v5;
  result[9] = v17 - v4;
  result[10] = v15 - v11;
  result[11] = 0.0;
  result[12] = 0.0;
  result[13] = 0.0;
  result[14] = 0.0;
  result[15] = 1.0;
  return result;
}

// FUN_1000e502 @ 0x1000E502
// [binja] int32_t __stdcall sub_1000e502(float arg1, float arg2, float arg3)
int __stdcall sub_1000E502(int a1, float a2, float a3, float a4)
{
  grim_select_renderer_backend(1u);
  return off_10053CF8(a1, a2, a3, a4);
}

// sub_1000E530 @ 0x1000E530
int sub_1000E530()
{
  grim_select_renderer_backend(1u);
  return off_10053CF4();
}

// FUN_1000e541 @ 0x1000E541
// [binja] int32_t __stdcall sub_1000e541(int32_t arg1, float arg2, int32_t arg3, int32_t arg4, int32_t arg5)
int __stdcall sub_1000E541(int a1, float a2, int a3, int a4, int a5)
{
  grim_select_renderer_backend(1u);
  return off_10053CFC(a1, a2, a3, a4, a5);
}

// FUN_1000e568 @ 0x1000E568
// [binja] float* __stdcall sub_1000e568(float* arg1, float arg2, float* arg3, int32_t arg4, float* arg5)
float *__stdcall sub_1000E568(float *a1, float a2, float *a3, int a4, float *a5)
{
  int v6; // [esp+0h] [ebp-50h]
  int v7; // [esp+4h] [ebp-4Ch]
  int v8; // [esp+8h] [ebp-48h]
  _BYTE v9[12]; // [esp+10h] [ebp-40h] BYREF
  _BYTE v10[52]; // [esp+1Ch] [ebp-34h] BYREF

  a1[14] = 0.0;
  a1[13] = 0.0;
  a1[12] = 0.0;
  a1[11] = 0.0;
  a1[9] = 0.0;
  a1[8] = 0.0;
  a1[7] = 0.0;
  a1[6] = 0.0;
  a1[4] = 0.0;
  a1[3] = 0.0;
  a1[2] = 0.0;
  a1[1] = 0.0;
  *a1 = a2;
  a1[5] = a2;
  a1[10] = a2;
  a1[15] = 1.0;
  if ( a4 )
  {
    sub_1000E41A(v9, a4, v6, v7, v8);
    if ( a3 )
    {
      a1[12] = a1[12] - *a3;
      a1[13] = a1[13] - a3[1];
      a1[14] = a1[14] - a3[2];
      sub_1000D773(a1, a1, v10);
      a1[12] = *a3 + a1[12];
      a1[13] = a1[13] + a3[1];
      a1[14] = a3[2] + a1[14];
    }
    else
    {
      sub_1000D773(a1, a1, v10);
    }
  }
  if ( a5 )
  {
    a1[12] = *a5 + a1[12];
    a1[13] = a5[1] + a1[13];
    a1[14] = a5[2] + a1[14];
  }
  return a1;
}

// sub_1000E675 @ 0x1000E675
float *__stdcall sub_1000E675(float *a1, float *a2, float *a3)
{
  long double v3; // st7
  float *result; // eax
  long double v5; // st7
  long double v6; // st7

  v3 = *a1 * *a1 + a1[1] * a1[1] + a1[2] * a1[2] + a1[3] * a1[3];
  result = a2;
  if ( v3 <= 1.1754944e-38 )
  {
    if ( a2 )
    {
      *a2 = 1.0;
      a2[1] = 0.0;
      a2[2] = 0.0;
    }
    result = a3;
    if ( a3 )
      *a3 = 0.0;
  }
  else
  {
    if ( a2 )
    {
      v5 = 1.0 / sqrt(v3);
      *a2 = v5 * *a1;
      a2[1] = v5 * a1[1];
      a2[2] = v5 * a1[2];
    }
    if ( a3 )
    {
      v6 = acos(a1[3]);
      *a3 = v6 + v6;
    }
  }
  return result;
}

// sub_1000E71F @ 0x1000E71F
float *__stdcall sub_1000E71F(float *a1, float *a2)
{
  double v3; // st7
  float *result; // eax
  long double v5; // st6
  double v6; // st7
  double v7; // st6
  int v8; // ebx
  int v9; // edx
  int v10; // edi
  int v11; // esi
  long double v12; // st7
  long double v13; // st6
  long double v14; // st7
  double v15; // st6
  int v16; // ebx
  int v17; // edi
  int v18; // esi
  double v19; // st6
  int v20; // edi
  _DWORD v21[3]; // [esp+0h] [ebp-1Ch]
  float v22; // [esp+Ch] [ebp-10h]
  float v23; // [esp+10h] [ebp-Ch]
  float v24; // [esp+14h] [ebp-8h]
  int v25; // [esp+18h] [ebp-4h]
  int v26; // [esp+24h] [ebp+8h]
  int v27; // [esp+28h] [ebp+Ch]

  v3 = a2[5] + *a2 + a2[10];
  if ( v3 <= 0.0 )
  {
    v21[2] = 0;
    v6 = *a2 - a2[5] - a2[10];
    v22 = v6;
    v21[0] = 1;
    v7 = a2[5];
    v21[1] = 2;
    v23 = v7 - *a2 - a2[10];
    v24 = a2[10] - (a2[5] + *a2);
    v8 = v6 < v23;
    v27 = v8;
    if ( *(&v22 + v8) < (double)v24 )
    {
      v8 = 2;
      v27 = 2;
    }
    v9 = v8;
    result = a1;
    v11 = v21[v8];
    v12 = sqrt(*(&v22 + v8) + 1.0);
    v25 = v21[v8];
    v10 = v25;
    v13 = v12 * 0.5;
    a1[v9] = v13;
    v14 = 0.25 / v13;
    v15 = a2[v11 * 4 + v8] + a2[4 * v8 + v10];
    v16 = 4 * v21[v11] + v27;
    v26 = v21[v11];
    v17 = v21[v11];
    result[v11] = v15 * v14;
    v18 = v17 + v11 * 4;
    v19 = a2[v16] + a2[v17 + v9 * 4];
    v20 = v25;
    result[v26] = v19 * v14;
    result[3] = (a2[v18] - a2[v20 + v26 * 4]) * v14;
  }
  else
  {
    v5 = sqrt(v3 + 1.0) * 0.5;
    a1[3] = v5;
    *a1 = (a2[6] - a2[9]) * (0.25 / v5);
    a1[1] = (a2[8] - a2[2]) * (0.25 / v5);
    a1[2] = (a2[1] - a2[4]) * (0.25 / v5);
    return a1;
  }
  return result;
}

// FUN_1000e853 @ 0x1000E853
// [binja] int32_t __stdcall sub_1000e853(int32_t arg1, float arg2)
int __stdcall sub_1000E853(int a1, int a2, float a3)
{
  grim_select_renderer_backend(1u);
  return off_10053CCC(a1, a2, a3);
}

// FUN_1000e873 @ 0x1000E873
// [binja] float* __stdcall sub_1000e873(float arg1, float arg2, float arg3)
float *__stdcall sub_1000E873(float *a1, int a2, float a3)
{
  float v5[3]; // [esp+0h] [ebp-14h] BYREF
  float *v6; // [esp+10h] [ebp-4h]
  float v7; // [esp+1Ch] [ebp+8h]
  float v8; // [esp+20h] [ebp+Ch]

  sub_1000CE76(v5, a2);
  v6 = a1 + 3;
  v7 = a3 * 0.5;
  *v6 = cos(v7);
  v8 = sin(v7);
  *a1 = v5[0] * v8;
  a1[1] = v5[1] * v8;
  a1[2] = v5[2] * v8;
  return a1;
}

// FUN_1000e8cf @ 0x1000E8CF
// [binja] int32_t __stdcall sub_1000e8cf(float arg1, float arg2, float arg3)
int __stdcall sub_1000E8CF(int a1, float a2, float a3, float a4)
{
  grim_select_renderer_backend(1u);
  return off_10053CBC(a1, a2, a3, a4);
}

// sub_1000E903 @ 0x1000E903
float *__stdcall sub_1000E903(float *a1, float a2, float a3, float a4)
{
  double v5; // st7
  double v6; // st6
  double v7; // st7
  double v8; // st6
  float v9; // [esp+8h] [ebp-18h]
  float v10; // [esp+Ch] [ebp-14h]
  float v11; // [esp+10h] [ebp-10h]
  float v12; // [esp+14h] [ebp-Ch]
  float v13; // [esp+18h] [ebp-8h]
  float v14; // [esp+1Ch] [ebp-4h]
  float v15; // [esp+30h] [ebp+10h]
  float v16; // [esp+30h] [ebp+10h]
  float v17; // [esp+34h] [ebp+14h]

  v9 = a4 * 0.5;
  v14 = cos(v9);
  v17 = sin(v9);
  v15 = a3 * 0.5;
  v12 = cos(v15);
  v10 = sin(v15);
  v16 = a2 * 0.5;
  v13 = cos(v16);
  v11 = sin(v16);
  v5 = v11 * v12;
  v6 = v13 * v10;
  *a1 = v14 * v6 + v5 * v17;
  a1[1] = v5 * v14 - v6 * v17;
  v7 = v13 * v12;
  v8 = v11 * v10;
  a1[2] = v7 * v17 - v8 * v14;
  a1[3] = v8 * v17 + v7 * v14;
  return a1;
}

// sub_1000E9DC @ 0x1000E9DC
int sub_1000E9DC()
{
  grim_select_renderer_backend(1u);
  return off_10053CA4();
}

// sub_1000E9EF @ 0x1000E9EF
float *__stdcall sub_1000E9EF(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = a3[3] * a2[1] - *a3 * a2[2] + a3[1] * a2[3] + a3[2] * *a2;
  v4 = a3[3] * a2[2] + *a3 * a2[1] - a3[1] * *a2 + a3[2] * a2[3];
  v5 = a3[3] * a2[3] - *a3 * *a2 - a3[1] * a2[1] - a3[2] * a2[2];
  *a1 = a3[3] * *a2 + *a3 * a2[3] + a3[1] * a2[2] - a3[2] * a2[1];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_1000EA92 @ 0x1000EA92
float *__stdcall sub_1000EA92(float *a1, float *a2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[4]; // [esp+10h] [ebp-10h] BYREF
  float v8; // [esp+2Ch] [ebp+Ch]

  v2 = a2;
  v8 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3];
  if ( float_near_equal(v8, 1.0) )
  {
    result = a1;
    if ( a1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = a1;
  if ( v8 > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(v8);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v7[2] = v5 * v2[2];
    v6 = v5 * v2[3];
    v2 = v7;
    v7[3] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4++;
    result[2] = *v4;
    result[3] = v4[1];
    return result;
  }
  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  a1[3] = 0.0;
  return result;
}

// sub_1000EB4B @ 0x1000EB4B
int sub_1000EB4B()
{
  grim_select_renderer_backend(1u);
  return off_10053D08();
}

// sub_1000EB5E @ 0x1000EB5E
float *__stdcall sub_1000EB5E(float *a1, float *a2)
{
  float *v3; // ecx
  double v4; // st7
  double v5; // st7
  float v7; // [esp+14h] [ebp+Ch]

  v3 = a1;
  v7 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3];
  if ( v7 <= 1.0842022e-19 )
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    v5 = 0.0;
    goto LABEL_5;
  }
  *a1 = -*a2;
  a1[1] = -a2[1];
  a1[2] = -a2[2];
  a1[3] = a2[3];
  if ( !float_near_equal(v7, 1.0) )
  {
    v4 = 1.0 / v7;
    *v3 = v4 * *v3;
    v3[1] = v4 * v3[1];
    v3[2] = v4 * v3[2];
    v5 = v4 * v3[3];
LABEL_5:
    v3[3] = v5;
  }
  return v3;
}

// sub_1000EC18 @ 0x1000EC18
float *__stdcall sub_1000EC18(float *a1, float *a2)
{
  long double v3; // st7
  bool v4; // zf
  float *result; // eax
  double v6; // st7
  float v7; // [esp+Ch] [ebp-4h]
  float v8; // [esp+1Ch] [ebp+Ch]

  if ( a2[3] >= 1.0 )
  {
    result = a1;
    goto LABEL_5;
  }
  v3 = acos(a2[3]);
  v7 = sin(v3);
  v4 = !float_near_equal(v7, 0.0);
  result = a1;
  if ( !v4 )
  {
LABEL_5:
    *result = *a2;
    result[1] = a2[1];
    result[2] = a2[2];
    goto LABEL_6;
  }
  v8 = v3;
  v6 = v8 / v7;
  *a1 = v6 * *a2;
  a1[1] = v6 * a2[1];
  a1[2] = v6 * a2[2];
LABEL_6:
  result[3] = 0.0;
  return result;
}

// sub_1000EC9C @ 0x1000EC9C
float *__stdcall sub_1000EC9C(float *a1, float *a2)
{
  float *v2; // ecx
  double v3; // st7
  float v5; // [esp+10h] [ebp-4h]
  float v6; // [esp+20h] [ebp+Ch]

  v5 = sqrt(*a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2]);
  a1[3] = cos(v5);
  v6 = sin(v5);
  if ( float_near_equal(v6, 0.0) )
  {
    if ( a1 != v2 )
    {
      *a1 = *v2;
      a1[1] = v2[1];
      a1[2] = v2[2];
    }
  }
  else
  {
    v3 = v6 / v5;
    *a1 = v3 * *v2;
    a1[1] = v3 * v2[1];
    a1[2] = v3 * v2[2];
  }
  return a1;
}

// FUN_1000ed37 @ 0x1000ED37
// [binja] int32_t __stdcall sub_1000ed37(int32_t arg1, int32_t arg2, float arg3)
int __stdcall sub_1000ED37(int a1, int a2, int a3, float a4)
{
  grim_select_renderer_backend(1u);
  return off_10053CE4(a1, a2, a3, a4);
}

// sub_1000ED61 @ 0x1000ED61
float *__stdcall sub_1000ED61(float *a1, float *a2, float *a3, float a4)
{
  double v5; // st7
  double v7; // st6
  double v8; // st5
  long double v9; // st6
  long double v10; // st6
  long double v11; // st6
  float v13; // [esp+0h] [ebp-4h]
  float v14; // [esp+10h] [ebp+Ch]
  float v15; // [esp+14h] [ebp+10h]
  float v16; // [esp+14h] [ebp+10h]

  v5 = 1.0 - a4;
  v7 = *a2 * *a3 + a3[2] * a2[2] + a3[1] * a2[1] + a3[3] * a2[3];
  if ( v7 < 0.0 )
    v14 = -1.0;
  else
    v14 = 1.0;
  v8 = v14 * v7;
  if ( 1.0 - v8 <= 0.00000011920929 )
  {
    v10 = a4;
  }
  else
  {
    v9 = sqrt(1.0 - v8 * v8);
    v15 = v8;
    v16 = atan2(v9, v15);
    v13 = 1.0 / v9;
    v5 = sin(v16 * v5) * v13;
    v10 = sin(v16 * a4) * v13;
  }
  v11 = v10 * v14;
  *a1 = v5 * *a2 + v11 * *a3;
  a1[1] = v11 * a3[1] + v5 * a2[1];
  a1[2] = v11 * a3[2] + v5 * a2[2];
  a1[3] = v11 * a3[3] + v5 * a2[3];
  return a1;
}

// FUN_1000ee44 @ 0x1000EE44
// [binja] int32_t __stdcall sub_1000ee44(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000EE44(int a1, int a2, int a3, int a4, int a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053D04(a1, a2, a3, a4, a5, a6);
}

// FUN_1000ee6e @ 0x1000EE6E
// [binja] int32_t __stdcall sub_1000ee6e(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, float arg6)
int __stdcall sub_1000EE6E(int a1, int a2, int a3, int a4, int a5, float a6)
{
  float v7; // [esp+0h] [ebp-24h]
  int v8[4]; // [esp+4h] [ebp-20h] BYREF
  int v9[4]; // [esp+14h] [ebp-10h] BYREF

  j_FUN_1000ed37((int)v8, a2, a5, a6);
  j_FUN_1000ed37((int)v9, a3, a4, a6);
  v7 = (1.0 - a6) * a6 + (1.0 - a6) * a6;
  j_FUN_1000ed37(a1, (int)v8, (int)v9, v7);
  return a1;
}

// sub_1000EEC5 @ 0x1000EEC5
int sub_1000EEC5()
{
  grim_select_renderer_backend(1u);
  return off_10053D0C();
}

// sub_1000EED6 @ 0x1000EED6
int __stdcall sub_1000EED6(int a1, int a2, int a3, int a4, float a5, float a6)
{
  grim_select_renderer_backend(1u);
  return off_10053CE8(a1, a2, a3, a4, a5, a6);
}

// FUN_1000ef05 @ 0x1000EF05
// [binja] int32_t* __stdcall sub_1000ef05(int32_t* arg1, int32_t* arg2, int32_t arg3, int32_t arg4, float arg5, float arg6)
_DWORD *__stdcall sub_1000EF05(_DWORD *a1, _DWORD *a2, int a3, int a4, float a5, float a6)
{
  float v7; // [esp+4h] [ebp-28h]
  int v8[4]; // [esp+Ch] [ebp-20h] BYREF
  int v9[4]; // [esp+1Ch] [ebp-10h] BYREF
  float v10; // [esp+44h] [ebp+18h]

  v10 = a5 + a6;
  if ( float_near_equal(v10, 0.0) )
  {
    if ( a1 != a2 )
    {
      *a1 = *a2;
      a1[1] = a2[1];
      a1[2] = a2[2];
      a1[3] = a2[3];
    }
  }
  else
  {
    j_FUN_1000ed37((int)v8, (int)a2, a3, v10);
    j_FUN_1000ed37((int)v9, (int)a2, a4, v10);
    v7 = a6 / v10;
    j_FUN_1000ed37((int)a1, (int)v8, (int)v9, v7);
  }
  return a1;
}

// sub_1000EF90 @ 0x1000EF90
int sub_1000EF90()
{
  grim_select_renderer_backend(1u);
  return off_10053CAC();
}

// sub_1000EFA3 @ 0x1000EFA3
float *__stdcall sub_1000EFA3(float *a1, float *a2)
{
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7; // [esp+18h] [ebp+Ch]

  v7 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2];
  if ( float_near_equal(v7, 1.0) )
  {
    result = a1;
    if ( a1 != a2 )
    {
      *a1 = *a2;
      v4 = a2 + 1;
      a1[1] = *v4++;
      a1[2] = *v4;
      a1[3] = v4[1];
    }
  }
  else
  {
    result = a1;
    if ( v7 <= 1.1754944e-38 )
    {
      *a1 = 0.0;
      a1[1] = 0.0;
      a1[2] = 0.0;
      v6 = 0.0;
    }
    else
    {
      v5 = 1.0 / sqrt(v7);
      *a1 = v5 * *a2;
      a1[1] = v5 * a2[1];
      a1[2] = v5 * a2[2];
      v6 = v5 * a2[3];
    }
    a1[3] = v6;
  }
  return result;
}

// sub_1000F054 @ 0x1000F054
float *__stdcall sub_1000F054(float *a1, float *a2, float *a3, float *a4)
{
  double v4; // st7
  double v5; // st6
  float v7; // [esp+1Ch] [ebp+Ch]

  v4 = *a2 * *a3 + a2[1] * a3[1] + a3[2] * a2[2];
  v5 = v4 - (*a2 * *a4 + a4[2] * a2[2] + a2[1] * a4[1]);
  if ( v5 == 0.0 )
    return 0;
  v7 = (v4 + a2[3]) / v5;
  if ( !finite(v7) )
    return 0;
  *a1 = (*a4 - *a3) * v7 + *a3;
  a1[1] = (a4[1] - a3[1]) * v7 + a3[1];
  a1[2] = (a4[2] - a3[2]) * v7 + a3[2];
  return a1;
}

// sub_1000F103 @ 0x1000F103
int __stdcall sub_1000F103(int a1, float *a2, int a3)
{
  *(float *)a1 = *(float *)a3;
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a3 + 4);
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a3 + 8);
  *(float *)(a1 + 12) = -(a2[1] * *(float *)(a3 + 4) + a2[2] * *(float *)(a3 + 8) + *a2 * *(float *)a3);
  return a1;
}

// sub_1000F148 @ 0x1000F148
float *__stdcall sub_1000F148(float *a1, float *a2, float *a3, float *a4)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  float v9; // [esp+Ch] [ebp-18h]
  float v10; // [esp+10h] [ebp-14h]
  float v11; // [esp+14h] [ebp-10h]
  float v12; // [esp+18h] [ebp-Ch]
  float v13; // [esp+1Ch] [ebp-8h]

  v4 = *a2 - *a3;
  v5 = a2[1] - a3[1];
  v6 = a2[2] - a3[2];
  v12 = *a2 - *a4;
  v13 = a2[1] - a4[1];
  v7 = a2[2] - a4[2];
  v9 = v7 * v5 - v13 * v6;
  v10 = v6 * v12 - v7 * v4;
  v11 = v13 * v4 - v12 * v5;
  *a1 = v9;
  a1[1] = v10;
  a1[2] = v11;
  sub_1000CE76(a1, a1);
  a1[3] = -(a1[2] * a2[2] + a1[1] * a2[1] + *a1 * *a2);
  return a1;
}

// sub_1000F1F7 @ 0x1000F1F7
float *__stdcall sub_1000F1F7(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[8] * a2[2] + a3[12] * a2[3] + a3[4] * a2[1] + *a2 * *a3;
  v5 = a3[9] * a2[2] + a3[1] * *a2 + a3[13] * a2[3] + a3[5] * a2[1];
  v6 = a3[10] * a2[2] + a3[2] * *a2 + a3[14] * a2[3] + a3[6] * a2[1];
  v7 = a3[11] * a2[2] + a3[3] * *a2 + a3[15] * a2[3] + a3[7] * a2[1];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// FUN_1000f296 @ 0x1000F296
// [binja] int32_t* __stdcall sub_1000f296(int32_t* arg1, float arg2)
float *__stdcall sub_1000F296(float *a1, float *a2)
{
  float *v2; // ecx
  float *result; // eax
  float v4; // ecx
  long double v5; // st7
  long double v6; // st7
  float v7; // [esp+8h] [ebp-8h]
  float v8; // [esp+Ch] [ebp-4h]
  float v9; // [esp+1Ch] [ebp+Ch]

  v9 = *a2 * *a2 + a2[1] * a2[1];
  if ( float_near_equal(v9, 1.0) )
  {
    result = a1;
    if ( a1 == v2 )
      return result;
    *a1 = *v2;
    v4 = v2[1];
    goto LABEL_4;
  }
  result = a1;
  if ( v9 > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(v9);
    v7 = v5 * *v2;
    v6 = v5 * v2[1];
    *a1 = v7;
    v8 = v6;
    v4 = v8;
LABEL_4:
    result[1] = v4;
    return result;
  }
  *a1 = 0.0;
  a1[1] = 0.0;
  return result;
}

// FUN_1000f323 @ 0x1000F323
// [binja] float* __stdcall sub_1000f323(float* arg1, float* arg2, float* arg3)
float *__stdcall sub_1000F323(float *a1, float *a2, float *a3)
{
  float v4; // [esp+8h] [ebp-10h]
  float v5; // [esp+Ch] [ebp-Ch]
  float v6; // [esp+10h] [ebp-8h]
  float v7; // [esp+14h] [ebp-4h]

  v4 = a3[4] * a2[1] + *a2 * *a3 + a3[12];
  v5 = a3[1] * *a2 + a3[5] * a2[1] + a3[13];
  v6 = a3[2] * *a2 + a3[6] * a2[1] + a3[14];
  v7 = a3[3] * *a2 + a3[7] * a2[1] + a3[15];
  *a1 = v4;
  a1[1] = v5;
  a1[2] = v6;
  a1[3] = v7;
  return a1;
}

// FUN_1000f38e @ 0x1000F38E
// [binja] float* __stdcall sub_1000f38e(float* arg1, float* arg2, float* arg3)
float *__stdcall sub_1000F38E(float *a1, float *a2, float *a3)
{
  double v3; // st6
  double v4; // st7
  bool v5; // zf
  float *result; // eax
  double v7; // st7
  float v8; // [esp+8h] [ebp-4h]

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a3[13];
  v4 = *a2 * a3[3] + a2[1] * a3[7] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a3[12];
  a1[1] = v3;
  v8 = v4;
  v5 = !float_near_equal(v8, 1.0);
  result = a1;
  if ( v5 )
  {
    v7 = 1.0 / v8;
    *a1 = v7 * *a1;
    a1[1] = v7 * a1[1];
  }
  return result;
}

// FUN_1000f40e @ 0x1000F40E
// [binja] float* __stdcall sub_1000f40e(float* arg1, float* arg2, float* arg3)
float *__stdcall sub_1000F40E(float *a1, float *a2, float *a3)
{
  double v3; // st7
  double v4; // st6
  float v6; // [esp+0h] [ebp-8h]
  float v7; // [esp+4h] [ebp-4h]

  v6 = a3[4] * a2[1] + *a2 * *a3;
  v3 = a3[1] * *a2;
  v4 = a3[5] * a2[1];
  *a1 = v6;
  v7 = v3 + v4;
  a1[1] = v7;
  return a1;
}

// FUN_1000f44a @ 0x1000F44A
// [binja] float* __stdcall sub_1000f44a(float* arg1, float arg2)
float *__stdcall sub_1000F44A(float *a1, float *a2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[3]; // [esp+10h] [ebp-Ch] BYREF
  float v8; // [esp+28h] [ebp+Ch]

  v2 = a2;
  v8 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2];
  if ( float_near_equal(v8, 1.0) )
  {
    result = a1;
    if ( a1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = a1;
  if ( v8 > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(v8);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v6 = v5 * v2[2];
    v2 = v7;
    v7[2] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4;
    result[2] = v4[1];
    return result;
  }
  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  return result;
}

// FUN_1000f4ea @ 0x1000F4EA
// [binja] float* __stdcall sub_1000f4ea(float* arg1, float* arg2, float* arg3)
float *__stdcall sub_1000F4EA(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7
  bool v6; // zf
  float *result; // eax
  double v8; // st7
  float v9; // [esp+8h] [ebp-4h]

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a3[12];
  a1[1] = v3;
  a1[2] = v4;
  v9 = v5;
  v6 = !float_near_equal(v9, 1.0);
  result = a1;
  if ( v6 )
  {
    v8 = 1.0 / v9;
    *a1 = v8 * *a1;
    a1[1] = v8 * a1[1];
    a1[2] = v8 * a1[2];
  }
  return result;
}

// FUN_1000f5a9 @ 0x1000F5A9
// [binja] float* __stdcall sub_1000f5a9(float* arg1, int32_t arg2, int32_t* arg3, int32_t* arg4, int32_t* arg5, int32_t* arg6)
float *__stdcall sub_1000F5A9(float *a1, int a2, int a3, float *a4, float *a5, float *a6)
{
  float *v6; // esi
  float *v8; // [esp-4h] [ebp-54h]
  float v9[16]; // [esp+10h] [ebp-40h] BYREF

  v6 = v9;
  switch ( (a4 != 0) | (2 * ((a5 != 0) | (2 * (a6 != 0)))) )
  {
    case 0:
      v9[14] = 0.0;
      v9[13] = 0.0;
      v9[12] = 0.0;
      v9[11] = 0.0;
      v9[9] = 0.0;
      v9[8] = 0.0;
      v9[7] = 0.0;
      v9[6] = 0.0;
      v9[4] = 0.0;
      v9[3] = 0.0;
      v9[2] = 0.0;
      v9[1] = 0.0;
      v9[15] = 1.0;
      v9[10] = 1.0;
      v9[5] = 1.0;
      v9[0] = 1.0;
      break;
    case 1:
      v6 = a4;
      break;
    case 2:
      v6 = a5;
      break;
    case 3:
      sub_1000D773(v9, a5, a4);
      break;
    case 4:
      v6 = a6;
      break;
    case 5:
      v8 = a4;
      goto LABEL_9;
    case 6:
      v8 = a5;
LABEL_9:
      sub_1000D773(v9, a6, v8);
      break;
    case 7:
      sub_1000D773(v9, a6, a5);
      sub_1000D773(v9, v9, a4);
      break;
    default:
      break;
  }
  sub_1000D180(a1, a2, v6);
  if ( a3 )
  {
    *a1 = (*a1 + 1.0) * (double)*(unsigned int *)(a3 + 8) * 0.5 + (double)*(unsigned int *)a3;
    a1[1] = (1.0 - a1[1]) * (double)*(unsigned int *)(a3 + 12) * 0.5 + (double)*(unsigned int *)(a3 + 4);
    a1[2] = (*(float *)(a3 + 20) - *(float *)(a3 + 16)) * a1[2] + *(float *)(a3 + 16);
  }
  return a1;
}

// sub_1000F736 @ 0x1000F736
float *__stdcall sub_1000F736(float *a1, float *a2, int a3, int a4, int a5, int a6)
{
  double v6; // st7
  double v7; // st7
  int v9; // [esp+10h] [ebp-54h]
  float v10[16]; // [esp+24h] [ebp-40h] BYREF

  switch ( (a4 != 0) | (2 * ((a5 != 0) | (2 * (a6 != 0)))) )
  {
    case 0:
      v10[14] = 0.0;
      v10[13] = 0.0;
      v10[12] = 0.0;
      v10[11] = 0.0;
      v10[9] = 0.0;
      v10[8] = 0.0;
      v10[7] = 0.0;
      v10[6] = 0.0;
      v10[4] = 0.0;
      v10[3] = 0.0;
      v10[2] = 0.0;
      v10[1] = 0.0;
      v10[15] = 1.0;
      v10[10] = 1.0;
      v10[5] = 1.0;
      v10[0] = 1.0;
      break;
    case 1:
      sub_1000DC7F(v10, 0, a4);
      break;
    case 2:
      sub_1000DC7F(v10, 0, a5);
      break;
    case 3:
      sub_1000D773(v10, a5, a4);
      goto LABEL_11;
    case 4:
      sub_1000DC7F(v10, 0, a6);
      break;
    case 5:
      v9 = a4;
      goto LABEL_9;
    case 6:
      v9 = a5;
LABEL_9:
      sub_1000D773(v10, a6, v9);
      goto LABEL_11;
    case 7:
      sub_1000D773(v10, a6, a5);
      sub_1000D773(v10, v10, a4);
LABEL_11:
      sub_1000DC7F(v10, 0, v10);
      break;
    default:
      break;
  }
  if ( a3 )
  {
    v6 = *a2 - (double)*(unsigned int *)a3;
    *a1 = v6 / (double)*(unsigned int *)(a3 + 8) + v6 / (double)*(unsigned int *)(a3 + 8) - 1.0;
    v7 = a2[1] - (double)*(unsigned int *)(a3 + 4);
    a1[1] = -(v7 / (double)*(unsigned int *)(a3 + 12) + v7 / (double)*(unsigned int *)(a3 + 12) - 1.0);
    a1[2] = (a2[2] - *(float *)(a3 + 16)) / (*(float *)(a3 + 20) - *(float *)(a3 + 16));
    sub_1000D180(a1, a1, v10);
  }
  else
  {
    sub_1000D180(a1, a2, v10);
  }
  return a1;
}

// FUN_1000f8dc @ 0x1000F8DC
// [binja] float* __stdcall sub_1000f8dc(float* arg1, float arg2)
float *__stdcall sub_1000F8DC(float *a1, float *a2)
{
  float *v2; // esi
  float *result; // eax
  float *v4; // esi
  long double v5; // st7
  long double v6; // st7
  float v7[4]; // [esp+10h] [ebp-10h] BYREF
  float v8; // [esp+2Ch] [ebp+Ch]

  v2 = a2;
  v8 = *a2 * *a2 + a2[1] * a2[1] + a2[2] * a2[2] + a2[3] * a2[3];
  if ( float_near_equal(v8, 1.0) )
  {
    result = a1;
    if ( a1 == v2 )
      return result;
    goto LABEL_3;
  }
  result = a1;
  if ( v8 > 1.1754944e-38 )
  {
    v5 = 1.0 / sqrt(v8);
    v7[0] = v5 * *v2;
    v7[1] = v5 * v2[1];
    v7[2] = v5 * v2[2];
    v6 = v5 * v2[3];
    v2 = v7;
    v7[3] = v6;
LABEL_3:
    *result = *v2;
    v4 = v2 + 1;
    result[1] = *v4++;
    result[2] = *v4;
    result[3] = v4[1];
    return result;
  }
  *a1 = 0.0;
  a1[1] = 0.0;
  a1[2] = 0.0;
  a1[3] = 0.0;
  return result;
}

// FUN_1000f995 @ 0x1000F995
// [binja] int32_t __stdcall sub_1000f995(int32_t arg1, float arg2, float arg3, float arg4)
int __stdcall sub_1000F995(int a1, float a2, float a3, float a4)
{
  int v5[4]; // [esp+Ch] [ebp-10h] BYREF

  j_FUN_1000e8cf((int)v5, a2, a3, a4);
  ((void (__stdcall *)(int, int *))sub_1000E41A)(a1, v5);
  return a1;
}

// FUN_1000f9ce @ 0x1000F9CE
// [binja] float* __stdcall sub_1000f9ce(float* arg1, float* arg2, void* arg3, int32_t* arg4, float* arg5, int32_t arg6, float* arg7)
float *__stdcall sub_1000F9CE(float *a1, float *a2, int a3, float *a4, float *a5, int a6, float *a7)
{
  float v7; // ecx
  int v8; // ecx
  float *v9; // esi
  int v10; // eax
  char *v12; // [esp+Ch] [ebp-D0h]
  int v13; // [esp+10h] [ebp-CCh]
  int v14; // [esp+14h] [ebp-C8h]
  _DWORD v15[16]; // [esp+1Ch] [ebp-C0h] BYREF
  _BYTE v16[4]; // [esp+5Ch] [ebp-80h] BYREF
  char v17; // [esp+60h] [ebp-7Ch] BYREF
  _BYTE v18[52]; // [esp+68h] [ebp-74h] BYREF
  _BYTE v19[4]; // [esp+9Ch] [ebp-40h] BYREF
  _BYTE v20[60]; // [esp+A0h] [ebp-3Ch] BYREF

  if ( a4 )
  {
    if ( a3 )
    {
      *(float *)&v15[14] = 0.0;
      v7 = *a4;
      *(float *)&v15[13] = 0.0;
      *(float *)v15 = v7;
      v8 = *((_DWORD *)a4 + 1);
      *(float *)&v15[12] = 0.0;
      *(float *)&v15[10] = a4[2];
      *(float *)&v15[11] = 0.0;
      v15[5] = v8;
      *(float *)&v15[9] = 0.0;
      *(float *)&v15[8] = 0.0;
      *(float *)&v15[7] = 0.0;
      *(float *)&v15[6] = 0.0;
      *(float *)&v15[4] = 0.0;
      *(float *)&v15[3] = 0.0;
      *(float *)&v15[2] = 0.0;
      *(float *)&v15[1] = 0.0;
      *(float *)&v15[15] = 1.0;
      sub_1000E41A(v16, a3, v12, v13, v14);
      v12 = &v17;
      if ( a2 )
      {
        sub_1000D9BC(v20);
        v9 = a1;
        a1[14] = 0.0;
        a1[13] = 0.0;
        a1[12] = 0.0;
        a1[11] = 0.0;
        a1[9] = 0.0;
        a1[8] = 0.0;
        a1[7] = 0.0;
        a1[6] = 0.0;
        a1[4] = 0.0;
        a1[3] = 0.0;
        a1[2] = 0.0;
        a1[1] = 0.0;
        a1[15] = 1.0;
        a1[10] = 1.0;
        a1[5] = 1.0;
        *a1 = 1.0;
        a1[12] = -*a2;
        a1[13] = -a2[1];
        a1[14] = -a2[2];
        sub_1000D773(a1, a1, v19);
        sub_1000D773(v9, v9, v15);
        sub_1000D773(v9, v9, v16);
        a1[12] = a1[12] + *a2;
        a1[13] = a2[1] + a1[13];
        a1[14] = a1[14] + a2[2];
      }
      else
      {
        v9 = a1;
        sub_1000D9BC(a1);
        sub_1000D773(v9, v9, v15);
        sub_1000D773(v9, v9, v16);
      }
    }
    else
    {
      v9 = a1;
      a1[14] = 0.0;
      a1[13] = 0.0;
      a1[12] = 0.0;
      a1[11] = 0.0;
      a1[9] = 0.0;
      a1[8] = 0.0;
      a1[7] = 0.0;
      a1[6] = 0.0;
      a1[4] = 0.0;
      a1[3] = 0.0;
      a1[2] = 0.0;
      a1[1] = 0.0;
      *a1 = *a4;
      a1[5] = a4[1];
      v10 = *((_DWORD *)a4 + 2);
      a1[15] = 1.0;
      *((_DWORD *)a1 + 10) = v10;
    }
  }
  else
  {
    v9 = a1;
    a1[14] = 0.0;
    a1[13] = 0.0;
    a1[12] = 0.0;
    a1[11] = 0.0;
    a1[9] = 0.0;
    a1[8] = 0.0;
    a1[7] = 0.0;
    a1[6] = 0.0;
    a1[4] = 0.0;
    a1[3] = 0.0;
    a1[2] = 0.0;
    a1[1] = 0.0;
    a1[15] = 1.0;
    a1[10] = 1.0;
    a1[5] = 1.0;
    *a1 = 1.0;
  }
  if ( a6 )
  {
    sub_1000E41A(v16, a6, v12, v13, v14);
    if ( a5 )
    {
      v9[12] = v9[12] - *a5;
      v9[13] = v9[13] - a5[1];
      v9[14] = v9[14] - a5[2];
      sub_1000D773(v9, v9, v18);
      v9[12] = v9[12] + *a5;
      v9[13] = v9[13] + a5[1];
      v9[14] = v9[14] + a5[2];
    }
    else
    {
      sub_1000D773(v9, v9, v18);
    }
  }
  if ( a7 )
  {
    v9[12] = v9[12] + *a7;
    v9[13] = a7[1] + v9[13];
    v9[14] = a7[2] + v9[14];
  }
  return v9;
}

// FUN_1000fc82 @ 0x1000FC82
// [binja] float* __stdcall sub_1000fc82(float* arg1, float* arg2, int32_t arg3)
float *__stdcall sub_1000FC82(float *a1, float *a2, int a3)
{
  double v4; // st7
  double v5; // st6
  double v6; // st5
  double v7; // st4
  double v8; // st3
  float v9; // [esp+8h] [ebp-18h]
  float v10; // [esp+Ch] [ebp-14h]
  float v11; // [esp+10h] [ebp-10h] BYREF
  float v12; // [esp+14h] [ebp-Ch]
  float v13; // [esp+18h] [ebp-8h]
  float v14; // [esp+1Ch] [ebp-4h]

  sub_1000EF9D(&v11, a3);
  v4 = v12 * a2[1] + v11 * *a2 + v14 * a2[3] + v13 * a2[2];
  v5 = -v11;
  v6 = -v12;
  v7 = -v13;
  v9 = v7;
  v8 = -v14;
  v10 = v8;
  *a1 = v5 * *a2 + v4;
  a1[4] = v6 * *a2;
  a1[8] = v7 * *a2;
  a1[12] = v8 * *a2;
  a1[1] = v5 * a2[1];
  a1[5] = v6 * a2[1] + v4;
  a1[9] = v7 * a2[1];
  a1[13] = v8 * a2[1];
  a1[2] = v5 * a2[2];
  a1[6] = v6 * a2[2];
  a1[10] = v7 * a2[2] + v4;
  a1[14] = v8 * a2[2];
  a1[3] = v5 * a2[3];
  a1[7] = v6 * a2[3];
  a1[11] = v9 * a2[3];
  a1[15] = v10 * a2[3] + v4;
  return a1;
}

// FUN_1000fd5c @ 0x1000FD5C
// [binja] float* __stdcall sub_1000fd5c(float* arg1, float arg2)
float *__stdcall sub_1000FD5C(float *a1, int a2)
{
  double v2; // st7
  double v4; // st6
  double v5; // st5
  float v6; // [esp+0h] [ebp-10h] BYREF
  float v7; // [esp+4h] [ebp-Ch]
  float v8; // [esp+8h] [ebp-8h]
  float v9; // [esp+Ch] [ebp-4h]
  float v10; // [esp+1Ch] [ebp+Ch]

  sub_1000EF9D(&v6, a2);
  v2 = v6 * -2.0;
  v4 = v7 * -2.0;
  v5 = v8 * -2.0;
  v10 = v5;
  *a1 = v6 * v2 + 1.0;
  a1[1] = v4 * v6;
  a1[2] = v5 * v6;
  a1[3] = 0.0;
  a1[4] = v7 * v2;
  a1[5] = v7 * v4 + 1.0;
  a1[6] = v5 * v7;
  a1[7] = 0.0;
  a1[8] = v8 * v2;
  a1[9] = v8 * v4;
  a1[10] = v8 * v5 + 1.0;
  a1[11] = 0.0;
  a1[12] = v9 * v2;
  a1[13] = v9 * v4;
  a1[14] = v9 * v10;
  a1[15] = 1.0;
  return a1;
}

// sub_1000FE1B @ 0x1000FE1B
int __stdcall sub_1000FE1B(float *a1, float *a2, float *a3, float *a4, float *a5, float *a6, float *a7)
{
  unsigned __int8 v8; // c0
  unsigned __int8 v9; // c3
  unsigned __int8 v11; // c0
  unsigned __int8 v12; // c3
  unsigned __int8 v14; // c0
  unsigned __int8 v15; // c3
  int result; // eax
  _BYTE v17[16]; // [esp+8h] [ebp-44h] BYREF
  float v18; // [esp+18h] [ebp-34h] BYREF
  float v19; // [esp+1Ch] [ebp-30h]
  float v20; // [esp+20h] [ebp-2Ch]
  float v21; // [esp+24h] [ebp-28h]
  float v22; // [esp+28h] [ebp-24h] BYREF
  float v23; // [esp+2Ch] [ebp-20h]
  float v24; // [esp+30h] [ebp-1Ch]
  float v25; // [esp+34h] [ebp-18h]
  float v26; // [esp+38h] [ebp-14h] BYREF
  float v27; // [esp+3Ch] [ebp-10h]
  float v28; // [esp+40h] [ebp-Ch]
  float v29; // [esp+44h] [ebp-8h]
  float v30; // [esp+48h] [ebp-4h] BYREF
  float v31; // [esp+4Ch] [ebp+0h]
  float v32; // [esp+50h] [ebp+4h]
  float v33; // [esp+54h] [ebp+8h]
  float v34; // [esp+58h] [ebp+Ch] BYREF
  float v35; // [esp+5Ch] [ebp+10h]
  float v36; // [esp+60h] [ebp+14h]
  float v37; // [esp+64h] [ebp+18h]
  float v38; // [esp+68h] [ebp+1Ch] BYREF
  float v39; // [esp+6Ch] [ebp+20h]
  float v40; // [esp+70h] [ebp+24h]
  float v41; // [esp+74h] [ebp+28h]
  float v42; // [esp+78h] [ebp+2Ch] BYREF
  float v43; // [esp+7Ch] [ebp+30h]
  float v44; // [esp+80h] [ebp+34h]
  float v45; // [esp+84h] [ebp+38h]
  float v46; // [esp+88h] [ebp+3Ch] BYREF
  float v47; // [esp+8Ch] [ebp+40h]
  float v48; // [esp+90h] [ebp+44h]
  float v49; // [esp+94h] [ebp+48h]
  float v50; // [esp+98h] [ebp+4Ch] BYREF
  float v51; // [esp+9Ch] [ebp+50h]
  float v52; // [esp+A0h] [ebp+54h]
  float v53; // [esp+A4h] [ebp+58h]

  v22 = *a4;
  v23 = a4[1];
  v24 = a4[2];
  v25 = a4[3];
  v34 = *a5;
  v35 = a5[1];
  v36 = a5[2];
  v37 = a5[3];
  v46 = *a6;
  v47 = a6[1];
  v48 = a6[2];
  v51 = v23 - v35;
  v49 = a6[3];
  v52 = v24 - v36;
  v26 = *a7;
  v27 = a7[1];
  v53 = v25 - v37;
  v28 = a7[2];
  v29 = a7[3];
  if ( !(v8 | v9) )
  {
    v42 = -v22;
    v43 = -v23;
    v44 = -v24;
    v45 = -v25;
    v22 = v42;
    v23 = v43;
    v24 = v44;
    v25 = v45;
  }
  v51 = v35 - v47;
  v52 = v36 - v48;
  v53 = v37 - v49;
  if ( !(v11 | v12) )
  {
    v42 = -v46;
    v43 = -v47;
    v44 = -v48;
    v45 = -v49;
    v46 = v42;
    v47 = v43;
    v48 = v44;
    v49 = v45;
  }
  v51 = v47 - v27;
  v52 = v48 - v28;
  v53 = v49 - v29;
  if ( !(v14 | v15) )
  {
    v42 = -v26;
    v43 = -v27;
    v44 = -v28;
    v45 = -v29;
    v26 = v42;
    v27 = v43;
    v28 = v44;
    v29 = v45;
  }
  sub_1000EB58(&v42, &v34);
  sub_1000E9E9(&v38, &v42, &v22);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v18, &v30);
  sub_1000E9E9(&v38, &v42, &v46);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v50, &v30);
  v39 = v19 + v51;
  v40 = v20 + v52;
  v30 = (v18 + v50) * -0.25;
  v31 = v39 * -0.25;
  v32 = v40 * -0.25;
  v33 = (v21 + v53) * -0.25;
  sub_1000EC96(v17, &v30);
  sub_1000E9E9(&v38, &v34, v17);
  *a1 = v38;
  a1[1] = v39;
  a1[2] = v40;
  a1[3] = v41;
  sub_1000EB58(&v42, &v46);
  sub_1000E9E9(&v38, &v42, &v34);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v18, &v30);
  sub_1000E9E9(&v38, &v42, &v26);
  v30 = v38;
  v31 = v39;
  v32 = v40;
  v33 = v41;
  sub_1000EC12(&v50, &v30);
  v39 = v19 + v51;
  v40 = v20 + v52;
  v30 = (v18 + v50) * -0.25;
  v31 = v39 * -0.25;
  v32 = v40 * -0.25;
  v33 = (v21 + v53) * -0.25;
  sub_1000EC96(v17, &v30);
  result = sub_1000E9E9(&v38, &v46, v17);
  *a2 = v38;
  a2[1] = v39;
  a2[2] = v40;
  a2[3] = v41;
  *a3 = v46;
  a3[1] = v47;
  a3[2] = v48;
  a3[3] = v49;
  return result;
}

// grim_d3d_debug_set_mute @ 0x100101F5
// loads DebugSetMute from d3d8/d3d8d and toggles D3D debug output
HMODULE __cdecl sub_100101F5(int a1)
{
  HMODULE LibraryA; // eax
  HMODULE result; // eax

  if ( DebugSetMute )
    goto LABEL_10;
  if ( !dword_1005DB60 )
  {
    if ( GetModuleHandleA("d3d8.dll") )
    {
      LibraryA = LoadLibraryA("d3d8.dll");
      if ( LibraryA )
        DebugSetMute = (int (__cdecl *)(_DWORD))GetProcAddress(LibraryA, "DebugSetMute");
    }
    result = GetModuleHandleA("d3d8d.dll");
    if ( result )
    {
      result = LoadLibraryA("d3d8d.dll");
      if ( result )
      {
        result = (HMODULE)GetProcAddress(result, "DebugSetMute");
        dword_1005DB60 = (int (*)(void))result;
      }
    }
    if ( !DebugSetMute )
    {
LABEL_11:
      if ( !dword_1005DB60 )
        return result;
      return (HMODULE)dword_1005DB60();
    }
LABEL_10:
    result = (HMODULE)DebugSetMute(a1);
    goto LABEL_11;
  }
  return (HMODULE)dword_1005DB60();
}

// FUN_10010285 @ 0x10010285
// [binja] int32_t* __fastcall sub_10010285(int32_t* arg1)
_DWORD *__thiscall sub_10010285(_DWORD *this)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 14) = 0;
  *(this + 15) = 0;
  *(this + 19) = 0;
  *(this + 20) = 0;
  return this;
}

// FUN_1001029e @ 0x1001029E
// [binja] int32_t __fastcall sub_1001029e(void* arg1)
void __thiscall sub_1001029E(int this)
{
  void *v2; // edi
  void *v3; // esi

  if ( *(_DWORD *)(this + 4) && *(_DWORD *)(this + 56) )
    operator delete(*(void **)(this + 4));
  if ( *(_DWORD *)(this + 8) && *(_DWORD *)(this + 60) )
    operator delete(*(void **)(this + 8));
  v2 = *(void **)(this + 76);
  if ( v2 )
  {
    FUN_1001029e(*(_DWORD *)(this + 76));
    operator delete(v2);
  }
  v3 = *(void **)(this + 80);
  if ( v3 )
  {
    FUN_1001029e(v3);
    operator delete(v3);
  }
}

// FUN_100102f7 @ 0x100102F7
// [binja] void* __thiscall sub_100102f7(void* arg1, char arg2)
void *__thiscall sub_100102F7(void *this, char a2)
{
  FUN_1001029e((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// FUN_10010313 @ 0x10010313
// [binja] int32_t __thiscall sub_10010313(int32_t* arg1, int32_t* arg2)
int __thiscall sub_10010313(char *this, _DWORD *a2)
{
  _DWORD *v3; // edx
  void *v4; // eax
  int v5; // eax

  if ( *((_DWORD *)this + 1) && *((_DWORD *)this + 14) )
    operator delete(*((void **)this + 1));
  if ( *((_DWORD *)this + 2) && *((_DWORD *)this + 15) )
    operator delete(*((void **)this + 2));
  *(_DWORD *)this = a2[1];
  *((_DWORD *)this + 1) = *a2;
  *((_DWORD *)this + 2) = a2[18];
  v3 = this + 24;
  qmemcpy(this + 24, a2 + 10, 0x18u);
  *((_DWORD *)this + 12) = a2[2];
  *((_DWORD *)this + 13) = a2[3];
  v4 = *(void **)this;
  if ( *(_DWORD *)this == 827611204 || v4 == (void *)844388420 )
    goto LABEL_15;
  if ( v4 == (void *)844715353 )
  {
LABEL_14:
    *v3 &= ~1u;
    goto LABEL_16;
  }
  if ( v4 == (void *)861165636 || v4 == (void *)877942852 || v4 == (void *)894720068 )
  {
LABEL_15:
    *v3 &= 0xFFFFFFFC;
    *((_DWORD *)this + 7) &= 0xFFFFFFFC;
    goto LABEL_16;
  }
  if ( v4 == (void *)1498831189 )
    goto LABEL_14;
LABEL_16:
  v5 = *((_DWORD *)this + 8) - *v3;
  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 15) = 0;
  *((_DWORD *)this + 3) = v5;
  *((_DWORD *)this + 4) = *((_DWORD *)this + 9) - *((_DWORD *)this + 7);
  *((_DWORD *)this + 5) = *((_DWORD *)this + 11) - *((_DWORD *)this + 10);
  return 0;
}

// FUN_100103d6 @ 0x100103D6
// [binja] int32_t __thiscall sub_100103d6(int32_t* arg1, void* arg2, void* arg3)
int __thiscall sub_100103D6(int *this, int a2, unsigned int a3)
{
  int *v3; // esi
  int v5; // edi
  unsigned int v6; // ebx
  int v7; // eax
  unsigned __int16 v8; // dx
  int v9; // eax
  int v10; // eax
  unsigned int v11; // eax
  int v12; // edx
  int v13; // ecx
  int v14; // eax
  int v15; // ebx
  void *v16; // eax
  _BYTE *v17; // eax
  int v18; // ecx
  unsigned int i; // edx
  int v20; // eax
  int v21; // eax
  int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // eax
  bool v25; // zf
  char *v26; // ecx
  char *v27; // edx
  int v28; // eax
  unsigned int v29; // ebx
  int v30; // eax
  int v31; // ecx
  unsigned int v32; // eax
  unsigned int v33; // eax
  int v34; // ecx
  int v35; // eax
  int v36; // eax
  char *v37; // edi
  char v38; // si
  unsigned int v39; // ecx
  int v40; // eax
  __int16 v41; // di
  unsigned int j; // ecx
  unsigned int v43; // eax
  char *v44; // esi
  char *v45; // edi
  unsigned int v46; // [esp+4h] [ebp-1Ch]
  unsigned int v47; // [esp+4h] [ebp-1Ch]
  unsigned int v48; // [esp+8h] [ebp-18h]
  int v49; // [esp+8h] [ebp-18h]
  unsigned int v51; // [esp+10h] [ebp-10h]
  unsigned int v52; // [esp+14h] [ebp-Ch]
  int v53; // [esp+18h] [ebp-8h]
  char *v54; // [esp+18h] [ebp-8h]
  unsigned int v55; // [esp+1Ch] [ebp-4h]
  unsigned int v56; // [esp+28h] [ebp+8h]
  unsigned int v57; // [esp+28h] [ebp+8h]
  unsigned int v58; // [esp+28h] [ebp+8h]
  int v59; // [esp+2Ch] [ebp+Ch]
  int v60; // [esp+2Ch] [ebp+Ch]
  char *v61; // [esp+2Ch] [ebp+Ch]

  v3 = this;
  if ( a3 < 0x28 )
    return -2147467259;
  v5 = a2;
  v6 = *(_DWORD *)a2;
  if ( *(_DWORD *)a2 < 0x28u )
    return -2147467259;
  v55 = *(_DWORD *)(a2 + 4);
  v7 = *(_DWORD *)(a2 + 8);
  if ( v7 <= 0 )
    v7 = -v7;
  v8 = *(_WORD *)(a2 + 14);
  v53 = v7;
  v9 = *(_DWORD *)(a2 + 32);
  if ( v8 <= 8u && !v9 )
    v9 = 1 << v8;
  v48 = v6 + 4 * v9;
  if ( v48 > a3 )
    return -2147467259;
  if ( *(_WORD *)(a2 + 12) != 1 )
    return -2147467259;
  if ( *(int *)(a2 + 8) < 0 )
  {
    v10 = *(_DWORD *)(a2 + 16);
    if ( v10 )
    {
      if ( v10 != 3 )
        return -2147467259;
    }
  }
  v11 = *(_DWORD *)(a2 + 16);
  if ( v11 <= 2 )
  {
    LOBYTE(a2) = *(_WORD *)(a2 + 14);
    if ( v8 == 1 || v8 == 4 || v8 == 8 )
    {
      v60 = 41;
      goto LABEL_80;
    }
    if ( v8 != 16 )
    {
      if ( v8 != 24 )
      {
        if ( v8 != 32 )
          return -2147467259;
        goto LABEL_77;
      }
LABEL_43:
      v60 = 20;
      goto LABEL_80;
    }
LABEL_78:
    v60 = 24;
    goto LABEL_80;
  }
  if ( v11 == 3 )
  {
    if ( v6 >= 0x6C )
    {
      v12 = *(_DWORD *)(a2 + 48);
      v13 = *(_DWORD *)(a2 + 44);
      v14 = *(_DWORD *)(a2 + 40);
      v59 = *(_DWORD *)(a2 + 52);
    }
    else
    {
      v59 = 0;
      v12 = *(_DWORD *)(v6 + a2 + 8);
      v13 = *(_DWORD *)(v6 + a2 + 4);
      v14 = *(_DWORD *)(v6 + a2);
    }
    LOWORD(a2) = *(_WORD *)(a2 + 14);
    if ( (unsigned __int16)a2 != 16 )
    {
      if ( (unsigned __int16)a2 != 24 )
      {
        if ( (unsigned __int16)a2 != 32 )
          return -2147467259;
        if ( v12 != 255 )
        {
          if ( v12 == 1072693248 )
          {
            if ( v13 == 1047552 && v14 == 1023 && v59 == -1073741824 )
            {
              v60 = 31;
              goto LABEL_80;
            }
          }
          else if ( !v12 && v13 == -65536 && v14 == 0xFFFF && !v59 )
          {
            v60 = 34;
            goto LABEL_80;
          }
          return -2147467259;
        }
        if ( v13 != 65280 || v14 != 16711680 )
          return -2147467259;
        if ( v59 )
        {
          if ( v59 == -16777216 )
          {
            v60 = 21;
LABEL_80:
            if ( v3[16] && v60 == 41 )
            {
              v15 = *(_DWORD *)(v5 + 32);
              v46 = v15;
              if ( !v15 )
              {
                v15 = 1 << a2;
                v46 = 1 << a2;
              }
              v3[15] = 1;
              v16 = operator new(0x400u);
              v3[2] = (int)v16;
              if ( !v16 )
                return -2147024882;
              v56 = 0;
              v17 = (_BYTE *)(v5 + *(_DWORD *)v5);
              if ( v15 )
              {
                do
                {
                  v18 = 4 * v56;
                  *(_BYTE *)(v18 + v3[2]) = v17[2];
                  *(_BYTE *)(v18 + v3[2] + 1) = v17[1];
                  *(_BYTE *)(v18 + v3[2] + 2) = *v17;
                  *(_BYTE *)(v18 + v3[2] + 3) = -1;
                  ++v56;
                  v15 = v46;
                  v17 += 4;
                }
                while ( v56 < v46 );
              }
              for ( i = v15; i < 0x100; ++i )
              {
                v20 = 4 * i;
                *(_BYTE *)(v20 + v3[2]) = -1;
                *(_BYTE *)(v20 + v3[2] + 1) = -1;
                *(_BYTE *)(v20 + v3[2] + 2) = -1;
                *(_BYTE *)(v20 + v3[2] + 3) = -1;
              }
            }
            if ( *(_WORD *)(v5 + 14) == 1 )
            {
              v23 = (v55 + 7) >> 3;
            }
            else
            {
              if ( *(_WORD *)(v5 + 14) != 4 )
              {
                v21 = v55 * (*(unsigned __int16 *)(v5 + 14) >> 3);
                v22 = v21 + 3;
LABEL_96:
                v52 = v22 & 0xFFFFFFFC;
                v47 = v21;
                *v3 = v60;
                v24 = (v21 + 3) & 0xFFFFFFFC;
                v25 = v3[16] == 0;
                v3[3] = v55;
                v3[12] = v24;
                v3[13] = 0;
                v3[4] = v53;
                v3[5] = 1;
                if ( v25 )
                  return 0;
                if ( *(int *)(v5 + 8) < 0 && *(_WORD *)(v5 + 14) >= 8u )
                {
                  v3[14] = 0;
                  v3[1] = v5 + v48;
                  return 0;
                }
                v3[14] = 1;
                v26 = (char *)operator new(v53 * v24);
                v61 = v26;
                v3[1] = (int)v26;
                if ( !v26 )
                  return -2147024882;
                v27 = (char *)(v48 + v5);
                v28 = v3[12];
                if ( *(int *)(v5 + 8) >= 0 )
                {
                  v49 = -v28;
                  v29 = (unsigned int)&v26[v28 * (v53 - 1)];
                }
                else
                {
                  v49 = v3[12];
                  v29 = (unsigned int)v26;
                }
                v54 = &v26[v53 * v28];
                v30 = *(_DWORD *)(v5 + 16);
                v57 = v29;
                v51 = v29;
                if ( v30 == 2 )
                {
                  if ( v29 >= (unsigned int)v26 )
                  {
                    do
                    {
                      if ( *v27 )
                      {
                        v34 = 0;
                        do
                        {
                          if ( (v34 & 1) != 0 )
                            LOBYTE(v35) = v27[1] & 0xF;
                          else
                            v35 = (unsigned __int8)v27[1] >> 4;
                          *(_BYTE *)(v34 + v29) = v35;
                          ++v34;
                        }
                        while ( v34 < (unsigned __int8)*v27 );
                        v3 = this;
                        v29 += (unsigned __int8)*v27;
                      }
                      else if ( v27[1] )
                      {
                        if ( v27[1] == 1 )
                        {
                          v29 = (unsigned int)&v61[-v3[12]];
                        }
                        else if ( v27[1] == 2 )
                        {
                          v29 += (unsigned __int8)v27[2] - v3[12] * (unsigned __int8)v27[3];
                          v27 += 2;
                        }
                        else
                        {
                          v31 = 0;
                          if ( v27[1] )
                          {
                            do
                            {
                              v32 = (unsigned __int8)v27[(v31 >> 1) + 2];
                              if ( (v31 & 1) != 0 )
                                LOBYTE(v32) = v32 & 0xF;
                              else
                                v32 >>= 4;
                              *(_BYTE *)(v31 + v29) = v32;
                              ++v31;
                            }
                            while ( v31 < (unsigned __int8)v27[1] );
                            v3 = this;
                          }
                          v33 = (unsigned __int8)v27[1];
                          v29 += v33;
                          v27 += ((v33 >> 1) + 1) & 0xFFFFFFFE;
                        }
                      }
                      else
                      {
                        v29 = v51 - v3[12];
                        v51 = v29;
                      }
                      v27 += 2;
                    }
                    while ( v29 >= (unsigned int)v61 );
                  }
                  return 0;
                }
                if ( v30 != 1 )
                {
                  v41 = *(_WORD *)(v5 + 14);
                  if ( v41 == 1 )
                  {
                    while ( v29 >= (unsigned int)v26 && v29 < (unsigned int)v54 )
                    {
                      v58 = 0;
                      if ( v55 )
                      {
                        do
                        {
                          *(_BYTE *)(v58 + v29) = ((unsigned __int8)v27[v58 >> 3] >> (7 - (v58 & 7))) & 1;
                          ++v58;
                        }
                        while ( v58 < v55 );
                        v26 = v61;
                      }
                      v29 += v49;
                      v27 += v52;
                    }
                  }
                  else if ( v41 == 4 )
                  {
                    if ( v29 >= (unsigned int)v26 )
                    {
                      do
                      {
                        if ( v29 >= (unsigned int)v54 )
                          break;
                        for ( j = 0; j < v55; ++j )
                        {
                          v43 = (unsigned __int8)v27[j >> 1];
                          if ( (j & 1) != 0 )
                            LOBYTE(v43) = v43 & 0xF;
                          else
                            v43 >>= 4;
                          *(_BYTE *)(j + v29) = v43;
                        }
                        v29 += v49;
                        v27 += v52;
                      }
                      while ( v29 >= (unsigned int)v61 );
                    }
                  }
                  else
                  {
                    while ( v29 >= (unsigned int)v26 )
                    {
                      if ( v29 >= (unsigned int)v54 )
                        break;
                      v44 = v27;
                      v27 += v52;
                      v45 = (char *)v29;
                      v29 += v49;
                      qmemcpy(v45, v44, v47);
                    }
                  }
                  return 0;
                }
                if ( v29 < (unsigned int)v26 )
                  return 0;
                while ( !*v27 )
                {
                  if ( v27[1] )
                  {
                    if ( v27[1] == 1 )
                    {
                      v29 = (unsigned int)&v61[-v3[12]];
                    }
                    else
                    {
                      if ( v27[1] != 2 )
                      {
                        qmemcpy((void *)v29, v27 + 2, (unsigned __int8)v27[1]);
                        v36 = (unsigned __int8)v27[1];
                        v29 += v36;
                        v27 += (v36 + 1) & 0xFFFFFFFE;
LABEL_140:
                        v3 = this;
                        goto LABEL_141;
                      }
                      v29 += (unsigned __int8)v27[2] - v3[12] * (unsigned __int8)v27[3];
                      v27 += 2;
                    }
                  }
                  else
                  {
                    v29 = v51 - v3[12];
                    v51 = v29;
                  }
LABEL_141:
                  v27 += 2;
                  v57 = v29;
                  if ( v29 < (unsigned int)v61 )
                    return 0;
                }
                v37 = (char *)v29;
                LOBYTE(v29) = v27[1];
                BYTE1(v29) = v29;
                v38 = *v27;
                v39 = (unsigned __int8)*v27 >> 2;
                v40 = v29 << 16;
                LOWORD(v40) = v29;
                memset32(v37, v40, v39);
                memset(&v37[4 * v39], v29, v38 & 3);
                v29 = (unsigned __int8)*v27 + v57;
                goto LABEL_140;
              }
              v23 = (v55 + 1) >> 1;
            }
            v21 = v55;
            v22 = v23 + 3;
            goto LABEL_96;
          }
          return -2147467259;
        }
LABEL_77:
        v60 = 22;
        goto LABEL_80;
      }
      if ( v12 != 255 || v13 != 65280 || v14 != 16711680 || v59 )
        return -2147467259;
      goto LABEL_43;
    }
    if ( v12 == 255 )
    {
      if ( v13 == 255 && v14 == 255 && v59 == 65280 )
      {
        v60 = 51;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v12 != 31 )
    {
      if ( v12 == 15 )
      {
        if ( v13 == 240 && v14 == 3840 )
        {
          if ( v59 == 61440 )
          {
            v60 = 26;
            goto LABEL_80;
          }
          if ( !v59 )
          {
            v60 = 30;
            goto LABEL_80;
          }
        }
      }
      else if ( v12 == 3 && v13 == 28 && v14 == 224 && v59 == 65280 )
      {
        v60 = 29;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v13 == 2016 )
    {
      if ( v14 == 63488 && !v59 )
      {
        v60 = 23;
        goto LABEL_80;
      }
      return -2147467259;
    }
    if ( v13 != 992 || v14 != 31744 )
      return -2147467259;
    if ( v59 )
    {
      if ( v59 == 0x8000 )
      {
        v60 = 25;
        goto LABEL_80;
      }
      return -2147467259;
    }
    goto LABEL_78;
  }
  return -2147467263;
}

// FUN_10010aec @ 0x10010AEC
// [binja] int32_t __thiscall sub_10010aec(int32_t* arg1, HANDLE arg2)
int __thiscall sub_10010AEC(int *this, HANDLE hFile, DWORD NumberOfBytesWritten)
{
  int v4; // eax
  bool v5; // zf
  unsigned int j; // ecx
  int v8; // eax
  int v9; // ecx
  char *v10; // esi
  unsigned int v11; // edi
  int v12; // ecx
  int v13; // eax
  char v14; // dl
  unsigned int i; // esi
  char v16; // cl
  int v17; // eax
  char v18; // cl
  int v19; // ecx
  int v20; // eax
  DWORD v21; // esi
  int v22; // ecx
  int v23; // eax
  char *v24; // edi
  char v25; // [esp+Ch] [ebp-424h] BYREF
  _BYTE v26[1023]; // [esp+Dh] [ebp-423h] BYREF
  _DWORD v27[27]; // [esp+40Ch] [ebp-24h] BYREF
  __int16 Buffer; // [esp+478h] [ebp+48h] BYREF
  DWORD v29; // [esp+47Ah] [ebp+4Ah]
  __int16 v30; // [esp+47Eh] [ebp+4Eh]
  __int16 v31; // [esp+480h] [ebp+50h]
  DWORD v32; // [esp+482h] [ebp+52h]
  unsigned int k; // [esp+488h] [ebp+58h]
  _BYTE v34[4]; // [esp+48Ch] [ebp+5Ch]
  DWORD v35; // [esp+490h] [ebp+60h]
  _BYTE v36[4]; // [esp+494h] [ebp+64h] BYREF
  DWORD nNumberOfBytesToWrite; // [esp+498h] [ebp+68h]
  DWORD v38; // [esp+49Ch] [ebp+6Ch]

  v36[0] = 0;
  v36[1] = 0;
  v36[2] = 0;
  v36[3] = 0;
  LOBYTE(v38) = 0;
  HIBYTE(v38) = -1;
  v34[0] = 0;
  memset(v27, 0, sizeof(v27));
  v4 = *this;
  v5 = *this == 20;
  *(_WORD *)((char *)&v38 + 1) = -21931;
  v34[1] = 36;
  v34[2] = 73;
  v34[3] = 109;
  v35 = -2378094;
  nNumberOfBytesToWrite = 0;
  if ( v5 )
  {
    v27[0] = 40;
    v27[4] = 0;
    HIWORD(v27[3]) = 24;
  }
  else
  {
    switch ( v4 )
    {
      case 27:
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        for ( i = 0; i < 0x100; ++i )
        {
          v16 = v34[i >> 5];
          v17 = 4 * i;
          v26[v17 + 2] = 0;
          v26[v17 + 1] = v16;
          v26[v17] = v34[(i >> 2) & 7];
          v18 = *((_BYTE *)&v38 + (i & 3));
          v26[v17 - 1] = v18;
        }
        break;
      case 41:
        v9 = *(this + 2);
        v10 = (char *)(v9 + 2);
        v11 = 0;
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        v12 = v9 - (_DWORD)v26;
        do
        {
          v13 = 4 * v11;
          v26[v13 + 1] = v26[4 * v11 + v12];
          v26[v13] = *(v10 - 1);
          v14 = *v10;
          v26[v13 + 2] = 0;
          ++v11;
          v10 += 4;
          v26[v13 - 1] = v14;
        }
        while ( v11 < 0x100 );
        break;
      case 50:
        v27[0] = 40;
        v27[4] = 0;
        HIWORD(v27[3]) = 8;
        nNumberOfBytesToWrite = 1024;
        for ( j = 0; j < 0x100; ++j )
        {
          v8 = 4 * j;
          v26[v8 + 2] = 0;
          v26[v8 + 1] = j;
          v26[v8] = j;
          v26[v8 - 1] = j;
        }
        break;
      default:
        return -2147467259;
    }
  }
  v19 = *(this + 3);
  v20 = *(this + 4);
  v27[6] = 2834;
  v27[7] = 2834;
  v27[1] = v19;
  v27[2] = v20;
  v38 = (HIWORD(v27[3]) >> 3) * v19;
  v35 = (v38 + 3) & 0xFFFFFFFC;
  Buffer = 19778;
  v30 = 0;
  v31 = 0;
  k = HIWORD(v27[3]) >> 3;
  v21 = ((v35 * v20 + nNumberOfBytesToWrite + 57) & 0xFFFFFFFC) - (v35 * v20 + nNumberOfBytesToWrite + 54);
  v29 = (v35 * v20 + nNumberOfBytesToWrite + 57) & 0xFFFFFFFC;
  LOWORD(v27[3]) = 1;
  v32 = nNumberOfBytesToWrite + 54;
  if ( NumberOfBytesWritten )
    WriteFile(hFile, &Buffer, 0xEu, &NumberOfBytesWritten, 0);
  WriteFile(hFile, v27, 0x28u, &NumberOfBytesWritten, 0);
  if ( nNumberOfBytesToWrite )
    WriteFile(hFile, &v25, nNumberOfBytesToWrite, &NumberOfBytesWritten, 0);
  v22 = *(this + 12);
  v23 = *(this + 1) + k * *(this + 6) + v22 * *(this + 7);
  v24 = (char *)(v23 + v22 * (*(this + 4) - 1));
  for ( k = v23; (unsigned int)v24 >= k; v24 -= *(this + 12) )
  {
    WriteFile(hFile, v24, v38, &NumberOfBytesWritten, 0);
    if ( v38 < v35 )
      WriteFile(hFile, v36, v35 - v38, &NumberOfBytesWritten, 0);
  }
  if ( v21 )
    WriteFile(hFile, v36, v21, &NumberOfBytesWritten, 0);
  return 0;
}

// sub_10010DD0 @ 0x10010DD0
void __cdecl __noreturn sub_10010DD0(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  longjmp((int *)(*(_DWORD *)a1 + 132), 1);
}

// nullsub_2 @ 0x10010DEC
void nullsub_2()
{
  ;
}

// sub_10010DED @ 0x10010DED
char __cdecl sub_10010DED(int a1)
{
  _DWORD *v1; // eax

  v1 = *(_DWORD **)(a1 + 20);
  *v1 = v1[7];
  v1[1] = v1[8];
  return 1;
}

// sub_10010E02 @ 0x10010E02
_DWORD *__cdecl sub_10010E02(int a1, int a2)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 20);
  *result += a2;
  result[1] -= a2;
  return result;
}

// FUN_10010e13 @ 0x10010E13
// [binja] int32_t __thiscall sub_10010e13(int32_t* arg1, int32_t arg2, int32_t arg3)
int __thiscall sub_10010E13(_DWORD *this, int a2, int a3)
{
  int v3; // esi
  _DWORD *v4; // eax
  unsigned int v5; // eax
  _DWORD *v6; // esi
  unsigned int v7; // ecx
  bool v8; // zf
  unsigned int v9; // eax
  void *v10; // eax
  char *i; // ebx
  int *v12; // esi
  _BYTE *v13; // eax
  int *v14; // ecx
  unsigned __int16 v15; // dx
  int v17; // [esp-4h] [ebp-284h]
  unsigned int v18; // [esp-4h] [ebp-284h]
  void (__cdecl __noreturn *v19[2])(int); // [esp+Ch] [ebp-274h] BYREF
  void (*v20)(); // [esp+14h] [ebp-26Ch]
  char v21[64]; // [esp+90h] [ebp-1F0h] BYREF
  int v22; // [esp+D0h] [ebp-1B0h] BYREF
  int v23; // [esp+D4h] [ebp-1ACh]
  _DWORD *v24; // [esp+E4h] [ebp-19Ch]
  int v25; // [esp+114h] [ebp-16Ch]
  unsigned int v26; // [esp+12Ch] [ebp-154h]
  unsigned int v27; // [esp+130h] [ebp-150h]
  int v28; // [esp+138h] [ebp-148h]
  unsigned int v29; // [esp+148h] [ebp-138h]
  _DWORD *v30; // [esp+278h] [ebp-8h]
  const void **v31; // [esp+27Ch] [ebp-4h]

  v30 = this;
  v22 = sub_1001E027(v19);
  v19[0] = sub_10010DD0;
  v20 = nullsub_2;
  if ( setjmp3(v21, 0, v17) )
    goto LABEL_2;
  sub_1001C265(&v22, 61, 424);
  v4 = (_DWORD *)(*(int (__cdecl **)(int *, _DWORD, int))v23)(&v22, 0, 36);
  v24 = v4;
  v4[8] = a3;
  v4[2] = nullsub_2;
  v4[3] = sub_10010DED;
  v4[4] = sub_10010E02;
  v4[5] = sub_1001DD80;
  v4[6] = nullsub_2;
  v4[1] = 0;
  *v4 = 0;
  v4[7] = a2;
  sub_1001C5DE(&v22, 1);
  if ( !sub_1001BF5E() )
    v25 = 1;
  v20 = (void (*)())sub_1001DF31;
  sub_1001C76E(&v22);
  if ( v28 == 1 )
  {
    v6 = v30;
    v5 = v26;
    *v30 = 50;
    v6[12] = v5;
LABEL_9:
    v6[13] = 0;
    v8 = v6[16] == 0;
    v6[3] = v5;
    v9 = v27;
    v6[4] = v27;
    v6[5] = 1;
    if ( !v8 )
    {
      v18 = v9 * v6[12];
      v6[14] = 1;
      v10 = operator new(v18);
      v6[1] = v10;
      if ( !v10
        || (v31 = (const void **)(*(int (__cdecl **)(int *, int, unsigned int, int))(v23 + 8))(&v22, 1, v28 * v26, 1)) == 0 )
      {
        v3 = -2147024882;
        goto LABEL_25;
      }
      if ( *v6 == 50 )
      {
        for ( i = (char *)v6[1]; v29 < v27; i += v26 )
        {
          sub_1001C6EA(&v22, v31, 1);
          qmemcpy(i, *v31, v26);
        }
      }
      else if ( *v6 == 22 )
      {
        v12 = (int *)v6[1];
        while ( v29 < v27 )
        {
          sub_1001C6EA(&v22, v31, 1);
          v13 = *v31;
          v14 = &v12[v26];
          while ( v12 < v14 )
          {
            HIBYTE(v15) = *v13;
            LOBYTE(v15) = v13[1];
            *v12++ = (unsigned __int8)v13[2] | (v15 << 8);
            v13 += 3;
          }
        }
      }
      sub_1001C537(&v22);
    }
    v3 = 0;
    goto LABEL_25;
  }
  if ( v28 == 3 )
  {
    v5 = v26;
    v6 = v30;
    v7 = 4 * v26;
    *v30 = 22;
    v6[12] = v7;
    goto LABEL_9;
  }
LABEL_2:
  v3 = -2147467259;
LABEL_25:
  sub_1001C325(&v22);
  return v3;
}

// FUN_10011083 @ 0x10011083
// [binja] int32_t __thiscall sub_10011083(int32_t* arg1, void* arg2, int32_t arg3)
int __thiscall sub_10011083(int *this, unsigned __int8 *a2, unsigned int a3)
{
  int *v3; // esi
  unsigned __int8 v6; // cl
  int v7; // edx
  int v8; // eax
  unsigned int v9; // edi
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  unsigned int v17; // eax
  void *v18; // edx
  unsigned int v19; // eax
  unsigned int v20; // eax
  unsigned int v21; // ecx
  int v22; // edx
  unsigned int v23; // eax
  unsigned int v24; // edi
  unsigned int v25; // edx
  unsigned int v26; // edx
  _BYTE *v27; // edi
  unsigned int v28; // ecx
  unsigned int v29; // eax
  bool v30; // zf
  char *v31; // eax
  char *v32; // edx
  unsigned int v33; // eax
  int v34; // ecx
  unsigned int v36; // [esp+Ch] [ebp-30h]
  unsigned int v37; // [esp+Ch] [ebp-30h]
  unsigned int v38; // [esp+10h] [ebp-2Ch]
  int v39; // [esp+14h] [ebp-28h]
  BOOL v40; // [esp+18h] [ebp-24h]
  BOOL v41; // [esp+1Ch] [ebp-20h]
  int v42; // [esp+20h] [ebp-1Ch]
  int v43; // [esp+20h] [ebp-1Ch]
  char v44; // [esp+24h] [ebp-18h]
  unsigned int v45; // [esp+24h] [ebp-18h]
  int v46; // [esp+28h] [ebp-14h]
  int v47; // [esp+28h] [ebp-14h]
  _BYTE *v48; // [esp+2Ch] [ebp-10h]
  int v49; // [esp+30h] [ebp-Ch]
  unsigned int v50; // [esp+34h] [ebp-8h]
  int v51; // [esp+38h] [ebp-4h]
  _BYTE *v52; // [esp+38h] [ebp-4h]
  unsigned __int16 *v53; // [esp+44h] [ebp+8h]
  char *v54; // [esp+44h] [ebp+8h]
  unsigned int v55; // [esp+48h] [ebp+Ch]
  unsigned int v56; // [esp+48h] [ebp+Ch]
  unsigned int v57; // [esp+48h] [ebp+Ch]

  v3 = this;
  if ( a3 < 0x12 )
    return -2147467259;
  v6 = a2[1];
  if ( (v6 & 0xFE) != 0 )
    return -2147467259;
  v7 = a2[2];
  if ( (v7 & 0xFFFFFFF4) != 0 || !*((_WORD *)a2 + 6) || !*((_WORD *)a2 + 7) )
    return -2147467259;
  v8 = a2[7];
  v46 = 0;
  v9 = (unsigned int)(v8 + 7) >> 3;
  if ( v6 )
  {
    v10 = v8 - 15;
    if ( v10 )
    {
      v11 = v10 - 1;
      if ( v11 )
      {
        v12 = v11 - 8;
        if ( v12 )
        {
          if ( v12 != 8 )
            return -2147467259;
          v46 = 21;
        }
        else
        {
          v46 = 20;
        }
      }
      else
      {
        v46 = 25;
      }
    }
    else
    {
      v46 = 24;
    }
  }
  v13 = a2[16];
  v50 = (unsigned int)(v13 + 7) >> 3;
  if ( (v7 & 3) == 1 )
  {
    if ( !a2[1] || a2[16] != 8 )
      return -2147467259;
    v49 = 41;
  }
  else if ( (v7 & 3) == 2 )
  {
    v14 = v13 - 15;
    if ( v14 )
    {
      v15 = v14 - 1;
      if ( v15 )
      {
        v16 = v15 - 8;
        if ( v16 )
        {
          if ( v16 != 8 )
            return -2147467259;
          v49 = 21;
        }
        else
        {
          v49 = 20;
        }
      }
      else
      {
        v49 = 25;
      }
    }
    else
    {
      v49 = 24;
    }
  }
  else
  {
    if ( (v7 & 3) != 3 || a2[16] != 8 )
      return -2147467259;
    v49 = 50;
  }
  v39 = v7 & 8;
  v40 = (a2[17] & 0x20) == 32;
  v17 = *a2;
  v55 = a3 - 18;
  v41 = (a2[17] & 0x10) != 16;
  if ( v55 < v17 )
    return -2147467259;
  v56 = v55 - v17;
  v51 = (int)&a2[v17 + 18];
  v36 = v9 * *(unsigned __int16 *)(a2 + 5);
  if ( v56 < v36 )
    return -2147467259;
  if ( v3[16] && v49 == 41 )
  {
    if ( *(unsigned __int16 *)(a2 + 5) + *(unsigned __int16 *)(a2 + 3) > 256 )
      return -2147467259;
    v18 = operator new(0x400u);
    v3[2] = (int)v18;
    if ( !v18 )
      return -2147024882;
    v3[15] = 1;
    memset(v18, 0xFFu, 0x400u);
    v53 = (unsigned __int16 *)v51;
    v19 = v3[2] + 4 * *(unsigned __int16 *)(a2 + 3);
    v48 = (_BYTE *)v19;
    v38 = v19 + 4 * *(unsigned __int16 *)(a2 + 5);
    if ( v19 < v38 )
    {
      LOBYTE(v20) = v56;
      LOBYTE(v21) = v56;
      while ( 1 )
      {
        LOBYTE(v22) = v44;
        if ( v46 == 20 )
          break;
        switch ( v46 )
        {
          case 21:
            LOBYTE(v21) = BYTE1(*(_DWORD *)v53);
            v42 = HIBYTE(*(_DWORD *)v53);
            LOBYTE(v20) = BYTE2(*(_DWORD *)v53);
            LOBYTE(v22) = *(_DWORD *)v53;
            v53 += 2;
            goto LABEL_50;
          case 24:
            v26 = *v53;
            v20 = (8 * ((v26 >> 10) & 0x1F)) | (((v26 >> 10) & 0x1F) >> 2);
            v21 = (8 * ((v26 >> 5) & 0x1F)) | (((v26 >> 5) & 0x1F) >> 2);
            v22 = (8 * (v26 & 0x1F)) | ((unsigned __int8)(v26 & 0x1F) >> 2);
            ++v53;
LABEL_49:
            LOBYTE(v42) = -1;
            goto LABEL_50;
          case 25:
            v23 = *v53;
            v42 = 255 * (v23 >> 15);
            v24 = v23 & 0x1F;
            v25 = v23 >> 5;
            v20 = (8 * ((v23 >> 10) & 0x1F)) | (((v23 >> 10) & 0x1F) >> 2);
            v21 = (8 * (v25 & 0x1F)) | ((unsigned __int8)(v25 & 0x1F) >> 2);
            v22 = (8 * v24) | (v24 >> 2);
            ++v53;
LABEL_50:
            v44 = v22;
            break;
        }
        v27 = v48;
        v48 += 4;
        v27[2] = v22;
        v27[3] = v42;
        *v27 = v20;
        v27[1] = v21;
        if ( (unsigned int)v48 >= v38 )
          goto LABEL_52;
      }
      LOBYTE(v20) = *((_BYTE *)v53 + 2);
      LOBYTE(v21) = *((_BYTE *)v53 + 1);
      LOBYTE(v22) = *(_BYTE *)v53;
      v53 = (unsigned __int16 *)((char *)v53 + 3);
      goto LABEL_49;
    }
  }
LABEL_52:
  v57 = v56 - v36;
  v28 = v36 + v51;
  v29 = v50 * *((unsigned __int16 *)a2 + 6) * *((unsigned __int16 *)a2 + 7);
  *v3 = v49;
  v3[1] = v36 + v51;
  v30 = v3[16] == 0;
  v3[12] = v50 * *((unsigned __int16 *)a2 + 6);
  v3[13] = 0;
  v3[3] = *((unsigned __int16 *)a2 + 6);
  v52 = (_BYTE *)(v36 + v51);
  v3[4] = *((unsigned __int16 *)a2 + 7);
  v3[5] = 1;
  if ( v30 )
    return 0;
  if ( !v39 && v40 && v41 )
  {
    if ( v57 >= v29 )
    {
      v3[1] = v28;
      v3[14] = 0;
      return 0;
    }
  }
  else
  {
    v31 = (char *)operator new(v29);
    v3[1] = (int)v31;
    if ( !v31 )
      return -2147024882;
    v3[14] = 1;
    if ( v40 )
      v32 = v31;
    else
      v32 = &v31[v3[12] * (*((unsigned __int16 *)a2 + 7) - 1)];
    v47 = 0;
    if ( !*((_WORD *)a2 + 7) )
      return 0;
    while ( 1 )
    {
      v54 = v41 ? v32 : &v32[v3[12] - v50];
      v33 = *((unsigned __int16 *)a2 + 6);
      v45 = 0;
      if ( *((_WORD *)a2 + 6) )
        break;
LABEL_83:
      if ( v40 )
        v32 += v3[12];
      else
        v32 -= v3[12];
      if ( ++v47 >= (unsigned int)*((unsigned __int16 *)a2 + 7) )
        return 0;
    }
    while ( 1 )
    {
      if ( v39 )
      {
        if ( !v57 )
          return -2147467259;
        v34 = *v52 & 0x80;
        v33 = (*v52++ & 0x7F) + 1;
        --v57;
        v43 = v34;
      }
      else
      {
        v43 = 0;
      }
      v45 += v33;
      if ( v33 )
        break;
LABEL_80:
      if ( v43 )
      {
        v52 += v50;
        v57 -= v50;
      }
      v33 = *((unsigned __int16 *)a2 + 6);
      if ( v45 >= v33 )
        goto LABEL_83;
    }
    while ( 1 )
    {
      v37 = v33 - 1;
      if ( v57 < v50 )
        break;
      qmemcpy(v54, v52, v50);
      if ( !v43 )
      {
        v52 += v50;
        v57 -= v50;
      }
      if ( v41 )
        v54 += v50;
      else
        v54 -= v50;
      --v33;
      if ( !v37 )
      {
        v3 = this;
        goto LABEL_80;
      }
    }
  }
  return -2147467259;
}

// FUN_1001152a @ 0x1001152A
// [binja] int32_t __thiscall sub_1001152a(int32_t* arg1, char* arg2, int32_t arg3)
unsigned int __thiscall sub_1001152A(_DWORD *this, _BYTE *a2, unsigned int a3)
{
  _BYTE *v5; // edi
  bool v6; // zf
  int v7; // ebx
  int v8; // ecx
  _BYTE *v9; // eax
  unsigned __int8 *v10; // edi
  unsigned __int8 v11; // al
  int v12; // [esp+8h] [ebp-18h]
  int v13; // [esp+Ch] [ebp-14h]
  _BYTE *v14; // [esp+10h] [ebp-10h]
  _BYTE *v15; // [esp+14h] [ebp-Ch]
  unsigned int v16; // [esp+18h] [ebp-8h]
  int v17; // [esp+1Ch] [ebp-4h]
  unsigned int v18; // [esp+2Ch] [ebp+Ch]
  unsigned int v19; // [esp+2Ch] [ebp+Ch]

  if ( a3 < 2 )
    return -2147467259;
  if ( *a2 != 80 )
    return -2147467259;
  if ( a2[1] == 51 )
  {
    v12 = 1;
  }
  else
  {
    if ( a2[1] != 54 )
      return -2147467259;
    v12 = 0;
  }
  v5 = a2 + 2;
  v6 = a3 == 2;
  v18 = a3 - 2;
  v7 = 0;
  v15 = a2 + 2;
  v17 = 0;
  v13 = 0;
  v16 = 255;
  if ( v6 )
    return -2147467259;
  while ( v12 || v17 != 3 )
  {
    if ( !isspace((unsigned __int8)*v5) )
    {
      if ( *v5 != 35 )
      {
        if ( v18 )
        {
          do
          {
            if ( isspace((unsigned __int8)*v5) )
              break;
            if ( !isdigit((unsigned __int8)*v5) )
              return -2147467259;
            v8 = (unsigned __int8)*v5++;
            v6 = v18-- == 1;
            v7 = v8 + 10 * v7 - 48;
            v15 = v5;
          }
          while ( !v6 );
        }
        if ( v17 )
        {
          if ( v17 == 1 )
          {
            if ( !v7 )
              return -2147467259;
            v9 = operator new(4 * v13 * v7);
            *(this + 1) = v9;
            if ( !v9 )
              return -2147024882;
            a2 = v9;
            *(this + 13) = 0;
            v14 = &v9[4 * v13 * v7];
            v5 = v15;
            *(this + 14) = 1;
            *this = 22;
            *(this + 12) = 4 * v13;
            *(this + 3) = v13;
            *(this + 4) = v7;
            *(this + 5) = 1;
            goto LABEL_39;
          }
          if ( v17 != 2 )
          {
            switch ( v17 )
            {
              case 3:
                if ( a2 >= v14 )
                  return -2147467259;
                *(_DWORD *)a2 = ((255 * v7 / v16) | 0xFFFFFF00) << 16;
                break;
              case 4:
                *(_DWORD *)a2 |= (255 * v7 / v16) << 8;
                break;
              case 5:
                *(_DWORD *)a2 |= 255 * v7 / v16;
                a2 += 4;
                if ( a2 == v14 )
                  return 0;
                v17 = 2;
                break;
            }
            goto LABEL_39;
          }
          v16 = v7;
        }
        else
        {
          v13 = v7;
        }
        if ( !v7 )
          return -2147467259;
LABEL_39:
        ++v17;
        goto LABEL_40;
      }
      for ( ; v18; --v18 )
      {
        if ( *v5 == 10 )
          break;
        ++v5;
      }
    }
    ++v5;
    --v18;
    v15 = v5;
LABEL_40:
    v7 = 0;
    if ( !v18 )
      return -2147467259;
  }
  if ( v16 > 0xFF )
    return -2147467259;
  if ( v18 > 1 && *v5 == 13 )
  {
    ++v5;
    --v18;
  }
  v10 = v5 + 1;
  v19 = v18 - 1;
  if ( v19 )
  {
    do
    {
      if ( a2 >= v14 )
        break;
      v11 = 255 * (unsigned int)*v10 / v16;
      v10 += 3;
      *(_DWORD *)a2 = (255 * (unsigned int)*(v10 - 1) / v16)
                    | (((255 * (unsigned int)*(v10 - 2) / v16) | ((v11 | 0xFFFFFF00) << 8)) << 8);
      v6 = v19 == 3;
      v19 -= 3;
      a2 += 4;
    }
    while ( !v6 );
  }
  return v14 != a2 ? 0x80004005 : 0;
}

// sub_100117B0 @ 0x100117B0
unsigned int __cdecl sub_100117B0(jmp_buf Buf, void *a2, unsigned int a3)
{
  int v3; // ebx

  v3 = Buf[21];
  if ( a3 > *(_DWORD *)(v3 + 4) )
    png_error(Buf, (int)"read error");
  qmemcpy(a2, *(const void **)v3, a3);
  *(_DWORD *)v3 += a3;
  *(_DWORD *)(v3 + 4) -= a3;
  return a3;
}

// sub_100117F3 @ 0x100117F3
void __cdecl __noreturn sub_100117F3(jmp_buf Buf)
{
  longjmp(Buf, 1);
}

// FUN_100117ff @ 0x100117FF
// [binja] int32_t __thiscall sub_100117ff(int32_t* arg1, void* arg2, void* arg3)
int __thiscall sub_100117FF(int *this, int a2, int a3)
{
  int *v3; // eax
  int *v4; // esi
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned __int8 v13; // al
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  bool v19; // zf
  void *v20; // eax
  unsigned int i; // eax
  double v22; // st7
  __int64 v23; // rax
  int v24; // ecx
  bool v25; // cc
  int j; // eax
  void *v27; // eax
  int v28; // eax
  int v29; // edi
  int v30; // ecx
  char v31; // bl
  int v32; // edi
  int v33; // ecx
  int v34; // eax
  int *__attribute__((__org_typedef(jmp_buf))) v35; // [esp+8h] [ebp-168h]
  int v36; // [esp+Ch] [ebp-164h]
  unsigned int v37; // [esp+Ch] [ebp-164h]
  int v38; // [esp+10h] [ebp-160h]
  _BYTE v39[256]; // [esp+1Ch] [ebp-154h]
  double v40; // [esp+11Ch] [ebp-54h] BYREF
  long double v41; // [esp+124h] [ebp-4Ch]
  _DWORD v42[2]; // [esp+12Ch] [ebp-44h] BYREF
  int v43; // [esp+134h] [ebp-3Ch] BYREF
  int v44; // [esp+138h] [ebp-38h] BYREF
  int *v45; // [esp+13Ch] [ebp-34h]
  int v46; // [esp+140h] [ebp-30h] BYREF
  int v47; // [esp+144h] [ebp-2Ch] BYREF
  int v48; // [esp+148h] [ebp-28h] BYREF
  int v49; // [esp+14Ch] [ebp-24h] BYREF
  int v50; // [esp+150h] [ebp-20h] BYREF
  void *v51; // [esp+154h] [ebp-1Ch]
  unsigned int v52; // [esp+158h] [ebp-18h] BYREF
  int v53; // [esp+15Ch] [ebp-14h]
  int v54; // [esp+160h] [ebp-10h] BYREF
  int v55; // [esp+164h] [ebp-Ch]
  int v56; // [esp+168h] [ebp-8h] BYREF
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+16Ch] [ebp-4h] BYREF

  v45 = this;
  Buf = 0;
  v56 = 0;
  v51 = 0;
  if ( sub_100204E3(a2, 0, a3) )
    return -2147467259;
  v3 = (int *)png_create_read_struct("1.0.5", 0, sub_100117F3, nullsub_2);
  Buf = v3;
  if ( !v3 )
    goto LABEL_86;
  v56 = sub_100205E8(v3);
  if ( !v56 )
    goto LABEL_86;
  if ( !setjmp3(Buf, 0, v38) )
  {
    v42[0] = a2;
    v42[1] = a3;
    FUN_100204a4(Buf, v42, sub_100117B0);
    FUN_1001e294(Buf, v56);
    FUN_1001ea59(Buf, v56, &v46, &v52, &v49, &v47, 0, 0, 0);
    v4 = v45;
    if ( v47 )
    {
      switch ( v47 )
      {
        case 2:
          *v45 = 20;
          break;
        case 3:
          *v45 = 41;
          break;
        case 4:
          *v45 = 51;
          break;
        case 6:
          *v45 = 21;
          break;
      }
    }
    else
    {
      *v45 = 50;
    }
    if ( v49 == 16 )
    {
      sub_1001EBCD(Buf);
      switch ( *v4 )
      {
        case 20:
          *v4 = 909201952;
          break;
        case 21:
          *v4 = 909201985;
          break;
        case 50:
          *v4 = 909200416;
          break;
        case 51:
          *v4 = 909200449;
          break;
        default:
          return -2147467259;
      }
    }
    if ( v49 < 8 )
      sub_1001EBDF(Buf);
    if ( !v47 && v49 < 8 )
      sub_1001ED80(Buf);
    if ( sub_1001EA2E(Buf, v56, &v44) )
    {
      sub_100203E1(Buf, v56, v44);
    }
    else if ( sub_1001EA05(Buf, v56, &v40) )
    {
      sub_1001ED4A((int)Buf, 2.2, v40);
    }
    if ( *v4 != 41 && sub_1001E9BF(Buf, v56, 16) )
    {
      sub_1001ED80(Buf);
      v6 = *v4;
      if ( *v4 == 20 )
      {
        *v4 = 21;
      }
      else
      {
        switch ( v6 )
        {
          case 50:
            *v4 = 51;
            break;
          case 909200416:
            *v4 = 909200449;
            break;
          case 909201952:
            *v4 = 909201985;
            break;
        }
      }
    }
    v7 = *v4;
    if ( *v4 == 20 || v7 == 909201952 || v7 == 21 || v7 == 909201985 )
      sub_1001EBC4(Buf);
    if ( *v4 == 20 )
    {
      sub_1001EC11(Buf, 255, 1);
      *v4 = 22;
    }
    FUN_1001e407(Buf, v56);
    v8 = *v4;
    if ( *v4 > 51 )
    {
      v15 = v8 - 909200416;
      if ( !v15 )
      {
LABEL_58:
        v55 = 1;
        goto LABEL_59;
      }
      v16 = v15 - 33;
      if ( v16 )
      {
        v17 = v16 - 1503;
        if ( v17 )
        {
          if ( v17 != 33 )
            goto LABEL_59;
          goto LABEL_65;
        }
LABEL_66:
        v55 = 3;
        goto LABEL_59;
      }
    }
    else if ( *v4 != 51 )
    {
      v9 = v8 - 20;
      if ( v9 )
      {
        v10 = v9 - 1;
        if ( v10 )
        {
          v11 = v10 - 1;
          if ( v11 )
          {
            v12 = v11 - 19;
            if ( !v12 || v12 == 9 )
              goto LABEL_58;
LABEL_59:
            v13 = sub_1001E9EF(Buf, v56);
            if ( v55 != v13 )
              goto LABEL_60;
            v36 = v56;
            v4[3] = v46;
            v35 = Buf;
            v4[4] = v52;
            v4[5] = 1;
            v18 = sub_1001E9D9(v35, v36);
            v19 = v4[16] == 0;
            v4[12] = v18;
            v4[13] = 0;
            if ( !v19 )
            {
              v20 = operator new(v52 * v18);
              v4[1] = (int)v20;
              if ( !v20 || (v37 = 4 * v52, v4[14] = 1, (v51 = operator new(v37)) == 0) )
              {
LABEL_86:
                v14 = -2147024882;
                goto LABEL_97;
              }
              for ( i = 0; i < v52; ++i )
                *((_DWORD *)v51 + i) = v4[1] + i * v4[12];
              FUN_1001e7ce(Buf, (int)v51);
              if ( *v4 == 41 )
              {
                v48 = 0;
                v50 = 0;
                if ( sub_1001E9BF(Buf, v56, 8) )
                  sub_1001EB2A(Buf, v56, &v54, &v50);
                if ( sub_1001E9BF(Buf, v56, 16) )
                  sub_1001EB5D(Buf, v56, &v43, &v48, 0);
                if ( *((float *)Buf + 76) <= 0.000001 || *((float *)Buf + 77) <= 0.000001 )
                {
                  for ( j = 0; j < 256; ++j )
                    v39[j] = j;
                }
                else
                {
                  v22 = *((float *)Buf + 77);
                  v53 = 0;
                  v41 = 1.0 / (v22 * *((float *)Buf + 76));
                  do
                  {
                    v23 = (__int64)(pow((double)v53 * 0.00392156862745098, v41) * 255.0 + 0.5);
                    v24 = v53++;
                    v25 = v53 < 256;
                    v39[v24] = v23;
                  }
                  while ( v25 );
                }
                v27 = operator new(0x400u);
                v4[2] = (int)v27;
                if ( !v27 )
                  goto LABEL_86;
                v28 = 0;
                v25 = v48 <= 0;
                v4[15] = 1;
                if ( !v25 )
                {
                  v29 = 0;
                  do
                  {
                    v30 = 4 * v28;
                    *(_BYTE *)(v30 + v4[2]) = v39[*(unsigned __int8 *)(v29 + v54)];
                    *(_BYTE *)(v4[2] + v30 + 1) = v39[*(unsigned __int8 *)(v29 + v54 + 1)];
                    *(_BYTE *)(v4[2] + v30 + 2) = v39[*(unsigned __int8 *)(v29 + v54 + 2)];
                    v31 = *(_BYTE *)(v28 + v43);
                    ++v28;
                    *(_BYTE *)(v4[2] + v30 + 3) = v31;
                    v29 += 3;
                  }
                  while ( v28 < v48 );
                }
                if ( v28 < v50 )
                {
                  v32 = 3 * v28;
                  do
                  {
                    v33 = 4 * v28;
                    *(_BYTE *)(v33 + v4[2]) = v39[*(unsigned __int8 *)(v32 + v54)];
                    *(_BYTE *)(v4[2] + v33 + 1) = v39[*(unsigned __int8 *)(v32 + v54 + 1)];
                    *(_BYTE *)(v4[2] + v33 + 2) = v39[*(unsigned __int8 *)(v32 + v54 + 2)];
                    *(_BYTE *)(v4[2] + v33 + 3) = -1;
                    ++v28;
                    v32 += 3;
                  }
                  while ( v28 < v50 );
                }
                if ( v28 < 256 )
                {
                  v34 = 4 * v28;
                  do
                  {
                    *(_BYTE *)(v34 + v4[2]) = -1;
                    *(_BYTE *)(v34 + v4[2] + 1) = -1;
                    *(_BYTE *)(v34 + v4[2] + 2) = -1;
                    *(_BYTE *)(v34 + v4[2] + 3) = -1;
                    v34 += 4;
                  }
                  while ( v34 < 1024 );
                }
              }
            }
            v14 = 0;
            goto LABEL_97;
          }
        }
LABEL_65:
        v55 = 4;
        goto LABEL_59;
      }
      goto LABEL_66;
    }
    v55 = 2;
    goto LABEL_59;
  }
LABEL_60:
  v14 = -2147467259;
LABEL_97:
  if ( Buf )
    sub_1001E93E(&Buf, &v56, 0);
  if ( v51 )
    operator delete(v51);
  return v14;
}

// FUN_10011d95 @ 0x10011D95
// [binja] int32_t __thiscall sub_10011d95(int32_t* arg1, uint32_t arg2, int32_t* arg3)
int __thiscall sub_10011D95(_DWORD *this, int a2, unsigned int a3)
{
  _DWORD *v3; // ebx
  int v5; // eax
  int v6; // eax
  int *v7; // edi
  int v8; // eax
  int v9; // edi
  _DWORD *v10; // eax
  _DWORD *v11; // esi
  _DWORD *v12; // eax
  unsigned int v13; // edi
  int v14; // ebx
  _DWORD *v15; // eax
  _DWORD *v16; // eax
  _DWORD *v17; // eax
  int v18; // eax
  int v19; // ecx
  int v20; // edx
  _DWORD *v21; // [esp+8h] [ebp-2Ch]
  int v22; // [esp+Ch] [ebp-28h]
  int v23; // [esp+10h] [ebp-24h]
  unsigned int v24; // [esp+14h] [ebp-20h]
  unsigned int v25; // [esp+18h] [ebp-1Ch]
  _DWORD *v26; // [esp+1Ch] [ebp-18h]
  unsigned int v27; // [esp+20h] [ebp-14h]
  int v28; // [esp+24h] [ebp-10h]
  int v29; // [esp+28h] [ebp-Ch]
  int v31; // [esp+30h] [ebp-4h]
  unsigned int v32; // [esp+3Ch] [ebp+8h]
  unsigned int v33; // [esp+40h] [ebp+Ch]
  unsigned int v34; // [esp+40h] [ebp+Ch]

  v3 = this;
  if ( a3 < 4 )
    return -2147467259;
  if ( *(_DWORD *)a2 != 542327876 )
    return -2147467259;
  v33 = a3 - 4;
  if ( v33 < 0x7C )
    return -2147467259;
  v34 = v33 - 124;
  v31 = a2 + 128;
  *(this + 3) = *(_DWORD *)(a2 + 16);
  *(this + 4) = *(_DWORD *)(a2 + 12);
  if ( *(char *)(a2 + 10) >= 0 )
    v5 = 1;
  else
    v5 = *(_DWORD *)(a2 + 24);
  *(this + 5) = v5;
  if ( !v5 )
    *(this + 5) = 1;
  v6 = *(_DWORD *)(a2 + 112) & 0xFC00;
  if ( v6 == 64512 )
  {
    v27 = 6;
  }
  else
  {
    if ( v6 )
      return -2147467259;
    v27 = 1;
  }
  v24 = *(_DWORD *)(a2 + 28);
  if ( !v24 )
    v24 = 1;
  v7 = &dword_10053EC8;
  if ( dword_10053EC8 )
  {
    do
    {
      if ( *(_DWORD *)(a2 + 76) == 32 )
      {
        v8 = v7[2];
        if ( *(_DWORD *)(a2 + 80) == v8 )
        {
          if ( ((v8 & 4) == 0 || *(_DWORD *)(a2 + 84) == v7[3])
            && ((v8 & 0xC4462) == 0 || *(_DWORD *)(a2 + 88) == v7[4])
            && ((v8 & 0xE4040) == 0 || *(_DWORD *)(a2 + 92) == v7[5])
            && ((v8 & 0xC4440) == 0 || *(_DWORD *)(a2 + 96) == v7[6])
            && ((v8 & 0xC4040) == 0 || *(_DWORD *)(a2 + 100) == v7[7])
            && ((v8 & 0x80003) == 0 || *(_DWORD *)(a2 + 104) == v7[8]) )
          {
            v3 = this;
            break;
          }
          v3 = this;
        }
      }
      v7 += 9;
    }
    while ( *v7 );
  }
  v9 = *v7;
  v23 = v9;
  if ( v9 )
  {
    v10 = grim_format_info_lookup(v9);
    v21 = v10;
    if ( *(char *)(a2 + 10) >= 0 )
      v3[17] = 2 * (v27 == 6) + 3;
    else
      v3[17] = 4;
    if ( v10[1] != 1 )
    {
      v22 = 0;
LABEL_43:
      v28 = 0;
      v11 = (_DWORD *)v34;
      while ( 1 )
      {
        v12 = this;
        v13 = v3[3];
        v14 = v3[4];
        v25 = v14;
        v32 = *(this + 5);
        if ( v28 )
        {
          v15 = operator new(0x54u);
          if ( v15 )
            v12 = FUN_10010285(v15);
          else
            v12 = 0;
          if ( !v12 )
            return -2147024882;
          v26[20] = v12;
        }
        v29 = 0;
        v26 = v12;
        if ( v24 )
        {
          while ( 1 )
          {
            if ( v29 )
            {
              v16 = operator new(0x54u);
              if ( v16 )
                v17 = FUN_10010285(v16);
              else
                v17 = 0;
              if ( !v17 )
                return -2147024882;
              v11[19] = v17;
              v11 = v17;
            }
            else
            {
              v11 = v26;
            }
            if ( v23 == 827611204 )
              break;
            switch ( v23 )
            {
              case 844388420:
                goto LABEL_70;
              case 844715353:
                goto LABEL_68;
              case 861165636:
              case 877942852:
              case 894720068:
LABEL_70:
                v18 = 16 * ((v13 + 3) >> 2);
LABEL_72:
                v19 = v18 * ((unsigned int)(v14 + 3) >> 2);
                goto LABEL_73;
              case 1498831189:
LABEL_68:
                v18 = 4 * ((v13 + 1) >> 1);
                break;
              default:
                v18 = v13 * (v21[2] >> 3);
                break;
            }
            v19 = v14 * v18;
LABEL_73:
            v11[14] = 0;
            v11[15] = 0;
            v20 = v32 * v19;
            *v11 = v23;
            v11[12] = v18;
            v11[1] = v31;
            v11[5] = v32;
            v11[13] = v19;
            v11[3] = v13;
            v11[4] = v25;
            v11[2] = v22;
            if ( v34 < v32 * v19 )
              return -2147467259;
            v31 += v20;
            v34 -= v20;
            if ( v13 == 1 )
              v13 = 1;
            else
              v13 >>= 1;
            if ( v25 == 1 )
              v14 = 1;
            else
              v14 = v25 >> 1;
            v25 = v14;
            if ( v32 == 1 )
              v32 = 1;
            else
              v32 >>= 1;
            if ( ++v29 >= v24 )
              goto LABEL_84;
          }
          v18 = 8 * ((v13 + 3) >> 2);
          goto LABEL_72;
        }
LABEL_84:
        if ( ++v28 >= v27 )
          return 0;
        v3 = this;
      }
    }
    if ( v34 >= 0x400 )
    {
      v31 = a2 + 1152;
      v34 -= 1024;
      v22 = a2 + 128;
      goto LABEL_43;
    }
  }
  return -2147467259;
}

// FUN_100120d6 @ 0x100120D6
// [binja] int32_t __thiscall sub_100120d6(int32_t* arg1, HANDLE arg2)
int __thiscall sub_100120D6(int *this, HANDLE hFile)
{
  int *i; // eax
  int v4; // eax
  int *v5; // ebx
  int v6; // ecx
  int v8; // eax
  int *v9; // esi
  unsigned int v10; // eax
  _DWORD *j; // esi
  bool v12; // zf
  unsigned int v13; // eax
  int v14; // edi
  int v15; // eax
  const void *v16; // eax
  DWORD v17; // ecx
  unsigned int v18; // eax
  _DWORD v19[31]; // [esp+Ch] [ebp-20h] BYREF
  int Buffer; // [esp+88h] [ebp+5Ch] BYREF
  int *v21; // [esp+8Ch] [ebp+60h]
  int v22; // [esp+90h] [ebp+64h]
  DWORD NumberOfBytesWritten; // [esp+94h] [ebp+68h] BYREF
  _DWORD *v24; // [esp+98h] [ebp+6Ch]
  int v25; // [esp+9Ch] [ebp+70h]

  v21 = this;
  v25 = 0;
  for ( i = this; i; ++v25 )
    i = (int *)i[19];
  v4 = dword_10053EC8;
  v5 = &dword_10053EC8;
  if ( dword_10053EC8 )
  {
    v6 = *this;
    do
    {
      if ( v4 == v6 )
        break;
      v5 += 9;
      v4 = *v5;
    }
    while ( *v5 );
  }
  if ( !*v5 )
    return -2147467259;
  v24 = grim_format_info_lookup(*this);
  v22 = v24[2] >> 3;
  Buffer = 542327876;
  WriteFile(hFile, &Buffer, 4u, &NumberOfBytesWritten, 0);
  memset(v19, 0, sizeof(v19));
  v19[2] = *(this + 4);
  v19[3] = *(this + 3);
  v8 = v5[2];
  v19[0] = 124;
  v19[1] = 4103;
  qmemcpy(&v19[18], v5 + 1, 0x20u);
  v19[26] = 4096;
  if ( (v8 & 3) != 0 )
    v19[26] = 4098;
  if ( (v8 & 0x20) != 0 )
    BYTE1(v19[26]) |= 1u;
  v9 = v21;
  if ( v21[19] )
  {
    v19[26] |= 0x400008u;
    v19[1] = 135175;
    v19[6] = v25;
  }
  if ( v21[20] )
  {
    v19[26] |= 8u;
    BYTE1(v19[27]) |= 0xFEu;
  }
  v10 = v21[5];
  if ( v10 > 1 )
  {
    BYTE2(v19[1]) |= 0x80u;
    BYTE2(v19[27]) |= 0x20u;
    v19[5] = v10;
  }
  WriteFile(hFile, v19, 0x7Cu, &NumberOfBytesWritten, 0);
  if ( v24[1] == 1 )
    WriteFile(hFile, (LPCVOID)v9[2], 0x400u, &NumberOfBytesWritten, 0);
  v24 = v9;
  do
  {
    for ( j = v24; j; j = (_DWORD *)j[19] )
    {
      v12 = j[5] == 0;
      v25 = 0;
      if ( !v12 )
      {
        v13 = j[4];
        while ( 1 )
        {
          v14 = 0;
          if ( v13 )
            break;
LABEL_39:
          if ( (unsigned int)++v25 >= j[5] )
            goto LABEL_40;
        }
        while ( 2 )
        {
          v15 = *v21;
          if ( *v21 == 827611204 )
          {
            v18 = j[13] * (v25 + j[10]) + j[12] * ((unsigned int)(v14 + j[7]) >> 2) + 8 * (j[6] >> 2);
            v17 = 8 * ((unsigned int)(j[3] + 3) >> 2);
          }
          else
          {
            if ( v15 != 844388420 )
            {
              if ( v15 == 844715353 )
                goto LABEL_34;
              if ( v15 != 861165636 && v15 != 877942852 && v15 != 894720068 )
              {
                if ( v15 != 1498831189 )
                {
                  v16 = (const void *)(j[1] + v22 * j[6] + j[13] * (v25 + j[10]) + j[12] * (v14 + j[7]));
                  v17 = v22 * j[3];
                  goto LABEL_38;
                }
LABEL_34:
                v16 = (const void *)(j[1] + v22 * j[6] + j[13] * (v25 + j[10]) + j[12] * (v14 + j[7]));
                v17 = 4 * ((unsigned int)(j[3] + 1) >> 1);
LABEL_38:
                WriteFile(hFile, v16, v17, &NumberOfBytesWritten, 0);
                v13 = j[4];
                if ( ++v14 >= v13 )
                  goto LABEL_39;
                continue;
              }
            }
            v18 = 16 * (j[6] >> 2) + j[13] * (v25 + j[10]) + j[12] * ((unsigned int)(v14 + j[7]) >> 2);
            v17 = 16 * ((unsigned int)(j[3] + 3) >> 2);
          }
          break;
        }
        v16 = (const void *)(j[1] + v18);
        v14 += 3;
        goto LABEL_38;
      }
LABEL_40:
      ;
    }
    v24 = (_DWORD *)v24[20];
  }
  while ( v24 );
  return 0;
}

// FUN_1001237e @ 0x1001237E
// [binja] int32_t __thiscall sub_1001237e(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4)
int __thiscall sub_1001237E(int *this, LPCWCH lpWideCharStr, int a3, LPSTR lpMultiByteStr)
{
  int *v4; // esi
  int v5; // edi
  int *v6; // ebx
  _DWORD *v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int *v11; // ebx
  int v12; // esi
  int v13; // eax
  _DWORD v15[4]; // [esp+Ch] [ebp-D4h] BYREF
  _BYTE v16[24]; // [esp+1Ch] [ebp-C4h] BYREF
  _BYTE v17[24]; // [esp+34h] [ebp-ACh] BYREF
  int v18; // [esp+4Ch] [ebp-94h]
  int v19; // [esp+50h] [ebp-90h]
  int v20; // [esp+54h] [ebp-8Ch]
  _DWORD v21[2]; // [esp+58h] [ebp-88h] BYREF
  int v22; // [esp+60h] [ebp-80h]
  int v23; // [esp+64h] [ebp-7Ch]
  _DWORD v24[6]; // [esp+68h] [ebp-78h] BYREF
  _BYTE v25[24]; // [esp+80h] [ebp-60h] BYREF
  int v26; // [esp+98h] [ebp-48h]
  int v27; // [esp+9Ch] [ebp-44h]
  int v28; // [esp+A0h] [ebp-40h]
  HANDLE hFile[4]; // [esp+A4h] [ebp-3Ch] BYREF
  _BYTE v30[12]; // [esp+B4h] [ebp-2Ch] BYREF
  int *v31; // [esp+C0h] [ebp-20h]
  int v32; // [esp+C4h] [ebp-1Ch]
  void *v33; // [esp+C8h] [ebp-18h]
  int *v34; // [esp+CCh] [ebp-14h]
  int v35; // [esp+D0h] [ebp-10h]
  int v36; // [esp+DCh] [ebp-4h]

  v4 = this;
  v31 = this;
  FUN_1001bca5(hFile);
  v5 = a3;
  v36 = 0;
  if ( !a3 )
    goto LABEL_7;
  if ( a3 <= 0 )
  {
LABEL_25:
    v12 = -2005530516;
    goto LABEL_37;
  }
  if ( a3 <= 3 )
  {
LABEL_24:
    v12 = -2005529767;
    goto LABEL_37;
  }
  if ( a3 != 4 )
  {
    if ( a3 != 5 )
    {
      if ( a3 == 6 )
      {
LABEL_7:
        v6 = (int *)&unk_10053E28;
        goto LABEL_8;
      }
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  v6 = (int *)&unk_10053E40;
LABEL_8:
  v7 = grim_format_info_lookup(*v4);
  v8 = sub_1000AB3F(v6, v4[2], (int)v7);
  v9 = v8;
  v32 = v8;
  if ( !v8 )
    goto LABEL_24;
  if ( v8 == *v4 )
  {
LABEL_21:
    v13 = FUN_1001bdc7(lpWideCharStr, lpMultiByteStr);
    if ( v13 < 0 )
    {
LABEL_22:
      v12 = v13;
      goto LABEL_37;
    }
    if ( v5 )
    {
      if ( v5 == 4 )
      {
        v13 = FUN_100120d6(v4, hFile[0]);
      }
      else
      {
        if ( v5 != 6 )
        {
          v13 = -2147467263;
          goto LABEL_22;
        }
        v13 = FUN_10010aec(v4, hFile[0], 0);
      }
    }
    else
    {
      v13 = FUN_10010aec(v4, hFile[0], 1u);
    }
    if ( v13 >= 0 )
    {
      v12 = 0;
      goto LABEL_37;
    }
    goto LABEL_22;
  }
  FUN_1001284c(v30);
  LOBYTE(v36) = 1;
  v10 = grim_format_info_lookup(v9)[2] >> 3;
  v35 = v10;
  v34 = v4;
  while ( 1 )
  {
    v11 = v34;
    if ( v34 )
      break;
LABEL_19:
    v34 = (int *)v34[20];
    if ( !v34 )
    {
      LOBYTE(v36) = 0;
      FUN_10012856(v30);
      goto LABEL_21;
    }
  }
  while ( 1 )
  {
    v33 = operator new(v11[4] * v10 * v11[3] * v11[5]);
    if ( !v33 )
    {
      LOBYTE(v36) = 0;
      FUN_10012856(v30);
      v12 = -2147024882;
      goto LABEL_37;
    }
    v15[0] = v11[1];
    v15[1] = *v11;
    v15[2] = v11[12];
    v15[3] = v11[13];
    qmemcpy(v16, v11 + 6, sizeof(v16));
    qmemcpy(v17, v11 + 6, sizeof(v17));
    v19 = 0;
    v18 = 1;
    v20 = v11[2];
    v21[0] = v33;
    v21[1] = v32;
    v22 = v35 * v11[3];
    v23 = v11[4] * v35 * v11[3];
    v24[0] = 0;
    v24[1] = 0;
    v24[2] = v11[3];
    v24[3] = v11[4];
    v24[4] = 0;
    v24[5] = v11[5];
    qmemcpy(v25, v24, sizeof(v25));
    v27 = 0;
    v26 = 1;
    v28 = v11[2];
    v12 = FUN_10016007(v21, v15, 524289);
    if ( v12 < 0 )
      break;
    if ( v11[1] && v11[14] )
    {
      operator delete((void *)v11[1]);
      v11[1] = 0;
    }
    *v11 = v32;
    v11[1] = (int)v33;
    qmemcpy(v11 + 6, v25, 0x18u);
    v11[12] = v22;
    v11[13] = v23;
    v10 = v35;
    v11[14] = 1;
    v11 = (int *)v11[19];
    if ( !v11 )
    {
      v5 = a3;
      v4 = v31;
      goto LABEL_19;
    }
  }
  operator delete(v33);
  LOBYTE(v36) = 0;
  FUN_10012856(v30);
LABEL_37:
  v36 = -1;
  FUN_1001bed2(hFile);
  return v12;
}

// FUN_10012647 @ 0x10012647
// [binja] int32_t __stdcall sub_10012647(int16_t* arg1, void* arg2)
int __thiscall sub_10012647(int *this, int a2, unsigned int a3)
{
  if ( a3 >= 0xE && *(_WORD *)a2 == 19778 && *(_DWORD *)(a2 + 2) <= a3 )
    return FUN_100103d6(this, a2 + 14, a3 - 14);
  else
    return -2147467259;
}

// FUN_10012677 @ 0x10012677
// [binja] int32_t __thiscall sub_10012677(int32_t* arg1, void* arg2, int32_t* arg3, int32_t* arg4, int32_t arg5)
int __thiscall sub_10012677(int this, unsigned __int8 *a2, unsigned int a3, _DWORD *a4, int a5)
{
  int v5; // ebx
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // eax
  unsigned int v13; // eax
  void *v14; // ecx
  void *v15; // ecx
  bool v16; // cf
  _DWORD *i; // eax
  _DWORD *v19; // eax
  int v20; // ecx
  _DWORD v21[7]; // [esp+Ch] [ebp-20h]
  int v22; // [esp+28h] [ebp-4h]

  v5 = a3;
  v21[0] = 0;
  v21[1] = 5;
  v21[2] = 4;
  v21[3] = 1;
  v21[4] = 3;
  v21[5] = 2;
  v21[6] = 6;
  v22 = 0;
  do
  {
    *(_DWORD *)(this + 64) = a5;
    v7 = v21[v22];
    *(_DWORD *)(this + 72) = v7;
    *(_DWORD *)(this + 68) = 3;
    if ( !v7 )
    {
      v13 = FUN_10012647((int *)this, (int)a2, a3);
      goto LABEL_16;
    }
    v8 = v7 - 1;
    if ( !v8 )
    {
      v13 = FUN_10010e13((_DWORD *)this, (int)a2, a3);
      goto LABEL_16;
    }
    v9 = v8 - 1;
    if ( !v9 )
    {
      v13 = FUN_10011083((int *)this, a2, a3);
      goto LABEL_16;
    }
    v10 = v9 - 1;
    if ( !v10 )
    {
      v13 = FUN_100117ff((int *)this, (int)a2, a3);
      goto LABEL_16;
    }
    v11 = v10 - 1;
    if ( !v11 )
    {
      v13 = FUN_10011d95((_DWORD *)this, (int)a2, a3);
      goto LABEL_16;
    }
    v12 = v11 - 1;
    if ( !v12 )
    {
      v13 = FUN_1001152a((_DWORD *)this, a2, a3);
      goto LABEL_16;
    }
    if ( v12 == 1 )
    {
      v13 = FUN_100103d6((int *)this, (int)a2, a3);
LABEL_16:
      v5 = v13;
    }
    if ( v5 >= 0 )
      break;
    if ( *(_DWORD *)(this + 4) && *(_DWORD *)(this + 56) )
      operator delete(*(void **)(this + 4));
    if ( *(_DWORD *)(this + 8) && *(_DWORD *)(this + 60) )
      operator delete(*(void **)(this + 8));
    v14 = *(void **)(this + 76);
    if ( v14 )
      FUN_100102f7(v14, 1);
    v15 = *(void **)(this + 80);
    if ( v15 )
      FUN_100102f7(v15, 1);
    v16 = (unsigned int)++v22 < 7;
    *(_DWORD *)(this + 4) = 0;
    *(_DWORD *)(this + 8) = 0;
    *(_DWORD *)(this + 56) = 0;
    *(_DWORD *)(this + 60) = 0;
    *(_DWORD *)(this + 76) = 0;
    *(_DWORD *)(this + 80) = 0;
  }
  while ( v16 );
  if ( v22 == 7 )
    return -2005529767;
  if ( a4 )
  {
    memset(a4, 0, 0x1Cu);
    *a4 = *(_DWORD *)(this + 12);
    a4[1] = *(_DWORD *)(this + 16);
    a4[2] = *(_DWORD *)(this + 20);
    a4[3] = 1;
    a4[4] = sub_1000AC8F(*(_DWORD *)this);
    a4[5] = *(_DWORD *)(this + 68);
    a4[6] = *(_DWORD *)(this + 72);
    for ( i = (_DWORD *)(this + 76); *i; i = (_DWORD *)(*i + 76) )
      ++a4[3];
  }
  do
  {
    v19 = (_DWORD *)this;
    if ( this )
    {
      do
      {
        v19[8] = v19[3];
        v19[9] = v19[4];
        v20 = v19[5];
        v19[6] = 0;
        v19[7] = 0;
        v19[10] = 0;
        v19[11] = v20;
        v19 = (_DWORD *)v19[19];
      }
      while ( v19 );
    }
    this = *(_DWORD *)(this + 80);
  }
  while ( this );
  return 0;
}

// FUN_1001284c @ 0x1001284C
// [binja] int32_t* __fastcall sub_1001284c(int32_t* arg1)
_DWORD *__thiscall sub_1001284C(_DWORD *this)
{
  *(this + 1) = 0;
  *this = 0;
  return this;
}

// FUN_10012856 @ 0x10012856
// [binja] void __fastcall sub_10012856(int32_t* arg1)
int __thiscall sub_10012856(_DWORD *this)
{
  int (__thiscall ***v2)(_DWORD, int); // ecx
  int result; // eax

  v2 = (int (__thiscall ***)(_DWORD, int))*(this + 1);
  if ( v2 )
    result = (**v2)(v2, 1);
  if ( *this )
    return (**(int (__thiscall ***)(_DWORD, int))*this)(*this, 1);
  return result;
}

// sub_1001288A @ 0x1001288A
_DWORD *__cdecl sub_1001288A(unsigned int a1, signed int a2, int a3)
{
  unsigned int v3; // edi
  double v4; // st7
  double v5; // st6
  unsigned int v6; // esi
  __int64 v7; // rax
  _DWORD *v8; // edi
  int v9; // ebx
  int v10; // esi
  double v11; // st7
  double X; // st7
  int v13; // edx
  double v14; // st7
  int v15; // ecx
  float *v16; // eax
  double v17; // st6
  float *v18; // eax
  _DWORD *v20; // [esp+14h] [ebp-3Ch]
  int v21; // [esp+18h] [ebp-38h]
  float v22; // [esp+1Ch] [ebp-34h]
  float v23; // [esp+20h] [ebp-30h]
  float v24; // [esp+24h] [ebp-2Ch]
  float v25; // [esp+28h] [ebp-28h]
  int i; // [esp+2Ch] [ebp-24h]
  float v27; // [esp+30h] [ebp-20h]
  float v28; // [esp+34h] [ebp-1Ch]
  unsigned int v29; // [esp+38h] [ebp-18h]
  float v30; // [esp+3Ch] [ebp-14h]
  float v31; // [esp+40h] [ebp-10h]
  unsigned int v32; // [esp+44h] [ebp-Ch]
  float v33; // [esp+48h] [ebp-8h]
  float v34; // [esp+4Ch] [ebp-4h]

  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v28 = (float)(unsigned int)a2;
      v4 = (double)a1;
      v23 = v4;
      v5 = v28 / v4;
      v6 = 16;
      v25 = v5;
      v22 = 0.5 / v5;
      do
      {
        v7 = (__int64)(((double)v3 - 0.5) * v5 + v5 - ((double)v3 - 0.5) * v5 + (double)(a3 != 0) + 1.0);
        ++v3;
        v6 += 16 * v7 + 12;
      }
      while ( v3 < a1 );
      v8 = operator new(v6);
      if ( v8 )
      {
        v9 = 0;
        v29 = 0;
        v34 = 0.0;
        v10 = 1;
        while ( 1 )
        {
          v32 = 0;
          v20 = &v8[v10];
          v21 = v10 * 4;
          ++v10;
          do
          {
            v24 = (float)v29;
            v11 = (double)v32 + v24 - 0.5;
            v31 = v11;
            X = v11 * v25;
            v27 = X;
            v33 = v25 + X;
            if ( !a3 )
            {
              if ( X < 0.0 )
              {
                X = 0.0;
                v27 = 0.0;
              }
              if ( v33 > (double)v28 )
                v33 = (float)(unsigned int)a2;
            }
            v13 = (__int64)floor(X);
            v14 = (double)v13;
            if ( v14 < v33 )
            {
              v15 = v13 - a2;
              for ( i = v13 - a2; ; v15 = i )
              {
                v30 = v14 + 1.0;
                if ( v13 >= 0 )
                {
                  if ( v13 < a2 )
                    v15 = v13;
                }
                else
                {
                  v15 = v13 + a2;
                }
                if ( v15 != v9 )
                {
                  if ( v34 > 0.0000099999997 )
                  {
                    v16 = (float *)&v8[v10];
                    *(_DWORD *)v16 = v9;
                    v10 += 2;
                    v16[1] = v34;
                  }
                  v9 = v15;
                  v34 = 0.0;
                }
                if ( v14 < v27 )
                  v14 = v27;
                if ( v30 > (double)v33 )
                  v30 = v33;
                if ( a3 )
                  goto LABEL_33;
                if ( v31 < 0.0 )
                {
                  v17 = 1.0;
                  goto LABEL_34;
                }
                if ( v31 + 1.0 < v23 )
LABEL_33:
                  v17 = (v30 + v14) * v22 - v31;
                else
                  v17 = 0.0;
LABEL_34:
                if ( v32 )
                  v17 = 1.0 - v17;
                ++v13;
                ++i;
                v34 = (v30 - v14) * v17 + v34;
                v14 = (double)v13;
                if ( v14 >= v33 )
                  break;
              }
            }
            ++v32;
          }
          while ( v32 < 2 );
          if ( v34 > 0.0000099999997 )
          {
            v18 = (float *)&v8[v10];
            v10 += 2;
            *(_DWORD *)v18 = v9;
            v18[1] = v34;
          }
          v34 = 0.0;
          ++v29;
          *v20 = v10 * 4 - v21;
          if ( v29 >= a1 )
          {
            *v8 = v10 * 4;
            return v8;
          }
        }
      }
    }
  }
  return 0;
}

// FUN_10012b47 @ 0x10012B47
// [binja] int32_t* __thiscall sub_10012b47(int32_t* arg1, char arg2)
void **__thiscall sub_10012B47(void **this, char a2)
{
  if ( (a2 & 2) != 0 )
  {
    FUN_1004b5cf(
      this,
      0xCu,
      (int)*(this - 1),
      (void (__thiscall *)(void *))Concurrency::SchedulerPolicy::~SchedulerPolicy);
    if ( (a2 & 1) != 0 )
      operator delete(this - 1);
    return this - 1;
  }
  else
  {
    operator delete(*this);
    if ( (a2 & 1) != 0 )
      operator delete(this);
    return this;
  }
}

// FUN_10012b93 @ 0x10012B93
// [binja] int32_t __fastcall sub_10012b93(int32_t* arg1)
int __thiscall sub_10012B93(unsigned int *this)
{
  unsigned int v2; // edi
  BOOL v3; // edi
  int v4; // edi
  int *v5; // eax
  void **v6; // eax
  int v7; // edi
  char *v8; // eax
  void *v9; // eax
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  _DWORD *i; // ecx
  float *v13; // eax
  float *v14; // edx
  void **v15; // ebx
  int v16; // edi
  void *v17; // eax
  void *v18; // eax
  unsigned int v19; // edi
  float *v20; // edx
  float *v21; // eax
  float *v22; // ecx
  float *v23; // ebx
  int v24; // eax
  float *k; // ecx
  double v26; // st7
  float *v27; // edi
  float *m; // ebx
  void **v29; // edi
  bool v30; // zf
  _DWORD *v31; // ecx
  int v32; // esi
  BOOL v34; // [esp-4h] [ebp-6Ch]
  void *v35; // [esp+Ch] [ebp-5Ch]
  char *v36; // [esp+Ch] [ebp-5Ch]
  void **v37; // [esp+10h] [ebp-58h]
  void **v38; // [esp+10h] [ebp-58h]
  BOOL v39; // [esp+14h] [ebp-54h]
  float *v40; // [esp+14h] [ebp-54h]
  unsigned int v41; // [esp+18h] [ebp-50h]
  unsigned int v42; // [esp+1Ch] [ebp-4Ch]
  void *v43; // [esp+20h] [ebp-48h]
  float *v44; // [esp+20h] [ebp-48h]
  float *v45; // [esp+24h] [ebp-44h]
  int v46; // [esp+28h] [ebp-40h]
  _DWORD *v47; // [esp+2Ch] [ebp-3Ch]
  int v48; // [esp+30h] [ebp-38h]
  float *v49; // [esp+34h] [ebp-34h]
  float *v50; // [esp+38h] [ebp-30h]
  _DWORD *v51; // [esp+3Ch] [ebp-2Ch]
  _DWORD *v52; // [esp+40h] [ebp-28h]
  unsigned int v53; // [esp+44h] [ebp-24h]
  void **v54; // [esp+48h] [ebp-20h]
  char *v55; // [esp+4Ch] [ebp-1Ch]
  unsigned int v56; // [esp+50h] [ebp-18h]
  void **v57; // [esp+54h] [ebp-14h]
  float *j; // [esp+58h] [ebp-10h]
  float *v59; // [esp+58h] [ebp-10h]
  unsigned int v60; // [esp+58h] [ebp-10h]

  v51 = 0;
  v52 = 0;
  v37 = 0;
  v54 = 0;
  v35 = 0;
  v2 = *(this + 2);
  v39 = ((v2 >> 18) & 1) == 0;
  v34 = (v2 & 0x10000) == 0;
  v3 = ((v2 >> 17) & 1) == 0;
  v45 = (float *)sub_1001288A(*(_DWORD *)(*this + 4184), *(_DWORD *)(*(this + 1) + 4184), v34);
  if ( v45
    && (v51 = sub_1001288A(*(_DWORD *)(*this + 4188), *(_DWORD *)(*(this + 1) + 4188), v3)) != 0
    && (v52 = sub_1001288A(*(_DWORD *)(*this + 4192), *(_DWORD *)(*(this + 1) + 4192), v39)) != 0 )
  {
    v42 = (unsigned int)v45 + *(_DWORD *)v45;
    v41 = (unsigned int)v51 + *v51;
    v53 = (unsigned int)v52 + *v52;
    v4 = *(_DWORD *)(*(this + 1) + 4192);
    v5 = (int *)operator new(12 * v4 + 4);
    if ( v5 )
    {
      *v5 = v4;
      v38 = (void **)(v5 + 1);
      FUN_1004b6c3(
        v5 + 1,
        0xCu,
        v4,
        unknown_libname_2,
        (void (__thiscall *)(void *))Concurrency::SchedulerPolicy::~SchedulerPolicy);
      v6 = v38;
      v57 = v38;
    }
    else
    {
      v57 = 0;
      v6 = 0;
    }
    v37 = v6;
    if ( !v6 )
      goto LABEL_54;
    v7 = *(_DWORD *)(*this + 4184);
    v8 = (char *)operator new(16 * v7);
    v36 = v8;
    if ( v8 )
    {
      sub_1000B393((int)v8, 16, v7, (int (__thiscall *)(int))sub_1000AE4F);
      v9 = v36;
      v55 = v36;
    }
    else
    {
      v55 = 0;
      v9 = 0;
    }
    v35 = v9;
    if ( v9 )
    {
      v10 = v52 + 1;
      if ( (unsigned int)(v52 + 1) < v53 )
      {
        do
        {
          v11 = (_DWORD *)((char *)v10 + *v10);
          for ( i = v10 + 1; i < v11; i += 2 )
            v57[3 * *i + 2] = (char *)v57[3 * *i + 2] + 1;
          v10 = v11;
        }
        while ( (unsigned int)v11 < v53 );
      }
      v46 = 0;
      v13 = (float *)(v52 + 1);
      if ( (unsigned int)(v52 + 1) < v53 )
      {
        do
        {
          v14 = (float *)((char *)v13 + *(_DWORD *)v13);
          v56 = (unsigned int)v14;
          v40 = v13 + 1;
          for ( j = v13 + 1; j < v14; j += 2 )
          {
            v15 = &v57[3 * *(_DWORD *)j];
            if ( !*v15 )
            {
              if ( v54 )
              {
                *v15 = *v54;
                *v54 = 0;
                v54 = (void **)v54[1];
              }
              else
              {
                v16 = *(_DWORD *)(*(this + 1) + 4184) * *(_DWORD *)(*(this + 1) + 4188);
                v17 = operator new(16 * v16);
                v43 = v17;
                if ( v17 )
                {
                  sub_1000B393((int)v17, 16, v16, (int (__thiscall *)(int))sub_1000AE4F);
                  v18 = v43;
                }
                else
                {
                  v18 = 0;
                }
                *v15 = v18;
                if ( !v18 )
                  goto LABEL_54;
                v14 = (float *)v56;
              }
              memset(*v15, 0, 16 * *(_DWORD *)(*(this + 1) + 4184) * *(_DWORD *)(*(this + 1) + 4188));
            }
          }
          v48 = 0;
          v47 = v51 + 1;
          if ( (unsigned int)(v51 + 1) < v41 )
          {
            do
            {
              v19 = (unsigned int)v47 + *v47;
              v44 = (float *)v19;
              (*(void (__stdcall **)(int, int, char *))(*(_DWORD *)*this + 4))(v48, v46, v55);
              v49 = v45 + 1;
              if ( (unsigned int)(v45 + 1) < v42 )
              {
                v20 = (float *)(v55 + 8);
                do
                {
                  v21 = (float *)((char *)v49 + *(_DWORD *)v49);
                  v22 = v40;
                  v50 = v21;
                  while ( 1 )
                  {
                    v59 = v22;
                    if ( (unsigned int)v22 >= v56 )
                      break;
                    v23 = (float *)(v47 + 1);
                    if ( (unsigned int)(v47 + 1) < v19 )
                    {
                      do
                      {
                        v24 = (int)v57[3 * *(_DWORD *)v22] + 16 * *(_DWORD *)v23 * *(_DWORD *)(*(this + 1) + 4184);
                        for ( k = v49 + 1; k < v50; k += 2 )
                        {
                          v26 = k[1] * v23[1] * v59[1];
                          *(float *)(v24 + 16 * *(_DWORD *)k) = v26 * *(v20 - 2) + *(float *)(v24 + 16 * *(_DWORD *)k);
                          *(float *)(16 * *(_DWORD *)k + v24 + 4) = v26 * *(v20 - 1)
                                                                  + *(float *)(16 * *(_DWORD *)k + v24 + 4);
                          *(float *)(16 * *(_DWORD *)k + v24 + 8) = v26 * *v20 + *(float *)(16 * *(_DWORD *)k + v24 + 8);
                          v27 = (float *)(16 * *(_DWORD *)k + v24 + 12);
                          *v27 = v26 * v20[1] + *v27;
                        }
                        v22 = v59;
                        v23 += 2;
                      }
                      while ( v23 < v44 );
                      v19 = (unsigned int)v44;
                      v21 = v50;
                    }
                    v22 += 2;
                  }
                  v20 += 4;
                  v49 = v21;
                }
                while ( (unsigned int)v21 < v42 );
              }
              ++v48;
              v47 = (_DWORD *)v19;
            }
            while ( v19 < v41 );
            v14 = (float *)v56;
          }
          for ( m = v40; m < v14; m += 2 )
          {
            v29 = &v57[3 * *(_DWORD *)m];
            v30 = v29[2] == (void *)1;
            v29[2] = (char *)v29[2] - 1;
            if ( v30 )
            {
              v31 = (_DWORD *)*(this + 1);
              v60 = 0;
              if ( v31[1047] )
              {
                do
                {
                  (*(void (__stdcall **)(unsigned int, _DWORD, unsigned int))(*v31 + 8))(
                    v60,
                    *(_DWORD *)m,
                    (unsigned int)*v29 + 16 * v60 * v31[1046]);
                  ++v60;
                  v31 = (_DWORD *)*(this + 1);
                }
                while ( v60 < v31[1047] );
                v14 = (float *)v56;
              }
              v29[1] = v54;
              v54 = v29;
            }
          }
          ++v46;
          v13 = v14;
        }
        while ( (unsigned int)v14 < v53 );
      }
      v32 = 0;
    }
    else
    {
LABEL_54:
      v32 = -2147024882;
    }
  }
  else
  {
    v32 = -2147467259;
  }
  if ( v37 )
    FUN_10012b47(v37, 3);
  operator delete(v52);
  operator delete(v51);
  operator delete(v45);
  operator delete(v35);
  operator delete(0);
  return v32;
}

// FUN_10013007 @ 0x10013007
// [binja] int32_t __fastcall sub_10013007(int32_t* arg1)
int __thiscall sub_10013007(_DWORD *this)
{
  _DWORD *v1; // edi
  unsigned int v2; // esi
  int v4; // eax
  unsigned int v5; // ecx
  int v6; // edx
  unsigned int v7; // ecx
  int v8; // esi
  unsigned int v9; // eax
  _DWORD *v10; // edx
  char *v11; // ebx
  int v12; // eax
  int v13; // ecx
  int v14; // [esp-8h] [ebp-28h]
  unsigned int v15; // [esp+8h] [ebp-18h]
  unsigned int v16; // [esp+Ch] [ebp-14h]
  int v17; // [esp+Ch] [ebp-14h]
  unsigned int v18; // [esp+10h] [ebp-10h]
  unsigned int v19; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  unsigned int v22; // [esp+18h] [ebp-8h]
  char *i; // [esp+1Ch] [ebp-4h]

  v1 = (_DWORD *)*this;
  v2 = *(_DWORD *)(*this + 4148);
  v18 = *(_DWORD *)(*this + 4144);
  if ( (((unsigned __int8)v2
       | (unsigned __int8)(*(_BYTE *)(*this + 4144) | *(_BYTE *)(*this + 4152) | *(_BYTE *)(*this + 4156)))
      & 3) != 0 )
    return -2147467259;
  v4 = *(this + 1);
  v5 = *(_DWORD *)(v4 + 4148);
  v16 = *(_DWORD *)(v4 + 4144);
  if ( (((unsigned __int8)v5 | (unsigned __int8)(v16 | *(_BYTE *)(v4 + 4152) | *(_BYTE *)(v4 + 4156))) & 3) != 0 )
    return -2147467259;
  v6 = *(_DWORD *)(v4 + 4);
  if ( v6 == 827611204 )
  {
    v14 = 8;
  }
  else
  {
    if ( v6 != 844388420 && v6 != 861165636 && v6 != 877942852 && v6 != 894720068 )
      return -2147467259;
    v14 = 16;
  }
  v15 = v14 * (*(_DWORD *)(v4 + 4184) >> 2);
  v20 = *(_DWORD *)(v4 + 24)
      + v14 * (v16 >> 2)
      + *(_DWORD *)(v4 + 4160) * *(_DWORD *)(v4 + 4180)
      + *(_DWORD *)(v4 + 4176) * (v5 >> 2);
  v7 = v18;
  v19 = 0;
  v8 = v1[6] + v14 * (v7 >> 2) + v1[1040] * v1[1045] + v1[1044] * (v2 >> 2);
  v17 = v8;
  if ( *(_DWORD *)(v4 + 4192) )
  {
    v9 = *(_DWORD *)(v4 + 4188);
    v10 = this;
    do
    {
      v22 = 0;
      v11 = (char *)v20;
      for ( i = (char *)v8; v22 < v9; i += *(_DWORD *)(*v10 + 4176) )
      {
        v22 += 4;
        qmemcpy(v11, i, v15);
        v12 = v10[1];
        v11 += *(_DWORD *)(v12 + 4176);
        v9 = *(_DWORD *)(v12 + 4188);
      }
      v13 = v10[1];
      v20 += *(_DWORD *)(v13 + 4180);
      v8 = *(_DWORD *)(*v10 + 4180) + v17;
      ++v19;
      v17 = v8;
    }
    while ( v19 < *(_DWORD *)(v13 + 4192) );
  }
  return 0;
}

// sub_10013195 @ 0x10013195
int __cdecl sub_10013195(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6; // edx
  int v7; // edi
  unsigned int *v8; // ecx
  unsigned int v9; // edx
  unsigned int v10; // ebx
  unsigned int *v11; // ecx
  bool v12; // zf
  unsigned int v14; // [esp+4h] [ebp-18h]
  unsigned int v15; // [esp+8h] [ebp-14h]
  unsigned int v16; // [esp+Ch] [ebp-10h]
  unsigned int v17; // [esp+10h] [ebp-Ch]
  unsigned int *v18; // [esp+14h] [ebp-8h]
  unsigned int v19; // [esp+18h] [ebp-4h]
  unsigned int v20; // [esp+30h] [ebp+14h]

  v6 = a2;
  v7 = a5;
  v14 = a2 + a5 * a4;
  if ( a2 < v14 )
  {
    v20 = a2 + 4 * a3;
    do
    {
      v18 = a1;
      if ( v6 < v20 )
      {
        v8 = (unsigned int *)(v6 + 4);
        v16 = v6 + 4;
        v15 = ((v20 - v6 - 1) >> 3) + 1;
        do
        {
          v17 = *(unsigned int *)((char *)v8 + v7 - 4);
          v19 = *(unsigned int *)((char *)v8 + v7);
          v9 = *v8;
          v7 = a5;
          v10 = (((v19 >> 2) & 0x3FC03FC0)
               + ((v17 >> 2) & 0x3FC03FC0)
               + ((*(v8 - 1) >> 2) & 0x3FC03FC0)
               + ((v9 >> 2) & 0x3FC03FC0)
               + 8388736)
              ^ ((((v19 & 0xFF00FF) + (v17 & 0xFF00FF) + (*(v8 - 1) & 0xFF00FF) + (v9 & 0xFF00FF) + 131074) >> 2)
               ^ (((v19 >> 2) & 0xFFC03FC0)
                + ((v17 >> 2) & 0xFFC03FC0)
                + ((*(v8 - 1) >> 2) & 0xFFC03FC0)
                + ((v9 >> 2) & 0xFFC03FC0)
                - 8388480))
              & 0xFF00FF;
          v11 = v18++;
          *v11 = v10;
          v8 = (unsigned int *)(v16 + 8);
          v12 = v15-- == 1;
          v16 += 8;
        }
        while ( !v12 );
        v6 = a2;
      }
      a1 = (unsigned int *)((char *)a1 + a6);
      v20 += 2 * v7;
      v6 += 2 * v7;
      a2 = v6;
    }
    while ( v6 < v14 );
  }
  return 0;
}

// FUN_100132bb @ 0x100132BB
// [binja] int32_t __fastcall sub_100132bb(int32_t* arg1)
int sub_100132BB()
{
  return off_10054390();
}

// sub_100132EC @ 0x100132EC
int __cdecl sub_100132EC(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  int v6; // eax
  unsigned int v7; // edi
  _DWORD *v8; // esi
  unsigned int v9; // ebx
  unsigned int *v10; // eax
  bool v11; // zf
  unsigned int v13; // [esp+4h] [ebp-18h]
  unsigned int v14; // [esp+Ch] [ebp-10h]
  unsigned int *v15; // [esp+18h] [ebp-4h]
  unsigned int v16; // [esp+30h] [ebp+14h]

  v6 = a5;
  v7 = a2;
  v13 = a2 + a5 * a4;
  if ( a2 < v13 )
  {
    v16 = a2 + 4 * a3;
    do
    {
      v15 = a1;
      if ( v7 < v16 )
      {
        v8 = (_DWORD *)(v7 + 4);
        v14 = ((v16 - v7 - 1) >> 3) + 1;
        do
        {
          v9 = ((*(_DWORD *)((char *)v8 + v6) & 0xFF00)
              + (*(_DWORD *)((char *)v8 + v6 - 4) & 0xFF00)
              + (*(v8 - 1) & 0xFF00)
              + (*v8 & 0xFF00)
              + 512)
             & 0x3FC00
             | ((*(_DWORD *)((char *)v8 + v6) & 0xFF00FF)
              + (*(_DWORD *)((char *)v8 + v6 - 4) & 0xFF00FF)
              + (*(v8 - 1) & 0xFF00FF)
              + (*v8 & 0xFF00FF)
              + 131074)
             & 0x3FC03FC;
          v10 = v15++;
          v8 += 2;
          v11 = v14-- == 1;
          *v10 = v9 >> 2;
          v6 = a5;
        }
        while ( !v11 );
        v7 = a2;
      }
      a1 = (unsigned int *)((char *)a1 + a6);
      v16 += 2 * v6;
      v7 += 2 * v6;
      a2 = v7;
    }
    while ( v7 < v13 );
  }
  return 0;
}

// sub_100133D4 @ 0x100133D4
int __cdecl sub_100133D4(unsigned int *a1, unsigned int a2, int a3, int a4, int a5, int a6)
{
  __m64 *v7; // eax
  unsigned int *v8; // edx
  __m64 *v9; // edi
  __m64 *v10; // esi
  int v11; // ebx
  __m64 *i; // eax
  __m64 v13; // mm5
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 *v17; // ecx
  __m64 v18; // mm0
  __m64 *v19; // [esp+10h] [ebp-Ch]
  signed int v20; // [esp+18h] [ebp-4h]
  int v21; // [esp+2Ch] [ebp+10h]

  if ( (a3 & 3) != 0 )
    return sub_10013195(a1, a2, a3, a4, a5, a6);
  v20 = a2 + a5 * a4;
  _m_empty();
  v21 = 4 * a3;
  v7 = (__m64 *)a2;
  v8 = a1;
  if ( (int)a2 < v20 )
  {
    do
    {
      v9 = v7;
      v10 = (__m64 *)((char *)v7 + a5);
      v11 = (int)v7 + v21;
      v19 = v7;
      for ( i = (__m64 *)v8;
            (int)v9 < v11;
            v17->m64_u64 = (unsigned __int64)_m_packuswb(
                                               _m_psrawi(
                                                 _m_paddw(_m_paddw(_m_paddw(v18, v15), v16), (__m64)0x2000200020002LL),
                                                 2u),
                                               _m_psrawi(
                                                 _m_paddw(
                                                   _m_paddw(
                                                     _m_paddw(
                                                       _m_paddw(_m_punpcklbw(v13, 0), _m_punpckhbw(v13, 0)),
                                                       _m_punpcklbw(v14, 0)),
                                                     _m_punpckhbw(v14, 0)),
                                                   (__m64)0x2000200020002LL),
                                                 2u)) )
      {
        v13 = v9[1];
        v14 = v10[1];
        v15 = _m_punpcklbw((__m64)v10->m64_u64, 0);
        v16 = _m_punpckhbw((__m64)v10->m64_u64, 0);
        v17 = i;
        v18 = _m_paddw(_m_punpcklbw((__m64)v9->m64_u64, 0), _m_punpckhbw((__m64)v9->m64_u64, 0));
        v9 += 2;
        v10 += 2;
        ++i;
      }
      v7 = (__m64 *)((char *)v19 + a5 + a5);
      v8 = (unsigned int *)((char *)v8 + a6);
    }
    while ( (int)v7 < v20 );
  }
  _m_empty();
  return 0;
}

// sub_100134EA @ 0x100134EA
int sub_100134EA()
{
  if ( sub_1001BF5E() )
  {
    off_10054390 = (_DWORD (*)())sub_100133D4;
    off_10054394 = (int (*)())sub_100133D4;
  }
  else
  {
    off_10054390 = (_DWORD (*)())sub_10013195;
    off_10054394 = (int (*)())sub_100132EC;
  }
  return off_10054390();
}

// sub_10013522 @ 0x10013522
int sub_10013522()
{
  int (*v0)(); // eax

  if ( sub_1001BF5E() )
  {
    v0 = (int (*)())sub_100133D4;
    off_10054390 = (_DWORD (*)())sub_100133D4;
  }
  else
  {
    off_10054390 = (_DWORD (*)())sub_10013195;
    v0 = (int (*)())sub_100132EC;
  }
  off_10054394 = v0;
  return v0();
}

// FUN_10013551 @ 0x10013551
// [binja] int32_t __fastcall sub_10013551(int32_t* arg1)
int sub_10013551()
{
  return off_10054394();
}

// FUN_10013582 @ 0x10013582
// [binja] int32_t __fastcall sub_10013582(int32_t* arg1)
int __fastcall sub_10013582(_DWORD *a1)
{
  int v1; // esi
  int v2; // edi
  unsigned __int16 *v3; // eax
  unsigned __int16 *v4; // ebp
  _WORD *v5; // edi
  unsigned __int16 *v6; // ebx
  int v7; // ecx
  int v8; // esi
  int v9; // eax
  __int16 v10; // bx
  _WORD *v11; // eax
  bool v12; // cf
  _WORD *v14; // [esp+Ch] [ebp-24h]
  _WORD *v15; // [esp+10h] [ebp-20h]
  unsigned __int16 *v16; // [esp+14h] [ebp-1Ch]
  _WORD *v17; // [esp+18h] [ebp-18h]
  unsigned __int16 *v18; // [esp+1Ch] [ebp-14h]
  unsigned int v19; // [esp+24h] [ebp-Ch]
  _DWORD *v20; // [esp+28h] [ebp-8h]
  unsigned __int16 *i; // [esp+2Ch] [ebp-4h]

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 4176);
  v15 = *(_WORD **)(a1[1] + 24);
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = (unsigned __int16 *)((char *)v3 + v2 * *(_DWORD *)(*a1 + 4188));
  v20 = a1;
  v18 = v3;
  for ( i = v4; v3 < v4; v18 = v3 )
  {
    v14 = v15;
    v5 = (unsigned __int16 *)((char *)v3 + v2);
    v6 = v3;
    v16 = v3;
    v17 = v5;
    v19 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v19 )
    {
      do
      {
        v7 = *v6;
        v8 = v6[1];
        v9 = (unsigned __int16)v5[1];
        v10 = (((*v5 & 0xF81F) + (v7 & 0xF81F) + (v9 & 0xF81F) + (v8 & 0xF81Fu) + 4098) >> 2)
            ^ ((((v8 & 0xFFFF07E0) + (*v5 & 0x7E0) + (v7 & 0xFFFF07E0) + (v9 & 0xFFFF07E0) + 64) >> 2)
             ^ (((*v5 & 0xF81F) + (v7 & 0xFFFFF81F) + (v9 & 0xFFFFF81F) + (v8 & 0xFFFFF81F) + 4098) >> 2))
            & 0x7E0;
        v11 = v14++;
        *v11 = v10;
        v6 = v16 + 2;
        v5 = v17 + 2;
        v12 = (unsigned int)(v16 + 2) < v19;
        v16 += 2;
        v17 += 2;
      }
      while ( v12 );
      a1 = v20;
      v3 = v18;
      v4 = i;
    }
    v15 = (_WORD *)((char *)v15 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v2 = *(_DWORD *)(*a1 + 4176);
    v3 += v2;
  }
  return 0;
}

// FUN_100136d2 @ 0x100136D2
// [binja] int32_t __fastcall sub_100136d2(int32_t* arg1)
int __fastcall sub_100136D2(_DWORD *a1)
{
  int v1; // eax
  int v2; // ebx
  unsigned __int16 *v3; // esi
  unsigned __int16 *v4; // edx
  unsigned __int16 *v5; // ebx
  unsigned __int16 *v6; // ebp
  int v7; // edx
  int v8; // eax
  int v9; // ebx
  unsigned int v10; // ebp
  int v11; // eax
  _WORD *v12; // eax
  _WORD *v14; // [esp+8h] [ebp-20h]
  _WORD *v15; // [esp+Ch] [ebp-1Ch]
  unsigned __int16 *v16; // [esp+10h] [ebp-18h]
  unsigned __int16 *v17; // [esp+14h] [ebp-14h]
  int v18; // [esp+18h] [ebp-10h]
  unsigned __int16 *v19; // [esp+1Ch] [ebp-Ch]
  _DWORD *v20; // [esp+20h] [ebp-8h]
  unsigned __int16 *i; // [esp+24h] [ebp-4h]

  v15 = *(_WORD **)(a1[1] + 24);
  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 4176);
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = (unsigned __int16 *)((char *)v3 + v2 * *(_DWORD *)(*a1 + 4188));
  v20 = a1;
  for ( i = v4; v3 < v4; v3 += v2 )
  {
    v14 = v15;
    v5 = (unsigned __int16 *)((char *)v3 + v2);
    v6 = v3;
    v16 = v3;
    v17 = v5;
    v19 = &v3[*(_DWORD *)(v1 + 4184)];
    if ( v3 < v19 )
    {
      do
      {
        v7 = v6[1];
        v8 = v5[1];
        v9 = *v5;
        v18 = *v6;
        v10 = (v7 & 0xFFFF03E0) + (v9 & 0xFFFF03E0) + (v18 & 0xFFFF03E0) + (v8 & 0xFFFF03E0) + 64;
        v11 = (v9 & 0x7C1F) + (v18 & 0x7C1F) + (v8 & 0x7C1F);
        v5 = v17 + 2;
        v17 += 2;
        LOWORD(v10) = ((v11 + (v7 & 0x7C1Fu) + 2050) >> 2) & 0x7C1F | (v10 >> 2) & 0x3E0;
        v12 = v14++;
        *v12 = v10;
        v6 = v16 + 2;
        v16 += 2;
      }
      while ( v16 < v19 );
      a1 = v20;
      v4 = i;
    }
    v15 = (_WORD *)((char *)v15 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v2 = *(_DWORD *)(*a1 + 4176);
  }
  return 0;
}

// FUN_100137f6 @ 0x100137F6
// [binja] int32_t __fastcall sub_100137f6(int32_t* arg1)
int __fastcall sub_100137F6(_DWORD *a1)
{
  int v1; // esi
  char *v2; // edx
  int v3; // edi
  char *v4; // ebp
  char *v5; // edi
  char *v6; // ebx
  __int16 v7; // si
  __int16 v8; // dx
  __int16 v9; // di
  _WORD *v10; // ecx
  bool v11; // cf
  _WORD *v13; // [esp+Ch] [ebp-24h]
  _WORD *v14; // [esp+10h] [ebp-20h]
  char *v15; // [esp+14h] [ebp-1Ch]
  char *v16; // [esp+18h] [ebp-18h]
  char *v17; // [esp+1Ch] [ebp-14h]
  unsigned int v18; // [esp+24h] [ebp-Ch]
  _DWORD *v19; // [esp+28h] [ebp-8h]
  char *i; // [esp+2Ch] [ebp-4h]

  v1 = *a1;
  v2 = *(char **)(*a1 + 24);
  v3 = *(_DWORD *)(*a1 + 4176);
  v4 = &v2[v3 * *(_DWORD *)(*a1 + 4188)];
  v19 = a1;
  v14 = *(_WORD **)(a1[1] + 24);
  v17 = v2;
  for ( i = v4; v2 < v4; v17 = v2 )
  {
    v13 = v14;
    v5 = &v2[v3];
    v6 = v2;
    v15 = v2;
    v16 = v5;
    v18 = (unsigned int)&v2[2 * *(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v2 < v18 )
    {
      do
      {
        v7 = *((_WORD *)v6 + 1);
        v8 = *((_WORD *)v5 + 1);
        v9 = *(_WORD *)v5;
        v10 = v13++;
        *v10 = (((v9 & 0x83E0) + (*(_WORD *)v6 & 0x83E0) + (v8 & 0x83E0) + (v7 & 0x83E0u) + 65600) >> 2)
             ^ ((((v7 & 0x7C1F) + (v9 & 0x7C1F) + (*(_WORD *)v6 & 0x7C1F) + (v8 & 0x7C1Fu) + 2050) >> 2)
              ^ (((v9 & 0x83E0) + (*(_WORD *)v6 & 0x83E0) + (v8 & 0x83E0) + (v7 & 0x83E0u) + 65600) >> 2))
             & 0x7C1F;
        v6 = v15 + 4;
        v5 = v16 + 4;
        v11 = (unsigned int)(v15 + 4) < v18;
        v15 += 4;
        v16 += 4;
      }
      while ( v11 );
      a1 = v19;
      v2 = v17;
      v4 = i;
    }
    v14 = (_WORD *)((char *)v14 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v3 = *(_DWORD *)(*a1 + 4176);
    v2 += 2 * v3;
  }
  return 0;
}

// FUN_10013945 @ 0x10013945
// [binja] int32_t __fastcall sub_10013945(int32_t* arg1)
int __fastcall sub_10013945(_DWORD *a1)
{
  int v1; // esi
  int v2; // edi
  unsigned __int16 *v3; // eax
  unsigned __int16 *v4; // ebp
  _WORD *v5; // edi
  unsigned __int16 *v6; // ebx
  int v7; // ecx
  int v8; // esi
  int v9; // eax
  __int16 v10; // bx
  _WORD *v11; // eax
  bool v12; // cf
  _WORD *v14; // [esp+Ch] [ebp-24h]
  _WORD *v15; // [esp+10h] [ebp-20h]
  unsigned __int16 *v16; // [esp+14h] [ebp-1Ch]
  _WORD *v17; // [esp+18h] [ebp-18h]
  unsigned __int16 *v18; // [esp+1Ch] [ebp-14h]
  unsigned int v19; // [esp+24h] [ebp-Ch]
  _DWORD *v20; // [esp+28h] [ebp-8h]
  unsigned __int16 *i; // [esp+2Ch] [ebp-4h]

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 4176);
  v15 = *(_WORD **)(a1[1] + 24);
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = (unsigned __int16 *)((char *)v3 + v2 * *(_DWORD *)(*a1 + 4188));
  v20 = a1;
  v18 = v3;
  for ( i = v4; v3 < v4; v18 = v3 )
  {
    v14 = v15;
    v5 = (unsigned __int16 *)((char *)v3 + v2);
    v6 = v3;
    v16 = v3;
    v17 = v5;
    v19 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v19 )
    {
      do
      {
        v7 = *v6;
        v8 = v6[1];
        v9 = (unsigned __int16)v5[1];
        v10 = (((*v5 & 0xF0F0) + (v7 & 0xF0F0) + (v9 & 0xF0F0) + (v8 & 0xF0F0u) + 8224) >> 2)
            ^ ((((v8 & 0xFFFF0F0F) + (*v5 & 0xF0F) + (v7 & 0xFFFF0F0F) + (v9 & 0xFFFF0F0F) + 514) >> 2)
             ^ (((*v5 & 0xF0F0) + (v7 & 0xFFFFF0F0) + (v9 & 0xFFFFF0F0) + (v8 & 0xFFFFF0F0) + 8224) >> 2))
            & 0xF0F;
        v11 = v14++;
        *v11 = v10;
        v6 = v16 + 2;
        v5 = v17 + 2;
        v12 = (unsigned int)(v16 + 2) < v19;
        v16 += 2;
        v17 += 2;
      }
      while ( v12 );
      a1 = v20;
      v3 = v18;
      v4 = i;
    }
    v15 = (_WORD *)((char *)v15 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v2 = *(_DWORD *)(*a1 + 4176);
    v3 += v2;
  }
  return 0;
}

// FUN_10013a98 @ 0x10013A98
// [binja] int32_t __fastcall sub_10013a98(int32_t* arg1)
int __fastcall sub_10013A98(_DWORD *a1)
{
  int v1; // edx
  _BYTE *v2; // ebp
  unsigned __int8 *v3; // eax
  int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebx
  int v8; // ebp
  int v9; // esi
  int v10; // eax
  int v11; // edi
  char v12; // dl
  _BYTE *v13; // eax
  bool v14; // cf
  _BYTE *v16; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v17; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v18; // [esp+14h] [ebp-18h]
  _BYTE *v19; // [esp+18h] [ebp-14h]
  unsigned __int8 *v20; // [esp+1Ch] [ebp-10h]
  unsigned int v21; // [esp+20h] [ebp-Ch]
  _DWORD *v22; // [esp+24h] [ebp-8h]
  unsigned __int8 *i; // [esp+28h] [ebp-4h]

  v1 = *a1;
  v2 = *(_BYTE **)(a1[1] + 24);
  v3 = *(unsigned __int8 **)(*a1 + 24);
  v4 = *(_DWORD *)(*a1 + 4176);
  v5 = &v3[v4 * *(_DWORD *)(*a1 + 4188)];
  v22 = a1;
  v19 = v2;
  v20 = v3;
  for ( i = v5; v3 < v5; v20 = v3 )
  {
    v6 = &v3[v4];
    v7 = v3;
    v16 = v2;
    v17 = v3;
    v18 = v6;
    v21 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v21 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = v6[1];
        v11 = *v6;
        LOWORD(v8) = v8 & 0xE3;
        LOWORD(v9) = v9 & 0xE3;
        v12 = (((v11 & 0xE3) + v8 + (v10 & 0xE3u) + v9 + 66) >> 2)
            ^ ((((v11 & 0xFFFF00E3) + (*v7 & 0xE3) + (v10 & 0xFFFF00E3) + (v7[1] & 0xE3) + 66) >> 2)
             ^ (((v11 & 0x1C) + (*v7 & 0x1C) + (v10 & 0x1C) + (v7[1] & 0x1Cu) + 8) >> 2))
            & 0x1C;
        v13 = v16++;
        v7 = v17 + 2;
        v6 = v18 + 2;
        v14 = (unsigned int)(v17 + 2) < v21;
        *v13 = v12;
        v17 += 2;
        v18 += 2;
      }
      while ( v14 );
      a1 = v22;
      v2 = v19;
      v3 = v20;
      v5 = i;
    }
    v2 += *(_DWORD *)(a1[1] + 4176);
    v1 = *a1;
    v4 = *(_DWORD *)(*a1 + 4176);
    v3 += 2 * v4;
    v19 = v2;
  }
  return 0;
}

// FUN_10013bd7 @ 0x10013BD7
// [binja] int32_t __fastcall sub_10013bd7(int32_t* arg1)
int __thiscall sub_10013BD7(_DWORD *this)
{
  _BYTE *v1; // ebx
  int v2; // eax
  unsigned __int8 *v3; // edx
  int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned int v6; // eax
  unsigned __int8 *v7; // edi
  bool i; // cf
  int v9; // edi
  int v10; // ebx
  unsigned int v11; // ebx
  _BYTE *v12; // edi
  _BYTE *v14; // [esp+Ch] [ebp-10h]
  unsigned __int8 *v15; // [esp+10h] [ebp-Ch]
  _BYTE *v16; // [esp+14h] [ebp-8h]
  unsigned __int8 *v17; // [esp+18h] [ebp-4h]

  v1 = *(_BYTE **)(*(this + 1) + 24);
  v2 = *this;
  v3 = *(unsigned __int8 **)(*this + 24);
  v4 = *(_DWORD *)(*this + 4176);
  v5 = &v3[v4 * *(_DWORD *)(*this + 4188)];
  while ( 1 )
  {
    v14 = v1;
    if ( v3 >= v5 )
      break;
    v6 = (unsigned int)&v3[*(_DWORD *)(v2 + 4184)];
    v7 = &v3[v4];
    v16 = v1;
    v17 = v3;
    for ( i = (unsigned int)v3 < v6; ; i = (unsigned int)v17 < v6 )
    {
      v15 = v7;
      if ( !i )
        break;
      v9 = *v7 + v17[1] + v7[1];
      v10 = *v17;
      v17 += 2;
      v11 = v9 + v10 + 2;
      v12 = v16++;
      *v12 = v11 >> 2;
      v7 = v15 + 2;
    }
    v1 = &v14[*(_DWORD *)(*(this + 1) + 4176)];
    v2 = *this;
    v4 = *(_DWORD *)(*this + 4176);
    v3 += 2 * v4;
  }
  return 0;
}

// FUN_10013c72 @ 0x10013C72
// [binja] int32_t __fastcall sub_10013c72(int32_t* arg1)
int __fastcall sub_10013C72(_DWORD *a1)
{
  int v1; // edx
  int v2; // ebp
  unsigned __int16 *v3; // eax
  unsigned __int16 *v4; // edi
  unsigned __int16 *v5; // ebp
  unsigned __int16 *v6; // ebx
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v10; // ebp
  unsigned int v11; // ebx
  int v12; // ecx
  int v13; // eax
  unsigned int v14; // edx
  int v15; // ebp
  unsigned int v16; // ecx
  int v17; // edi
  unsigned int v18; // edx
  _WORD *v19; // eax
  bool v20; // cf
  _WORD *v22; // [esp+8h] [ebp-24h]
  _WORD *v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  unsigned __int16 *v25; // [esp+14h] [ebp-18h]
  unsigned __int16 *v26; // [esp+18h] [ebp-14h]
  unsigned __int16 *v27; // [esp+1Ch] [ebp-10h]
  unsigned int v28; // [esp+20h] [ebp-Ch]
  _DWORD *v29; // [esp+24h] [ebp-8h]
  unsigned __int16 *i; // [esp+28h] [ebp-4h]

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 4176);
  v23 = *(_WORD **)(a1[1] + 24);
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = (unsigned __int16 *)((char *)v3 + v2 * *(_DWORD *)(*a1 + 4188));
  v29 = a1;
  v27 = v3;
  for ( i = v4; v3 < v4; v27 = v3 )
  {
    v22 = v23;
    v5 = (unsigned __int16 *)((char *)v3 + v2);
    v6 = v3;
    v25 = v3;
    v26 = v5;
    v28 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v28 )
    {
      do
      {
        v7 = *v6;
        v8 = v6[1];
        v9 = v5[1];
        v10 = *v5;
        v24 = v7;
        LOWORD(v7) = *v6 & 0xE3;
        v11 = (v10 & 0xFFFF00E3) + v7 + (v9 & 0xFFFF00E3);
        HIWORD(v12) = HIWORD(v9);
        v13 = v9 & 0xFF1C;
        LOWORD(v12) = v13;
        v14 = (v11 + (v8 & 0xFFFF00E3) + 66) >> 2;
        HIWORD(v11) = HIWORD(v10);
        v15 = v10 & 0xFF1C;
        LOWORD(v11) = v15;
        v16 = v11 + (v24 & 0xFFFFFF1C) + v12;
        HIWORD(v11) = HIWORD(v8);
        v17 = v8 & 0xFF1C;
        LOWORD(v11) = v17;
        LOBYTE(v14) = ((v16 + v11 + 520) >> 2) ^ v14;
        v18 = ((v15 + (v24 & 0xFF1Cu) + v13 + v17 + 520) >> 2) ^ v14 & 0xFFFF00E3;
        v19 = v22++;
        v6 = v25 + 2;
        v5 = v26 + 2;
        v20 = (unsigned int)(v25 + 2) < v28;
        *v19 = v18;
        v25 += 2;
        v26 += 2;
      }
      while ( v20 );
      a1 = v29;
      v3 = v27;
      v4 = i;
    }
    v23 = (_WORD *)((char *)v23 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v2 = *(_DWORD *)(*a1 + 4176);
    v3 += v2;
  }
  return 0;
}

// FUN_10013dbe @ 0x10013DBE
// [binja] int32_t __fastcall sub_10013dbe(int32_t* arg1)
int __fastcall sub_10013DBE(_DWORD *a1)
{
  _WORD *v1; // ebp
  int v2; // eax
  unsigned __int16 *v3; // esi
  int v4; // edi
  unsigned __int16 *v5; // edx
  unsigned __int16 *v6; // edi
  unsigned __int16 *v7; // ebx
  int v8; // edx
  int v9; // eax
  int v10; // ebx
  int v11; // edi
  unsigned int v12; // ebp
  unsigned int v13; // eax
  unsigned int v14; // ebp
  _WORD *v15; // eax
  _WORD *v17; // [esp+Ch] [ebp-1Ch]
  unsigned __int16 *v18; // [esp+10h] [ebp-18h]
  unsigned __int16 *v19; // [esp+14h] [ebp-14h]
  _WORD *v20; // [esp+18h] [ebp-10h]
  unsigned int v21; // [esp+1Ch] [ebp-Ch]
  _DWORD *v22; // [esp+20h] [ebp-8h]
  unsigned __int16 *i; // [esp+24h] [ebp-4h]

  v1 = *(_WORD **)(a1[1] + 24);
  v2 = *a1;
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = *(_DWORD *)(*a1 + 4176);
  v5 = (unsigned __int16 *)((char *)v3 + v4 * *(_DWORD *)(*a1 + 4188));
  v22 = a1;
  v20 = v1;
  for ( i = v5; v3 < v5; v20 = v1 )
  {
    v6 = (unsigned __int16 *)((char *)v3 + v4);
    v7 = v3;
    v17 = v1;
    v18 = v3;
    v19 = v6;
    v21 = (unsigned int)&v3[*(_DWORD *)(v2 + 4184)];
    if ( (unsigned int)v3 < v21 )
    {
      do
      {
        v8 = v7[1];
        v9 = v6[1];
        v10 = *v7;
        v11 = *v6;
        v12 = (v11 & 0xFFFF00F0) + (v10 & 0xFFFF00F0) + (v9 & 0xFFFF00F0) + (v8 & 0xFFFF00F0) + 32;
        LOWORD(v9) = v9 & 0xF0F;
        LOWORD(v10) = v10 & 0xF0F;
        LOWORD(v11) = v11 & 0xF0F;
        LOWORD(v8) = v8 & 0xF0F;
        v13 = (unsigned int)(v11 + v10 + v9 + v8 + 514) >> 2;
        LOWORD(v13) = v13 & 0xF0F;
        v7 = v18 + 2;
        v6 = v19 + 2;
        v18 = v7;
        v19 += 2;
        v14 = v13 | (v12 >> 2) & 0xFFFF00F0;
        v15 = v17++;
        *v15 = v14;
      }
      while ( (unsigned int)v7 < v21 );
      a1 = v22;
      v1 = v20;
      v5 = i;
    }
    v1 = (_WORD *)((char *)v1 + *(_DWORD *)(a1[1] + 4176));
    v2 = *a1;
    v4 = *(_DWORD *)(*a1 + 4176);
    v3 += v4;
  }
  return 0;
}

// FUN_10013edf @ 0x10013EDF
// [binja] int32_t __fastcall sub_10013edf(int32_t* arg1)
int __fastcall sub_10013EDF(_DWORD *a1)
{
  int v1; // edx
  int v2; // ebp
  unsigned __int16 *v3; // eax
  unsigned __int16 *v4; // edi
  unsigned __int16 *v5; // ebp
  unsigned __int16 *v6; // ebx
  int v7; // edx
  int v8; // edi
  int v9; // eax
  int v10; // ebp
  unsigned int v11; // ebx
  int v12; // ecx
  int v13; // eax
  unsigned int v14; // edx
  int v15; // ebp
  unsigned int v16; // ecx
  int v17; // edi
  unsigned int v18; // edx
  _WORD *v19; // eax
  bool v20; // cf
  _WORD *v22; // [esp+8h] [ebp-24h]
  _WORD *v23; // [esp+Ch] [ebp-20h]
  int v24; // [esp+10h] [ebp-1Ch]
  unsigned __int16 *v25; // [esp+14h] [ebp-18h]
  unsigned __int16 *v26; // [esp+18h] [ebp-14h]
  unsigned __int16 *v27; // [esp+1Ch] [ebp-10h]
  unsigned int v28; // [esp+20h] [ebp-Ch]
  _DWORD *v29; // [esp+24h] [ebp-8h]
  unsigned __int16 *i; // [esp+28h] [ebp-4h]

  v1 = *a1;
  v2 = *(_DWORD *)(*a1 + 4176);
  v23 = *(_WORD **)(a1[1] + 24);
  v3 = *(unsigned __int16 **)(*a1 + 24);
  v4 = (unsigned __int16 *)((char *)v3 + v2 * *(_DWORD *)(*a1 + 4188));
  v29 = a1;
  v27 = v3;
  for ( i = v4; v3 < v4; v27 = v3 )
  {
    v22 = v23;
    v5 = (unsigned __int16 *)((char *)v3 + v2);
    v6 = v3;
    v25 = v3;
    v26 = v5;
    v28 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v28 )
    {
      do
      {
        v7 = *v6;
        v8 = v6[1];
        v9 = v5[1];
        v10 = *v5;
        v24 = v7;
        LOWORD(v7) = (unsigned __int8)*v6;
        v11 = (v10 & 0xFFFF00FF) + v7 + (v9 & 0xFFFF00FF);
        HIWORD(v12) = HIWORD(v9);
        v13 = v9 & 0xFF00;
        LOWORD(v12) = v13;
        v14 = (v11 + (v8 & 0xFFFF00FF) + 2) >> 2;
        HIWORD(v11) = HIWORD(v10);
        v15 = v10 & 0xFF00;
        LOWORD(v11) = v15;
        v16 = v11 + (v24 & 0xFFFFFF00) + v12;
        HIWORD(v11) = HIWORD(v8);
        v17 = v8 & 0xFF00;
        LOWORD(v11) = v17;
        LOBYTE(v14) = ((v16 + v11 + 512) >> 2) ^ v14;
        v18 = ((v15 + (v24 & 0xFF00u) + v13 + v17 + 512) >> 2) ^ v14 & 0xFFFF00FF;
        v19 = v22++;
        v6 = v25 + 2;
        v5 = v26 + 2;
        v20 = (unsigned int)(v25 + 2) < v28;
        *v19 = v18;
        v25 += 2;
        v26 += 2;
      }
      while ( v20 );
      a1 = v29;
      v3 = v27;
      v4 = i;
    }
    v23 = (_WORD *)((char *)v23 + *(_DWORD *)(a1[1] + 4176));
    v1 = *a1;
    v2 = *(_DWORD *)(*a1 + 4176);
    v3 += v2;
  }
  return 0;
}

// FUN_1001402b @ 0x1001402B
// [binja] int32_t __fastcall sub_1001402b(int32_t* arg1)
int __fastcall sub_1001402B(_DWORD *a1)
{
  int v1; // edx
  _BYTE *v2; // ebp
  unsigned __int8 *v3; // eax
  int v4; // edi
  unsigned __int8 *v5; // esi
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebx
  int v8; // ebp
  int v9; // esi
  int v10; // eax
  int v11; // edi
  char v12; // dl
  _BYTE *v13; // eax
  bool v14; // cf
  _BYTE *v16; // [esp+Ch] [ebp-20h]
  unsigned __int8 *v17; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v18; // [esp+14h] [ebp-18h]
  _BYTE *v19; // [esp+18h] [ebp-14h]
  unsigned __int8 *v20; // [esp+1Ch] [ebp-10h]
  unsigned int v21; // [esp+20h] [ebp-Ch]
  _DWORD *v22; // [esp+24h] [ebp-8h]
  unsigned __int8 *i; // [esp+28h] [ebp-4h]

  v1 = *a1;
  v2 = *(_BYTE **)(a1[1] + 24);
  v3 = *(unsigned __int8 **)(*a1 + 24);
  v4 = *(_DWORD *)(*a1 + 4176);
  v5 = &v3[v4 * *(_DWORD *)(*a1 + 4188)];
  v22 = a1;
  v19 = v2;
  v20 = v3;
  for ( i = v5; v3 < v5; v20 = v3 )
  {
    v6 = &v3[v4];
    v7 = v3;
    v16 = v2;
    v17 = v3;
    v18 = v6;
    v21 = (unsigned int)&v3[*(_DWORD *)(v1 + 4184)];
    if ( (unsigned int)v3 < v21 )
    {
      do
      {
        v8 = *v7;
        v9 = v7[1];
        v10 = v6[1];
        v11 = *v6;
        LOWORD(v8) = v8 & 0xF0;
        LOWORD(v9) = v9 & 0xF0;
        v12 = (((v11 & 0xF0) + v8 + (v10 & 0xF0u) + v9 + 32) >> 2)
            ^ ((((v11 & 0xFFFF00F0) + (*v7 & 0xF0) + (v10 & 0xFFFF00F0) + (v7[1] & 0xF0) + 32) >> 2)
             ^ (((v11 & 0xF) + (*v7 & 0xF) + (v10 & 0xF) + (v7[1] & 0xFu) + 2) >> 2))
            & 0xF;
        v13 = v16++;
        v7 = v17 + 2;
        v6 = v18 + 2;
        v14 = (unsigned int)(v17 + 2) < v21;
        *v13 = v12;
        v17 += 2;
        v18 += 2;
      }
      while ( v14 );
      a1 = v22;
      v2 = v19;
      v3 = v20;
      v5 = i;
    }
    v2 += *(_DWORD *)(a1[1] + 4176);
    v1 = *a1;
    v4 = *(_DWORD *)(*a1 + 4176);
    v3 += 2 * v4;
    v19 = v2;
  }
  return 0;
}

// FUN_1001416a @ 0x1001416A
// [binja] int32_t __fastcall sub_1001416a(int32_t* arg1)
int __thiscall sub_1001416A(_DWORD *this)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  char *v5; // edx
  char *v6; // ebx
  unsigned int v7; // [esp+8h] [ebp-10h]
  unsigned int i; // [esp+Ch] [ebp-Ch]
  _DWORD *v9; // [esp+10h] [ebp-8h]
  unsigned int v10; // [esp+14h] [ebp-4h]

  v1 = this;
  v2 = (_DWORD *)*(this + 1);
  v3 = (_DWORD *)*this;
  v9 = v1;
  if ( v2[1] != v3[1] )
    return -2147467259;
  if ( v3[4] )
    return -2147467259;
  if ( v2[1046] != v3[1046] )
    return -2147467259;
  v7 = v2[1047];
  if ( v7 != v3[1047] || v2[1048] != v3[1048] )
    return -2147467259;
  if ( !v2[3] )
    return FUN_10013007(v1);
  if ( v2[5] && v2 + 12 != v3 + 12 && memcmp(v2 + 12, v3 + 12, 0x400u) )
    return -2147467259;
  v10 = 0;
  if ( v2[1048] )
  {
    while ( 1 )
    {
      v5 = (char *)(v2[6] + v10 * v2[1045]);
      v6 = (char *)(*(_DWORD *)(*v9 + 24) + v10 * *(_DWORD *)(*v1 + 4180));
      for ( i = 0; i < v7; v7 = v2[1047] )
      {
        qmemcpy(v5, v6, v2[1049]);
        v2 = (_DWORD *)v9[1];
        v6 += *(_DWORD *)(*v9 + 4176);
        v5 += v2[1044];
        ++i;
      }
      ++v10;
      v2 = (_DWORD *)v9[1];
      if ( v10 >= v2[1048] )
        break;
      v1 = v9;
    }
  }
  return 0;
}

// FUN_100142a2 @ 0x100142A2
// [binja] int32_t __fastcall sub_100142a2(int32_t* arg1)
int __thiscall sub_100142A2(_DWORD *this)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ecx
  int v4; // edi
  void *v5; // eax
  void *v6; // ebx
  unsigned int v7; // ebx
  int v8; // eax
  unsigned int v9; // eax
  unsigned int i; // edi
  void *v12; // [esp+Ch] [ebp-10h]

  v2 = (_DWORD *)*(this + 1);
  v3 = (_DWORD *)*this;
  v4 = v2[1046];
  if ( v4 != v3[1046] || v2[1047] != v3[1047] || v2[1048] != v3[1048] )
    return -2147467259;
  v5 = operator new(16 * v4);
  v6 = v5;
  if ( v5 )
  {
    sub_1000B393((int)v5, 16, v4, (int (__thiscall *)(int))sub_1000AE4F);
    v12 = v6;
  }
  else
  {
    v12 = 0;
  }
  v7 = 0;
  if ( !v12 )
    return -2147467259;
  v8 = *(this + 1);
  if ( *(_DWORD *)(v8 + 4192) )
  {
    v9 = *(_DWORD *)(v8 + 4188);
    do
    {
      for ( i = 0; i < v9; ++i )
      {
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, void *))(*(_DWORD *)*this + 4))(*this, i, v7, v12);
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, void *))(*(_DWORD *)*(this + 1) + 8))(
          *(this + 1),
          i,
          v7,
          v12);
        v9 = *(_DWORD *)(*(this + 1) + 4188);
      }
      ++v7;
    }
    while ( v7 < *(_DWORD *)(*(this + 1) + 4192) );
  }
  operator delete(v12);
  return 0;
}

// FUN_10014393 @ 0x10014393
// [binja] int32_t __fastcall sub_10014393(int32_t* arg1)
int __thiscall sub_10014393(_DWORD *this)
{
  _DWORD *v3; // eax
  _DWORD *v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // edi
  void *v7; // eax
  void *v8; // eax
  unsigned int v9; // ebx
  unsigned int i; // edi
  _DWORD *v11; // ecx
  unsigned int j; // edi
  _DWORD *v13; // ecx
  unsigned int v14; // eax
  unsigned int k; // edi
  unsigned int v16; // [esp+4h] [ebp-20h]
  unsigned int v17; // [esp+8h] [ebp-1Ch]
  unsigned int v18; // [esp+Ch] [ebp-18h]
  int v19; // [esp+Ch] [ebp-18h]
  void *v20; // [esp+Ch] [ebp-18h]
  void *v21; // [esp+10h] [ebp-14h]
  void *v22; // [esp+10h] [ebp-14h]
  char *v23; // [esp+10h] [ebp-14h]
  void *v24; // [esp+14h] [ebp-10h]

  if ( *((_BYTE *)this + 8) != 1 )
    return -2147467259;
  v3 = (_DWORD *)*(this + 1);
  v4 = (_DWORD *)*this;
  v18 = v3[1046];
  if ( v18 <= v4[1046] )
    v18 = v4[1046];
  v16 = v3[1047];
  if ( v16 >= v4[1047] )
    v16 = v4[1047];
  v5 = v4[1048];
  v17 = v3[1048];
  if ( v17 >= v5 )
    v17 = v5;
  v6 = 16 * v18;
  v7 = operator new(16 * v18);
  v21 = v7;
  if ( v7 )
  {
    sub_1000B393((int)v7, 16, v18, (int (__thiscall *)(int))sub_1000AE4F);
    v24 = v21;
  }
  else
  {
    v24 = 0;
  }
  if ( !v24 )
    return -2147467259;
  v19 = *(_DWORD *)(*(this + 1) + 4184);
  v8 = operator new(16 * v19);
  v22 = v8;
  if ( v8 )
  {
    sub_1000B393((int)v8, 16, v19, (int (__thiscall *)(int))sub_1000AE4F);
    v20 = v22;
  }
  else
  {
    v20 = 0;
  }
  if ( v20 )
  {
    v9 = v17;
    v23 = 0;
    memset(v24, 0, v6);
    memset(v20, 0, 16 * *(_DWORD *)(*(this + 1) + 4184));
    if ( v17 )
    {
      do
      {
        for ( i = 0; i < v16; ++i )
        {
          (*(void (__thiscall **)(_DWORD, unsigned int, char *, void *))(*(_DWORD *)*this + 4))(*this, i, v23, v24);
          (*(void (__thiscall **)(_DWORD, unsigned int, char *, void *))(*(_DWORD *)*(this + 1) + 8))(
            *(this + 1),
            i,
            v23,
            v24);
        }
        v11 = (_DWORD *)*(this + 1);
        for ( j = v16; j < v11[1047]; ++j )
        {
          (*(void (__thiscall **)(_DWORD *, unsigned int, char *, void *))(*v11 + 8))(v11, j, v23, v20);
          v11 = (_DWORD *)*(this + 1);
        }
        v9 = v17;
        ++v23;
      }
      while ( (unsigned int)v23 < v17 );
    }
    v13 = (_DWORD *)*(this + 1);
    if ( v9 < v13[1048] )
    {
      v14 = v13[1047];
      do
      {
        for ( k = 0; k < v14; ++k )
        {
          (*(void (__thiscall **)(_DWORD *, unsigned int, unsigned int, void *))(*v13 + 8))(v13, k, v9, v20);
          v13 = (_DWORD *)*(this + 1);
          v14 = v13[1047];
        }
        v13 = (_DWORD *)*(this + 1);
        ++v9;
      }
      while ( v9 < v13[1048] );
    }
    operator delete(v24);
    operator delete(v20);
    return 0;
  }
  else
  {
    operator delete(v24);
    return -2147467259;
  }
}

// FUN_10014595 @ 0x10014595
// [binja] int32_t __fastcall sub_10014595(int32_t* arg1)
int __thiscall sub_10014595(_DWORD *this)
{
  int v3; // edi
  char *v4; // eax
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // esi
  unsigned int v8; // edi
  unsigned int v9; // esi
  _DWORD *v10; // eax
  unsigned int v11; // esi
  char *v12; // esi
  int v13; // [esp+4h] [ebp-3Ch]
  int v14; // [esp+8h] [ebp-38h]
  int v15; // [esp+Ch] [ebp-34h]
  char *v16; // [esp+10h] [ebp-30h]
  _DWORD *v17; // [esp+10h] [ebp-30h]
  char *v18; // [esp+10h] [ebp-30h]
  int v19; // [esp+14h] [ebp-2Ch]
  unsigned int v20; // [esp+18h] [ebp-28h]
  unsigned int v21; // [esp+1Ch] [ebp-24h]
  unsigned int v22; // [esp+20h] [ebp-20h]
  unsigned int v23; // [esp+24h] [ebp-1Ch]
  unsigned int i; // [esp+28h] [ebp-18h]
  _DWORD *v25; // [esp+2Ch] [ebp-14h]
  char *v26; // [esp+30h] [ebp-10h]

  if ( *((_BYTE *)this + 8) != 2 )
    return -2147467259;
  v3 = *(_DWORD *)(*this + 4184);
  v4 = (char *)operator new(16 * v3);
  v16 = v4;
  if ( v4 )
  {
    sub_1000B393((int)v4, 16, v3, (int (__thiscall *)(int))sub_1000AE4F);
    v26 = v16;
  }
  else
  {
    v26 = 0;
  }
  if ( !v26 )
    return -2147024882;
  v5 = *(_DWORD *)(*(this + 1) + 4184);
  v6 = operator new(16 * v5);
  v17 = v6;
  if ( v6 )
  {
    sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    v25 = v17;
  }
  else
  {
    v25 = 0;
  }
  if ( v25 )
  {
    v7 = (_DWORD *)*(this + 1);
    v8 = v7[1047];
    v20 = 0;
    v23 = 0;
    v15 = (*(_DWORD *)(*this + 4184) << 16) / v7[1046];
    v14 = (*(_DWORD *)(*this + 4188) << 16) / v8;
    v13 = (*(_DWORD *)(*this + 4192) << 16) / v7[1048];
    do
    {
      v19 = -1;
      v9 = 0;
      v18 = 0;
      for ( i = 0; i < v8; v18 += v14 )
      {
        v22 = 0;
        v21 = 0;
        if ( ((v9 ^ v19) & 0xFFFF0000) != 0 )
        {
          (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, char *))(*(_DWORD *)*this + 4))(
            *this,
            HIWORD(v9),
            HIWORD(v20),
            v26);
          v19 = v9;
        }
        if ( *(_DWORD *)(*(this + 1) + 4184) )
        {
          v10 = v25;
          do
          {
            v11 = v22;
            v22 += v15;
            v12 = &v26[16 * HIWORD(v11)];
            ++v21;
            *v10 = *(_DWORD *)v12;
            v12 += 4;
            v10[1] = *(_DWORD *)v12;
            v12 += 4;
            v10[2] = *(_DWORD *)v12;
            v10[3] = *((_DWORD *)v12 + 1);
            v10 += 4;
          }
          while ( v21 < *(_DWORD *)(*(this + 1) + 4184) );
        }
        (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, _DWORD *))(*(_DWORD *)*(this + 1) + 8))(
          *(this + 1),
          i,
          v23,
          v25);
        v9 = (unsigned int)&v18[v14];
        ++i;
        v8 = *(_DWORD *)(*(this + 1) + 4188);
      }
      v20 += v13;
      ++v23;
    }
    while ( v23 < *(_DWORD *)(*(this + 1) + 4192) );
    operator delete(v26);
    operator delete(v25);
    return 0;
  }
  else
  {
    operator delete(v26);
    return -2147024882;
  }
}

// FUN_10014799 @ 0x10014799
// [binja] int32_t __fastcall sub_10014799(int32_t* arg1)
int __usercall sub_10014799@<eax>(_DWORD *a1@<ecx>, int a2@<edi>, float *a3@<esi>)
{
  _DWORD *v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  int v9; // esi
  _DWORD *v10; // ecx
  int v11; // eax
  int v12; // ecx
  int v13; // eax
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // esi
  float *v21; // eax
  int v22; // esi
  char *v23; // eax
  char *v24; // eax
  int v25; // esi
  char *v26; // eax
  char *v27; // ecx
  int v28; // esi
  char *v29; // ecx
  unsigned int v30; // edx
  float *v31; // eax
  float *v32; // ecx
  double v33; // st6
  float *v34; // edi
  double v35; // st5
  double v36; // st4
  float *v37; // eax
  double v38; // st6
  double v39; // st5
  double v40; // st4
  float *v41; // eax
  float v44; // [esp+4h] [ebp-6Ch]
  float v45; // [esp+8h] [ebp-68h]
  float v46; // [esp+14h] [ebp-5Ch]
  float v47; // [esp+20h] [ebp-50h]
  float v48; // [esp+2Ch] [ebp-44h]
  float v49; // [esp+30h] [ebp-40h]
  float v50; // [esp+34h] [ebp-3Ch]
  float v51; // [esp+38h] [ebp-38h]
  float v52; // [esp+3Ch] [ebp-34h]
  float v53; // [esp+40h] [ebp-30h]
  float *v54; // [esp+44h] [ebp-2Ch]
  char *v55; // [esp+44h] [ebp-2Ch]
  char *v56; // [esp+44h] [ebp-2Ch]
  char *v57; // [esp+44h] [ebp-2Ch]
  char *v58; // [esp+48h] [ebp-28h]
  char *v59; // [esp+4Ch] [ebp-24h]
  float *v60; // [esp+50h] [ebp-20h]
  float *v61; // [esp+54h] [ebp-1Ch]
  unsigned int i; // [esp+58h] [ebp-18h]
  char *v63; // [esp+5Ch] [ebp-14h]
  char *v64; // [esp+60h] [ebp-10h]

  if ( *((_BYTE *)a1 + 8) != 5 )
    return -2147467259;
  v5 = (_DWORD *)*a1;
  v6 = *(_DWORD *)(*a1 + 4184);
  v7 = (_DWORD *)a1[1];
  v8 = v7[1046];
  if ( v8 != v6 >> 1 && (v8 != 1 || v6 != 1) )
    return -2147467259;
  v9 = v7[1047];
  if ( v9 != v5[1047] >> 1 && (v9 != 1 || v5[1047] != 1) )
    return -2147467259;
  if ( v7[1048] != 1 || v5[1048] != 1 )
    return -2147467259;
  if ( v6 > 1 && (v6 & 1) != 0 )
  {
    v5[1046] = v6 & 0xFFFFFFFE;
    *(_DWORD *)(*a1 + 4196) -= *(_DWORD *)(*a1 + 4200);
  }
  v10 = (_DWORD *)(*a1 + 4188);
  if ( *v10 > 1u )
    *v10 &= ~1u;
  if ( (*((_BYTE *)a1 + 10) & 8) != 0 )
    goto LABEL_44;
  v11 = *a1;
  v12 = *(_DWORD *)(*a1 + 4);
  if ( v12 != *(_DWORD *)(a1[1] + 4) || *(_DWORD *)(v11 + 4184) < 2u || *(_DWORD *)(v11 + 4188) < 2u )
    goto LABEL_44;
  if ( v12 <= 28 )
  {
    if ( v12 != 28 )
    {
      switch ( v12 )
      {
        case 21:
          v13 = FUN_100132bb();
          goto LABEL_42;
        case 22:
          v13 = FUN_10013551();
          goto LABEL_42;
        case 23:
          v13 = FUN_10013582(a1);
          goto LABEL_42;
        case 24:
          v13 = FUN_100136d2(a1);
          goto LABEL_42;
        case 25:
          v13 = FUN_100137f6(a1);
          goto LABEL_42;
        case 26:
          v13 = FUN_10013945(a1);
          goto LABEL_42;
        case 27:
          v13 = FUN_10013a98(a1);
          goto LABEL_42;
        default:
          goto LABEL_44;
      }
    }
    goto LABEL_39;
  }
  v14 = v12 - 29;
  if ( !v14 )
  {
    v13 = FUN_10013c72(a1);
LABEL_42:
    if ( v13 >= 0 )
      return 0;
    goto LABEL_44;
  }
  v15 = v14 - 1;
  if ( !v15 )
  {
    v13 = FUN_10013dbe(a1);
    goto LABEL_42;
  }
  v16 = v15 - 10;
  if ( v16 )
  {
    v17 = v16 - 1;
    if ( v17 )
    {
      v18 = v17 - 9;
      if ( !v18 )
      {
LABEL_39:
        v13 = FUN_10013bd7(a1);
        goto LABEL_42;
      }
      v19 = v18 - 1;
      if ( !v19 )
      {
        v13 = FUN_10013edf(a1);
        goto LABEL_42;
      }
      if ( v19 == 1 )
      {
        v13 = FUN_1001402b(a1);
        goto LABEL_42;
      }
    }
  }
LABEL_44:
  v20 = *(_DWORD *)(a1[1] + 4184);
  v21 = (float *)operator new(16 * v20);
  v54 = v21;
  if ( v21 )
  {
    sub_1000B393((int)v21, 16, v20, (int (__thiscall *)(int))sub_1000AE4F);
    v61 = v54;
  }
  else
  {
    v61 = 0;
  }
  if ( !v61 )
    return -2147024882;
  v22 = *(_DWORD *)(*a1 + 4184);
  if ( *(_DWORD *)(*a1 + 4188) == 1 )
  {
    v23 = (char *)operator new(16 * v22);
    v55 = v23;
    if ( v23 )
    {
      sub_1000B393((int)v23, 16, v22, (int (__thiscall *)(int))sub_1000AE4F);
      v24 = v55;
    }
    else
    {
      v24 = 0;
    }
    v59 = v24;
    v63 = v24;
  }
  else
  {
    v25 = 2 * v22;
    v26 = (char *)operator new(16 * v25);
    v56 = v26;
    if ( v26 )
    {
      sub_1000B393((int)v26, 16, v25, (int (__thiscall *)(int))sub_1000AE4F);
      v27 = v56;
    }
    else
    {
      v27 = 0;
    }
    v59 = v27;
    v63 = v27;
    v24 = &v27[16 * *(_DWORD *)(*a1 + 4184)];
  }
  v64 = v24;
  if ( v59 )
  {
    if ( *(_DWORD *)(*a1 + 4184) == 1 )
    {
      v58 = v63;
      v29 = v24;
    }
    else
    {
      v58 = v63 + 16;
      v29 = v24 + 16;
    }
    v57 = v29;
    for ( i = 0; i < *(_DWORD *)(a1[1] + 4188); ++i )
    {
      (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, char *, int, float *))(*(_DWORD *)*a1 + 4))(
        *a1,
        2 * i,
        0,
        v63,
        a2,
        a3);
      if ( v64 != v63 )
        (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, char *))(*(_DWORD *)*a1 + 4))(*a1, 2 * i + 1, 0, v64);
      v30 = 0;
      if ( *(_DWORD *)(a1[1] + 4184) )
      {
        v60 = v61;
        do
        {
          v31 = (float *)&v58[32 * v30];
          v32 = (float *)&v63[32 * v30];
          v33 = *v31 + *v32;
          v34 = v60;
          v35 = v31[1];
          v60 += 4;
          v48 = v31[2] + v32[2];
          v36 = v31[3];
          v37 = (float *)&v64[32 * v30];
          v49 = v36 + v32[3];
          v46 = v33 + *v37;
          v38 = v35 + v32[1] + v37[1];
          v39 = v48 + v37[2];
          v40 = v49 + v37[3];
          v41 = (float *)&v57[32 * v30];
          v47 = v40;
          ++v30;
          v44 = v46 + *v41;
          v45 = v38 + v41[1];
          v50 = v44 * 0.25;
          v51 = v45 * 0.25;
          v52 = (v39 + v41[2]) * 0.25;
          v53 = (v47 + v41[3]) * 0.25;
          *v34++ = v50;
          *v34++ = v51;
          *v34 = v52;
          v34[1] = v53;
        }
        while ( v30 < *(_DWORD *)(a1[1] + 4184) );
      }
      a3 = v61;
      a2 = 0;
      (*(void (__thiscall **)(_DWORD, unsigned int))(*(_DWORD *)a1[1] + 8))(a1[1], i);
    }
    operator delete(v59);
    v28 = 0;
  }
  else
  {
    v28 = -2147024882;
  }
  operator delete(v61);
  return v28;
}

// FUN_10014bbc @ 0x10014BBC
// [binja] int32_t __fastcall sub_10014bbc(int32_t* arg1)
int __usercall sub_10014BBC@<eax>(_DWORD *a1@<ecx>, unsigned int a2@<edi>, float *a3@<esi>)
{
  _DWORD *v5; // ecx
  unsigned int v6; // eax
  _DWORD *v7; // edx
  int v8; // esi
  int v9; // esi
  _DWORD *v10; // ecx
  _DWORD *v11; // ecx
  int v12; // esi
  float *v13; // eax
  int v14; // esi
  int v15; // esi
  char *v16; // eax
  char *v17; // ecx
  int v18; // eax
  char *v19; // esi
  char *v20; // edx
  int v21; // esi
  char *v22; // eax
  char *v23; // edx
  int v24; // esi
  int v25; // eax
  int v26; // edi
  float *v27; // ecx
  float *v28; // edx
  double v29; // st6
  double v30; // st5
  double v31; // st4
  float *v32; // ecx
  double v33; // st6
  double v34; // st5
  double v35; // st4
  float *v36; // ecx
  double v37; // st6
  double v38; // st5
  float *v39; // ecx
  double v40; // st5
  float *v41; // ecx
  double v42; // st6
  double v43; // st5
  float *v44; // ecx
  float *v45; // edi
  float *v46; // eax
  float v49; // [esp+4h] [ebp-C4h]
  float v50; // [esp+10h] [ebp-B8h]
  float v51; // [esp+14h] [ebp-B4h]
  float v52; // [esp+20h] [ebp-A8h]
  float v53; // [esp+2Ch] [ebp-9Ch]
  float v54; // [esp+30h] [ebp-98h]
  float v55; // [esp+3Ch] [ebp-8Ch]
  float v56; // [esp+40h] [ebp-88h]
  float v57; // [esp+44h] [ebp-84h]
  float v58; // [esp+48h] [ebp-80h]
  float v59; // [esp+54h] [ebp-74h]
  float v60; // [esp+58h] [ebp-70h]
  float v61; // [esp+5Ch] [ebp-6Ch]
  float v62; // [esp+60h] [ebp-68h]
  float v63; // [esp+68h] [ebp-60h]
  float v64; // [esp+6Ch] [ebp-5Ch]
  float v65; // [esp+70h] [ebp-58h]
  float v66; // [esp+74h] [ebp-54h]
  float v67; // [esp+78h] [ebp-50h]
  float v68; // [esp+7Ch] [ebp-4Ch]
  char *v69; // [esp+84h] [ebp-44h]
  char *v70; // [esp+88h] [ebp-40h]
  char *v71; // [esp+8Ch] [ebp-3Ch]
  void *v72; // [esp+90h] [ebp-38h]
  float *v73; // [esp+94h] [ebp-34h]
  char *v74; // [esp+98h] [ebp-30h]
  unsigned int v75; // [esp+9Ch] [ebp-2Ch]
  char *v76; // [esp+A0h] [ebp-28h]
  unsigned int v77; // [esp+A4h] [ebp-24h]
  float *v78; // [esp+A8h] [ebp-20h]
  char *v79; // [esp+ACh] [ebp-1Ch]
  char *v80; // [esp+B0h] [ebp-18h]
  float *v81; // [esp+B4h] [ebp-14h]
  char *v82; // [esp+B4h] [ebp-14h]
  char *v83; // [esp+B4h] [ebp-14h]
  char *i; // [esp+B4h] [ebp-14h]
  unsigned int v85; // [esp+B8h] [ebp-10h]

  if ( *((_BYTE *)a1 + 8) != 5 )
    return -2147467259;
  v5 = (_DWORD *)*a1;
  v6 = *(_DWORD *)(*a1 + 4184);
  v7 = (_DWORD *)a1[1];
  v8 = v7[1046];
  if ( v8 != v6 >> 1 && (v8 != 1 || v6 != 1) )
    return -2147467259;
  v9 = v7[1047];
  if ( v9 != v5[1047] >> 1 && (v9 != 1 || v5[1047] != 1) )
    return -2147467259;
  if ( v7[1048] != v5[1048] >> 1 )
    return -2147467259;
  if ( v6 > 1 && (v6 & 1) != 0 )
  {
    v5[1046] = v6 & 0xFFFFFFFE;
    *(_DWORD *)(*a1 + 4196) -= *(_DWORD *)(*a1 + 4200);
  }
  v10 = (_DWORD *)(*a1 + 4188);
  if ( *v10 > 1u )
    *v10 &= ~1u;
  v11 = (_DWORD *)(*a1 + 4192);
  if ( *v11 > 1u )
    *v11 &= ~1u;
  v12 = *(_DWORD *)(a1[1] + 4184);
  v13 = (float *)operator new(16 * v12);
  v81 = v13;
  if ( v13 )
  {
    sub_1000B393((int)v13, 16, v12, (int (__thiscall *)(int))sub_1000AE4F);
    v78 = v81;
  }
  else
  {
    v78 = 0;
  }
  if ( !v78 )
    return -2147024882;
  v14 = *(_DWORD *)(*a1 + 4184);
  if ( *(_DWORD *)(*a1 + 4188) == 1 )
  {
    v15 = 2 * v14;
    v16 = (char *)operator new(16 * v15);
    v82 = v16;
    if ( v16 )
    {
      sub_1000B393((int)v16, 16, v15, (int (__thiscall *)(int))sub_1000AE4F);
      v17 = v82;
    }
    else
    {
      v17 = 0;
    }
    v18 = *(_DWORD *)(*a1 + 4184);
    v19 = &v17[16 * v18];
    v20 = v19;
    v72 = v17;
    v80 = v17;
    v74 = v19;
    v79 = v17;
    v76 = v19;
  }
  else
  {
    v21 = 4 * v14;
    v22 = (char *)operator new(16 * v21);
    v83 = v22;
    if ( v22 )
    {
      sub_1000B393((int)v22, 16, v21, (int (__thiscall *)(int))sub_1000AE4F);
      v23 = v83;
    }
    else
    {
      v23 = 0;
    }
    v18 = *(_DWORD *)(*a1 + 4184);
    v74 = &v23[16 * v18];
    v19 = v74;
    v79 = &v23[32 * v18];
    v76 = &v23[48 * v18];
    v17 = v79;
    v72 = v23;
    v80 = v23;
    v20 = v76;
  }
  if ( v72 )
  {
    if ( v18 == 1 )
    {
      v71 = v80;
      v70 = v19;
    }
    else
    {
      v71 = v80 + 16;
      v17 += 16;
      v70 = v19 + 16;
      v20 += 16;
    }
    v25 = a1[1];
    v77 = 0;
    v69 = v17;
    for ( i = v20; v77 < *(_DWORD *)(v25 + 4192); v25 = a1[1] )
    {
      v85 = 0;
      if ( *(_DWORD *)(v25 + 4188) )
      {
        do
        {
          v26 = 2 * v77;
          (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, char *, unsigned int, float *))(*(_DWORD *)*a1 + 4))(
            *a1,
            2 * v85,
            2 * v77,
            v80,
            a2,
            a3);
          if ( v19 != v80 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*a1 + 4))(*a1, 2 * v85, v26 + 1, v19);
          if ( v79 != v80 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*a1 + 4))(*a1, 2 * v85 + 1, v26, v79);
          if ( v76 != v19 && v76 != v79 )
            (*(void (__thiscall **)(_DWORD, unsigned int, int, char *))(*(_DWORD *)*a1 + 4))(
              *a1,
              2 * v85 + 1,
              v26 + 1,
              v76);
          v75 = 0;
          if ( *(_DWORD *)(a1[1] + 4184) )
          {
            v73 = v78;
            do
            {
              v27 = (float *)&v71[32 * v75];
              v28 = (float *)&v80[32 * v75];
              v29 = *v27 + *v28;
              v30 = v27[1] + v28[1];
              v55 = v27[2] + v28[2];
              v31 = v27[3];
              v32 = (float *)&v19[32 * v75];
              v56 = v31 + v28[3];
              v51 = v29 + *v32;
              v33 = v30 + v32[1];
              v34 = v55 + v32[2];
              v35 = v56 + v32[3];
              v36 = (float *)&v70[32 * v75];
              v52 = v35;
              v57 = v51 + *v36;
              v58 = v33 + v36[1];
              v37 = v34 + v36[2];
              v38 = v52 + v36[3];
              v39 = (float *)&v79[32 * v75];
              v66 = v57 + *v39;
              v67 = v58 + v39[1];
              v68 = v37 + v39[2];
              v40 = v38 + v39[3];
              v41 = (float *)&v69[32 * v75];
              v42 = v40;
              v43 = v66 + *v41;
              v63 = v67 + v41[1];
              v64 = v68 + v41[2];
              v65 = v42 + v41[3];
              v44 = (float *)&v76[32 * v75];
              v45 = v73;
              v73 += 4;
              v53 = v64 + v44[2];
              v46 = (float *)&i[32 * v75++];
              v54 = v65 + v44[3];
              v49 = v43 + *v44 + *v46;
              v50 = v54 + v46[3];
              v59 = v49 * 0.125;
              v60 = (v63 + v44[1] + v46[1]) * 0.125;
              v61 = (v53 + v46[2]) * 0.125;
              v62 = v50 * 0.125;
              *v45++ = v59;
              *v45++ = v60;
              *v45 = v61;
              v45[1] = v62;
              v19 = v74;
            }
            while ( v75 < *(_DWORD *)(a1[1] + 4184) );
          }
          a3 = v78;
          a2 = v77;
          (*(void (__thiscall **)(_DWORD, unsigned int))(*(_DWORD *)a1[1] + 8))(a1[1], v85++);
        }
        while ( v85 < *(_DWORD *)(a1[1] + 4188) );
      }
      ++v77;
    }
    operator delete(v72);
    v24 = 0;
  }
  else
  {
    v24 = -2147024882;
  }
  operator delete(v78);
  return v24;
}

// sub_1001504E @ 0x1001504E
int *__usercall sub_1001504E@<eax>(unsigned int a1@<ebx>, unsigned int a2@<edi>, int a3)
{
  int *result; // eax
  int *v4; // esi
  int v5; // eax
  double X; // st7
  int v7; // eax
  unsigned int v8; // ecx
  double v9; // st7
  int *v10; // [esp+Ch] [ebp-18h]
  float v11; // [esp+14h] [ebp-10h]
  float v12; // [esp+18h] [ebp-Ch]
  float v13; // [esp+1Ch] [ebp-8h]
  int v14; // [esp+20h] [ebp-4h]
  unsigned int v15; // [esp+20h] [ebp-4h]

  result = (int *)operator new(16 * a1);
  v4 = result;
  if ( result )
  {
    v10 = result;
    v5 = v14;
    v15 = 0;
    for ( dword_1005DB68 = v5; v15 < a1; *((float *)v4 - 1) = 1.0 - v9 )
    {
      v11 = (double)a2 / (double)a1;
      X = (double)v15 * v11 - 0.5;
      v13 = X;
      v12 = floor(X);
      v7 = (int)v12;
      v8 = v7 + 1;
      if ( v7 < 0 )
        v7 = a3 != 0 ? a2 - 1 : 0;
      if ( v8 >= a2 )
        v8 = a3 == 0 ? a2 - 1 : 0;
      *v4 = v7;
      v4[2] = v8;
      v4 += 4;
      ++v15;
      v9 = 1.0 - (v13 - v12);
      *((float *)v4 - 3) = v9;
    }
    return v10;
  }
  return result;
}

// FUN_1001514e @ 0x1001514E
// [binja] int32_t __fastcall sub_1001514e(int32_t* arg1)
int __thiscall sub_1001514E(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax
  int *v4; // eax
  int v5; // ebx
  void *v6; // eax
  void *v7; // eax
  int v8; // ebx
  char *v9; // eax
  char *v10; // eax
  char *v11; // ebx
  int *v12; // edi
  int v13; // eax
  int v14; // ecx
  char *v15; // eax
  int *v16; // eax
  double v17; // st7
  int v18; // ecx
  double v19; // st7
  double v20; // st6
  int v21; // edx
  float *v22; // ecx
  double v23; // st6
  double v24; // st7
  double v25; // st6
  double v26; // st5
  double v27; // st5
  float *v28; // edi
  int v29; // esi
  float v30; // [esp+4h] [ebp-D0h]
  float v31; // [esp+8h] [ebp-CCh]
  float v32; // [esp+Ch] [ebp-C8h]
  float v33; // [esp+10h] [ebp-C4h]
  float v34; // [esp+14h] [ebp-C0h]
  float v35; // [esp+18h] [ebp-BCh]
  float v36; // [esp+1Ch] [ebp-B8h]
  float v37; // [esp+24h] [ebp-B0h]
  float v38; // [esp+28h] [ebp-ACh]
  float v39; // [esp+2Ch] [ebp-A8h]
  float v40; // [esp+38h] [ebp-9Ch]
  float v41; // [esp+3Ch] [ebp-98h]
  float v42; // [esp+40h] [ebp-94h]
  float v43; // [esp+44h] [ebp-90h]
  float v44; // [esp+48h] [ebp-8Ch]
  float v45; // [esp+4Ch] [ebp-88h]
  float v46; // [esp+54h] [ebp-80h]
  float v47; // [esp+58h] [ebp-7Ch]
  float v48; // [esp+5Ch] [ebp-78h]
  float v49; // [esp+64h] [ebp-70h]
  float v50; // [esp+68h] [ebp-6Ch]
  float v51; // [esp+6Ch] [ebp-68h]
  float v52; // [esp+78h] [ebp-5Ch]
  float v53; // [esp+7Ch] [ebp-58h]
  float v54; // [esp+80h] [ebp-54h]
  float v55; // [esp+84h] [ebp-50h]
  float v56; // [esp+88h] [ebp-4Ch]
  float v57; // [esp+8Ch] [ebp-48h]
  float *v59; // [esp+98h] [ebp-3Ch]
  char *v60; // [esp+9Ch] [ebp-38h]
  unsigned int v61; // [esp+A0h] [ebp-34h]
  int *v62; // [esp+A4h] [ebp-30h]
  char *v63; // [esp+A8h] [ebp-2Ch]
  unsigned int v64; // [esp+ACh] [ebp-28h]
  int v65; // [esp+B0h] [ebp-24h]
  float *v66; // [esp+B4h] [ebp-20h]
  void *v67; // [esp+B8h] [ebp-1Ch]
  char *v68; // [esp+B8h] [ebp-1Ch]
  int v69; // [esp+BCh] [ebp-18h]
  void *v70; // [esp+C0h] [ebp-14h]
  void *v71; // [esp+C0h] [ebp-14h]
  BOOL v72; // [esp+C4h] [ebp-10h]
  int *v73; // [esp+C4h] [ebp-10h]

  v70 = 0;
  v67 = 0;
  v1 = this;
  v2 = *(this + 2);
  if ( (_BYTE)v2 != 3 )
    return -2147467259;
  v72 = (v2 & 0x20000) == 0;
  v62 = sub_1001504E(*(_DWORD *)(*(this + 1) + 4184), *(_DWORD *)(*this + 4184), (v2 & 0x10000) == 0);
  v4 = sub_1001504E(*(_DWORD *)(v1[1] + 4188), *(_DWORD *)(*v1 + 4188), v72);
  v73 = v4;
  if ( !v62 || !v4 )
    goto LABEL_27;
  v5 = *(_DWORD *)(v1[1] + 4184);
  v6 = operator new(16 * v5);
  v71 = v6;
  if ( v6 )
  {
    sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    v7 = v71;
    v66 = (float *)v71;
  }
  else
  {
    v66 = 0;
    v7 = 0;
  }
  v70 = v7;
  if ( v7
    && ((v8 = 2 * *(_DWORD *)(*v1 + 4184), v9 = (char *)operator new(32 * *(_DWORD *)(*v1 + 4184)), (v68 = v9) == 0)
      ? (v10 = 0)
      : (sub_1000B393((int)v9, 16, v8, (int (__thiscall *)(int))sub_1000AE4F), v10 = v68),
        (v67 = v10) != 0) )
  {
    v64 = 0;
    v65 = -1;
    v69 = -1;
    v11 = &v10[16 * *(_DWORD *)(*v1 + 4184)];
    v63 = v10;
    if ( *(_DWORD *)(v1[1] + 4188) )
    {
      v12 = v73 + 2;
      v60 = (char *)(v73 + 2);
      do
      {
        v13 = *(v12 - 2);
        v61 = 0;
        if ( v13 != v65 )
        {
          v14 = v69;
          if ( v13 == v69 )
          {
            v15 = v63;
            v69 = -1;
            v63 = v11;
            v65 = v14;
            v11 = v15;
          }
          else
          {
            v65 = *(v12 - 2);
            (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(*v1, v13, 0, v63);
          }
        }
        if ( *v12 != v69 )
        {
          v69 = *v12;
          (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(*v1, *v12, 0, v11);
        }
        if ( *(_DWORD *)(v1[1] + 4184) )
        {
          v16 = v62 + 2;
          v59 = v66;
          do
          {
            v17 = *((float *)v16 + 1);
            v18 = 16 * *v16;
            v55 = v17 * *(float *)&v11[v18];
            v56 = v17 * *(float *)&v11[v18 + 4];
            v57 = v17 * *(float *)&v11[v18 + 8];
            v19 = v17 * *(float *)&v11[v18 + 12];
            v20 = *((float *)v16 - 1);
            v21 = 16 * *(v16 - 2);
            v40 = v20 * *(float *)&v11[v21 + 4];
            v41 = v20 * *(float *)&v11[v21 + 8];
            v22 = (float *)&v63[v18];
            v42 = v20 * *(float *)&v11[v21 + 12];
            v46 = v20 * *(float *)&v11[v21] + v55;
            v47 = v40 + v56;
            v48 = v41 + v57;
            v23 = *((float *)v12 + 1);
            v37 = v46 * v23;
            v38 = v47 * v23;
            v39 = v48 * v23;
            v24 = (v42 + v19) * v23;
            v25 = *((float *)v16 + 1);
            v34 = v25 * *v22;
            v35 = v25 * v22[1];
            v36 = v25 * v22[2];
            v26 = *((float *)v16 - 1);
            v16 += 4;
            ++v61;
            v52 = v26 * *(float *)&v63[v21 + 4];
            v53 = v26 * *(float *)&v63[v21 + 8];
            v54 = v26 * *(float *)&v63[v21 + 12];
            v49 = v26 * *(float *)&v63[v21] + v34;
            v50 = v52 + v35;
            v51 = v53 + v36;
            v27 = *((float *)v12 - 1);
            v28 = v59;
            v59 += 4;
            v43 = v49 * v27;
            v44 = v50 * v27;
            v45 = v51 * v27;
            v30 = v43 + v37;
            v31 = v44 + v38;
            v32 = v45 + v39;
            v33 = (v54 + v25 * v22[3]) * v27 + v24;
            *v28++ = v30;
            *v28++ = v31;
            *v28 = v32;
            v28[1] = v33;
            v12 = (int *)v60;
          }
          while ( v61 < *(_DWORD *)(*(this + 1) + 4184) );
          v1 = this;
        }
        (*(void (__thiscall **)(_DWORD, unsigned int, _DWORD, float *))(*(_DWORD *)v1[1] + 8))(v1[1], v64, 0, v66);
        v12 += 4;
        ++v64;
        v60 = (char *)v12;
      }
      while ( v64 < *(_DWORD *)(v1[1] + 4188) );
    }
    v29 = 0;
  }
  else
  {
LABEL_27:
    v29 = -2147024882;
  }
  operator delete(v62);
  operator delete(v73);
  operator delete(v70);
  operator delete(v67);
  return v29;
}

// FUN_10015534 @ 0x10015534
// [binja] int32_t __fastcall sub_10015534(int32_t* arg1)
int __thiscall sub_10015534(_DWORD *this)
{
  _DWORD *v1; // esi
  int v2; // eax
  int *v4; // eax
  int v5; // edi
  void *v6; // eax
  void *v7; // eax
  int v8; // edi
  char *v9; // eax
  char *v10; // eax
  int v11; // edi
  char *v12; // ecx
  char *v13; // edi
  int v14; // eax
  int *v15; // ebx
  int v16; // eax
  int v17; // ecx
  char *v18; // ecx
  char *v19; // eax
  int *v20; // eax
  double v21; // st7
  int v22; // ecx
  double v23; // st6
  int v24; // edx
  double v25; // st6
  double v26; // st7
  double v27; // st6
  double v28; // st5
  double v29; // st5
  double v30; // st7
  double v31; // st6
  double v32; // st7
  double v33; // st6
  double v34; // st6
  double v35; // st5
  float *v36; // ecx
  double v37; // st5
  double v38; // st6
  double v39; // st5
  double v40; // st4
  double v41; // st4
  double v42; // st3
  double v43; // st5
  float *v44; // edi
  int v45; // esi
  float v46; // [esp+4h] [ebp-1A4h]
  float v47; // [esp+8h] [ebp-1A0h]
  float v48; // [esp+Ch] [ebp-19Ch]
  float v49; // [esp+10h] [ebp-198h]
  float v50; // [esp+14h] [ebp-194h]
  float v51; // [esp+18h] [ebp-190h]
  float v52; // [esp+1Ch] [ebp-18Ch]
  float v53; // [esp+24h] [ebp-184h]
  float v54; // [esp+28h] [ebp-180h]
  float v55; // [esp+2Ch] [ebp-17Ch]
  float v56; // [esp+34h] [ebp-174h]
  float v57; // [esp+38h] [ebp-170h]
  float v58; // [esp+3Ch] [ebp-16Ch]
  float v59; // [esp+44h] [ebp-164h]
  float v60; // [esp+48h] [ebp-160h]
  float v61; // [esp+4Ch] [ebp-15Ch]
  float v62; // [esp+54h] [ebp-154h]
  float v63; // [esp+58h] [ebp-150h]
  float v64; // [esp+5Ch] [ebp-14Ch]
  float v65; // [esp+64h] [ebp-144h]
  float v66; // [esp+68h] [ebp-140h]
  float v67; // [esp+6Ch] [ebp-13Ch]
  float v68; // [esp+74h] [ebp-134h]
  float v69; // [esp+78h] [ebp-130h]
  float v70; // [esp+7Ch] [ebp-12Ch]
  float v71; // [esp+84h] [ebp-124h]
  float v72; // [esp+88h] [ebp-120h]
  float v73; // [esp+8Ch] [ebp-11Ch]
  float v74; // [esp+94h] [ebp-114h]
  float v75; // [esp+98h] [ebp-110h]
  float v76; // [esp+9Ch] [ebp-10Ch]
  float v77; // [esp+A4h] [ebp-104h]
  float v78; // [esp+A8h] [ebp-100h]
  float v79; // [esp+ACh] [ebp-FCh]
  float v80; // [esp+B4h] [ebp-F4h]
  float v81; // [esp+B8h] [ebp-F0h]
  float v82; // [esp+BCh] [ebp-ECh]
  float v83; // [esp+C4h] [ebp-E4h]
  float v84; // [esp+C8h] [ebp-E0h]
  float v85; // [esp+CCh] [ebp-DCh]
  float v86; // [esp+D4h] [ebp-D4h]
  float v87; // [esp+D8h] [ebp-D0h]
  float v88; // [esp+DCh] [ebp-CCh]
  float v89; // [esp+E8h] [ebp-C0h]
  float v90; // [esp+ECh] [ebp-BCh]
  float v91; // [esp+F0h] [ebp-B8h]
  float v92; // [esp+F8h] [ebp-B0h]
  float v93; // [esp+FCh] [ebp-ACh]
  float v94; // [esp+100h] [ebp-A8h]
  float v95; // [esp+104h] [ebp-A4h]
  float v96; // [esp+108h] [ebp-A0h]
  float v97; // [esp+10Ch] [ebp-9Ch]
  float v98; // [esp+114h] [ebp-94h]
  float v99; // [esp+118h] [ebp-90h]
  float v100; // [esp+11Ch] [ebp-8Ch]
  float v101; // [esp+124h] [ebp-84h]
  float v102; // [esp+128h] [ebp-80h]
  float v103; // [esp+12Ch] [ebp-7Ch]
  float v104; // [esp+138h] [ebp-70h]
  float v105; // [esp+13Ch] [ebp-6Ch]
  float v106; // [esp+140h] [ebp-68h]
  float v107; // [esp+148h] [ebp-60h]
  float v108; // [esp+14Ch] [ebp-5Ch]
  float v109; // [esp+150h] [ebp-58h]
  float *v111; // [esp+158h] [ebp-50h]
  int *v112; // [esp+15Ch] [ebp-4Ch]
  int *v113; // [esp+160h] [ebp-48h]
  void *v114; // [esp+164h] [ebp-44h]
  void *v115; // [esp+164h] [ebp-44h]
  char *v116; // [esp+168h] [ebp-40h]
  BOOL v117; // [esp+16Ch] [ebp-3Ch]
  int *v118; // [esp+16Ch] [ebp-3Ch]
  unsigned int v119; // [esp+170h] [ebp-38h]
  float *v120; // [esp+174h] [ebp-34h]
  void *v121; // [esp+178h] [ebp-30h]
  char *v122; // [esp+178h] [ebp-30h]
  char *v123; // [esp+17Ch] [ebp-2Ch]
  char *v124; // [esp+180h] [ebp-28h]
  unsigned int v125; // [esp+184h] [ebp-24h]
  BOOL v126; // [esp+188h] [ebp-20h]
  unsigned int v127; // [esp+188h] [ebp-20h]
  char *v128; // [esp+18Ch] [ebp-1Ch]
  int v129; // [esp+190h] [ebp-18h]
  int v130; // [esp+194h] [ebp-14h]
  float *v131; // [esp+198h] [ebp-10h]

  v114 = 0;
  v121 = 0;
  v1 = this;
  v2 = *(this + 2);
  if ( (_BYTE)v2 != 3 )
    return -2147467259;
  v126 = (v2 & 0x40000) == 0;
  v117 = (v2 & 0x20000) == 0;
  v113 = sub_1001504E(*(_DWORD *)(*(this + 1) + 4184), *(_DWORD *)(*this + 4184), (v2 & 0x10000) == 0);
  v112 = sub_1001504E(*(_DWORD *)(v1[1] + 4188), *(_DWORD *)(*v1 + 4188), v117);
  v4 = sub_1001504E(*(_DWORD *)(v1[1] + 4192), *(_DWORD *)(*v1 + 4192), v126);
  v118 = v4;
  if ( !v113 || !v112 || !v4 )
    goto LABEL_31;
  v5 = *(_DWORD *)(v1[1] + 4184);
  v6 = operator new(16 * v5);
  v115 = v6;
  if ( v6 )
  {
    sub_1000B393((int)v6, 16, v5, (int (__thiscall *)(int))sub_1000AE4F);
    v7 = v115;
    v120 = (float *)v115;
  }
  else
  {
    v120 = 0;
    v7 = 0;
  }
  v114 = v7;
  if ( v7
    && ((v8 = 4 * *(_DWORD *)(*v1 + 4184), v9 = (char *)operator new(*(_DWORD *)(*v1 + 4184) << 6), (v122 = v9) == 0)
      ? (v10 = 0)
      : (sub_1000B393((int)v9, 16, v8, (int (__thiscall *)(int))sub_1000AE4F), v10 = v122),
        (v121 = v10) != 0) )
  {
    v11 = *(_DWORD *)(*v1 + 4184);
    v119 = 0;
    v128 = &v10[16 * v11];
    v12 = &v10[32 * v11];
    v13 = &v10[48 * v11];
    v124 = v10;
    v14 = v1[1];
    v116 = v12;
    v123 = v13;
    if ( *(_DWORD *)(v14 + 4192) )
    {
      v131 = (float *)(v118 + 2);
      do
      {
        v125 = 0;
        v129 = -1;
        v130 = -1;
        if ( *(_DWORD *)(v14 + 4188) )
        {
          v15 = v112 + 2;
          do
          {
            v16 = *(v15 - 2);
            v127 = 0;
            if ( v16 != v129 )
            {
              v17 = v130;
              if ( v16 == v130 )
              {
                v130 = -1;
                v129 = v17;
                v18 = v128;
                v128 = v124;
                v19 = v116;
                v116 = v13;
                v124 = v18;
                v123 = v19;
                v13 = v19;
              }
              else
              {
                v129 = *(v15 - 2);
                (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(
                  *v1,
                  v16,
                  *((_DWORD *)v131 - 2),
                  v124);
                (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(
                  *v1,
                  v129,
                  *(_DWORD *)v131,
                  v116);
              }
            }
            if ( *v15 != v130 )
            {
              v130 = *v15;
              (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(
                *v1,
                *v15,
                *((_DWORD *)v131 - 2),
                v128);
              (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*v1 + 4))(
                *v1,
                v130,
                *(_DWORD *)v131,
                v13);
            }
            if ( *(_DWORD *)(v1[1] + 4184) )
            {
              v20 = v113 + 2;
              v111 = v120;
              do
              {
                v21 = *((float *)v20 + 1);
                v22 = 16 * *v20;
                v74 = v21 * *(float *)&v13[v22];
                v75 = v21 * *(float *)&v13[v22 + 4];
                v76 = v21 * *(float *)&v13[v22 + 8];
                v23 = *((float *)v20 - 1);
                v24 = 16 * *(v20 - 2);
                v107 = v23 * *(float *)&v13[v24 + 4];
                v108 = v23 * *(float *)&v13[v24 + 8];
                v109 = v23 * *(float *)&v13[v24 + 12];
                v98 = v23 * *(float *)&v13[v24] + v74;
                v99 = v107 + v75;
                v100 = v108 + v76;
                v25 = *((float *)v15 + 1);
                v56 = v98 * v25;
                v57 = v99 * v25;
                v58 = v100 * v25;
                v26 = (v109 + v21 * *(float *)&v13[v22 + 12]) * v25;
                v27 = *((float *)v20 + 1);
                v50 = v27 * *(float *)&v116[v22];
                v51 = v27 * *(float *)&v116[v22 + 4];
                v52 = v27 * *(float *)&v116[v22 + 8];
                v28 = *((float *)v20 - 1);
                v92 = v28 * *(float *)&v116[v24 + 4];
                v93 = v28 * *(float *)&v116[v24 + 8];
                v94 = v28 * *(float *)&v116[v24 + 12];
                v68 = v28 * *(float *)&v116[v24] + v50;
                v69 = v92 + v51;
                v70 = v93 + v52;
                v29 = *((float *)v15 - 1);
                v86 = v68 * v29;
                v87 = v69 * v29;
                v88 = v70 * v29;
                v80 = v86 + v56;
                v81 = v87 + v57;
                v82 = v88 + v58;
                v30 = (v94 + v27 * *(float *)&v116[v22 + 12]) * v29 + v26;
                v31 = v131[1];
                v53 = v80 * v31;
                v54 = v81 * v31;
                v55 = v82 * v31;
                v32 = v30 * v31;
                v33 = *((float *)v20 + 1);
                v62 = v33 * *(float *)&v128[v22];
                v63 = v33 * *(float *)&v128[v22 + 4];
                v64 = v33 * *(float *)&v128[v22 + 8];
                v34 = v33 * *(float *)&v128[v22 + 12];
                v35 = *((float *)v20 - 1);
                v104 = v35 * *(float *)&v128[v24 + 4];
                v105 = v35 * *(float *)&v128[v24 + 8];
                v36 = (float *)&v124[v22];
                v106 = v35 * *(float *)&v128[v24 + 12];
                v101 = v35 * *(float *)&v128[v24] + v62;
                v102 = v104 + v63;
                v103 = v105 + v64;
                v37 = *((float *)v15 + 1);
                v71 = v101 * v37;
                v72 = v102 * v37;
                v73 = v103 * v37;
                v38 = (v106 + v34) * v37;
                v39 = *((float *)v20 + 1);
                v95 = v39 * *v36;
                v96 = v39 * v36[1];
                v97 = v39 * v36[2];
                v40 = *((float *)v20 - 1);
                v89 = v40 * *(float *)&v124[v24 + 4];
                v90 = v40 * *(float *)&v124[v24 + 8];
                v91 = v40 * *(float *)&v124[v24 + 12];
                v83 = v40 * *(float *)&v124[v24] + v95;
                v84 = v89 + v96;
                v85 = v90 + v97;
                v41 = *((float *)v15 - 1);
                v77 = v83 * v41;
                v78 = v84 * v41;
                v79 = v85 * v41;
                v42 = (v91 + v39 * v36[3]) * v41;
                v65 = v77 + v71;
                v66 = v78 + v72;
                v67 = v79 + v73;
                v43 = *(v131 - 1);
                v59 = v65 * v43;
                v60 = v66 * v43;
                v61 = v67 * v43;
                v44 = v111;
                v111 += 4;
                v46 = v59 + v53;
                v20 += 4;
                ++v127;
                v47 = v60 + v54;
                v48 = v61 + v55;
                v49 = (v42 + v38) * v43 + v32;
                *v44++ = v46;
                *v44++ = v47;
                *v44 = v48;
                v44[1] = v49;
                v13 = v123;
              }
              while ( v127 < *(_DWORD *)(*(this + 1) + 4184) );
              v1 = this;
            }
            (*(void (__thiscall **)(_DWORD, unsigned int, unsigned int, float *))(*(_DWORD *)v1[1] + 8))(
              v1[1],
              v125,
              v119,
              v120);
            v15 += 4;
            ++v125;
          }
          while ( v125 < *(_DWORD *)(v1[1] + 4188) );
        }
        v131 += 4;
        ++v119;
        v14 = v1[1];
      }
      while ( v119 < *(_DWORD *)(v14 + 4192) );
    }
    v45 = 0;
  }
  else
  {
LABEL_31:
    v45 = -2147024882;
  }
  operator delete(v113);
  operator delete(v112);
  operator delete(v118);
  operator delete(v114);
  operator delete(v121);
  return v45;
}

// FUN_10015c65 @ 0x10015C65
// [binja] int32_t __fastcall sub_10015c65(int32_t* arg1)
int __thiscall sub_10015C65(_DWORD *this)
{
  int v2; // edx
  BOOL v3; // edi
  float *v4; // esi
  unsigned int v5; // edi
  int v6; // esi
  int *v7; // eax
  void **v8; // eax
  int v9; // esi
  char *v10; // eax
  void *v11; // eax
  _DWORD *v12; // ecx
  _DWORD *v13; // edx
  _DWORD *i; // ecx
  float *v15; // eax
  float *v16; // esi
  float *v17; // eax
  void **v18; // edi
  int v19; // esi
  void *v20; // eax
  void *v21; // eax
  float *v22; // eax
  float *v23; // edx
  float *v24; // ecx
  float *v25; // edi
  float *v26; // ecx
  float *v27; // eax
  double v28; // st7
  float *v29; // esi
  float *v30; // edi
  void **v31; // esi
  bool v32; // zf
  int v33; // esi
  unsigned int v35; // [esp+Ch] [ebp-44h]
  void *v36; // [esp+10h] [ebp-40h]
  float *v37; // [esp+10h] [ebp-40h]
  void *v38; // [esp+14h] [ebp-3Ch]
  char *v39; // [esp+14h] [ebp-3Ch]
  float *v40; // [esp+18h] [ebp-38h]
  void **v41; // [esp+1Ch] [ebp-34h]
  void **v42; // [esp+1Ch] [ebp-34h]
  float *v43; // [esp+20h] [ebp-30h]
  unsigned int v44; // [esp+24h] [ebp-2Ch]
  int v45; // [esp+28h] [ebp-28h]
  char *v46; // [esp+2Ch] [ebp-24h]
  _DWORD *v47; // [esp+30h] [ebp-20h]
  unsigned int v48; // [esp+34h] [ebp-1Ch]
  void **v49; // [esp+38h] [ebp-18h]
  void **v50; // [esp+3Ch] [ebp-14h]
  float *v51; // [esp+40h] [ebp-10h]
  float *v52; // [esp+40h] [ebp-10h]

  v2 = *(this + 1);
  v47 = 0;
  v41 = 0;
  v49 = 0;
  v38 = 0;
  if ( *(_DWORD *)(v2 + 4192) != 1 || *(_DWORD *)(*this + 4192) != 1 )
    return -2147467259;
  v3 = ((*(this + 2) >> 17) & 1) == 0;
  v4 = (float *)sub_1001288A(*(_DWORD *)(*this + 4184), *(_DWORD *)(v2 + 4184), (*(this + 2) & 0x10000) == 0);
  v40 = v4;
  if ( v4 && (v47 = sub_1001288A(*(_DWORD *)(*this + 4188), *(_DWORD *)(*(this + 1) + 4188), v3)) != 0 )
  {
    v44 = (unsigned int)v4 + *(_DWORD *)v4;
    v5 = (unsigned int)v47 + *v47;
    v6 = *(_DWORD *)(*(this + 1) + 4188);
    v35 = v5;
    v7 = (int *)operator new(12 * v6 + 4);
    if ( v7 )
    {
      *v7 = v6;
      v42 = (void **)(v7 + 1);
      FUN_1004b6c3(
        v7 + 1,
        0xCu,
        v6,
        unknown_libname_2,
        (void (__thiscall *)(void *))Concurrency::SchedulerPolicy::~SchedulerPolicy);
      v8 = v42;
      v50 = v42;
    }
    else
    {
      v50 = 0;
      v8 = 0;
    }
    v41 = v8;
    if ( !v8 )
      goto LABEL_47;
    v9 = *(_DWORD *)(*this + 4184);
    v10 = (char *)operator new(16 * v9);
    v39 = v10;
    if ( v10 )
    {
      sub_1000B393((int)v10, 16, v9, (int (__thiscall *)(int))sub_1000AE4F);
      v11 = v39;
      v46 = v39;
    }
    else
    {
      v46 = 0;
      v11 = 0;
    }
    v38 = v11;
    if ( v11 )
    {
      v12 = v47 + 1;
      if ( (unsigned int)(v47 + 1) < v5 )
      {
        do
        {
          v13 = (_DWORD *)((char *)v12 + *v12);
          for ( i = v12 + 1; i < v13; i += 2 )
            v50[3 * *i + 2] = (char *)v50[3 * *i + 2] + 1;
          v12 = v13;
        }
        while ( (unsigned int)v13 < v5 );
      }
      v15 = (float *)(v47 + 1);
      v45 = 0;
      if ( (unsigned int)(v47 + 1) < v5 )
      {
        do
        {
          v16 = (float *)((char *)v15 + *(_DWORD *)v15);
          v17 = v15 + 1;
          v48 = (unsigned int)v16;
          v43 = v17;
          while ( 1 )
          {
            v51 = v17;
            if ( v17 >= v16 )
              break;
            v18 = &v50[3 * *(_DWORD *)v17];
            if ( !*v18 )
            {
              if ( v49 )
              {
                *v18 = *v49;
                *v49 = 0;
                v49 = (void **)v49[1];
              }
              else
              {
                v19 = *(_DWORD *)(*(this + 1) + 4184);
                v20 = operator new(16 * v19);
                v36 = v20;
                if ( v20 )
                {
                  sub_1000B393((int)v20, 16, v19, (int (__thiscall *)(int))sub_1000AE4F);
                  v21 = v36;
                }
                else
                {
                  v21 = 0;
                }
                *v18 = v21;
                if ( !v21 )
                  goto LABEL_47;
              }
              v16 = (float *)v48;
              memset(*v18, 0, 16 * *(_DWORD *)(*(this + 1) + 4184));
            }
            v17 = v51 + 2;
          }
          (*(void (__thiscall **)(_DWORD, int, _DWORD, char *))(*(_DWORD *)*this + 4))(*this, v45, 0, v46);
          v22 = v40 + 1;
          if ( (unsigned int)(v40 + 1) < v44 )
          {
            v23 = (float *)(v46 + 8);
            do
            {
              v24 = v43;
              v25 = (float *)((char *)v22 + *(_DWORD *)v22);
              v52 = v43;
              if ( v43 < v16 )
              {
                v37 = v22 + 1;
                while ( 1 )
                {
                  v26 = (float *)v50[3 * *(_DWORD *)v24];
                  v27 = v37;
                  if ( v37 < v25 )
                  {
                    do
                    {
                      v28 = v27[1] * v52[1];
                      v26[4 * *(_DWORD *)v27] = v28 * *(v23 - 2) + v26[4 * *(_DWORD *)v27];
                      v26[4 * *(_DWORD *)v27 + 1] = v28 * *(v23 - 1) + v26[4 * *(_DWORD *)v27 + 1];
                      v26[4 * *(_DWORD *)v27 + 2] = v28 * *v23 + v26[4 * *(_DWORD *)v27 + 2];
                      v29 = &v26[4 * *(_DWORD *)v27 + 3];
                      v27 += 2;
                      *v29 = v28 * v23[1] + *v29;
                    }
                    while ( v27 < v25 );
                    v16 = (float *)v48;
                  }
                  v52 += 2;
                  if ( v52 >= v16 )
                    break;
                  v24 = v52;
                }
              }
              v23 += 4;
              v22 = v25;
            }
            while ( (unsigned int)v25 < v44 );
          }
          v30 = v43;
          if ( v43 < v16 )
          {
            do
            {
              v31 = &v50[3 * *(_DWORD *)v30];
              v32 = v31[2] == (void *)1;
              v31[2] = (char *)v31[2] - 1;
              if ( v32 )
              {
                (*(void (__thiscall **)(_DWORD, _DWORD, _DWORD, void *))(*(_DWORD *)*(this + 1) + 8))(
                  *(this + 1),
                  *(_DWORD *)v30,
                  0,
                  *v31);
                v31[1] = v49;
                v49 = v31;
              }
              v30 += 2;
            }
            while ( (unsigned int)v30 < v48 );
            v16 = (float *)v48;
          }
          ++v45;
          v15 = v16;
        }
        while ( (unsigned int)v16 < v35 );
      }
      v33 = 0;
    }
    else
    {
LABEL_47:
      v33 = -2147024882;
    }
  }
  else
  {
    v33 = -2147467259;
  }
  if ( v41 )
    FUN_10012b47(v41, 3);
  operator delete(v47);
  operator delete(v40);
  operator delete(v38);
  operator delete(0);
  return v33;
}

// FUN_10016007 @ 0x10016007
// [binja] int32_t __thiscall sub_10016007(int32_t* arg1, void*** arg2, void*** arg3, int32_t arg4)
int __userpurge sub_10016007@<eax>(int *a1@<ecx>, unsigned int a2@<edi>, _DWORD *a3, void *a4, int a5)
{
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  void (__thiscall ***v9)(_DWORD, int); // ecx

  a1[1] = 0;
  *a1 = 0;
  a1[2] = a5;
  if ( !(_WORD)a5 || (unsigned __int16)a5 > 5u || (a5 & 0xFFF00000) != 0 )
    return -2005530516;
  a3[16] = a5 & 0x80000;
  v6 = grim_pixel_format_create(a3);
  a1[1] = v6;
  if ( !v6 )
    goto LABEL_18;
  v7 = grim_pixel_format_create(a4);
  *a1 = v7;
  if ( !v7 )
    goto LABEL_18;
  v8 = FUN_10017361(v7);
  if ( v8 >= 0 )
  {
    if ( FUN_1001416a(a1) >= 0
      || FUN_100142a2(a1) >= 0
      || FUN_10014393(a1) >= 0
      || FUN_10014595(a1) >= 0
      || FUN_10014799(a1, a2, (float *)a1) >= 0
      || FUN_10014bbc(a1, a2, (float *)a1) >= 0
      || FUN_1001514e(a1) >= 0
      || FUN_10015534(a1) >= 0
      || FUN_10015c65(a1) >= 0
      || FUN_10012b93((unsigned int *)a1) >= 0 )
    {
      v8 = 0;
      goto LABEL_19;
    }
LABEL_18:
    v8 = -2147467259;
  }
LABEL_19:
  v9 = (void (__thiscall ***)(_DWORD, int))a1[1];
  if ( v9 )
  {
    (**v9)(v9, 1);
    a1[1] = 0;
  }
  if ( *a1 )
  {
    (**(void (__thiscall ***)(int, int))*a1)(*a1, 1);
    *a1 = 0;
  }
  return v8;
}

// FUN_10016121 @ 0x10016121
// [binja] int32_t* __fastcall sub_10016121(int32_t* arg1)
void __thiscall sub_10016121(_DWORD *this)
{
  *this = 0;
  *(this + 1) = 0;
  *(this + 2) = 0;
  *(this + 3) = 0;
}

// FUN_10016131 @ 0x10016131
// [binja] int32_t __fastcall sub_10016131(char* arg1)
int __thiscall sub_10016131(_DWORD *this)
{
  int v2; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // eax

  v2 = *(this + 2);
  if ( v2 || (v2 = *(this + 1)) != 0 )
    (*(void (__stdcall **)(int))(*(_DWORD *)v2 + 40))(v2);
  v3 = *(this + 1);
  if ( v3 )
  {
    v4 = *(this + 2);
    if ( v4 )
    {
      v5 = *(this + 3);
      if ( v5 )
      {
        if ( (*(_BYTE *)this & 1) == 0 )
          (*(void (__stdcall **)(int, int, _DWORD, _DWORD, int, _DWORD))(*(_DWORD *)v5 + 112))(v5, v4, 0, 0, v3, 0);
      }
    }
  }
  v6 = *(this + 2);
  if ( v6 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v6 + 8))(*(this + 2));
    *(this + 2) = 0;
  }
  v7 = *(this + 3);
  if ( v7 )
  {
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)v7 + 8))(*(this + 3));
    *(this + 3) = 0;
  }
  *(this + 1) = 0;
  return 0;
}

// FUN_1001619a @ 0x1001619A
// [binja] int32_t* __fastcall sub_1001619a(int32_t* arg1)
void __thiscall sub_1001619A(_DWORD *this)
{
  *this = 0;
}

// FUN_100161a0 @ 0x100161A0
// [binja] int32_t __fastcall sub_100161a0(int32_t* arg1)
int __thiscall sub_100161A0(_DWORD *this)
{
  if ( *this )
    (*(void (__stdcall **)(_DWORD))(*(_DWORD *)*this + 40))(*this);
  *this = 0;
  return 0;
}

// FUN_100161bb @ 0x100161BB
// [binja] int32_t __thiscall sub_100161bb(char* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t arg6, int32_t arg7)
int __thiscall sub_100161BB(_DWORD *this, _DWORD *a2, _DWORD *a3, int a4, int *a5, int a6, int a7)
{
  int result; // eax
  unsigned int v8; // ebx
  unsigned int v9; // eax
  _DWORD *v10; // edi
  _DWORD *v11; // esi
  _DWORD *v12; // edi
  int v13; // ebx
  unsigned int v14; // eax
  bool v15; // zf
  unsigned int v16; // edx
  unsigned int v17; // eax
  unsigned int v18; // esi
  unsigned int v19; // ecx
  int v20; // edx
  int v21; // edx
  unsigned int v22; // edx
  unsigned int v23; // edx
  _DWORD *v24; // eax
  int v25; // [esp+Ch] [ebp-60h] BYREF
  unsigned int v26; // [esp+14h] [ebp-58h]
  int v27; // [esp+18h] [ebp-54h]
  unsigned int v28; // [esp+24h] [ebp-48h]
  unsigned int v29; // [esp+28h] [ebp-44h]
  unsigned int v30; // [esp+2Ch] [ebp-40h] BYREF
  unsigned int v31; // [esp+30h] [ebp-3Ch]
  unsigned int v32; // [esp+34h] [ebp-38h]
  unsigned int v33; // [esp+38h] [ebp-34h]
  int v34; // [esp+3Ch] [ebp-30h]
  int v35; // [esp+40h] [ebp-2Ch]
  int v36; // [esp+44h] [ebp-28h]
  int v37; // [esp+48h] [ebp-24h]
  _DWORD v38[2]; // [esp+4Ch] [ebp-20h] BYREF
  _DWORD *v39; // [esp+54h] [ebp-18h]
  int v40; // [esp+58h] [ebp-14h] BYREF
  _DWORD *v41; // [esp+5Ch] [ebp-10h]
  int v42; // [esp+60h] [ebp-Ch] BYREF
  BOOL v43; // [esp+64h] [ebp-8h]
  int v44; // [esp+68h] [ebp-4h]
  int v45; // [esp+80h] [ebp+14h]

  v39 = this;
  FUN_10016131(this);
  (*(void (__stdcall **)(_DWORD *, int *))(*a3 + 32))(a3, &v25);
  if ( a5 )
  {
    v34 = *a5;
    v35 = a5[1];
    v36 = a5[2];
    v37 = a5[3];
    if ( v34 < 0 || v36 > v28 || v34 > v36 || v35 < 0 || v37 > v29 || v35 > v37 )
      return -2005530516;
    if ( v34 || v36 != v28 || v35 || (v45 = 0, v37 != v29) )
      v45 = 1;
    v43 = (a7 & 1) == 0 && !v45;
  }
  else
  {
    v36 = v28;
    v37 = v29;
    v34 = 0;
    v35 = 0;
    v45 = 0;
    v43 = (a7 & 1) == 0;
  }
  v44 = a7 & 0x10000;
  if ( (a7 & 0x10000) == 0 )
  {
    if ( v27 || (v26 & 0x200) != 0 )
      goto LABEL_38;
    grim_d3d_debug_set_mute(1);
    if ( (*(int (__stdcall **)(_DWORD *, void *, int *))(*a3 + 28))(a3, &unk_1004E544, &v40) < 0 )
    {
      v26 = a3[4];
      v44 = ((v26 >> 26) & 1) == 0;
    }
    else
    {
      v44 = 1;
      if ( v40 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v40 + 8))(v40);
        v40 = 0;
      }
    }
    grim_d3d_debug_set_mute(0);
    if ( !v44 )
    {
LABEL_38:
      v41 = a3;
      goto LABEL_39;
    }
  }
  if ( v25 == 827611204 || v25 == 844388420 || v25 == 861165636 || v25 == 877942852 || v25 == 894720068 )
  {
    v8 = (v28 + 3) & 0xFFFFFFFC;
    v9 = (v29 + 3) & 0xFFFFFFFC;
  }
  else
  {
    v8 = v28;
    v9 = v29;
  }
  v10 = v39;
  v41 = (_DWORD *)v9;
  v11 = v39 + 3;
  (*(void (__stdcall **)(_DWORD *, _DWORD *))(*a3 + 12))(a3, v39 + 3);
  v12 = v10 + 2;
  result = (*(int (__stdcall **)(_DWORD, unsigned int, _DWORD *, int, _DWORD *))(*(_DWORD *)*v11 + 108))(
             *v11,
             v8,
             v41,
             v25,
             v12);
  if ( result >= 0 )
  {
    if ( v43
      || (result = (*(int (__stdcall **)(_DWORD, _DWORD *, _DWORD, _DWORD, _DWORD, _DWORD))(*(_DWORD *)*v11 + 112))(
                     *v11,
                     a3,
                     0,
                     0,
                     *v12,
                     0),
          result >= 0) )
    {
      v41 = (_DWORD *)*v12;
LABEL_39:
      v13 = 16 * (a7 & 1 | 0x80);
      if ( v43 && !v44 && (v26 & 0x200) != 0 )
      {
        if ( (a7 & 0x20000) != 0 )
        {
          v13 |= 0x2000u;
          goto LABEL_84;
        }
        grim_d3d_debug_set_mute(1);
        if ( (*(int (__stdcall **)(_DWORD *, void *, int *))(*a3 + 28))(a3, &unk_1004E534, &v42) >= 0 )
        {
          if ( (*(int (__stdcall **)(int))(*(_DWORD *)v42 + 52))(v42) == 1 )
          {
            v13 |= 0x2000u;
            v45 = 0;
          }
          if ( v42 )
          {
            (*(void (__stdcall **)(int))(*(_DWORD *)v42 + 8))(v42);
            v42 = 0;
          }
        }
        grim_d3d_debug_set_mute(0);
      }
      if ( !v45 )
        goto LABEL_84;
      if ( v25 != 827611204 && v25 != 844388420 )
      {
        if ( v25 == 844715353 )
        {
LABEL_59:
          v14 = (v36 + 1) & 0xFFFFFFFE;
          v30 = v34 & 0xFFFFFFFE;
          v32 = v14;
          v31 = v35;
          v33 = v37;
          if ( v14 > v28 )
          {
            v14 = v28;
            v32 = v28;
          }
          if ( (v34 & 0xFFFFFFFE) != 0 || v14 != v28 || v35 )
            goto LABEL_75;
          v15 = v37 == v29;
          goto LABEL_74;
        }
        if ( v25 != 861165636 && v25 != 877942852 && v25 != 894720068 )
        {
          if ( v25 != 1498831189 )
          {
            v30 = v34;
            v31 = v35;
            v32 = v36;
            v33 = v37;
LABEL_75:
            result = (*(int (__stdcall **)(_DWORD *, _DWORD *, unsigned int *, int))(*v41 + 36))(v41, v38, &v30, v13);
            if ( result < 0 )
              return result;
            v34 -= v30;
            v36 -= v30;
            v35 -= v31;
            v37 -= v31;
            goto LABEL_77;
          }
          goto LABEL_59;
        }
      }
      v16 = v34 & 0xFFFFFFFC;
      v17 = (v36 + 3) & 0xFFFFFFFC;
      v18 = v35 & 0xFFFFFFFC;
      v19 = (v37 + 3) & 0xFFFFFFFC;
      v30 = v34 & 0xFFFFFFFC;
      v32 = v17;
      v31 = v35 & 0xFFFFFFFC;
      v33 = v19;
      if ( v44 )
      {
        if ( v16 || v17 != ((v28 + 3) & 0xFFFFFFFC) || v18 || v19 != ((v29 + 3) & 0xFFFFFFFC) )
          goto LABEL_75;
        goto LABEL_84;
      }
      if ( v17 > v28 )
      {
        v17 = v28;
        v32 = v28;
      }
      if ( v19 > v29 )
      {
        v19 = v29;
        v33 = v29;
      }
      if ( v16 || v17 != v28 || v18 )
        goto LABEL_75;
      v15 = v19 == v29;
LABEL_74:
      if ( !v15 )
        goto LABEL_75;
LABEL_84:
      result = (*(int (__stdcall **)(_DWORD *, _DWORD *, _DWORD, int))(*v41 + 36))(v41, v38, 0, v13);
      if ( result < 0 )
        return result;
LABEL_77:
      v20 = v38[1];
      a2[3] = 0;
      a2[4] = 0;
      a2[5] = 0;
      a2[8] = 0;
      a2[14] = 0;
      *a2 = v20;
      a2[1] = v25;
      v21 = v38[0];
      a2[10] = v34;
      a2[15] = 1;
      a2[16] = 1;
      a2[2] = v21;
      v22 = v28;
      a2[11] = v35;
      a2[17] = a6;
      a2[6] = v22;
      v23 = v29;
      a2[12] = v36;
      a2[18] = a4;
      a2[7] = v23;
      a2[9] = 1;
      v24 = v39;
      a2[13] = v37;
      v24[1] = a3;
      *v24 = a7;
      return 0;
    }
  }
  return result;
}

// FUN_100165d3 @ 0x100165D3
// [binja] int32_t __thiscall sub_100165d3(int32_t* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7)
int __thiscall sub_100165D3(_DWORD *this, _DWORD *a2, int a3, int a4, const void *a5, int a6, int a7)
{
  bool v7; // zf
  unsigned int v8; // ebx
  BOOL v9; // eax
  int result; // eax
  int v11; // esi
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int v16; // edx
  _DWORD *v17; // ecx
  int v18; // [esp+Ch] [ebp-68h] BYREF
  int v19; // [esp+14h] [ebp-60h]
  int v20; // [esp+18h] [ebp-5Ch]
  unsigned int v21; // [esp+20h] [ebp-54h]
  unsigned int v22; // [esp+24h] [ebp-50h]
  unsigned int v23; // [esp+28h] [ebp-4Ch]
  _DWORD v24[6]; // [esp+2Ch] [ebp-48h] BYREF
  _DWORD v25[6]; // [esp+44h] [ebp-30h] BYREF
  _DWORD v26[3]; // [esp+5Ch] [ebp-18h] BYREF
  _DWORD *v27; // [esp+68h] [ebp-Ch]
  int v28; // [esp+6Ch] [ebp-8h]
  int v29; // [esp+70h] [ebp-4h] BYREF
  int v30; // [esp+88h] [ebp+14h]

  v7 = *this == 0;
  v27 = this;
  if ( !v7 )
    FUN_100161a0(this);
  (*(void (__stdcall **)(int, int *))(*(_DWORD *)a3 + 32))(a3, &v18);
  if ( a5 )
  {
    qmemcpy(v25, a5, sizeof(v25));
    if ( v25[2] > v21 )
      return -2005530516;
    if ( v25[0] > v25[2] )
      return -2005530516;
    if ( v25[3] > v22 )
      return -2005530516;
    if ( v25[1] > v25[3] )
      return -2005530516;
    v8 = v25[5];
    if ( v25[5] > v23 || v25[4] > v25[5] )
      return -2005530516;
    if ( v25[0] || v25[2] != v21 || v25[1] || v25[3] != v22 || v25[4] || (v30 = 0, v25[5] != v23) )
      v30 = 1;
    v9 = (a7 & 1) == 0 && !v30;
  }
  else
  {
    v8 = v23;
    v30 = 0;
    v25[2] = v21;
    v25[3] = v22;
    v9 = (a7 & 1) == 0;
    v25[0] = 0;
    v25[1] = 0;
    v25[4] = 0;
    v25[5] = v23;
  }
  if ( !v20 && (v19 & 0x200) == 0 )
    return -2005530516;
  v11 = 16 * (a7 & 1 | 0x80);
  v28 = v11;
  if ( v9 && (v19 & 0x200) != 0 )
  {
    if ( (a7 & 0x20000) != 0 )
    {
      v11 |= 0x2000u;
      goto LABEL_65;
    }
    grim_d3d_debug_set_mute(1);
    if ( (*(int (__stdcall **)(int, void *, int *))(*(_DWORD *)a3 + 28))(a3, &unk_1004E524, &v29) >= 0 )
    {
      if ( (*(int (__stdcall **)(int))(*(_DWORD *)v29 + 52))(v29) == 1 )
      {
        v11 |= 0x2000u;
        v28 = v11;
        v30 = 0;
      }
      if ( v29 )
      {
        (*(void (__stdcall **)(int))(*(_DWORD *)v29 + 8))(v29);
        v29 = 0;
      }
    }
    grim_d3d_debug_set_mute(0);
  }
  if ( !v30 )
    goto LABEL_65;
  if ( v18 != 827611204 && v18 != 844388420 )
  {
    if ( v18 == 844715353 )
    {
LABEL_44:
      v12 = (v25[2] + 1) & 0xFFFFFFFE;
      v24[3] = v25[3];
      v24[0] = v25[0] & 0xFFFFFFFE;
      v24[2] = v12;
      v24[1] = v25[1];
      v24[4] = v25[4];
      v24[5] = v8;
      if ( v12 > v21 )
      {
        v12 = v21;
        v24[2] = v21;
      }
      if ( (v25[0] & 0xFFFFFFFE) != 0 || v12 != v21 || v25[1] || v25[3] != v22 || v25[4] || v8 != v23 )
        goto LABEL_68;
      goto LABEL_65;
    }
    if ( v18 != 861165636 && v18 != 877942852 && v18 != 894720068 )
    {
      if ( v18 != 1498831189 )
      {
        qmemcpy(v24, v25, sizeof(v24));
LABEL_67:
        v11 = v28;
LABEL_68:
        result = (*(int (__stdcall **)(int, _DWORD *, _DWORD *, int))(*(_DWORD *)a3 + 36))(a3, v26, v24, v11);
        if ( result < 0 )
          return result;
        v25[0] -= v24[0];
        v25[2] -= v24[0];
        v25[1] -= v24[1];
        v25[3] -= v24[1];
        v25[4] -= v24[4];
        v25[5] = v8 - v24[4];
        goto LABEL_70;
      }
      goto LABEL_44;
    }
  }
  v13 = (v25[2] + 3) & 0xFFFFFFFC;
  v14 = (v25[3] + 3) & 0xFFFFFFFC;
  v24[0] = v25[0] & 0xFFFFFFFC;
  v24[2] = v13;
  v24[1] = v25[1] & 0xFFFFFFFC;
  v24[3] = v14;
  v24[4] = v25[4];
  v24[5] = v8;
  if ( v13 > v21 )
  {
    v13 = v21;
    v24[2] = v21;
  }
  if ( v14 > v22 )
  {
    v14 = v22;
    v24[3] = v22;
  }
  if ( (v25[0] & 0xFFFFFFFC) != 0 || v13 != v21 || (v25[1] & 0xFFFFFFFC) != 0 || v14 != v22 || v25[4] || v8 != v23 )
    goto LABEL_67;
  v11 = v28;
LABEL_65:
  result = (*(int (__stdcall **)(int, _DWORD *, _DWORD, int))(*(_DWORD *)a3 + 36))(a3, v26, 0, v11);
  if ( result >= 0 )
  {
LABEL_70:
    v15 = v21;
    *a2 = v26[2];
    a2[1] = v18;
    a2[2] = v26[0];
    a2[3] = v26[1];
    a2[4] = 0;
    a2[5] = 0;
    a2[8] = 0;
    a2[9] = v23;
    qmemcpy(a2 + 10, v25, 0x18u);
    a2[17] = a6;
    a2[6] = v15;
    v16 = v22;
    a2[18] = a4;
    v17 = v27;
    a2[7] = v16;
    a2[16] = 1;
    *v17 = a3;
    return 0;
  }
  return result;
}

// grim_vertex_space_converter_destroy @ 0x1001692E
// frees the converted vertex buffer at this+0x104c
void __thiscall sub_1001692E(_DWORD *this)
{
  void *v1; // [esp-4h] [ebp-4h]

  v1 = (void *)*(this + 1043);
  *this = &off_1004CAE4;
  operator delete(v1);
}

// nullsub_6 @ 0x10016941
void __stdcall nullsub_6(int a1, int a2, int a3)
{
  ;
}

// grim_convert_vertex_space @ 0x10016944
// converts vec4 coordinates between space modes (1/2/3), writes to this+0x104c, returns the output buffer
int __thiscall sub_10016944(_DWORD *this, int a2)
{
  unsigned int v2; // esi
  int v3; // edx
  float *v4; // eax
  double v5; // st7
  unsigned int v6; // esi
  int v7; // edx
  float *v8; // eax
  double v9; // st5
  unsigned int v10; // esi
  int v11; // edx
  float *v12; // eax
  double v13; // st7
  unsigned int v14; // esi
  int v15; // edx
  float *v16; // eax
  double v17; // st5
  unsigned int v18; // esi
  int v19; // edx
  float *v20; // eax
  double v21; // st5
  unsigned int v22; // esi
  int v23; // edx
  float *v24; // eax
  double v25; // st5

  switch ( *(this + 2) )
  {
    case 1:
      if ( *(this + 1042) == 2 )
      {
        v22 = 0;
        if ( *(this + 1046) )
        {
          v23 = 0;
          v24 = (float *)(a2 + 8);
          do
          {
            ++v22;
            *(float *)(v23 + *(this + 1043)) = (*(v24 - 2) + 1.0) * 0.5;
            v23 += 16;
            *(float *)(v23 + *(this + 1043) - 12) = (*(v24 - 1) + 1.0) * 0.5;
            v25 = *v24;
            v24 += 4;
            *(float *)(v23 + *(this + 1043) - 8) = (v25 + 1.0) * 0.5;
            *(float *)(v23 + *(this + 1043) - 4) = *(v24 - 3);
          }
          while ( v22 < *(this + 1046) );
        }
      }
      else if ( *(this + 1042) == 3 )
      {
        v18 = 0;
        if ( *(this + 1046) )
        {
          v19 = 0;
          v20 = (float *)(a2 + 8);
          do
          {
            ++v18;
            *(float *)(v19 + *(this + 1043)) = (*(v20 - 2) + 1.0) * 0.5;
            v19 += 16;
            *(float *)(v19 + *(this + 1043) - 12) = (*(v20 - 1) + 1.0) * 0.5;
            v21 = *v20;
            v20 += 4;
            *(float *)(v19 + *(this + 1043) - 8) = (v21 + 1.0) * 0.5;
            *(float *)(v19 + *(this + 1043) - 4) = (*(v20 - 3) + 1.0) * 0.5;
          }
          while ( v18 < *(this + 1046) );
        }
      }
      break;
    case 2:
      if ( *(this + 1042) == 1 )
      {
        v14 = 0;
        if ( *(this + 1046) )
        {
          v15 = 0;
          v16 = (float *)(a2 + 8);
          do
          {
            ++v14;
            *(float *)(v15 + *(this + 1043)) = *(v16 - 2) * 2.0 - 1.0;
            v15 += 16;
            *(float *)(v15 + *(this + 1043) - 12) = *(v16 - 1) * 2.0 - 1.0;
            v17 = *v16;
            v16 += 4;
            *(float *)(v15 + *(this + 1043) - 8) = v17 * 2.0 - 1.0;
            *(float *)(v15 + *(this + 1043) - 4) = *(v16 - 3);
          }
          while ( v14 < *(this + 1046) );
        }
      }
      else if ( *(this + 1042) == 3 )
      {
        v10 = 0;
        if ( *(this + 1046) )
        {
          v11 = 0;
          v12 = (float *)(a2 + 8);
          do
          {
            *(float *)(v11 + *(this + 1043)) = *(v12 - 2);
            ++v10;
            *(float *)(v11 + *(this + 1043) + 4) = *(v12 - 1);
            v11 += 16;
            *(float *)(v11 + *(this + 1043) - 8) = *v12;
            v13 = v12[1];
            v12 += 4;
            *(float *)(v11 + *(this + 1043) - 4) = (v13 + 1.0) * 0.5;
          }
          while ( v10 < *(this + 1046) );
        }
      }
      break;
    case 3:
      if ( *(this + 1042) == 1 )
      {
        v6 = 0;
        if ( *(this + 1046) )
        {
          v7 = 0;
          v8 = (float *)(a2 + 8);
          do
          {
            ++v6;
            *(float *)(v7 + *(this + 1043)) = *(v8 - 2) * 2.0 - 1.0;
            v7 += 16;
            *(float *)(v7 + *(this + 1043) - 12) = *(v8 - 1) * 2.0 - 1.0;
            v9 = *v8;
            v8 += 4;
            *(float *)(v7 + *(this + 1043) - 8) = v9 * 2.0 - 1.0;
            *(float *)(v7 + *(this + 1043) - 4) = *(v8 - 3) * 2.0 - 1.0;
          }
          while ( v6 < *(this + 1046) );
        }
      }
      else if ( *(this + 1042) == 2 )
      {
        v2 = 0;
        if ( *(this + 1046) )
        {
          v3 = 0;
          v4 = (float *)(a2 + 8);
          do
          {
            *(float *)(v3 + *(this + 1043)) = *(v4 - 2);
            ++v2;
            *(float *)(v3 + *(this + 1043) + 4) = *(v4 - 1);
            v3 += 16;
            *(float *)(v3 + *(this + 1043) - 8) = *v4;
            v5 = v4[1];
            v4 += 4;
            *(float *)(v3 + *(this + 1043) - 4) = v5 + v5 - 1.0;
          }
          while ( v2 < *(this + 1046) );
        }
      }
      break;
  }
  return *(this + 1043);
}

// nullsub_3 @ 0x10016C3B
void nullsub_3()
{
  ;
}

// FUN_10016c3c @ 0x10016C3C
// [binja] int32_t __fastcall sub_10016c3c(void*** arg1)
void __thiscall sub_10016C3C(int this)
{
  unsigned int v2; // ebx
  unsigned int j; // edi
  int i; // [esp+8h] [ebp-10h]

  *(_DWORD *)this = &off_1004CAF8;
  if ( *(_DWORD *)(this + 4284) )
  {
    if ( *(_DWORD *)(this + 4288) )
    {
      v2 = *(_DWORD *)(this + 4252);
      for ( i = *(_DWORD *)(this + 4288); v2 < *(_DWORD *)(this + 4256); ++v2 )
      {
        for ( j = *(_DWORD *)(this + 4240); j < *(_DWORD *)(this + 4248); j += 4 )
        {
          operator delete(*(void **)(i + 4));
          i += 8;
        }
      }
    }
  }
  operator delete(*(void **)(this + 4280));
  operator delete(*(void **)(this + 4288));
  grim_vertex_space_converter_destroy((_DWORD *)this);
}

// grim_pixel_format_write_dxt_cache @ 0x10016CDC
// writes RGBA floats into the DXT block cache and encodes when block data is complete
void __thiscall sub_10016CDC(int this, int a2, int a3, int a4)
{
  unsigned int v5; // esi
  void *v6; // edi
  unsigned int v7; // edi
  void *v8; // eax
  void *v9; // eax
  unsigned int v10; // ecx
  unsigned int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // eax
  unsigned int v14; // eax
  int v15; // edi
  unsigned int v16; // eax
  unsigned int v17; // edx
  int v18; // ecx
  _DWORD *v19; // edi
  _DWORD *v20; // esi
  int v21; // eax
  unsigned int v22; // eax
  int v23; // esi
  unsigned int v24; // eax
  _DWORD *v25; // edx
  int v26; // ecx
  int v27; // esi
  _DWORD *v28; // esi
  int v29; // [esp+Ch] [ebp-18h]
  unsigned int v30; // [esp+Ch] [ebp-18h]
  unsigned int v31; // [esp+Ch] [ebp-18h]
  unsigned int j; // [esp+Ch] [ebp-18h]
  void *v33; // [esp+10h] [ebp-14h]
  char *v34; // [esp+10h] [ebp-14h]
  void *v35; // [esp+10h] [ebp-14h]
  unsigned int v36; // [esp+14h] [ebp-10h]
  unsigned int v37; // [esp+2Ch] [ebp+8h]
  _DWORD *v38; // [esp+2Ch] [ebp+8h]
  int v39; // [esp+30h] [ebp+Ch]
  _DWORD *v40; // [esp+30h] [ebp+Ch]
  unsigned int i; // [esp+34h] [ebp+10h]
  unsigned int v42; // [esp+34h] [ebp+10h]

  v5 = *(_DWORD *)(this + 4148) + a2;
  v39 = *(_DWORD *)(this + 4160) + a3;
  v37 = v5;
  if ( !*(_DWORD *)(this + 4288) )
  {
    v6 = operator new(8 * *(_DWORD *)(this + 4268) * *(_DWORD *)(this + 4264));
    *(_DWORD *)(this + 4288) = v6;
    if ( !v6 )
      return;
    memset(v6, 0, 8 * *(_DWORD *)(this + 4268) * *(_DWORD *)(this + 4264));
  }
  v7 = *(_DWORD *)(this + 4288)
     + 8 * (((v5 - *(_DWORD *)(this + 4240)) >> 2) + *(_DWORD *)(this + 4264) * (v39 - *(_DWORD *)(this + 4252)));
  v36 = v7;
  if ( !*(_DWORD *)(v7 + 4) )
  {
    v29 = 16 * *(_DWORD *)(this + 4260);
    v8 = operator new(*(_DWORD *)(this + 4260) << 8);
    v33 = v8;
    if ( v8 )
    {
      sub_1000B393((int)v8, 16, v29, (int (__thiscall *)(int))sub_1000AE4F);
      v9 = v33;
    }
    else
    {
      v9 = 0;
    }
    *(_DWORD *)(v7 + 4) = v9;
    if ( !v9 )
      return;
    *(_DWORD *)v7 = 0;
    ++*(_DWORD *)(this + 4284);
  }
  if ( !*(_DWORD *)v7 )
  {
    v10 = 4;
    if ( *(_DWORD *)(this + 4156) >= 4u )
      v10 = *(_DWORD *)(this + 4156);
    v11 = v5 & 3;
    if ( v11 < *(_DWORD *)(this + 4148) || v11 + 4 > v10 )
    {
      v14 = *(_DWORD *)(this + 4236);
      v15 = *(_DWORD *)(this + 24)
          + v39 * *(_DWORD *)(this + 4180)
          + *(_DWORD *)(this + 4224) * (v14 >> 2)
          + *(_DWORD *)(this + 4176) * (v5 >> 2);
      v34 = *(char **)(v36 + 4);
      v31 = v14;
      while ( v14 < *(_DWORD *)(this + 4244) )
      {
        (*(void (__cdecl **)(char *, int))(this + 4228))(v34, v15);
        v15 += *(_DWORD *)(this + 4224);
        v34 += 256;
        v31 += 4;
        v14 = v31;
      }
      v7 = v36;
    }
    else
    {
      v30 = 4;
      if ( *(_DWORD *)(this + 4152) >= 4u )
        v30 = *(_DWORD *)(this + 4152);
      v12 = *(_DWORD *)(this + 4236);
      if ( v12 < *(_DWORD *)(this + 4144) )
        (*(void (__cdecl **)(_DWORD, unsigned int))(this + 4228))(
          *(_DWORD *)(v7 + 4),
          *(_DWORD *)(this + 24)
        + v39 * *(_DWORD *)(this + 4180)
        + *(_DWORD *)(this + 4176) * (v5 >> 2)
        + *(_DWORD *)(this + 4224) * (v12 >> 2));
      v13 = *(_DWORD *)(this + 4244);
      if ( v13 > v30 )
        (*(void (__cdecl **)(_DWORD, unsigned int))(this + 4228))(
          *(_DWORD *)(v7 + 4),
          *(_DWORD *)(this + 24)
        + v39 * *(_DWORD *)(this + 4180)
        + *(_DWORD *)(this + 4176) * (v5 >> 2)
        + *(_DWORD *)(this + 4224) * ((v13 - 4) >> 2));
    }
  }
  if ( *(_DWORD *)(this + 4168) )
    a4 = grim_convert_vertex_space((_DWORD *)this, a4);
  v16 = *(_DWORD *)(this + 4144) - *(_DWORD *)(this + 4236);
  v17 = v16 + *(_DWORD *)(this + 4184);
  v18 = (v5 - *(_DWORD *)(this + 4240)) & 3;
  if ( v16 < v17 )
  {
    do
    {
      v19 = (_DWORD *)(*(_DWORD *)(v36 + 4) + 16 * (v16 & 3 | (4 * (v18 | v16 & 0xFFFFFFFC))));
      v20 = (_DWORD *)a4;
      a4 += 16;
      *v19 = *v20++;
      *++v19 = *v20++;
      *++v19 = *v20;
      ++v16;
      v19[1] = v20[1];
    }
    while ( v16 < v17 );
    v5 = v37;
    v7 = v36;
  }
  v21 = (v5 - *(_DWORD *)(this + 4240)) & 3;
  if ( *(_DWORD *)(this + 4212) )
  {
    for ( i = 0; i < 4; ++i )
    {
      if ( (i & *(_DWORD *)(this + 4220)) == v21 )
        *(_DWORD *)v7 |= 1 << i;
    }
  }
  else
  {
    *(_DWORD *)v7 |= 1 << v21;
  }
  if ( *(_DWORD *)v7 == 15 )
  {
    v22 = *(_DWORD *)(this + 4236);
    v23 = *(_DWORD *)(this + 24)
        + v39 * *(_DWORD *)(this + 4180)
        + *(_DWORD *)(this + 4224) * (v22 >> 2)
        + *(_DWORD *)(this + 4176) * (v5 >> 2);
    v40 = *(_DWORD **)(v7 + 4);
    for ( j = v22; ; v22 = j )
    {
      v35 = (void *)v23;
      if ( v22 >= *(_DWORD *)(this + 4244) )
        break;
      v24 = 0;
      if ( *(_DWORD *)(this + 4212) )
      {
        v25 = v40;
        do
        {
          v42 = 0;
          v26 = 4 * v24;
          v38 = v25;
          do
          {
            v27 = (*(_DWORD *)(this + 4216) & v42) + 4 * (v24 & *(_DWORD *)(this + 4220));
            if ( v26 != v27 )
            {
              v28 = &v40[4 * v27];
              *v38 = *v28++;
              v38[1] = *v28++;
              v38[2] = *v28;
              v38[3] = v28[1];
              v7 = v36;
            }
            ++v42;
            v38 += 4;
            ++v26;
          }
          while ( v42 < 4 );
          v25 = v38;
          ++v24;
        }
        while ( v24 < 4 );
      }
      (*(void (__cdecl **)(void *, _DWORD *))(this + 4232))(v35, v40);
      v23 = (int)v35 + *(_DWORD *)(this + 4224);
      v40 += 64;
      j += 4;
    }
    if ( v7 + 8 >= *(_DWORD *)(this + 4288) + 8 * *(_DWORD *)(this + 4264) * *(_DWORD *)(this + 4268)
      || *(_DWORD *)(v7 + 8)
      || *(_DWORD *)(v7 + 12) )
    {
      operator delete(*(void **)(v7 + 4));
      --*(_DWORD *)(this + 4284);
    }
    else
    {
      *(_DWORD *)(v7 + 12) = *(_DWORD *)(v7 + 4);
      *(_DWORD *)(v7 + 4) = 0;
    }
    *(_DWORD *)(v7 + 4) = 0;
  }
}

// fpu_set_round_trunc @ 0x100170D6
// sets x87 rounding mode to truncate; saves control word in DAT_1005db6c
int sub_100170D6()
{
  int v1; // [esp+0h] [ebp-8h]

  dword_1005DB6C = v1;
  return v1;
}

// grim_pixel_format_init @ 0x100170F9
// initializes format descriptor, bytes-per-pixel, palette expansion, and coordinate mode
float *__thiscall sub_100170F9(float *this, float *a2, unsigned int a3, int a4)
{
  unsigned int v5; // esi
  void *v6; // ecx
  int v7; // ecx
  unsigned int v8; // ecx
  int v9; // ecx
  float *v10; // ecx
  float *v11; // eax
  int v12; // ecx
  int v13; // ecx
  int v14; // eax
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // ecx
  bool v19; // zf
  int v20; // eax
  float v22; // [esp+Ch] [ebp-10h]
  float v23; // [esp+10h] [ebp-Ch]
  float v24; // [esp+14h] [ebp-8h]
  float v25; // [esp+18h] [ebp-4h]
  int v26; // [esp+28h] [ebp+Ch]

  *(_DWORD *)this = &off_1004CAE4;
  sub_1000B393((int)(this + 12), 16, 256, (int (__thiscall *)(int))sub_1000AE4F);
  *(this + 6) = *a2;
  *(this + 1) = a2[1];
  *(this + 1044) = a2[2];
  *(this + 1045) = a2[3];
  qmemcpy(this + 1036, a2 + 10, 0x18u);
  v5 = 0;
  v6 = &unk_10054418;
  if ( !*((_DWORD *)a2 + 16) )
    v6 = &unk_10054398;
  *((_DWORD *)this + 11) = v6;
  *((_DWORD *)this + 1050) = a3 >> 3;
  *(this + 1042) = 0.0;
  *(this + 1043) = 0.0;
  *((_DWORD *)this + 3) = a3 != 0;
  *((_DWORD *)this + 2) = a4;
  v7 = *((_DWORD *)a2 + 17);
  *((_DWORD *)this + 4) = v7;
  if ( v7 )
  {
    v8 = *((_DWORD *)a2 + 17);
    v22 = (double)BYTE2(v8) * 0.0039215689;
    v23 = (double)BYTE1(v8) * 0.0039215689;
    v24 = (double)(unsigned __int8)v8 * 0.0039215689;
    v25 = (double)HIBYTE(v8) * 0.0039215689;
    *(this + 7) = v22;
    *(this + 8) = v23;
    *(this + 9) = v24;
    *(this + 10) = v25;
    v5 = 0;
  }
  v9 = *((_DWORD *)this + 1);
  if ( v9 == 41 || v9 == 40 )
  {
    *((_DWORD *)this + 5) = 1;
    if ( *((_DWORD *)a2 + 18) )
    {
      v10 = this + 13;
      do
      {
        v26 = *(unsigned __int8 *)(v5 + *((_DWORD *)a2 + 18));
        v5 += 4;
        *(v10 - 1) = (double)v26 * 0.0039215689;
        *v10 = (double)*(unsigned __int8 *)(v5 + *((_DWORD *)a2 + 18) - 3) * 0.0039215689;
        v10 += 4;
        *(v10 - 3) = (double)*(unsigned __int8 *)(v5 + *((_DWORD *)a2 + 18) - 2) * 0.0039215689;
        *(v10 - 2) = (double)*(unsigned __int8 *)(v5 + *((_DWORD *)a2 + 18) - 1) * 0.0039215689;
      }
      while ( v5 < 0x400 );
    }
    else
    {
      v11 = this + 14;
      v12 = 256;
      do
      {
        v11[1] = 1.0;
        *v11 = 1.0;
        v11 += 4;
        --v12;
        *(v11 - 5) = 1.0;
        *(v11 - 6) = 1.0;
      }
      while ( v12 );
    }
  }
  else
  {
    *(this + 5) = 0.0;
  }
  v13 = *((_DWORD *)this + 1038);
  v14 = *((_DWORD *)this + 1040);
  *((_DWORD *)this + 1047) = *((_DWORD *)this + 1039) - *((_DWORD *)this + 1037);
  v15 = *((_DWORD *)this + 1041) - v14;
  v16 = *((_DWORD *)this + 1050);
  v17 = *((_DWORD *)this + 1036);
  v18 = v13 - v17;
  *((_DWORD *)this + 1048) = v15;
  *((_DWORD *)this + 1046) = v18;
  v19 = *((_DWORD *)this + 3) == 0;
  *((_DWORD *)this + 1049) = v18 * v16;
  if ( !v19 )
  {
    *((_DWORD *)this + 6) += *((_DWORD *)this + 1040) * *((_DWORD *)this + 1045)
                           + *((_DWORD *)this + 1037) * *((_DWORD *)this + 1044)
                           + v17 * v16;
    *(this + 1038) = *(this + 1046);
    *(this + 1039) = *(this + 1047);
    v20 = *((_DWORD *)this + 1048);
    *(this + 1036) = 0.0;
    *(this + 1037) = 0.0;
    *(this + 1040) = 0.0;
    *((_DWORD *)this + 1041) = v20;
  }
  return this;
}

// FUN_10017345 @ 0x10017345
// [binja] void*** __thiscall sub_10017345(void*** arg1, char arg2)
_DWORD *__thiscall sub_10017345(_DWORD *this, char a2)
{
  grim_vertex_space_converter_destroy(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// FUN_10017361 @ 0x10017361
// [binja] int32_t __thiscall sub_10017361(void* arg1, void* arg2)
int __thiscall sub_10017361(int *this, int a2)
{
  int v3; // edi
  void *v4; // ebx
  int v5; // eax

  if ( *(this + 2) != *(_DWORD *)(a2 + 8) )
  {
    v3 = *(this + 1046);
    v4 = operator new(16 * v3);
    v5 = 0;
    if ( v4 )
    {
      sub_1000B393((int)v4, 16, v3, (int (__thiscall *)(int))sub_1000AE4F);
      v5 = (int)v4;
    }
    *(this + 1043) = v5;
    if ( !v5 )
      return -2147024882;
    *(this + 1042) = *(_DWORD *)(a2 + 8);
  }
  return 0;
}

// FUN_100173dc @ 0x100173DC
// [binja] int32_t __fastcall sub_100173dc(int32_t* arg1)
int __thiscall sub_100173DC(_DWORD *this)
{
  int v2; // eax
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  int result; // eax
  char v7; // [esp+Ch] [ebp-24h] BYREF
  int v8; // [esp+14h] [ebp-1Ch]
  int v9; // [esp+18h] [ebp-18h]
  int v10; // [esp+1Ch] [ebp-14h]
  int v11; // [esp+20h] [ebp-10h]
  int v12; // [esp+24h] [ebp-Ch]
  int v13; // [esp+28h] [ebp-8h]
  int v14; // [esp+2Ch] [ebp-4h]

  v2 = *(this + 1046);
  v3 = *(this + 1050);
  v12 = v2;
  v11 = *(this + 1049);
  v10 = *(this + 6);
  v9 = *(this + 11);
  v8 = *(this + 4);
  *(this + 1049) = v3;
  v4 = *(this + 2) == 1;
  *(this + 1046) = 1;
  *(this + 6) = &v7;
  *(this + 11) = &unk_10054398;
  *(this + 4) = 0;
  if ( !v4 )
  {
    v14 = *(this + 1042);
    v5 = *(this + 1043);
    *(this + 1042) = 1;
    v13 = v5;
    *(this + 1043) = this + 7;
    grim_convert_vertex_space(this, (int)(this + 7));
    *(this + 1042) = v14;
    *(this + 1043) = v13;
  }
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD *))(*this + 8))(this, 0, 0, this + 7);
  (*(void (__thiscall **)(_DWORD *, _DWORD, _DWORD, _DWORD *))(*this + 4))(this, 0, 0, this + 7);
  *(this + 1046) = v12;
  *(this + 1049) = v11;
  *(this + 6) = v10;
  *(this + 11) = v9;
  result = v8;
  *(this + 4) = v8;
  return result;
}

// grim_apply_color_key @ 0x100174A8
// zeroes RGBA pixels that match the current color key
void __thiscall sub_100174A8(int this, unsigned int a2)
{
  float *v2; // edx
  unsigned int v3; // esi

  if ( a2 < a2 + 16 * *(_DWORD *)(this + 4184) )
  {
    v2 = (float *)(a2 + 8);
    v3 = ((unsigned int)(16 * *(_DWORD *)(this + 4184) - 1) >> 4) + 1;
    do
    {
      if ( *(v2 - 2) == *(float *)(this + 28)
        && *(v2 - 1) == *(float *)(this + 32)
        && *v2 == *(float *)(this + 36)
        && v2[1] == *(float *)(this + 40) )
      {
        v2[1] = 0.0;
        *v2 = 0.0;
        *(v2 - 1) = 0.0;
        *(v2 - 2) = 0.0;
      }
      v2 += 4;
      --v3;
    }
    while ( v3 );
  }
}

// FUN_10017518 @ 0x10017518
// [binja] int16_t __thiscall sub_10017518(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017518(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _BYTE *v6; // edx
  int v7; // eax
  unsigned int i; // esi
  float v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+Ch] [ebp-Ch]
  float v12; // [esp+Ch] [ebp-Ch]
  float v13; // [esp+10h] [ebp-8h]
  _DWORD *v14; // [esp+14h] [ebp-4h]

  v14 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v14;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  for ( i = 0; i < v14[1046]; v7 += 16 )
  {
    v13 = *(float *)(v5 + 4 * (i & 3));
    v10 = *(float *)(v7 + a4 + 8) * 255.0 + v13;
    *v6 = (int)v10;
    v11 = *(float *)(v7 + a4 + 4) * 255.0 + v13;
    v6[1] = (int)v11;
    v12 = *(float *)(v7 + a4) * 255.0 + v13;
    v6[2] = (int)v12;
    v6 += 3;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10017604 @ 0x10017604
// [binja] int16_t __thiscall sub_10017604(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017604(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // ebx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  float v13; // [esp+18h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-Ch]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v18[1046] )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v5 + 4 * (v7 & 3));
      v13 = *(float *)(v8 + a4) * 255.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + a4 + 4) * 255.0 + v17;
      v12 = (int)v14;
      v15 = *(float *)(v8 + a4 + 8) * 255.0 + v17;
      v11 = (int)v15;
      v16 = *(float *)(v8 + a4 + 12) * 255.0 + v17;
      v8 += 16;
      *v6++ = v11 | ((v12 | ((v9 | ((int)v16 << 8)) << 8)) << 8);
      ++v7;
    }
    while ( v7 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017727 @ 0x10017727
// [binja] int16_t __thiscall sub_10017727(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017727(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // eax
  int v11; // [esp+0h] [ebp-1Ch]
  float v12; // [esp+10h] [ebp-Ch]
  float v13; // [esp+10h] [ebp-Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+14h] [ebp-8h]
  _DWORD *v16; // [esp+18h] [ebp-4h]

  v16 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v16[1046] )
  {
    v8 = 0;
    do
    {
      v15 = *(float *)(v5 + 4 * (v7 & 3));
      v12 = *(float *)(v8 + a4) * 255.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v8 + a4 + 4) * 255.0 + v15;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 8) * 255.0 + v15;
      v8 += 16;
      *v6++ = (int)v14 | ((v11 | (v9 << 8)) << 8);
      ++v7;
    }
    while ( v7 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017828 @ 0x10017828
// [binja] int16_t __thiscall sub_10017828(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017828(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  __int16 v9; // ax
  int v11; // [esp+0h] [ebp-1Ch]
  float v12; // [esp+10h] [ebp-Ch]
  float v13; // [esp+10h] [ebp-Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+14h] [ebp-8h]
  _DWORD *v16; // [esp+18h] [ebp-4h]

  v16 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v16[1046] )
  {
    v8 = 0;
    do
    {
      v15 = *(float *)(v5 + 4 * (v7 & 3));
      v12 = *(float *)(v8 + a4) * 31.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v8 + a4 + 4) * 63.0 + v15;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 8) * 31.0 + v15;
      v8 += 16;
      *v6++ = (int)v14 | (32 * (v11 | (v9 << 6)));
      ++v7;
    }
    while ( v7 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017929 @ 0x10017929
// [binja] int16_t __thiscall sub_10017929(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017929(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  __int16 v9; // ax
  int v11; // [esp+0h] [ebp-1Ch]
  float v12; // [esp+10h] [ebp-Ch]
  float v13; // [esp+10h] [ebp-Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+14h] [ebp-8h]
  _DWORD *v16; // [esp+18h] [ebp-4h]

  v16 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v16[1046] )
  {
    v8 = 0;
    do
    {
      v15 = *(float *)(v5 + 4 * (v7 & 3));
      v12 = *(float *)(v8 + a4) * 31.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v8 + a4 + 4) * 31.0 + v15;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 8) * 31.0 + v15;
      v8 += 16;
      *v6++ = (int)v14 | (32 * (v11 | (32 * v9)));
      ++v7;
    }
    while ( v7 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017a2a @ 0x10017A2A
// [binja] int16_t __thiscall sub_10017a2a(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017A2A(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // ebx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  float v13; // [esp+18h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-Ch]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v18[1046] )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v5 + 4 * (v7 & 3));
      v13 = *(float *)(v8 + a4) * 31.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + a4 + 4) * 31.0 + v17;
      v12 = (int)v14;
      v15 = *(float *)(v8 + a4 + 8) * 31.0 + v17;
      v11 = (int)v15;
      v16 = v17 + *(float *)(v8 + a4 + 12);
      v8 += 16;
      *v6++ = v11 | (32 * (v12 | (32 * (v9 | (32 * (int)v16)))));
      ++v7;
    }
    while ( v7 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017b47 @ 0x10017B47
// [binja] int16_t __thiscall sub_10017b47(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017B47(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // ebx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  float v13; // [esp+18h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-Ch]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v18[1046] )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v5 + 4 * (v7 & 3));
      v13 = *(float *)(v8 + a4) * 15.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + a4 + 4) * 15.0 + v17;
      v12 = (int)v14;
      v15 = *(float *)(v8 + a4 + 8) * 15.0 + v17;
      v11 = (int)v15;
      v16 = *(float *)(v8 + a4 + 12) * 15.0 + v17;
      v8 += 16;
      *v6++ = v11 | (16 * (v12 | (16 * (v9 | (16 * (int)v16)))));
      ++v7;
    }
    while ( v7 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017c6a @ 0x10017C6A
// [binja] int16_t __thiscall sub_10017c6a(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017C6A(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // edi
  int v5; // eax
  int v6; // ebx
  _BYTE *v7; // edx
  int v8; // esi
  char v9; // al
  int v11; // [esp+Ch] [ebp-1Ch]
  float v12; // [esp+1Ch] [ebp-Ch]
  float v13; // [esp+1Ch] [ebp-Ch]
  float v14; // [esp+1Ch] [ebp-Ch]
  float v15; // [esp+20h] [ebp-8h]
  _DWORD *v16; // [esp+24h] [ebp-4h]

  v4 = 0;
  v16 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v16[1046] )
  {
    v8 = 0;
    do
    {
      v15 = *(float *)(v6 + 4 * (v4 & 3));
      v12 = *(float *)(v8 + a4) * 7.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v8 + a4 + 4) * 7.0 + v15;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 8) * 3.0 + v15;
      v8 += 16;
      *v7++ = (int)v14 | (4 * (v11 | (8 * v9)));
      ++v4;
    }
    while ( v4 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017d68 @ 0x10017D68
// [binja] int16_t __thiscall sub_10017d68(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017D68(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // esi
  _BYTE *v7; // edx
  unsigned int i; // ecx
  float v10; // [esp+10h] [ebp-8h]
  _DWORD *v11; // [esp+14h] [ebp-4h]

  v4 = 0;
  v11 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v11;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < v11[1046]; v4 += 16 )
  {
    v10 = *(float *)(v6 + 4 * (i & 3)) + *(float *)(v4 + a4 + 12) * 255.0;
    *v7++ = (int)v10;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10017e11 @ 0x10017E11
// [binja] int16_t __thiscall sub_10017e11(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017E11(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // eax
  int v9; // ebx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  float v13; // [esp+18h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-Ch]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v18[1046] )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v5 + 4 * (v7 & 3));
      v13 = *(float *)(v8 + a4) * 7.0 + v17;
      v9 = (int)v13;
      v14 = *(float *)(v8 + a4 + 4) * 7.0 + v17;
      v12 = (int)v14;
      v15 = *(float *)(v8 + a4 + 8) * 3.0 + v17;
      v11 = (int)v15;
      v16 = *(float *)(v8 + a4 + 12) * 255.0 + v17;
      v8 += 16;
      *v6++ = v11 | (4 * (v12 | (8 * (v9 | (8 * (int)v16)))));
      ++v7;
    }
    while ( v7 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10017f34 @ 0x10017F34
// [binja] int16_t __thiscall sub_10017f34(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10017F34(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  __int16 v9; // ax
  int v11; // [esp+0h] [ebp-1Ch]
  float v12; // [esp+10h] [ebp-Ch]
  float v13; // [esp+10h] [ebp-Ch]
  float v14; // [esp+10h] [ebp-Ch]
  float v15; // [esp+14h] [ebp-8h]
  _DWORD *v16; // [esp+18h] [ebp-4h]

  v16 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v16[1046] )
  {
    v8 = 0;
    do
    {
      v15 = *(float *)(v5 + 4 * (v7 & 3));
      v12 = *(float *)(v8 + a4) * 15.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v8 + a4 + 4) * 15.0 + v15;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 8) * 15.0 + v15;
      v8 += 16;
      *v6++ = (int)v14 | (16 * (v11 | (16 * v9)));
      ++v7;
    }
    while ( v7 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018035 @ 0x10018035
// [binja] int16_t __thiscall sub_10018035(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018035(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  int v9; // ebx
  int v11; // [esp+0h] [ebp-24h]
  int v12; // [esp+4h] [ebp-20h]
  float v13; // [esp+18h] [ebp-Ch]
  float v14; // [esp+18h] [ebp-Ch]
  float v15; // [esp+18h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-Ch]
  float v17; // [esp+1Ch] [ebp-8h]
  _DWORD *v18; // [esp+20h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v18[1046] )
  {
    v8 = 0;
    do
    {
      v17 = *(float *)(v5 + 4 * (v7 & 3));
      v13 = *(float *)(v8 + a4) * 1023.0 + v17;
      v11 = (int)v13;
      v14 = *(float *)(v8 + a4 + 4) * 1023.0 + v17;
      v12 = (int)v14;
      v15 = *(float *)(v8 + a4 + 8) * 1023.0 + v17;
      v9 = (int)v15;
      v16 = *(float *)(v8 + a4 + 12) * 3.0 + v17;
      v8 += 16;
      *v6++ = v11 | ((v12 | ((v9 | ((int)v16 << 10)) << 10)) << 10);
      ++v7;
    }
    while ( v7 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018158 @ 0x10018158
// [binja] int16_t __thiscall sub_10018158(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018158(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // edi
  int v5; // eax
  int v6; // esi
  int *v7; // edx
  int v8; // ecx
  float v10; // [esp+10h] [ebp-10h]
  float v11; // [esp+18h] [ebp-8h]
  _DWORD *v12; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v12 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v12;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v12[1046] )
  {
    v8 = 0;
    do
    {
      v11 = *(float *)(v8 + a4) * 65535.0 + *(float *)(v6 + 4 * (v4 & 3));
      v10 = *(float *)(v8 + a4 + 4) * 65535.0 + *(float *)(v6 + 4 * (v4 & 3));
      *v7++ = (int)v11 | ((int)v10 << 16);
      ++v4;
      v8 += 16;
    }
    while ( v4 < v12[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018228 @ 0x10018228
// [binja] int16_t __thiscall sub_10018228(void* arg1, int32_t arg2, int32_t arg3, float* arg4)
int __thiscall sub_10018228(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // ebx
  _WORD *v6; // edx
  _DWORD *v7; // eax
  unsigned int v8; // esi
  _DWORD *v9; // ecx
  unsigned __int8 v11; // c0
  unsigned __int8 v12; // c2
  __int16 v13; // cx
  __int16 v15; // [esp+10h] [ebp-10h]
  int v16; // [esp+14h] [ebp-Ch]
  unsigned int v17; // [esp+18h] [ebp-8h]
  float v18; // [esp+18h] [ebp-8h]
  _DWORD *v19; // [esp+1Ch] [ebp-4h]

  v19 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v19;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = v19;
  v8 = 0;
  if ( v19[1046] )
  {
    v16 = 0;
    do
    {
      v15 = 0;
      v17 = 0;
      v9 = v7 + 14;
      do
      {
        if ( v11 | v12 )
          v15 = v17;
        ++v17;
        v9 += 4;
      }
      while ( v17 < 0x100 );
      v18 = *(float *)(v16 + a4 + 12) * 255.0 + *(float *)(v5 + 4 * (v8 & 3));
      v16 += 16;
      LOBYTE(v13) = 0;
      HIBYTE(v13) = (int)v18;
      *v6 = v15 | v13;
      v7 = v19;
      ++v6;
      ++v8;
    }
    while ( v8 < v19[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018340 @ 0x10018340
// [binja] void* __thiscall sub_10018340(void* arg1, void* arg2, float arg3, void* arg4)
int __thiscall sub_10018340(float *this, int a2, int a3, int a4)
{
  int result; // eax
  _BYTE *v5; // edx
  float *v6; // esi
  char v7; // bl
  float *v8; // edi
  double v9; // st6
  double v10; // st5
  double v11; // st4
  double v12; // st2
  double v13; // st3
  unsigned int v14; // [esp+10h] [ebp+8h]
  float v15; // [esp+14h] [ebp+Ch]
  unsigned int v16; // [esp+18h] [ebp+10h]

  if ( *((_DWORD *)this + 1042) )
    result = grim_convert_vertex_space(this, a4);
  else
    result = a4;
  v5 = (_BYTE *)(*((_DWORD *)this + 6) + a3 * *((_DWORD *)this + 1045) + a2 * *((_DWORD *)this + 1044));
  v14 = 0;
  if ( *((_DWORD *)this + 1046) )
  {
    v6 = (float *)(result + 8);
    do
    {
      v7 = 0;
      v15 = 3.4028235e38;
      v16 = 0;
      v8 = this + 14;
      do
      {
        v9 = *(v6 - 1) - *(v8 - 1);
        v10 = *v6 - *v8;
        v11 = v6[1] - v8[1];
        v12 = *(v6 - 2) - *(v8 - 2);
        v13 = v11 * v11 + v10 * v10 + v9 * v9 + v12 * v12;
        if ( v13 < v15 )
        {
          v7 = v16;
          v15 = v13;
        }
        ++v16;
        v8 += 4;
      }
      while ( v16 < 0x100 );
      *v5++ = v7;
      result = ++v14;
      v6 += 4;
    }
    while ( v14 < *((_DWORD *)this + 1046) );
  }
  return result;
}

// FUN_10018405 @ 0x10018405
// [binja] int16_t __thiscall sub_10018405(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018405(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // esi
  _BYTE *v7; // edx
  unsigned int i; // ecx
  float v10; // [esp+10h] [ebp-8h]
  _DWORD *v11; // [esp+14h] [ebp-4h]

  v4 = 0;
  v11 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v11;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < v11[1046]; v4 += 16 )
  {
    v10 = (*(float *)(v4 + a4 + 8) * 0.072099999
         + *(float *)(v4 + a4 + 4) * 0.71539998
         + *(float *)(v4 + a4) * 0.21250001)
        * 255.0
        + *(float *)(v6 + 4 * (i & 3));
    *v7++ = (int)v10;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_100184ca @ 0x100184CA
// [binja] int16_t __thiscall sub_100184ca(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_100184CA(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // edi
  int v5; // eax
  int v6; // ebx
  _WORD *v7; // edx
  int v8; // esi
  __int16 v9; // cx
  float v11; // [esp+10h] [ebp-10h]
  float v12; // [esp+18h] [ebp-8h]
  _DWORD *v13; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v13 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v13;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v13[1046] )
  {
    v8 = 0;
    do
    {
      v12 = (*(float *)(v8 + a4 + 8) * 0.072099999
           + *(float *)(v8 + a4 + 4) * 0.71539998
           + *(float *)(v8 + a4) * 0.21250001)
          * 255.0
          + *(float *)(v6 + 4 * (v4 & 3));
      v11 = *(float *)(v8 + a4 + 12) * 255.0 + *(float *)(v6 + 4 * (v4 & 3));
      LOBYTE(v9) = 0;
      HIBYTE(v9) = (int)v11;
      v8 += 16;
      *v7++ = (int)v12 | v9;
      ++v4;
    }
    while ( v4 < v13[1046] );
  }
  return dword_1005DB6C;
}

// FUN_100185c0 @ 0x100185C0
// [binja] int16_t __thiscall sub_100185c0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_100185C0(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // edi
  int v5; // eax
  int v6; // ebx
  _BYTE *v7; // edx
  int v8; // esi
  float v10; // [esp+10h] [ebp-10h]
  float v11; // [esp+18h] [ebp-8h]
  _DWORD *v12; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v12 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v12;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v12[1046] )
  {
    v8 = 0;
    do
    {
      v11 = (*(float *)(v8 + a4 + 8) * 0.072099999
           + *(float *)(v8 + a4 + 4) * 0.71539998
           + *(float *)(v8 + a4) * 0.21250001)
          * 15.0
          + *(float *)(v6 + 4 * (v4 & 3));
      v10 = *(float *)(v8 + a4 + 12) * 15.0 + *(float *)(v6 + 4 * (v4 & 3));
      *v7++ = (int)v11 | (16 * (int)v10);
      ++v4;
      v8 += 16;
    }
    while ( v4 < v12[1046] );
  }
  return dword_1005DB6C;
}

// FUN_100186ab @ 0x100186AB
// [binja] int16_t __thiscall sub_100186ab(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_100186AB(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // eax
  int v8; // esi
  __int16 v9; // cx
  float v11; // [esp+4h] [ebp-10h]
  float v12; // [esp+Ch] [ebp-8h]
  _DWORD *v13; // [esp+10h] [ebp-4h]

  v13 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v13;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v13[1046] )
  {
    v8 = 0;
    do
    {
      v12 = *(float *)(v8 + a4) * 128.0 + *(float *)(v5 + 4 * (v7 & 3));
      LOBYTE(v9) = (int)v12;
      v11 = *(float *)(v8 + a4 + 4) * 128.0 + *(float *)(v5 + 4 * (v7 & 3));
      v8 += 16;
      HIBYTE(v9) = (int)v11;
      *v6++ = v9;
      ++v7;
    }
    while ( v7 < v13[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018780 @ 0x10018780
// [binja] int16_t __thiscall sub_10018780(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018780(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  _WORD *v6; // edx
  int v7; // esi
  char v8; // cl
  char v9; // al
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+18h] [ebp-10h]
  float v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  float v15; // [esp+20h] [ebp-8h]
  _DWORD *v16; // [esp+24h] [ebp-4h]

  v4 = 0;
  v16 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v5;
  }
  v14 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v16[1046] )
  {
    v7 = 0;
    do
    {
      v15 = *(float *)(v14 + 4 * (v4 & 3));
      v11 = *(float *)(v7 + a4) * 16.0 + v15;
      v8 = (int)v11;
      v12 = *(float *)(v7 + a4 + 4) * 16.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v7 + a4 + 12) * 63.0 + v15;
      *v6++ = v8 & 0x1F | (32 * ((32 * (int)v13) | v9 & 0x1F));
      ++v4;
      v7 += 16;
    }
    while ( v4 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018885 @ 0x10018885
// [binja] int16_t __thiscall sub_10018885(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018885(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int *v5; // edx
  unsigned int v6; // eax
  int v7; // esi
  unsigned __int8 v8; // di
  unsigned __int16 v9; // bx
  int v11; // [esp+0h] [ebp-20h]
  float v12; // [esp+10h] [ebp-10h]
  float v13; // [esp+10h] [ebp-10h]
  float v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  float v16; // [esp+18h] [ebp-8h]
  _DWORD *v17; // [esp+1Ch] [ebp-4h]

  v17 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v17;
    a4 = v4;
  }
  v15 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v6 = 0;
  if ( v17[1046] )
  {
    v7 = 0;
    do
    {
      v16 = *(float *)(v15 + 4 * (v6 & 3));
      v12 = *(float *)(v7 + a4) * 128.0 + v16;
      v8 = (int)v12;
      v13 = *(float *)(v7 + a4 + 4) * 128.0 + v16;
      v11 = (int)v13;
      v14 = *(float *)(v7 + a4 + 12) * 255.0 + v16;
      HIBYTE(v9) = (int)v14;
      v7 += 16;
      LOBYTE(v9) = v11;
      *v5++ = v8 | (v9 << 8);
      ++v6;
    }
    while ( v6 < v17[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018990 @ 0x10018990
// [binja] int16_t __thiscall sub_10018990(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018990(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int *v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v10; // [esp+Ch] [ebp-28h]
  float v11; // [esp+20h] [ebp-14h]
  float v12; // [esp+20h] [ebp-14h]
  float v13; // [esp+20h] [ebp-14h]
  float v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h]
  float v16; // [esp+28h] [ebp-Ch]
  unsigned int v17; // [esp+2Ch] [ebp-8h]
  _DWORD *v18; // [esp+30h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v15 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v17 = 0;
  if ( v18[1046] )
  {
    v6 = 0;
    do
    {
      v16 = *(float *)(v15 + 4 * (v17 & 3));
      v11 = *(float *)(v6 + a4) * 128.0 + v16;
      v7 = (int)v11;
      v12 = *(float *)(v6 + a4 + 4) * 128.0 + v16;
      v10 = (int)v12;
      v13 = *(float *)(v6 + a4 + 8) * 128.0 + v16;
      v8 = (int)v13;
      v14 = *(float *)(v6 + a4 + 12) * 128.0 + v16;
      *v5++ = (unsigned __int8)v7 | (((unsigned __int8)v10 | ((((int)v14 << 8) | (unsigned __int8)v8) << 8)) << 8);
      ++v17;
      v6 += 16;
    }
    while ( v17 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018aca @ 0x10018ACA
// [binja] int16_t __thiscall sub_10018aca(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018ACA(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  int v6; // edi
  int *v7; // edx
  int v8; // esi
  float v10; // [esp+10h] [ebp-10h]
  float v11; // [esp+18h] [ebp-8h]
  _DWORD *v12; // [esp+1Ch] [ebp-4h]

  v4 = 0;
  v12 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v12;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v12[1046] )
  {
    v8 = 0;
    do
    {
      v11 = *(float *)(v8 + a4) * 32768.0 + *(float *)(v6 + 4 * (v4 & 3));
      v10 = *(float *)(v8 + a4 + 4) * 32768.0 + *(float *)(v6 + 4 * (v4 & 3));
      *v7++ = (unsigned __int16)(int)v11 | ((int)v10 << 16);
      ++v4;
      v8 += 16;
    }
    while ( v4 < v12[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018ba0 @ 0x10018BA0
// [binja] int16_t __thiscall sub_10018ba0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018BA0(_DWORD *this, char a2, char a3, int a4)
{
  unsigned int v4; // ebx
  int v5; // eax
  int *v6; // edx
  int v7; // ecx
  __int16 v8; // si
  __int16 v9; // ax
  float v11; // [esp+18h] [ebp-10h]
  float v12; // [esp+18h] [ebp-10h]
  float v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  float v15; // [esp+20h] [ebp-8h]
  _DWORD *v16; // [esp+24h] [ebp-4h]

  v4 = 0;
  v16 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v16;
    a4 = v5;
  }
  v14 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  if ( v16[1046] )
  {
    v7 = 0;
    do
    {
      v15 = *(float *)(v14 + 4 * (v4 & 3));
      v11 = *(float *)(v7 + a4) * 512.0 + v15;
      v8 = (int)v11;
      v12 = *(float *)(v7 + a4 + 4) * 1024.0 + v15;
      v9 = (int)v12;
      v13 = *(float *)(v7 + a4 + 8) * 1024.0 + v15;
      *v6++ = v8 & 0x3FF | ((((int)v13 << 11) | v9 & 0x7FF) << 10);
      ++v4;
      v7 += 16;
    }
    while ( v4 < v16[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018caa @ 0x10018CAA
// [binja] int16_t __thiscall sub_10018caa(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018CAA(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int *v5; // edx
  int v6; // ecx
  int v7; // edi
  int v8; // eax
  int v10; // [esp+Ch] [ebp-28h]
  float v11; // [esp+20h] [ebp-14h]
  float v12; // [esp+20h] [ebp-14h]
  float v13; // [esp+20h] [ebp-14h]
  float v14; // [esp+20h] [ebp-14h]
  int v15; // [esp+24h] [ebp-10h]
  float v16; // [esp+28h] [ebp-Ch]
  unsigned int v17; // [esp+2Ch] [ebp-8h]
  _DWORD *v18; // [esp+30h] [ebp-4h]

  v18 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v18;
    a4 = v4;
  }
  v15 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v17 = 0;
  if ( v18[1046] )
  {
    v6 = 0;
    do
    {
      v16 = *(float *)(v15 + 4 * (v17 & 3));
      v11 = *(float *)(v6 + a4) * 512.0 + v16;
      v7 = (int)v11;
      v12 = *(float *)(v6 + a4 + 4) * 512.0 + v16;
      v10 = (int)v12;
      v13 = *(float *)(v6 + a4 + 8) * 512.0 + v16;
      v8 = (int)v13;
      v14 = *(float *)(v6 + a4 + 12) + *(float *)(v6 + a4 + 12) + v16;
      *v5++ = v7 & 0x3FF | ((v10 & 0x3FF | ((((int)v14 << 10) | v8 & 0x3FF) << 10)) << 10);
      ++v17;
      v6 += 16;
    }
    while ( v17 < v18[1046] );
  }
  return dword_1005DB6C;
}

// FUN_10018de0 @ 0x10018DE0
// [binja] int16_t __thiscall sub_10018de0(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018DE0(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // esi
  _WORD *v7; // edx
  unsigned int i; // ecx
  float v10; // [esp+10h] [ebp-8h]
  _DWORD *v11; // [esp+14h] [ebp-4h]

  v4 = 0;
  v11 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v11;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < v11[1046]; v4 += 16 )
  {
    v10 = (*(float *)(v4 + a4 + 8) * 0.072099999
         + *(float *)(v4 + a4 + 4) * 0.71539998
         + *(float *)(v4 + a4) * 0.21250001)
        * 65535.0
        + *(float *)(v6 + 4 * (i & 3));
    *v7++ = (int)v10;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10018ea7 @ 0x10018EA7
// [binja] int16_t __thiscall sub_10018ea7(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018EA7(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // edi
  int v5; // eax
  int v6; // esi
  _WORD *v7; // edx
  unsigned int i; // ecx
  float v10; // [esp+10h] [ebp-8h]
  _DWORD *v11; // [esp+14h] [ebp-4h]

  v4 = 0;
  v11 = this;
  if ( *(this + 1042) )
  {
    v5 = grim_convert_vertex_space(this, a4);
    this = v11;
    a4 = v5;
  }
  v6 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  for ( i = 0; i < v11[1046]; v4 += 16 )
  {
    v10 = (*(float *)(v4 + a4 + 8) * 0.072099999
         + *(float *)(v4 + a4 + 4) * 0.71539998
         + *(float *)(v4 + a4) * 0.21250001)
        * 65535.0
        + *(float *)(v6 + 4 * (i & 3));
    *v7++ = (int)v10;
    ++i;
  }
  return dword_1005DB6C;
}

// FUN_10018f6e @ 0x10018F6E
// [binja] int16_t __thiscall sub_10018f6e(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_10018F6E(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  int *v6; // edx
  unsigned int v7; // esi
  int v8; // ecx
  float v10; // [esp+4h] [ebp-10h]
  float v11; // [esp+Ch] [ebp-8h]
  _DWORD *v12; // [esp+10h] [ebp-4h]

  v12 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v12;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v12[1046] )
  {
    v8 = 0;
    do
    {
      v11 = (*(float *)(v8 + a4 + 8) * 0.072099999
           + *(float *)(v8 + a4 + 4) * 0.71539998
           + *(float *)(v8 + a4) * 0.21250001)
          * 65535.0
          + *(float *)(v5 + 4 * (v7 & 3));
      v10 = *(float *)(v8 + a4 + 12) * 65535.0 + *(float *)(v5 + 4 * (v7 & 3));
      *v6++ = (int)v11 | ((int)v10 << 16);
      ++v7;
      v8 += 16;
    }
    while ( v7 < v12[1046] );
  }
  return dword_1005DB6C;
}

// FUN_1001905c @ 0x1001905C
// [binja] int16_t __thiscall sub_1001905c(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_1001905C(_DWORD *this, char a2, char a3, int a4)
{
  int v4; // eax
  int v5; // edi
  _WORD *v6; // edx
  unsigned int v7; // esi
  int v8; // eax
  float v10; // [esp+Ch] [ebp-Ch]
  float v11; // [esp+Ch] [ebp-Ch]
  float v12; // [esp+Ch] [ebp-Ch]
  float v13; // [esp+10h] [ebp-8h]
  _DWORD *v14; // [esp+14h] [ebp-4h]

  v14 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v14;
    a4 = v4;
  }
  v5 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v7 = 0;
  if ( v14[1046] )
  {
    v8 = 0;
    do
    {
      v13 = *(float *)(v5 + 4 * (v7 & 3));
      v10 = *(float *)(v8 + a4 + 8) * 65535.0 + v13;
      *v6 = (int)v10;
      v11 = *(float *)(v8 + a4 + 4) * 65535.0 + v13;
      v6[1] = (int)v11;
      v12 = *(float *)(v8 + a4) * 65535.0 + v13;
      v6[2] = (int)v12;
      v6 += 3;
      ++v7;
      v8 += 16;
    }
    while ( v7 < v14[1046] );
  }
  return dword_1005DB6C;
}

// FUN_1001914b @ 0x1001914B
// [binja] int16_t __thiscall sub_1001914b(void* arg1, int32_t arg2, int32_t arg3, void* arg4)
int __thiscall sub_1001914B(_DWORD *this, int a2, int a3, int a4)
{
  int v4; // eax
  _QWORD *v5; // esi
  int v6; // ecx
  int v7; // edi
  unsigned __int64 v8; // rt0
  int v10; // [esp+Ch] [ebp-2Ch]
  int v11; // [esp+10h] [ebp-28h]
  float v12; // [esp+24h] [ebp-14h]
  float v13; // [esp+24h] [ebp-14h]
  float v14; // [esp+24h] [ebp-14h]
  float v15; // [esp+24h] [ebp-14h]
  int v16; // [esp+28h] [ebp-10h]
  float v17; // [esp+2Ch] [ebp-Ch]
  unsigned int v18; // [esp+30h] [ebp-8h]
  _DWORD *v19; // [esp+34h] [ebp-4h]

  v19 = this;
  if ( *(this + 1042) )
  {
    v4 = grim_convert_vertex_space(this, a4);
    this = v19;
    a4 = v4;
  }
  v5 = (_QWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  v16 = *(this + 11) + 4 * ((a3 & 3) + 8 * (a2 & 3));
  fpu_set_round_trunc();
  v18 = 0;
  if ( v19[1046] )
  {
    v6 = 0;
    do
    {
      v17 = *(float *)(v16 + 4 * (v18 & 3));
      v12 = *(float *)(v6 + a4) * 65535.0 + v17;
      v7 = (int)v12;
      v13 = *(float *)(v6 + a4 + 4) * 65535.0 + v17;
      v11 = (int)v13;
      v14 = *(float *)(v6 + a4 + 8) * 65535.0 + v17;
      v10 = (int)v14;
      v15 = *(float *)(v6 + a4 + 12) * 65535.0 + v17;
      v8 = v11 | ((v7 | (unsigned __int64)((__int64)(int)v15 << 16)) << 16);
      *v5++ = __PAIR64__((v10 >> 31) | (unsigned int)(v8 >> 16), (unsigned int)v10 | ((_DWORD)v8 << 16));
      ++v18;
      v6 += 16;
    }
    while ( v18 < v19[1046] );
  }
  return dword_1005DB6C;
}

// FUN_100192a7 @ 0x100192A7
// [binja] void* __thiscall sub_100192a7(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_100192A7(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1049)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)v4[2] * 0.0039215689;
    a4 += 4;
    *(a4 - 3) = (double)v4[1] * 0.0039215689;
    v7 = *v4;
    v4 += 3;
    *(a4 - 2) = (double)v7 * 0.0039215689;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019333 @ 0x10019333
// [binja] int32_t* __thiscall sub_10019333(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019333(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned int v4; // eax
  unsigned int i; // esi
  double v7; // st6

  v4 = *(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044);
  for ( i = v4 + 4 * *(this + 1046); v4 < i; *(a4 - 1) = (double)*(unsigned __int8 *)(v4 - 1) * 0.0039215689 )
  {
    *a4 = (double)*(unsigned __int8 *)(v4 + 2) * 0.0039215689;
    a4[1] = (double)*(unsigned __int8 *)(v4 + 1) * 0.0039215689;
    v7 = (double)(unsigned __int8)*(_DWORD *)v4;
    v4 += 4;
    a4 += 4;
    *(a4 - 2) = v7 * 0.0039215689;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_100193d9 @ 0x100193D9
// [binja] void* __thiscall sub_100193d9(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_100193D9(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned int v4; // eax
  unsigned int i; // esi
  double v7; // st6

  v4 = *(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044);
  for ( i = v4 + 4 * *(this + 1046); v4 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)*(unsigned __int8 *)(v4 + 2) * 0.0039215689;
    a4[1] = (double)*(unsigned __int8 *)(v4 + 1) * 0.0039215689;
    v7 = (double)(unsigned __int8)*(_DWORD *)v4;
    v4 += 4;
    a4 += 4;
    *(a4 - 2) = v7 * 0.0039215689;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019475 @ 0x10019475
// [binja] int16_t* __thiscall sub_10019475(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019475(_DWORD *this, int a2, int a3, float *a4)
{
  _WORD *v5; // eax
  _WORD *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_WORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[*(this + 1046)]; v5 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)(*v5 >> 11) * 0.032258064;
    a4 += 4;
    *(a4 - 3) = (double)(((unsigned __int16)*v5 >> 5) & 0x3F) * 0.015873017;
    v7 = *(_BYTE *)v5++ & 0x1F;
    *(a4 - 2) = (double)v7 * 0.032258064;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001951a @ 0x1001951A
// [binja] int16_t* __thiscall sub_1001951a(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001951A(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)((*(unsigned __int16 *)v5 >> 10) & 0x1F) * 0.032258064;
    a4 += 4;
    *(a4 - 3) = (double)((*(unsigned __int16 *)v5 >> 5) & 0x1F) * 0.032258064;
    v7 = *v5 & 0x1F;
    v5 += 2;
    *(a4 - 2) = (double)v7 * 0.032258064;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_100195bc @ 0x100195BC
// [binja] int16_t* __thiscall sub_100195bc(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_100195BC(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = (float)v7 )
  {
    *a4 = (double)((*(unsigned __int16 *)v5 >> 10) & 0x1F) * 0.032258064;
    a4 += 4;
    *(a4 - 3) = (double)((*(unsigned __int16 *)v5 >> 5) & 0x1F) * 0.032258064;
    *(a4 - 2) = (double)(*v5 & 0x1F) * 0.032258064;
    v7 = *(_WORD *)v5 >> 15;
    v5 += 2;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001966c @ 0x1001966C
// [binja] void* __thiscall sub_1001966c(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001966C(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = (double)v7 * 0.06666667 )
  {
    *a4 = (double)(v5[1] & 0xF) * 0.06666667;
    a4 += 4;
    *(a4 - 3) = (double)((*v5 >> 4) & 0xF) * 0.06666667;
    *(a4 - 2) = (double)(*v5 & 0xF) * 0.06666667;
    v7 = *(_WORD *)v5 >> 12;
    v5 += 2;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001971b @ 0x1001971B
// [binja] int32_t* __thiscall sub_1001971b(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001971B(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // eax
  _DWORD *i; // edi
  double v7; // st6

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = v7 * 0.33333334 )
  {
    *a4 = (double)(*v4 & 0x3FF) * 0.00097751711;
    a4[1] = (double)((*v4 >> 10) & 0x3FF) * 0.00097751711;
    a4[2] = (double)((*v4 >> 20) & 0x3FF) * 0.00097751711;
    v7 = (double)(*v4++ >> 30);
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_100197f1 @ 0x100197F1
// [binja] int32_t* __thiscall sub_100197f1(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_100197F1(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // eax
  _DWORD *i; // esi
  double v7; // st6

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v7 = (double)(unsigned __int16)*v4++;
    *a4 = v7 * 0.000015259022;
    a4 += 4;
    *(a4 - 3) = (double)*((unsigned __int16 *)v4 - 1) * 0.000015259022;
    *(a4 - 2) = 1.0;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019883 @ 0x10019883
// [binja] char* __thiscall sub_10019883(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019883(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[*(this + 1046)]; v5 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)(*v5 >> 5) * 0.14285715;
    a4 += 4;
    *(a4 - 3) = (double)((*v5 >> 2) & 7) * 0.14285715;
    v7 = *v5++ & 3;
    *(a4 - 2) = (double)v7 * 0.33333334;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019925 @ 0x10019925
// [binja] char* __thiscall sub_10019925(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019925(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = (double)v7 * 0.0039215689 )
  {
    *a4 = 0.0;
    a4 += 4;
    *(a4 - 3) = 0.0;
    *(a4 - 2) = 0.0;
    v7 = *v4++;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019997 @ 0x10019997
// [binja] char* __thiscall sub_10019997(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019997(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = (double)(unsigned __int8)*(v5 - 1) * 0.0039215689 )
  {
    *a4 = (double)((*v5 >> 5) & 7) * 0.14285715;
    a4 += 4;
    *(a4 - 3) = (double)((*v5 >> 2) & 7) * 0.14285715;
    v7 = *v5 & 3;
    v5 += 2;
    *(a4 - 2) = (double)v7 * 0.33333334;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019a49 @ 0x10019A49
// [binja] void* __thiscall sub_10019a49(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019A49(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)(v5[1] & 0xF) * 0.06666667;
    a4 += 4;
    *(a4 - 3) = (double)((*v5 >> 4) & 0xF) * 0.06666667;
    v7 = *v5 & 0xF;
    v5 += 2;
    *(a4 - 2) = (double)v7 * 0.06666667;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019ae8 @ 0x10019AE8
// [binja] char* __thiscall sub_10019ae8(void* arg1, void* arg2, int32_t arg3, uint32_t arg4)
void __thiscall sub_10019AE8(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int8 *v4; // eax
  float *v6; // edi
  float *v7; // esi
  unsigned __int8 *i; // [esp+8h] [ebp+8h]
  int v9; // [esp+10h] [ebp+10h]

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[2 * *(this + 1046)]; v4 < i; *(a4 - 1) = (double)v9 * 0.0039215689 )
  {
    v6 = a4;
    a4 += 4;
    v7 = (float *)(this + 4 * *v4 + 12);
    *v6 = *v7++;
    *++v6 = *v7++;
    *++v6 = *v7;
    v6[1] = v7[1];
    v9 = v4[1];
    v4 += 2;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// sub_10019B6F @ 0x10019B6F
void __thiscall sub_10019B6F(_DWORD *this, int a2, int a3, _DWORD *a4)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *i; // edx
  _DWORD *v7; // esi
  _DWORD *v8; // edi

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *v8 = v7[1] )
  {
    v7 = this + 4 * *v4 + 12;
    *a4 = *v7++;
    a4[1] = *v7++;
    a4[2] = *v7;
    v8 = a4 + 3;
    ++v4;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019bd3 @ 0x10019BD3
// [binja] char* __thiscall sub_10019bd3(void* arg1, int32_t arg2, int32_t arg3, uint32_t arg4)
void __thiscall sub_10019BD3(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int8 *v4; // eax
  unsigned __int8 *i; // esi
  double v7; // st7
  int v8; // [esp+14h] [ebp+10h]

  v4 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v8 = *v4++;
    v7 = (double)v8 * 0.0039215689;
    a4[2] = v7;
    a4[1] = v7;
    *a4 = v7;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019c41 @ 0x10019C41
// [binja] char* __thiscall sub_10019c41(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019C41(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int8 *v5; // eax
  unsigned __int8 *i; // edi
  double v7; // st6
  int v8; // [esp+18h] [ebp+10h]

  v5 = (unsigned __int8 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = (double)*(v5 - 1) * 0.0039215689 )
  {
    v8 = *v5;
    v5 += 2;
    v7 = (double)v8 * 0.0039215689;
    a4[2] = v7;
    a4[1] = v7;
    *a4 = v7;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019cca @ 0x10019CCA
// [binja] char* __thiscall sub_10019cca(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019CCA(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  double v7; // st6
  int v8; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[*(this + 1046)]; v5 < i; *(a4 - 1) = (double)v8 * 0.06666667 )
  {
    v7 = (double)(*v5 & 0xF) * 0.06666667;
    a4[2] = v7;
    a4[1] = v7;
    *a4 = v7;
    v8 = *v5++ >> 4;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019d53 @ 0x10019D53
// [binja] char* __thiscall sub_10019d53(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019D53(_DWORD *this, int a2, int a3, float *a4)
{
  char *v4; // eax
  char *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (char *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[2 * *(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v7 = *v4;
    v4 += 2;
    *a4 = (double)v7 * 0.0078125;
    a4 += 4;
    *(a4 - 3) = (double)*(v4 - 1) * 0.0078125;
    *(a4 - 2) = 0.0;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019dd5 @ 0x10019DD5
// [binja] char* __thiscall sub_10019dd5(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019DD5(_DWORD *this, int a2, int a3, float *a4)
{
  _BYTE *v5; // eax
  _BYTE *i; // edi
  int v7; // [esp+18h] [ebp+10h]
  int v8; // [esp+18h] [ebp+10h]

  v5 = (_BYTE *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v5[2 * *(this + 1046)]; v5 < i; *(a4 - 1) = (double)v8 * 0.015873017 )
  {
    v7 = (char)(8 * (*(unsigned __int16 *)v5 >> 5)) >> 3;
    *a4 = (double)((char)(8 * *v5) >> 3) * 0.0625;
    a4 += 4;
    *(a4 - 3) = (double)v7 * 0.0625;
    *(a4 - 2) = 0.0;
    v8 = *(_WORD *)v5 >> 10;
    v5 += 2;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019e86 @ 0x10019E86
// [binja] char* __thiscall sub_10019e86(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019E86(_DWORD *this, int a2, int a3, float *a4)
{
  char *v4; // eax
  char *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (char *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[4 * *(this + 1046)]; v4 < i; *(a4 - 1) = (double)(unsigned __int8)*(v4 - 2) * 0.0039215689 )
  {
    v7 = *v4;
    v4 += 4;
    *a4 = (double)v7 * 0.0078125;
    a4 += 4;
    *(a4 - 3) = (double)*(v4 - 3) * 0.0078125;
    *(a4 - 2) = 0.0;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019f17 @ 0x10019F17
// [binja] char* __thiscall sub_10019f17(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019F17(_DWORD *this, int a2, int a3, float *a4)
{
  char *v4; // eax
  char *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (char *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[4 * *(this + 1046)]; v4 < i; *(a4 - 1) = (double)*(v4 - 1) * 0.0078125 )
  {
    v7 = *v4;
    v4 += 4;
    *a4 = (double)v7 * 0.0078125;
    a4 += 4;
    *(a4 - 3) = (double)*(v4 - 3) * 0.0078125;
    *(a4 - 2) = (double)*(v4 - 2) * 0.0078125;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_10019fae @ 0x10019FAE
// [binja] int16_t* __thiscall sub_10019fae(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_10019FAE(_DWORD *this, int a2, int a3, float *a4)
{
  __int16 *v4; // eax
  __int16 *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (__int16 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[2 * *(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v7 = *v4;
    v4 += 2;
    *a4 = (double)v7 * 0.000030517578;
    a4 += 4;
    *(a4 - 3) = (double)*(v4 - 1) * 0.000030517578;
    *(a4 - 2) = 0.0;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a031 @ 0x1001A031
// [binja] int32_t* __thiscall sub_1001a031(void* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001A031(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // eax
  _DWORD *i; // ebx
  __int16 v7; // si
  double v8; // st6
  int v9; // [esp+14h] [ebp+10h]

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v7 = (__int16)(32 * (*v4 >> 21)) >> 5;
    v8 = (double)((__int16)(*(_WORD *)v4 << 6) >> 6);
    v9 = (__int16)(32 * (*v4++ >> 10)) >> 5;
    *a4 = v8 * 0.001953125;
    a4 += 4;
    *(a4 - 3) = (double)v9 * 0.0009765625;
    *(a4 - 2) = (double)v7 * 0.0009765625;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a0eb @ 0x1001A0EB
// [binja] int32_t* __thiscall sub_1001a0eb(void* arg1, uint32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001A0EB(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // eax
  _DWORD *i; // ebx
  __int16 v7; // si
  double v8; // st6
  int v9; // [esp+14h] [ebp+10h]

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = v8 * 0.33333334 )
  {
    v7 = (__int16)(*v4 >> 20 << 6) >> 6;
    v9 = (__int16)((unsigned __int16)(*v4 >> 10) << 6) >> 6;
    *a4 = (double)((__int16)(*(_WORD *)v4 << 6) >> 6) * 0.001953125;
    a4[1] = (double)v9 * 0.001953125;
    a4[2] = (double)v7 * 0.001953125;
    v8 = (double)(*v4++ >> 30);
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a1be @ 0x1001A1BE
// [binja] int16_t* __thiscall sub_1001a1be(void* arg1, int32_t arg2, int32_t arg3, uint32_t arg4)
void __thiscall sub_1001A1BE(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int16 *v4; // eax
  unsigned __int16 *i; // esi
  double v7; // st7
  int v8; // [esp+14h] [ebp+10h]

  v4 = (unsigned __int16 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = 1.0 )
  {
    v8 = *v4++;
    v7 = (double)v8 * 0.000015259022;
    a4[2] = v7;
    a4[1] = v7;
    *a4 = v7;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a22e @ 0x1001A22E
// [binja] int32_t* __thiscall sub_1001a22e(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001A22E(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // eax
  _DWORD *i; // esi
  double v7; // st6

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[*(this + 1046)]; v4 < i; *(a4 - 1) = (double)*((unsigned __int16 *)v4 - 1) * 0.000015259022 )
  {
    v7 = (double)(unsigned __int16)*v4++ * 0.000015259022;
    a4[2] = v7;
    a4[1] = v7;
    *a4 = v7;
    a4 += 4;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a2bc @ 0x1001A2BC
// [binja] void* __thiscall sub_1001a2bc(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4)
void __thiscall sub_1001A2BC(_DWORD *this, int a2, int a3, float *a4)
{
  unsigned __int16 *v4; // eax
  unsigned __int16 *i; // esi
  int v7; // [esp+14h] [ebp+10h]

  v4 = (unsigned __int16 *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = (unsigned __int16 *)((char *)v4 + *(this + 1049)); v4 < i; *(a4 - 1) = 1.0 )
  {
    *a4 = (double)v4[2] * 0.000015259022;
    a4 += 4;
    *(a4 - 3) = (double)v4[1] * 0.000015259022;
    v7 = *v4;
    v4 += 3;
    *(a4 - 2) = (double)v7 * 0.000015259022;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// FUN_1001a348 @ 0x1001A348
// [binja] uint32_t __thiscall sub_1001a348(uint32_t arg1, uint32_t arg2, int32_t arg3, uint32_t arg4)
void __thiscall sub_1001A348(_DWORD *this, int a2, int a3, float *a4)
{
  _DWORD *v4; // esi
  _DWORD *i; // [esp+14h] [ebp+8h]
  unsigned int v7; // [esp+1Ch] [ebp+10h]

  v4 = (_DWORD *)(*(this + 6) + a3 * *(this + 1045) + a2 * *(this + 1044));
  for ( i = &v4[2 * *(this + 1046)]; v4 < i; *(a4 - 1) = (double)*((unsigned __int16 *)v4 - 1) * 0.000015259022 )
  {
    *a4 = (double)(unsigned __int16)v4[1] * 0.000015259022;
    a4[1] = (double)(unsigned __int16)HIWORD(*v4) * 0.000015259022;
    v7 = (unsigned __int16)*v4;
    v4 += 2;
    a4 += 4;
    *(a4 - 2) = (double)v7 * 0.000015259022;
  }
  if ( *(this + 4) )
    grim_apply_color_key((int)this, (unsigned int)&a4[-4 * *(this + 1046)]);
}

// grim_pixel_format_ctor_r8g8b8 @ 0x1001A428
// pixel format ctor for D3DFMT_R8G8B8
float *__thiscall sub_1001A428(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x18u, 1);
  *(_DWORD *)this = &off_1004CB6C;
  return this;
}

// grim_pixel_format_init_yuv @ 0x1001A444
// initializes packed YUV (UYVY/YUY2) cache state and allocates RGB float cache
int __thiscall sub_1001A444(int this, int a2)
{
  unsigned int v3; // ecx
  int v4; // ebx
  void *v5; // eax
  void *v6; // eax
  void *v8; // [esp+10h] [ebp-10h]

  grim_pixel_format_init((float *)this, (float *)a2, 0, 1);
  v3 = *(_DWORD *)(this + 4144) & 0xFFFFFFFE;
  v4 = ((*(_DWORD *)(this + 4152) + 1) & 0xFFFFFFFE) - v3;
  *(_DWORD *)(this + 4216) = (*(_DWORD *)(this + 4152) + 1) & 0xFFFFFFFE;
  *(_DWORD *)this = &off_1004CB7C;
  *(_DWORD *)(this + 4208) = v3;
  *(_DWORD *)(this + 4212) = 0;
  *(_DWORD *)(this + 4224) = 0;
  *(_DWORD *)(this + 4220) = 0;
  *(_DWORD *)(this + 4228) = 0;
  *(_DWORD *)(this + 4232) = v4;
  *(_DWORD *)(this + 4236) = 0;
  *(_DWORD *)(this + 4240) = 1;
  v5 = operator new(16 * v4);
  v8 = v5;
  if ( v5 )
  {
    sub_1000B393((int)v5, 16, v4, (int (__thiscall *)(int))sub_1000AE4F);
    v6 = v8;
  }
  else
  {
    v6 = 0;
  }
  *(_DWORD *)(this + 4204) = v6;
  if ( !v6 )
    *(_DWORD *)(this + 4240) = 0;
  if ( *(_DWORD *)(a2 + 4) == 1498831189 )
  {
    *(_DWORD *)(this + 4244) = 8;
    *(_DWORD *)(this + 4248) = 0;
  }
  else
  {
    *(_DWORD *)(this + 4244) = 0;
    *(_DWORD *)(this + 4248) = 8;
  }
  return this;
}

// grim_pixel_format_ctor_a8r8g8b8 @ 0x1001A53C
// pixel format ctor for D3DFMT_A8R8G8B8
float *__thiscall sub_1001A53C(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 1);
  *(_DWORD *)this = &off_1004CB8C;
  return this;
}

// grim_pixel_format_ctor_x8r8g8b8 @ 0x1001A558
// pixel format ctor for D3DFMT_X8R8G8B8
float *__thiscall sub_1001A558(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 1);
  *(_DWORD *)this = &off_1004CB9C;
  return this;
}

// grim_pixel_format_ctor_r5g6b5 @ 0x1001A579
// pixel format ctor for D3DFMT_R5G6B5
float *__thiscall sub_1001A579(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CBAC;
  return this;
}

// grim_pixel_format_flush_yuv_cache @ 0x1001A595
// flushes cached YUV<->RGB conversions back into packed 16-bit storage
int __fastcall sub_1001A595(_DWORD *a1)
{
  unsigned int v1; // edx
  float *v2; // eax
  int v3; // edx
  int v4; // esi
  int v5; // ebx
  int v6; // edi
  float v8; // [esp+4h] [ebp-28h]
  float v9; // [esp+4h] [ebp-28h]
  float v10; // [esp+Ch] [ebp-20h]
  float v11; // [esp+Ch] [ebp-20h]
  float v12; // [esp+14h] [ebp-18h]
  float v13; // [esp+14h] [ebp-18h]
  float v14; // [esp+1Ch] [ebp-10h]
  _WORD *v15; // [esp+20h] [ebp-Ch]
  unsigned int v16; // [esp+24h] [ebp-8h]
  _DWORD *v17; // [esp+28h] [ebp-4h]

  v17 = a1;
  if ( a1[1059] && a1[1060] )
  {
    v1 = a1[1052];
    v15 = (_WORD *)(a1[6] + a1[1044] * a1[1053] + a1[1045] * a1[1056] + 2 * v1);
    v2 = (float *)a1[1051];
    v16 = v1;
    if ( v1 < a1[1054] )
    {
      do
      {
        v12 = v2[4] * 65.481003 + v2[6] * 24.966 + v2[5] * 128.55299;
        v10 = v2[2] * 112.0 - v2[1] * 74.203003 - *v2 * 37.797001;
        v8 = *v2 * 112.0 - (v2[1] * 93.786003 + v2[2] * 18.214001);
        v14 = *v2 * 65.481003 + v2[1] * 128.55299 + v2[2] * 24.966 + 0.5;
        v3 = (int)v14 + 16;
        v13 = v12 + 0.5;
        v4 = (int)v13 + 16;
        v11 = v10 + 0.5;
        v5 = (int)v11 + 128;
        v9 = v8 + 0.5;
        v6 = (int)v9 + 128;
        if ( v3 >= 0 )
        {
          if ( v3 > 255 )
            v3 = 255;
        }
        else
        {
          v3 = 0;
        }
        if ( v4 >= 0 )
        {
          if ( v4 > 255 )
            LOWORD(v4) = 255;
        }
        else
        {
          LOWORD(v4) = 0;
        }
        if ( v5 >= 0 )
        {
          if ( v5 > 255 )
            v5 = 255;
        }
        else
        {
          v5 = 0;
        }
        if ( v6 >= 0 )
        {
          if ( v6 > 255 )
            LOWORD(v6) = 255;
        }
        else
        {
          LOWORD(v6) = 0;
        }
        v16 += 2;
        v2 += 8;
        *v15 = (v5 << v17[1062]) | (v3 << v17[1061]);
        v15 += 2;
        *(v15 - 1) = ((_WORD)v6 << v17[1062]) | ((_WORD)v4 << v17[1061]);
        a1 = v17;
      }
      while ( v16 < v17[1054] );
    }
    a1[1059] = 0;
  }
  return 0;
}

// grim_pixel_format_ctor_x1r5g5b5 @ 0x1001A781
// pixel format ctor for D3DFMT_X1R5G5B5
float *__thiscall sub_1001A781(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CBDC;
  return this;
}

// grim_pixel_format_ctor_a1r5g5b5 @ 0x1001A79D
// pixel format ctor for D3DFMT_A1R5G5B5
float *__thiscall sub_1001A79D(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CBEC;
  return this;
}

// grim_pixel_format_load_yuv_cache @ 0x1001A7B9
// loads packed YUV pixels into float cache and converts to RGB
int __thiscall sub_1001A7B9(int this, unsigned int a2, unsigned int a3, int a4)
{
  int result; // eax
  unsigned int v6; // eax
  float *v7; // edx
  _WORD *v8; // ebx
  unsigned __int16 v9; // ax
  double v10; // st4
  _WORD *v11; // ebx
  unsigned __int16 v12; // ax
  double v13; // st4
  double v14; // st3
  double v15; // st3
  double v16; // st2
  double v17; // st2
  double v18; // st1
  double v19; // st1
  double v20; // st2
  double v21; // st2
  double v22; // st2
  double v23; // st4
  double v24; // st4
  double v25; // st4
  float v26; // [esp+4h] [ebp-Ch]
  float v27; // [esp+8h] [ebp-8h]
  float v28; // [esp+8h] [ebp-8h]
  float v29; // [esp+Ch] [ebp-4h]
  float v30; // [esp+Ch] [ebp-4h]
  _WORD *v31; // [esp+18h] [ebp+8h]
  float v32; // [esp+18h] [ebp+8h]
  float v33; // [esp+18h] [ebp+8h]
  float v34; // [esp+18h] [ebp+8h]
  float v35; // [esp+18h] [ebp+8h]
  int v36; // [esp+1Ch] [ebp+Ch]
  float v37; // [esp+1Ch] [ebp+Ch]
  float v38; // [esp+1Ch] [ebp+Ch]
  float v39; // [esp+1Ch] [ebp+Ch]
  unsigned int i; // [esp+20h] [ebp+10h]

  if ( !*(_DWORD *)(this + 4240) )
    return -2147024882;
  if ( a2 < *(_DWORD *)(this + 4212)
    || a2 >= *(_DWORD *)(this + 4220)
    || a3 < *(_DWORD *)(this + 4224)
    || a3 >= *(_DWORD *)(this + 4228) )
  {
    result = grim_pixel_format_flush_yuv_cache((_DWORD *)this);
    if ( result < 0 )
      return result;
    *(_DWORD *)(this + 4220) = a2 + 1;
    *(_DWORD *)(this + 4212) = a2;
    *(_DWORD *)(this + 4224) = a3;
    *(_DWORD *)(this + 4228) = a3 + 1;
    if ( a4 )
    {
      v6 = *(_DWORD *)(this + 4208);
      v7 = *(float **)(this + 4204);
      v8 = (_WORD *)(*(_DWORD *)(this + 24) + a3 * *(_DWORD *)(this + 4180) + a2 * *(_DWORD *)(this + 4176) + 2 * v6);
      v31 = v8;
      for ( i = v6; i < *(_DWORD *)(this + 4216); v31 = v8 )
      {
        v9 = *v8;
        v10 = (double)(unsigned __int8)(*v8 >> *(_WORD *)(this + 4244));
        v11 = v31;
        v36 = (unsigned __int8)(v9 >> *(_WORD *)(this + 4248));
        v12 = v31[1];
        v27 = v10 - 16.0;
        v29 = (double)v36 - 128.0;
        v13 = (double)(unsigned __int8)(v12 >> *(_WORD *)(this + 4244)) - 16.0;
        v14 = (double)(unsigned __int8)(v12 >> *(_WORD *)(this + 4248)) - 128.0;
        v37 = v14;
        v15 = v14 * 0.0062589301;
        v16 = v27 * 0.0045662099;
        v32 = v16;
        v17 = v16 + v15;
        *v7 = v17;
        v28 = v29 * 0.00153632;
        v18 = v37 * 0.00318811;
        v26 = v18;
        v38 = v32 - v28 - v18;
        v7[1] = v38;
        v19 = v29 * 0.0079107098;
        v33 = v19 + v32;
        v7[2] = v33;
        v7[3] = 1.0;
        if ( v17 >= 0.0 )
        {
          if ( v17 > 1.0 )
            v17 = 1.0;
        }
        else
        {
          v17 = 0.0;
        }
        *v7 = v17;
        if ( v38 >= 0.0 )
        {
          if ( v38 <= 1.0 )
            v20 = v38;
          else
            v20 = 1.0;
        }
        else
        {
          v20 = 0.0;
        }
        v7[1] = v20;
        if ( v33 >= 0.0 )
        {
          if ( v33 <= 1.0 )
            v21 = v33;
          else
            v21 = 1.0;
        }
        else
        {
          v21 = 0.0;
        }
        v7[2] = v21;
        v34 = v13 * 0.0045662099;
        v22 = v13 * 0.0045662099 + v15;
        v23 = v22;
        v7[4] = v22;
        v39 = v34 - v28 - v26;
        v7[5] = v39;
        v30 = v19;
        v35 = v34 + v30;
        v7[6] = v35;
        v7[7] = 1.0;
        if ( v22 >= 0.0 )
        {
          if ( v22 > 1.0 )
            v23 = 1.0;
        }
        else
        {
          v23 = 0.0;
        }
        v7[4] = v23;
        if ( v39 >= 0.0 )
        {
          if ( v39 <= 1.0 )
            v24 = v39;
          else
            v24 = 1.0;
        }
        else
        {
          v24 = 0.0;
        }
        v7[5] = v24;
        if ( v35 >= 0.0 )
        {
          if ( v35 <= 1.0 )
            v25 = v35;
          else
            v25 = 1.0;
        }
        else
        {
          v25 = 0.0;
        }
        i += 2;
        v7[6] = v25;
        v8 = v11 + 2;
        v7 += 8;
      }
    }
  }
  return 0;
}

// grim_pixel_format_ctor_a4r4g4b4 @ 0x1001AA8A
// pixel format ctor for D3DFMT_A4R4G4B4
float *__thiscall sub_1001AA8A(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CC10;
  return this;
}

// grim_pixel_format_ctor_r3g3b2 @ 0x1001AAA6
// pixel format ctor for D3DFMT_R3G3B2
float *__thiscall sub_1001AAA6(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 8u, 1);
  *(_DWORD *)this = &off_1004CC20;
  return this;
}

// grim_pixel_format_ctor_a8 @ 0x1001AAC2
// pixel format ctor for D3DFMT_A8
float *__thiscall sub_1001AAC2(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 8u, 1);
  *(_DWORD *)this = &off_1004CC30;
  return this;
}

// grim_pixel_format_ctor_a8r3g3b2 @ 0x1001AADE
// pixel format ctor for D3DFMT_A8R3G3B2
float *__thiscall sub_1001AADE(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CC40;
  return this;
}

// grim_pixel_format_ctor_x4r4g4b4 @ 0x1001AAFA
// pixel format ctor for D3DFMT_X4R4G4B4
float *__thiscall sub_1001AAFA(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CC50;
  return this;
}

// grim_pixel_format_write_yuv_cache @ 0x1001AB16
// loads YUV cache for coords, copies RGBA floats into cache, marks dirty for flush
signed int __thiscall sub_1001AB16(_DWORD *this, int a2, int a3, const void *a4)
{
  signed int result; // eax

  if ( *(this + 1042) )
    a4 = (const void *)grim_convert_vertex_space(this, (int)a4);
  result = grim_pixel_format_load_yuv_cache(
             (int)this,
             *(this + 1037) + a2,
             *(this + 1040) + a3,
             *(this + 1058) != *(this + 1046));
  if ( result >= 0 )
  {
    result = 16 * *(this + 1046);
    qmemcpy((void *)(*(this + 1051) + 16 * (*(this + 1036) - *(this + 1052))), a4, result);
    *(this + 1059) = 1;
  }
  return result;
}

// grim_pixel_format_ctor_a2b10g10r10 @ 0x1001ABA3
// pixel format ctor for D3DFMT_A2B10G10R10
float *__thiscall sub_1001ABA3(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 1);
  *(_DWORD *)this = &off_1004CC60;
  return this;
}

// sub_1001ABBF @ 0x1001ABBF
void __thiscall sub_1001ABBF(_DWORD *this, int a2, int a3, void *a4)
{
  if ( grim_pixel_format_load_yuv_cache((int)this, *(this + 1037) + a2, *(this + 1040) + a3, 1) >= 0 )
  {
    qmemcpy(a4, (const void *)(*(this + 1051) + 16 * (*(this + 1036) - *(this + 1052))), 16 * *(this + 1046));
    if ( *(this + 4) )
      grim_apply_color_key((int)this, (unsigned int)a4);
  }
}

// grim_pixel_format_ctor_g16r16 @ 0x1001AC2E
// pixel format ctor for D3DFMT_G16R16
float *__thiscall sub_1001AC2E(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 1);
  *(_DWORD *)this = &off_1004CC70;
  return this;
}

// grim_pixel_format_init_dxt @ 0x1001AC4A
// initializes DXT block-compressed pixel format (DXT1..DXT5)
int __thiscall sub_1001AC4A(int this, int a2)
{
  BOOL v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // edi
  int v7; // ecx
  int v8; // ebx
  unsigned int v9; // eax
  unsigned int v10; // ecx
  int v11; // edx
  int v12; // edx

  grim_pixel_format_init((float *)this, (float *)a2, 0, 1);
  *(_DWORD *)this = &off_1004CAF8;
  if ( *(_DWORD *)(a2 + 24) == 1 )
  {
    *(_DWORD *)(this + 4216) = 0;
  }
  else if ( *(_DWORD *)(a2 + 24) == 2 )
  {
    *(_DWORD *)(this + 4216) = 1;
  }
  else
  {
    *(_DWORD *)(this + 4216) = 3;
  }
  if ( *(_DWORD *)(a2 + 28) == 1 )
  {
    *(_DWORD *)(this + 4220) = 0;
  }
  else if ( *(_DWORD *)(a2 + 28) == 2 )
  {
    *(_DWORD *)(this + 4220) = 1;
  }
  else
  {
    *(_DWORD *)(this + 4220) = 3;
  }
  v3 = *(_DWORD *)(this + 4216) != 3 || *(_DWORD *)(this + 4220) != 3;
  *(_DWORD *)(this + 4212) = v3;
  v4 = *(_DWORD *)(this + 4);
  switch ( v4 )
  {
    case 827611204:
      *(_DWORD *)(this + 4224) = 8;
      *(_DWORD *)(this + 4232) = sub_10021B96;
      *(_DWORD *)(this + 4228) = grim_dxt1_decode_color_block;
      break;
    case 844388420:
      *(_DWORD *)(this + 4224) = 16;
      *(_DWORD *)(this + 4232) = grim_dxt2_encode_block;
      *(_DWORD *)(this + 4228) = grim_dxt2_decode_block;
      break;
    case 861165636:
      *(_DWORD *)(this + 4224) = 16;
      *(_DWORD *)(this + 4232) = grim_dxt3_encode_block;
      *(_DWORD *)(this + 4228) = grim_dxt3_decode_block;
      break;
    case 877942852:
      *(_DWORD *)(this + 4224) = 16;
      *(_DWORD *)(this + 4232) = grim_dxt4_encode_block;
      *(_DWORD *)(this + 4228) = grim_dxt4_decode_block;
      break;
    case 894720068:
      *(_DWORD *)(this + 4224) = 16;
      *(_DWORD *)(this + 4232) = grim_dxt5_encode_block;
      *(_DWORD *)(this + 4228) = grim_dxt5_decode_block;
      break;
  }
  v5 = *(_DWORD *)(this + 4160);
  v6 = *(_DWORD *)(this + 4144);
  v7 = *(_DWORD *)(this + 4156);
  v8 = *(_DWORD *)(this + 4148);
  *(_DWORD *)(this + 4272) = -1;
  *(_DWORD *)(this + 4276) = -1;
  *(_DWORD *)(this + 4252) = v5;
  v9 = (*(_DWORD *)(this + 4152) + 3) & 0xFFFFFFFC;
  v6 &= 0xFFFFFFFC;
  *(_DWORD *)(this + 4244) = v9;
  v8 &= 0xFFFFFFFC;
  v10 = (v7 + 3) & 0xFFFFFFFC;
  v11 = *(_DWORD *)(this + 4164);
  *(_DWORD *)(this + 4248) = v10;
  *(_DWORD *)(this + 4260) = (v9 - v6) >> 2;
  *(_DWORD *)(this + 4256) = v11;
  v12 = v11 - *(_DWORD *)(this + 4160);
  *(_DWORD *)(this + 4236) = v6;
  *(_DWORD *)(this + 4280) = 0;
  *(_DWORD *)(this + 4284) = 0;
  *(_DWORD *)(this + 4288) = 0;
  *(_DWORD *)(this + 4240) = v8;
  *(_DWORD *)(this + 4264) = (v10 - v8) >> 2;
  *(_DWORD *)(this + 4268) = v12;
  return this;
}

// grim_pixel_format_ctor_a8p8 @ 0x1001AE3C
// pixel format ctor for D3DFMT_A8P8
float *__thiscall sub_1001AE3C(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CC80;
  return this;
}

// FUN_1001ae58 @ 0x1001AE58
// [binja] void*** __thiscall sub_1001ae58(void*** arg1, char arg2)
_DWORD *__thiscall sub_1001AE58(_DWORD *this, char a2)
{
  j_grim_vertex_space_converter_destroy(this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// grim_pixel_format_ctor_p8 @ 0x1001AE74
// pixel format ctor for D3DFMT_P8
float *__thiscall sub_1001AE74(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 8u, 1);
  *(_DWORD *)this = &off_1004CC90;
  return this;
}

// grim_pixel_format_ctor_l8 @ 0x1001AE90
// pixel format ctor for D3DFMT_L8
float *__thiscall sub_1001AE90(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 8u, 1);
  *(_DWORD *)this = &off_1004CCA0;
  return this;
}

// grim_pixel_format_ctor_a8l8 @ 0x1001AEAC
// pixel format ctor for D3DFMT_A8L8
float *__thiscall sub_1001AEAC(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CCB0;
  return this;
}

// FUN_1001aec8 @ 0x1001AEC8
// [binja] void*** __thiscall sub_1001aec8(void*** arg1, char arg2)
void *__thiscall sub_1001AEC8(void *this, char a2)
{
  FUN_10016c3c((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// grim_pixel_format_ctor_a4l4 @ 0x1001AEE4
// pixel format ctor for D3DFMT_A4L4
float *__thiscall sub_1001AEE4(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 8u, 1);
  *(_DWORD *)this = &off_1004CCC0;
  return this;
}

// FUN_1001af00 @ 0x1001AF00
// [binja] void* __fastcall sub_1001af00(void* arg1)
int __thiscall sub_1001AF00(int this)
{
  int v1; // eax
  double v2; // st7
  float v4; // [esp+0h] [ebp-Ch]
  float v5; // [esp+0h] [ebp-Ch]
  float v6; // [esp+0h] [ebp-Ch]
  float v7; // [esp+4h] [ebp-8h]

  v1 = *(_DWORD *)(this + 4);
  if ( v1 == 844388420 || v1 == 861165636 )
    v2 = 15.0;
  else
    v2 = 255.0;
  *(float *)(this + 4204) = v2;
  *(float *)(this + 4208) = 1.0 / *(float *)(this + 4204);
  v7 = *(float *)(this + 28) * 31.0 + 0.5;
  *(float *)(this + 28) = (double)(int)v7 * 0.032258064;
  v4 = *(float *)(this + 32) * 63.0 + 0.5;
  *(float *)(this + 32) = (double)(int)v4 * 0.015873017;
  v5 = *(float *)(this + 36) * 31.0 + 0.5;
  *(float *)(this + 36) = (double)(int)v5 * 0.032258064;
  v6 = *(float *)(this + 4204) * *(float *)(this + 40) + 0.5;
  *(float *)(this + 40) = (double)(int)v6 * *(float *)(this + 4208);
  return this;
}

// grim_pixel_format_ctor_v8u8 @ 0x1001B001
// pixel format ctor for D3DFMT_V8U8
float *__thiscall sub_1001B001(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 2);
  *(_DWORD *)this = &off_1004CCD0;
  return this;
}

// grim_pixel_format_ctor_l6v5u5 @ 0x1001B01D
// pixel format ctor for D3DFMT_L6V5U5
float *__thiscall sub_1001B01D(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 2);
  *(_DWORD *)this = &off_1004CCE0;
  return this;
}

// grim_pixel_format_ctor_x8l8v8u8 @ 0x1001B039
// pixel format ctor for D3DFMT_X8L8V8U8
float *__thiscall sub_1001B039(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 2);
  *(_DWORD *)this = &off_1004CCF0;
  return this;
}

// grim_pixel_format_ctor_q8w8v8u8 @ 0x1001B055
// pixel format ctor for D3DFMT_Q8W8V8U8
float *__thiscall sub_1001B055(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 3);
  *(_DWORD *)this = &off_1004CD00;
  return this;
}

// grim_pixel_format_ctor_v16u16 @ 0x1001B071
// pixel format ctor for D3DFMT_V16U16
float *__thiscall sub_1001B071(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 2);
  *(_DWORD *)this = &off_1004CD10;
  return this;
}

// grim_pixel_format_ctor_w11v11u10 @ 0x1001B08D
// pixel format ctor for D3DFMT_W11V11U10
float *__thiscall sub_1001B08D(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 2);
  *(_DWORD *)this = &off_1004CD20;
  return this;
}

// grim_pixel_format_ctor_a2w10v10u10 @ 0x1001B0A9
// pixel format ctor for D3DFMT_A2W10V10U10
float *__thiscall sub_1001B0A9(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 2);
  *(_DWORD *)this = &off_1004CD30;
  return this;
}

// grim_pixel_format_ctor_d16_lockable @ 0x1001B0C5
// pixel format ctor for D3DFMT_D16_LOCKABLE
float *__thiscall sub_1001B0C5(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CD40;
  return this;
}

// grim_pixel_format_ctor_l16 @ 0x1001B0E1
// pixel format ctor for FourCC L16 (16-bit luminance)
float *__thiscall sub_1001B0E1(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x10u, 1);
  *(_DWORD *)this = &off_1004CD50;
  return this;
}

// grim_pixel_format_read_dxt_cache @ 0x1001B0FD
// decodes DXT blocks into cache on demand and copies RGBA floats to output (color key aware)
unsigned int __thiscall sub_1001B0FD(unsigned int this, int a2, int a3, float *a4)
{
  int v4; // esi
  void *v5; // eax
  void *v6; // edi
  unsigned int result; // eax
  unsigned int v8; // edi
  int v9; // ebx
  int v10; // esi
  int v11; // ebx
  unsigned int v12; // edx
  float *v13; // esi
  unsigned int v14; // edx
  float v15; // [esp+18h] [ebp-34h]
  float v16; // [esp+1Ch] [ebp-30h]
  float v17; // [esp+20h] [ebp-2Ch]
  float v18; // [esp+38h] [ebp-14h]
  float v19; // [esp+38h] [ebp-14h]
  float v20; // [esp+38h] [ebp-14h]
  float v21; // [esp+38h] [ebp-14h]
  unsigned int v22; // [esp+3Ch] [ebp-10h]
  int v23; // [esp+54h] [ebp+8h]
  int v24; // [esp+58h] [ebp+Ch]

  v22 = this;
  v23 = *(_DWORD *)(this + 4148) + a2;
  v24 = *(_DWORD *)(this + 4160) + a3;
  if ( !*(_DWORD *)(this + 4280) )
  {
    v4 = 16 * *(_DWORD *)(this + 4260);
    v5 = operator new(*(_DWORD *)(this + 4260) << 8);
    v6 = v5;
    if ( v5 )
      sub_1000B393((int)v5, 16, v4, (int (__thiscall *)(int))sub_1000AE4F);
    else
      v6 = 0;
    result = v22;
    *(_DWORD *)(v22 + 4280) = v6;
    if ( !v6 )
      return result;
    this = v22;
  }
  if ( (v23 & 0xFFFFFFFC) != *(_DWORD *)(this + 4272) || v24 != *(_DWORD *)(this + 4276) )
  {
    *(_DWORD *)(this + 4272) = v23 & 0xFFFFFFFC;
    *(_DWORD *)(v22 + 4276) = v24;
    this = v22;
    v8 = *(_DWORD *)(v22 + 4236);
    v9 = *(_DWORD *)(v22 + 4280);
    v10 = *(_DWORD *)(v22 + 24)
        + *(_DWORD *)(v22 + 4180) * *(_DWORD *)(v22 + 4276)
        + *(_DWORD *)(v22 + 4224) * (v8 >> 2)
        + *(_DWORD *)(v22 + 4176) * (*(_DWORD *)(v22 + 4272) >> 2);
    while ( v8 < *(_DWORD *)(this + 4244) )
    {
      (*(void (__cdecl **)(int, int))(this + 4228))(v9, v10);
      this = v22;
      v10 += *(_DWORD *)(v22 + 4224);
      v9 += 256;
      v8 += 4;
    }
  }
  result = *(_DWORD *)(this + 4144) - *(_DWORD *)(this + 4236);
  v11 = (v23 - *(_DWORD *)(this + 4240)) & 3;
  v12 = result + *(_DWORD *)(this + 4184);
  while ( result < v12 )
  {
    v13 = (float *)(*(_DWORD *)(this + 4280) + 16 * (result & 3 | (4 * (v11 | result & 0xFFFFFFFC))));
    *a4 = *v13++;
    a4[1] = *v13++;
    a4[2] = *v13;
    a4[3] = v13[1];
    a4 += 4;
    this = v22;
    ++result;
  }
  if ( *(_DWORD *)(this + 16) )
  {
    fpu_set_round_trunc();
    while ( (unsigned int)a4 < v14 )
    {
      v18 = *a4 * 31.0 + 0.5;
      v15 = (double)(int)v18 * 0.032258064;
      if ( v15 == *(float *)(v22 + 28) )
      {
        v19 = a4[1] * 63.0 + 0.5;
        v16 = (double)(int)v19 * 0.015873017;
        if ( v16 == *(float *)(v22 + 32) )
        {
          v20 = a4[2] * 31.0 + 0.5;
          v17 = (double)(int)v20 * 0.032258064;
          if ( v17 == *(float *)(v22 + 36) )
          {
            v21 = *(float *)(v22 + 4204) * a4[3] + 0.5;
            if ( (double)(int)v21 * *(float *)(v22 + 4208) == *(float *)(v22 + 40) )
            {
              *a4 = 0.0;
              a4[1] = 0.0;
              a4[2] = 0.0;
              a4[3] = 0.0;
            }
          }
        }
      }
      a4 += 4;
    }
    return dword_1005DB6C;
  }
  return result;
}

// grim_pixel_format_ctor_al16 @ 0x1001B3A6
// pixel format ctor for FourCC AL16
float *__thiscall sub_1001B3A6(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x20u, 1);
  *(_DWORD *)this = &off_1004CD60;
  return this;
}

// grim_pixel_format_ctor_r16 @ 0x1001B3C2
// pixel format ctor for FourCC R16
float *__thiscall sub_1001B3C2(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x30u, 1);
  *(_DWORD *)this = &off_1004CD70;
  return this;
}

// grim_pixel_format_ctor_ar16 @ 0x1001B3DE
// pixel format ctor for FourCC AR16
float *__thiscall sub_1001B3DE(float *this, float *a2)
{
  grim_pixel_format_init(this, a2, 0x40u, 1);
  *(_DWORD *)this = &off_1004CD80;
  return this;
}

// grim_pixel_format_ctor_dxt1 @ 0x1001B3FA
// pixel format ctor for FourCC DXT1
_DWORD *__thiscall sub_1001B3FA(_DWORD *this, int a2)
{
  grim_pixel_format_init_dxt((int)this, a2);
  *this = &off_1004CD90;
  return this;
}

// grim_pixel_format_ctor_dxt2 @ 0x1001B412
// pixel format ctor for FourCC DXT2
_DWORD *__thiscall sub_1001B412(_DWORD *this, int a2)
{
  grim_pixel_format_init_dxt((int)this, a2);
  *this = &off_1004CDA0;
  return this;
}

// grim_pixel_format_ctor_dxt3 @ 0x1001B42A
// pixel format ctor for FourCC DXT3
_DWORD *__thiscall sub_1001B42A(_DWORD *this, int a2)
{
  grim_pixel_format_init_dxt((int)this, a2);
  *this = &off_1004CDB0;
  return this;
}

// grim_pixel_format_ctor_dxt4 @ 0x1001B442
// pixel format ctor for FourCC DXT4
_DWORD *__thiscall sub_1001B442(_DWORD *this, int a2)
{
  grim_pixel_format_init_dxt((int)this, a2);
  *this = &off_1004CDC0;
  return this;
}

// grim_pixel_format_ctor_dxt5 @ 0x1001B45A
// pixel format ctor for FourCC DXT5
_DWORD *__thiscall sub_1001B45A(_DWORD *this, int a2)
{
  grim_pixel_format_init_dxt((int)this, a2);
  *this = &off_1004CDD0;
  return this;
}

// FUN_1001b472 @ 0x1001B472
// [binja] void*** __thiscall sub_1001b472(void*** arg1, char arg2)
void *__thiscall sub_1001B472(void *this, char a2)
{
  j_FUN_10016c3c((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// FUN_1001b493 @ 0x1001B493
// [binja] int32_t __fastcall sub_1001b493(void*** arg1)
void __thiscall sub_1001B493(int this)
{
  *(_DWORD *)this = &off_1004CB7C;
  grim_pixel_format_flush_yuv_cache((_DWORD *)this);
  if ( *(_DWORD *)(this + 4204) )
    operator delete(*(void **)(this + 4204));
  grim_vertex_space_converter_destroy((_DWORD *)this);
}

// grim_pixel_format_ctor_uyvy @ 0x1001B4DC
// pixel format ctor for FourCC UYVY
_DWORD *__thiscall sub_1001B4DC(_DWORD *this, int a2)
{
  grim_pixel_format_init_yuv((int)this, a2);
  *this = &off_1004CDE0;
  return this;
}

// grim_pixel_format_ctor_yuy2 @ 0x1001B4F4
// pixel format ctor for FourCC YUY2
_DWORD *__thiscall sub_1001B4F4(_DWORD *this, int a2)
{
  grim_pixel_format_init_yuv((int)this, a2);
  *this = &off_1004CDF0;
  return this;
}

// grim_pixel_format_create @ 0x1001B50C
// factory: picks pixel format implementation from FourCC/D3DFORMAT
_DWORD *__cdecl sub_1001B50C(float *a1)
{
  int v1; // eax
  _DWORD *v2; // esi
  float *v3; // ecx
  _DWORD *v4; // eax
  float *v5; // ecx
  float *v6; // ecx
  float *v7; // ecx
  float *v8; // ecx
  float *v9; // ecx
  float *v10; // ecx
  float *v11; // ecx
  float *v12; // ecx
  float *v13; // ecx
  float *v14; // ecx
  float *v15; // ecx
  float *v16; // ecx
  float *v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  float *v23; // ecx
  float *v24; // ecx
  float *v25; // ecx
  float *v26; // ecx
  float *v27; // ecx
  float *v28; // ecx
  float *v29; // ecx
  int v30; // eax
  int v31; // eax
  int v32; // eax
  int v33; // eax
  float *v34; // ecx
  float *v35; // ecx
  float *v36; // ecx
  float *v37; // ecx
  float *v38; // ecx
  _DWORD *v39; // ecx
  _DWORD *v40; // ecx
  _DWORD *v41; // ecx
  _DWORD *v42; // ecx
  _DWORD *v43; // ecx
  _DWORD *v44; // ecx
  float *v45; // ecx
  int v46; // eax
  int v47; // eax
  int v48; // eax
  _DWORD *v49; // ecx
  float *v50; // ecx
  float *v51; // ecx
  float *v52; // ecx

  v1 = *((_DWORD *)a1 + 1);
  v2 = 0;
  if ( v1 > 827611204 )
  {
    if ( v1 > 909200416 )
    {
      v46 = v1 - 909200449;
      if ( v46 )
      {
        v47 = v46 - 1503;
        if ( v47 )
        {
          v48 = v47 - 33;
          if ( v48 )
          {
            if ( v48 != 589629204 )
              return v2;
            v49 = operator new(0x109Cu);
            if ( v49 )
            {
              v4 = grim_pixel_format_ctor_uyvy(v49, (int)a1);
              goto LABEL_105;
            }
          }
          else
          {
            v50 = (float *)operator new(0x106Cu);
            if ( v50 )
            {
              v4 = grim_pixel_format_ctor_ar16(v50, a1);
              goto LABEL_105;
            }
          }
        }
        else
        {
          v51 = (float *)operator new(0x106Cu);
          if ( v51 )
          {
            v4 = grim_pixel_format_ctor_r16(v51, a1);
            goto LABEL_105;
          }
        }
      }
      else
      {
        v52 = (float *)operator new(0x106Cu);
        if ( v52 )
        {
          v4 = grim_pixel_format_ctor_al16(v52, a1);
          goto LABEL_105;
        }
      }
    }
    else
    {
      switch ( v1 )
      {
        case 909200416:
          v45 = (float *)operator new(0x106Cu);
          if ( v45 )
          {
            v4 = grim_pixel_format_ctor_l16(v45, a1);
            goto LABEL_105;
          }
          break;
        case 844388420:
          v44 = operator new(0x10C4u);
          if ( v44 )
          {
            v4 = grim_pixel_format_ctor_dxt2(v44, (int)a1);
            goto LABEL_105;
          }
          break;
        case 844715353:
          v43 = operator new(0x109Cu);
          if ( v43 )
          {
            v4 = grim_pixel_format_ctor_yuy2(v43, (int)a1);
            goto LABEL_105;
          }
          break;
        case 861165636:
          v42 = operator new(0x10C4u);
          if ( v42 )
          {
            v4 = grim_pixel_format_ctor_dxt3(v42, (int)a1);
            goto LABEL_105;
          }
          break;
        case 877942852:
          v41 = operator new(0x10C4u);
          if ( v41 )
          {
            v4 = grim_pixel_format_ctor_dxt4(v41, (int)a1);
            goto LABEL_105;
          }
          break;
        case 894720068:
          v40 = operator new(0x10C4u);
          if ( v40 )
          {
            v4 = grim_pixel_format_ctor_dxt5(v40, (int)a1);
            goto LABEL_105;
          }
          break;
        default:
          return v2;
      }
    }
    goto LABEL_104;
  }
  if ( v1 == 827611204 )
  {
    v39 = operator new(0x10C4u);
    if ( v39 )
    {
      v4 = grim_pixel_format_ctor_dxt1(v39, (int)a1);
      goto LABEL_105;
    }
    goto LABEL_104;
  }
  if ( v1 > 40 )
  {
    if ( v1 > 62 )
    {
      v30 = v1 - 63;
      if ( v30 )
      {
        v31 = v30 - 1;
        if ( v31 )
        {
          v32 = v31 - 1;
          if ( v32 )
          {
            v33 = v32 - 2;
            if ( v33 )
            {
              if ( v33 != 3 )
                return v2;
              v34 = (float *)operator new(0x106Cu);
              if ( v34 )
              {
                v4 = grim_pixel_format_ctor_d16_lockable(v34, a1);
                goto LABEL_105;
              }
            }
            else
            {
              v35 = (float *)operator new(0x106Cu);
              if ( v35 )
              {
                v4 = grim_pixel_format_ctor_a2w10v10u10(v35, a1);
                goto LABEL_105;
              }
            }
          }
          else
          {
            v36 = (float *)operator new(0x106Cu);
            if ( v36 )
            {
              v4 = grim_pixel_format_ctor_w11v11u10(v36, a1);
              goto LABEL_105;
            }
          }
        }
        else
        {
          v37 = (float *)operator new(0x106Cu);
          if ( v37 )
          {
            v4 = grim_pixel_format_ctor_v16u16(v37, a1);
            goto LABEL_105;
          }
        }
      }
      else
      {
        v38 = (float *)operator new(0x106Cu);
        if ( v38 )
        {
          v4 = grim_pixel_format_ctor_q8w8v8u8(v38, a1);
          goto LABEL_105;
        }
      }
    }
    else if ( v1 == 62 )
    {
      v29 = (float *)operator new(0x106Cu);
      if ( v29 )
      {
        v4 = grim_pixel_format_ctor_x8l8v8u8(v29, a1);
        goto LABEL_105;
      }
    }
    else
    {
      v18 = v1 - 41;
      if ( v18 )
      {
        v19 = v18 - 9;
        if ( v19 )
        {
          v20 = v19 - 1;
          if ( v20 )
          {
            v21 = v20 - 1;
            if ( v21 )
            {
              v22 = v21 - 8;
              if ( v22 )
              {
                if ( v22 != 1 )
                  return v2;
                v23 = (float *)operator new(0x106Cu);
                if ( v23 )
                {
                  v4 = grim_pixel_format_ctor_l6v5u5(v23, a1);
                  goto LABEL_105;
                }
              }
              else
              {
                v24 = (float *)operator new(0x106Cu);
                if ( v24 )
                {
                  v4 = grim_pixel_format_ctor_v8u8(v24, a1);
                  goto LABEL_105;
                }
              }
            }
            else
            {
              v25 = (float *)operator new(0x106Cu);
              if ( v25 )
              {
                v4 = grim_pixel_format_ctor_a4l4(v25, a1);
                goto LABEL_105;
              }
            }
          }
          else
          {
            v26 = (float *)operator new(0x106Cu);
            if ( v26 )
            {
              v4 = grim_pixel_format_ctor_a8l8(v26, a1);
              goto LABEL_105;
            }
          }
        }
        else
        {
          v27 = (float *)operator new(0x106Cu);
          if ( v27 )
          {
            v4 = grim_pixel_format_ctor_l8(v27, a1);
            goto LABEL_105;
          }
        }
      }
      else
      {
        v28 = (float *)operator new(0x106Cu);
        if ( v28 )
        {
          v4 = grim_pixel_format_ctor_p8(v28, a1);
          goto LABEL_105;
        }
      }
    }
LABEL_104:
    v4 = 0;
    goto LABEL_105;
  }
  if ( v1 == 40 )
  {
    v17 = (float *)operator new(0x106Cu);
    if ( v17 )
    {
      v4 = grim_pixel_format_ctor_a8p8(v17, a1);
LABEL_105:
      v2 = v4;
      if ( v4 && v4[4] )
        (*(void (__thiscall **)(_DWORD *))(*v4 + 12))(v4);
      return v2;
    }
    goto LABEL_104;
  }
  switch ( v1 )
  {
    case 20:
      v3 = (float *)operator new(0x106Cu);
      if ( !v3 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_r8g8b8(v3, a1);
      goto LABEL_105;
    case 21:
      v5 = (float *)operator new(0x106Cu);
      if ( !v5 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a8r8g8b8(v5, a1);
      goto LABEL_105;
    case 22:
      v6 = (float *)operator new(0x106Cu);
      if ( !v6 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_x8r8g8b8(v6, a1);
      goto LABEL_105;
    case 23:
      v7 = (float *)operator new(0x106Cu);
      if ( !v7 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_r5g6b5(v7, a1);
      goto LABEL_105;
    case 24:
      v8 = (float *)operator new(0x106Cu);
      if ( !v8 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_x1r5g5b5(v8, a1);
      goto LABEL_105;
    case 25:
      v9 = (float *)operator new(0x106Cu);
      if ( !v9 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a1r5g5b5(v9, a1);
      goto LABEL_105;
    case 26:
      v10 = (float *)operator new(0x106Cu);
      if ( !v10 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a4r4g4b4(v10, a1);
      goto LABEL_105;
    case 27:
      v11 = (float *)operator new(0x106Cu);
      if ( !v11 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_r3g3b2(v11, a1);
      goto LABEL_105;
    case 28:
      v12 = (float *)operator new(0x106Cu);
      if ( !v12 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a8(v12, a1);
      goto LABEL_105;
    case 29:
      v13 = (float *)operator new(0x106Cu);
      if ( !v13 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a8r3g3b2(v13, a1);
      goto LABEL_105;
    case 30:
      v14 = (float *)operator new(0x106Cu);
      if ( !v14 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_x4r4g4b4(v14, a1);
      goto LABEL_105;
    case 31:
      v15 = (float *)operator new(0x106Cu);
      if ( !v15 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_a2b10g10r10(v15, a1);
      goto LABEL_105;
    case 34:
      v16 = (float *)operator new(0x106Cu);
      if ( !v16 )
        goto LABEL_104;
      v4 = grim_pixel_format_ctor_g16r16(v16, a1);
      goto LABEL_105;
    default:
      return v2;
  }
  return v2;
}

// FUN_1001bc84 @ 0x1001BC84
// [binja] void*** __thiscall sub_1001bc84(void*** arg1, char arg2)
void *__thiscall sub_1001BC84(void *this, char a2)
{
  j_FUN_1001b493((int)this);
  if ( (a2 & 1) != 0 )
    operator delete(this);
  return this;
}

// FUN_1001bca5 @ 0x1001BCA5
// [binja] int32_t* __fastcall sub_1001bca5(int32_t* arg1)
_DWORD *__thiscall sub_1001BCA5(_DWORD *this)
{
  *this = -1;
  *(this + 1) = -1;
  *(this + 2) = 0;
  *(this + 3) = 0;
  return this;
}

// FUN_1001bcb7 @ 0x1001BCB7
// [binja] int32_t __thiscall sub_1001bcb7(int32_t* arg1, int32_t* arg2, int32_t* arg3)
int __thiscall sub_1001BCB7(int this, LPCWCH lpWideCharStr, LPSTR lpMultiByteStr)
{
  void *v5; // esp
  HANDLE FileW; // eax
  HANDLE FileMappingA; // eax
  LPVOID v8; // eax
  DWORD FileSize; // eax
  CHAR v10[12]; // [esp+0h] [ebp-34h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-28h] BYREF
  int cbMultiByte; // [esp+A0h] [ebp+6Ch]

  if ( !lpWideCharStr )
    return -2005530516;
  if ( !lpMultiByteStr )
    goto LABEL_8;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwPlatformId != 2 )
  {
    cbMultiByte = WideCharToMultiByte(0, 0, lpWideCharStr, -1, 0, 0, 0, 0);
    v5 = alloca(cbMultiByte);
    WideCharToMultiByte(0, 0, lpWideCharStr, -1, v10, cbMultiByte, 0, 0);
    lpWideCharStr = (LPCWCH)v10;
    lpMultiByteStr = 0;
  }
  if ( lpMultiByteStr )
    FileW = CreateFileW(lpWideCharStr, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
  else
LABEL_8:
    FileW = CreateFileA((LPCSTR)lpWideCharStr, 0x80000000, 1u, 0, 3u, 0x10000000u, 0);
  *(_DWORD *)this = FileW;
  if ( FileW != (HANDLE)-1 )
  {
    FileMappingA = CreateFileMappingA(FileW, 0, 2u, 0, 0, 0);
    *(_DWORD *)(this + 4) = FileMappingA;
    if ( FileMappingA != (HANDLE)-1 )
    {
      v8 = MapViewOfFile(FileMappingA, 4u, 0, 0, 0);
      *(_DWORD *)(this + 8) = v8;
      if ( v8 )
      {
        FileSize = GetFileSize(*(HANDLE *)this, 0);
        *(_DWORD *)(this + 12) = FileSize;
        if ( FileSize != -1 )
          return 0;
      }
    }
  }
  GetLastError();
  return -2005529767;
}

// FUN_1001bdc7 @ 0x1001BDC7
// [binja] int32_t __thiscall sub_1001bdc7(void** arg1, int32_t arg2, int32_t* arg3)
int __thiscall sub_1001BDC7(_DWORD *this, LPCWCH lpWideCharStr, LPSTR lpMultiByteStr)
{
  const WCHAR *v3; // ebx
  _DWORD *v4; // edi
  void *v6; // esp
  HANDLE FileW; // eax
  CHAR v8[12]; // [esp+0h] [ebp-34h] BYREF
  struct _OSVERSIONINFOA VersionInformation; // [esp+Ch] [ebp-28h] BYREF
  _DWORD *v10; // [esp+A0h] [ebp+6Ch]
  LPCWCH lpWideCharStra; // [esp+ACh] [ebp+78h]

  v3 = lpWideCharStr;
  v4 = this;
  v10 = this;
  if ( !lpWideCharStr )
    return -2005530516;
  if ( !lpMultiByteStr )
    goto LABEL_8;
  VersionInformation.dwOSVersionInfoSize = 148;
  GetVersionExA(&VersionInformation);
  if ( VersionInformation.dwPlatformId != 2 )
  {
    lpWideCharStra = (LPCWCH)WideCharToMultiByte(0, 0, lpWideCharStr, -1, 0, 0, 0, 0);
    v6 = alloca((int)lpWideCharStra);
    WideCharToMultiByte(0, 0, v3, -1, v8, (int)lpWideCharStra, 0, 0);
    v3 = (const WCHAR *)v8;
    v4 = v10;
    lpMultiByteStr = 0;
  }
  if ( lpMultiByteStr )
    FileW = CreateFileW(v3, 0x40000000u, 0, 0, 2u, 0, 0);
  else
LABEL_8:
    FileW = CreateFileA((LPCSTR)v3, 0x40000000u, 0, 0, 2u, 0, 0);
  *v4 = FileW;
  if ( FileW != (HANDLE)-1 )
    return 0;
  GetLastError();
  return -2005529767;
}

// FUN_1001bed2 @ 0x1001BED2
// [binja] void __fastcall sub_1001bed2(int32_t* arg1)
void __thiscall sub_1001BED2(int this)
{
  const void *v2; // eax

  if ( *(_DWORD *)this != -1 )
  {
    v2 = *(const void **)(this + 8);
    if ( v2 )
    {
      UnmapViewOfFile(v2);
      *(_DWORD *)(this + 8) = 0;
      *(_DWORD *)(this + 12) = 0;
    }
    if ( *(_DWORD *)(this + 4) != -1 )
    {
      CloseHandle(*(HANDLE *)(this + 4));
      *(_DWORD *)(this + 4) = -1;
    }
    if ( *(_DWORD *)this != -1 )
    {
      CloseHandle(*(HANDLE *)this);
      *(_DWORD *)this = -1;
    }
  }
}

// sub_1001BEDD @ 0x1001BEDD
BOOL __cdecl sub_1001BEDD(int a1, LPCSTR lpValueName, LPBYTE lpData, DWORD cbData)
{
  LSTATUS v4; // esi
  BOOL result; // eax
  DWORD Type; // [esp+0h] [ebp-8h] BYREF
  HKEY phkResult; // [esp+4h] [ebp-4h] BYREF

  phkResult = 0;
  result = 0;
  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Direct3D", &phkResult) )
  {
    v4 = RegQueryValueExA(phkResult, lpValueName, 0, &Type, lpData, &cbData);
    RegCloseKey(phkResult);
    if ( !v4 && Type == a1 )
      return 1;
  }
  return result;
}

// FUN_1001bf39 @ 0x1001BF39
// [binja] int32_t __fastcall sub_1001bf39(int32_t arg1)
BOOL sub_1001BF39()
{
  _EAX = 1;
  __asm { cpuid }
  return (_EDX & 0x800000) != 0;
}

// sub_1001BF5E @ 0x1001BF5E
int sub_1001BF5E()
{
  BYTE Data[4]; // [esp+4h] [ebp-10h] BYREF
  DWORD Type; // [esp+8h] [ebp-Ch] BYREF
  DWORD cbData; // [esp+Ch] [ebp-8h] BYREF
  HKEY phkResult; // [esp+10h] [ebp-4h] BYREF

  if ( !RegOpenKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\Direct3D", &phkResult) )
  {
    cbData = 4;
    if ( !RegQueryValueExA(phkResult, "DisableMMX", 0, &Type, Data, &cbData) && Type == 4 && *(_DWORD *)Data )
    {
      RegCloseKey(phkResult);
      dword_10054498 = 0;
      return 0;
    }
    RegCloseKey(phkResult);
  }
  if ( dword_10054498 < 0 )
  {
    dword_10054498 = 0;
    if ( FUN_1001bf39() )
    {
      _m_empty();
      dword_10054498 = 1;
    }
  }
  return dword_10054498;
}

// FUN_1001bff7 @ 0x1001BFF7
// [binja] int32_t __fastcall sub_1001bff7(int32_t arg1)
BOOL sub_1001BFF7()
{
  int v11; // [esp+Ch] [ebp-4h]

  v11 = 0;
  _EAX = 0x80000000;
  __asm { cpuid }
  if ( _EAX >= 0x80000001 )
  {
    _EAX = -2147483647;
    __asm { cpuid }
    return _EDX < 0;
  }
  return v11;
}

// FUN_1001c02f @ 0x1001C02F
// [binja] int32_t __fastcall sub_1001c02f(int32_t arg1)
int sub_1001C02F()
{
  _DWORD v11[7]; // [esp-Ch] [ebp-48h] BYREF
  int v12; // [esp+10h] [ebp-2Ch]
  int v13; // [esp+14h] [ebp-28h]
  char v14[16]; // [esp+18h] [ebp-24h] BYREF
  int v15; // [esp+28h] [ebp-14h]
  _DWORD *v16; // [esp+2Ch] [ebp-10h]
  int v17; // [esp+38h] [ebp-4h]

  v16 = v11;
  v15 = 0;
  strcpy(v14, "GenuineIntel");
  _EAX = 0;
  __asm { cpuid }
  v12 = _EAX;
  v11[4] = _EBX;
  v11[5] = _EDX;
  v11[6] = _ECX;
  v17 = -1;
  if ( !_EAX )
    return v15;
  _EAX = 1;
  __asm { cpuid }
  v12 = _EAX;
  v13 = _EDX;
  if ( (_EDX & 0x2000000) != 0 )
    v15 |= 4u;
  if ( (v13 & 0x4000000) != 0 )
    return v15 | 8;
  return v15;
}

// sub_1001C0D4 @ 0x1001C0D4
int __cdecl sub_1001C0D4(DWORD ProcessorFeature)
{
  char v1; // bl
  struct _OSVERSIONINFOA VersionInformation; // [esp+8h] [ebp-24h] BYREF
  char v4; // [esp+9Fh] [ebp+73h]

  memset(&VersionInformation, 0, sizeof(VersionInformation));
  v1 = 0;
  v4 = 0;
  VersionInformation.dwOSVersionInfoSize = 148;
  if ( !GetVersionExA(&VersionInformation) )
  {
    v1 = 1;
    v4 = 1;
  }
  if ( VersionInformation.dwPlatformId == 1 )
  {
    if ( VersionInformation.dwMajorVersion <= 4
      && (VersionInformation.dwMajorVersion != 4
       || VersionInformation.dwMinorVersion < 0xA
       || LOWORD(VersionInformation.dwBuildNumber) < 0x55Du) )
    {
      v4 = 1;
    }
    goto LABEL_11;
  }
  if ( VersionInformation.dwPlatformId != 2 )
    return 0;
  if ( v1 )
  {
LABEL_11:
    if ( ProcessorFeature != 6 )
    {
      if ( ProcessorFeature == 7 )
        return FUN_1001bff7();
      if ( ProcessorFeature != 10 || v4 )
        return 0;
      return FUN_1001c02f() & 8;
    }
    if ( !v4 )
      return FUN_1001c02f() & 4;
    return 0;
  }
  if ( ProcessorFeature != 10 )
    return IsProcessorFeaturePresent(ProcessorFeature);
  return FUN_1001c02f() & 8;
}

// grim_select_renderer_backend @ 0x1001C188
// copies the render backend vtable and selects D3DX/alt paths based on config
int __stdcall sub_1001C188(int Data)
{
  if ( Data )
  {
    if ( dword_1005449C == 0xFFFF )
    {
      dword_1005449C = 0;
      qmemcpy(&off_10053C58, off_10053D40, 0xE4u);
      sub_10022B47(&off_10053C58);
      if ( !sub_1001BEDD(4, "DisableD3DXPSGP", (LPBYTE)&Data, 4u) )
        Data = 0;
      if ( Data != 1 )
      {
        if ( sub_1001C0D4(7u) )
        {
          sub_100224C5(&off_10053C58);
          dword_1005449C = 1;
        }
        else if ( sub_1001C0D4(0xAu) )
        {
          sub_100222E0(&off_10053C58);
          dword_1005449C = 2;
        }
        else if ( sub_1001C0D4(6u) )
        {
          sub_100221D0(&off_10053C58);
          dword_1005449C = 3;
        }
      }
    }
  }
  else
  {
    dword_1005449C = 0xFFFF;
    qmemcpy(&off_10053C58, off_10053D40, 0xE4u);
  }
  return dword_1005449C;
}

// sub_1001C265 @ 0x1001C265
int __cdecl sub_1001C265(_DWORD *a1, int a2, int a3)
{
  int v3; // edx
  int v4; // ecx
  _DWORD *v5; // eax
  int result; // eax

  a1[1] = 0;
  if ( a2 != 61 )
  {
    *(_DWORD *)(*a1 + 20) = 10;
    *(_DWORD *)(*a1 + 24) = 61;
    *(_DWORD *)(*a1 + 28) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a3 != 424 )
  {
    *(_DWORD *)(*a1 + 20) = 19;
    *(_DWORD *)(*a1 + 24) = 424;
    *(_DWORD *)(*a1 + 28) = a3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = *a1;
  memset(a1, 0, 0x1A8u);
  *a1 = v3;
  *((_BYTE *)a1 + 12) = 1;
  sub_10023AEF(a1);
  a1[2] = 0;
  a1[5] = 0;
  a1[36] = 0;
  a1[37] = 0;
  a1[38] = 0;
  a1[39] = 0;
  v4 = 4;
  v5 = a1 + 44;
  do
  {
    *(v5 - 4) = 0;
    *v5++ = 0;
    --v4;
  }
  while ( v4 );
  sub_1001DE99(a1);
  result = sub_10023139(a1);
  if ( byte_100554E8 == 2 )
  {
    result = FUN_10022c2f();
    byte_100554E8 = result;
  }
  a1[4] = 200;
  return result;
}

// sub_1001C32A @ 0x1001C32A
int __usercall sub_1001C32A@<eax>(int a1@<esi>)
{
  int *v1; // eax
  int v2; // ecx
  int v3; // edx
  int v4; // edi
  _DWORD *v5; // eax

  switch ( *(_DWORD *)(a1 + 32) )
  {
    case 1:
      *(_DWORD *)(a1 + 36) = 1;
      *(_DWORD *)(a1 + 40) = 1;
      break;
    case 3:
      if ( *(_BYTE *)(a1 + 256) )
        goto LABEL_17;
      if ( *(_BYTE *)(a1 + 262) )
      {
        if ( !*(_BYTE *)(a1 + 263) )
        {
          *(_DWORD *)(a1 + 36) = 2;
          goto LABEL_24;
        }
        if ( *(_BYTE *)(a1 + 263) != 1 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
LABEL_17:
        *(_DWORD *)(a1 + 36) = 3;
LABEL_24:
        *(_DWORD *)(a1 + 40) = 2;
        break;
      }
      v1 = *(int **)(a1 + 196);
      v2 = *v1;
      v3 = v1[21];
      v4 = v1[42];
      if ( *v1 == 1 )
      {
        if ( v3 == 2 && v4 == 3 )
          goto LABEL_23;
      }
      else if ( v2 == 82 && v3 == 71 && v4 == 66 )
      {
        *(_DWORD *)(a1 + 36) = 2;
        goto LABEL_24;
      }
      v5 = (_DWORD *)(*(_DWORD *)a1 + 24);
      *v5 = v2;
      v5[1] = v3;
      v5[2] = v4;
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 107;
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
LABEL_23:
      *(_DWORD *)(a1 + 36) = 3;
      goto LABEL_24;
    case 4:
      if ( *(_BYTE *)(a1 + 262) && *(_BYTE *)(a1 + 263) )
      {
        if ( *(_BYTE *)(a1 + 263) != 2 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 110;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = *(unsigned __int8 *)(a1 + 263);
          (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, -1);
        }
        *(_DWORD *)(a1 + 36) = 5;
      }
      else
      {
        *(_DWORD *)(a1 + 36) = 4;
      }
      *(_DWORD *)(a1 + 40) = 4;
      break;
    default:
      *(_DWORD *)(a1 + 36) = 0;
      *(_DWORD *)(a1 + 40) = 0;
      break;
  }
  *(_BYTE *)(a1 + 64) = 0;
  *(_BYTE *)(a1 + 65) = 0;
  *(double *)(a1 + 56) = 1.0;
  *(_DWORD *)(a1 + 68) = 0;
  *(_BYTE *)(a1 + 74) = 0;
  *(_DWORD *)(a1 + 116) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 89) = 0;
  *(_BYTE *)(a1 + 90) = 0;
  *(_DWORD *)(a1 + 44) = 1;
  *(_DWORD *)(a1 + 48) = 1;
  *(_BYTE *)(a1 + 72) = 1;
  *(_BYTE *)(a1 + 73) = 1;
  *(_DWORD *)(a1 + 76) = 2;
  *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 84) = 256;
  return 1;
}

// sub_1001C49D @ 0x1001C49D
int __cdecl sub_1001C49D(_DWORD *a1)
{
  int v1; // eax
  int v2; // edi

  v1 = a1[4];
  v2 = 0;
  switch ( v1 )
  {
    case 200:
      (*(void (__cdecl **)(_DWORD *))(a1[99] + 4))(a1);
      (*(void (__cdecl **)(_DWORD *))(a1[5] + 8))(a1);
      a1[4] = 201;
      break;
    case 201:
      break;
    case 202:
      return 1;
    default:
      if ( v1 > 202 && (v1 <= 208 || v1 == 210) )
        return (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
      *(_DWORD *)(*a1 + 20) = 18;
      *(_DWORD *)(*a1 + 24) = a1[4];
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      return v2;
  }
  v2 = (*(int (__cdecl **)(_DWORD *))a1[99])(a1);
  if ( v2 == 1 )
  {
    sub_1001C32A((int)a1);
    a1[4] = 202;
  }
  return v2;
}

// sub_1001C537 @ 0x1001C537
char __cdecl sub_1001C537(int a1)
{
  int v1; // eax

  v1 = *(_DWORD *)(a1 + 16);
  if ( (v1 == 205 || v1 == 206) && !*(_BYTE *)(a1 + 64) )
  {
    if ( *(_DWORD *)(a1 + 120) < *(_DWORD *)(a1 + 96) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 66;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 == 207 )
  {
    *(_DWORD *)(a1 + 16) = 210;
  }
  else if ( v1 != 210 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  do
  {
    if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 17) )
    {
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 20) + 24))(a1);
      sub_10023BA3(a1);
      return 1;
    }
  }
  while ( (**(int (__cdecl ***)(int))(a1 + 396))(a1) );
  return 0;
}

// sub_1001C5DE @ 0x1001C5DE
int __cdecl sub_1001C5DE(_DWORD *a1, char a2)
{
  int v2; // eax
  int result; // eax

  v2 = a1[4];
  if ( v2 != 200 && v2 != 201 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*a1 + 24) = a1[4];
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1001C49D(a1);
  if ( result == 1 )
    return 1;
  if ( result == 2 )
  {
    if ( a2 )
    {
      *(_DWORD *)(*a1 + 20) = 50;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    sub_10023BA3(a1);
    return 2;
  }
  return result;
}

// sub_1001C641 @ 0x1001C641
char __usercall sub_1001C641@<al>(int a1@<esi>)
{
  unsigned int *v1; // edi
  unsigned int v2; // eax
  int v3; // ecx
  unsigned int v4; // ebp

  if ( *(_DWORD *)(a1 + 16) != 204 )
  {
    (**(void (__cdecl ***)(int))(a1 + 380))(a1);
    *(_DWORD *)(a1 + 120) = 0;
    *(_DWORD *)(a1 + 16) = 204;
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
  {
    v1 = (unsigned int *)(a1 + 120);
    while ( 1 )
    {
      v2 = *v1;
      if ( *v1 < *(_DWORD *)(a1 + 96) )
        break;
LABEL_10:
      (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 380) + 4))(a1);
      (**(void (__cdecl ***)(int))(a1 + 380))(a1);
      *v1 = 0;
      if ( !*(_BYTE *)(*(_DWORD *)(a1 + 380) + 8) )
        goto LABEL_11;
    }
    while ( 1 )
    {
      v3 = *(_DWORD *)(a1 + 8);
      if ( v3 )
      {
        *(_DWORD *)(v3 + 4) = v2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = *(_DWORD *)(a1 + 96);
        (**(void (__cdecl ***)(int))(a1 + 8))(a1);
      }
      v4 = *v1;
      (*(void (__cdecl **)(int, _DWORD, int, _DWORD))(*(_DWORD *)(a1 + 384) + 4))(a1, 0, a1 + 120, 0);
      v2 = *v1;
      if ( *v1 == v4 )
        return 0;
      if ( v2 >= *(_DWORD *)(a1 + 96) )
        goto LABEL_10;
    }
  }
  else
  {
LABEL_11:
    *(_DWORD *)(a1 + 16) = (*(_BYTE *)(a1 + 65) != 0) + 205;
    return 1;
  }
}

// sub_1001C6EA @ 0x1001C6EA
_DWORD *__cdecl sub_1001C6EA(_DWORD *a1, int a2, int a3)
{
  _DWORD *v3; // esi
  unsigned int v4; // ecx
  _DWORD *result; // eax
  int v6; // eax
  int v7; // eax

  v3 = a1;
  if ( a1[4] != 205 )
  {
    *(_DWORD *)(*a1 + 20) = 18;
    *(_DWORD *)(*v3 + 24) = v3[4];
    (*(void (__cdecl **)(_DWORD *))*v3)(v3);
  }
  v4 = v3[30];
  if ( v4 < v3[24] )
  {
    v6 = v3[2];
    if ( v6 )
    {
      *(_DWORD *)(v6 + 4) = v4;
      *(_DWORD *)(v3[2] + 8) = v3[24];
      (*(void (__cdecl **)(_DWORD *))v3[2])(v3);
    }
    v7 = v3[96];
    a1 = 0;
    (*(void (__cdecl **)(_DWORD *, int, _DWORD **, int))(v7 + 4))(v3, a2, &a1, a3);
    result = a1;
    v3[30] += a1;
  }
  else
  {
    *(_DWORD *)(*v3 + 20) = 119;
    (*(void (__cdecl **)(_DWORD *, int))(*v3 + 4))(v3, -1);
    return 0;
  }
  return result;
}

// sub_1001C76E @ 0x1001C76E
char __cdecl sub_1001C76E(int a1)
{
  int v2; // eax
  void (__cdecl **v3)(int); // eax
  int v4; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // ecx

  if ( *(_DWORD *)(a1 + 16) == 202 )
  {
    sub_100241E2(a1);
    if ( *(_BYTE *)(a1 + 64) )
    {
      *(_DWORD *)(a1 + 16) = 207;
      return 1;
    }
    *(_DWORD *)(a1 + 16) = 203;
  }
  v2 = *(_DWORD *)(a1 + 16);
  if ( v2 != 203 )
  {
    if ( v2 != 204 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    return sub_1001C641(a1);
  }
  if ( !*(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) )
  {
LABEL_17:
    *(_DWORD *)(a1 + 132) = *(_DWORD *)(a1 + 124);
    return sub_1001C641(a1);
  }
  while ( 1 )
  {
    v3 = *(void (__cdecl ***)(int))(a1 + 8);
    if ( v3 )
      (*v3)(a1);
    v4 = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
    if ( !v4 )
      return 0;
    if ( v4 == 2 )
      goto LABEL_17;
    v5 = *(_DWORD *)(a1 + 8);
    if ( v5 && (v4 == 3 || v4 == 1) )
    {
      ++*(_DWORD *)(v5 + 4);
      v6 = *(_DWORD *)(a1 + 8);
      v7 = *(_DWORD *)(v6 + 8);
      if ( *(_DWORD *)(v6 + 4) >= v7 )
        *(_DWORD *)(v6 + 8) = v7 + *(_DWORD *)(a1 + 280);
    }
  }
}

// sub_1001C82F @ 0x1001C82F
char __usercall sub_1001C82F@<al>(int a1@<esi>)
{
  _BYTE *v1; // eax
  int v2; // ecx
  int v3; // eax

  *(_DWORD *)(*(_DWORD *)a1 + 20) = 101;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 80) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 60;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = (_BYTE *)(a1 + 218);
  v2 = 16;
  do
  {
    *(v1 - 16) = 0;
    *v1 = 1;
    v1[16] = 5;
    ++v1;
    --v2;
  }
  while ( v2 );
  v3 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 252) = 0;
  *(_DWORD *)(a1 + 36) = 0;
  *(_BYTE *)(a1 + 264) = 0;
  *(_BYTE *)(a1 + 256) = 0;
  *(_BYTE *)(a1 + 257) = 0;
  *(_BYTE *)(a1 + 262) = 0;
  *(_BYTE *)(a1 + 263) = 0;
  *(_WORD *)(a1 + 258) = 1;
  *(_WORD *)(a1 + 260) = 1;
  *(_BYTE *)(v3 + 80) = 1;
  return 1;
}

// sub_1001C8BD @ 0x1001C8BD
char __usercall sub_1001C8BD@<al>(char a1@<cl>, int a2@<esi>, char a3)
{
  unsigned __int8 **v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int16 v6; // ax
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // edi
  unsigned __int16 v11; // ax
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // edi
  unsigned __int16 v14; // ax
  unsigned __int8 *v15; // edi
  unsigned __int8 *v16; // edi
  int v17; // ecx
  _DWORD *v18; // eax
  unsigned __int8 *v19; // edi
  _DWORD *v20; // eax
  int v22; // ecx
  unsigned __int8 *v23; // edi
  int v24; // ecx
  unsigned __int8 *v25; // edi
  int v26; // edx
  _DWORD *v27; // ecx
  int v28; // [esp+8h] [ebp-8h]
  unsigned __int8 *v29; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v30; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v31; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v32; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v33; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v34; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v35; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v36; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v37; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v38; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v39; // [esp+Ch] [ebp-4h]
  int v40; // [esp+18h] [ebp+8h]
  int v41; // [esp+18h] [ebp+8h]
  int v42; // [esp+18h] [ebp+8h]
  _DWORD *v43; // [esp+18h] [ebp+8h]

  v3 = *(unsigned __int8 ***)(a2 + 20);
  v4 = v3[1];
  v5 = *v3;
  *(_BYTE *)(a2 + 200) = a1;
  v29 = v4;
  *(_BYTE *)(a2 + 201) = a3;
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v5 = *v3;
    v29 = v3[1];
  }
  v30 = v29 - 1;
  LOBYTE(v6) = 0;
  HIBYTE(v6) = *v5;
  v7 = v5 + 1;
  v40 = v6;
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v7 = *v3;
    v30 = v3[1];
  }
  v31 = v30 - 1;
  v41 = *v7 + v40;
  v8 = v7 + 1;
  if ( !v31 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v8 = *v3;
    v31 = v3[1];
  }
  v9 = *v8;
  v32 = v31 - 1;
  v10 = v8 + 1;
  *(_DWORD *)(a2 + 192) = v9;
  if ( !v32 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v10 = *v3;
    v32 = v3[1];
  }
  v33 = v32 - 1;
  LOBYTE(v11) = 0;
  HIBYTE(v11) = *v10;
  v12 = v10 + 1;
  *(_DWORD *)(a2 + 28) = v11;
  if ( !v33 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v12 = *v3;
    v33 = v3[1];
  }
  v34 = v33 - 1;
  *(_DWORD *)(a2 + 28) += *v12;
  v13 = v12 + 1;
  if ( !v34 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v13 = *v3;
    v34 = v3[1];
  }
  v35 = v34 - 1;
  LOBYTE(v14) = 0;
  HIBYTE(v14) = *v13;
  v15 = v13 + 1;
  *(_DWORD *)(a2 + 24) = v14;
  if ( !v35 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
      return 0;
    v15 = *v3;
    v35 = v3[1];
  }
  v36 = v35 - 1;
  *(_DWORD *)(a2 + 24) += *v15;
  v16 = v15 + 1;
  if ( !v36 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
    {
      v16 = *v3;
      v36 = v3[1];
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v17 = *(_DWORD *)(a2 + 376);
  v37 = v36 - 1;
  v42 = v41 - 8;
  *(_DWORD *)(a2 + 32) = *v16;
  v18 = (_DWORD *)(*(_DWORD *)a2 + 24);
  *v18 = v17;
  v18[1] = *(_DWORD *)(a2 + 24);
  v18[2] = *(_DWORD *)(a2 + 28);
  v18[3] = *(_DWORD *)(a2 + 32);
  *(_DWORD *)(*(_DWORD *)a2 + 20) = 99;
  v19 = v16 + 1;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 4))(a2, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a2 + 400) + 81) )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 57;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( !*(_DWORD *)(a2 + 28) || !*(_DWORD *)(a2 + 24) || *(int *)(a2 + 32) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 31;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( v42 != 3 * *(_DWORD *)(a2 + 32) )
  {
    *(_DWORD *)(*(_DWORD *)a2 + 20) = 9;
    (**(void (__cdecl ***)(int))a2)(a2);
  }
  if ( !*(_DWORD *)(a2 + 196) )
    *(_DWORD *)(a2 + 196) = (**(int (__cdecl ***)(int, int, int))(a2 + 4))(a2, 1, 84 * *(_DWORD *)(a2 + 32));
  v28 = 0;
  v20 = *(_DWORD **)(a2 + 196);
  v43 = v20;
  if ( *(int *)(a2 + 32) > 0 )
  {
    while ( 1 )
    {
      v20[1] = v28;
      if ( !v37 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v19 = *v3;
        v37 = v3[1];
        v20 = v43;
      }
      v22 = *v19;
      v38 = v37 - 1;
      v23 = v19 + 1;
      *v20 = v22;
      if ( !v38 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v23 = *v3;
        v38 = v3[1];
        v20 = v43;
      }
      v24 = *v23;
      v39 = v38 - 1;
      v25 = v23 + 1;
      v20[2] = (v24 >> 4) & 0xF;
      v20[3] = v24 & 0xF;
      if ( !v39 )
      {
        if ( !((unsigned __int8 (__cdecl *)(int))v3[3])(a2) )
          return 0;
        v25 = *v3;
        v39 = v3[1];
        v20 = v43;
      }
      v26 = *v20;
      v37 = v39 - 1;
      v20[4] = *v25;
      v27 = (_DWORD *)(*(_DWORD *)a2 + 24);
      *v27 = v26;
      v27[1] = v20[2];
      v27[2] = v20[3];
      v27[3] = v20[4];
      *(_DWORD *)(*(_DWORD *)a2 + 20) = 100;
      v19 = v25 + 1;
      (*(void (__cdecl **)(int, int))(*(_DWORD *)a2 + 4))(a2, 1);
      ++v28;
      v43 += 21;
      if ( v28 >= *(_DWORD *)(a2 + 32) )
        break;
      v20 = v43;
    }
  }
  *(_BYTE *)(*(_DWORD *)(a2 + 400) + 81) = 1;
  v3[1] = v37;
  *v3 = v19;
  return 1;
}

// sub_1001CBB8 @ 0x1001CBB8
char __usercall sub_1001CBB8@<al>(_DWORD *a1@<esi>)
{
  unsigned __int8 **v1; // ebx
  unsigned __int8 *v2; // edi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // edi
  unsigned __int8 *v5; // edi
  int v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  unsigned __int8 *v9; // edi
  int v10; // eax
  _DWORD *v11; // ecx
  _DWORD *v12; // eax
  int v13; // eax
  unsigned __int8 *v14; // edi
  int v15; // eax
  unsigned __int8 *v16; // edi
  int v18; // ecx
  _DWORD *v19; // eax
  int v20; // [esp+8h] [ebp-20h]
  _DWORD *v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  _DWORD *v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  int v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+20h] [ebp-8h]
  int v28; // [esp+20h] [ebp-8h]
  unsigned __int8 *v29; // [esp+24h] [ebp-4h]
  unsigned __int8 *v30; // [esp+24h] [ebp-4h]
  unsigned __int8 *v31; // [esp+24h] [ebp-4h]
  unsigned __int8 *v32; // [esp+24h] [ebp-4h]
  unsigned __int8 *v33; // [esp+24h] [ebp-4h]
  unsigned __int8 *v34; // [esp+24h] [ebp-4h]
  unsigned __int8 *v35; // [esp+24h] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v29 = v1[1];
  v2 = *v1;
  if ( !*(_BYTE *)(a1[100] + 81) )
  {
    *(_DWORD *)(*a1 + 20) = 61;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v29 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v29 = v1[1];
  }
  v30 = v29 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v26 = v3;
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v4 = *v1;
    v30 = v1[1];
  }
  v31 = v30 - 1;
  v27 = *v4 + v26;
  v5 = v4 + 1;
  if ( !v31 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v5 = *v1;
    v31 = v1[1];
  }
  v6 = *v5;
  v32 = v31 - 1;
  v7 = v5 + 1;
  v22 = v6;
  if ( v27 != 2 * v6 + 6 || v6 < 1 || v6 > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v6 = v22;
  }
  *(_DWORD *)(*a1 + 20) = 102;
  *(_DWORD *)(*a1 + 24) = v6;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v23 = 0;
  a1[72] = v22;
  if ( v22 > 0 )
  {
    v24 = a1 + 73;
    do
    {
      if ( !v32 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
          return 0;
        v7 = *v1;
        v32 = v1[1];
      }
      v8 = *v7;
      v33 = v32 - 1;
      v9 = v7 + 1;
      v25 = v8;
      if ( !v33 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
          return 0;
        v9 = *v1;
        v33 = v1[1];
      }
      v10 = *v9;
      v32 = v33 - 1;
      v28 = 0;
      v11 = (_DWORD *)a1[49];
      v7 = v9 + 1;
      v20 = v10;
      v21 = v11;
      if ( (int)a1[8] <= 0 )
      {
LABEL_27:
        *(_DWORD *)(*a1 + 20) = 5;
        *(_DWORD *)(*a1 + 24) = v25;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        v10 = v20;
        v11 = v21;
      }
      else
      {
        while ( v25 != *v11 )
        {
          ++v28;
          v11 += 21;
          v21 = v11;
          if ( v28 >= a1[8] )
            goto LABEL_27;
        }
      }
      *v24 = v11;
      v11[6] = v10 & 0xF;
      v11[5] = (v10 >> 4) & 0xF;
      v12 = (_DWORD *)(*a1 + 24);
      *v12 = v25;
      v12[1] = v11[5];
      v12[2] = v11[6];
      *(_DWORD *)(*a1 + 20) = 103;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      ++v23;
      ++v24;
    }
    while ( v23 < v22 );
  }
  if ( !v32 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v7 = *v1;
    v32 = v1[1];
  }
  v13 = *v7;
  v34 = v32 - 1;
  v14 = v7 + 1;
  a1[90] = v13;
  if ( v34 )
    goto LABEL_35;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v14 = *v1;
  v34 = v1[1];
LABEL_35:
  v15 = *v14;
  v35 = v34 - 1;
  v16 = v14 + 1;
  a1[91] = v15;
  if ( !v35 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v16 = *v1;
    v35 = v1[1];
  }
  v18 = (int)*v16 >> 4;
  a1[93] = *v16 & 0xF;
  v19 = (_DWORD *)*a1;
  a1[92] = v18 & 0xF;
  v19 += 6;
  *v19 = a1[90];
  v19[1] = a1[91];
  v19[2] = a1[92];
  v19[3] = a1[93];
  *(_DWORD *)(*a1 + 20) = 104;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *(_DWORD *)(a1[100] + 84) = 0;
  ++a1[31];
  v1[1] = v35 - 1;
  *v1 = v16 + 1;
  return 1;
}

// sub_1001CE6A @ 0x1001CE6A
char __cdecl sub_1001CE6A(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  int v8; // ecx
  bool v9; // cc
  __int16 v11; // cx
  __int16 v12; // dx
  __int16 v13; // ax
  unsigned __int16 v14; // cx
  __int16 v15; // ax
  _DWORD *v16; // eax
  int v17; // eax
  int v18; // ecx
  _BYTE v19[5]; // [esp+Ch] [ebp-18h]
  unsigned __int8 v20; // [esp+11h] [ebp-13h]
  unsigned __int8 v21; // [esp+12h] [ebp-12h]
  char v22; // [esp+13h] [ebp-11h]
  unsigned __int8 v23; // [esp+14h] [ebp-10h]
  unsigned __int8 v24; // [esp+15h] [ebp-Fh]
  unsigned __int8 v25; // [esp+16h] [ebp-Eh]
  unsigned __int8 v26; // [esp+17h] [ebp-Dh]
  __int16 v27; // [esp+18h] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-8h]
  int v29; // [esp+20h] [ebp-4h]
  unsigned __int8 *v30; // [esp+2Ch] [ebp+8h]
  unsigned __int8 *v31; // [esp+2Ch] [ebp+8h]
  unsigned __int8 *v32; // [esp+2Ch] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v30 = v2[1];
  if ( !v30 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v30 = v2[1];
  }
  v31 = v30 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v29 = v4;
  if ( v31 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v5 = *v2;
  v31 = v2[1];
LABEL_7:
  v32 = v31 - 1;
  v29 = *v5 + v29 - 2;
  v6 = v5 + 1;
  if ( v29 < 14 )
  {
    v18 = v29;
    *(_DWORD *)(*a1 + 20) = 76;
    *(_DWORD *)(*a1 + 24) = v18;
  }
  else
  {
    v28 = 0;
    do
    {
      if ( !v32 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v6 = *v2;
        v32 = v2[1];
      }
      --v32;
      v7 = *v6;
      v8 = v28;
      ++v6;
      v9 = ++v28 < 14;
      v19[v8] = v7;
    }
    while ( v9 );
    v29 -= 14;
    if ( v19[0] == 74 && v19[1] == 70 && v19[2] == 73 && v19[3] == 70 && !v19[4] )
    {
      if ( v20 == 1 )
      {
        if ( v21 > 2u )
        {
          *(_DWORD *)(*a1 + 20) = 88;
          *(_DWORD *)(*a1 + 24) = 1;
          *(_DWORD *)(*a1 + 28) = v21;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 115;
        *(_DWORD *)(*a1 + 24) = v20;
        *(_DWORD *)(*a1 + 28) = v21;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
      }
      v11 = v24;
      v12 = v26;
      *((_BYTE *)a1 + 257) = v22;
      v13 = v23;
      *((_BYTE *)a1 + 256) = 1;
      v14 = (v13 << 8) + v11;
      v15 = v25;
      *((_WORD *)a1 + 129) = v14;
      *((_WORD *)a1 + 130) = v12 + (v15 << 8);
      v16 = (_DWORD *)(*a1 + 24);
      *v16 = v14;
      v16[1] = *((unsigned __int16 *)a1 + 130);
      v16[2] = *((unsigned __int8 *)a1 + 257);
      *(_DWORD *)(*a1 + 20) = 86;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      if ( v27 )
      {
        *(_DWORD *)(*a1 + 20) = 89;
        *(_DWORD *)(*a1 + 24) = (unsigned __int8)v27;
        *(_DWORD *)(*a1 + 28) = HIBYTE(v27);
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      }
      v17 = v29;
      if ( v29 == 3 * (unsigned __int8)v27 * HIBYTE(v27) )
        goto LABEL_31;
      *(_DWORD *)(*a1 + 20) = 87;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 76;
      v17 = v29 + 14;
    }
    *(_DWORD *)(*a1 + 24) = v17;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
LABEL_31:
  v9 = v29 <= 0;
  *v2 = v6;
  v2[1] = v32;
  if ( !v9 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v29);
  return 1;
}

// sub_1001D0A6 @ 0x1001D0A6
char __cdecl sub_1001D0A6(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // ebx
  unsigned __int8 v7; // al
  int v8; // ecx
  bool v9; // cc
  int v10; // edx
  _DWORD *v11; // eax
  int v12; // ecx
  int v13; // edx
  unsigned __int8 v14; // al
  int v16; // ecx
  _BYTE v17[11]; // [esp+Ch] [ebp-14h]
  unsigned __int8 v18; // [esp+17h] [ebp-9h]
  int v19; // [esp+18h] [ebp-8h]
  int v20; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v21; // [esp+28h] [ebp+8h]
  unsigned __int8 *v22; // [esp+28h] [ebp+8h]
  unsigned __int8 *v23; // [esp+28h] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v21 = v2[1];
  if ( !v21 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v21 = v2[1];
  }
  v22 = v21 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v20 = v4;
  if ( v22 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v5 = *v2;
  v22 = v2[1];
LABEL_7:
  v23 = v22 - 1;
  v20 = *v5 + v20 - 2;
  v6 = v5 + 1;
  if ( v20 < 12 )
  {
    v16 = v20;
    *(_DWORD *)(*a1 + 20) = 77;
    *(_DWORD *)(*a1 + 24) = v16;
    goto LABEL_22;
  }
  v19 = 0;
  do
  {
    if ( !v23 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v6 = *v2;
      v23 = v2[1];
    }
    --v23;
    v7 = *v6;
    v8 = v19;
    ++v6;
    v9 = ++v19 < 12;
    v17[v8] = v7;
  }
  while ( v9 );
  v20 -= 12;
  if ( v17[0] != 65 || v17[1] != 100 || v17[2] != 111 || v17[3] != 98 || v17[4] != 101 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    *(_DWORD *)(*a1 + 24) = v20 + 12;
LABEL_22:
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    goto LABEL_23;
  }
  v10 = v17[8];
  v11 = (_DWORD *)(*a1 + 24);
  *v11 = v17[6] + (v17[5] << 8);
  v12 = v10 + (v17[7] << 8);
  v13 = v17[10];
  v11[1] = v12;
  v11[2] = v13 + (v17[9] << 8);
  v11[3] = v18;
  *(_DWORD *)(*a1 + 20) = 75;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v14 = v18;
  *((_BYTE *)a1 + 262) = 1;
  *((_BYTE *)a1 + 263) = v14;
LABEL_23:
  v9 = v20 <= 0;
  *v2 = v6;
  v2[1] = v23;
  if ( !v9 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v20);
  return 1;
}

// sub_1001D220 @ 0x1001D220
char __usercall sub_1001D220@<al>(_DWORD *a1@<esi>)
{
  unsigned __int8 **v1; // ebx
  unsigned __int8 *v2; // edi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // edi
  unsigned __int8 *v5; // edi
  int v6; // eax
  unsigned __int8 *v7; // edi
  int v8; // eax
  int v9; // eax
  int v11; // [esp+8h] [ebp-10h]
  int v12; // [esp+Ch] [ebp-Ch]
  int v13; // [esp+10h] [ebp-8h]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+10h] [ebp-8h]
  unsigned __int8 *v16; // [esp+14h] [ebp-4h]
  unsigned __int8 *v17; // [esp+14h] [ebp-4h]
  unsigned __int8 *v18; // [esp+14h] [ebp-4h]
  unsigned __int8 *v19; // [esp+14h] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v16 = v1[1];
  if ( !v16 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v16 = v1[1];
  }
  v17 = v16 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v13 = v3;
  if ( v17 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v4 = *v1;
  v17 = v1[1];
LABEL_7:
  v18 = v17 - 1;
  v14 = *v4 + v13;
  v5 = v4 + 1;
  v15 = v14 - 2;
  while ( v15 > 0 )
  {
    if ( !v18 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v5 = *v1;
      v18 = v1[1];
    }
    v6 = *v5;
    v19 = v18 - 1;
    v7 = v5 + 1;
    v12 = v6;
    if ( !v19 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v7 = *v1;
      v19 = v1[1];
    }
    v8 = *v7;
    v18 = v19 - 1;
    v15 -= 2;
    *(_DWORD *)(*a1 + 20) = 78;
    *(_DWORD *)(*a1 + 24) = v12;
    v11 = v8;
    *(_DWORD *)(*a1 + 28) = v8;
    v5 = v7 + 1;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    v9 = v12;
    if ( v12 >= 32 )
    {
      *(_DWORD *)(*a1 + 20) = 26;
      *(_DWORD *)(*a1 + 24) = v12;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v9 = v12;
    }
    if ( v9 < 16 )
    {
      *((_BYTE *)a1 + v9 + 202) = v11 & 0xF;
      *((_BYTE *)a1 + v9 + 218) = v11 >> 4;
      if ( (unsigned __int8)(v11 & 0xF) > (unsigned __int8)(v11 >> 4) )
      {
        *(_DWORD *)(*a1 + 20) = 27;
        *(_DWORD *)(*a1 + 24) = v11;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      *((_BYTE *)a1 + v9 + 218) = v11;
    }
  }
  v1[1] = v18;
  *v1 = v5;
  return 1;
}

// sub_1001D377 @ 0x1001D377
char __usercall sub_1001D377@<al>(_DWORD *a1@<ebx>)
{
  int v1; // esi
  int v2; // eax
  char *v3; // edi
  unsigned __int16 v4; // ax
  char *v5; // edi
  int v6; // eax
  char *v7; // edi
  unsigned int v8; // eax
  int v9; // ecx
  int v10; // ecx
  unsigned __int8 *v11; // edi
  unsigned __int8 v12; // cl
  _DWORD *v13; // eax
  _DWORD *v14; // eax
  int i; // edi
  char v16; // al
  unsigned int v17; // eax
  int *v18; // edi
  int v19; // edi
  int v20; // eax
  _BYTE v22[256]; // [esp+8h] [ebp-130h] BYREF
  unsigned int v23; // [esp+108h] [ebp-30h]
  int v24; // [esp+10Ch] [ebp-2Ch]
  int v25; // [esp+110h] [ebp-28h]
  int v26; // [esp+114h] [ebp-24h]
  int v27; // [esp+118h] [ebp-20h]
  int v28; // [esp+11Ch] [ebp-1Ch]
  unsigned __int8 v29; // [esp+120h] [ebp-18h]
  int v30; // [esp+124h] [ebp-14h]
  int v31; // [esp+128h] [ebp-10h]
  int v32; // [esp+12Ch] [ebp-Ch]
  char *v33; // [esp+130h] [ebp-8h]
  int v34; // [esp+134h] [ebp-4h]

  v1 = a1[5];
  v2 = *(_DWORD *)(v1 + 4);
  v3 = *(char **)v1;
  v24 = v1;
  v34 = v2;
  if ( !v2 )
  {
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
      return 0;
    v33 = *(char **)v1;
    v3 = v33;
    v34 = *(_DWORD *)(v1 + 4);
  }
  --v34;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v32 = v4;
  if ( v34 )
    goto LABEL_7;
  if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
    return 0;
  v33 = *(char **)v1;
  v5 = v33;
  v34 = *(_DWORD *)(v1 + 4);
LABEL_7:
  v6 = (unsigned __int8)*v5;
  --v34;
  v7 = v5 + 1;
  v32 = v6 + v32 - 2;
  while ( v32 > 0 )
  {
    if ( !v34 )
    {
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
        return 0;
      v33 = *(char **)v1;
      v7 = v33;
      v34 = *(_DWORD *)(v1 + 4);
    }
    v8 = (unsigned __int8)*v7;
    v9 = *a1;
    --v34;
    *(_DWORD *)(v9 + 20) = 79;
    v10 = *a1;
    v23 = v8;
    *(_DWORD *)(v10 + 24) = v8;
    v11 = (unsigned __int8 *)(v7 + 1);
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    LOBYTE(v25) = 0;
    v30 = 0;
    v31 = 1;
    do
    {
      if ( !v34 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
          return 0;
        v33 = *(char **)v1;
        v11 = (unsigned __int8 *)v33;
        v34 = *(_DWORD *)(v1 + 4);
      }
      v12 = *v11;
      --v34;
      *((_BYTE *)&v25 + v31) = v12;
      v30 += v12;
      ++v11;
      ++v31;
      v33 = (char *)v11;
    }
    while ( v31 <= 16 );
    v13 = (_DWORD *)(*a1 + 24);
    *v13 = BYTE1(v25);
    v13[1] = BYTE2(v25);
    v13[2] = HIBYTE(v25);
    v32 -= 17;
    v13[3] = (unsigned __int8)v26;
    v13[4] = BYTE1(v26);
    v13[5] = BYTE2(v26);
    v13[6] = HIBYTE(v26);
    v13[7] = (unsigned __int8)v27;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v14 = (_DWORD *)(*a1 + 24);
    *v14 = BYTE1(v27);
    v14[1] = BYTE2(v27);
    v14[2] = HIBYTE(v27);
    v14[3] = (unsigned __int8)v28;
    v14[4] = BYTE1(v28);
    v14[5] = BYTE2(v28);
    v14[6] = HIBYTE(v28);
    v14[7] = v29;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    if ( v30 > 256 || v30 > v32 )
    {
      *(_DWORD *)(*a1 + 20) = 28;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    for ( i = 0; i < v30; ++i )
    {
      if ( !v34 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(v1 + 12))(a1) )
          return 0;
        v33 = *(char **)v1;
        v34 = *(_DWORD *)(v1 + 4);
      }
      --v34;
      v16 = *v33++;
      v22[i] = v16;
    }
    v32 -= v30;
    v17 = v23;
    if ( (v23 & 0x10) != 0 )
    {
      v17 = v23 - 16;
      v18 = &a1[v23 + 28];
      v31 = (int)v18;
    }
    else
    {
      v31 = (int)&a1[v23 + 40];
      v18 = (int *)v31;
    }
    if ( v17 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 29;
      *(_DWORD *)(*a1 + 24) = v17;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !*v18 )
      *v18 = sub_10023BFC(a1);
    v19 = *v18;
    v20 = v31;
    *(_DWORD *)v19 = v25;
    v19 += 4;
    *(_DWORD *)v19 = v26;
    v19 += 4;
    *(_DWORD *)v19 = v27;
    v19 += 4;
    *(_DWORD *)v19 = v28;
    *(_BYTE *)(v19 + 4) = v29;
    qmemcpy((void *)(*(_DWORD *)v20 + 17), v22, 0x100u);
    v7 = v33;
    v1 = v24;
  }
  *(_DWORD *)(v1 + 4) = v34;
  *(_DWORD *)v1 = v7;
  return 1;
}

// sub_1001D60B @ 0x1001D60B
char __usercall sub_1001D60B@<al>(_DWORD *a1@<ebx>)
{
  unsigned __int8 **v1; // edi
  unsigned __int8 *v2; // esi
  unsigned __int16 v3; // ax
  unsigned __int8 *v4; // esi
  unsigned __int8 *v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  _DWORD *v10; // eax
  __int16 v11; // ax
  int *v12; // eax
  unsigned __int16 *v13; // ecx
  _DWORD *v14; // eax
  int v16; // [esp+8h] [ebp-18h]
  int v17; // [esp+Ch] [ebp-14h]
  int v18; // [esp+10h] [ebp-10h]
  _DWORD *v19; // [esp+10h] [ebp-10h]
  int *v20; // [esp+10h] [ebp-10h]
  unsigned __int16 *v21; // [esp+10h] [ebp-10h]
  __int16 v22; // [esp+14h] [ebp-Ch]
  __int16 v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+14h] [ebp-Ch]
  int v25; // [esp+18h] [ebp-8h]
  int v26; // [esp+18h] [ebp-8h]
  int v27; // [esp+18h] [ebp-8h]
  unsigned __int8 *v28; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v29; // [esp+1Ch] [ebp-4h]
  unsigned __int8 *v30; // [esp+1Ch] [ebp-4h]

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v28 = v1[1];
  if ( !v28 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v28 = v1[1];
  }
  v29 = v28 - 1;
  LOBYTE(v3) = 0;
  HIBYTE(v3) = *v2;
  v4 = v2 + 1;
  v25 = v3;
  if ( v29 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    return 0;
  v4 = *v1;
  v29 = v1[1];
LABEL_7:
  v30 = v29 - 1;
  v26 = *v4 + v25;
  v5 = v4 + 1;
  v27 = v26 - 2;
  while ( v27 > 0 )
  {
    if ( !v30 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v5 = *v1;
      v30 = v1[1];
    }
    v6 = *v5;
    --v30;
    *(_DWORD *)(*a1 + 20) = 80;
    v7 = v6;
    v8 = v6 & 0xF;
    *(_DWORD *)(*a1 + 24) = v8;
    v18 = v8;
    v17 = v7 >> 4;
    *(_DWORD *)(*a1 + 28) = v7 >> 4;
    ++v5;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    v9 = v18;
    if ( v18 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 30;
      *(_DWORD *)(*a1 + 24) = v18;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v9 = v18;
    }
    v10 = &a1[v9 + 36];
    v19 = v10;
    if ( !*v10 )
    {
      *v10 = sub_10023BE0(a1);
      v10 = v19;
    }
    v16 = *v10;
    v20 = &dword_1004E8C0;
    do
    {
      if ( v17 )
      {
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        --v30;
        LOBYTE(v11) = 0;
        HIBYTE(v11) = *v5++;
        v22 = v11;
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        v23 = *v5 + v22;
      }
      else
      {
        if ( !v30 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
            return 0;
          v5 = *v1;
          v30 = v1[1];
        }
        v23 = *v5;
      }
      v12 = v20;
      --v30;
      ++v20;
      ++v5;
      *(_WORD *)(v16 + 2 * *v12) = v23;
    }
    while ( (int)v20 < (int)dword_1004E9C0 );
    if ( *(int *)(*a1 + 104) >= 2 )
    {
      v13 = (unsigned __int16 *)(v16 + 4);
      v21 = (unsigned __int16 *)(v16 + 4);
      v24 = 8;
      while ( 1 )
      {
        v14 = (_DWORD *)(*a1 + 24);
        *v14 = *(v13 - 2);
        v14[1] = *(v13 - 1);
        v14[2] = *v13;
        v14[3] = v13[1];
        v14[4] = v13[2];
        v14[5] = v13[3];
        v14[6] = v13[4];
        v14[7] = v13[5];
        *(_DWORD *)(*a1 + 20) = 92;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
        v21 += 8;
        if ( !--v24 )
          break;
        v13 = v21;
      }
    }
    v27 -= 65;
    if ( v17 )
      v27 -= 64;
  }
  v1[1] = v30;
  *v1 = v5;
  return 1;
}

// sub_1001D834 @ 0x1001D834
char __cdecl sub_1001D834(int a1)
{
  int v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  unsigned __int16 v5; // cx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  unsigned __int16 v10; // cx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // edi
  int v14; // [esp+Ch] [ebp-4h]
  int v15; // [esp+Ch] [ebp-4h]
  int v16; // [esp+Ch] [ebp-4h]
  int v17; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = *(unsigned __int8 ***)(a1 + 20);
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
    v1 = a1;
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v14 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v1 = a1;
  }
  v15 = *v7 + v14;
  v8 = v6 - 1;
  v9 = v7 + 1;
  if ( v15 != 4 )
  {
    *(_DWORD *)(*(_DWORD *)v1 + 20) = 9;
    (**(void (__cdecl ***)(int))v1)(v1);
    v1 = a1;
  }
  if ( !v8 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
    {
      v9 = *v2;
      v8 = v2[1];
      v1 = a1;
      goto LABEL_12;
    }
    return 0;
  }
LABEL_12:
  LOBYTE(v10) = 0;
  HIBYTE(v10) = *v9;
  v11 = v8 - 1;
  v12 = v9 + 1;
  v16 = v10;
  if ( !v11 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v2[3])(v1) )
      return 0;
    v12 = *v2;
    v11 = v2[1];
    v1 = a1;
  }
  v17 = *v12 + v16;
  *(_DWORD *)(*(_DWORD *)v1 + 20) = 81;
  *(_DWORD *)(*(_DWORD *)v1 + 24) = v17;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)v1 + 4))(v1, 1);
  *(_DWORD *)(a1 + 252) = v17;
  *v2 = v12 + 1;
  v2[1] = v11 - 1;
  return 1;
}

// sub_1001D90B @ 0x1001D90B
char __cdecl sub_1001D90B(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int16 v4; // ax
  unsigned __int8 *v5; // ebx
  int v7; // [esp+Ch] [ebp-4h]
  int v8; // [esp+Ch] [ebp-4h]
  unsigned __int8 *v9; // [esp+18h] [ebp+8h]
  unsigned __int8 *v10; // [esp+18h] [ebp+8h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v9 = v2[1];
  if ( !v9 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v9 = v2[1];
  }
  v10 = v9 - 1;
  LOBYTE(v4) = 0;
  HIBYTE(v4) = *v3;
  v5 = v3 + 1;
  v7 = v4;
  if ( !v10 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v5 = *v2;
    v10 = v2[1];
  }
  v8 = *v5 + v7;
  *(_DWORD *)(*a1 + 20) = 90;
  *(_DWORD *)(*a1 + 24) = a1[94];
  *(_DWORD *)(*a1 + 28) = v8;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *v2 = v5 + 1;
  v2[1] = v10 - 1;
  (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v8 - 2);
  return 1;
}

// sub_1001D9A7 @ 0x1001D9A7
char __cdecl sub_1001D9A7(_DWORD *a1)
{
  _DWORD *v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // ecx
  int v6; // ecx
  int v8; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  while ( 1 )
  {
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
        return 0;
      v1 = a1;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    --v3;
    ++v4;
    if ( v5 != 255 )
    {
      ++*(_DWORD *)(v1[100] + 88);
      goto LABEL_3;
    }
    do
    {
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
        v1 = a1;
      }
      v6 = *v4;
      --v3;
      ++v4;
      v8 = v6;
    }
    while ( v6 == 255 );
    if ( v6 )
      break;
    *(_DWORD *)(v1[100] + 88) += 2;
LABEL_3:
    *v2 = v4;
    v2[1] = v3;
  }
  if ( *(_DWORD *)(v1[100] + 88) )
  {
    *(_DWORD *)(*v1 + 20) = 112;
    *(_DWORD *)(*v1 + 24) = *(_DWORD *)(v1[100] + 88);
    *(_DWORD *)(*v1 + 28) = v6;
    (*(void (__cdecl **)(_DWORD *, int))(*v1 + 4))(v1, -1);
    *(_DWORD *)(a1[100] + 88) = 0;
    v1 = a1;
    v6 = v8;
  }
  v1[94] = v6;
  *v2 = v4;
  v2[1] = v3;
  return 1;
}

// sub_1001DA7E @ 0x1001DA7E
char __cdecl sub_1001DA7E(_DWORD *a1)
{
  _DWORD *v1; // eax
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // edx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebx
  unsigned __int8 *v11; // edi
  int v12; // [esp+Ch] [ebp-4h]
  int v13; // [esp+Ch] [ebp-4h]

  v1 = a1;
  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
    v1 = a1;
  }
  v5 = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v12 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(v1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v1 = a1;
    v5 = v12;
  }
  v9 = *v7;
  v10 = v6 - 1;
  v11 = v7 + 1;
  v13 = v9;
  if ( v5 != 255 || v9 != 216 )
  {
    *(_DWORD *)(*v1 + 20) = 52;
    *(_DWORD *)(*v1 + 24) = v5;
    *(_DWORD *)(*v1 + 28) = v9;
    (*(void (__cdecl **)(_DWORD *))*v1)(v1);
    v1 = a1;
    v9 = v13;
  }
  v1[94] = v9;
  *v2 = v11;
  v2[1] = v10;
  return 1;
}

// sub_1001DB15 @ 0x1001DB15
int __cdecl sub_1001DB15(_DWORD *a1)
{
  int v2; // eax
  char v3; // al
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int result; // eax
  char v8; // [esp-4h] [ebp-10h]

  while ( 1 )
  {
    if ( !a1[94] && !(*(_BYTE *)(a1[100] + 80) ? sub_1001D9A7(a1) : sub_1001DA7E(a1)) )
      return 0;
    v2 = a1[94];
    if ( v2 > 207 )
      break;
    if ( v2 >= 205 )
      goto LABEL_26;
    if ( v2 > 200 )
    {
      v4 = v2 - 201;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( !v6 )
          {
LABEL_26:
            *(_DWORD *)(*a1 + 20) = 59;
LABEL_34:
            *(_DWORD *)(*a1 + 24) = a1[94];
            (*(void (__cdecl **)(_DWORD *))*a1)(a1);
            goto LABEL_48;
          }
          if ( v6 != 1 )
            goto LABEL_33;
          v3 = sub_1001D220(a1);
        }
        else
        {
          v3 = sub_1001C8BD(1, (int)a1, 1);
        }
        goto LABEL_47;
      }
      v8 = 1;
    }
    else
    {
      if ( v2 >= 197 )
        goto LABEL_26;
      if ( v2 == 1 )
      {
LABEL_36:
        *(_DWORD *)(*a1 + 20) = 91;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        goto LABEL_48;
      }
      if ( v2 <= 191 )
        goto LABEL_33;
      if ( v2 > 193 )
      {
        if ( v2 == 194 )
        {
          v3 = sub_1001C8BD(1, (int)a1, 0);
        }
        else
        {
          if ( v2 == 195 )
            goto LABEL_26;
          v3 = sub_1001D377(a1);
        }
        goto LABEL_47;
      }
      v8 = 0;
    }
    v3 = sub_1001C8BD(0, (int)a1, v8);
LABEL_47:
    if ( !v3 )
      return 0;
LABEL_48:
    a1[94] = 0;
  }
  if ( v2 > 219 )
  {
    if ( v2 == 220 )
    {
      v3 = sub_1001D90B(a1);
    }
    else if ( v2 == 221 )
    {
      v3 = sub_1001D834((int)a1);
    }
    else
    {
      if ( v2 <= 223 )
        goto LABEL_33;
      if ( v2 <= 239 )
      {
        v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 4 * v2 - 880))(a1);
      }
      else
      {
        if ( v2 != 254 )
        {
LABEL_33:
          *(_DWORD *)(*a1 + 20) = 67;
          goto LABEL_34;
        }
        v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 12))(a1);
      }
    }
    goto LABEL_47;
  }
  if ( v2 == 219 )
  {
    v3 = sub_1001D60B(a1);
    goto LABEL_47;
  }
  if ( v2 <= 215 )
    goto LABEL_36;
  if ( v2 == 216 )
  {
    v3 = sub_1001C82F((int)a1);
    goto LABEL_47;
  }
  if ( v2 == 217 )
  {
    *(_DWORD *)(*a1 + 20) = 84;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    result = 2;
    goto LABEL_51;
  }
  if ( sub_1001CBB8(a1) )
  {
    result = 1;
LABEL_51:
    a1[94] = 0;
    return result;
  }
  return 0;
}

// sub_1001DD02 @ 0x1001DD02
char __cdecl sub_1001DD02(_DWORD *a1)
{
  if ( a1[94] || sub_1001D9A7(a1) )
  {
    if ( a1[94] == *(_DWORD *)(a1[100] + 84) + 208 )
    {
      *(_DWORD *)(*a1 + 20) = 97;
      *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 84);
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
      a1[94] = 0;
LABEL_5:
      *(_DWORD *)(a1[100] + 84) = ((unsigned __int8)*(_DWORD *)(a1[100] + 84) + 1) & 7;
      return 1;
    }
    if ( (*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD))(a1[5] + 20))(a1, *(_DWORD *)(a1[100] + 84)) )
      goto LABEL_5;
  }
  return 0;
}

// sub_1001DD80 @ 0x1001DD80
char __cdecl sub_1001DD80(_DWORD *a1, int a2)
{
  int v3; // edi
  int v5; // [esp+14h] [ebp+4h]

  v3 = a1[94];
  *(_DWORD *)(*a1 + 20) = 117;
  *(_DWORD *)(*a1 + 24) = v3;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while ( 1 )
  {
    if ( v3 < 192 )
    {
LABEL_3:
      v5 = 2;
      goto LABEL_12;
    }
    if ( v3 < 208 || v3 > 215 || v3 == ((a2 + 1) & 7) + 208 || v3 == ((a2 + 2) & 7) + 208 )
    {
      v5 = 3;
    }
    else
    {
      if ( v3 == ((a2 - 1) & 7) + 208 || v3 == ((a2 - 2) & 7) + 208 )
        goto LABEL_3;
      v5 = 1;
    }
LABEL_12:
    *(_DWORD *)(*a1 + 20) = 96;
    *(_DWORD *)(*a1 + 24) = v3;
    *(_DWORD *)(*a1 + 28) = v5;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    if ( v5 == 1 )
      break;
    if ( v5 != 2 )
      return 1;
    if ( !sub_1001D9A7(a1) )
      return 0;
    v3 = a1[94];
  }
  a1[94] = 0;
  return 1;
}

// sub_1001DE6F @ 0x1001DE6F
int __cdecl sub_1001DE6F(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  a1[49] = 0;
  a1[31] = 0;
  a1[94] = 0;
  v1 = a1 + 100;
  *(_BYTE *)(*v1 + 80) = 0;
  *(_BYTE *)(*v1 + 81) = 0;
  result = a1[100];
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// sub_1001DE99 @ 0x1001DE99
int __cdecl sub_1001DE99(int a1)
{
  _DWORD *v1; // eax
  int i; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
  *(_DWORD *)(a1 + 400) = v1;
  *v1 = sub_1001DE6F;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 4) = sub_1001DB15;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 8) = sub_1001DD02;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 12) = sub_1001D90B;
  for ( i = 16; i < 80; i += 4 )
    *(_DWORD *)(i + *(_DWORD *)(a1 + 400)) = sub_1001D90B;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 16) = sub_1001CE6A;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 72) = sub_1001D0A6;
  return sub_1001DE6F((_DWORD *)a1);
}

// sub_1001DF16 @ 0x1001DF16
void __cdecl __noreturn sub_1001DF16(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  sub_10023BC5(a1);
  exit(1);
}

// sub_1001DF31 @ 0x1001DF31
int __cdecl sub_1001DF31(int a1)
{
  _BYTE v2[200]; // [esp+0h] [ebp-C8h] BYREF

  return (*(int (__cdecl **)(int, _BYTE *))(*(_DWORD *)a1 + 12))(a1, v2);
}

// sub_1001DF4E @ 0x1001DF4E
int __cdecl sub_1001DF4E(int *a1, int a2)
{
  int result; // eax
  int v3; // esi

  result = (int)a1;
  v3 = *a1;
  if ( a2 >= 0 )
  {
    if ( *(_DWORD *)(v3 + 104) >= a2 )
      return (*(int (__cdecl **)(int *))(v3 + 8))(a1);
  }
  else
  {
    if ( !*(_DWORD *)(v3 + 108) || *(int *)(v3 + 104) >= 3 )
      result = (*(int (__cdecl **)(int *))(v3 + 8))(a1);
    ++*(_DWORD *)(v3 + 108);
  }
  return result;
}

// sub_1001DF7F @ 0x1001DF7F
int __cdecl sub_1001DF7F(int a1, char *Buffer)
{
  _DWORD *v2; // eax
  int v3; // edx
  const char *v4; // ecx
  int v5; // ecx
  int v6; // esi
  const char **v7; // ecx
  char v8; // dl
  char *i; // esi

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( v3 <= 0 || v3 > v2[29] )
  {
    v5 = v2[30];
    if ( !v5 )
      goto LABEL_9;
    v6 = v2[31];
    if ( v3 < v6 || v3 > v2[32] )
      goto LABEL_9;
    v4 = *(const char **)(v5 + 4 * (v3 - v6));
  }
  else
  {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if ( !v4 )
  {
LABEL_9:
    v7 = (const char **)v2[28];
    v2[6] = v3;
    v4 = *v7;
  }
  v8 = *v4;
  for ( i = (char *)v4; ; v8 = *i )
  {
    if ( !v8 )
      return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
    ++i;
    if ( v8 == 37 )
      break;
  }
  if ( *i != 115 )
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  return sprintf(Buffer, v4, v2 + 6);
}

// sub_1001E016 @ 0x1001E016
int __cdecl sub_1001E016(int *a1)
{
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

// sub_1001E027 @ 0x1001E027
void (__cdecl __noreturn **__cdecl sub_1001E027(void (__cdecl __noreturn **a1)(int a1)))(int a1)
{
  *a1 = sub_1001DF16;
  a1[1] = (void (__cdecl __noreturn *)(int))sub_1001DF4E;
  a1[2] = (void (__cdecl __noreturn *)(int))sub_1001DF31;
  a1[3] = (void (__cdecl __noreturn *)(int))sub_1001DF7F;
  a1[4] = (void (__cdecl __noreturn *)(int))sub_1001E016;
  a1[26] = 0;
  a1[27] = 0;
  a1[5] = 0;
  a1[28] = (void (__cdecl __noreturn *)(int))off_1004CE48;
  a1[29] = (void (__cdecl __noreturn *)(int))119;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  return a1;
}

// sub_1001E073 @ 0x1001E073
_BYTE *__cdecl sub_1001E073(int a1, const void *a2)
{
  int v2; // ecx
  _BYTE *result; // eax
  int i; // esi
  int v5; // edx
  _BYTE *v6; // eax
  _BYTE *v7; // eax

  result = 0;
  for ( i = 0; i < 4; ++i )
  {
    v5 = *(unsigned __int8 *)(a1 + i + 268);
    if ( v5 < 41 || v5 > 122 || v5 > 90 && v5 < 97 )
    {
      result[v2] = 91;
      v6 = result + 1;
      v6[v2] = byte_1004E1C0[(v5 >> 4) & 0xF];
      (++v6)[v2] = byte_1004E1C0[v5 & 0xF];
      result = v6 + 1;
      result[v2] = 93;
    }
    else
    {
      result[v2] = v5;
    }
    ++result;
  }
  if ( a2 )
  {
    result[v2] = 58;
    v7 = result + 1;
    v7[v2] = 32;
    result = &v7[v2 + 1];
    qmemcpy(result, a2, 0x40u);
    result[63] = 0;
  }
  else
  {
    result[v2] = 0;
  }
  return result;
}

// sub_1001E0FA @ 0x1001E0FA
_DWORD *__cdecl sub_1001E0FA(_DWORD *a1, int a2, int a3, int a4)
{
  a1[18] = a2;
  a1[16] = a3;
  a1[17] = a4;
  return a1;
}

// png_error @ 0x1001E114
// png error handler: call error_fn then longjmp
void __cdecl __noreturn sub_1001E114(jmp_buf Buf, int a2)
{
  void (__cdecl *v2)(int *__attribute__((__org_typedef(jmp_buf))), int); // eax

  v2 = (void (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int))Buf[16];
  if ( v2 )
    v2(Buf, a2);
  longjmp(Buf, 1);
}

// png_warning @ 0x1001E132
// png warning handler: call warning_fn
int (__cdecl *__cdecl sub_1001E132(int a1, int a2))(int, int)
{
  int (__cdecl *result)(int, int); // eax

  result = *(int (__cdecl **)(int, int))(a1 + 68);
  if ( result )
    return (int (__cdecl *)(int, int))result(a1, a2);
  return result;
}

// FUN_1001e147 @ 0x1001E147
void __cdecl __noreturn sub_1001E147(jmp_buf Buf, const void *a2)
{
  int v2[20]; // [esp+0h] [ebp-50h] BYREF

  sub_1001E073((int)Buf, a2);
  png_error(Buf, (int)v2);
}

// FUN_1001e16c @ 0x1001E16C
int (__cdecl *__cdecl sub_1001E16C(int a1, const void *a2))(int, int)
{
  _BYTE v3[80]; // [esp+0h] [ebp-50h] BYREF

  sub_1001E073(a1, a2);
  return png_warning(a1, (int)v3);
}

// png_create_read_struct @ 0x1001E191
// allocates png_struct, initializes zlib stream, checks version; error_fn/warn_fn are png_error_ptr callbacks
jmp_buf __cdecl sub_1001E191(_BYTE *a1, int a2, int a3, int a4)
{
  int *v4; // eax
  int v6; // eax
  int v7; // [esp+0h] [ebp-8h]
  int *__attribute__((__org_typedef(jmp_buf))) Buf; // [esp+4h] [ebp-4h]

  v4 = (int *)sub_100246F2(1);
  Buf = v4;
  if ( !v4 )
    return 0;
  if ( setjmp3(v4, 0, v7) )
  {
    png_free((int)Buf, (void *)Buf[39]);
    png_free_ptr(Buf);
    return 0;
  }
  sub_1001E0FA(Buf, a2, a3, a4);
  if ( !a1 || *a1 != 49 )
    png_error(Buf, (int)"Incompatible libpng version in application and library");
  Buf[40] = 0x2000;
  Buf[39] = png_malloc(Buf, 0x2000u);
  Buf[33] = (int)FUN_1002052b;
  Buf[34] = (int)png_free_thunk;
  Buf[35] = (int)Buf;
  v6 = inflateInit_(Buf + 25, "1.1.3", 56);
  if ( v6 == -6 )
    png_error(Buf, (int)"zlib version error");
  if ( v6 == -4 || v6 == -2 )
    png_error(Buf, (int)"zlib memory error");
  if ( v6 )
    png_error(Buf, (int)"Unknown zlib error");
  Buf[28] = Buf[39];
  Buf[29] = Buf[40];
  FUN_100204a4(Buf, 0, 0);
  return Buf;
}

// FUN_1001e294 @ 0x1001E294
int __cdecl sub_1001E294(jmp_buf Buf, int a2)
{
  int *__attribute__((__org_typedef(jmp_buf))) v2; // esi
  unsigned __int8 v3; // al
  unsigned int v4; // ebx
  int v5; // edi
  _DWORD *v6; // ebx
  size_t v7; // edi
  int result; // eax
  int v9; // [esp-18h] [ebp-24h]

  v2 = Buf;
  v3 = *((_BYTE *)Buf + 284);
  if ( v3 < 8u )
  {
    v4 = v3;
    v5 = 8 - v3;
    png_read_data(Buf, v3 + a2 + 32, v5);
    v9 = a2 + 32;
    *((_BYTE *)v2 + 284) = 8;
    if ( sub_100204E3(v9, v4, v5) )
    {
      if ( v4 < 4 )
      {
        if ( sub_100204E3(a2 + 32, v4, v5 - 4) )
          png_error(v2, (int)"Not a PNG file");
      }
      png_error(v2, (int)"PNG file corrupted by ASCII conversion");
    }
  }
  v6 = v2 + 67;
  while ( 1 )
  {
    while ( 1 )
    {
      while ( 1 )
      {
        while ( 1 )
        {
          png_read_data(v2, (int)&Buf, 4);
          v7 = png_get_uint_32(&Buf);
          png_reset_crc(v2);
          png_crc_read(v2, (int)(v2 + 67), 4);
          if ( *v6 != *(_DWORD *)"IHDR" )
            break;
          FUN_10025163(v2, a2, v7);
        }
        if ( *v6 != *(_DWORD *)"PLTE" )
          break;
        FUN_10025359(v2, a2, v7);
      }
      if ( *v6 != *(_DWORD *)"IEND" )
        break;
      FUN_10025483(v2, a2, v7);
    }
    if ( *v6 == *(_DWORD *)"IDAT" )
      break;
    if ( *v6 == *(_DWORD *)"gAMA" )
    {
      FUN_100254cd(v2, a2, v7);
    }
    else if ( *v6 == *(_DWORD *)"sRGB" )
    {
      FUN_100255d8(v2, a2, v7);
    }
    else if ( *v6 == *(_DWORD *)"tRNS" )
    {
      FUN_100256c7(v2, a2, v7);
    }
    else
    {
      FUN_1002587e(v2, a2, v7);
    }
  }
  result = v2[22];
  if ( (result & 1) == 0 )
    png_error(v2, (int)"Missing IHDR before IDAT");
  if ( *((_BYTE *)v2 + 278) == 3 && (result & 2) == 0 )
    png_error(v2, (int)"Missing PLTE before IDAT");
  v2[22] |= 4u;
  v2[63] = v7;
  return result;
}

// FUN_1001e407 @ 0x1001E407
int __cdecl sub_1001E407(jmp_buf Buf, int a2)
{
  if ( (Buf[23] & 0x40) == 0 )
    FUN_10024f3b(Buf);
  return sub_1001ED89(Buf, a2);
}

// FUN_1001e427 @ 0x1001E427
int (__cdecl *__cdecl sub_1001E427(jmp_buf Buf, int a2, int a3))(jmp_buf, int, _DWORD)
{
  int *__attribute__((__org_typedef(jmp_buf))) v3; // esi
  int (__cdecl *result)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
  int v5; // eax
  bool v6; // zf
  int v7; // eax
  unsigned int v8; // eax
  unsigned int v9; // edx
  int v10; // ecx
  int v11; // eax
  const char *v12; // eax
  char v13; // al
  unsigned __int8 v14; // cl
  int v15; // eax
  unsigned int v16; // ecx
  unsigned __int8 *v17; // eax
  unsigned __int8 v18; // cl

  v3 = Buf;
  if ( (Buf[23] & 0x40) == 0 )
    FUN_10024f3b(Buf);
  if ( !*((_BYTE *)v3 + 275) || (v3[24] & 2) == 0 )
    goto LABEL_36;
  switch ( *((_BYTE *)v3 + 276) )
  {
    case 0:
      if ( (v3[53] & 7) == 0 )
        break;
      v6 = a3 == 0;
      goto LABEL_34;
    case 1:
      if ( (v3[53] & 7) != 0 || (unsigned int)v3[46] < 5 )
      {
        if ( a3 )
          sub_100248E1(v3, a3, 15);
        return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
      }
      break;
    case 2:
      v7 = v3[53];
      if ( (v7 & 7) == 4 )
        break;
      if ( !a3 )
        return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
      v6 = (v7 & 4) == 0;
LABEL_34:
      if ( !v6 )
        sub_100248E1(v3, a3, 255);
      return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
    case 3:
      if ( (v3[53] & 3) != 0 || (unsigned int)v3[46] < 3 )
      {
        if ( a3 )
          sub_100248E1(v3, a3, 51);
        return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
      }
      break;
    case 4:
      v5 = v3[53];
      if ( (v5 & 3) == 2 )
        break;
      if ( a3 )
      {
        v6 = (v5 & 2) == 0;
        goto LABEL_34;
      }
      return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
    case 5:
      if ( (v3[53] & 1) != 0 || (unsigned int)v3[46] < 2 )
      {
        if ( a3 )
          sub_100248E1(v3, a3, 85);
        return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
      }
      break;
    default:
      if ( *((_BYTE *)v3 + 276) == 6 && (v3[53] & 1) == 0 )
        return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_100258C8(v3);
      break;
  }
LABEL_36:
  if ( (v3[22] & 4) == 0 )
    png_error(v3, (int)"Invalid attempt to read row data");
  v3[28] = v3[55];
  v3[29] = v3[51];
  while ( 1 )
  {
    if ( !v3[26] )
    {
      while ( !v3[63] )
      {
        png_crc_finish(v3, 0);
        png_read_data(v3, (int)&Buf, 4);
        v3[63] = png_get_uint_32(&Buf);
        png_reset_crc(v3);
        png_crc_read(v3, (int)(v3 + 67), 4);
        if ( v3[67] != *(_DWORD *)"IDAT" )
          png_error(v3, (int)"Not enough image data");
      }
      v8 = v3[40];
      v9 = v3[63];
      v10 = v3[39];
      v3[26] = v8;
      v3[25] = v10;
      if ( v8 > v9 )
        v3[26] = v9;
      png_crc_read(v3, v10, v3[26]);
      v3[63] -= v3[26];
    }
    v11 = inflate(v3 + 25, 1);
    if ( v11 == 1 )
      break;
    if ( v11 )
    {
      v12 = (const char *)v3[31];
      if ( !v12 )
        v12 = "Decompression error";
      png_error(v3, (int)v12);
    }
    if ( !v3[29] )
      goto LABEL_59;
  }
  if ( v3[29] || v3[26] || v3[63] )
    png_error(v3, (int)"Extra compressed data");
  v3[22] |= 8u;
  v3[23] |= 0x20u;
LABEL_59:
  v13 = *((_BYTE *)v3 + 278);
  *((_BYTE *)v3 + 250) = *((_BYTE *)v3 + 282);
  *((_BYTE *)v3 + 249) = *((_BYTE *)v3 + 279);
  v14 = *((_BYTE *)v3 + 281);
  *((_BYTE *)v3 + 251) = v14;
  *((_BYTE *)v3 + 248) = v13;
  v15 = v3[52];
  v16 = v15 * v14 + 7;
  v3[60] = v15;
  v17 = (unsigned __int8 *)v3[55];
  v3[61] = v16 >> 3;
  FUN_10024dc0(v3, v3 + 60, v17 + 1, v3[54] + 1, *v17);
  FUN_10024790(v3, v3[54], v3[55], v3[50] + 1);
  if ( v3[24] )
    FUN_10020149(v3);
  if ( *((_BYTE *)v3 + 275) && (v3[24] & 2) != 0 )
  {
    v18 = *((_BYTE *)v3 + 276);
    if ( v18 < 6u )
      sub_10024AF7(v3 + 60, v3[55] + 1, v18);
    if ( a3 )
      sub_100248E1(v3, a3, dword_1004E1F8[*((unsigned __int8 *)v3 + 276)]);
    if ( a2 )
      sub_100248E1(v3, a2, dword_1004E1DC[*((unsigned __int8 *)v3 + 276)]);
  }
  else
  {
    if ( a2 )
      sub_100248E1(v3, a2, 255);
    if ( a3 )
      sub_100248E1(v3, a3, 255);
  }
  sub_100258C8(v3);
  result = (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))v3[91];
  if ( result )
    return (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))result(
                                                                                         v3,
                                                                                         v3[53],
                                                                                         *((unsigned __int8 *)v3 + 276));
  return result;
}

// FUN_1001e7ce @ 0x1001E7CE
int (__cdecl *__cdecl sub_1001E7CE(jmp_buf Buf, int *a2))(jmp_buf, int, _DWORD)
{
  int (__cdecl *result)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD); // eax
  int v4; // edi
  int *v5; // ebx
  int (__cdecl *v6)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD); // [esp+8h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+14h] [ebp+8h]

  result = (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))sub_1001EBF8(Buf);
  v4 = Buf[47];
  Buf[48] = v4;
  if ( (int)result > 0 )
  {
    v6 = result;
    do
    {
      v5 = a2;
      if ( v4 )
      {
        Bufa = (int *)v4;
        do
        {
          result = FUN_1001e427(Buf, *v5++, 0);
          Bufa = (int *)((char *)Bufa - 1);
        }
        while ( Bufa );
      }
      v6 = (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, _DWORD))((char *)v6 - 1);
    }
    while ( v6 );
  }
  return result;
}

// FUN_1001e81b @ 0x1001E81B
int __cdecl sub_1001E81B(int a1, int a2, int a3)
{
  int v3; // edi
  int v4; // esi
  int result; // eax
  int v6; // edx
  int v7; // esi
  _BYTE v8[64]; // [esp+Ch] [ebp-40h] BYREF

  v3 = 0;
  if ( a2 )
    FUN_100205da(a1, a2);
  if ( a3 )
    FUN_100205da(a1, a3);
  png_free(a1, *(void **)(a1 + 156));
  png_free(a1, *(void **)(a1 + 220));
  png_free(a1, *(void **)(a1 + 216));
  png_free(a1, *(void **)(a1 + 372));
  png_free(a1, *(void **)(a1 + 376));
  png_free(a1, *(void **)(a1 + 312));
  if ( (*(_BYTE *)(a1 + 93) & 0x10) != 0 )
    png_free_thunk(a1, *(void **)(a1 + 260));
  if ( (*(_BYTE *)(a1 + 93) & 0x20) != 0 )
    png_free(a1, *(void **)(a1 + 348));
  if ( *(_DWORD *)(a1 + 324) )
  {
    v4 = 1 << (8 - *(_BYTE *)(a1 + 300));
    if ( v4 > 0 )
    {
      do
        png_free(a1, *(void **)(*(_DWORD *)(a1 + 324) + 4 * v3++));
      while ( v3 < v4 );
    }
    png_free(a1, *(void **)(a1 + 324));
  }
  inflateEnd(a1 + 100);
  result = *(_DWORD *)(a1 + 72);
  v6 = *(_DWORD *)(a1 + 64);
  qmemcpy(v8, (const void *)a1, sizeof(v8));
  v7 = *(_DWORD *)(a1 + 68);
  memset((void *)a1, 0, 0x19Cu);
  *(_DWORD *)(a1 + 68) = v7;
  qmemcpy((void *)a1, v8, 0x40u);
  *(_DWORD *)(a1 + 64) = v6;
  *(_DWORD *)(a1 + 72) = result;
  return result;
}

// sub_1001E93E @ 0x1001E93E
int __cdecl sub_1001E93E(int *a1, int *a2, int *a3)
{
  int result; // eax
  int v4; // esi
  int v5; // [esp+Ch] [ebp-8h]
  int v6; // [esp+10h] [ebp-4h]

  result = (int)a1;
  v4 = 0;
  v6 = 0;
  v5 = 0;
  if ( a1 )
  {
    result = *a1;
    v6 = *a1;
  }
  if ( a2 )
    v4 = *a2;
  if ( a3 )
  {
    result = *a3;
    v5 = *a3;
  }
  if ( v6 )
    result = FUN_1001e81b(v6, v4, v5);
  if ( v4 )
  {
    result = png_free_ptr(v4);
    *a2 = 0;
  }
  if ( v5 )
  {
    result = png_free_ptr(v5);
    *a3 = 0;
  }
  if ( v6 )
  {
    png_free_ptr(v6);
    *a1 = 0;
    return (int)a1;
  }
  return result;
}

// sub_1001E9BF @ 0x1001E9BF
int __cdecl sub_1001E9BF(int a1, int a2, int a3)
{
  if ( a1 && a2 )
    return a3 & *(_DWORD *)(a2 + 8);
  else
    return 0;
}

// sub_1001E9D9 @ 0x1001E9D9
int __cdecl sub_1001E9D9(int a1, int a2)
{
  if ( a1 && a2 )
    return *(_DWORD *)(a2 + 12);
  else
    return 0;
}

// sub_1001E9EF @ 0x1001E9EF
char __cdecl sub_1001E9EF(int a1, int a2)
{
  if ( a1 && a2 )
    return *(_BYTE *)(a2 + 29);
  else
    return 0;
}

// sub_1001EA05 @ 0x1001EA05
int __cdecl sub_1001EA05(int a1, int a2, double *a3)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 1) == 0 || !a3 )
    return 0;
  *a3 = *(float *)(a2 + 40);
  return 1;
}

// sub_1001EA2E @ 0x1001EA2E
int __cdecl sub_1001EA2E(int a1, int a2, _DWORD *a3)
{
  int result; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  result = 2048;
  if ( (*(_DWORD *)(a2 + 8) & 0x800) == 0 || !a3 )
    return 0;
  *a3 = *(unsigned __int8 *)(a2 + 44);
  return result;
}

// FUN_1001ea59 @ 0x1001EA59
int __cdecl sub_1001EA59(
        int a1,
        int a2,
        unsigned int *a3,
        _DWORD *a4,
        _DWORD *a5,
        _DWORD *a6,
        _DWORD *a7,
        _DWORD *a8,
        _DWORD *a9)
{
  int v9; // eax

  if ( !a1 || !a2 || !a3 || !a4 || !a5 || !a6 )
    return 0;
  *a3 = *(_DWORD *)a2;
  *a4 = *(_DWORD *)(a2 + 4);
  *a5 = *(unsigned __int8 *)(a2 + 24);
  *a6 = *(unsigned __int8 *)(a2 + 25);
  if ( a8 )
    *a8 = *(unsigned __int8 *)(a2 + 26);
  if ( a9 )
    *a9 = *(unsigned __int8 *)(a2 + 27);
  if ( a7 )
    *a7 = *(unsigned __int8 *)(a2 + 28);
  if ( *a6 == 3 )
    v9 = 1;
  else
    v9 = *a6 & 2 | 1;
  if ( (*a6 & 4) != 0 )
    ++v9;
  if ( *a3 > 0x7FFFFFFFu / ((v9 * *a5 + 7) >> 3) )
    png_warning(a1, (int)"Width too large for libpng to process image data.");
  return 1;
}

// sub_1001EB2A @ 0x1001EB2A
int __cdecl sub_1001EB2A(int a1, int a2, _DWORD *a3, _DWORD *a4)
{
  if ( !a1 || !a2 || (*(_BYTE *)(a2 + 8) & 8) == 0 || !a3 )
    return 0;
  *a3 = *(_DWORD *)(a2 + 16);
  *a4 = *(unsigned __int16 *)(a2 + 20);
  return 8;
}

// sub_1001EB5D @ 0x1001EB5D
int __cdecl sub_1001EB5D(int a1, int a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  int result; // eax

  result = 0;
  if ( a1 && a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    if ( *(_BYTE *)(a2 + 25) == 3 )
    {
      if ( a3 )
      {
        *a3 = *(_DWORD *)(a2 + 48);
        result = 16;
      }
      if ( a5 )
        *a5 = a2 + 52;
    }
    else
    {
      if ( a5 )
      {
        *a5 = a2 + 52;
        result = 16;
      }
      if ( a3 )
        *a3 = 0;
    }
    if ( a4 )
    {
      *a4 = *(unsigned __int16 *)(a2 + 22);
      return result | 0x10;
    }
  }
  return result;
}

// sub_1001EBC4 @ 0x1001EBC4
int __cdecl sub_1001EBC4(int a1)
{
  *(_DWORD *)(a1 + 96) |= 1u;
  return a1;
}

// sub_1001EBCD @ 0x1001EBCD
int __cdecl sub_1001EBCD(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 279) == 16 )
    *(_DWORD *)(a1 + 96) |= 0x10u;
  return result;
}

// sub_1001EBDF @ 0x1001EBDF
int __cdecl sub_1001EBDF(int a1)
{
  int result; // eax

  result = a1;
  if ( *(_BYTE *)(a1 + 279) < 8u )
  {
    *(_DWORD *)(a1 + 96) |= 4u;
    *(_BYTE *)(a1 + 280) = 8;
  }
  return result;
}

// sub_1001EBF8 @ 0x1001EBF8
int __cdecl sub_1001EBF8(int a1)
{
  if ( !*(_BYTE *)(a1 + 275) )
    return 1;
  *(_DWORD *)(a1 + 96) |= 2u;
  return 7;
}

// sub_1001EC11 @ 0x1001EC11
int __cdecl sub_1001EC11(int a1, unsigned __int8 a2, int a3)
{
  int result; // eax
  char v4; // cl

  result = a1;
  *(_BYTE *)(a1 + 97) |= 0x80u;
  *(_WORD *)(a1 + 286) = a2;
  if ( a3 == 1 )
    *(_BYTE *)(a1 + 92) |= 0x80u;
  else
    *(_BYTE *)(a1 + 92) &= ~0x80u;
  v4 = *(_BYTE *)(a1 + 278);
  if ( v4 == 2 )
    *(_BYTE *)(a1 + 283) = 4;
  if ( !v4 && *(_BYTE *)(a1 + 279) >= 8u )
    *(_BYTE *)(a1 + 283) = 2;
  return result;
}

// sub_1001EC5E @ 0x1001EC5E
void __cdecl sub_1001EC5E(int a1, char *a2)
{
  int v3; // esi
  char v4; // dl

  if ( *(_BYTE *)(a1 + 9) == 16 && *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
  {
    v3 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
    do
    {
      v4 = *a2;
      *a2 = a2[1];
      a2[1] = v4;
      a2 += 2;
      --v3;
    }
    while ( v3 );
  }
}

// sub_1001EC8B @ 0x1001EC8B
char __cdecl sub_1001EC8B(int *a1, char *a2)
{
  char *v2; // eax
  char v3; // dl
  int v4; // ecx
  int v5; // esi
  char v6; // dl
  int v7; // esi
  char v8; // dl
  int v9; // esi
  char v10; // cl
  char v11; // dl
  char v12; // cl
  int v13; // esi
  char v14; // cl
  char v15; // dl
  char v16; // cl

  LOBYTE(v2) = (_BYTE)a1;
  v3 = *((_BYTE *)a1 + 8);
  if ( (v3 & 2) != 0 )
  {
    v4 = *a1;
    LOBYTE(v2) = *((_BYTE *)a1 + 9);
    if ( (_BYTE)v2 == 8 )
    {
      if ( v3 == 2 )
      {
        v2 = a2;
        if ( v4 )
        {
          v5 = *a1;
          do
          {
            v6 = *v2;
            *v2 = v2[2];
            v2[2] = v6;
            v2 += 3;
            --v5;
          }
          while ( v5 );
        }
      }
      else if ( v3 == 6 )
      {
        v2 = a2;
        if ( v4 )
        {
          v7 = *a1;
          do
          {
            v8 = *v2;
            *v2 = v2[2];
            v2[2] = v8;
            v2 += 4;
            --v7;
          }
          while ( v7 );
        }
      }
    }
    else if ( (_BYTE)v2 == 16 )
    {
      if ( v3 == 2 )
      {
        if ( v4 )
        {
          v2 = a2 + 1;
          v9 = *a1;
          do
          {
            v10 = *(v2 - 1);
            *(v2 - 1) = v2[3];
            v11 = v2[4];
            v2[3] = v10;
            v12 = *v2;
            *v2 = v11;
            v2[4] = v12;
            v2 += 6;
            --v9;
          }
          while ( v9 );
        }
      }
      else if ( v3 == 6 && v4 )
      {
        v2 = a2 + 1;
        v13 = *a1;
        do
        {
          v14 = *(v2 - 1);
          *(v2 - 1) = v2[3];
          v15 = v2[4];
          v2[3] = v14;
          v16 = *v2;
          *v2 = v15;
          v2[4] = v16;
          v2 += 8;
          --v13;
        }
        while ( v13 );
      }
    }
  }
  return (char)v2;
}

// sub_1001ED4A @ 0x1001ED4A
int __cdecl sub_1001ED4A(int a1, double a2, double a3)
{
  int result; // eax

  result = a1;
  if ( fabs(a2 * a3 - 1.0) > 0.05 )
    *(_BYTE *)(a1 + 97) |= 0x20u;
  *(float *)(a1 + 304) = a3;
  *(float *)(a1 + 308) = a2;
  return result;
}

// sub_1001ED80 @ 0x1001ED80
int __cdecl sub_1001ED80(int a1)
{
  *(_BYTE *)(a1 + 97) |= 0x10u;
  return a1;
}

// sub_1001ED89 @ 0x1001ED89
unsigned int __cdecl sub_1001ED89(int a1, int a2)
{
  char v2; // dl
  char v3; // dl
  char v4; // dl
  unsigned __int8 v5; // al
  unsigned int result; // eax

  if ( (*(_BYTE *)(a1 + 97) & 0x10) != 0 )
  {
    v2 = *(_BYTE *)(a2 + 25);
    if ( v2 == 3 )
    {
      *(_BYTE *)(a2 + 25) = 4 * (*(_WORD *)(a1 + 266) != 0) + 2;
    }
    else
    {
      if ( *(_WORD *)(a1 + 266) )
        *(_BYTE *)(a2 + 25) = v2 | 4;
      if ( *(_BYTE *)(a2 + 24) >= 8u )
        goto LABEL_8;
    }
    *(_BYTE *)(a2 + 24) = 8;
LABEL_8:
    *(_WORD *)(a2 + 22) = 0;
  }
  if ( (*(_BYTE *)(a1 + 97) & 0x20) != 0 )
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 304);
  if ( (*(_BYTE *)(a1 + 97) & 4) != 0 && *(_BYTE *)(a2 + 24) == 16 )
    *(_BYTE *)(a2 + 24) = 8;
  if ( (*(_BYTE *)(a1 + 96) & 0x40) != 0 )
  {
    v3 = *(_BYTE *)(a2 + 25);
    if ( (v3 == 2 || v3 == 6) && *(_DWORD *)(a1 + 372) && *(_BYTE *)(a2 + 24) == 8 )
      *(_BYTE *)(a2 + 25) = 3;
  }
  if ( (*(_BYTE *)(a1 + 96) & 4) != 0 && *(_BYTE *)(a2 + 24) < 8u )
    *(_BYTE *)(a2 + 24) = 8;
  v4 = *(_BYTE *)(a2 + 25);
  if ( v4 == 3 || (v4 & 2) == 0 )
    *(_BYTE *)(a2 + 29) = 1;
  else
    *(_BYTE *)(a2 + 29) = 3;
  if ( (v4 & 4) != 0 )
    ++*(_BYTE *)(a2 + 29);
  if ( *(char *)(a1 + 97) < 0 && (v4 == 2 || !v4) )
    ++*(_BYTE *)(a2 + 29);
  v5 = *(_BYTE *)(a2 + 29) * *(_BYTE *)(a2 + 24);
  *(_BYTE *)(a2 + 30) = v5;
  result = (*(_DWORD *)a2 * (unsigned int)v5 + 7) >> 3;
  *(_DWORD *)(a2 + 12) = result;
  return result;
}

// sub_1001EE74 @ 0x1001EE74
void __cdecl sub_1001EE74(int *a1, int a2)
{
  int *v2; // ebx
  unsigned __int8 v3; // cl
  int v4; // eax
  int v5; // ecx
  int v6; // ecx
  _BYTE *v7; // esi
  _BYTE *v8; // edi
  int v9; // edx
  _BYTE *v10; // esi
  _BYTE *v11; // edi
  int v12; // edx
  _BYTE *v13; // esi
  _BYTE *v14; // edi
  int v15; // edx
  unsigned __int8 v16; // dl
  int v17; // [esp+4h] [ebp-4h]
  int v18; // [esp+4h] [ebp-4h]
  int v19; // [esp+4h] [ebp-4h]

  v2 = a1;
  v3 = *((_BYTE *)a1 + 9);
  if ( v3 < 8u )
  {
    v4 = *a1;
    v5 = v3 - 1;
    if ( v5 )
    {
      v6 = v5 - 1;
      if ( v6 )
      {
        if ( v6 != 2 )
          goto LABEL_26;
        v7 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 1));
        v8 = (_BYTE *)(v4 + a2 - 1);
        v9 = 4 - 4 * ((v4 - 1) & 1);
        if ( !v4 )
          goto LABEL_26;
        v17 = *a1;
        do
        {
          *v8 = (*v7 >> v9) & 0xF;
          if ( v9 == 4 )
          {
            v9 = 0;
            --v7;
          }
          else
          {
            v9 = 4;
          }
          --v8;
          --v17;
        }
        while ( v17 );
        goto LABEL_25;
      }
      v10 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 2));
      v11 = (_BYTE *)(v4 + a2 - 1);
      v12 = 6 - 2 * ((v4 - 1) & 3);
      if ( v4 )
      {
        v18 = *a1;
        do
        {
          *v11 = (*v10 >> v12) & 3;
          if ( v12 == 6 )
          {
            v12 = 0;
            --v10;
          }
          else
          {
            v12 += 2;
          }
          --v11;
          --v18;
        }
        while ( v18 );
LABEL_25:
        v2 = a1;
      }
    }
    else
    {
      v13 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 3));
      v14 = (_BYTE *)(v4 + a2 - 1);
      v15 = 7 - ((v4 - 1) & 7);
      if ( v4 )
      {
        v19 = *a1;
        do
        {
          *v14 = (*v13 >> v15) & 1;
          if ( v15 == 7 )
          {
            v15 = 0;
            --v13;
          }
          else
          {
            ++v15;
          }
          --v14;
          --v19;
        }
        while ( v19 );
        goto LABEL_25;
      }
    }
LABEL_26:
    v16 = *((_BYTE *)v2 + 10);
    *((_BYTE *)v2 + 9) = 8;
    *((_BYTE *)v2 + 11) = 8 * v16;
    v2[1] = v4 * v16;
  }
}

// sub_1001EF84 @ 0x1001EF84
char __cdecl sub_1001EF84(int *a1, _BYTE *a2, unsigned __int8 *a3)
{
  int i; // eax
  int v5; // edi
  bool v6; // zf
  int v7; // edx
  int v8; // ebx
  int v9; // ebx
  int v10; // ecx
  unsigned __int8 *v11; // esi
  _BYTE *v12; // esi
  _BYTE *v13; // esi
  unsigned int j; // edi
  int v15; // esi
  _BYTE *v16; // edi
  int v17; // esi
  _DWORD v19[4]; // [esp+4h] [ebp-14h] BYREF
  unsigned int v20; // [esp+14h] [ebp-4h]
  __int16 v21; // [esp+20h] [ebp+8h]
  unsigned int k; // [esp+20h] [ebp+8h]
  unsigned int v23; // [esp+20h] [ebp+8h]

  LOBYTE(i) = *((_BYTE *)a1 + 8);
  if ( (_BYTE)i != 3 )
  {
    v21 = 0;
    v5 = *a1;
    v6 = (i & 2) == 0;
    LOBYTE(i) = (_BYTE)a3;
    if ( v6 )
    {
      v7 = *((unsigned __int8 *)a1 + 9) - a3[3];
      v9 = 1;
    }
    else
    {
      v7 = *((unsigned __int8 *)a1 + 9) - *a3;
      v8 = a3[2];
      v19[1] = *((unsigned __int8 *)a1 + 9) - a3[1];
      v19[2] = *((unsigned __int8 *)a1 + 9) - v8;
      v9 = 3;
    }
    v6 = (a1[2] & 4) == 0;
    v19[0] = v7;
    if ( !v6 )
    {
      i = *((unsigned __int8 *)a1 + 9) - a3[4];
      v19[v9] = i;
      LOBYTE(v7) = v19[0];
      ++v9;
    }
    v10 = 0;
    if ( v9 > 0 )
    {
      do
      {
        i = (int)&v19[v10];
        if ( *(int *)i > 0 )
        {
          v21 = 1;
        }
        else
        {
          *(_DWORD *)i = 0;
          LOBYTE(v7) = v19[0];
        }
        ++v10;
      }
      while ( v10 < v9 );
      if ( v21 )
      {
        if ( *((_BYTE *)a1 + 9) == 2 )
        {
          v17 = a1[1];
          for ( i = (int)a2; v17; --v17 )
          {
            *(_BYTE *)i = (*(_BYTE *)i >> 1) & 0x55;
            ++i;
          }
        }
        else if ( *((_BYTE *)a1 + 9) == 4 )
        {
          v15 = a1[1];
          v16 = a2;
          for ( LOBYTE(i) = (15 >> v7) | (240 >> v7) & 0xF0; v15; --v15 )
          {
            *v16 = i & (*v16 >> v7);
            ++v16;
          }
        }
        else
        {
          LOBYTE(i) = *((_BYTE *)a1 + 9) - 8;
          if ( *((_BYTE *)a1 + 9) == 8 )
          {
            v13 = a2;
            v23 = v9 * v5;
            for ( j = 0; j < v23; ++j )
            {
              i = j / v9;
              *v13++ >>= LOBYTE(v19[j % v9]);
            }
          }
          else
          {
            LOBYTE(i) = *((_BYTE *)a1 + 9) - 16;
            if ( *((_BYTE *)a1 + 9) == 16 )
            {
              v11 = a2;
              v20 = v9 * v5;
              for ( k = 0; k < v20; LOBYTE(i) = k )
              {
                LOWORD(i) = (unsigned __int16)(v11[1] + (*v11 << 8)) >> LOWORD(v19[k % v9]);
                *v11 = BYTE1(i);
                v12 = v11 + 1;
                *v12 = i;
                v11 = v12 + 1;
                ++k;
              }
            }
          }
        }
      }
    }
  }
  return i;
}

// sub_1001F0FB @ 0x1001F0FB
int __cdecl sub_1001F0FB(int a1, _BYTE *a2)
{
  int result; // eax
  _BYTE *v3; // esi
  char *v4; // edx
  int v5; // edi
  char v6; // cl
  unsigned __int8 v7; // dl
  int v8; // ecx

  result = a1;
  if ( *(_BYTE *)(a1 + 9) == 16 )
  {
    v3 = a2;
    v4 = a2;
    if ( *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10) )
    {
      v5 = *(_DWORD *)a1 * *(unsigned __int8 *)(a1 + 10);
      do
      {
        v6 = *v4;
        v4 += 2;
        *v3++ = v6;
        --v5;
      }
      while ( v5 );
    }
    v7 = *(_BYTE *)(a1 + 10);
    v8 = *(_DWORD *)a1 * v7;
    *(_BYTE *)(a1 + 9) = 8;
    *(_BYTE *)(a1 + 11) = 8 * v7;
    *(_DWORD *)(a1 + 4) = v8;
  }
  return result;
}

// sub_1001F13F @ 0x1001F13F
unsigned int __cdecl sub_1001F13F(int a1, int a2, unsigned int a3, char a4)
{
  char v4; // dl
  char v6; // cl
  unsigned int result; // eax
  unsigned int v8; // ebx
  char v9; // cl
  _BYTE *v10; // ecx
  _BYTE *v11; // edi
  _BYTE *v12; // edi
  bool v13; // zf
  _BYTE *v14; // edi
  _BYTE *v15; // ecx
  _BYTE *v16; // edi
  _BYTE *v17; // ecx
  _BYTE *v18; // edi
  _BYTE *v19; // ecx
  char *v20; // edi
  char v21; // cl
  char *v22; // edi
  char v23; // cl
  _BYTE *v24; // ecx
  _BYTE *v25; // edi
  _BYTE *v26; // edi
  _BYTE *v27; // ecx
  char v28; // bl
  _BYTE *v29; // edi
  _BYTE *v30; // ecx
  _BYTE *v31; // edi
  _BYTE *v32; // ecx
  _BYTE *v33; // edi
  _BYTE *v34; // ecx
  _BYTE *v35; // ecx
  _BYTE *v36; // edi
  char v37; // bl
  _BYTE *v38; // ecx
  _BYTE *v39; // edi
  _BYTE *v40; // ecx
  unsigned int v41; // [esp+18h] [ebp+8h]
  unsigned int v42; // [esp+18h] [ebp+8h]
  char *v43; // [esp+18h] [ebp+8h]
  char *v44; // [esp+18h] [ebp+8h]
  unsigned int v45; // [esp+18h] [ebp+8h]
  unsigned int v46; // [esp+18h] [ebp+8h]
  char v47; // [esp+1Bh] [ebp+Bh]
  unsigned int v48; // [esp+20h] [ebp+10h]
  unsigned int v49; // [esp+20h] [ebp+10h]
  unsigned int v50; // [esp+20h] [ebp+10h]
  unsigned int v51; // [esp+20h] [ebp+10h]

  v4 = a3;
  v6 = *(_BYTE *)(a1 + 8);
  result = *(_DWORD *)a1;
  v8 = a3 >> 8;
  v47 = BYTE1(a3);
  if ( v6 )
  {
    if ( v6 != 2 )
      return result;
    v23 = *(_BYTE *)(a1 + 9);
    if ( v23 == 8 )
    {
      if ( a4 >= 0 )
      {
        v29 = (_BYTE *)(a2 + 2 * result + result);
        v30 = &v29[result];
        if ( result )
        {
          v46 = result;
          do
          {
            v31 = v29 - 1;
            v32 = v30 - 1;
            *v32 = *v31--;
            *--v32 = *v31;
            v29 = v31 - 1;
            *--v32 = *v29;
            v30 = v32 - 1;
            v13 = v46-- == 1;
            *v30 = a3;
          }
          while ( !v13 );
        }
      }
      else
      {
        v24 = (_BYTE *)(a2 + 2 * result + result);
        v25 = &v24[result];
        if ( result > 1 )
        {
          v45 = result - 1;
          do
          {
            v26 = v25 - 1;
            *v26 = a3;
            v27 = v24 - 1;
            *--v26 = *v27;
            v28 = *--v27;
            --v26;
            v24 = v27 - 1;
            *v26 = v28;
            v25 = v26 - 1;
            v13 = v45-- == 1;
            *v25 = *v24;
          }
          while ( !v13 );
        }
        *(v25 - 1) = a3;
      }
      *(_BYTE *)(a1 + 11) = 32;
      result *= 4;
    }
    else
    {
      if ( v23 != 16 )
        return result;
      v33 = (_BYTE *)(a2 + 2 * result + result);
      v34 = &v33[result];
      if ( a4 >= 0 )
      {
        if ( result )
        {
          v51 = result;
          do
          {
            v39 = v33 - 1;
            v40 = v34 - 1;
            *v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39--;
            *--v40 = *v39;
            v33 = v39 - 1;
            *--v40 = *v33;
            *--v40 = v47;
            v34 = v40 - 1;
            v13 = v51-- == 1;
            *v34 = v4;
          }
          while ( !v13 );
        }
      }
      else
      {
        if ( result > 1 )
        {
          v50 = result - 1;
          do
          {
            v35 = v34 - 1;
            *v35-- = v47;
            *v35 = v4;
            v36 = v33 - 1;
            *--v35 = *v36--;
            *--v35 = *v36--;
            *--v35 = *v36--;
            *--v35 = *v36;
            v37 = *--v36;
            --v35;
            v33 = v36 - 1;
            *v35 = v37;
            v34 = v35 - 1;
            v13 = v50-- == 1;
            *v34 = *v33;
          }
          while ( !v13 );
          LOBYTE(v8) = v47;
        }
        v38 = v34 - 1;
        *v38 = v8;
        *(v38 - 1) = v4;
      }
      *(_BYTE *)(a1 + 11) = 64;
      result *= 8;
    }
    *(_BYTE *)(a1 + 10) = 4;
  }
  else
  {
    v9 = *(_BYTE *)(a1 + 9);
    if ( v9 == 8 )
    {
      v10 = (_BYTE *)(result + a2);
      v11 = (_BYTE *)(result + a2 + result);
      if ( a4 >= 0 )
      {
        if ( result )
        {
          v42 = result;
          do
          {
            --v10;
            v14 = v11 - 1;
            *v14 = *v10;
            v11 = v14 - 1;
            v13 = v42-- == 1;
            *v11 = a3;
          }
          while ( !v13 );
        }
      }
      else
      {
        if ( result > 1 )
        {
          v41 = result - 1;
          do
          {
            v12 = v11 - 1;
            --v10;
            *v12 = a3;
            v11 = v12 - 1;
            v13 = v41-- == 1;
            *v11 = *v10;
          }
          while ( !v13 );
        }
        *(v11 - 1) = a3;
      }
      *(_BYTE *)(a1 + 10) = 2;
      *(_BYTE *)(a1 + 11) = 16;
      result *= 2;
    }
    else
    {
      if ( v9 != 16 )
        return result;
      if ( a4 >= 0 )
      {
        v43 = (char *)(result + a2);
        v20 = (char *)(result + result + a2);
        if ( result )
        {
          v49 = result;
          do
          {
            v44 = v43 - 1;
            v21 = *v44;
            v22 = v20 - 1;
            v43 = v44 - 1;
            *v22-- = v21;
            *v22-- = *v43;
            *v22 = v8;
            v20 = v22 - 1;
            v13 = v49-- == 1;
            *v20 = v4;
          }
          while ( !v13 );
        }
      }
      else
      {
        v15 = (_BYTE *)(result + result + a2);
        if ( result > 1 )
        {
          v48 = result - 1;
          v16 = (_BYTE *)(result + a2);
          do
          {
            v17 = v15 - 1;
            *v17-- = v8;
            *v17 = v4;
            v18 = v16 - 1;
            *--v17 = *v18;
            v16 = v18 - 1;
            v15 = v17 - 1;
            v13 = v48-- == 1;
            *v15 = *v16;
            LOBYTE(v8) = v47;
          }
          while ( !v13 );
        }
        v19 = v15 - 1;
        *v19 = v8;
        *(v19 - 1) = v4;
      }
      *(_BYTE *)(a1 + 10) = 2;
      *(_BYTE *)(a1 + 11) = 32;
      result *= 4;
    }
  }
  *(_DWORD *)(a1 + 4) = result;
  return result;
}

// sub_1001F377 @ 0x1001F377
unsigned __int8 *__cdecl sub_1001F377(int *a1, _BYTE *a2, unsigned __int8 *a3, int a4, char a5)
{
  unsigned __int8 *result; // eax
  int *v6; // edi
  unsigned __int8 v7; // cl
  int v8; // edx
  _BYTE *v9; // ecx
  int v10; // esi
  _BYTE *v11; // ecx
  __int16 v12; // cx
  unsigned __int8 *v13; // eax
  __int16 v14; // cx
  __int16 v15; // cx
  _BYTE *v16; // ecx
  int v17; // esi
  __int16 v18; // cx
  _BYTE *v19; // ecx
  int v20; // esi
  _BYTE *v21; // ecx
  __int16 v22; // cx
  unsigned __int8 *v23; // eax
  __int16 v24; // cx
  __int16 v25; // cx
  char v26; // cl
  int v27; // edx
  int v28; // edi
  char *v29; // ecx
  bool v30; // zf
  char v31; // cl
  _BYTE *v32; // esi
  unsigned int v33; // edi
  _BYTE *v34; // ecx
  int v35; // esi
  __int16 v36; // cx
  int v37; // [esp+8h] [ebp-14h]
  unsigned int v38; // [esp+14h] [ebp-8h]
  char *v39; // [esp+18h] [ebp-4h]
  int v40; // [esp+24h] [ebp+8h]
  int v41; // [esp+24h] [ebp+8h]

  result = a3;
  v6 = a1;
  v7 = *((_BYTE *)a1 + 9);
  v8 = *a1;
  v37 = *a1;
  if ( v7 <= 8u && a3 || v7 == 16 && a4 )
  {
    if ( *((_BYTE *)a1 + 8) )
    {
      switch ( *((_BYTE *)a1 + 8) )
      {
        case 2:
          if ( v7 == 8 )
          {
            v19 = a2;
            if ( v8 )
            {
              v20 = *a1;
              do
              {
                *v19 = a3[(unsigned __int8)*v19];
                v21 = v19 + 1;
                *v21 = a3[(unsigned __int8)*v21];
                ++v21;
                *v21 = a3[(unsigned __int8)*v21];
                v19 = v21 + 1;
                --v20;
              }
              while ( v20 );
            }
          }
          else
          {
            result = a2;
            if ( v8 )
            {
              v41 = *a1;
              do
              {
                v22 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                result[1] = v22;
                *result = HIBYTE(v22);
                v23 = result + 2;
                v24 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                v23[1] = v24;
                *v23 = HIBYTE(v24);
                v23 += 2;
                v25 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v23[1] >> a5)) + 2 * *v23);
                *v23 = HIBYTE(v25);
                v23[1] = v25;
                result = v23 + 2;
                --v41;
              }
              while ( v41 );
            }
          }
          break;
        case 4:
          if ( v7 == 8 )
          {
            v16 = a2;
            if ( v8 )
            {
              v17 = *a1;
              do
              {
                *v16 = a3[(unsigned __int8)*v16];
                v16 += 2;
                --v17;
              }
              while ( v17 );
            }
          }
          else
          {
            for ( result = a2; v8; --v8 )
            {
              v18 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
              *result = HIBYTE(v18);
              result[1] = v18;
              result += 4;
            }
          }
          break;
        case 6:
          if ( v7 == 8 )
          {
            v9 = a2;
            if ( v8 )
            {
              v10 = *a1;
              do
              {
                *v9 = a3[(unsigned __int8)*v9];
                v11 = v9 + 1;
                *v11 = a3[(unsigned __int8)*v11];
                ++v11;
                *v11 = a3[(unsigned __int8)*v11];
                v9 = v11 + 2;
                --v10;
              }
              while ( v10 );
            }
          }
          else
          {
            result = a2;
            if ( v8 )
            {
              v40 = *a1;
              do
              {
                v12 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
                result[1] = v12;
                *result = HIBYTE(v12);
                v13 = result + 2;
                v14 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                v13[1] = v14;
                *v13 = HIBYTE(v14);
                v13 += 2;
                v15 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (v13[1] >> a5)) + 2 * *v13);
                *v13 = HIBYTE(v15);
                v13[1] = v15;
                result = v13 + 4;
                --v40;
              }
              while ( v40 );
            }
          }
          break;
      }
    }
    else
    {
      if ( v7 == 2 )
      {
        v39 = a2;
        if ( v8 )
        {
          v38 = ((unsigned int)(v8 - 1) >> 2) + 1;
          do
          {
            v26 = *v39;
            v27 = *v39 & 0xC;
            v28 = *v39 & 0x30;
            LOBYTE(v27) = a3[*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0 | ((*v39 & 0xC0) >> 2)) >> 2)) >> 2)] & 0xC0
                        | ((unsigned __int8)(a3[v28 | (4 * v28) | ((v28 | (v28 >> 2)) >> 2)] & 0xC3
                                           | ((unsigned __int8)((a3[v26 & 3
                                                                  | (4 * (v26 & 3 | (4 * (v26 & 3 | (4 * (v26 & 3))))))] >> 2)
                                                              | a3[v27 | (v27 >> 2) | (4 * (v27 | (4 * (v26 & 0xC))))]
                                                              & 0xCF) >> 2)) >> 2);
            v29 = v39++;
            v30 = v38-- == 1;
            *v29 = v27;
          }
          while ( !v30 );
          v8 = v37;
          v6 = a1;
        }
      }
      v31 = *((_BYTE *)v6 + 9);
      switch ( v31 )
      {
        case 4:
          v32 = a2;
          if ( v8 )
          {
            v33 = ((unsigned int)(v8 - 1) >> 1) + 1;
            do
            {
              *v32 = (a3[*v32 & 0xF | (16 * (*v32 & 0xF))] >> 4) | a3[*v32 & 0xF0 | ((*v32 & 0xF0) >> 4)] & 0xF0;
              ++v32;
              --v33;
            }
            while ( v33 );
          }
          break;
        case 8:
          v34 = a2;
          if ( v8 )
          {
            v35 = v8;
            do
            {
              *v34 = a3[(unsigned __int8)*v34];
              ++v34;
              --v35;
            }
            while ( v35 );
          }
          break;
        case 16:
          for ( result = a2; v8; --v8 )
          {
            v36 = *(_WORD *)(*(_DWORD *)(a4 + 4 * (result[1] >> a5)) + 2 * *result);
            *result = HIBYTE(v36);
            result[1] = v36;
            result += 2;
          }
          break;
      }
    }
  }
  return result;
}

// sub_1001F6C5 @ 0x1001F6C5
int __cdecl sub_1001F6C5(int *a1, int a2, int a3, int a4, int a5)
{
  int result; // eax
  unsigned __int8 v7; // cl
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  _BYTE *v11; // edx
  bool v12; // zf
  int v13; // ecx
  _BYTE *v14; // edx
  int v15; // ecx
  _BYTE *v16; // edx
  unsigned __int8 *v17; // edx
  int v18; // ebx
  _BYTE *v19; // ecx
  _BYTE *v20; // ecx
  _BYTE *v21; // ecx
  _BYTE *v22; // ecx
  int v23; // [esp+4h] [ebp-8h]
  int v24; // [esp+4h] [ebp-8h]
  int v25; // [esp+4h] [ebp-8h]
  int v26; // [esp+4h] [ebp-8h]
  int v27; // [esp+4h] [ebp-8h]
  _BYTE *v28; // [esp+8h] [ebp-4h]
  _BYTE *v29; // [esp+8h] [ebp-4h]
  _BYTE *v30; // [esp+8h] [ebp-4h]
  int v31; // [esp+14h] [ebp+8h]
  int v32; // [esp+14h] [ebp+8h]
  int v33; // [esp+14h] [ebp+8h]
  int v34; // [esp+14h] [ebp+8h]
  int v35; // [esp+14h] [ebp+8h]

  result = *a1;
  if ( *((_BYTE *)a1 + 8) == 3 )
  {
    v7 = *((_BYTE *)a1 + 9);
    if ( v7 < 8u )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          if ( v9 == 2 )
          {
            v28 = (_BYTE *)(result + a2 - 1);
            LOBYTE(v10) = 4 * (result & 1);
            v11 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 1));
            v31 = 4 * (*a1 & 1);
            if ( result )
            {
              v23 = result;
              do
              {
                *v28 = (*v11 >> v10) & 0xF;
                if ( v31 == 4 )
                {
                  v10 = 0;
                  --v11;
                }
                else
                {
                  v10 = v31 + 4;
                }
                --v28;
                v12 = v23-- == 1;
                v31 = v10;
              }
              while ( !v12 );
            }
          }
        }
        else
        {
          v29 = (_BYTE *)(result + a2 - 1);
          LOBYTE(v13) = 2 * (3 - ((result - 1) & 3));
          v14 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 2));
          v32 = 2 * (3 - (((_BYTE)result - 1) & 3));
          if ( result )
          {
            v24 = result;
            do
            {
              *v29 = (*v14 >> v13) & 3;
              if ( v32 == 6 )
              {
                v13 = 0;
                --v14;
              }
              else
              {
                v13 = v32 + 2;
              }
              --v29;
              v12 = v24-- == 1;
              v32 = v13;
            }
            while ( !v12 );
          }
        }
      }
      else
      {
        v30 = (_BYTE *)(result + a2 - 1);
        LOBYTE(v15) = 7 - ((result - 1) & 7);
        v16 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 3));
        v33 = 7 - (((_BYTE)result - 1) & 7);
        if ( result )
        {
          v25 = result;
          do
          {
            *v30 = (*v16 >> v15) & 1;
            if ( v33 == 7 )
            {
              v15 = 0;
              --v16;
            }
            else
            {
              v15 = v33 + 1;
            }
            --v30;
            v12 = v25-- == 1;
            v33 = v15;
          }
          while ( !v12 );
        }
      }
      *((_BYTE *)a1 + 9) = 8;
      *((_BYTE *)a1 + 11) = 8;
      a1[1] = result;
    }
    if ( *((_BYTE *)a1 + 9) == 8 )
    {
      v17 = (unsigned __int8 *)(result + a2 - 1);
      if ( a4 )
      {
        v18 = 4 * result;
        v26 = 4 * result;
        v19 = (_BYTE *)(4 * result + a2 - 1);
        if ( result )
        {
          v34 = result;
          result = a3;
          do
          {
            if ( *v17 < a5 )
              *v19 = *(_BYTE *)(*v17 + a4);
            else
              *v19 = -1;
            v20 = v19 - 1;
            *v20-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 2);
            *v20-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 1);
            *v20 = *(_BYTE *)(*v17 + a3 + 2 * *v17);
            v19 = v20 - 1;
            --v17;
            --v34;
          }
          while ( v34 );
          v18 = v26;
        }
        *((_BYTE *)a1 + 11) = 32;
        *((_BYTE *)a1 + 8) = 6;
        *((_BYTE *)a1 + 10) = 4;
      }
      else
      {
        v18 = 3 * result;
        v27 = 3 * result;
        v21 = (_BYTE *)(3 * result + a2 - 1);
        if ( result )
        {
          v35 = result;
          result = a3;
          do
          {
            *v21 = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 2);
            v22 = v21 - 1;
            *v22-- = *(_BYTE *)(*v17 + a3 + 2 * *v17 + 1);
            *v22 = *(_BYTE *)(*v17 + a3 + 2 * *v17);
            v21 = v22 - 1;
            --v17;
            --v35;
          }
          while ( v35 );
          v18 = v27;
        }
        *((_BYTE *)a1 + 11) = 24;
        *((_BYTE *)a1 + 8) = 2;
        *((_BYTE *)a1 + 10) = 3;
      }
      *((_BYTE *)a1 + 9) = 8;
      a1[1] = v18;
    }
  }
  return result;
}

// sub_1001F8CD @ 0x1001F8CD
int __cdecl sub_1001F8CD(int *a1, int a2, _WORD *a3)
{
  char v4; // cl
  int result; // eax
  unsigned __int16 v6; // bx
  unsigned __int8 v7; // cl
  int v8; // ecx
  int v9; // ecx
  int v10; // ecx
  unsigned __int8 *v11; // edx
  bool v12; // zf
  int v13; // ecx
  unsigned __int8 *v14; // edx
  char v15; // bl
  int v16; // ecx
  _BYTE *v17; // edx
  char v18; // cl
  _BYTE *v19; // ecx
  _BYTE *v20; // edi
  int v21; // edx
  _BYTE *v22; // edi
  int v23; // edx
  _BYTE *v24; // ecx
  _BYTE *v25; // edi
  unsigned __int16 v26; // bx
  _BYTE *v27; // edi
  _BYTE *v28; // edi
  char v29; // cl
  unsigned __int8 v30; // cl
  _WORD *v31; // edx
  char v32; // cl
  _BYTE *v33; // ecx
  _BYTE *v34; // edi
  _BYTE *v35; // edi
  _BYTE *v36; // ecx
  _BYTE *v37; // ecx
  _BYTE *v38; // edi
  __int16 v39; // bx
  __int16 v40; // dx
  __int16 v41; // dx
  _BYTE *v42; // edi
  _BYTE *v43; // edi
  _BYTE *v44; // ecx
  char v45; // cl
  int v46; // [esp+Ch] [ebp-Ch]
  int v47; // [esp+Ch] [ebp-Ch]
  int v48; // [esp+Ch] [ebp-Ch]
  int v49; // [esp+Ch] [ebp-Ch]
  unsigned __int16 v50; // [esp+10h] [ebp-8h]
  _BYTE *v51; // [esp+14h] [ebp-4h]
  _BYTE *v52; // [esp+14h] [ebp-4h]
  _BYTE *v53; // [esp+14h] [ebp-4h]
  int v54; // [esp+20h] [ebp+8h]
  int v55; // [esp+20h] [ebp+8h]
  int v56; // [esp+20h] [ebp+8h]
  int v57; // [esp+20h] [ebp+8h]
  int v58; // [esp+20h] [ebp+8h]
  int v59; // [esp+20h] [ebp+8h]

  v4 = *((_BYTE *)a1 + 8);
  result = *a1;
  if ( v4 )
  {
    if ( v4 == 2 )
    {
      v31 = a3;
      if ( a3 )
      {
        v32 = *((_BYTE *)a1 + 9);
        if ( v32 == 8 )
        {
          v33 = (_BYTE *)(a1[1] + a2 - 1);
          v34 = (_BYTE *)(a2 + 4 * result - 1);
          if ( result )
          {
            v58 = *a1;
            do
            {
              if ( (unsigned __int8)*(v33 - 2) == a3[1]
                && (unsigned __int8)*(v33 - 1) == a3[2]
                && (unsigned __int8)*v33 == a3[3] )
              {
                *v34 = 0;
              }
              else
              {
                *v34 = -1;
              }
              v35 = v34 - 1;
              *v35-- = *v33;
              v36 = v33 - 1;
              *v35-- = *v36;
              *v35 = *--v36;
              v34 = v35 - 1;
              v33 = v36 - 1;
              --v58;
            }
            while ( v58 );
          }
        }
        else if ( v32 == 16 )
        {
          v37 = (_BYTE *)(a1[1] + a2 - 1);
          v38 = (_BYTE *)(a2 + 8 * result - 1);
          if ( result )
          {
            v59 = *a1;
            while ( 1 )
            {
              HIBYTE(v39) = *(v37 - 5);
              LOBYTE(v39) = *(v37 - 4);
              if ( v39 == v31[1]
                && (HIBYTE(v40) = *(v37 - 3), LOBYTE(v40) = *(v37 - 2), v40 == a3[2])
                && (HIBYTE(v41) = *(v37 - 1), LOBYTE(v41) = *v37, v41 == a3[3]) )
              {
                *v38 = 0;
                v42 = v38 - 1;
                *v42 = 0;
              }
              else
              {
                *v38 = -1;
                v42 = v38 - 1;
                *v42 = -1;
              }
              v43 = v42 - 1;
              *v43-- = *v37;
              v44 = v37 - 1;
              *v43-- = *v44;
              *v43-- = *--v44;
              *v43-- = *--v44;
              *v43-- = *--v44;
              *v43 = *--v44;
              v38 = v43 - 1;
              v37 = v44 - 1;
              if ( !--v59 )
                break;
              v31 = a3;
            }
          }
        }
        v45 = *((_BYTE *)a1 + 9);
        *((_BYTE *)a1 + 8) = 6;
        *((_BYTE *)a1 + 10) = 4;
        v30 = 4 * v45;
        goto LABEL_68;
      }
    }
  }
  else
  {
    v6 = 0;
    if ( a3 )
      v6 = a3[4];
    v7 = *((_BYTE *)a1 + 9);
    v50 = v6;
    if ( v7 < 8u )
    {
      v8 = v7 - 1;
      if ( v8 )
      {
        v9 = v8 - 1;
        if ( v9 )
        {
          if ( v9 == 2 )
          {
            v51 = (_BYTE *)(result + a2 - 1);
            v50 = 17 * v6;
            LOBYTE(v10) = 4 - 4 * ((result - 1) & 1);
            v11 = (unsigned __int8 *)(a2 + ((unsigned int)(result - 1) >> 1));
            v54 = 4 - 4 * (((_BYTE)result - 1) & 1);
            if ( result )
            {
              v46 = result;
              do
              {
                *v51 = (*v11 >> v10) & 0xF | (16 * ((*v11 >> v10) & 0xF));
                v10 = 4;
                if ( v54 == 4 )
                {
                  v10 = 0;
                  --v11;
                }
                --v51;
                v12 = v46-- == 1;
                v54 = v10;
              }
              while ( !v12 );
            }
          }
        }
        else
        {
          v50 = 85 * v6;
          v52 = (_BYTE *)(result + a2 - 1);
          v13 = (unsigned __int8)(2 * (3 - ((result - 1) & 3)));
          v14 = (unsigned __int8 *)(a2 + ((unsigned int)(result - 1) >> 2));
          v55 = 2 * (3 - (((_BYTE)result - 1) & 3));
          if ( result )
          {
            v47 = result;
            do
            {
              v15 = (*v14 >> v13) & 3;
              *v52 = v15 | (4 * (v15 | (4 * (v15 | (4 * v15)))));
              if ( v55 == 6 )
              {
                v13 = 0;
                --v14;
              }
              else
              {
                v13 = v55 + 2;
              }
              --v52;
              v12 = v47-- == 1;
              v55 = v13;
            }
            while ( !v12 );
          }
        }
      }
      else
      {
        v50 = 255 * v6;
        v53 = (_BYTE *)(result + a2 - 1);
        v16 = (unsigned __int8)(7 - ((result - 1) & 7));
        v17 = (_BYTE *)(a2 + ((unsigned int)(result - 1) >> 3));
        v56 = 7 - (((_BYTE)result - 1) & 7);
        if ( result )
        {
          v48 = result;
          do
          {
            *v53 = -(((*v17 >> v16) & 1) != 0);
            if ( v56 == 7 )
            {
              v16 = 0;
              --v17;
            }
            else
            {
              v16 = v56 + 1;
            }
            --v53;
            v12 = v48-- == 1;
            v56 = v16;
          }
          while ( !v12 );
        }
      }
      v6 = v50;
      *((_BYTE *)a1 + 9) = 8;
      *((_BYTE *)a1 + 11) = 8;
      a1[1] = result;
    }
    if ( a3 )
    {
      v18 = *((_BYTE *)a1 + 9);
      if ( v18 == 8 )
      {
        v19 = (_BYTE *)(result + a2 - 1);
        v20 = (_BYTE *)(a2 + 2 * result - 1);
        if ( result )
        {
          v21 = result;
          do
          {
            if ( (unsigned __int8)*v19 == v50 )
              *v20 = 0;
            else
              *v20 = -1;
            v22 = v20 - 1;
            *v22 = *v19;
            v20 = v22 - 1;
            --v19;
            --v21;
          }
          while ( v21 );
        }
      }
      else if ( v18 == 16 )
      {
        v23 = a1[1];
        v24 = (_BYTE *)(v23 + a2 - 1);
        v25 = (_BYTE *)(a2 + 2 * v23 - 1);
        if ( result )
        {
          v49 = v6;
          v57 = result;
          do
          {
            HIBYTE(v26) = *(v24 - 1);
            LOBYTE(v26) = *v24;
            if ( v26 == v49 )
            {
              *v25 = 0;
              v27 = v25 - 1;
              *v27 = 0;
            }
            else
            {
              *v25 = -1;
              v27 = v25 - 1;
              *v27 = -1;
            }
            v28 = v27 - 1;
            *v28-- = *v24;
            *v28 = *(v24 - 1);
            v25 = v28 - 1;
            v24 -= 2;
            --v57;
          }
          while ( v57 );
        }
      }
      v29 = *((_BYTE *)a1 + 9);
      *((_BYTE *)a1 + 8) = 4;
      *((_BYTE *)a1 + 10) = 2;
      v30 = 2 * v29;
LABEL_68:
      *((_BYTE *)a1 + 11) = v30;
      a1[1] = (result * (unsigned int)v30) >> 3;
    }
  }
  return result;
}

// sub_1001FC1F @ 0x1001FC1F
int __cdecl sub_1001FC1F(int *a1, char *a2, int a3, int a4)
{
  char v5; // cl
  int result; // eax
  char *v7; // edx
  char v8; // al
  char *v9; // edx
  char v10; // bl
  char v11; // al
  char *v12; // esi
  bool v13; // zf
  unsigned __int8 v14; // cl
  char *v15; // edx
  char v16; // al
  char *v17; // edx
  char v18; // bl
  char v19; // al
  char *v20; // esi
  char *i; // ecx
  int v22; // [esp+Ch] [ebp-8h]
  int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  char *v25; // [esp+1Ch] [ebp+8h]
  char *v26; // [esp+1Ch] [ebp+8h]

  v5 = *((_BYTE *)a1 + 8);
  result = *a1;
  v22 = *a1;
  if ( v5 == 2 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v7 = a2;
    v25 = a2;
    if ( !result )
    {
LABEL_8:
      v14 = *((_BYTE *)a1 + 9);
      *((_BYTE *)a1 + 11) = v14;
      *((_BYTE *)a1 + 8) = 3;
      *((_BYTE *)a1 + 10) = 1;
      a1[1] = (result * (unsigned int)v14 + 7) >> 3;
      return result;
    }
    v23 = result;
    do
    {
      v8 = *v7;
      v9 = v7 + 1;
      v10 = *v9++;
      v11 = *(_BYTE *)((((int)(unsigned __int8)*v9 >> 3) & 0x1F | (4 * (v10 & 0xF8 | (32 * (v8 & 0xF8))))) + a3);
      v12 = v25;
      v7 = v9 + 1;
      ++v25;
      v13 = v23-- == 1;
      *v12 = v11;
    }
    while ( !v13 );
LABEL_7:
    result = v22;
    goto LABEL_8;
  }
  if ( v5 == 6 && a3 && *((_BYTE *)a1 + 9) == 8 )
  {
    v15 = a2;
    v26 = a2;
    if ( !result )
      goto LABEL_8;
    v24 = result;
    do
    {
      v16 = *v15;
      v17 = v15 + 1;
      v18 = *v17++;
      v19 = *(_BYTE *)((((int)(unsigned __int8)*v17 >> 3) & 0x1F | (4 * (v18 & 0xF8 | (32 * (v16 & 0xF8))))) + a3);
      v20 = v26;
      v15 = v17 + 2;
      ++v26;
      v13 = v24-- == 1;
      *v20 = v19;
    }
    while ( !v13 );
    goto LABEL_7;
  }
  if ( v5 == 3 )
  {
    if ( a4 )
    {
      if ( *((_BYTE *)a1 + 9) == 8 )
      {
        for ( i = a2; result; --result )
        {
          *i = *(_BYTE *)((unsigned __int8)*i + a4);
          ++i;
        }
      }
    }
  }
  return result;
}

// FUN_1001fd2d @ 0x1001FD2D
void __cdecl sub_1001FD2D(jmp_buf Buf)
{
  long double v2; // st7
  int v3; // eax
  __int64 v4; // rax
  int v5; // eax
  unsigned int v6; // edi
  int v7; // ebx
  long double v8; // st7
  int v9; // eax
  bool v10; // zf
  int v11; // eax
  int *__attribute__((__org_typedef(jmp_buf))) v12; // edx
  __int16 v13; // cx
  unsigned int v14; // ebx
  int v15; // eax
  int v16; // ebx
  __int64 v17; // rax
  double v18; // [esp+4h] [ebp-28h]
  unsigned int v19; // [esp+14h] [ebp-18h]
  unsigned int v20; // [esp+18h] [ebp-14h]
  char v21; // [esp+1Ch] [ebp-10h]
  unsigned int v22; // [esp+20h] [ebp-Ch]
  int v23; // [esp+28h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+34h] [ebp+8h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufb; // [esp+34h] [ebp+8h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufc; // [esp+34h] [ebp+8h]

  if ( *((float *)Buf + 76) != 0.0 )
  {
    if ( *((_BYTE *)Buf + 279) > 8u )
    {
      if ( (*((_BYTE *)Buf + 278) & 2) != 0 )
      {
        v5 = *((unsigned __int8 *)Buf + 336);
        if ( *((unsigned __int8 *)Buf + 337) > v5 )
          v5 = *((unsigned __int8 *)Buf + 337);
        if ( *((unsigned __int8 *)Buf + 338) > v5 )
          v5 = *((unsigned __int8 *)Buf + 338);
      }
      else
      {
        v5 = *((unsigned __int8 *)Buf + 339);
      }
      v6 = 0;
      if ( v5 <= 0 )
        v23 = 0;
      else
        v23 = 16 - v5;
      if ( (*((_BYTE *)Buf + 97) & 4) != 0 && v23 < 5 )
        v23 = 5;
      if ( v23 > 8 )
        v23 = 8;
      if ( v23 < 0 )
        v23 = 0;
      v7 = 1 << (8 - v23);
      v21 = 8 - v23;
      Buf[75] = (unsigned __int8)v23;
      if ( *((float *)Buf + 77) <= 0.000001 )
        v8 = 1.0;
      else
        v8 = 1.0 / (*((float *)Buf + 77) * *((float *)Buf + 76));
      v9 = png_malloc(Buf, 4 * v7);
      v10 = (Buf[24] & 0x480) == 0;
      Buf[81] = v9;
      Bufb = 0;
      if ( v10 )
      {
        if ( v7 > 0 )
        {
          do
          {
            *(_DWORD *)(Buf[81] + 4 * (_DWORD)Bufb) = png_malloc(Buf, 0x200u);
            v16 = 0;
            v22 = (unsigned int)((_DWORD)Bufb * dword_100544A0[v23]) >> 4;
            do
            {
              v17 = (__int64)(pow((double)v22 * 0.00001525902189669642, v8) * 65535.0 + 0.5);
              v22 += 256;
              *(_WORD *)(v16 + *(_DWORD *)(Buf[81] + 4 * (_DWORD)Bufb)) = v17;
              v16 += 2;
            }
            while ( v16 < 512 );
            Bufb = (int *)((char *)Bufb + 1);
          }
          while ( (int)Bufb < 1 << (8 - v23) );
        }
      }
      else
      {
        if ( v7 > 0 )
        {
          do
          {
            v11 = png_malloc(Buf, 0x200u);
            v12 = Bufb;
            Bufb = (int *)((char *)Bufb + 1);
            *(_DWORD *)(Buf[81] + 4 * (_DWORD)v12) = v11;
          }
          while ( (int)Bufb < v7 );
          v6 = 0;
        }
        Bufc = 0;
        v20 = v7 << 8;
        v18 = (double)(unsigned int)(v7 << 8);
        do
        {
          v19 = (__int64)(pow(((double)(int)Bufc + 0.5) * 0.00390625, 1.0 / v8) * v18);
          if ( v6 <= v19 )
          {
            LOBYTE(v13) = 0;
            HIBYTE(v13) = (_BYTE)Bufc;
            do
            {
              v14 = v6 >> v21;
              v15 = *(_DWORD *)(Buf[81] + 4 * (v6++ & (255 >> v23)));
              *(_WORD *)(v15 + 2 * v14) = (unsigned __int16)Bufc | v13;
            }
            while ( v6 <= v19 );
          }
          Bufc = (int *)((char *)Bufc + 1);
        }
        while ( (int)Bufc < 256 );
        for ( ; v6 < v20; ++v6 )
          *(_WORD *)(*(_DWORD *)(Buf[81] + 4 * (v6 & (255 >> v23))) + 2 * (v6 >> v21)) = -1;
      }
    }
    else
    {
      if ( *((float *)Buf + 77) <= 0.000001 )
        v2 = 1.0;
      else
        v2 = 1.0 / (*((float *)Buf + 77) * *((float *)Buf + 76));
      v3 = png_malloc(Buf, 0x100u);
      Bufa = 0;
      Buf[78] = v3;
      do
      {
        v4 = (__int64)(pow((double)(int)Bufa * 0.00392156862745098, v2) * 255.0 + 0.5);
        HIDWORD(v4) = Bufa;
        Bufa = (int *)((char *)Bufa + 1);
        *(_BYTE *)(HIDWORD(v4) + Buf[78]) = v4;
      }
      while ( (int)Bufa < 256 );
    }
  }
}

// FUN_10020036 @ 0x10020036
void __cdecl sub_10020036(jmp_buf Buf)
{
  int v2; // edi
  int v3; // ecx
  _BYTE *v4; // eax
  unsigned int v5; // ebx
  unsigned int v6; // eax
  unsigned int v7; // ecx
  unsigned __int16 v8; // cx
  int v9; // eax
  int v10; // edi
  char v11; // [esp+Ch] [ebp-4h]
  char Bufa; // [esp+18h] [ebp+8h]

  v2 = *((unsigned __int8 *)Buf + 278);
  if ( (Buf[24] & 0x602000) != 0 )
  {
    FUN_1001fd2d(Buf);
    if ( v2 == 3 )
    {
      v3 = *((unsigned __int16 *)Buf + 132);
      if ( *((_WORD *)Buf + 132) )
      {
        v4 = (_BYTE *)(Buf[65] + 2);
        do
        {
          *(v4 - 2) = *(_BYTE *)((unsigned __int8)*(v4 - 2) + Buf[78]);
          *(v4 - 1) = *(_BYTE *)((unsigned __int8)*(v4 - 1) + Buf[78]);
          *v4 = *(_BYTE *)((unsigned __int8)*v4 + Buf[78]);
          v4 += 3;
          --v3;
        }
        while ( v3 );
      }
    }
  }
  if ( (Buf[24] & 8) != 0 && v2 == 3 )
  {
    v5 = 8 - *((unsigned __int8 *)Buf + 336);
    v6 = 8 - *((unsigned __int8 *)Buf + 337);
    v7 = 8 - *((unsigned __int8 *)Buf + 338);
    Bufa = 8 - *((_BYTE *)Buf + 337);
    v11 = 8 - *((_BYTE *)Buf + 338);
    if ( v5 > 8 )
      LOBYTE(v5) = 0;
    if ( v6 > 8 )
      Bufa = 0;
    if ( v7 > 8 )
      v11 = 0;
    v8 = *((_WORD *)Buf + 132);
    if ( v8 )
    {
      v9 = 0;
      v10 = v8;
      do
      {
        *(_BYTE *)(v9 + Buf[65]) >>= v5;
        *(_BYTE *)(v9 + Buf[65] + 1) >>= Bufa;
        *(_BYTE *)(v9 + Buf[65] + 2) >>= v11;
        v9 += 3;
        --v10;
      }
      while ( v10 );
    }
  }
}

// FUN_10020149 @ 0x10020149
void __cdecl sub_10020149(jmp_buf Buf)
{
  if ( !Buf[55] )
    png_error(Buf, (int)"NULL row buffer");
  if ( (*((_BYTE *)Buf + 97) & 0x10) != 0 )
  {
    if ( *((_BYTE *)Buf + 248) == 3 )
    {
      sub_1001F6C5(Buf + 60, Buf[55] + 1, Buf[65], Buf[87], *((unsigned __int16 *)Buf + 133));
    }
    else if ( *((_WORD *)Buf + 133) )
    {
      sub_1001F8CD(Buf + 60, Buf[55] + 1, (_WORD *)Buf + 176);
    }
    else
    {
      sub_1001F8CD(Buf + 60, Buf[55] + 1, 0);
    }
  }
  if ( (*((_BYTE *)Buf + 97) & 0x20) != 0 && *((_BYTE *)Buf + 278) != 3 )
    sub_1001F377(Buf + 60, (_BYTE *)(Buf[55] + 1), (unsigned __int8 *)Buf[78], Buf[81], Buf[75]);
  if ( (*((_BYTE *)Buf + 97) & 4) != 0 )
    sub_1001F0FB((int)(Buf + 60), (_BYTE *)(Buf[55] + 1));
  if ( (Buf[24] & 0x40) != 0 )
  {
    sub_1001FC1F(Buf + 60, (char *)(Buf[55] + 1), Buf[93], Buf[94]);
    if ( !Buf[61] )
      png_error(Buf, (int)"png_do_dither returned rowbytes=0");
  }
  if ( (Buf[24] & 8) != 0 )
    sub_1001EF84(Buf + 60, (_BYTE *)(Buf[55] + 1), (unsigned __int8 *)Buf + 341);
  if ( (Buf[24] & 4) != 0 )
    sub_1001EE74(Buf + 60, Buf[55] + 1);
  if ( (Buf[24] & 1) != 0 )
    sub_1001EC8B(Buf + 60, (char *)(Buf[55] + 1));
  if ( *((char *)Buf + 97) < 0 )
    sub_1001F13F((int)(Buf + 60), Buf[55] + 1, *((unsigned __int16 *)Buf + 143), Buf[23]);
  if ( (Buf[24] & 0x10) != 0 )
    sub_1001EC5E((int)(Buf + 60), (char *)(Buf[55] + 1));
}

// sub_10020301 @ 0x10020301
void __cdecl sub_10020301(int a1, int a2, double a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 1u;
      *(float *)(a2 + 40) = a3;
    }
  }
}

// FUN_1002031c @ 0x1002031C
void __cdecl sub_1002031C(int a1, int a2, unsigned int a3, int a4, char a5, char a6, char a7, char a8, char a9)
{
  unsigned __int8 v9; // al

  if ( a1 && a2 )
  {
    *(_BYTE *)(a2 + 26) = a8;
    *(_DWORD *)(a2 + 4) = a4;
    *(_BYTE *)(a2 + 27) = a9;
    *(_DWORD *)a2 = a3;
    *(_BYTE *)(a2 + 24) = a5;
    *(_BYTE *)(a2 + 25) = a6;
    *(_BYTE *)(a2 + 28) = a7;
    if ( a6 == 3 || (a6 & 2) == 0 )
      *(_BYTE *)(a2 + 29) = 1;
    else
      *(_BYTE *)(a2 + 29) = 3;
    if ( (a6 & 4) != 0 )
      ++*(_BYTE *)(a2 + 29);
    v9 = a5 * *(_BYTE *)(a2 + 29);
    *(_BYTE *)(a2 + 30) = v9;
    if ( a3 <= 0x7FFFFFFFu / ((v9 + 7) >> 3) )
    {
      *(_DWORD *)(a2 + 12) = (a3 * v9 + 7) >> 3;
    }
    else
    {
      png_warning(a1, (int)"Width too large to process image data; rowbytes will overflow.");
      *(_DWORD *)(a2 + 12) = 0;
    }
  }
}

// sub_100203BD @ 0x100203BD
void __cdecl sub_100203BD(int a1, int a2, int a3, __int16 a4)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_DWORD *)(a2 + 8) |= 8u;
      *(_DWORD *)(a2 + 16) = a3;
      *(_WORD *)(a2 + 20) = a4;
    }
  }
}

// sub_100203E1 @ 0x100203E1
void __cdecl sub_100203E1(int a1, int a2, char a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      *(_BYTE *)(a2 + 9) |= 8u;
      *(_BYTE *)(a2 + 44) = a3;
    }
  }
}

// sub_100203FC @ 0x100203FC
void __cdecl sub_100203FC(int a1, __int64 a2)
{
  if ( a1 )
  {
    if ( (_DWORD)a2 )
    {
      sub_100203E1(a1, a2, SBYTE4(a2));
      sub_10020301(a1, a2, 0.4545499980449677);
    }
  }
}

// sub_10020435 @ 0x10020435
void __cdecl sub_10020435(int a1, int a2, int a3, int a4, int a5)
{
  if ( a1 && a2 )
  {
    if ( a3 )
      *(_DWORD *)(a2 + 48) = a3;
    if ( a5 )
    {
      *(_DWORD *)(a2 + 52) = *(_DWORD *)a5;
      *(_DWORD *)(a2 + 56) = *(_DWORD *)(a5 + 4);
      *(_WORD *)(a2 + 60) = *(_WORD *)(a5 + 8);
      if ( !a4 )
        LOWORD(a4) = 1;
    }
    *(_DWORD *)(a2 + 8) |= 0x10u;
    *(_WORD *)(a2 + 22) = a4;
  }
}

// png_read_data @ 0x1002047C
// png read callback wrapper (errors if NULL)
int __cdecl sub_1002047C(jmp_buf Buf, int a2, int a3)
{
  int (__cdecl *v3)(int *__attribute__((__org_typedef(jmp_buf))), int, int); // eax

  v3 = (int (__cdecl *)(int *__attribute__((__org_typedef(jmp_buf))), int, int))Buf[20];
  if ( !v3 )
    png_error(Buf, (int)"Call to NULL read function");
  return v3(Buf, a2, a3);
}

// FUN_100204a4 @ 0x100204A4
int (__cdecl *__cdecl sub_100204A4(_DWORD *a1, int a2, int (__cdecl *a3)(int, int)))(int, int)
{
  bool v3; // zf
  int (__cdecl *result)(int, int); // eax

  v3 = a1[19] == 0;
  a1[21] = a2;
  result = a3;
  a1[20] = a3;
  if ( !v3 )
  {
    a1[19] = 0;
    png_warning((int)a1, (int)"It's an error to set both read_data_fn and write_data_fn in the ");
    result = png_warning((int)a1, (int)"same structure.  Resetting write_data_fn to NULL.");
  }
  a1[72] = 0;
  return result;
}

// sub_100204E3 @ 0x100204E3
int __cdecl sub_100204E3(int a1, unsigned int a2, unsigned int a3)
{
  int v3; // ecx

  v3 = a3;
  if ( a3 <= 8 )
  {
    if ( !a3 )
      return 0;
  }
  else
  {
    v3 = 8;
  }
  if ( a2 > 7 )
    return 0;
  if ( a2 + v3 > 8 )
    v3 = 8 - a2;
  return memcmp((const char *)(a1 + a2), &byte_1004E51C[a2], v3);
}

// FUN_1002052b @ 0x1002052B
char *__cdecl sub_1002052B(jmp_buf Buf, int a2, int a3)
{
  unsigned int v3; // esi
  char *v4; // edx
  char *result; // eax
  void *v6; // edi
  unsigned int v7; // ecx

  v3 = a3 * a2;
  v4 = (char *)png_malloc(Buf, a3 * a2);
  result = 0;
  if ( v4 )
  {
    v6 = v4;
    if ( v3 <= 0x8000 )
    {
      v7 = a3 * a2;
    }
    else
    {
      memset(v4, 0, 0x8000u);
      v7 = v3 - 0x8000;
      v6 = v4 + 0x8000;
    }
    memset(v6, 0, v7);
    return v4;
  }
  return result;
}

// png_reset_crc @ 0x10020583
// reset png CRC state
int __cdecl sub_10020583(int a1)
{
  int result; // eax

  result = sub_10025AEC(0, 0, 0);
  *(_DWORD *)(a1 + 256) = result;
  return result;
}

// FUN_100205da @ 0x100205DA
// [binja] void sub_100205da(int32_t arg1)
int __cdecl sub_100205DA(int a1, void *a2)
{
  memset(a2, 0, 0x40u);
  return 0;
}

// sub_100205E8 @ 0x100205E8
void *__cdecl sub_100205E8(int a1)
{
  void *v2; // edx

  if ( !a1 )
    return 0;
  v2 = (void *)sub_100246F2(2);
  if ( v2 )
    memset(v2, 0, 0x40u);
  return v2;
}

// grim_dxt_decode_rgb565 @ 0x1002060E
// unpacks RGB565 into RGBA floats (alpha=1)
float *__usercall sub_1002060E@<eax>(float *result@<eax>, unsigned int a2@<ecx>)
{
  *result = (double)((unsigned __int16)a2 >> 11) * 0.032258064;
  result[1] = (double)((a2 >> 5) & 0x3F) * 0.015873017;
  result[2] = (double)(a2 & 0x1F) * 0.032258064;
  result[3] = 1.0;
  return result;
}

// grim_dxt_unpremultiply_rgba_block @ 0x1002065A
// divides rgb by alpha for a 4x4 RGBA block
int __fastcall sub_1002065A(float *a1)
{
  int v1; // edx
  double v2; // st7
  double v3; // st7
  double v4; // st6
  double v5; // st6

  v1 = 16;
  do
  {
    if ( 0.0 == a1[3] )
    {
      *a1 = 0.0;
      a1[1] = 0.0;
      v2 = 0.0;
    }
    else
    {
      if ( a1[3] >= 1.0 )
        goto LABEL_15;
      v3 = 1.0 / a1[3];
      if ( *a1 >= (double)a1[3] )
        v4 = 1.0;
      else
        v4 = v3 * *a1;
      *a1 = v4;
      if ( a1[1] >= (double)a1[3] )
        v5 = 1.0;
      else
        v5 = v3 * a1[1];
      a1[1] = v5;
      if ( a1[2] >= (double)a1[3] )
        v2 = 1.0;
      else
        v2 = v3 * a1[2];
    }
    a1[2] = v2;
LABEL_15:
    a1 += 4;
    --v1;
  }
  while ( v1 );
  return 0;
}

// grim_dxt_premultiply_rgba_block @ 0x100206D8
// multiplies rgb by alpha for a 4x4 RGBA block
int __usercall sub_100206D8@<eax>(float *a1@<eax>, float *a2@<ecx>)
{
  int v2; // edx
  double v3; // st7

  v2 = 16;
  do
  {
    v3 = a1[3] * *a1;
    a1 += 4;
    *a2 = v3;
    a2 += 4;
    --v2;
    *(a2 - 3) = *(a1 - 3) * *(a1 - 1);
    *(a2 - 2) = *(a1 - 2) * *(a1 - 1);
    *(a2 - 1) = *(a1 - 1);
  }
  while ( v2 );
  return 0;
}

// sub_10020708 @ 0x10020708
int sub_10020708()
{
  int v1; // [esp+0h] [ebp-8h]

  dword_1005DB70 = v1;
  return v1;
}

// grim_dxt_pack_rgb565 @ 0x1002072B
// clamps rgb floats and packs into RGB565
int __thiscall sub_1002072B(float *this)
{
  double v1; // st6
  double v2; // st6
  double v3; // st7
  int v4; // ecx
  float v6; // [esp+0h] [ebp-18h]
  float v7; // [esp+4h] [ebp-14h]
  float v8; // [esp+8h] [ebp-10h]
  float v9; // [esp+10h] [ebp-8h]
  float v10; // [esp+10h] [ebp-8h]
  float v11; // [esp+14h] [ebp-4h]

  if ( *this < 0.0 )
  {
    v1 = 0.0;
LABEL_3:
    v6 = v1;
    goto LABEL_7;
  }
  if ( *this > 1.0 )
  {
    v1 = 1.0;
    goto LABEL_3;
  }
  v6 = *this;
LABEL_7:
  if ( *(this + 1) < 0.0 )
  {
    v2 = 0.0;
LABEL_9:
    v7 = v2;
    goto LABEL_13;
  }
  if ( *(this + 1) > 1.0 )
  {
    v2 = 1.0;
    goto LABEL_9;
  }
  v7 = *(this + 1);
LABEL_13:
  if ( *(this + 2) >= 0.0 )
  {
    if ( *(this + 2) <= 1.0 )
    {
      v8 = *(this + 2);
      goto LABEL_19;
    }
    v3 = 1.0;
  }
  else
  {
    v3 = 0.0;
  }
  v8 = v3;
LABEL_19:
  sub_10020708();
  v11 = v6 * 31.0 + 0.5;
  v9 = v7 * 63.0 + 0.5;
  v4 = (int)v9;
  v10 = v8 * 31.0 + 0.5;
  return (int)v10 | (32 * (v4 | ((int)v11 << 6)));
}

// grim_dxt5_optimize_alpha_endpoints @ 0x10020825
// iteratively chooses DXT5 alpha endpoints for 6/8-alpha modes
float *__cdecl sub_10020825(float *a1, float *a2, int a3, unsigned int a4)
{
  unsigned int v4; // esi
  float *v5; // ebx
  unsigned int v6; // edx
  float *v7; // ecx
  float *v8; // ecx
  double v9; // st7
  int v10; // edx
  float *v11; // eax
  unsigned int v12; // edx
  float *v13; // ecx
  double v14; // st7
  unsigned int v15; // eax
  unsigned int v16; // eax
  double v17; // st7
  double v18; // st6
  float *v19; // eax
  float v20; // eax
  double v21; // st7
  double v22; // st7
  float v24[8]; // [esp+Ch] [ebp-50h] BYREF
  int v25; // [esp+2Ch] [ebp-30h]
  float v26; // [esp+30h] [ebp-2Ch]
  float v27; // [esp+34h] [ebp-28h]
  float v28; // [esp+38h] [ebp-24h]
  unsigned int i; // [esp+3Ch] [ebp-20h]
  _BYTE *v30; // [esp+40h] [ebp-1Ch]
  float v31; // [esp+44h] [ebp-18h]
  float v32; // [esp+48h] [ebp-14h]
  float v33; // [esp+4Ch] [ebp-10h]
  float v34; // [esp+50h] [ebp-Ch]
  float v35; // [esp+54h] [ebp-8h]
  float v36; // [esp+58h] [ebp-4h]

  v4 = a4;
  if ( a4 == 6 )
  {
    v5 = (float *)&grim_dxt5_alpha_weights_min_6;
    v30 = &grim_dxt5_alpha_weights_max_6;
  }
  else
  {
    v5 = (float *)&grim_dxt5_alpha_weights_min_8;
    v30 = &grim_dxt5_alpha_weights_max_8;
  }
  v6 = 0;
  v36 = 1.0;
  v35 = 0.0;
  if ( a4 == 8 )
  {
    do
    {
      v7 = (float *)(a3 + 4 * v6);
      if ( *v7 < (double)v36 )
        v36 = *v7;
      if ( *v7 > (double)v35 )
        v35 = *v7;
      ++v6;
    }
    while ( v6 < 0x10 );
  }
  else
  {
    do
    {
      v8 = (float *)(a3 + 4 * v6);
      if ( *v8 < (double)v36 && *v8 > 0.0 )
        v36 = *v8;
      if ( *v8 > (double)v35 && *v8 < 1.0 )
        v35 = *v8;
      ++v6;
    }
    while ( v6 < 0x10 );
  }
  v25 = a4 - 1;
  v28 = (float)(a4 - 1);
  sub_10020708();
  for ( i = 0; i < 8; ++i )
  {
    v9 = v35 - v36;
    if ( v9 < 0.00390625 )
      break;
    v27 = v28 / v9;
    if ( v4 )
    {
      v10 = v30 - (_BYTE *)v5;
      v11 = v5;
      do
      {
        *(float *)((char *)v11 + (char *)v24 - (char *)v5) = v35 * *(float *)((char *)v11 + v10) + v36 * *v11;
        ++v11;
        --v4;
      }
      while ( v4 );
      v4 = a4;
    }
    if ( v4 == 6 )
    {
      v24[6] = 0.0;
      v24[7] = 1.0;
    }
    v12 = 0;
    v34 = 0.0;
    v33 = 0.0;
    v32 = 0.0;
    v31 = 0.0;
    do
    {
      v13 = (float *)(a3 + 4 * v12);
      v14 = (*v13 - v36) * v27;
      if ( v14 > 0.0 )
      {
        if ( v14 < v28 )
        {
          v26 = v14 + 0.5;
          v25 = (int)v26;
          v15 = v25;
        }
        else
        {
          if ( v4 == 6 && (v35 + 1.0) * 0.5 <= *v13 )
            goto LABEL_38;
          v15 = a4 - 1;
        }
      }
      else
      {
        if ( v4 == 6 && v36 * 0.5 >= *v13 )
          goto LABEL_38;
        v15 = 0;
      }
      if ( v15 < v4 )
      {
        v16 = v15;
        v17 = *v13 - v24[v16];
        v34 = v17 * v5[v16] + v34;
        v18 = v5[v16];
        v19 = (float *)&v30[v16 * 4];
        v32 = v18 * v18 + v32;
        v33 = v17 * *v19 + v33;
        v31 = *v19 * *v19 + v31;
      }
LABEL_38:
      ++v12;
    }
    while ( v12 < 0x10 );
    if ( v32 > 0.0 )
      v36 = v36 - v34 / v32;
    if ( v31 > 0.0 )
      v35 = v35 - v33 / v31;
    if ( v36 > (double)v35 )
    {
      v20 = v35;
      v35 = v36;
      v36 = v20;
    }
    if ( v34 * v34 < 0.015625 && v33 * v33 < 0.015625 )
      break;
  }
  if ( v36 >= 0.0 )
  {
    if ( v36 <= 1.0 )
      v21 = v36;
    else
      v21 = 1.0;
  }
  else
  {
    v21 = 0.0;
  }
  *a1 = v21;
  if ( v35 >= 0.0 )
  {
    if ( v35 <= 1.0 )
      v22 = v35;
    else
      v22 = 1.0;
  }
  else
  {
    v22 = 0.0;
  }
  *a2 = v22;
  return a2;
}

// grim_dxt1_optimize_color_endpoints @ 0x10020B2A
// optimizes DXT1 color endpoints for 3- or 4-color mode
float *__cdecl sub_10020B2A(float *a1, float *a2, int a3, int a4)
{
  double v4; // st7
  float *v5; // ecx
  int v6; // edx
  double v7; // st6
  double v8; // st5
  unsigned __int8 v10; // c0
  unsigned __int8 v11; // c2
  float *result; // eax
  float v13; // ecx
  float *v14; // eax
  double v15; // st5
  int v16; // ecx
  double v17; // st6
  double v18; // st5
  double v19; // st5
  double v20; // st3
  double v21; // st3
  double v22; // st4
  char v23; // bl
  unsigned int i; // edx
  float *v25; // ecx
  float v26; // eax
  float v27; // eax
  double v29; // st7
  float *v30; // eax
  float *v31; // ecx
  int v32; // edx
  int v33; // esi
  double v34; // st6
  double v35; // st5
  double v36; // st6
  double v37; // st5
  double v38; // st4
  double v39; // st4
  float *v40; // ecx
  int v41; // esi
  double v42; // st6
  int v43; // edx
  double v44; // st6
  double v45; // st5
  int v46; // eax
  float *v47; // edx
  double v48; // st4
  float *v49; // eax
  double v50; // st4
  double v51; // st3
  double v52; // st6
  double v53; // st6
  float v55[15]; // [esp+4h] [ebp-54h] BYREF
  float *v56; // [esp+40h] [ebp-18h]
  int v57; // [esp+44h] [ebp-14h]
  float v58; // [esp+48h] [ebp-10h]
  float v59; // [esp+4Ch] [ebp-Ch]
  float v60; // [esp+50h] [ebp-8h]
  float *v61; // [esp+58h] [ebp+0h]
  _BYTE *v62; // [esp+5Ch] [ebp+4h]
  float v63; // [esp+60h] [ebp+8h]
  float v64; // [esp+64h] [ebp+Ch]
  float v65; // [esp+68h] [ebp+10h]
  float v66; // [esp+6Ch] [ebp+14h]
  float v67; // [esp+70h] [ebp+18h]
  float v68; // [esp+74h] [ebp+1Ch]
  float v69; // [esp+7Ch] [ebp+24h]
  float v70; // [esp+80h] [ebp+28h]
  float v71; // [esp+84h] [ebp+2Ch]
  float v72; // [esp+88h] [ebp+30h]
  float v73; // [esp+90h] [ebp+38h] BYREF
  float v74; // [esp+94h] [ebp+3Ch]
  float v75; // [esp+98h] [ebp+40h]
  float v76; // [esp+9Ch] [ebp+44h]
  float v77; // [esp+A0h] [ebp+48h]
  float v78; // [esp+A4h] [ebp+4Ch]
  float v79; // [esp+A8h] [ebp+50h]
  float v80; // [esp+B0h] [ebp+58h]
  float v81; // [esp+B4h] [ebp+5Ch]
  float v82; // [esp+B8h] [ebp+60h]
  int v83; // [esp+BCh] [ebp+64h]
  float v84; // [esp+D4h] [ebp+7Ch]

  if ( a4 == 3 )
  {
    v61 = (float *)&grim_dxt1_color_weights_min_3;
    v62 = &grim_dxt1_color_weights_max_3;
  }
  else
  {
    v61 = (float *)&grim_dxt1_color_weights_min_4;
    v62 = &grim_dxt1_color_weights_max_4;
  }
  v77 = 0.0;
  v4 = 0.0;
  v78 = 0.0;
  v80 = flt_100544C0;
  v81 = flt_100544C4;
  v79 = 0.0;
  v82 = flt_100544C8;
  v83 = unk_100544CC;
  v56 = (float *)(a3 + 8);
  v5 = (float *)(a3 + 8);
  v6 = 16;
  do
  {
    if ( *(v5 - 2) < (double)v80 )
      v80 = *(v5 - 2);
    if ( *(v5 - 1) < (double)v81 )
      v81 = *(v5 - 1);
    if ( *v5 < (double)v82 )
      v82 = *v5;
    if ( *(v5 - 2) > (double)v77 )
      v77 = *(v5 - 2);
    if ( v4 < *(v5 - 1) )
      v4 = *(v5 - 1);
    if ( *v5 > (double)v79 )
      v79 = *v5;
    v5 += 4;
    --v6;
  }
  while ( v6 );
  v78 = v4;
  v70 = v77 - v80;
  v71 = v4 - v81;
  v7 = v79 - v82;
  v8 = v7 * v7 + v71 * v71 + v70 * v70;
  v69 = v8;
  if ( v10 | v11 )
    goto LABEL_19;
  v14 = (float *)(a3 + 8);
  v15 = 1.0 / v8;
  v16 = 16;
  v58 = v70 * v15;
  v59 = v71 * v15;
  v60 = v15 * v7;
  v66 = (v77 + v80) * 0.5;
  v67 = (v4 + v81) * 0.5;
  v68 = (v79 + v82) * 0.5;
  v76 = 0.0;
  v75 = 0.0;
  v74 = 0.0;
  v17 = 0.0;
  do
  {
    v70 = (*(v14 - 2) - v66) * v58;
    v71 = (*(v14 - 1) - v67) * v59;
    v18 = *v14;
    v14 += 4;
    --v16;
    v19 = (v18 - v68) * v60;
    v20 = v71 + v19 + v70;
    v17 = v17 + v20 * v20;
    v21 = v71 + v70 - v19;
    v74 = v21 * v21 + v74;
    v22 = v70 - v71;
    v75 = (v22 + v19) * (v22 + v19) + v75;
    v76 = (v22 - v19) * (v22 - v19) + v76;
  }
  while ( v16 );
  v73 = v17;
  v23 = 0;
  for ( i = 1; i < 4; ++i )
  {
    v25 = &v73 + i;
    if ( v17 < *v25 )
    {
      v23 = i;
      v17 = *v25;
    }
  }
  if ( (v23 & 2) != 0 )
  {
    v26 = v81;
    v81 = v4;
    v64 = v26;
    v4 = v26;
    v78 = v26;
  }
  if ( (v23 & 1) != 0 )
  {
    v27 = v79;
    v79 = v82;
    v82 = v27;
  }
  if ( v69 < 0.00024414062 )
  {
LABEL_19:
    *a1 = v80;
    a1[1] = v81;
    a1[2] = v82;
    result = a2;
    v13 = v77;
    a2[1] = v4;
    *a2 = v13;
  }
  else
  {
    v64 = (float)(unsigned int)(a4 - 1);
    sub_10020708();
    v69 = 0.0;
    v29 = 0.000015258789;
    do
    {
      if ( a4 )
      {
        v30 = v61;
        v31 = v55;
        v32 = v62 - (_BYTE *)v61;
        v33 = a4;
        do
        {
          *(v31 - 1) = v80 * *v30 + v77 * *(float *)((char *)v30 + v32);
          *v31 = v81 * *v30 + v78 * *(float *)((char *)v30 + v32);
          v34 = v82 * *v30;
          v35 = v79 * *(float *)((char *)v30++ + v32);
          v31[1] = v34 + v35;
          v31 += 4;
          --v33;
        }
        while ( v33 );
      }
      v36 = v77 - v80;
      v71 = v78 - v81;
      v37 = v79 - v82;
      v38 = v37 * v37 + v71 * v71 + v36 * v36;
      if ( v38 < 0.00024414062 )
        break;
      v39 = v64 / v38;
      v40 = v56;
      v41 = 16;
      v70 = v39 * v36;
      v71 = v71 * v39;
      v72 = v39 * v37;
      v75 = 0.0;
      v74 = 0.0;
      v73 = 0.0;
      v68 = 0.0;
      v67 = 0.0;
      v66 = 0.0;
      v65 = 0.0;
      v84 = 0.0;
      do
      {
        v42 = (*(v40 - 1) - v81) * v71 + (*(v40 - 2) - v80) * v70 + (*v40 - v82) * v72;
        v63 = v42;
        if ( v42 < v64 )
        {
          v63 = v63 + 0.5;
          v57 = (int)v63;
          v43 = v57;
          v29 = 0.000015258789;
        }
        else
        {
          v43 = a4 - 1;
        }
        v44 = v55[4 * v43 - 1] - *(v40 - 2);
        v59 = v55[4 * v43] - *(v40 - 1);
        v45 = v55[4 * v43 + 1] - *v40;
        v46 = v43;
        v47 = &v61[v46];
        v48 = v61[v46];
        v49 = (float *)&v62[v46 * 4];
        v50 = v48 * 0.125;
        v40 += 4;
        --v41;
        v51 = *v49 * 0.125;
        v84 = v50 * *v47 + v84;
        v66 = v50 * v44 + v66;
        v67 = v50 * v59 + v67;
        v68 = v50 * v45 + v68;
        v65 = v51 * *v49 + v65;
        v73 = v51 * v44 + v73;
        v74 = v59 * v51 + v74;
        v75 = v51 * v45 + v75;
      }
      while ( v41 );
      if ( v84 > 0.0 )
      {
        v52 = -1.0 / v84;
        v80 = v66 * v52 + v80;
        v81 = v67 * v52 + v81;
        v82 = v52 * v68 + v82;
      }
      if ( v65 > 0.0 )
      {
        v53 = -1.0 / v65;
        v77 = v73 * v53 + v77;
        v78 = v74 * v53 + v78;
        v79 = v53 * v75 + v79;
      }
      if ( v66 * v66 < v29
        && v67 * v67 < v29
        && v68 * v68 < v29
        && v73 * v73 < v29
        && v74 * v74 < v29
        && v75 * v75 < v29 )
      {
        break;
      }
      ++LODWORD(v69);
    }
    while ( LODWORD(v69) < 8 );
    *a1 = v80;
    a1[1] = v81;
    a1[2] = v82;
    result = a2;
    *a2 = v77;
    a2[1] = v78;
  }
  result[2] = v79;
  return result;
}

// grim_dxt1_encode_color_block @ 0x10021095
// encodes a 4x4 RGBA block into a DXT1 color block (supports 1-bit alpha mode)
int __usercall sub_10021095@<eax>(float *a1@<eax>, int a2, int a3)
{
  int v4; // esi
  float *v5; // ecx
  int v6; // edi
  char v7; // dl
  char *v8; // esi
  char *v9; // edi
  float *v10; // eax
  unsigned int v11; // ecx
  double v12; // st7
  double v13; // st6
  double v14; // st5
  double v15; // st4
  bool v16; // zf
  unsigned int v17; // esi
  int v18; // eax
  unsigned int v19; // edi
  float *v20; // esi
  float *v21; // esi
  double v22; // st7
  double v23; // st6
  double v24; // st4
  double v25; // st5
  double v26; // st4
  double v27; // st7
  double v28; // st6
  double v29; // st5
  unsigned int v30; // edx
  _BYTE *v31; // esi
  char *v32; // edi
  float *v33; // ecx
  double v34; // st7
  int v35; // eax
  int v36; // ebx
  int v37; // eax
  double v38; // st7
  int v39; // ebx
  double v40; // st6
  float v42[4]; // [esp+0h] [ebp-270h]
  float v43; // [esp+10h] [ebp-260h] BYREF
  float v44; // [esp+14h] [ebp-25Ch] BYREF
  _BYTE v45[248]; // [esp+18h] [ebp-258h] BYREF
  float v46[64]; // [esp+110h] [ebp-160h] BYREF
  float v47; // [esp+210h] [ebp-60h] BYREF
  float v48; // [esp+214h] [ebp-5Ch]
  float v49; // [esp+218h] [ebp-58h]
  int v50; // [esp+220h] [ebp-50h]
  char *v51; // [esp+224h] [ebp-4Ch]
  char *v52; // [esp+228h] [ebp-48h]
  char *v53; // [esp+22Ch] [ebp-44h]
  char *v54; // [esp+230h] [ebp-40h]
  char *v55; // [esp+234h] [ebp-3Ch]
  char *v56; // [esp+238h] [ebp-38h]
  char *v57; // [esp+23Ch] [ebp-34h]
  char *v58; // [esp+240h] [ebp-30h]
  char *v59; // [esp+244h] [ebp-2Ch]
  float v60; // [esp+248h] [ebp-28h]
  float v61; // [esp+24Ch] [ebp-24h]
  float v62; // [esp+250h] [ebp-20h]
  float v63; // [esp+254h] [ebp-1Ch]
  float v64; // [esp+258h] [ebp-18h]
  float v65; // [esp+25Ch] [ebp-14h]
  float v66; // [esp+260h] [ebp-10h]
  float v67; // [esp+264h] [ebp-Ch]
  float v68; // [esp+268h] [ebp-8h]
  float v69; // [esp+26Ch] [ebp-4h]
  float v70; // [esp+270h] [ebp+0h]
  float v71; // [esp+274h] [ebp+4h]
  float v72; // [esp+278h] [ebp+8h]
  float v73; // [esp+27Ch] [ebp+Ch]
  float v74; // [esp+280h] [ebp+10h]
  float v75; // [esp+284h] [ebp+14h]
  int v76; // [esp+288h] [ebp+18h]
  char *v77; // [esp+28Ch] [ebp+1Ch]
  char *v78; // [esp+290h] [ebp+20h]
  char *v79; // [esp+294h] [ebp+24h]
  float v80; // [esp+298h] [ebp+28h] BYREF
  float v81; // [esp+29Ch] [ebp+2Ch]
  float v82; // [esp+2A0h] [ebp+30h]
  float v83; // [esp+2A4h] [ebp+34h]
  float v84; // [esp+2A8h] [ebp+38h] BYREF
  float v85; // [esp+2ACh] [ebp+3Ch]
  float v86; // [esp+2B0h] [ebp+40h]
  char *v87; // [esp+2B8h] [ebp+48h]
  float v88; // [esp+2BCh] [ebp+4Ch]
  float v89; // [esp+2C0h] [ebp+50h]
  float v90; // [esp+2C4h] [ebp+54h] BYREF
  float v91; // [esp+2C8h] [ebp+58h]
  float v92; // [esp+2CCh] [ebp+5Ch]
  float v93; // [esp+2D0h] [ebp+60h]
  int v94; // [esp+2D4h] [ebp+64h]
  int v95; // [esp+2D8h] [ebp+68h]
  float v96; // [esp+2DCh] [ebp+6Ch]
  char v97; // [esp+2ECh] [ebp+7Ch]
  float v98; // [esp+2ECh] [ebp+7Ch]
  unsigned int v99; // [esp+2ECh] [ebp+7Ch]

  if ( a3 )
  {
    v4 = 0;
    v5 = a1 + 3;
    v6 = 16;
    do
    {
      if ( *v5 < 0.5 )
        ++v4;
      v5 += 4;
      --v6;
    }
    while ( v6 );
    if ( v4 == 16 )
    {
      *(_WORD *)(a2 + 2) = -1;
      *(_DWORD *)(a2 + 4) = -1;
      *(_WORD *)a2 = 0;
      return 0;
    }
    v94 = 4 - (v4 != 0);
  }
  else
  {
    v94 = 4;
  }
  memset(v46, 0, sizeof(v46));
  sub_10020708();
  v77 = (char *)((char *)&v46[2] - (char *)a1);
  v53 = (char *)((char *)&v46[3] - (char *)a1);
  v51 = (char *)((char *)&v46[4] - (char *)a1);
  v76 = (char *)&v46[10] - (char *)a1;
  v54 = (char *)((char *)&v46[11] - (char *)a1);
  v56 = (char *)((char *)&v46[12] - (char *)a1);
  LODWORD(v88) = (char *)&v46[14] - (char *)a1;
  v52 = (char *)((char *)&v46[15] - (char *)a1);
  v58 = (char *)((char *)&v46[16] - (char *)a1);
  v87 = (char *)((char *)&v46[18] - (char *)a1);
  v59 = (char *)((char *)&v46[19] - (char *)a1);
  v97 = v7;
  v8 = (char *)((char *)v46 - (char *)a1);
  v55 = (char *)((char *)&v46[20] - (char *)a1);
  v9 = (char *)((char *)&v43 - (char *)a1);
  v10 = a1 + 2;
  v57 = (char *)((char *)v46 - (char *)a1);
  v11 = 0;
  while ( 1 )
  {
    v90 = v46[v11] + *(v10 - 2);
    v91 = *(v10 - 1) + v46[v11 + 1];
    v92 = *(float *)((char *)v10 + (_DWORD)v8) + *v10;
    v96 = v90 * 31.0 + 0.5;
    v50 = (int)v96;
    v89 = (double)v50 * 0.032258064;
    *(float *)((char *)&v43 + v11 * 4) = v89;
    v96 = v91 * 63.0 + 0.5;
    v79 = (char *)(int)v96;
    v96 = (double)(int)v79 * 0.015873017;
    *(float *)&v45[v11 * 4 - 4] = v96;
    *(float *)&v95 = v92 * 31.0 + 0.5;
    v78 = (char *)(int)*(float *)&v95;
    v12 = (double)(int)v78 * 0.032258064;
    v95 = v97 & 3;
    *(float *)((char *)v10 + (_DWORD)v9) = v12;
    *(float *)((char *)v10 + (char *)&v44 - (char *)a1) = 1.0;
    v13 = v90 - v89;
    v14 = v91 - v96;
    v85 = v14;
    v15 = v92 - v12;
    v86 = v15;
    if ( (v97 & 3) != 3 )
    {
      *(float *)&v77[(_DWORD)v10] = v13 * 0.4375 + *(float *)&v77[(_DWORD)v10];
      *(float *)&v53[(_DWORD)v10] = v14 * 0.4375 + *(float *)&v53[(_DWORD)v10];
      *(float *)&v51[(_DWORD)v10] = v15 * 0.4375 + *(float *)&v51[(_DWORD)v10];
    }
    if ( v11 < 48 )
    {
      if ( *(float *)&v95 != 0.0 )
      {
        *(float *)((char *)v10 + v76) = v13 * 0.1875 + *(float *)((char *)v10 + v76);
        *(float *)&v54[(_DWORD)v10] = v14 * 0.1875 + *(float *)&v54[(_DWORD)v10];
        *(float *)&v56[(_DWORD)v10] = v15 * 0.1875 + *(float *)&v56[(_DWORD)v10];
      }
      *(float *)((char *)v10 + LODWORD(v88)) = v13 * 0.3125 + *(float *)((char *)v10 + LODWORD(v88));
      *(float *)&v52[(_DWORD)v10] = v14 * 0.3125 + *(float *)&v52[(_DWORD)v10];
      v16 = v95 == 3;
      *(float *)&v58[(_DWORD)v10] = v15 * 0.3125 + *(float *)&v58[(_DWORD)v10];
      if ( !v16 )
      {
        *(float *)&v87[(_DWORD)v10] = v13 * 0.0625 + *(float *)&v87[(_DWORD)v10];
        *(float *)&v59[(_DWORD)v10] = v85 * 0.0625 + *(float *)&v59[(_DWORD)v10];
        *(float *)&v55[(_DWORD)v10] = v86 * 0.0625 + *(float *)&v55[(_DWORD)v10];
      }
    }
    ++v97;
    v11 += 4;
    v42[v11] = v89 * flt_100544C0;
    v42[v11 + 1] = v96 * flt_100544C4;
    *(float *)((char *)v10 + (_DWORD)v9) = v12 * flt_100544C8;
    v10 += 4;
    if ( v11 >= 64 )
      break;
    v8 = v57;
  }
  grim_dxt1_optimize_color_endpoints(&v80, &v90, (int)&v43, v94);
  v47 = v80 * flt_100544D0;
  v48 = v81 * flt_100544D4;
  v49 = v82 * flt_100544D8;
  v84 = v90 * flt_100544D0;
  v85 = v91 * flt_100544D4;
  v86 = v92 * flt_100544D8;
  *(float *)&v17 = COERCE_FLOAT(grim_dxt_pack_rgb565(&v47));
  v88 = *(float *)&v17;
  v18 = grim_dxt_pack_rgb565(&v84);
  v19 = v18;
  v87 = (char *)v18;
  if ( v94 == 4 && (_WORD)v17 == (_WORD)v18 )
  {
    *(_DWORD *)(a2 + 4) = 0;
    *(_WORD *)a2 = v17;
    *(_WORD *)(a2 + 2) = v18;
  }
  else
  {
    grim_dxt_decode_rgb565(&v47, v17);
    grim_dxt_decode_rgb565(&v84, v19);
    v80 = v47 * flt_100544C0;
    v81 = v48 * flt_100544C4;
    v82 = v49 * flt_100544C8;
    v90 = v84 * flt_100544C0;
    v91 = v85 * flt_100544C4;
    v92 = v86 * flt_100544C8;
    if ( (v94 == 3) == (unsigned __int16)v19 >= (unsigned __int16)v17 )
    {
      *(_WORD *)a2 = v17;
      *(_WORD *)(a2 + 2) = v19;
      v60 = v80;
      v61 = v81;
      v62 = v82;
      v63 = v83;
      v20 = &v90;
    }
    else
    {
      *(_WORD *)(a2 + 2) = v17;
      *(_WORD *)a2 = v19;
      v60 = v90;
      v61 = v91;
      v62 = v92;
      v63 = v93;
      v20 = &v80;
    }
    v64 = *v20;
    v21 = v20 + 1;
    v65 = *v21++;
    v66 = *v21;
    v67 = v21[1];
    v22 = v64 - v60;
    if ( v94 == 3 )
    {
      v89 = COERCE_FLOAT(&grim_dxt1_index_map_3color);
      v68 = 0.5 * v22 + v60;
      v23 = v65 - v61;
      v69 = v23 * 0.5 + v61;
      v24 = v66 - v62;
      v98 = v24;
      v70 = v24 * 0.5 + v62;
      v71 = (v67 - v63) * 0.5 + v63;
    }
    else
    {
      v89 = COERCE_FLOAT(&grim_dxt1_index_map_4color);
      v68 = 0.33333334 * v22 + v60;
      v23 = v65 - v61;
      v69 = 0.33333334 * v23 + v61;
      v25 = v66 - v62;
      v98 = v25;
      v70 = 0.33333334 * v25 + v62;
      v26 = v67 - v63;
      v71 = 0.33333334 * v26 + v63;
      v72 = v22 * 0.66666669 + v60;
      v73 = v23 * 0.66666669 + v61;
      v74 = v25 * 0.66666669 + v62;
      v75 = v26 * 0.66666669 + v63;
    }
    v90 = v22;
    v27 = v23;
    v28 = v98;
    v96 = (float)(unsigned int)(v94 - 1);
    if ( LOWORD(v88) == (_WORD)v87 )
      v29 = 0.0;
    else
      v29 = v96 / (v28 * v28 + v27 * v27 + v90 * v90);
    v90 = v90 * v29;
    memset(v46, 0, sizeof(v46));
    v91 = v29 * v27;
    v92 = v29 * v28;
    sub_10020708();
    *(float *)&v95 = COERCE_FLOAT(v46);
    v87 = (char *)((char *)&v46[1] - (char *)a1);
    v77 = (char *)((char *)&v46[5] - (char *)a1);
    v78 = (char *)((char *)&v46[13] - (char *)a1);
    v31 = (_BYTE *)(v45 - (_BYTE *)a1);
    v32 = (char *)((char *)&v46[17] - (char *)a1);
    v99 = v30;
    v33 = a1 + 1;
    v79 = (char *)((char *)&v46[21] - (char *)a1);
    do
    {
      if ( v94 == 3 && v33[2] < 0.5 )
      {
        v30 = (v30 >> 2) | 0xC0000000;
      }
      else
      {
        v80 = flt_100544C0 * *(v33 - 1) + *(float *)v95;
        v81 = flt_100544C4 * *v33 + *(float *)&v57[(_DWORD)v33];
        v82 = flt_100544C8 * v33[1] + *(float *)((char *)v33 + (_DWORD)v87);
        v34 = (v80 - v60) * v90 + (v82 - v62) * v92 + (v81 - v61) * v91;
        if ( v34 > 0.0 )
        {
          if ( v34 < v96 )
          {
            v88 = v34 + 0.5;
            v76 = (int)v88;
            v35 = *(_DWORD *)(LODWORD(v89) + 4 * v76);
          }
          else
          {
            v35 = 1;
          }
        }
        else
        {
          v35 = 0;
        }
        v36 = v35;
        v37 = 16 * v35;
        v30 = (v36 << 30) | (v30 >> 2);
        v38 = (v80 - *(float *)((char *)&v60 + v37)) * *(float *)((char *)v33 + (_DWORD)v31);
        v39 = v99 & 3;
        v40 = (v81 - *(float *)((char *)&v61 + v37)) * *(float *)((char *)v33 + (_DWORD)v31);
        v85 = v40;
        v86 = (v82 - *(float *)((char *)&v62 + v37)) * *(float *)((char *)v33 + (_DWORD)v31);
        if ( v39 != 3 )
        {
          *(float *)&v53[(_DWORD)v33] = v38 * 0.4375 + *(float *)&v53[(_DWORD)v33];
          *(float *)&v51[(_DWORD)v33] = 0.4375 * v40 + *(float *)&v51[(_DWORD)v33];
          *(float *)&v77[(_DWORD)v33] = v86 * 0.4375 + *(float *)&v77[(_DWORD)v33];
        }
        if ( v99 < 0xC )
        {
          if ( (v99 & 3) != 0 )
          {
            *(float *)&v54[(_DWORD)v33] = v38 * 0.1875 + *(float *)&v54[(_DWORD)v33];
            *(float *)&v56[(_DWORD)v33] = 0.1875 * v40 + *(float *)&v56[(_DWORD)v33];
            *(float *)&v78[(_DWORD)v33] = v86 * 0.1875 + *(float *)&v78[(_DWORD)v33];
          }
          *(float *)&v52[(_DWORD)v33] = v38 * 0.3125 + *(float *)&v52[(_DWORD)v33];
          *(float *)&v58[(_DWORD)v33] = v40 * 0.3125 + *(float *)&v58[(_DWORD)v33];
          *(float *)((char *)v33 + (_DWORD)v32) = v86 * 0.3125 + *(float *)((char *)v33 + (_DWORD)v32);
          if ( v39 != 3 )
          {
            *(float *)&v59[(_DWORD)v33] = v38 * 0.0625 + *(float *)&v59[(_DWORD)v33];
            *(float *)&v55[(_DWORD)v33] = v85 * 0.0625 + *(float *)&v55[(_DWORD)v33];
            *(float *)&v79[(_DWORD)v33] = v86 * 0.0625 + *(float *)&v79[(_DWORD)v33];
          }
        }
      }
      ++v99;
      v95 += 16;
      v33 += 4;
    }
    while ( v99 < 0x10 );
    *(_DWORD *)(a2 + 4) = v30;
  }
  return 0;
}

// grim_dxt1_decode_color_block @ 0x10021899
// decodes a DXT1 color block into 16 RGBA floats
int __cdecl sub_10021899(float *a1, unsigned __int16 *a2)
{
  unsigned __int16 v3; // si
  unsigned int v4; // edi
  double v5; // st7
  double v6; // st5
  double v7; // st5
  double v8; // st5
  unsigned int v9; // ebx
  int v11; // ecx
  int v12; // edx
  float *v13; // edi
  float v15; // [esp+Ch] [ebp-58h] BYREF
  float v16; // [esp+10h] [ebp-54h]
  float v17; // [esp+14h] [ebp-50h]
  float v18; // [esp+18h] [ebp-4Ch]
  float v19; // [esp+1Ch] [ebp-48h] BYREF
  float v20; // [esp+20h] [ebp-44h]
  float v21; // [esp+24h] [ebp-40h]
  float v22; // [esp+28h] [ebp-3Ch]
  float v23; // [esp+2Ch] [ebp-38h]
  float v24; // [esp+30h] [ebp-34h]
  float v25; // [esp+34h] [ebp-30h]
  float v26; // [esp+38h] [ebp-2Ch]
  float v27; // [esp+3Ch] [ebp-28h]
  float v28; // [esp+40h] [ebp-24h]
  float v29; // [esp+44h] [ebp-20h]
  float v30; // [esp+48h] [ebp-1Ch]
  float v31; // [esp+4Ch] [ebp-18h]
  float v32; // [esp+50h] [ebp-14h]
  float v33; // [esp+54h] [ebp-10h]
  float v34; // [esp+58h] [ebp-Ch]
  float v35; // [esp+5Ch] [ebp-8h]
  float v36; // [esp+60h] [ebp-4h]
  float v37; // [esp+70h] [ebp+Ch]

  v3 = *a2;
  grim_dxt_decode_rgb565(&v15, *a2);
  v4 = a2[1];
  grim_dxt_decode_rgb565(&v19, v4);
  if ( v3 > (unsigned __int16)v4 )
  {
    v5 = v19 - v15;
    v23 = v5 * 0.33333334 + v15;
    v6 = v20 - v16;
    v37 = v6;
    v24 = v6 * 0.33333334 + v16;
    v7 = v21 - v17;
    v36 = v7;
    v25 = v7 * 0.33333334 + v17;
    v8 = v22 - v18;
    v35 = v8;
    v26 = v8 * 0.33333334 + v18;
    v27 = v5 * 0.66666669 + v15;
    v28 = v37 * 0.66666669 + v16;
    v29 = v36 * 0.66666669 + v17;
    v30 = v35 * 0.66666669 + v18;
  }
  else
  {
    v23 = (v19 - v15) * 0.5 + v15;
    v24 = (v20 - v16) * 0.5 + v16;
    v25 = (v21 - v17) * 0.5 + v17;
    v26 = (v22 - v18) * 0.5 + v18;
    v31 = 0.0;
    v32 = 0.0;
    v33 = 0.0;
    v34 = 0.0;
    v27 = 0.0;
    v28 = 0.0;
    v29 = 0.0;
    v30 = 0.0;
  }
  v9 = *((_DWORD *)a2 + 1);
  v11 = 16;
  do
  {
    v12 = 16 * (v9 & 3);
    *a1 = *(float *)((char *)&v15 + v12);
    a1[1] = *(float *)((char *)&v15 + v12 + 4);
    a1[2] = *(float *)((char *)&v17 + v12);
    v13 = a1 + 3;
    a1 += 4;
    v9 >>= 2;
    --v11;
    *v13 = *(float *)((char *)&v18 + v12);
  }
  while ( v11 );
  return 0;
}

// grim_dxt3_decode_block @ 0x100219D7
// decodes a DXT3 block (explicit alpha + DXT1 color) to RGBA floats
int __cdecl sub_100219D7(float *a1, unsigned __int16 *a2)
{
  int result; // eax
  unsigned int v3; // ecx
  int v4; // edx
  float *v5; // eax
  double v6; // st6
  unsigned int v7; // esi
  int v8; // ecx
  float *v9; // eax
  double v10; // st6

  result = grim_dxt1_decode_color_block(a1, a2 + 4);
  if ( result >= 0 )
  {
    v3 = *(_DWORD *)a2;
    v4 = 8;
    v5 = a1 + 3;
    do
    {
      v6 = (double)(v3 & 0xF);
      v3 >>= 4;
      *v5 = v6 * 0.06666667;
      v5 += 4;
      --v4;
    }
    while ( v4 );
    v7 = *((_DWORD *)a2 + 1);
    v8 = 8;
    v9 = a1 + 35;
    do
    {
      v10 = (double)(v7 & 0xF);
      v7 >>= 4;
      *v9 = v10 * 0.06666667;
      v9 += 4;
      --v8;
    }
    while ( v8 );
    return 0;
  }
  return result;
}

// grim_dxt5_decode_block @ 0x10021A5A
// decodes a DXT5 block (interpolated alpha + DXT1 color) to RGBA floats
int __cdecl sub_10021A5A(float *a1, unsigned __int16 *a2)
{
  int result; // eax
  unsigned __int8 v3; // al
  unsigned __int8 v4; // cl
  unsigned int j; // eax
  double v6; // st7
  double v7; // st6
  unsigned int i; // eax
  double v9; // st7
  double v10; // st6
  int v11; // edx
  unsigned int v12; // ecx
  float *v13; // eax
  int v14; // ebx
  int v15; // edx
  unsigned int v16; // ecx
  float *v17; // eax
  int v18; // esi
  float v19; // [esp+8h] [ebp-20h]
  float v20; // [esp+Ch] [ebp-1Ch]
  float v21; // [esp+20h] [ebp-8h]
  float v22; // [esp+24h] [ebp-4h]

  result = grim_dxt1_decode_color_block(a1, a2 + 4);
  if ( result >= 0 )
  {
    v3 = *(_BYTE *)a2;
    v4 = *((_BYTE *)a2 + 1);
    v19 = (double)*(unsigned __int8 *)a2 * 0.0039215689;
    v20 = (double)v4 * 0.0039215689;
    if ( v3 <= v4 )
    {
      for ( i = 1; i < 5; *(&v19 + i) = (v9 + v10) * 0.2 )
      {
        v9 = (double)(5 - i) * v19;
        v10 = (double)i++ * v20;
      }
      v21 = 0.0;
      v22 = 1.0;
    }
    else
    {
      for ( j = 1; j < 7; *(&v19 + j) = (v6 + v7) * 0.14285715 )
      {
        v6 = (double)(7 - j) * v19;
        v7 = (double)j++ * v20;
      }
    }
    v11 = 8;
    v12 = *((unsigned __int8 *)a2 + 2) | (*(unsigned __int16 *)((char *)a2 + 3) << 8);
    v13 = a1 + 3;
    do
    {
      v14 = v12 & 7;
      v12 >>= 3;
      *v13 = *(&v19 + v14);
      v13 += 4;
      --v11;
    }
    while ( v11 );
    v15 = 8;
    v16 = *((unsigned __int8 *)a2 + 5) | (a2[3] << 8);
    v17 = a1 + 35;
    do
    {
      v18 = v16 & 7;
      v16 >>= 3;
      *v17 = *(&v19 + v18);
      v17 += 4;
      --v15;
    }
    while ( v15 );
    return 0;
  }
  return result;
}

// sub_10021B96 @ 0x10021B96
int __cdecl sub_10021B96(int a1, float *a2)
{
  int result; // eax

  result = grim_dxt1_encode_color_block(a2, a1, 1);
  if ( result >= 0 )
    return 0;
  return result;
}

// grim_dxt3_encode_block @ 0x10021BAE
// encodes a 4x4 RGBA block into DXT3 (explicit alpha + DXT1 color)
int __cdecl sub_10021BAE(_DWORD *a1, float *a2)
{
  unsigned int v3; // edx
  double v4; // st7
  int *v5; // edx
  int v6; // eax
  double v7; // st7
  int v8; // edx
  double v9; // st7
  float v11[16]; // [esp+Ch] [ebp-50h] BYREF
  float v12; // [esp+4Ch] [ebp-10h]
  float v13; // [esp+50h] [ebp-Ch]
  float v14; // [esp+54h] [ebp-8h]
  float *v15; // [esp+58h] [ebp-4h]
  unsigned int v16; // [esp+64h] [ebp+8h]

  *a1 = 0;
  a1[1] = 0;
  memset(v11, 0, sizeof(v11));
  sub_10020708();
  v16 = v3;
  v15 = a2 + 3;
  do
  {
    v4 = v11[v16] + *v15;
    v14 = v4;
    v13 = v4 * 15.0 + 0.5;
    LODWORD(v12) = (int)v13;
    v5 = &a1[v16 >> 3];
    v6 = (LODWORD(v12) << 28) | ((unsigned int)*v5 >> 4);
    v13 = v12;
    v7 = (double)LODWORD(v12);
    *v5 = v6;
    v8 = v16 & 3;
    v9 = v14 - v7 * 0.06666667;
    if ( v8 != 3 )
      v11[v16 + 1] = 0.4375 * v9 + v11[v16 + 1];
    if ( v16 < 0xC )
    {
      if ( (v16 & 3) != 0 )
        v11[v16 + 3] = 0.1875 * v9 + v11[v16 + 3];
      v11[v16 + 4] = 0.3125 * v9 + v11[v16 + 4];
      if ( v8 != 3 )
        v11[v16 + 5] = v9 * 0.0625 + v11[v16 + 5];
    }
    ++v16;
    v15 += 4;
  }
  while ( v16 < 0x10 );
  return grim_dxt1_encode_color_block(a2, (int)(a1 + 2), 0);
}

// grim_dxt5_encode_block @ 0x10021CC2
// encodes a 4x4 RGBA block into DXT5 (interpolated alpha + DXT1 color)
int __cdecl sub_10021CC2(float a1, int a2)
{
  float *v2; // ebx
  unsigned int v3; // edx
  float *v4; // edi
  double v5; // st7
  double v6; // st7
  unsigned __int8 v8; // c0
  unsigned __int8 v9; // c2
  double v10; // st7
  int v11; // esi
  float v12; // esi
  int result; // eax
  unsigned int v14; // edi
  char v15; // cl
  double v16; // st7
  double v17; // st6
  unsigned int j; // eax
  double v19; // st7
  double v20; // st6
  unsigned int i; // eax
  double v22; // st7
  double v23; // st6
  double v24; // st7
  unsigned int v25; // eax
  int v26; // ecx
  unsigned int v27; // edx
  unsigned int v28; // ebx
  double v29; // st7
  double v30; // st7
  int v31; // eax
  double v32; // st7
  int v33; // edi
  int v34; // [esp-4h] [ebp-40h]
  float v35[16]; // [esp+Ch] [ebp-30h] BYREF
  float v36[8]; // [esp+4Ch] [ebp+10h] BYREF
  float v37; // [esp+6Ch] [ebp+30h]
  float v38; // [esp+70h] [ebp+34h]
  float v39; // [esp+84h] [ebp+48h]
  float v40; // [esp+88h] [ebp+4Ch]
  int v41; // [esp+8Ch] [ebp+50h]
  float v42; // [esp+90h] [ebp+54h]
  float v43; // [esp+94h] [ebp+58h]
  float v44; // [esp+98h] [ebp+5Ch]
  float v45; // [esp+9Ch] [ebp+60h]
  float v46; // [esp+A0h] [ebp+64h]
  float v47; // [esp+A4h] [ebp+68h]
  int v48; // [esp+A8h] [ebp+6Ch] BYREF

  v2 = (float *)(a2 + 12);
  v47 = *(float *)(a2 + 12);
  v46 = v47;
  memset(v35, 0, sizeof(v35));
  sub_10020708();
  v3 = 0;
  v4 = v2;
  do
  {
    v5 = v35[v3] + *v4;
    v44 = v5;
    *(float *)&v48 = v5 * 255.0 + 0.5;
    LODWORD(v45) = (int)*(float *)&v48;
    *(float *)&v48 = v45;
    v6 = (double)SLODWORD(v45) * 0.0039215689;
    v36[v3] = v6;
    if ( v8 | v9 )
    {
      v47 = v6;
    }
    else if ( v6 > v46 )
    {
      v46 = v6;
    }
    v10 = v44 - v6;
    v11 = v3 & 3;
    if ( v11 != 3 )
      v35[v3 + 1] = 0.4375 * v10 + v35[v3 + 1];
    if ( v3 < 0xC )
    {
      if ( (v3 & 3) != 0 )
        v35[v3 + 3] = 0.1875 * v10 + v35[v3 + 3];
      v35[v3 + 4] = 0.3125 * v10 + v35[v3 + 4];
      if ( v11 != 3 )
        v35[v3 + 5] = v10 * 0.0625 + v35[v3 + 5];
    }
    ++v3;
    v4 += 4;
  }
  while ( v3 < 0x10 );
  v48 = dword_1005DB70;
  v12 = a1;
  result = grim_dxt1_encode_color_block((float *)a2, LODWORD(a1) + 8, 0);
  if ( result < 0 )
    return result;
  if ( 1.0 == v47 )
  {
    *(_BYTE *)LODWORD(v12) = -1;
    *(_BYTE *)(LODWORD(v12) + 1) = -1;
LABEL_24:
    *(_DWORD *)(LODWORD(v12) + 2) = 0;
    *(_WORD *)(LODWORD(v12) + 6) = 0;
    return 0;
  }
  if ( 0.0 == v47 || 1.0 == v46 )
  {
    a2 = 6;
    v14 = 6;
  }
  else
  {
    v14 = 8;
    a2 = 8;
  }
  grim_dxt5_optimize_alpha_endpoints((float *)&v48, &a1, (int)v36, v14);
  sub_10020708();
  *(float *)&v48 = *(float *)&v48 * 255.0 + 0.5;
  LODWORD(v45) = (int)*(float *)&v48;
  a1 = a1 * 255.0 + 0.5;
  v48 = (int)a1;
  v15 = v48;
  v16 = (double)LOBYTE(v45) * 0.0039215689;
  v17 = (double)(unsigned __int8)v48 * 0.0039215689;
  a1 = v17;
  if ( v14 == 8 )
  {
    if ( LOBYTE(v45) == (_BYTE)v48 )
    {
      *(_BYTE *)LODWORD(v12) = LOBYTE(v45);
      *(_BYTE *)(LODWORD(v12) + 1) = v15;
      goto LABEL_24;
    }
    *(_BYTE *)(LODWORD(v12) + 1) = LOBYTE(v45);
    v37 = v17;
    v38 = v16;
    *(_BYTE *)LODWORD(v12) = v15;
    for ( i = 1; i < 7; *(&v37 + i) = (v22 + v23) * 0.14285715 )
    {
      v22 = (double)(7 - i) * v37;
      a1 = *(float *)&i;
      v23 = (double)i++ * v38;
    }
    v45 = COERCE_FLOAT(&grim_dxt5_alpha_index_map_8);
  }
  else
  {
    *(_BYTE *)LODWORD(v12) = LOBYTE(v45);
    v37 = v16;
    v38 = a1;
    *(_BYTE *)(LODWORD(v12) + 1) = v15;
    for ( j = 1; j < 5; *(&v37 + j) = (v19 + v20) * 0.2 )
    {
      v19 = (double)(5 - j) * v37;
      a1 = *(float *)&j;
      v20 = (double)j++ * v38;
    }
    v45 = COERCE_FLOAT(&grim_dxt5_alpha_index_map_6);
    v39 = 0.0;
    v40 = 1.0;
  }
  LODWORD(a1) = v14 - 1;
  v43 = (float)(v14 - 1);
  if ( v37 == v38 )
    v24 = 0.0;
  else
    v24 = v43 / (v38 - v37);
  v44 = v24;
  memset(v35, 0, sizeof(v35));
  sub_10020708();
  v25 = 0;
  v26 = LODWORD(v12) + 3;
  v47 = *(float *)&v2;
  do
  {
    *(float *)&v27 = 0.0;
    a1 = 0.0;
    v48 = v25 + 8;
    v28 = v25;
    if ( v25 >= v25 + 8 )
      goto LABEL_58;
    v46 = v47;
    do
    {
      v29 = v35[v28] + *(float *)LODWORD(v46);
      a1 = v29;
      v30 = (v29 - v37) * v44;
      if ( v30 <= 0.0 )
      {
        if ( a2 != 6 || v37 * 0.5 < a1 )
        {
          v31 = 0;
          goto LABEL_49;
        }
        v34 = 6;
        goto LABEL_46;
      }
      if ( v30 < v43 )
      {
        v42 = v30 + 0.5;
        v41 = (int)v42;
        v31 = *(_DWORD *)(LODWORD(v45) + 4 * v41);
      }
      else
      {
        if ( a2 == 6 && (v38 + 1.0) * 0.5 <= a1 )
        {
          v34 = 7;
LABEL_46:
          v31 = v34;
          goto LABEL_49;
        }
        v31 = 1;
      }
LABEL_49:
      v32 = a1 - *(&v37 + v31);
      v27 = (v31 << 21) | (v27 >> 3);
      v33 = v28 & 3;
      if ( v33 != 3 )
        v35[v28 + 1] = 0.4375 * v32 + v35[v28 + 1];
      if ( v28 < 0xC )
      {
        if ( (v28 & 3) != 0 )
          v35[v28 + 3] = 0.1875 * v32 + v35[v28 + 3];
        v35[v28 + 4] = 0.3125 * v32 + v35[v28 + 4];
        if ( v33 != 3 )
          v35[v28 + 5] = v32 * 0.0625 + v35[v28 + 5];
      }
      LODWORD(v46) += 16;
      ++v28;
    }
    while ( v28 < v48 );
    a1 = *(float *)&v27;
LABEL_58:
    LODWORD(v47) += 128;
    *(_BYTE *)(v26 + 1) = BYTE2(a1);
    v25 = v48;
    *(_WORD *)(v26 - 1) = v27;
    v26 += 3;
  }
  while ( v25 < 0x10 );
  a2 = dword_1005DB70;
  return 0;
}

// grim_dxt2_decode_block @ 0x10022114
int __cdecl sub_10022114(float *a1, unsigned __int16 *a2)
{
  int result; // eax

  result = grim_dxt3_decode_block(a1, a2);
  if ( result >= 0 )
  {
    result = grim_dxt_unpremultiply_rgba_block(a1);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt4_decode_block @ 0x10022137
int __cdecl grim_dxt4_decode_block(float *a1, unsigned __int16 *a2)
{
  int result; // eax

  result = grim_dxt5_decode_block(a1, a2);
  if ( result >= 0 )
  {
    result = grim_dxt_unpremultiply_rgba_block(a1);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt2_encode_block @ 0x1002215A
// premultiplies RGBA and encodes a DXT3-style block (DXT2)
int __cdecl sub_1002215A(_DWORD *a1, float *a2)
{
  int result; // eax
  float v3[64]; // [esp+0h] [ebp-100h] BYREF

  result = grim_dxt_premultiply_rgba_block(a2, v3);
  if ( result >= 0 )
  {
    result = grim_dxt3_encode_block(a1, v3);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// grim_dxt4_encode_block @ 0x1002218E
// premultiplies RGBA and encodes a DXT5-style block (DXT4)
int __cdecl sub_1002218E(float a1, float *a2)
{
  int result; // eax
  float v3[64]; // [esp+0h] [ebp-100h] BYREF

  result = grim_dxt_premultiply_rgba_block(a2, v3);
  if ( result >= 0 )
  {
    result = grim_dxt5_encode_block(a1, (int)v3);
    if ( result >= 0 )
      return 0;
  }
  return result;
}

// sub_100221D0 @ 0x100221D0
__m128 *(__stdcall **__cdecl sub_100221D0(
        __m128 *(__stdcall **a1)(__m128 *, unsigned int *, __m128 *)))(__m128 *, unsigned int *, __m128 *)
{
  a1[28] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026970;
  *a1 = sub_10025C00;
  a1[13] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100266F0;
  a1[27] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100267E0;
  a1[11] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100278B0;
  a1[48] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100265D0;
  a1[47] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100261F0;
  a1[17] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026490;
  a1[54] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026580;
  a1[53] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026280;
  a1[52] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100263F0;
  a1[51] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026520;
  a1[50] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026130;
  a1[49] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026330;
  a1[18] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100272D0;
  a1[22] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026630;
  a1[25] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026D10;
  a1[24] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026BF0;
  a1[19] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026A50;
  a1[44] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026B80;
  a1[20] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026AE0;
  a1[16] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025FE0;
  a1[21] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025F00;
  a1[8] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026090;
  a1[7] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025E30;
  a1[10] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026F60;
  a1[9] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025C40;
  a1[6] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026DE0;
  a1[5] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CA0;
  a1[4] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027590;
  a1[3] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CE0;
  a1[2] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027060;
  a1[1] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026EA0;
  return a1;
}

// sub_100222E0 @ 0x100222E0
__m128 *(__stdcall **__cdecl sub_100222E0(
        __m128 *(__stdcall **a1)(__m128 *, unsigned int *, __m128 *)))(__m128 *, unsigned int *, __m128 *)
{
  a1[28] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027C00;
  *a1 = sub_10025C00;
  a1[13] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027980;
  a1[27] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027A70;
  a1[11] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100278B0;
  a1[48] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100265D0;
  a1[47] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100261F0;
  a1[17] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026490;
  a1[54] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026580;
  a1[53] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026280;
  a1[52] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100263F0;
  a1[51] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026520;
  a1[50] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026130;
  a1[49] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026330;
  a1[18] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100272D0;
  a1[22] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026630;
  a1[25] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027E00;
  a1[24] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027CE0;
  a1[31] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027820;
  a1[30] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100277A0;
  a1[19] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026A50;
  a1[20] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026AE0;
  a1[16] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100276F0;
  a1[21] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_100271F0;
  a1[8] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026090;
  a1[7] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027120;
  a1[10] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026F60;
  a1[9] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025C40;
  a1[6] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026DE0;
  a1[5] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CA0;
  a1[4] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027590;
  a1[3] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10025CE0;
  a1[2] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10027060;
  a1[1] = (__m128 *(__stdcall *)(__m128 *, unsigned int *, __m128 *))sub_10026EA0;
  return a1;
}

// sub_100223F0 @ 0x100223F0
int sub_100223F0()
{
  char v26[16]; // [esp+Ch] [ebp-28h] BYREF
  _DWORD v27[5]; // [esp+1Ch] [ebp-18h] BYREF
  int v28; // [esp+30h] [ebp-4h]

  strcpy((char *)v27, "UnknownVendr");
  strcpy(v26, "AuthenticAMD");
  _EAX = 0;
  __asm { cpuid }
  v28 = 1;
  _EAX = 0;
  __asm { cpuid }
  v27[0] = _EBX;
  v27[1] = _EDX;
  v27[2] = _ECX;
  if ( _EAX )
  {
    _EAX = 1;
    __asm { cpuid }
    v27[4] = _EAX;
    v28 |= ((_EDX & 0x800000) != 0 ? 0x20 : 0) | 2;
    _EAX = 0x80000000;
    __asm { cpuid }
    if ( _EAX > 0x80000000 )
    {
      v28 |= 4u;
      _EAX = -2147483647;
      __asm { cpuid }
      v28 |= _EDX < 0 ? 0x80 : 0;
      if ( !memcmp(v26, v27, 0xCu) )
      {
        v28 |= (_EDX & 0x40000000) != 0 ? 0x100 : 0;
        return ((_EDX & 0x400000) != 0 ? 0x200 : 0) | v28;
      }
    }
  }
  return v28;
}

// sub_100224C5 @ 0x100224C5
int __cdecl sub_100224C5(__m64 *(__stdcall **a1)(__m64 *, __m64 *, __m64 *))
{
  int result; // eax

  result = sub_100223F0();
  if ( (result & 0x20) != 0 && (result & 0x80u) != 0 )
  {
    *a1 = sub_1002DCA8;
    a1[1] = sub_1002D1EA;
    a1[2] = sub_1002DF69;
    a1[3] = sub_1002943A;
    a1[5] = sub_1002DCFD;
    a1[6] = sub_1002D25B;
    a1[7] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D2C2;
    a1[8] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DFEB;
    a1[9] = sub_1002DD36;
    a1[10] = sub_1002D7A2;
    a1[11] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002966C;
    a1[12] = sub_1002E393;
    a1[13] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E3D6;
    a1[14] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D7A7;
    a1[15] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D92F;
    a1[16] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E04A;
    a1[17] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DD9A;
    a1[18] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D1CE;
    a1[19] = sub_10027ED0;
    a1[20] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10027F69;
    a1[21] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E578;
    a1[22] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E4BA;
    a1[23] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10027FC6;
    a1[24] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10028079;
    a1[25] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_100284AA;
    a1[26] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002973B;
    a1[27] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002978B;
    a1[28] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029876;
    a1[29] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002856F;
    a1[30] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029952;
    a1[31] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_100299B5;
    a1[32] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029A13;
    a1[33] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029A6C;
    a1[34] = sub_1002E5DC;
    a1[35] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_100285DB;
    a1[36] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10028712;
    a1[37] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029AB3;
    a1[38] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029B5B;
    a1[39] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029CE2;
    a1[40] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002AE7A;
    a1[41] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002B01F;
    a1[42] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002B553;
    a1[43] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002879F;
    a1[44] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10028831;
    a1[54] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E17C;
    a1[51] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D321;
    a1[48] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DE32;
    a1[46] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DE7B;
    a1[52] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E1ED;
    a1[49] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D392;
    a1[55] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10028895;
    a1[56] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002893C;
    a1[53] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002E2B5;
    a1[47] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DEBE;
    a1[50] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002D466;
    a1[4] = sub_1002CAA2;
    a1[45] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_100289E1;
    if ( (result & 0x100) != 0 && (result & 0x200) != 0 )
    {
      a1[15] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002DB55;
      a1[18] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002C7C0;
      a1[38] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10029C2D;
      a1[39] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_1002B66C;
      a1[24] = (__m64 *(__stdcall *)(__m64 *, __m64 *, __m64 *))sub_10028295;
    }
  }
  return result;
}

// sub_100226EB @ 0x100226EB
float *__stdcall sub_100226EB(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_10022754 @ 0x10022754
float *__stdcall sub_10022754(float *a1, float *a2, float *a3)
{
  double v3; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5];
  *a1 = *a2 * *a3 + a2[1] * a3[4];
  a1[1] = v3;
  return a1;
}

// sub_10022789 @ 0x10022789
float *__stdcall sub_10022789(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// sub_10022814 @ 0x10022814
float *__stdcall sub_10022814(float *a1, float *a2, float *a3)
{
  double v3; // st6
  double v4; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8];
  a1[1] = v3;
  a1[2] = v4;
  return a1;
}

// sub_10022873 @ 0x10022873
float *__stdcall sub_10022873(float *a1, float *a2, float *a3)
{
  double v3; // st5
  double v4; // st6
  double v5; // st7

  v3 = *a2 * a3[1] + a2[1] * a3[5] + a2[2] * a3[9] + a2[3] * a3[13];
  v4 = *a2 * a3[2] + a2[1] * a3[6] + a2[2] * a3[10] + a2[3] * a3[14];
  v5 = *a2 * a3[3] + a2[1] * a3[7] + a2[2] * a3[11] + a2[3] * a3[15];
  *a1 = *a2 * *a3 + a2[1] * a3[4] + a2[2] * a3[8] + a2[3] * a3[12];
  a1[1] = v3;
  a1[2] = v4;
  a1[3] = v5;
  return a1;
}

// FUN_1002290c @ 0x1002290C
// [binja] float* __stdcall sub_1002290c(float* arg1, float* arg2)
float *__stdcall sub_1002290C(float *a1, float *a2)
{
  float v8; // [esp+4h] [ebp-8h]
  float v9; // [esp+8h] [ebp-4h]
  int v10; // [esp+8h] [ebp-4h]
  unsigned int v11; // [esp+8h] [ebp-4h]

  _EDX = a2;
  __asm
  {
    fld     dword ptr [edx]
    fmul    dword ptr [edx]
    fld     dword ptr [edx+4]
    fmul    dword ptr [edx+4]
    fld     dword ptr [edx+8]
    fmul    dword ptr [edx+8]
    fxch    st(2)
    faddp   st(1), st
    faddp   st(1), st
    fst     [ebp+var_8]
  }
  if ( v8 == 0.0 )
  {
    __asm { ffree   st }
    *(_DWORD *)a1 = LOBYTE(v8);
    *((_DWORD *)a1 + 1) = LOBYTE(v8);
    *((_DWORD *)a1 + 2) = LOBYTE(v8);
  }
  else
  {
    __asm
    {
      fld1
      fsubp   st(1), st
      fstp    [ebp+var_4]
    }
    if ( (LODWORD(v9) & 0x7FFFFFFFu) > 0x3727C5AC )
    {
      _EDI = (LODWORD(v8) >> 12) & 0xFF8;
      v10 = LODWORD(v8) & 0xFFFFFF | 0x3F000000;
      __asm
      {
        fld     [ebp+var_4]
        fmul    flt_100544E0[edi]
      }
      __asm { fadd    flt_100544E4[edi] }
      v11 = ((unsigned int)(-1090519041 - LODWORD(v8)) >> 1) & 0xFF800000;
      __asm
      {
        fmul    [ebp+var_4]
        fld     dword ptr [edx]
        fmul    st, st(1)
        fld     dword ptr [edx+4]
        fmul    st, st(2)
        fld     dword ptr [edx+8]
        fmul    st, st(3)
        fxch    st(2)
        fstp    dword ptr [ecx]
      }
      *a1 = _ET1;
      __asm { fstp    dword ptr [ecx+4] }
      a1[1] = _ET1;
      __asm { fstp    dword ptr [ecx+8] }
      a1[2] = _ET1;
      __asm { fstp    st }
    }
    else if ( a1 != a2 )
    {
      *a1 = *a2;
      a1[1] = a2[1];
      a1[2] = a2[2];
    }
  }
  return a1;
}

// FUN_100229d6 @ 0x100229D6
// [binja] int32_t __stdcall sub_100229d6(int32_t arg1, int32_t arg2, void* arg3)
_BYTE *__stdcall sub_100229D6(_BYTE *a1, _BYTE *a2, _BYTE *a3)
{
  _BYTE *result; // eax
  _BYTE *v4; // ebx
  _BYTE *v10; // ebx
  int v13; // edi
  _BYTE v16[64]; // [esp+Ch] [ebp-40h] BYREF

  result = a1;
  if ( a3 == a1 )
  {
    if ( a2 != a1 )
    {
      v4 = a1;
      _ECX = a2;
      _EDX = a3;
      _EDI = -4;
      do
      {
        _ESI = -16;
        __asm
        {
          fld     dword ptr [edx+edi*4+10h]
          fld     dword ptr [edx+edi*4+20h]
          fld     dword ptr [edx+edi*4+30h]
          fld     dword ptr [edx+edi*4+40h]
        }
        do
        {
          __asm
          {
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+40h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+44h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+48h]
            fld     st(3)
            fmul    dword ptr [ecx+esi*4+4Ch]
            fxch    st(3)
            faddp   st(1), st
            fxch    st(2)
            faddp   st(1), st
            faddp   st(1), st
            fstp    dword ptr [ebx+esi*4+40h]
          }
          *(float *)&v4[4 * _ESI + 64] = _ET1;
          _ESI += 4;
        }
        while ( _ESI );
        __asm
        {
          ffree   st(3)
          ffree   st(2)
          ffree   st(1)
          ffree   st
        }
        v4 += 4;
        ++_EDI;
      }
      while ( _EDI );
      return result;
    }
    qmemcpy(v16, a3, sizeof(v16));
    a3 = v16;
  }
  v10 = a1;
  _ECX = a2;
  _EDX = a3;
  v13 = -4;
  do
  {
    _ESI = -4;
    __asm
    {
      fld     dword ptr [ecx]
      fld     dword ptr [ecx+4]
      fld     dword ptr [ecx+8]
      fld     dword ptr [ecx+0Ch]
    }
    do
    {
      __asm
      {
        fld     st(3)
        fmul    dword ptr [edx+esi*4+10h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+20h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+30h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+40h]
        fxch    st(3)
        faddp   st(1), st
        fxch    st(2)
        faddp   st(1), st
        faddp   st(1), st
        fstp    dword ptr [ebx+esi*4+10h]
      }
      *(float *)&v10[4 * _ESI++ + 16] = _ET1;
    }
    while ( _ESI );
    __asm
    {
      ffree   st(3)
      ffree   st(2)
      ffree   st(1)
      ffree   st
    }
    _ECX += 16;
    v10 += 16;
    ++v13;
  }
  while ( v13 );
  return result;
}

// FUN_10022ab9 @ 0x10022AB9
// [binja] void* __stdcall sub_10022ab9(void* arg1, int32_t arg2, int32_t arg3)
char *__stdcall sub_10022AB9(char *a1, char *a2, char *a3)
{
  char *v3; // eax
  int v6; // edi
  float *v8; // ebx
  char *result; // eax
  char v11; // [esp+0h] [ebp-44h] BYREF
  char *v12; // [esp+40h] [ebp-4h]

  v3 = a1;
  if ( a1 == a2 || a1 == a3 )
    v3 = &v11;
  v12 = v3;
  _ECX = a2;
  _EDX = a3;
  v6 = -4;
  do
  {
    _ESI = -4;
    v8 = (float *)&v3[4 * v6 + 16];
    __asm
    {
      fld     dword ptr [ecx]
      fld     dword ptr [ecx+4]
      fld     dword ptr [ecx+8]
      fld     dword ptr [ecx+0Ch]
    }
    do
    {
      __asm
      {
        fld     st(3)
        fmul    dword ptr [edx+esi*4+10h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+20h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+30h]
        fld     st(3)
        fmul    dword ptr [edx+esi*4+40h]
        fxch    st(3)
        faddp   st(1), st
        fxch    st(2)
        faddp   st(1), st
        faddp   st(1), st
        fstp    dword ptr [ebx]
      }
      *v8 = _ET1;
      v8 += 4;
      ++_ESI;
    }
    while ( _ESI );
    __asm
    {
      ffree   st(3)
      ffree   st(2)
      ffree   st(1)
      ffree   st
    }
    _ECX += 16;
    ++v6;
  }
  while ( v6 );
  result = a1;
  if ( v12 != a1 )
    qmemcpy(a1, v12, 0x40u);
  return result;
}

// sub_10022B47 @ 0x10022B47
float *(__stdcall **__cdecl sub_10022B47(
        float *(__stdcall **a1)(float *a1, float *a2, float *a3)))(float *a1, float *a2, float *a3)
{
  *a1 = sub_100226EB;
  a1[1] = sub_10022789;
  a1[2] = sub_10022873;
  a1[3] = (float *(__stdcall *)(float *, float *, float *))FUN_100229d6;
  a1[4] = (float *(__stdcall *)(float *, float *, float *))FUN_10022ab9;
  a1[5] = sub_10022754;
  a1[6] = sub_10022814;
  a1[7] = (float *(__stdcall *)(float *, float *, float *))FUN_1002290c;
  return a1;
}

// sub_10022B83 @ 0x10022B83
int __cdecl sub_10022B83(int a1, int a2)
{
  return (a1 + a2 - 1) / a2;
}

// sub_10022B93 @ 0x10022B93
int __cdecl sub_10022B93(int a1, int a2)
{
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

// sub_10022BAB @ 0x10022BAB
const void **__cdecl sub_10022BAB(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  const void **result; // eax
  void **v7; // edx
  int v8; // [esp+Ch] [ebp+Ch]

  result = (const void **)(a1 + 4 * a2);
  v7 = (void **)(a3 + 4 * a4);
  if ( a5 > 0 )
  {
    v8 = a5;
    do
    {
      qmemcpy(*v7++, *result++, a6);
      --v8;
    }
    while ( v8 );
  }
  return result;
}

// sub_10022BF2 @ 0x10022BF2
int __cdecl sub_10022BF2(const void *a1, void *a2, int a3)
{
  qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
  return a3 << 7;
}

// memzero @ 0x10022C14
// zero-fill helper (memset to 0)
int __cdecl sub_10022C14(void *a1, unsigned int a2)
{
  memset(a1, 0, a2);
  return 0;
}

// FUN_10022c2f @ 0x10022C2F
// [binja] int32_t __fastcall sub_10022c2f(int32_t arg1)
unsigned int sub_10022C2F()
{
  unsigned int v0; // kr00_4
  unsigned int v1; // kr04_4
  int v2; // edx

  v0 = __readeflags();
  __writeeflags(v0 ^ 0x200000);
  v1 = __readeflags();
  v2 = v0 ^ v1;
  if ( v0 != v1 )
  {
    _EAX = 1;
    __asm { cpuid }
    return (_EDX & 0x800000u) >> 23;
  }
  return v2;
}

// sub_10022C61 @ 0x10022C61
int __usercall sub_10022C61@<eax>(int a1@<esi>)
{
  int v1; // ebx
  bool v2; // cc
  int v3; // edi
  int *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // eax
  int v9; // ebx
  int v10; // edi
  int v11; // eax
  int result; // eax

  if ( *(int *)(a1 + 28) > 65500 || *(int *)(a1 + 24) > 65500 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 40;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 65500;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_DWORD *)(a1 + 192) != 8 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 13;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 192);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(int *)(a1 + 32) > 10 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v1 = 0;
  v2 = *(_DWORD *)(a1 + 32) <= 0;
  v3 = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a1 + 268) = 1;
  *(_DWORD *)(a1 + 272) = 1;
  if ( !v2 )
  {
    v4 = (int *)(v3 + 12);
    do
    {
      v5 = *(v4 - 1);
      if ( v5 <= 0 || v5 > 4 || *v4 <= 0 || *v4 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 16;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v6 = *(_DWORD *)(a1 + 268);
      if ( v6 <= *(v4 - 1) )
        v6 = *(v4 - 1);
      *(_DWORD *)(a1 + 268) = v6;
      v7 = *(_DWORD *)(a1 + 272);
      if ( v7 <= *v4 )
        v7 = *v4;
      ++v1;
      *(_DWORD *)(a1 + 272) = v7;
      v4 += 21;
    }
    while ( v1 < *(_DWORD *)(a1 + 32) );
  }
  v8 = *(_DWORD *)(a1 + 196);
  v9 = 0;
  v2 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 276) = 8;
  if ( !v2 )
  {
    v10 = v8 + 28;
    do
    {
      *(_DWORD *)(v10 + 8) = 8;
      *(_DWORD *)v10 = sub_10022B83(*(_DWORD *)(a1 + 24) * *(_DWORD *)(v10 - 20), 8 * *(_DWORD *)(a1 + 268));
      *(_DWORD *)(v10 + 4) = sub_10022B83(*(_DWORD *)(a1 + 28) * *(_DWORD *)(v10 - 16), 8 * *(_DWORD *)(a1 + 272));
      *(_DWORD *)(v10 + 12) = sub_10022B83(*(_DWORD *)(a1 + 24) * *(_DWORD *)(v10 - 20), *(_DWORD *)(a1 + 268));
      v11 = sub_10022B83(*(_DWORD *)(a1 + 28) * *(_DWORD *)(v10 - 16), *(_DWORD *)(a1 + 272));
      *(_DWORD *)(v10 + 48) = 0;
      *(_DWORD *)(v10 + 16) = v11;
      *(_BYTE *)(v10 + 20) = 1;
      ++v9;
      v10 += 84;
    }
    while ( v9 < *(_DWORD *)(a1 + 32) );
  }
  *(_DWORD *)(a1 + 280) = sub_10022B83(*(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
  if ( *(_DWORD *)(a1 + 288) < *(_DWORD *)(a1 + 32) || *(_BYTE *)(a1 + 200) )
  {
    result = *(_DWORD *)(a1 + 396);
    *(_BYTE *)(result + 16) = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 396);
    *(_BYTE *)(result + 16) = 0;
  }
  return result;
}

// sub_10022E1C @ 0x10022E1C
int __usercall sub_10022E1C@<eax>(int *a1@<esi>)
{
  int v1; // eax
  _DWORD *v2; // ecx
  unsigned int v3; // ebx
  int result; // eax
  int v5; // edx
  bool v6; // cc
  _DWORD *v7; // ecx
  unsigned int v8; // ebx
  int v9; // edi
  int v10; // edx
  int v11; // edi
  unsigned int v12; // eax
  unsigned int v13; // ebx
  int v14; // edx
  int *v15; // [esp+8h] [ebp-8h]
  int v16; // [esp+Ch] [ebp-4h]

  v1 = a1[72];
  if ( v1 == 1 )
  {
    v2 = (_DWORD *)a1[73];
    a1[77] = v2[7];
    a1[78] = v2[8];
    v3 = v2[3];
    v2[16] = v2[9];
    result = v2[8] / v3;
    v5 = v2[8] % v3;
    v2[13] = 1;
    v2[14] = 1;
    v2[15] = 1;
    v2[17] = 1;
    if ( !v5 )
      v5 = v3;
    v2[18] = v5;
    a1[80] = 0;
    a1[79] = 1;
  }
  else
  {
    if ( v1 <= 0 || v1 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 24;
      *(_DWORD *)(*a1 + 24) = a1[72];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    a1[77] = sub_10022B83(a1[6], 8 * a1[67]);
    result = sub_10022B83(a1[7], 8 * a1[68]);
    v6 = a1[72] <= 0;
    a1[78] = result;
    a1[79] = 0;
    v16 = 0;
    if ( !v6 )
    {
      v15 = a1 + 73;
      do
      {
        v7 = (_DWORD *)*v15;
        v8 = *(_DWORD *)(*v15 + 8);
        v9 = *(_DWORD *)(*v15 + 12);
        v7[16] = v8 * *(_DWORD *)(*v15 + 36);
        v10 = v7[7] % v8;
        v7[14] = v9;
        v11 = v8 * v9;
        v7[13] = v8;
        v7[15] = v11;
        if ( !v10 )
          v10 = v8;
        v12 = v7[8];
        v13 = v7[3];
        v7[17] = v10;
        v14 = v12 % v13;
        if ( !(v12 % v13) )
          v14 = v13;
        v7[18] = v14;
        if ( v11 + a1[79] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 11;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        if ( v11 > 0 )
        {
          do
          {
            a1[a1[79]++ + 80] = v16;
            --v11;
          }
          while ( v11 );
        }
        result = ++v16;
        ++v15;
      }
      while ( v16 < a1[72] );
    }
  }
  return result;
}

// sub_10022F92 @ 0x10022F92
void __usercall sub_10022F92(int a1@<ebx>)
{
  unsigned int v1; // esi
  void *v2; // eax
  int v3; // [esp+0h] [ebp-Ch]
  int v4; // [esp+4h] [ebp-8h]
  int *v5; // [esp+8h] [ebp-4h]

  v4 = 0;
  if ( *(int *)(a1 + 288) > 0 )
  {
    v5 = (int *)(a1 + 292);
    do
    {
      v3 = *v5;
      if ( !*(_DWORD *)(*v5 + 76) )
      {
        v1 = *(_DWORD *)(*v5 + 16);
        if ( v1 >= 4 || !*(_DWORD *)(a1 + 4 * v1 + 144) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v1;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v2 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
        qmemcpy(v2, *(const void **)(a1 + 4 * v1 + 144), 0x82u);
        *(_DWORD *)(v3 + 76) = v2;
      }
      ++v4;
      ++v5;
    }
    while ( v4 < *(_DWORD *)(a1 + 288) );
  }
}

// sub_10023024 @ 0x10023024
int __cdecl sub_10023024(int a1)
{
  int result; // eax

  sub_10022E1C((int *)a1);
  sub_10022F92(a1);
  (**(void (__cdecl ***)(int))(a1 + 404))(a1);
  (**(void (__cdecl ***)(int))(a1 + 388))(a1);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
  **(_DWORD **)(a1 + 396) = result;
  return result;
}

// sub_1002305E @ 0x1002305E
int __cdecl sub_1002305E(_DWORD *a1)
{
  _BYTE *v1; // edi
  int v3; // ebp
  bool v4; // zf
  int v5; // esi

  v1 = (_BYTE *)a1[99];
  if ( v1[17] )
    return 2;
  v3 = (*(int (__cdecl **)(_DWORD *))(a1[100] + 4))(a1);
  if ( v3 == 1 )
  {
    if ( v1[20] )
    {
      sub_10022C61((int)a1);
      v1[20] = 0;
    }
    else
    {
      if ( !v1[16] )
      {
        *(_DWORD *)(*a1 + 20) = 34;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_10023024((int)a1);
    }
  }
  else if ( v3 == 2 )
  {
    v4 = v1[20] == 0;
    v1[17] = 1;
    if ( v4 )
    {
      v5 = a1[31];
      if ( a1[33] > v5 )
        a1[33] = v5;
    }
    else if ( *(_BYTE *)(a1[100] + 81) )
    {
      *(_DWORD *)(*a1 + 20) = 58;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  return v3;
}

// sub_100230F1 @ 0x100230F1
int __cdecl sub_100230F1(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 396);
  *(_BYTE *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 17) = 0;
  *(_DWORD *)v1 = sub_1002305E;
  *(_BYTE *)(v1 + 20) = 1;
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
  result = (**(int (__cdecl ***)(int))(a1 + 400))(a1);
  *(_DWORD *)(a1 + 140) = 0;
  return result;
}

// sub_10023128 @ 0x10023128
_DWORD *__cdecl sub_10023128(int a1)
{
  _DWORD *result; // eax

  result = *(_DWORD **)(a1 + 396);
  *result = sub_1002305E;
  return result;
}

// sub_10023139 @ 0x10023139
int __cdecl sub_10023139(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 396) = result;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_DWORD *)result = sub_1002305E;
  *(_DWORD *)(result + 4) = sub_100230F1;
  *(_DWORD *)(result + 8) = sub_10023024;
  *(_DWORD *)(result + 12) = sub_10023128;
  *(_BYTE *)(result + 20) = 1;
  return result;
}

// sub_1002317A @ 0x1002317A
int __usercall sub_1002317A@<eax>(int a1@<eax>, int a2@<edx>)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 53;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = a2;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// FUN_1002318f @ 0x1002318F
// [binja] void* sub_1002318f(int32_t* arg1, int32_t* arg2, int32_t* arg3)
int __cdecl sub_1002318F(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  _DWORD *v5; // eax
  unsigned int v6; // edi
  unsigned int v7; // esi
  _DWORD *v8; // ecx
  int v9; // ecx
  int v11; // [esp+Ch] [ebp-4h]
  _DWORD *v12; // [esp+1Ch] [ebp+Ch]
  _DWORD *v13; // [esp+20h] [ebp+10h]

  v3 = a3;
  v11 = a1[1];
  if ( a3 > 0x3B9AC9F0 )
    sub_1002317A((int)a1, 1);
  if ( (a3 & 7) != 0 )
    v3 = 8 - (a3 & 7) + a3;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v13 = 0;
  v12 = (_DWORD *)(v11 + 4 * a2 + 48);
  v5 = (_DWORD *)*v12;
  if ( !*v12 )
    goto LABEL_11;
  do
  {
    if ( v5[2] >= v3 )
      break;
    v13 = v5;
    v5 = (_DWORD *)*v5;
  }
  while ( v5 );
  if ( !v5 )
  {
LABEL_11:
    v6 = v3 + 16;
    if ( v13 )
      v7 = dword_1004EA08[a2];
    else
      v7 = dword_1004EA00[a2];
    if ( v7 > 1000000000 - v6 )
      v7 = 1000000000 - v6;
    while ( 1 )
    {
      v5 = (_DWORD *)FUN_1002e65a((int)a1, v7 + v6);
      if ( v5 )
        break;
      v7 >>= 1;
      if ( v7 < 0x32 )
        sub_1002317A((int)a1, 2);
    }
    *(_DWORD *)(v11 + 72) += v7 + v6;
    v8 = v13;
    *v5 = 0;
    v5[1] = 0;
    v5[2] = v3 + v7;
    if ( !v13 )
      v8 = v12;
    *v8 = v5;
  }
  v9 = v5[1];
  v5[2] -= v3;
  v5[1] = v3 + v9;
  return (int)v5 + v9 + 16;
}

// FUN_1002328b @ 0x1002328B
// [binja] void* sub_1002328b(uint32_t arg1, int32_t arg2, int32_t arg3)
_DWORD *__cdecl sub_1002328B(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  int v3; // ebx
  unsigned int v4; // edi
  _DWORD *v5; // esi
  int *v6; // eax
  int v7; // ecx

  v3 = a1[1];
  v4 = a3;
  if ( a3 > 0x3B9AC9F0 )
    sub_1002317A((int)a1, 3);
  if ( (a3 & 7) != 0 )
    v4 = 8 - (a3 & 7) + a3;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v5 = (_DWORD *)FUN_1002e65a((int)a1, v4 + 16);
  if ( !v5 )
    sub_1002317A((int)a1, 4);
  *(_DWORD *)(v3 + 72) += v4 + 16;
  v6 = (int *)(v3 + 4 * a2 + 56);
  v7 = *v6;
  v5[2] = 0;
  v5[1] = v4;
  *v5 = v7;
  *v6 = (int)v5;
  return v5 + 4;
}

// sub_10023319 @ 0x10023319
int __cdecl sub_10023319(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v4; // edi
  unsigned int v5; // esi
  unsigned int v7; // edi
  _DWORD *v8; // eax
  unsigned int v9; // ecx
  int v11; // [esp+20h] [ebp+14h]

  v4 = a1[1];
  v5 = 0x3B9AC9F0 / a3;
  if ( (int)(0x3B9AC9F0 / a3) <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)v5 >= (int)a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  v7 = 0;
  v11 = FUN_1002318f(a1, a2, 4 * a4);
  while ( v7 < a4 )
  {
    if ( v5 >= a4 - v7 )
      v5 = a4 - v7;
    v8 = FUN_1002328b(a1, a2, a3 * v5);
    if ( v5 )
    {
      v9 = v5;
      do
      {
        *(_DWORD *)(v11 + 4 * v7) = v8;
        v8 = (_DWORD *)((char *)v8 + a3);
        ++v7;
        --v9;
      }
      while ( v9 );
    }
  }
  return v11;
}

// sub_100233AB @ 0x100233AB
int __cdecl sub_100233AB(_DWORD *a1, unsigned int a2, int a3, signed int a4)
{
  int v4; // edi
  signed int v5; // esi
  unsigned int v7; // edi
  _DWORD *v8; // eax
  signed int v9; // ecx
  int v11; // [esp+24h] [ebp+14h]

  v4 = a1[1];
  v5 = 0x3B9AC9F0u / (a3 << 7);
  if ( v5 <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( v5 >= a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  v7 = 0;
  v11 = FUN_1002318f(a1, a2, 4 * a4);
  while ( v7 < a4 )
  {
    if ( v5 >= a4 - v7 )
      v5 = a4 - v7;
    v8 = FUN_1002328b(a1, a2, (a3 * v5) << 7);
    if ( v5 )
    {
      v9 = v5;
      do
      {
        *(_DWORD *)(v11 + 4 * v7) = v8;
        v8 += 32 * a3;
        ++v7;
        --v9;
      }
      while ( v9 );
    }
  }
  return v11;
}

// FUN_10023449 @ 0x10023449
// [binja] void* sub_10023449(int32_t* arg1, int32_t* arg2, char arg3, int32_t arg4, int32_t arg5, int32_t arg6)
int __cdecl sub_10023449(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // esi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = FUN_1002318f(a1, a2, 0x78u);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 32) = a3;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 64);
  *(_DWORD *)(v6 + 64) = result;
  return result;
}

// FUN_100234aa @ 0x100234AA
// [binja] void* sub_100234aa(int32_t* arg1, int32_t* arg2, char arg3, int32_t arg4, int32_t arg5, int32_t arg6)
int __cdecl sub_100234AA(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // esi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = FUN_1002318f(a1, a2, 0x78u);
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 34) = 0;
  *(_BYTE *)(result + 32) = a3;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(v6 + 68) = result;
  return result;
}

// sub_1002350B @ 0x1002350B
int __cdecl sub_1002350B(_DWORD *a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // eax
  int v3; // esi
  int v4; // ebx
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  int i; // esi
  int v9; // ebx
  unsigned int v10; // ecx
  int j; // esi
  int v12; // ebx
  unsigned int v13; // ecx
  signed int v14; // [esp+Ch] [ebp-4h]

  v1 = (_DWORD *)a1[1];
  v2 = (_DWORD *)v1[16];
  v3 = 0;
  v4 = 0;
  while ( v2 )
  {
    if ( !*v2 )
    {
      v5 = v2[2];
      v3 += v5 * v2[3];
      v4 += v5 * v2[1];
    }
    v2 = (_DWORD *)v2[9];
  }
  for ( result = v1[17]; result; result = *(_DWORD *)(result + 36) )
  {
    if ( !*(_DWORD *)result )
    {
      v7 = *(_DWORD *)(result + 8);
      v3 += (v7 * *(_DWORD *)(result + 12)) << 7;
      v4 += (v7 * *(_DWORD *)(result + 4)) << 7;
    }
  }
  if ( v3 > 0 )
  {
    result = FUN_1002e670(a1, v3, v4);
    if ( result < v4 )
    {
      result /= v3;
      v14 = result;
      if ( result <= 0 )
        v14 = 1;
    }
    else
    {
      v14 = 1000000000;
    }
    for ( i = v1[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( !*(_DWORD *)i )
      {
        v9 = *(_DWORD *)(i + 4);
        v10 = *(_DWORD *)(i + 12);
        if ( (int)((v9 - 1) / v10 + 1) > v14 )
        {
          *(_DWORD *)(i + 16) = v14 * v10;
          sub_1002E675(a1);
          *(_BYTE *)(i + 34) = 1;
        }
        else
        {
          *(_DWORD *)(i + 16) = v9;
        }
        *(_DWORD *)i = sub_10023319(a1, 1u, *(_DWORD *)(i + 8), *(_DWORD *)(i + 16));
        result = v1[19];
        *(_DWORD *)(i + 24) = 0;
        *(_DWORD *)(i + 28) = 0;
        *(_BYTE *)(i + 33) = 0;
        *(_DWORD *)(i + 20) = result;
      }
    }
    for ( j = v1[17]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( !*(_DWORD *)j )
      {
        v12 = *(_DWORD *)(j + 4);
        v13 = *(_DWORD *)(j + 12);
        if ( (int)((v12 - 1) / v13 + 1) > v14 )
        {
          *(_DWORD *)(j + 16) = v14 * v13;
          sub_1002E675(a1);
          *(_BYTE *)(j + 34) = 1;
        }
        else
        {
          *(_DWORD *)(j + 16) = v12;
        }
        *(_DWORD *)j = sub_100233AB(a1, 1u, *(_DWORD *)(j + 8), *(_DWORD *)(j + 16));
        result = v1[19];
        *(_DWORD *)(j + 24) = 0;
        *(_DWORD *)(j + 28) = 0;
        *(_BYTE *)(j + 33) = 0;
        *(_DWORD *)(j + 20) = result;
      }
    }
  }
  return result;
}

// sub_1002368A @ 0x1002368A
int __usercall sub_1002368A@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebx
  int result; // eax
  int i; // edi
  int v6; // ecx
  int v7; // [esp-4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v3 = *(_DWORD *)(a1 + 8) * *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 8);
  result = *(_DWORD *)(a1 + 16);
  for ( i = 0; i < result; v3 += v9 )
  {
    result -= i;
    if ( *(_DWORD *)(a1 + 20) < result )
      result = *(_DWORD *)(a1 + 20);
    v6 = i + *(_DWORD *)(a1 + 24);
    if ( result >= *(_DWORD *)(a1 + 28) - v6 )
      result = *(_DWORD *)(a1 + 28) - v6;
    if ( result >= *(_DWORD *)(a1 + 4) - v6 )
      result = *(_DWORD *)(a1 + 4) - v6;
    if ( result <= 0 )
      break;
    v7 = v8 * result;
    v9 = v8 * result;
    if ( a3 )
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 44))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    else
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 40))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    i += *(_DWORD *)(a1 + 20);
    result = *(_DWORD *)(a1 + 16);
  }
  return result;
}

// sub_10023712 @ 0x10023712
int __usercall sub_10023712@<eax>(int a1@<esi>, int a2, char a3)
{
  int v3; // ebx
  int result; // eax
  int i; // edi
  int v6; // ecx
  int v7; // [esp-4h] [ebp-14h]
  int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v3 = (*(_DWORD *)(a1 + 8) << 7) * *(_DWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 8) << 7;
  result = *(_DWORD *)(a1 + 16);
  for ( i = 0; i < result; v3 += v9 )
  {
    result -= i;
    if ( *(_DWORD *)(a1 + 20) < result )
      result = *(_DWORD *)(a1 + 20);
    v6 = i + *(_DWORD *)(a1 + 24);
    if ( result >= *(_DWORD *)(a1 + 28) - v6 )
      result = *(_DWORD *)(a1 + 28) - v6;
    if ( result >= *(_DWORD *)(a1 + 4) - v6 )
      result = *(_DWORD *)(a1 + 4) - v6;
    if ( result <= 0 )
      break;
    v7 = v8 * result;
    v9 = v8 * result;
    if ( a3 )
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 44))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    else
      (*(void (__cdecl **)(int, int, _DWORD, int, int))(a1 + 40))(
        a2,
        a1 + 40,
        *(_DWORD *)(*(_DWORD *)a1 + 4 * i),
        v3,
        v7);
    i += *(_DWORD *)(a1 + 20);
    result = *(_DWORD *)(a1 + 16);
  }
  return result;
}

// sub_1002379D @ 0x1002379D
int __cdecl sub_1002379D(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebx
  int v6; // edi
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // eax
  unsigned int v10; // edi
  int v11; // eax
  unsigned int v12; // edi
  unsigned int v13; // ebx
  unsigned int v15; // [esp+20h] [ebp+14h]

  v5 = a3 + a4;
  if ( a3 + a4 <= *(_DWORD *)(a2 + 4) && a4 <= *(_DWORD *)(a2 + 12) && *(_DWORD *)a2 )
  {
    v6 = a1;
  }
  else
  {
    v6 = a1;
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v7 = *(_DWORD *)(a2 + 24);
  if ( a3 < v7 || v5 > v7 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)v6 + 20) = 68;
      (**(void (__cdecl ***)(int))v6)(v6);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_1002368A(a2, v6, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    v8 = a3;
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v8 = v5 - *(_DWORD *)(a2 + 16);
      if ( v8 < 0 )
        v8 = 0;
    }
    *(_DWORD *)(a2 + 24) = v8;
    sub_1002368A(a2, v6, 0);
  }
  v9 = *(_DWORD *)(a2 + 28);
  if ( v9 < v5 )
  {
    if ( v9 >= a3 )
    {
      v10 = *(_DWORD *)(a2 + 28);
    }
    else
    {
      if ( a5 )
      {
        *(_DWORD *)(*(_DWORD *)v6 + 20) = 20;
        (**(void (__cdecl ***)(int))v6)(v6);
      }
      v10 = a3;
    }
    if ( a5 )
      *(_DWORD *)(a2 + 28) = v5;
    if ( *(_BYTE *)(a2 + 32) )
    {
      v15 = *(_DWORD *)(a2 + 8);
      v11 = *(_DWORD *)(a2 + 24);
      v12 = v10 - v11;
      v13 = v5 - v11;
      while ( v12 < v13 )
        memzero(*(void **)(*(_DWORD *)a2 + 4 * v12++), v15);
    }
    else
    {
      if ( a5 )
      {
LABEL_32:
        *(_BYTE *)(a2 + 33) = 1;
        return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
  }
  if ( a5 )
    goto LABEL_32;
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// sub_100238BB @ 0x100238BB
int __cdecl sub_100238BB(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v6; // edi
  unsigned int v7; // eax
  int v8; // eax
  unsigned int v9; // ebx
  int v10; // eax
  unsigned int v11; // edi
  unsigned int v12; // ebx
  unsigned int v14; // [esp+20h] [ebp+14h]
  unsigned int v15; // [esp+20h] [ebp+14h]

  v6 = a3 + a4;
  v14 = a3 + a4;
  if ( v14 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v7 = *(_DWORD *)(a2 + 24);
  if ( a3 < v7 || v6 > v7 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      sub_10023712(a2, a1, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v8 = v6 - *(_DWORD *)(a2 + 16);
      if ( v8 < 0 )
        v8 = 0;
      *(_DWORD *)(a2 + 24) = v8;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    sub_10023712(a2, a1, 0);
  }
  v9 = *(_DWORD *)(a2 + 28);
  if ( v9 < v6 )
  {
    if ( v9 < a3 )
    {
      if ( a5 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v9 = a3;
    }
    if ( a5 )
      *(_DWORD *)(a2 + 28) = v6;
    if ( *(_BYTE *)(a2 + 32) )
    {
      v10 = *(_DWORD *)(a2 + 24);
      v11 = *(_DWORD *)(a2 + 8) << 7;
      v12 = v9 - v10;
      v15 = v14 - v10;
      while ( v12 < v15 )
        memzero(*(void **)(*(_DWORD *)a2 + 4 * v12++), v11);
    }
    else
    {
      if ( a5 )
      {
LABEL_32:
        *(_BYTE *)(a2 + 33) = 1;
        return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
      }
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
  }
  if ( a5 )
    goto LABEL_32;
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// sub_100239DE @ 0x100239DE
_DWORD *__cdecl sub_100239DE(_DWORD *a1, unsigned int a2)
{
  unsigned int v2; // ebx
  _DWORD *v3; // esi
  int i; // edi
  int j; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // ebx
  int v8; // edi
  _DWORD **v9; // ecx
  _DWORD *result; // eax
  _DWORD *v11; // ebx
  int v12; // edi

  v2 = a2;
  v3 = (_DWORD *)a1[1];
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 == 1 )
  {
    for ( i = v3[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( *(_BYTE *)(i + 34) )
      {
        *(_BYTE *)(i + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
      }
    }
    v3[16] = 0;
    for ( j = v3[17]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( *(_BYTE *)(j + 34) )
      {
        *(_BYTE *)(j + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(j + 48))(a1, j + 40);
      }
    }
    v3[17] = 0;
  }
  v6 = (_DWORD *)v3[a2 + 14];
  v3[a2 + 14] = 0;
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      v8 = v6[2] + v6[1] + 16;
      zcfree((int)a1, v6);
      v3[18] -= v8;
      v6 = v7;
    }
    while ( v7 );
    v2 = a2;
  }
  v9 = (_DWORD **)&v3[v2 + 12];
  result = *v9;
  *v9 = 0;
  if ( result )
  {
    do
    {
      v11 = (_DWORD *)*result;
      v12 = result[2] + result[1] + 16;
      zcfree((int)a1, result);
      v3[18] -= v12;
      result = v11;
    }
    while ( v11 );
  }
  return result;
}

// sub_10023ABF @ 0x10023ABF
void __cdecl sub_10023ABF(int a1)
{
  signed int i; // edi

  for ( i = 1; i >= 0; --i )
    sub_100239DE((_DWORD *)a1, i);
  zcfree(a1, *(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  nullsub_3();
}

// sub_10023AEF @ 0x10023AEF
_DWORD *__cdecl sub_10023AEF(_DWORD *a1)
{
  int v1; // edi
  _DWORD *result; // eax
  _DWORD *v3; // ecx
  int v4; // edx

  a1[1] = 0;
  v1 = sub_1002E689(a1);
  result = (_DWORD *)FUN_1002e65a((int)a1, 0x50u);
  if ( result )
  {
    *result = FUN_1002318f;
    result[1] = FUN_1002328b;
    result[2] = sub_10023319;
    result[3] = sub_100233AB;
    result[4] = FUN_10023449;
    result[5] = FUN_100234aa;
    result[6] = sub_1002350B;
    result[7] = sub_1002379D;
    result[8] = sub_100238BB;
    result[9] = sub_100239DE;
    result[10] = sub_10023ABF;
    result[11] = v1;
    v3 = result + 15;
    v4 = 2;
    do
    {
      *(v3 - 2) = 0;
      *v3-- = 0;
      --v4;
    }
    while ( v4 );
    result[16] = 0;
    result[17] = 0;
    result[18] = 80;
    a1[1] = result;
  }
  else
  {
    nullsub_3();
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 0;
    return (_DWORD *)(*(int (__cdecl **)(_DWORD *, _DWORD *))*a1)(a1, a1);
  }
  return result;
}

// sub_10023BA3 @ 0x10023BA3
int __cdecl sub_10023BA3(int a1)
{
  int result; // eax

  (*(void (__cdecl **)(int, int))(*(_DWORD *)(a1 + 4) + 36))(a1, 1);
  result = *(_BYTE *)(a1 + 12) != 0 ? 200 : 100;
  *(_DWORD *)(a1 + 16) = result;
  return result;
}

// sub_10023BC5 @ 0x10023BC5
int __cdecl sub_10023BC5(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = (*(int (__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

// sub_10023BE0 @ 0x10023BE0
int __cdecl sub_10023BE0(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

// sub_10023BFC @ 0x10023BFC
int __cdecl sub_10023BFC(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

// FUN_10023c18 @ 0x10023C18
// [binja] int32_t __fastcall sub_10023c18(int32_t arg1, void* arg2)
char __fastcall sub_10023C18(int a1, int a2)
{
  _DWORD *v2; // ecx
  char result; // al
  int v4; // edx

  if ( *(_BYTE *)(a2 + 72) )
    return 0;
  if ( *(_BYTE *)(a2 + 264) )
    return 0;
  if ( *(_DWORD *)(a2 + 36) != 3 )
    return 0;
  if ( *(_DWORD *)(a2 + 32) != 3 )
    return 0;
  if ( *(_DWORD *)(a2 + 40) != 2 )
    return 0;
  if ( *(_DWORD *)(a2 + 100) != 3 )
    return 0;
  v2 = *(_DWORD **)(a2 + 196);
  if ( v2[2] != 2 )
    return 0;
  result = 1;
  if ( v2[23] != 1 )
    return 0;
  if ( v2[44] != 1 )
    return 0;
  if ( (int)v2[3] > 2 )
    return 0;
  if ( v2[24] != 1 )
    return 0;
  if ( v2[45] != 1 )
    return 0;
  v4 = *(_DWORD *)(a2 + 276);
  if ( v2[9] != v4 || v2[30] != v4 || v2[51] != v4 )
    return 0;
  return result;
}

// sub_10023C89 @ 0x10023C89
char __cdecl sub_10023C89(int a1)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  bool v8; // cc
  _DWORD *v9; // eax
  int v10; // edx
  int v11; // ebx
  _DWORD *v12; // edi
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v18; // [esp-18h] [ebp-20h]
  int v19; // [esp-18h] [ebp-20h]
  int v20; // [esp-18h] [ebp-20h]
  int v21; // [esp+4h] [ebp-4h]
  int i; // [esp+10h] [ebp+8h]

  if ( *(_DWORD *)(a1 + 16) != 202 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 48);
  if ( 8 * v2 > v3 )
  {
    if ( 4 * v2 > v3 )
    {
      if ( 2 * v2 > v3 )
      {
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 24);
        v5 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 276) = 8;
      }
      else
      {
        v7 = sub_10022B83(*(_DWORD *)(a1 + 24), 2);
        v20 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = v7;
        v5 = sub_10022B83(v20, 2);
        *(_DWORD *)(a1 + 276) = 4;
      }
    }
    else
    {
      v6 = sub_10022B83(*(_DWORD *)(a1 + 24), 4);
      v19 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 92) = v6;
      v5 = sub_10022B83(v19, 4);
      *(_DWORD *)(a1 + 276) = 2;
    }
  }
  else
  {
    v4 = sub_10022B83(*(_DWORD *)(a1 + 24), 8);
    v18 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 92) = v4;
    v5 = sub_10022B83(v18, 8);
    *(_DWORD *)(a1 + 276) = 1;
  }
  v21 = 0;
  v8 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 96) = v5;
  if ( !v8 )
  {
    v9 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 12);
    do
    {
      v10 = *(_DWORD *)(a1 + 276);
      for ( i = v10; i < 8; i *= 2 )
      {
        if ( 2 * i * *(v9 - 1) > v10 * *(_DWORD *)(a1 + 268) )
          break;
        if ( 2 * i * *v9 > v10 * *(_DWORD *)(a1 + 272) )
          break;
      }
      ++v21;
      v9[6] = i;
      v9 += 21;
    }
    while ( v21 < *(_DWORD *)(a1 + 32) );
  }
  v11 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v12 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    do
    {
      v12[1] = sub_10022B83(*(_DWORD *)(a1 + 24) * *v12 * *(v12 - 7), 8 * *(_DWORD *)(a1 + 268));
      v12[2] = sub_10022B83(*v12 * *(_DWORD *)(a1 + 28) * *(v12 - 6), 8 * *(_DWORD *)(a1 + 272));
      ++v11;
      v12 += 21;
    }
    while ( v11 < *(_DWORD *)(a1 + 32) );
  }
  v13 = *(_DWORD *)(a1 + 40);
  v14 = 1;
  if ( v13 != 1 )
  {
    if ( v13 <= 1 )
    {
LABEL_25:
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      goto LABEL_27;
    }
    v14 = 3;
    if ( v13 > 3 )
    {
      if ( v13 <= 5 )
      {
        *(_DWORD *)(a1 + 100) = 4;
        goto LABEL_27;
      }
      goto LABEL_25;
    }
  }
  *(_DWORD *)(a1 + 100) = v14;
LABEL_27:
  if ( *(_BYTE *)(a1 + 74) )
    v15 = 1;
  else
    v15 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 104) = v15;
  LOBYTE(v16) = FUN_10023c18(v14, a1);
  if ( (_BYTE)v16 )
  {
    v16 = *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 108) = v16;
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 1;
  }
  return v16;
}

// sub_10023E78 @ 0x10023E78
int __usercall sub_10023E78@<eax>(int a1@<eax>)
{
  int v2; // edx
  int v3; // eax
  int v4; // edx

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1408) + 256;
  v3 = 0;
  *(_DWORD *)(a1 + 284) = v2;
  memset((void *)(v2 - 256), 0, 0x100u);
  do
  {
    *(_BYTE *)(v3 + v2) = v3;
    ++v3;
  }
  while ( v3 <= 255 );
  v4 = v2 + 128;
  memset((void *)(v4 + 128), 0xFFu, 0x180u);
  memset((void *)(v4 + 512), 0, 0x180u);
  qmemcpy((void *)(v4 + 896), *(const void **)(a1 + 284), 0x80u);
  return 0;
}

// sub_10023EE7 @ 0x10023EE7
int __usercall sub_10023EE7@<eax>(int a1@<esi>)
{
  int v1; // edi
  int v2; // ecx
  char v3; // al
  int result; // eax
  int v5; // ecx
  int v6; // eax
  int v7; // [esp+0h] [ebp-10h]
  char v8; // [esp+Ch] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 380);
  sub_10023C89(v7);
  sub_10023E78(a1);
  *(_DWORD *)(v1 + 12) = 0;
  *(_BYTE *)(v1 + 16) = FUN_10023c18(v2, a1);
  *(_DWORD *)(v1 + 20) = 0;
  *(_DWORD *)(v1 + 24) = 0;
  v3 = *(_BYTE *)(a1 + 74);
  if ( !v3 || !*(_BYTE *)(a1 + 64) )
  {
    *(_BYTE *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 89) = 0;
    *(_BYTE *)(a1 + 90) = 0;
  }
  if ( v3 )
  {
    if ( *(_BYTE *)(a1 + 65) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_DWORD *)(a1 + 100) == 3 )
    {
      if ( *(_DWORD *)(a1 + 116) )
      {
        *(_BYTE *)(a1 + 89) = 1;
        goto LABEL_10;
      }
      if ( *(_BYTE *)(a1 + 80) )
      {
        *(_BYTE *)(a1 + 90) = 1;
        goto LABEL_10;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 89) = 0;
      *(_BYTE *)(a1 + 90) = 0;
      *(_DWORD *)(a1 + 116) = 0;
    }
    *(_BYTE *)(a1 + 88) = 1;
LABEL_10:
    if ( *(_BYTE *)(a1 + 88) )
    {
      sub_10033E84(a1);
      *(_DWORD *)(v1 + 20) = *(_DWORD *)(a1 + 420);
    }
    if ( *(_BYTE *)(a1 + 90) || *(_BYTE *)(a1 + 89) )
    {
      sub_100333F2(a1);
      *(_DWORD *)(v1 + 24) = *(_DWORD *)(a1 + 420);
    }
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(v1 + 16) )
    {
      sub_1003247D(a1);
    }
    else
    {
      sub_10031E84(a1);
      sub_100316F9(a1);
    }
    sub_1003123A(a1, *(_BYTE *)(a1 + 90));
  }
  sub_10030F9F(a1);
  if ( *(_BYTE *)(a1 + 201) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 200) )
  {
    sub_10030D87(a1);
  }
  else
  {
    sub_100301D9(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) || (v8 = 0, *(_BYTE *)(a1 + 64)) )
    v8 = 1;
  sub_1002F809(a1, v8);
  if ( !*(_BYTE *)(a1 + 65) )
    sub_1002EBCA(a1, 0);
  (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 4) + 24))(a1);
  result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 396) + 8))(a1);
  v5 = *(_DWORD *)(a1 + 8);
  if ( v5 )
  {
    if ( !*(_BYTE *)(a1 + 64) )
    {
      result = *(_DWORD *)(a1 + 396);
      if ( *(_BYTE *)(result + 16) )
      {
        v6 = *(_DWORD *)(a1 + 32);
        if ( *(_BYTE *)(a1 + 200) )
          v6 = 3 * v6 + 2;
        *(_DWORD *)(v5 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 8) = v6 * *(_DWORD *)(a1 + 280);
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 12) = 0;
        result = (*(_BYTE *)(a1 + 90) != 0) + 2;
        *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
        ++*(_DWORD *)(v1 + 12);
      }
    }
  }
  return result;
}

// sub_10024094 @ 0x10024094
int __cdecl sub_10024094(int a1)
{
  int v1; // edi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, 0);
    (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, 2);
    (**(void (__cdecl ***)(int, int))(a1 + 384))(a1, 2);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) && !*(_DWORD *)(a1 + 116) )
    {
      if ( *(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 90) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      }
      else if ( *(_BYTE *)(a1 + 88) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 20);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void (__cdecl ***)(int))(a1 + 408))(a1);
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 388) + 8))(a1);
    if ( !*(_BYTE *)(a1 + 65) )
    {
      if ( !*(_BYTE *)(v1 + 16) )
        (**(void (__cdecl ***)(int))(a1 + 416))(a1);
      (**(void (__cdecl ***)(int))(a1 + 412))(a1);
      if ( *(_BYTE *)(a1 + 74) )
        (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8 *)(v1 + 8));
      (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      (**(void (__cdecl ***)(int, _DWORD))(a1 + 384))(a1, 0);
    }
  }
  result = *(_DWORD *)(a1 + 8);
  if ( result )
  {
    *(_DWORD *)(result + 12) = *(_DWORD *)(v1 + 12);
    result = *(_DWORD *)(v1 + 12) + (*(_BYTE *)(v1 + 8) != 0) + 1;
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = result;
    if ( *(_BYTE *)(a1 + 64) )
    {
      result = *(_DWORD *)(a1 + 396);
      if ( !*(_BYTE *)(result + 17) )
      {
        result = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(result + 16) += (*(_BYTE *)(a1 + 90) != 0) + 1;
      }
    }
  }
  return result;
}

// sub_100241C1 @ 0x100241C1
int __cdecl sub_100241C1(int a1)
{
  int result; // eax
  int v2; // esi

  result = a1;
  v2 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(a1 + 74) )
    result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 420) + 8))(a1);
  ++*(_DWORD *)(v2 + 12);
  return result;
}

// sub_100241E2 @ 0x100241E2
int __cdecl sub_100241E2(int a1)
{
  int v1; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 380) = v1;
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)v1 = sub_10024094;
  *(_DWORD *)(v1 + 4) = sub_100241C1;
  return sub_10023EE7(a1);
}

// inflateReset @ 0x10024212
// zlib: reset inflate state
int __cdecl sub_10024212(_DWORD *a1)
{
  _DWORD *v1; // ecx

  if ( !a1 )
    return -2;
  v1 = (_DWORD *)a1[7];
  if ( !v1 )
    return -2;
  a1[5] = 0;
  a1[2] = 0;
  a1[6] = 0;
  *v1 = v1[3] != 0 ? 7 : 0;
  inflate_blocks_reset(*(_DWORD *)(a1[7] + 20), a1, 0);
  return 0;
}

// inflateEnd @ 0x10024251
// zlib: free inflate state
int __cdecl sub_10024251(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 || !a1[9] )
    return -2;
  v2 = *(_DWORD *)(v1 + 20);
  if ( v2 )
    inflate_blocks_free(v2, a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

// inflateInit2_ @ 0x1002428F
// zlib: init inflate with window bits
int __cdecl sub_1002428F(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  bool v4; // zf
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  int v10; // [esp-4h] [ebp-10h]

  if ( !a3 || *a3 != 49 || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v4 = a1[8] == 0;
  a1[6] = 0;
  if ( v4 )
  {
    a1[8] = zcalloc;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = zcfree;
  v5 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  a1[7] = v5;
  if ( v5 )
  {
    v6 = a2;
    *(_DWORD *)(v5 + 20) = 0;
    *(_DWORD *)(a1[7] + 12) = 0;
    if ( a2 < 0 )
    {
      v6 = -a2;
      *(_DWORD *)(a1[7] + 12) = 1;
    }
    if ( v6 < 8 || v6 > 15 )
    {
      v10 = -2;
    }
    else
    {
      *(_DWORD *)(a1[7] + 16) = v6;
      *(_DWORD *)(a1[7] + 20) = inflate_blocks_new(a1, *(_DWORD *)(a1[7] + 12) == 0 ? adler32 : 0, 1 << v6);
      if ( *(_DWORD *)(a1[7] + 20) )
      {
        inflateReset(a1);
        return 0;
      }
      v10 = -4;
    }
    v7 = v10;
    inflateEnd(a1);
    return v7;
  }
  return -4;
}

// inflateInit_ @ 0x10024374
// zlib: init inflate (wrapper for inflateInit2_)
int __cdecl sub_10024374(_DWORD *a1, _BYTE *a2, int a3)
{
  return inflateInit2_(a1, 15, a2, a3);
}

// inflate @ 0x1002438B
// zlib: inflate compressed data
int __cdecl sub_1002438B(unsigned __int8 **a1, int a2)
{
  int v2; // ebx
  unsigned __int8 *v3; // eax
  int v4; // edi
  unsigned __int8 *v5; // eax
  unsigned __int8 *v6; // ecx
  unsigned __int8 *v7; // eax
  unsigned __int8 *v8; // eax
  unsigned __int8 *v9; // ecx
  int v10; // ebx
  bool v11; // zf
  int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  unsigned __int8 *v15; // ecx
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // eax
  unsigned __int8 *v18; // ecx
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // ecx
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // eax
  unsigned __int8 *v24; // ecx
  unsigned __int8 *v25; // eax
  unsigned __int8 *v27; // eax
  unsigned __int8 *v28; // ecx
  unsigned __int8 *v29; // eax
  unsigned __int8 *v30; // eax
  unsigned __int8 *v31; // ecx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // eax
  unsigned __int8 *v34; // ecx
  unsigned __int8 *v35; // eax
  unsigned __int8 *v36; // eax
  unsigned __int8 *v37; // ecx
  unsigned __int8 *v38; // eax
  unsigned __int8 *v39; // eax
  int v41; // [esp+18h] [ebp+8h]

  v2 = 0;
  if ( !a1 )
    return -2;
  v3 = a1[7];
  if ( !v3 || !*a1 )
    return -2;
  v4 = -5;
  if ( a2 == 4 )
    v2 = -5;
  v41 = v2;
  while ( 1 )
  {
    switch ( *(_DWORD *)v3 )
    {
      case 0:
        v5 = a1[1];
        if ( !v5 )
          return v4;
        v6 = a1[7];
        ++a1[2];
        a1[1] = v5 - 1;
        *((_DWORD *)v6 + 1) = **a1;
        v7 = a1[7];
        LOBYTE(v6) = *((_DWORD *)v7 + 1) & 0xF;
        ++*a1;
        v4 = v2;
        if ( (_BYTE)v6 == 8 )
        {
          if ( (unsigned int)((*((_DWORD *)v7 + 1) >> 4) + 8) <= *((_DWORD *)v7 + 4) )
          {
            *(_DWORD *)v7 = 1;
LABEL_14:
            v8 = a1[1];
            if ( !v8 )
              return v4;
            v9 = a1[7];
            ++a1[2];
            a1[1] = v8 - 1;
            v4 = v2;
            v10 = *(*a1)++;
            if ( !((v10 + (*((_DWORD *)v9 + 1) << 8)) % 0x1Fu) )
            {
              v11 = (v10 & 0x20) == 0;
              v2 = v41;
              if ( v11 )
              {
                *(_DWORD *)v9 = 7;
                goto LABEL_37;
              }
              *(_DWORD *)a1[7] = 2;
LABEL_43:
              v27 = a1[1];
              if ( !v27 )
                return v4;
              v28 = a1[7];
              ++a1[2];
              a1[1] = v27 - 1;
              *((_DWORD *)v28 + 2) = **a1 << 24;
              v29 = a1[7];
              ++*a1;
              v4 = v2;
              *(_DWORD *)v29 = 3;
LABEL_45:
              v30 = a1[1];
              if ( !v30 )
                return v4;
              v31 = *a1;
              ++a1[2];
              a1[1] = v30 - 1;
              *((_DWORD *)a1[7] + 2) += *v31 << 16;
              v32 = a1[7];
              ++*a1;
              v4 = v2;
              *(_DWORD *)v32 = 4;
LABEL_47:
              v33 = a1[1];
              if ( !v33 )
                return v4;
              v34 = *a1;
              ++a1[2];
              a1[1] = v33 - 1;
              *((_DWORD *)a1[7] + 2) += *v34 << 8;
              v35 = a1[7];
              ++*a1;
              v4 = v2;
              *(_DWORD *)v35 = 5;
LABEL_49:
              v36 = a1[1];
              if ( !v36 )
                return v4;
              v37 = *a1;
              ++a1[2];
              a1[1] = v36 - 1;
              *((_DWORD *)a1[7] + 2) += *v37;
              v38 = a1[7];
              ++*a1;
              a1[12] = (unsigned __int8 *)*((_DWORD *)v38 + 2);
              *(_DWORD *)v38 = 6;
              return 2;
            }
            v2 = v41;
            *(_DWORD *)v9 = 13;
            a1[6] = "incorrect header check";
          }
          else
          {
            *(_DWORD *)v7 = 13;
            a1[6] = "invalid window size";
          }
        }
        else
        {
          *(_DWORD *)v7 = 13;
          a1[6] = "unknown compression method";
        }
LABEL_36:
        *((_DWORD *)a1[7] + 1) = 5;
LABEL_37:
        v3 = a1[7];
        break;
      case 1:
        goto LABEL_14;
      case 2:
        goto LABEL_43;
      case 3:
        goto LABEL_45;
      case 4:
        goto LABEL_47;
      case 5:
        goto LABEL_49;
      case 6:
        *(_DWORD *)a1[7] = 13;
        v39 = a1[7];
        a1[6] = "need dictionary";
        *((_DWORD *)v39 + 1) = 0;
        return -2;
      case 7:
        v12 = inflate_blocks(*((_DWORD *)a1[7] + 5), a1, v4);
        v4 = v12;
        if ( v12 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
          goto LABEL_37;
        }
        if ( !v12 )
          v4 = v2;
        if ( v4 != 1 )
          return v4;
        v4 = v2;
        inflate_blocks_reset(*((_DWORD *)a1[7] + 5), a1, a1[7] + 4);
        v13 = a1[7];
        if ( *((_DWORD *)v13 + 3) )
        {
          *(_DWORD *)v13 = 12;
          goto LABEL_37;
        }
        *(_DWORD *)v13 = 8;
LABEL_27:
        v14 = a1[1];
        if ( !v14 )
          return v4;
        v15 = a1[7];
        ++a1[2];
        a1[1] = v14 - 1;
        *((_DWORD *)v15 + 2) = **a1 << 24;
        v16 = a1[7];
        ++*a1;
        v4 = v2;
        *(_DWORD *)v16 = 9;
LABEL_29:
        v17 = a1[1];
        if ( !v17 )
          return v4;
        v18 = *a1;
        ++a1[2];
        a1[1] = v17 - 1;
        *((_DWORD *)a1[7] + 2) += *v18 << 16;
        v19 = a1[7];
        ++*a1;
        v4 = v2;
        *(_DWORD *)v19 = 10;
LABEL_31:
        v20 = a1[1];
        if ( !v20 )
          return v4;
        v21 = *a1;
        ++a1[2];
        a1[1] = v20 - 1;
        *((_DWORD *)a1[7] + 2) += *v21 << 8;
        v22 = a1[7];
        ++*a1;
        v4 = v2;
        *(_DWORD *)v22 = 11;
LABEL_33:
        v23 = a1[1];
        if ( !v23 )
          return v4;
        v24 = *a1;
        ++a1[2];
        a1[1] = v23 - 1;
        *((_DWORD *)a1[7] + 2) += *v24;
        v25 = a1[7];
        ++*a1;
        v4 = v2;
        if ( *((_DWORD *)v25 + 1) != *((_DWORD *)v25 + 2) )
        {
          *(_DWORD *)v25 = 13;
          a1[6] = "incorrect data check";
          goto LABEL_36;
        }
        *(_DWORD *)a1[7] = 12;
        return 1;
      case 8:
        goto LABEL_27;
      case 9:
        goto LABEL_29;
      case 0xA:
        goto LABEL_31;
      case 0xB:
        goto LABEL_33;
      case 0xC:
        return 1;
      case 0xD:
        return -3;
      default:
        return -2;
    }
  }
}

// sub_100246F2 @ 0x100246F2
void *__cdecl sub_100246F2(int a1)
{
  size_t v1; // esi
  void *v2; // edx

  if ( a1 == 2 )
  {
    v1 = 64;
  }
  else
  {
    if ( a1 != 1 )
      return 0;
    v1 = 412;
  }
  v2 = malloc(v1);
  if ( v2 )
    memset(v2, 0, v1);
  return v2;
}

// png_free_ptr @ 0x10024734
// free wrapper for png allocations
void __cdecl sub_10024734(void *Block)
{
  if ( Block )
    free(Block);
}

// png_malloc @ 0x10024741
// png malloc wrapper (errors on OOM)
void *__cdecl sub_10024741(jmp_buf Buf, size_t Size)
{
  void *result; // eax

  if ( !Buf || !Size )
    return 0;
  result = malloc(Size);
  if ( !result )
    png_error(Buf, (int)"Out of Memory");
  return result;
}

// png_free @ 0x10024777
// png free callback wrapper
void __cdecl sub_10024777(int a1, void *Block)
{
  if ( a1 )
  {
    if ( Block )
      free(Block);
  }
}

// FUN_10024790 @ 0x10024790
// [binja] int32_t sub_10024790(int32_t arg1, int32_t arg2, int32_t arg3)
void *__cdecl sub_10024790(int a1, void *a2, const void *a3, unsigned int a4)
{
  qmemcpy(a2, a3, a4);
  return a2;
}

// FUN_100247b3 @ 0x100247B3
// [binja] int32_t sub_100247b3(int32_t arg1, char arg2, int32_t arg3)
char *__usercall sub_100247B3@<eax>(int a1@<ebx>, int a2, char *a3, char a4, unsigned int a5)
{
  int v5; // eax

  LOBYTE(a1) = a4;
  BYTE1(a1) = a4;
  v5 = a1 << 16;
  LOWORD(v5) = a1;
  memset32(a3, v5, a5 >> 2);
  memset(&a3[4 * (a5 >> 2)], a4, a5 & 3);
  return a3;
}

// png_get_uint_32 @ 0x100247E4
// read big-endian 32-bit value
int __cdecl sub_100247E4(unsigned __int8 *a1)
{
  return a1[3] + ((a1[2] + ((a1[1] + (*a1 << 8)) << 8)) << 8);
}

// png_crc_read @ 0x10024807
// read PNG chunk data and update CRC
jmp_buf __cdecl sub_10024807(jmp_buf Buf, int a2, int a3)
{
  int *__attribute__((__org_typedef(jmp_buf))) result; // eax

  png_read_data(Buf, a2, a3);
  result = Buf;
  if ( (Buf[67] & 0x20) == 0 )
  {
    if ( (*((_BYTE *)Buf + 93) & 8) != 0 )
      return result;
    goto LABEL_5;
  }
  if ( (Buf[23] & 0x300) != 0x300 )
  {
LABEL_5:
    result = (int *)sub_10025AEC(Buf[64], a2, a3);
    Buf[64] = (int)result;
  }
  return result;
}

// png_crc_error @ 0x10024821
// read stored CRC and compare with computed
BOOL __cdecl sub_10024821(jmp_buf Buf)
{
  int *__attribute__((__org_typedef(jmp_buf))) v1; // esi
  int v2; // edi

  v1 = Buf;
  v2 = 1;
  if ( (Buf[67] & 0x20) != 0 )
  {
    if ( (Buf[23] & 0x300) != 0x300 )
      goto LABEL_6;
  }
  else if ( (*((_BYTE *)Buf + 93) & 8) == 0 )
  {
    goto LABEL_6;
  }
  v2 = 0;
LABEL_6:
  png_read_data(Buf, (int)&Buf, 4);
  return v2 && png_get_uint_32((unsigned __int8 *)&Buf) != v1[64];
}

// png_check_chunk_name @ 0x1002487F
// validate PNG chunk type characters
unsigned __int8 __cdecl sub_1002487F(jmp_buf Buf, unsigned __int8 *a2)
{
  unsigned __int8 v2; // al
  unsigned __int8 v3; // al
  unsigned __int8 v4; // al
  unsigned __int8 result; // al

  v2 = *a2;
  if ( *a2 < 0x29u
    || v2 > 0x7Au
    || v2 > 0x5Au && v2 < 0x61u
    || (v3 = a2[1], v3 < 0x29u)
    || v3 > 0x7Au
    || v3 > 0x5Au && v3 < 0x61u
    || (v4 = a2[2], v4 < 0x29u)
    || v4 > 0x7Au
    || v4 > 0x5Au && v4 < 0x61u
    || (result = a2[3], result < 0x29u)
    || result > 0x7Au
    || result > 0x5Au && result < 0x61u )
  {
    FUN_1001e147(Buf, "invalid chunk type");
  }
  return result;
}

// sub_100248E1 @ 0x100248E1
char __cdecl sub_100248E1(int a1, char *a2, int a3)
{
  unsigned int v3; // ecx
  unsigned int v4; // eax
  char *v5; // ebx
  char *v6; // edx
  _BYTE *v7; // edi
  unsigned __int8 *v8; // esi
  int v9; // edx
  _BYTE *v10; // edi
  unsigned __int8 *v11; // esi
  int v12; // edx
  _BYTE *v13; // edi
  unsigned __int8 *v14; // esi
  int v15; // edx
  int v17; // [esp+8h] [ebp-Ch]
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+8h] [ebp-Ch]
  unsigned int v21; // [esp+Ch] [ebp-8h]
  int v22; // [esp+Ch] [ebp-8h]
  int v23; // [esp+Ch] [ebp-8h]
  int v24; // [esp+Ch] [ebp-8h]
  unsigned __int8 v25; // [esp+13h] [ebp-1h]

  v3 = *(unsigned __int8 *)(a1 + 251);
  if ( a3 == 255 )
  {
    v4 = (*(_DWORD *)(a1 + 184) * v3 + 7) >> 3;
    qmemcpy(a2, (const void *)(*(_DWORD *)(a1 + 220) + 1), 4 * ((*(_DWORD *)(a1 + 184) * v3 + 7) >> 5) + (v4 & 3));
  }
  else
  {
    switch ( v3 )
    {
      case 1u:
        v4 = *(_DWORD *)(a1 + 184);
        v13 = a2;
        v14 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v24 = 128;
        v15 = 7;
        if ( v4 )
        {
          v20 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v24) != 0 )
            {
              LOBYTE(v4) = ((*v14 >> v15) & 1) << v15;
              *v13 = v4 | *v13 & (32639 >> (7 - v15));
            }
            if ( v15 )
            {
              --v15;
            }
            else
            {
              ++v14;
              v15 = 7;
              ++v13;
            }
            if ( v24 == 1 )
              v24 = 128;
            else
              v24 >>= 1;
            --v20;
          }
          while ( v20 );
        }
        break;
      case 2u:
        v4 = *(_DWORD *)(a1 + 184);
        v10 = a2;
        v11 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v23 = 128;
        v12 = 6;
        if ( v4 )
        {
          v19 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v23) != 0 )
            {
              LOBYTE(v4) = ((*v11 >> v12) & 3) << v12;
              *v10 = v4 | *v10 & (16191 >> (6 - v12));
            }
            if ( v12 )
            {
              v12 -= 2;
            }
            else
            {
              ++v11;
              v12 = 6;
              ++v10;
            }
            if ( v23 == 1 )
              v23 = 128;
            else
              v23 >>= 1;
            --v19;
          }
          while ( v19 );
        }
        break;
      case 4u:
        v4 = *(_DWORD *)(a1 + 184);
        v7 = a2;
        v8 = (unsigned __int8 *)(*(_DWORD *)(a1 + 220) + 1);
        v22 = 128;
        v9 = 4;
        if ( v4 )
        {
          v18 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( (a3 & v22) != 0 )
            {
              LOBYTE(v4) = ((*v8 >> v9) & 0xF) << v9;
              *v7 = v4 | *v7 & (3855 >> (4 - v9));
            }
            if ( v9 )
            {
              v9 -= 4;
            }
            else
            {
              ++v8;
              v9 = 4;
              ++v7;
            }
            if ( v22 == 1 )
              v22 = 128;
            else
              v22 >>= 1;
            --v18;
          }
          while ( v18 );
        }
        break;
      default:
        v4 = *(_DWORD *)(a1 + 184);
        v5 = a2;
        v6 = (char *)(*(_DWORD *)(a1 + 220) + 1);
        v21 = v3 >> 3;
        v25 = 0x80;
        if ( v4 )
        {
          v17 = *(_DWORD *)(a1 + 184);
          do
          {
            LOBYTE(v4) = a3;
            if ( ((unsigned __int8)a3 & v25) != 0 )
            {
              v4 = v3 >> 3;
              qmemcpy(v5, v6, v21);
            }
            v6 += v21;
            v5 += v21;
            if ( v25 == 1 )
              v25 = 0x80;
            else
              v25 >>= 1;
            --v17;
          }
          while ( v17 );
        }
        break;
    }
  }
  return v4;
}

// sub_10024AF7 @ 0x10024AF7
void __cdecl sub_10024AF7(int *a1, int a2, int a3)
{
  int v3; // eax
  int v4; // edx
  unsigned int v5; // esi
  unsigned int v6; // esi
  char *v7; // ebx
  char v8; // al
  unsigned int v9; // ecx
  _BYTE *v10; // edi
  char *v11; // esi
  int v12; // eax
  bool v13; // cc
  void *v14; // edi
  _BYTE *v15; // edi
  _BYTE *v16; // esi
  char v17; // al
  bool v18; // zf
  _BYTE *v19; // edi
  _BYTE *v20; // esi
  char v21; // al
  _BYTE *v22; // edi
  _BYTE *v23; // esi
  char v24; // al
  unsigned int v25; // ecx
  _BYTE v26[4]; // [esp+0h] [ebp-18h] BYREF
  int v27; // [esp+4h] [ebp-14h]
  unsigned int v28; // [esp+8h] [ebp-10h]
  int v29; // [esp+Ch] [ebp-Ch]
  unsigned int v30; // [esp+10h] [ebp-8h]
  unsigned int v31; // [esp+14h] [ebp-4h]
  char *v32; // [esp+24h] [ebp+Ch]
  char v33; // [esp+27h] [ebp+Fh]
  char v34; // [esp+27h] [ebp+Fh]
  char v35; // [esp+27h] [ebp+Fh]

  if ( a2 && a1 )
  {
    v3 = *a1;
    v4 = dword_1004EAAC[a3] * *a1;
    v29 = dword_1004EAAC[a3];
    v5 = *((unsigned __int8 *)a1 + 11);
    if ( v5 == 1 )
    {
      v28 = 0;
      v22 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 3));
      v23 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 3));
      v30 = 7 - (((_BYTE)v3 - 1) & 7);
      v31 = 7 - (((_BYTE)v4 - 1) & 7);
      if ( v3 )
      {
        do
        {
          v24 = (*v22 >> v30) & 1;
          v35 = v24;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 7;
              *v23 = (v24 << v31) | *v23 & (32639 >> (7 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v23;
              }
              else
              {
                ++v31;
              }
              if ( !--v27 )
                break;
              v24 = v35;
            }
          }
          if ( v30 == 7 )
          {
            v30 = 0;
            --v22;
          }
          else
          {
            ++v30;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else if ( *((_BYTE *)a1 + 11) == 2 )
    {
      v28 = 0;
      v19 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 2));
      v20 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 2));
      v30 = 2 * (3 - (((_BYTE)v3 - 1) & 3));
      v31 = 2 * (3 - (((_BYTE)v4 - 1) & 3));
      if ( v3 )
      {
        do
        {
          v21 = (*v19 >> v30) & 3;
          v34 = v21;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 6;
              *v20 = (v21 << v31) | *v20 & (16191 >> (6 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v20;
              }
              else
              {
                v31 += 2;
              }
              if ( !--v27 )
                break;
              v21 = v34;
            }
          }
          if ( v30 == 6 )
          {
            v30 = 0;
            --v19;
          }
          else
          {
            v30 += 2;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else if ( *((_BYTE *)a1 + 11) == 4 )
    {
      v28 = 0;
      v15 = (_BYTE *)(a2 + ((unsigned int)(v3 - 1) >> 1));
      v16 = (_BYTE *)(a2 + ((unsigned int)(v4 - 1) >> 1));
      v30 = 4 - 4 * (((_BYTE)v3 - 1) & 1);
      v31 = 4 - 4 * (((_BYTE)v4 - 1) & 1);
      if ( v3 )
      {
        do
        {
          v17 = (*v15 >> v30) & 0xF;
          v33 = v17;
          if ( v29 > 0 )
          {
            v27 = v29;
            while ( 1 )
            {
              v18 = v31 == 4;
              *v16 = (v17 << v31) | *v16 & (3855 >> (4 - v31));
              if ( v18 )
              {
                v31 = 0;
                --v16;
              }
              else
              {
                v31 += 4;
              }
              if ( !--v27 )
                break;
              v17 = v33;
            }
          }
          if ( v30 == 4 )
          {
            v30 = 0;
            --v15;
          }
          else
          {
            v30 += 4;
          }
          ++v28;
        }
        while ( v28 < *a1 );
      }
    }
    else
    {
      v31 = 0;
      v6 = v5 >> 3;
      v7 = (char *)(a2 + v6 * (v3 - 1));
      v30 = v6;
      v32 = (char *)(a2 + v6 * (v4 - 1));
      if ( v3 )
      {
        do
        {
          v8 = v30;
          v9 = v30 >> 2;
          qmemcpy(v26, v7, 4 * (v30 >> 2));
          v11 = &v7[4 * v9];
          v10 = &v26[4 * v9];
          LOBYTE(v9) = v8;
          v12 = v29;
          v13 = v29 <= 0;
          qmemcpy(v10, v11, v9 & 3);
          if ( !v13 )
          {
            v28 = v12;
            do
            {
              v14 = v32;
              v32 -= v30;
              qmemcpy(v14, v26, v30);
              --v28;
            }
            while ( v28 );
          }
          v7 -= v30;
          ++v31;
        }
        while ( v31 < *a1 );
      }
    }
    v25 = (v4 * (unsigned int)*((unsigned __int8 *)a1 + 11) + 7) >> 3;
    *a1 = v4;
    a1[1] = v25;
  }
}

// FUN_10024dc0 @ 0x10024DC0
char __cdecl sub_10024DC0(int a1, int a2, _BYTE *a3, unsigned __int8 *a4, int a5)
{
  unsigned int v5; // eax
  _BYTE *v6; // edx
  unsigned __int8 *v7; // edi
  unsigned int v8; // ecx
  int v9; // esi
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // ebx
  int v14; // eax
  bool v15; // zf
  _BYTE *v16; // esi
  unsigned __int8 *v17; // edi
  unsigned int v18; // ecx
  unsigned __int8 *j; // ebx
  unsigned int v20; // esi
  unsigned int i; // ecx
  unsigned int v22; // ecx
  _BYTE *v23; // esi
  _BYTE *v24; // edx
  unsigned int v25; // ecx
  int v27; // [esp+8h] [ebp-14h]
  unsigned int v28; // [esp+Ch] [ebp-10h]
  _BYTE *v29; // [esp+10h] [ebp-Ch]
  int v30; // [esp+14h] [ebp-8h]
  unsigned __int8 *v31; // [esp+18h] [ebp-4h]
  unsigned __int8 *v32; // [esp+34h] [ebp+18h]

  LOBYTE(v5) = a5;
  if ( a5 )
  {
    switch ( a5 )
    {
      case 1:
        v22 = *(_DWORD *)(a2 + 4);
        v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
        v23 = &a3[v5];
        if ( v5 < v22 )
        {
          v24 = a3;
          v25 = v22 - v5;
          do
          {
            LOBYTE(v5) = *v24;
            *v23++ += *v24++;
            --v25;
          }
          while ( v25 );
        }
        break;
      case 2:
        v20 = *(_DWORD *)(a2 + 4);
        v5 = (unsigned int)a3;
        for ( i = 0; i < v20; ++i )
          *(_BYTE *)v5++ += a4[i];
        break;
      case 3:
        v16 = a3;
        v17 = a4;
        v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
        v18 = *(_DWORD *)(a2 + 4) - v5;
        for ( j = a3; v5; --v5 )
          *v16++ += *v17++ >> 1;
        for ( ; v18; --v18 )
        {
          v5 = (*v17 + *j) / 2;
          *v16 += v5;
          ++j;
          ++v17;
          ++v16;
        }
        break;
      case 4:
        v6 = a3;
        v7 = a4;
        v5 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
        v8 = *(_DWORD *)(a2 + 4) - v5;
        v29 = a3;
        v32 = a3;
        v31 = a4;
        if ( v5 )
        {
          v9 = (*(unsigned __int8 *)(a2 + 11) + 7) >> 3;
          do
          {
            LOBYTE(v5) = *v7;
            *v6++ += *v7++;
            --v9;
          }
          while ( v9 );
          v29 = v6;
        }
        if ( v8 )
        {
          v28 = v8;
          do
          {
            v10 = *v32;
            v11 = *v31;
            ++v32;
            v27 = *v7++;
            ++v31;
            v12 = v10 - v11;
            if ( v27 - v11 >= 0 )
              v30 = v27 - v11;
            else
              v30 = v11 - v27;
            v13 = v10 - v11;
            if ( v12 < 0 )
              v13 = v11 - v10;
            v14 = v12 + v27 - v11;
            if ( v14 < 0 )
              v14 = -v14;
            if ( v30 > v13 || v30 > v14 )
            {
              LOBYTE(v10) = v27;
              if ( v13 > v14 )
                LOBYTE(v10) = v11;
            }
            *v29 += v10;
            LOBYTE(v5) = (_BYTE)v29 + 1;
            v15 = v28-- == 1;
            ++v29;
          }
          while ( !v15 );
        }
        break;
      default:
        png_warning(a1, (int)"Ignoring bad adaptive filter type");
        *a3 = 0;
        LOBYTE(v5) = (_BYTE)a3;
        break;
    }
  }
  return v5;
}

// FUN_10024f3b @ 0x10024F3B
char *__cdecl sub_10024F3B(jmp_buf Buf)
{
  unsigned int v1; // eax
  int v2; // edi
  unsigned int v3; // eax
  unsigned int v4; // ecx
  int v5; // eax
  int v6; // eax
  int v7; // ebx
  char v8; // cl
  char v9; // cl
  int v10; // ecx
  char *v11; // eax
  char *result; // eax
  unsigned int v13; // [esp-14h] [ebp-1Ch]

  Buf[26] = 0;
  FUN_10020036(Buf);
  v1 = Buf[47];
  if ( *((_BYTE *)Buf + 275) )
  {
    if ( (Buf[24] & 2) == 0 )
      v1 = (v1 + 7) >> 3;
    v2 = Buf[46];
    Buf[48] = v1;
    v3 = (v2 - dword_1004EA90[*((unsigned __int8 *)Buf + 276)] + dword_1004EAAC[*((unsigned __int8 *)Buf + 276)] - 1)
       / (unsigned int)dword_1004EAAC[*((unsigned __int8 *)Buf + 276)];
    v4 = ((v3 * *((unsigned __int8 *)Buf + 281) + 7) >> 3) + 1;
    Buf[52] = v3;
    Buf[51] = v4;
  }
  else
  {
    v2 = Buf[46];
    Buf[48] = v1;
    v5 = Buf[50] + 1;
    Buf[52] = v2;
    Buf[51] = v5;
  }
  v6 = *((unsigned __int8 *)Buf + 281);
  v7 = Buf[24];
  if ( (v7 & 4) != 0 && *((_BYTE *)Buf + 279) < 8u )
    v6 = 8;
  if ( (v7 & 0x1000) != 0 )
  {
    v8 = *((_BYTE *)Buf + 278);
    if ( v8 == 3 )
    {
      v6 = 8 * (*((_WORD *)Buf + 133) != 0) + 24;
    }
    else if ( v8 )
    {
      if ( v8 == 2 && *((_WORD *)Buf + 133) )
        v6 = 4 * v6 / 3;
    }
    else
    {
      if ( v6 < 8 )
        v6 = 8;
      if ( *((_WORD *)Buf + 133) )
        v6 *= 2;
    }
  }
  if ( (v7 & 0x8000) != 0 )
  {
    v9 = *((_BYTE *)Buf + 278);
    if ( v9 != 3 )
    {
      if ( v9 )
      {
        if ( v9 != 2 )
          goto LABEL_28;
        v10 = v6 > 32 ? 64 : 32;
      }
      else
      {
        v10 = v6 > 8 ? 32 : 16;
      }
      v6 = v10;
      goto LABEL_28;
    }
    v6 = 32;
  }
LABEL_28:
  Buf[55] = (int)png_malloc(Buf, ((v6 * ((v2 + 7) & 0xFFFFFFF8) + 7) >> 3) + ((v6 + 7) >> 3) + 1);
  v11 = (char *)png_malloc(Buf, Buf[50] + 1);
  v13 = Buf[50] + 1;
  Buf[54] = (int)v11;
  result = FUN_100247b3(v7, (int)Buf, v11, 0, v13);
  Buf[23] |= 0x40u;
  return result;
}

// png_crc_finish @ 0x100250D7
// read remaining chunk bytes and check CRC
int __cdecl sub_100250D7(jmp_buf Buf, unsigned int a2)
{
  unsigned int i; // edi

  for ( i = Buf[40]; a2 > i; a2 -= i )
    png_crc_read(Buf, Buf[39], Buf[40]);
  if ( a2 )
    png_crc_read(Buf, Buf[39], a2);
  if ( !png_crc_error(Buf) )
    return 0;
  if ( ((Buf[67] & 0x20) == 0 || (*((_BYTE *)Buf + 93) & 2) != 0)
    && ((Buf[67] & 0x20) != 0 || (*((_BYTE *)Buf + 93) & 4) == 0) )
  {
    FUN_1001e147(Buf, "CRC error");
  }
  FUN_1001e16c((int)Buf, "CRC error");
  return 1;
}

// FUN_10025163 @ 0x10025163
void __cdecl sub_10025163(jmp_buf Buf, int a2, int a3)
{
  signed int v4; // edi
  int v5; // eax
  char v6; // bl
  unsigned __int8 v7; // al
  char v8; // [esp-Ch] [ebp-34h]
  char v9; // [esp-8h] [ebp-30h]
  char v10; // [esp-4h] [ebp-2Ch]
  int v11; // [esp+Ch] [ebp-1Ch] BYREF
  unsigned __int8 v12[4]; // [esp+10h] [ebp-18h] BYREF
  unsigned __int8 v13; // [esp+14h] [ebp-14h]
  unsigned __int8 v14; // [esp+15h] [ebp-13h]
  unsigned __int8 v15; // [esp+16h] [ebp-12h]
  unsigned __int8 v16; // [esp+17h] [ebp-11h]
  unsigned __int8 v17; // [esp+18h] [ebp-10h]
  int v18; // [esp+1Ch] [ebp-Ch]
  int v19; // [esp+20h] [ebp-8h]
  int v20; // [esp+24h] [ebp-4h]
  int *__attribute__((__org_typedef(jmp_buf))) Bufa; // [esp+30h] [ebp+8h]
  char v22; // [esp+38h] [ebp+10h]

  if ( Buf[22] )
    png_error(Buf, (int)"Out of place IHDR");
  if ( a3 != 13 )
    png_error(Buf, (int)"Invalid IHDR chunk");
  Buf[22] |= 1u;
  png_crc_read(Buf, (int)&v11, 13);
  png_crc_finish(Buf, 0);
  v4 = png_get_uint_32((unsigned __int8 *)&v11);
  v5 = png_get_uint_32(v12);
  v6 = v13;
  Bufa = (int *)v5;
  v22 = v14;
  v18 = v15;
  v19 = v16;
  v20 = v17;
  if ( v4 <= 0 || v5 <= 0 )
    png_error(Buf, (int)"Invalid image size in IHDR");
  if ( v13 != 1 && v13 != 2 && v13 != 4 && v13 != 8 && v13 != 16 )
    png_error(Buf, (int)"Invalid bit depth in IHDR");
  if ( v14 == 1 || v14 == 5 || v14 > 6u )
    png_error(Buf, (int)"Invalid color type in IHDR");
  if ( v14 == 3 && v13 > 8u || (v14 == 2 || v14 == 4 || v14 == 6) && v13 < 8u )
    png_error(Buf, (int)"Invalid color type/bit depth combination in IHDR");
  if ( v20 >= 2 )
    png_error(Buf, (int)"Unknown interlace method in IHDR");
  if ( v18 )
    png_error(Buf, (int)"Unknown compression method in IHDR");
  if ( v19 )
    png_error(Buf, (int)"Unknown filter method in IHDR");
  *((_BYTE *)Buf + 275) = v20;
  Buf[46] = v4;
  Buf[47] = v5;
  *((_BYTE *)Buf + 279) = v6;
  *((_BYTE *)Buf + 278) = v22;
  switch ( v22 )
  {
    case 0:
      goto LABEL_39;
    case 2:
      *((_BYTE *)Buf + 282) = 3;
      break;
    case 3:
LABEL_39:
      *((_BYTE *)Buf + 282) = 1;
      break;
    case 4:
      *((_BYTE *)Buf + 282) = 2;
      break;
    case 6:
      *((_BYTE *)Buf + 282) = 4;
      break;
  }
  v10 = v19;
  v7 = v6 * *((_BYTE *)Buf + 282);
  v9 = v18;
  *((_BYTE *)Buf + 281) = v7;
  v8 = v20;
  Buf[50] = (v4 * (unsigned int)v7 + 7) >> 3;
  FUN_1002031c((int)Buf, a2, v4, (int)Bufa, v6, v22, v8, v9, v10);
}

// FUN_10025359 @ 0x10025359
void __cdecl sub_10025359(jmp_buf Buf, int a2, int a3)
{
  int *__attribute__((__org_typedef(jmp_buf))) v3; // esi
  int v4; // eax
  unsigned int v5; // edx
  int v6; // ebx
  char *v7; // eax
  _BYTE *v8; // edi
  int v9; // edi
  int v10; // [esp-1Ch] [ebp-28h]
  int v11; // [esp+4h] [ebp-8h]
  int v12; // [esp+8h] [ebp-4h]

  v3 = Buf;
  v4 = Buf[22];
  if ( (v4 & 1) == 0 )
    png_error(Buf, (int)"Missing IHDR before PLTE");
  if ( (v4 & 4) != 0 )
  {
    png_warning((int)Buf, (int)"Invalid PLTE after IDAT");
LABEL_10:
    png_crc_finish(v3, a3);
    return;
  }
  if ( (v4 & 2) != 0 )
    png_error(Buf, (int)"Duplicate PLTE chunk");
  v5 = a3 % 3u;
  Buf[22] |= 2u;
  if ( v5 )
  {
    if ( *((_BYTE *)v3 + 278) == 3 )
      png_error(v3, (int)"Invalid palette chunk");
    png_warning((int)v3, (int)"Invalid palette chunk");
    goto LABEL_10;
  }
  v6 = a3 / 3;
  v7 = FUN_1002052b(v3, a3 / 3, 3);
  *((_BYTE *)v3 + 93) |= 0x10u;
  v11 = (int)v7;
  if ( v6 > 0 )
  {
    v8 = v7 + 2;
    v12 = v6;
    do
    {
      png_crc_read(v3, (int)&Buf, 3);
      *((_WORD *)v8 - 1) = (_WORD)Buf;
      *v8 = BYTE2(Buf);
      v8 += 3;
      --v12;
    }
    while ( v12 );
  }
  png_crc_finish(v3, 0);
  v9 = a2;
  v10 = a2;
  v3[65] = v11;
  *((_WORD *)v3 + 132) = v6;
  sub_100203BD((int)v3, v10, v11, v6);
  if ( *((_BYTE *)v3 + 278) == 3
    && v9
    && (*(_BYTE *)(v9 + 8) & 0x10) != 0
    && *((_WORD *)v3 + 133) > *((_WORD *)v3 + 132) )
  {
    png_warning((int)v3, (int)"Truncating incorrect tRNS chunk length");
    *((_WORD *)v3 + 133) = *((_WORD *)v3 + 132);
  }
}

// FUN_10025483 @ 0x10025483
int __cdecl sub_10025483(jmp_buf Buf, int a2, unsigned int a3)
{
  int v3; // eax

  v3 = Buf[22];
  if ( (v3 & 1) == 0 || (v3 & 4) == 0 )
    png_error(Buf, (int)"No image in file");
  Buf[22] |= 0x18u;
  if ( a3 )
    png_warning((int)Buf, (int)"Incorrect IEND chunk length");
  return png_crc_finish(Buf, a3);
}

// FUN_100254cd @ 0x100254CD
void __cdecl sub_100254CD(jmp_buf Buf, int a2, unsigned int a3)
{
  int *__attribute__((__org_typedef(jmp_buf))) v3; // esi
  int v4; // eax
  int v5; // edi
  int v6; // eax
  int v7; // eax
  double v8; // st7

  v3 = Buf;
  v4 = Buf[22];
  v5 = a2;
  if ( (v4 & 1) == 0 )
    png_error(Buf, (int)"Missing IHDR before gAMA");
  if ( (v4 & 4) != 0 )
  {
    png_warning((int)Buf, (int)"Invalid gAMA after IDAT");
    goto LABEL_5;
  }
  if ( (v4 & 2) != 0 )
  {
    png_warning((int)Buf, (int)"Out of place gAMA chunk");
  }
  else if ( a2 )
  {
    v6 = *(_DWORD *)(a2 + 8);
    if ( (v6 & 1) != 0 && (v6 & 0x800) == 0 )
    {
      png_warning((int)Buf, (int)"Duplicate gAMA chunk");
      goto LABEL_5;
    }
  }
  if ( a3 != 4 )
  {
    png_warning((int)v3, (int)"Incorrect gAMA chunk length");
LABEL_5:
    png_crc_finish(v3, a3);
    return;
  }
  png_crc_read(v3, (int)&Buf, 4);
  if ( !png_crc_finish(v3, 0) )
  {
    v7 = png_get_uint_32((unsigned __int8 *)&Buf);
    if ( v7 )
    {
      if ( (*(_DWORD *)(v5 + 8) & 0x800) != 0 && fabs((double)(unsigned int)v7 - 45455.0) > 500.0 )
      {
        png_warning((int)v3, (int)"Ignoring incorrect gAMA value when sRGB is also present");
      }
      else
      {
        v8 = (double)(unsigned int)v7 * 0.0000099999997;
        *((float *)v3 + 76) = v8;
        sub_10020301((int)v3, v5, v8);
      }
    }
  }
}

// FUN_100255d8 @ 0x100255D8
void __cdecl sub_100255D8(jmp_buf Buf, unsigned int a2, unsigned int a3)
{
  int *__attribute__((__org_typedef(jmp_buf))) v3; // esi
  int v4; // eax
  unsigned int v5; // edi

  v3 = Buf;
  v4 = Buf[22];
  if ( (v4 & 1) == 0 )
    png_error(Buf, (int)"Missing IHDR before sRGB");
  if ( (v4 & 4) != 0 )
  {
    png_warning((int)Buf, (int)"Invalid sRGB after IDAT");
    goto LABEL_5;
  }
  if ( (v4 & 2) != 0 )
  {
    png_warning((int)Buf, (int)"Out of place sRGB chunk");
  }
  else if ( a2 && (*(_BYTE *)(a2 + 9) & 8) != 0 )
  {
    png_warning((int)Buf, (int)"Duplicate sRGB chunk");
    goto LABEL_5;
  }
  if ( a3 != 1 )
  {
    png_warning((int)v3, (int)"Incorrect sRGB chunk length");
LABEL_5:
    png_crc_finish(v3, a3);
    return;
  }
  png_crc_read(v3, (int)&Buf + 3, 1);
  if ( !png_crc_finish(v3, 0) )
  {
    v5 = HIBYTE(Buf);
    if ( HIBYTE(Buf) < 4u )
    {
      if ( (*(_BYTE *)(a2 + 8) & 1) != 0 && fabs(*((float *)v3 + 76) * 100000.0 + 0.5 - 45455.0) > 500.0 )
        png_warning((int)v3, (int)"Ignoring incorrect gAMA value when sRGB is also present");
      sub_100203FC((int)v3, __SPAIR64__(v5, a2));
    }
    else
    {
      png_warning((int)v3, (int)"Unknown sRGB intent");
    }
  }
}

// FUN_100256c7 @ 0x100256C7
void __cdecl sub_100256C7(jmp_buf Buf, int a2, size_t Size)
{
  int v3; // eax
  char v4; // al
  void *v5; // eax
  __int16 v6; // cx
  __int16 v7; // ax
  __int16 v8; // cx
  unsigned __int8 v9; // [esp+8h] [ebp-8h] BYREF
  unsigned __int8 v10; // [esp+9h] [ebp-7h]
  unsigned __int8 v11; // [esp+Ah] [ebp-6h]
  unsigned __int8 v12; // [esp+Bh] [ebp-5h]
  unsigned __int8 v13; // [esp+Ch] [ebp-4h]
  unsigned __int8 v14; // [esp+Dh] [ebp-3h]

  v3 = Buf[22];
  if ( (v3 & 1) == 0 )
    png_error(Buf, (int)"Missing IHDR before tRNS");
  if ( (v3 & 4) != 0 )
  {
    png_warning((int)Buf, (int)"Invalid tRNS after IDAT");
LABEL_13:
    png_crc_finish(Buf, Size);
    return;
  }
  if ( a2 && (*(_BYTE *)(a2 + 8) & 0x10) != 0 )
  {
    png_warning((int)Buf, (int)"Duplicate tRNS chunk");
    goto LABEL_13;
  }
  v4 = *((_BYTE *)Buf + 278);
  if ( v4 == 3 )
  {
    if ( (Buf[22] & 2) != 0 )
    {
      if ( Size > *((unsigned __int16 *)Buf + 132) )
      {
        png_warning((int)Buf, (int)"Incorrect tRNS chunk length");
        png_crc_finish(Buf, Size);
        return;
      }
    }
    else
    {
      png_warning((int)Buf, (int)"Missing PLTE before tRNS");
    }
    if ( !Size )
    {
      png_warning((int)Buf, (int)"Zero length tRNS chunk");
      png_crc_finish(Buf, 0);
      return;
    }
    v5 = png_malloc(Buf, Size);
    *((_BYTE *)Buf + 93) |= 0x20u;
    Buf[87] = (int)v5;
    png_crc_read(Buf, (int)v5, Size);
    *((_WORD *)Buf + 133) = Size;
    goto LABEL_25;
  }
  if ( v4 != 2 )
  {
    if ( v4 )
    {
      png_warning((int)Buf, (int)"tRNS chunk not allowed with alpha channel");
      goto LABEL_28;
    }
    if ( Size == 2 )
    {
      png_crc_read(Buf, (int)&v9, 2);
      *((_WORD *)Buf + 180) = v10 + (v9 << 8);
      goto LABEL_24;
    }
LABEL_22:
    png_warning((int)Buf, (int)"Incorrect tRNS chunk length");
LABEL_28:
    png_crc_finish(Buf, Size);
    return;
  }
  if ( Size != 6 )
    goto LABEL_22;
  png_crc_read(Buf, (int)&v9, 6);
  v6 = v12;
  *((_WORD *)Buf + 177) = v10 + (v9 << 8);
  v7 = v6 + (v11 << 8);
  v8 = v14;
  *((_WORD *)Buf + 178) = v7;
  *((_WORD *)Buf + 179) = v8 + (v13 << 8);
LABEL_24:
  *((_WORD *)Buf + 133) = 1;
LABEL_25:
  if ( !png_crc_finish(Buf, 0) )
    sub_10020435((int)Buf, a2, Buf[87], *((unsigned __int16 *)Buf + 133), (int)(Buf + 88));
}

// FUN_1002587e @ 0x1002587E
int __cdecl sub_1002587E(jmp_buf Buf, int a2, unsigned int a3)
{
  int v3; // eax

  png_check_chunk_name(Buf, (unsigned __int8 *)Buf + 268);
  if ( (Buf[67] & 0x20) == 0 )
    FUN_1001e147(Buf, "unknown critical chunk");
  v3 = Buf[22];
  if ( (v3 & 4) != 0 )
    Buf[22] = v3 | 8;
  return png_crc_finish(Buf, a3);
}

// sub_100258C8 @ 0x100258C8
int __usercall sub_100258C8@<eax>(int a1@<ebx>, jmp_buf Buf)
{
  int *__attribute__((__org_typedef(jmp_buf))) v2; // esi
  int result; // eax
  unsigned __int8 v4; // bl
  unsigned int v5; // edx
  bool v6; // zf
  unsigned int v7; // eax
  unsigned int v8; // edx
  int v9; // ecx
  int v10; // eax
  const char *v11; // eax
  int v12; // [esp+4h] [ebp-4h] BYREF

  v2 = Buf;
  result = (int)(Buf + 53);
  ++Buf[53];
  if ( *(_DWORD *)result >= (unsigned int)v2[48] )
  {
    if ( *((_BYTE *)v2 + 275) )
    {
      *(_DWORD *)result = 0;
      FUN_100247b3(a1, (int)v2, (char *)v2[54], 0, v2[50] + 1);
      while ( 1 )
      {
        v4 = ++*((_BYTE *)v2 + 276);
        if ( v4 >= 7u )
          break;
        result = (v2[46] - dword_1004EA90[v4] + dword_1004EAAC[v4] - 1) / (unsigned int)dword_1004EAAC[v4];
        v5 = ((result * (unsigned int)*((unsigned __int8 *)v2 + 281) + 7) >> 3) + 1;
        v6 = (v2[24] & 2) == 0;
        v2[52] = result;
        v2[51] = v5;
        if ( v6 )
        {
          result = (v2[47] - dword_1004EAC8[v4] + dword_1004EAE4[v4] - 1) / (unsigned int)dword_1004EAE4[v4];
          v6 = v2[52] == 0;
          v2[48] = result;
          if ( v6 )
            continue;
        }
        return result;
      }
    }
    if ( (v2[23] & 0x20) == 0 )
    {
      v2[28] = (int)&Buf;
      v2[29] = 1;
      while ( 1 )
      {
        if ( !v2[26] )
        {
          while ( !v2[63] )
          {
            png_crc_finish(v2, 0);
            png_read_data(v2, (int)&v12, 4);
            v2[63] = png_get_uint_32((unsigned __int8 *)&v12);
            png_reset_crc((int)v2);
            png_crc_read(v2, (int)(v2 + 67), 4);
            if ( v2[67] != *(_DWORD *)"IDAT" )
              png_error(v2, (int)"Not enough image data");
          }
          v7 = v2[40];
          v8 = v2[63];
          v9 = v2[39];
          v2[26] = v7;
          v2[25] = v9;
          if ( v7 > v8 )
            v2[26] = v8;
          png_crc_read(v2, v9, v2[26]);
          v2[63] -= v2[26];
        }
        v10 = inflate((unsigned __int8 **)v2 + 25, 1);
        if ( v10 == 1 )
          break;
        if ( v10 )
        {
          v11 = (const char *)v2[31];
          if ( !v11 )
            v11 = "Decompression Error";
          png_error(v2, (int)v11);
        }
        if ( !v2[29] )
          png_error(v2, (int)"Extra compressed data");
      }
      if ( !v2[29] || v2[26] || v2[63] )
        png_error(v2, (int)"Extra compressed data");
      v2[22] |= 8u;
      v2[23] |= 0x20u;
      v2[29] = 0;
    }
    if ( v2[63] || v2[26] )
      png_error(v2, (int)"Extra compression data");
    result = inflateReset(v2 + 25);
    v2[22] |= 8u;
  }
  return result;
}

// sub_10025AEC @ 0x10025AEC
int __cdecl sub_10025AEC(int a1, _BYTE *a2, unsigned int a3)
{
  _BYTE *v3; // edx
  unsigned int v5; // esi
  unsigned int v6; // eax
  unsigned int v7; // esi
  _BYTE *v8; // edx
  unsigned int v9; // edi
  unsigned int v10; // esi
  unsigned int v11; // edi
  unsigned int v12; // esi
  unsigned int v13; // edi
  unsigned int v14; // esi

  v3 = a2;
  if ( !a2 )
    return 0;
  v5 = ~a1;
  if ( a3 >= 8 )
  {
    v6 = a3 >> 3;
    do
    {
      a3 -= 8;
      v7 = (v5 >> 8) ^ dword_1004EF90[(unsigned __int8)(v5 ^ *v3)];
      v8 = v3 + 1;
      v9 = (v7 >> 8) ^ dword_1004EF90[(unsigned __int8)(v7 ^ *v8++)];
      v10 = (v9 >> 8) ^ dword_1004EF90[(unsigned __int8)(v9 ^ *v8++)];
      v11 = (v10 >> 8) ^ dword_1004EF90[(unsigned __int8)(v10 ^ *v8++)];
      v12 = (v11 >> 8) ^ dword_1004EF90[(unsigned __int8)(v11 ^ *v8++)];
      v13 = (v12 >> 8) ^ dword_1004EF90[(unsigned __int8)(v12 ^ *v8++)];
      v14 = (v13 >> 8) ^ dword_1004EF90[(unsigned __int8)(v13 ^ *v8++)];
      v5 = dword_1004EF90[(unsigned __int8)(v14 ^ *v8)] ^ (v14 >> 8);
      v3 = v8 + 1;
      --v6;
    }
    while ( v6 );
  }
  for ( ; a3; --a3 )
    v5 = dword_1004EF90[(unsigned __int8)(v5 ^ *v3++)] ^ (v5 >> 8);
  return ~v5;
}

// sub_10025C00 @ 0x10025C00
__m128 *__stdcall sub_10025C00(__m128 *a1, unsigned int *a2, __m128 *a3)
{
  *a1 = _mm_add_ps(
          _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3), a3[3]),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1]));
  return a1;
}

// sub_10025C40 @ 0x10025C40
double *__stdcall sub_10025C40(double *a1, unsigned int *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm1

  v3 = _mm_add_ps(
         _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3), a3[3]),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1]));
  v4 = _mm_rcp_ps(v3);
  v5 = _mm_mul_ps(_mm_mul_ps(v4, v4), v3);
  _mm_storel_ps(a1, _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 255)));
  return a1;
}

// sub_10025CA0 @ 0x10025CA0
double *__stdcall sub_10025CA0(double *a1, unsigned int *a2, __m128 *a3)
{
  _mm_storel_ps(
    a1,
    _mm_add_ps(
      _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), *a3),
      _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), a3[1])));
  return a1;
}

// sub_10025CE0 @ 0x10025CE0
void __stdcall sub_10025CE0(int a1, int a2, int a3)
{
  JUMPOUT(0x10025CF1);
}

// sub_10025CEE @ 0x10025CEE
double *__stdcall sub_10025CEE(double *a1, unsigned int *a2, const double *a3)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm4
  __m128 v10; // xmm5
  __m128 v11; // xmm6
  __m128 v12; // xmm7
  __m128 v13; // xmm2
  __m128 v14; // xmm1
  __m128 v15; // xmm7

  v5 = _mm_loadh_ps(a3 + 1);
  v6 = _mm_loadh_ps(a3 + 3);
  v7 = _mm_loadh_ps(a3 + 5);
  v8 = _mm_loadh_ps(a3 + 7);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), v5),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v6)),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v7)),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[3], (__m128)a2[3], 0), v8));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[7], (__m128)a2[7], 0), v8));
  v11 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[8], (__m128)a2[8], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v8));
  v12 = _mm_add_ps(
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[12], (__m128)a2[12], 0), v5),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), v6));
  v13 = _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v7);
  v14 = (__m128)a2[15];
  _mm_storel_ps(a1, v9);
  _mm_storeh_ps(a1 + 1, v9);
  _mm_storel_ps(a1 + 2, v10);
  _mm_storeh_ps(a1 + 3, v10);
  _mm_storel_ps(a1 + 4, v11);
  _mm_storeh_ps(a1 + 5, v11);
  v15 = _mm_add_ps(_mm_add_ps(v12, v13), _mm_mul_ps(_mm_shuffle_ps(v14, v14, 0), v8));
  _mm_storel_ps(a1 + 6, v15);
  _mm_storeh_ps(a1 + 7, v15);
  return a1;
}

// sub_10025E30 @ 0x10025E30
void __stdcall sub_10025E30(int a1, int a2)
{
  JUMPOUT(0x10025E41);
}

// sub_10025E3E @ 0x10025E3E
float *__stdcall sub_10025E3E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm6_4
  float v4; // xmm5_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E000 <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E004 * v6)
       * (float)(*(float *)&dword_1005E008
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
  }
  return result;
}

// sub_10025F00 @ 0x10025F00
void __stdcall sub_10025F00(int a1, int a2)
{
  JUMPOUT(0x10025F11);
}

// sub_10025F0E @ 0x10025F0E
float *__stdcall sub_10025F0E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm4_4
  float v4; // xmm6_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E00C <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E010 * v6)
       * (float)(*(float *)&dword_1005E014
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
    a1[3] = v7 * a2[3];
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    a1[3] = 0.0;
  }
  return result;
}

// sub_10025FE0 @ 0x10025FE0
void __stdcall sub_10025FE0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10025FF1);
}

// sub_10025FEE @ 0x10025FEE
__m128 *__stdcall sub_10025FEE(__m128 *a1, int a2, int a3, int a4)
{
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm3
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm4
  __m128 v12; // xmm2
  __m128 v13; // xmm3
  __m128 v14; // xmm1

  v5 = _mm_loadh_ps((const double *)(a3 + 8));
  v6 = _mm_shuffle_ps(v5, v5, 57);
  v7 = _mm_loadh_ps((const double *)(a2 + 8));
  v8 = _mm_loadh_ps((const double *)(a4 + 8));
  v9 = _mm_shuffle_ps(v8, v8, 78);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 57), v6);
  v11 = _mm_mul_ps(v9, v6);
  v12 = _mm_mul_ps(v6, v8);
  v13 = _mm_shuffle_ps(v7, v7, 57);
  v14 = _mm_shuffle_ps(v13, v13, 57);
  *a1 = _mm_xor_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v13, _mm_sub_ps(_mm_shuffle_ps(v11, v11, 57), _mm_shuffle_ps(v12, v12, 78))),
              _mm_mul_ps(_mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10), v14)),
            _mm_mul_ps(_mm_shuffle_ps(v14, v14, 57), _mm_sub_ps(v11, _mm_shuffle_ps(v12, v12, 57)))),
          (__m128)xmmword_10055500);
  return a1;
}

// sub_10026090 @ 0x10026090
float *__stdcall sub_10026090(float *a1, float *a2)
{
  float v2; // xmm1_4
  float v3; // xmm2_4
  float v4; // xmm3_4
  float v5; // xmm4_4
  float v6; // xmm6_4
  float v7; // xmm5_4

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = (float)((float)(*a2 * *a2) + (float)(v2 * v2)) + (float)((float)(v3 * v3) + (float)(v4 * v4));
  v6 = 1.0 / fsqrt(v5);
  v7 = (float)((float)(*(float *)&dword_10055520 - (float)(v5 * (float)(v6 * v6))) * *(float *)&dword_10055510) * v6;
  *a1 = *a2 * v7;
  a1[1] = v2 * v7;
  a1[2] = v3 * v7;
  a1[3] = v4 * v7;
  return a1;
}

// sub_10026130 @ 0x10026130
int __userpurge sub_10026130@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        int a3,
        const double *a4,
        const double *a5,
        const double *a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps(a4), _mm_shuffle_ps(v9, v9, 0)),
              _mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v9, v9, 85))),
            _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v9, v9, 170))),
          _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v9, v9, 255)));
  _mm_storeh_ps((double *)a3, v10);
  *(_DWORD *)(a3 + 8) = v10.m128_i32[0];
  return a3;
}

// sub_100261F0 @ 0x100261F0
double *__userpurge sub_100261F0@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        double *a3,
        int a4,
        const double *a5,
        int a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm6
  __m128 v11; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  v10 = _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v9, v9, 250));
  v11 = _mm_add_ps(_mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v9, v9, 80)), v10);
  _mm_storel_ps(a3, _mm_add_ps(v11, _mm_movehl_ps(v10, v11)));
  return a3;
}

// sub_10026280 @ 0x10026280
__m128 *__userpurge sub_10026280@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 *a3,
        __m128 *a4,
        __m128 *a5,
        __m128 *a6,
        __m128 *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_10055560), (__m128)xmmword_10055540),
           _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055550)),
         _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055530));
  *a3 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(*a4, _mm_shuffle_ps(v9, v9, 0)), _mm_mul_ps(*a5, _mm_shuffle_ps(v9, v9, 85))),
            _mm_mul_ps(*a6, _mm_shuffle_ps(v9, v9, 170))),
          _mm_mul_ps(*a7, _mm_shuffle_ps(v9, v9, 255)));
  return a3;
}

// sub_10026330 @ 0x10026330
int __userpurge sub_10026330@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        int a3,
        const double *a4,
        const double *a5,
        const double *a6,
        const double *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm0
  __m128 v11; // xmm4

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_100555A0);
  v9.m128_f32[0] = v9.m128_f32[0] + *(float *)&dword_10055580;
  v10 = _mm_add_ps(
          _mm_add_ps(v9, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  v11 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps(a4), _mm_shuffle_ps(v10, v10, 0)),
              _mm_mul_ps(_mm_loadh_ps(a5), _mm_shuffle_ps(v10, v10, 85))),
            _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v10, v10, 170))),
          _mm_mul_ps(_mm_loadh_ps(a7), _mm_shuffle_ps(v10, v10, 255)));
  _mm_storeh_ps((double *)a3, v11);
  *(_DWORD *)(a3 + 8) = v11.m128_i32[0];
  return a3;
}

// sub_100263F0 @ 0x100263F0
__m128 *__userpurge sub_100263F0@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 *a3,
        __m128 *a4,
        __m128 *a5,
        __m128 *a6,
        __m128 *a7,
        float a8)
{
  __m128 v8; // xmm0
  __m128 v9; // xmm0
  __m128 v10; // xmm0

  v8 = (__m128)LODWORD(a8);
  a1.m128_f32[0] = v8.m128_f32[0] * v8.m128_f32[0];
  a2.m128_f32[0] = a8 * (float)(v8.m128_f32[0] * v8.m128_f32[0]);
  v9 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 0), (__m128)xmmword_100555A0);
  v9.m128_f32[0] = v9.m128_f32[0] + *(float *)&dword_10055580;
  v10 = _mm_add_ps(
          _mm_add_ps(v9, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  *a3 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(_mm_mul_ps(*a4, _mm_shuffle_ps(v10, v10, 0)), _mm_mul_ps(*a5, _mm_shuffle_ps(v10, v10, 85))),
            _mm_mul_ps(*a6, _mm_shuffle_ps(v10, v10, 170))),
          _mm_mul_ps(*a7, _mm_shuffle_ps(v10, v10, 255)));
  return a3;
}

// sub_10026490 @ 0x10026490
double *__userpurge sub_10026490@<eax>(
        __m128 a1@<xmm1>,
        __m128 a2@<xmm2>,
        __m128 a3@<xmm3>,
        double *a4,
        int a5,
        const double *a6,
        int a7,
        const double *a8,
        float a9)
{
  __m128 v9; // xmm0
  __m128 v10; // xmm0
  __m128 v11; // xmm0
  __m128 v12; // xmm4

  v9 = (__m128)LODWORD(a9);
  a1.m128_f32[0] = v9.m128_f32[0] * v9.m128_f32[0];
  a2.m128_f32[0] = a9 * (float)(v9.m128_f32[0] * v9.m128_f32[0]);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), (__m128)xmmword_100555A0);
  v10.m128_f32[0] = v10.m128_f32[0] + *(float *)&dword_10055580;
  v11 = _mm_add_ps(
          _mm_add_ps(v10, _mm_mul_ps(_mm_shuffle_ps(a1, a1, 0), (__m128)xmmword_10055590)),
          _mm_mul_ps(_mm_shuffle_ps(a2, a2, 0), (__m128)xmmword_10055570));
  v12 = _mm_add_ps(
          _mm_mul_ps(_mm_loadh_ps(a6), _mm_shuffle_ps(v11, v11, 80)),
          _mm_mul_ps(_mm_loadh_ps(a8), _mm_shuffle_ps(v11, v11, 250)));
  _mm_storel_ps(a4, _mm_add_ps(v12, _mm_movehl_ps(a3, v12)));
  return a4;
}

// sub_10026520 @ 0x10026520
int __stdcall sub_10026520(
        int a1,
        const double *a2,
        const double *a3,
        const double *a4,
        unsigned int a5,
        unsigned int a6)
{
  __m128 v6; // xmm2
  __m128 v7; // xmm3

  v6 = _mm_loadh_ps(a2);
  v7 = _mm_add_ps(
         _mm_add_ps(_mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a3), v6), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), v6),
         _mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a4), v6), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0)));
  *(_DWORD *)(a1 + 8) = v7.m128_i32[0];
  _mm_storeh_ps((double *)a1, v7);
  return a1;
}

// sub_10026580 @ 0x10026580
__m128 *__stdcall sub_10026580(__m128 *a1, __m128 *a2, __m128 *a3, __m128 *a4, unsigned int a5, unsigned int a6)
{
  *a1 = _mm_add_ps(
          _mm_add_ps(_mm_mul_ps(_mm_sub_ps(*a3, *a2), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), *a2),
          _mm_mul_ps(_mm_sub_ps(*a4, *a2), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0)));
  return a1;
}

// sub_100265D0 @ 0x100265D0
double *__stdcall sub_100265D0(
        double *a1,
        const double *a2,
        const double *a3,
        const double *a4,
        unsigned int a5,
        unsigned int a6)
{
  __m128 v6; // xmm2

  v6 = _mm_loadh_ps(a2);
  _mm_storeh_ps(
    a1,
    _mm_add_ps(
      _mm_add_ps(_mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a3), v6), _mm_shuffle_ps((__m128)a5, (__m128)a5, 0)), v6),
      _mm_mul_ps(_mm_sub_ps(_mm_loadh_ps(a4), v6), _mm_shuffle_ps((__m128)a6, (__m128)a6, 0))));
  return a1;
}

// sub_10026630 @ 0x10026630
int __userpurge sub_10026630@<eax>(
        __m128 a1@<xmm5>,
        __m128 a2@<xmm6>,
        int a3,
        __m128 *a4,
        const double *a5,
        const double *a6)
{
  __m128 v6; // xmm1
  __m128 v7; // xmm4
  __m128 v8; // xmm0
  __m128 v9; // xmm2
  __m128 v10; // xmm3
  __m128 v11; // xmm0
  __m128 v12; // xmm5
  __m128 v13; // xmm6
  __m128 v14; // xmm0
  float v15; // xmm5_4
  __m128 v16; // xmm3
  __m128 v17; // xmm1
  int v19; // [esp+0h] [ebp-4h]

  v19 = a3;
  v6 = _mm_loadh_ps(a5);
  v7 = *a4;
  v8 = _mm_shuffle_ps(v7, v7, 78);
  v9 = _mm_loadh_ps(a6);
  v10 = _mm_mul_ps(v6, v8);
  v11 = _mm_mul_ps(v8, v9);
  v12 = _mm_movehl_ps(a1, v10);
  v13 = _mm_movehl_ps(a2, v11);
  v16 = _mm_add_ps(v10, v12);
  v14 = _mm_add_ps(v11, v13);
  v16.m128_f32[0] = v16.m128_f32[0] + _mm_shuffle_ps(v12, v16, 85).m128_f32[0];
  v15 = v16.m128_f32[0] - (float)(v14.m128_f32[0] + _mm_shuffle_ps(v13, v14, 85).m128_f32[0]);
  v16.m128_f32[0] = v16.m128_f32[0] + _mm_shuffle_ps(v7, v7, 255).m128_f32[0];
  if ( v15 == *(float *)&dword_1005DB80 )
    return 0;
  v16.m128_f32[0] = v16.m128_f32[0]
                  * (float)((float)((float)(1.0 / v15) + (float)(1.0 / v15))
                          - (float)((float)(v15 * (float)(1.0 / v15)) * (float)(1.0 / v15)));
  v17 = _mm_add_ps(v6, _mm_mul_ps(_mm_shuffle_ps(v16, v16, 0), _mm_sub_ps(v9, v6)));
  _mm_storeh_ps((double *)a3, v17);
  *(_DWORD *)(a3 + 8) = v17.m128_i32[0];
  return v19;
}

// sub_100266F0 @ 0x100266F0
void __stdcall sub_100266F0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10026701);
}

// sub_100266FE @ 0x100266FE
__m128 *__stdcall sub_100266FE(__m128 *a1, const double *a2, const double *a3, const double *a4)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  __m128 v8; // xmm4
  __m128 v9; // xmm5
  __m128 v10; // xmm3
  __m128 v11; // xmm5
  __m128 v12; // xmm1
  __m128 v13; // xmm3
  __m128 v14; // xmm5
  __m128 v15; // xmm0
  __m128 v16; // xmm5
  __m128 v17; // xmm3
  __m128 v18; // xmm0

  v5 = _mm_loadh_ps(a2);
  v6 = _mm_sub_ps(v5, _mm_loadh_ps(a4));
  v7 = _mm_shuffle_ps(v6, v6, 120);
  v8 = v5;
  v9 = _mm_sub_ps(v5, _mm_loadh_ps(a3));
  v10 = _mm_shuffle_ps(v9, v9, 99);
  v11 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 120), _mm_shuffle_ps(v6, v6, 99));
  v12 = (__m128)xmmword_100555D0;
  v13 = _mm_sub_ps(_mm_mul_ps(v7, v10), v11);
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = v15;
  v15.m128_f32[0] = fsqrt(v15.m128_f32[0]);
  v12.m128_f32[0] = (float)(*(float *)&xmmword_100555D0 * (float)(1.0 / v15.m128_f32[0]))
                  * (float)(*(float *)&xmmword_100555C0
                          - (float)((float)(v16.m128_f32[0] * (float)(1.0 / v15.m128_f32[0]))
                                  * (float)(1.0 / v15.m128_f32[0])));
  v17 = _mm_mul_ps(v13, _mm_shuffle_ps(v12, v12, 0));
  *a1 = v17;
  v18 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 14), v17);
  a1->m128_i32[3] = COERCE_UNSIGNED_INT(
                      v18.m128_f32[0]
                    + (float)(_mm_movehl_ps(v16, v18).m128_f32[0] + _mm_shuffle_ps(v18, v18, 85).m128_f32[0]))
                  ^ xmmword_100555B0;
  return a1;
}

// sub_100267E0 @ 0x100267E0
void __stdcall sub_100267E0(int a1, int a2, int a3)
{
  JUMPOUT(0x100267F1);
}

// sub_100267EE @ 0x100267EE
double *__stdcall sub_100267EE(double *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  char v8; // al
  __m128 v9; // xmm4
  float v10; // xmm3_4
  float v11; // xmm5_4
  double *result; // eax
  __m128 v13; // xmm4
  __m128 v14; // xmm0
  __m128 v15; // xmm0
  __m128 v16; // xmm0
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  float v19; // xmm7_4
  __m128 v20; // xmm0
  __m128 v21; // xmm1
  __m128 v22; // xmm2
  __m128 v23; // xmm3

  v3 = *a3;
  v4 = _mm_and_ps((__m128)xmmword_10055620, *a3);
  v5 = _mm_mul_ps(v4, v4);
  v6 = _mm_add_ps(v5, _mm_movehl_ps((__m128)0LL, v5));
  v7 = _mm_shuffle_ps(v6, v6, 1);
  v7.m128_f32[0] = v7.m128_f32[0] + v6.m128_f32[0];
  if ( v7.m128_f32[0] != 0.0 )
  {
    v8 = byte_1005DBF0;
    if ( (byte_1005DBF0 & 1) != 0 )
    {
      v9 = (__m128)xmmword_1005DBD0;
    }
    else
    {
      v8 = byte_1005DBF0 | 1;
      v9 = (__m128)(unsigned int)dword_1005E0C0;
      byte_1005DBF0 |= 1u;
      xmmword_1005DBD0 = (unsigned int)dword_1005E0C0;
    }
    if ( (v8 & 2) != 0 )
    {
      v10 = *(float *)&xmmword_1005DBE0;
    }
    else
    {
      v10 = *(float *)&dword_1005E0C4;
      byte_1005DBF0 = v8 | 2;
      xmmword_1005DBE0 = (unsigned int)dword_1005E0C4;
    }
    v11 = 1.0 / fsqrt(v7.m128_f32[0]);
    v9.m128_f32[0] = (float)(v9.m128_f32[0] * v11) * (float)(v10 - (float)((float)(v7.m128_f32[0] * v11) * v11));
    v7 = _mm_mul_ps(v3, _mm_shuffle_ps(v9, v9, 0));
  }
  result = a1;
  v13 = _mm_xor_ps((__m128)xmmword_100555E0, v7);
  v14 = _mm_mul_ps(v7, *a2);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v6, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = _mm_shuffle_ps(v15, v15, 0);
  v17 = _mm_and_ps((__m128)xmmword_10055600, v16);
  v18 = _mm_and_ps((__m128)xmmword_10055610, v16);
  v19 = v16.m128_f32[0];
  v20 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 85), *a2), _mm_and_ps((__m128)xmmword_100555F0, v16));
  v21 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), *a2), v17);
  v23 = _mm_mul_ps(_mm_shuffle_ps(v13, v13, 0), *a2);
  v22 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 255), *a2), v18);
  v23.m128_f32[0] = v23.m128_f32[0] + v19;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    _mm_storel_ps(a1, v23);
    _mm_storeh_ps(a1 + 1, v23);
    _mm_storel_ps(a1 + 2, v20);
    _mm_storeh_ps(a1 + 3, v20);
    _mm_storel_ps(a1 + 4, v21);
    _mm_storeh_ps(a1 + 5, v21);
    _mm_storel_ps(a1 + 6, v22);
    _mm_storeh_ps(a1 + 7, v22);
  }
  else
  {
    *(__m128 *)a1 = v23;
    *((__m128 *)a1 + 1) = v20;
    *((__m128 *)a1 + 2) = v21;
    *((__m128 *)a1 + 3) = v22;
  }
  return result;
}

// sub_10026970 @ 0x10026970
void __stdcall sub_10026970(int a1, int a2)
{
  JUMPOUT(0x10026981);
}

// sub_1002697E @ 0x1002697E
__m128 *__stdcall sub_1002697E(__m128 *a1, const double *a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm0
  __m128 v5; // xmm3
  __m128 v6; // xmm4
  __m128 v7; // xmm0
  float v8; // xmm5_4
  __m128 v9; // xmm1
  __m128 v10; // xmm4
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm2
  __m128 v14; // xmm0
  __m128 v15; // xmm3
  __m128 v16; // xmm2
  __m128 v17; // xmm4

  v3 = _mm_loadl_ps(a2);
  v4 = _mm_and_ps((__m128)xmmword_100556A0, v3);
  v5 = (__m128)(unsigned int)dword_10055690;
  v6 = _mm_mul_ps(v4, v4);
  v7 = _mm_add_ps(v6, _mm_movehl_ps(v6, v6));
  v8 = v7.m128_f32[0] + _mm_shuffle_ps(v7, v7, 1).m128_f32[0];
  v7.m128_f32[0] = 1.0 / fsqrt(v8);
  v5.m128_f32[0] = (float)(*(float *)&dword_10055690 * v7.m128_f32[0])
                 * (float)(*(float *)&dword_10055680 - (float)((float)(v8 * v7.m128_f32[0]) * v7.m128_f32[0]));
  v9 = _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 0));
  v10 = _mm_mul_ps((__m128)xmmword_10055670, v9);
  v11 = v9;
  v12 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), v10), (__m128)xmmword_10055660);
  v13 = v11;
  v14 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v11, v11, 255), v10), (__m128)xmmword_10055630);
  v15 = v13;
  v16 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), v10), (__m128)xmmword_10055640);
  v17 = _mm_add_ps(_mm_mul_ps(v10, _mm_shuffle_ps(v15, v15, 85)), (__m128)xmmword_10055650);
  *a1 = v12;
  a1[1] = v17;
  a1[2] = v16;
  a1[3] = v14;
  return a1;
}

// sub_10026A50 @ 0x10026A50
double *__stdcall sub_10026A50(double *a1, int a2, int a3)
{
  __m128 v3; // xmm0
  __m128 v4; // xmm2
  __m128 v5; // xmm1
  __m128 v6; // xmm0
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm1

  v3 = _mm_loadh_ps((const double *)(a2 + 8));
  v4 = _mm_loadh_ps((const double *)(a3 + 8));
  v5 = _mm_mul_ps(_mm_shuffle_ps(v4, v4, 255), v3);
  v6 = _mm_shuffle_ps(v3, v3, 27);
  v7 = _mm_add_ps(v5, _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 0), (__m128)xmmword_1005E100), v6));
  v8 = _mm_shuffle_ps(v6, v6, 177);
  v9 = _mm_add_ps(
         _mm_add_ps(v7, _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 85), (__m128)xmmword_1005E0F0), v8)),
         _mm_mul_ps(_mm_xor_ps(_mm_shuffle_ps(v4, v4, 170), (__m128)xmmword_1005E0E0), _mm_shuffle_ps(v8, v8, 27)));
  _mm_storel_ps(a1, v9);
  _mm_storeh_ps(a1 + 1, v9);
  return a1;
}

// sub_10026AE0 @ 0x10026AE0
float *__stdcall sub_10026AE0(float *a1, float *a2)
{
  float v2; // xmm1_4
  float v3; // xmm2_4
  float v4; // xmm3_4
  float v5; // xmm4_4
  float v6; // xmm6_4
  float v7; // xmm5_4

  v2 = a2[1];
  v3 = a2[2];
  v4 = a2[3];
  v5 = (float)((float)(*a2 * *a2) + (float)(v2 * v2)) + (float)((float)(v3 * v3) + (float)(v4 * v4));
  v6 = 1.0 / fsqrt(v5);
  v7 = (float)((float)(*(float *)&dword_100556D0 - (float)(v5 * (float)(v6 * v6))) * *(float *)&dword_100556C0) * v6;
  *a1 = *a2 * v7;
  a1[1] = v2 * v7;
  a1[2] = v3 * v7;
  a1[3] = v4 * v7;
  return a1;
}

// sub_10026B80 @ 0x10026B80
void __stdcall sub_10026B80(int a1, int a2)
{
  JUMPOUT(0x10026B91);
}

// sub_10026B8E @ 0x10026B8E
__m128 *__stdcall sub_10026B8E(__m128 *a1, int a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm2
  __m128 v5; // xmm0
  __m128 v6; // xmm3

  v3 = _mm_loadh_ps((const double *)(a2 + 8));
  v4 = _mm_mul_ps(v3, v3);
  v5 = _mm_add_ps(v4, _mm_movehl_ps(v4, v4));
  v4.m128_f32[0] = v5.m128_f32[0] + _mm_shuffle_ps(v5, v5, 85).m128_f32[0];
  v5.m128_f32[0] = 1.0 / v4.m128_f32[0];
  v6 = v5;
  v6.m128_f32[0] = (float)(v6.m128_f32[0] + v6.m128_f32[0])
                 - (float)((float)(v5.m128_f32[0] * v4.m128_f32[0]) * v5.m128_f32[0]);
  *a1 = _mm_mul_ps(_mm_mul_ps(v3, (__m128)xmmword_100556E0), _mm_shuffle_ps(v6, v6, 0));
  return a1;
}

// sub_10026BF0 @ 0x10026BF0
float *__stdcall sub_10026BF0(float *a1, float *a2)
{
  float *result; // eax
  double v3; // st7
  float v4; // edi
  float v5; // esi
  int v6; // ebp
  double v7; // st7
  int v8; // ecx
  int v9; // ebx
  int v10; // ebp
  float *v11; // esi
  long double v12; // st6
  long double v13; // st7
  float *v14; // ecx
  long double v15; // st6
  long double v16; // st7
  _DWORD v17[7]; // [esp+0h] [ebp-1Ch]

  result = a1;
  v3 = *a2 + a2[5] + a2[10];
  v4 = *a2;
  v5 = a2[5];
  v6 = *((_DWORD *)a2 + 10);
  if ( flt_1005E11C < v3 )
  {
    v15 = sqrt(v3 + flt_1005E120) * flt_1005E124;
    v16 = flt_1005E128 / v15;
    a1[3] = v15;
    *a1 = (a2[6] - a2[9]) * v16;
    a1[1] = (a2[8] - a2[2]) * v16;
    a1[2] = v16 * (a2[1] - a2[4]);
  }
  else
  {
    v7 = a2[10];
    *(float *)v17 = *a2;
    *(float *)&v17[1] = v5;
    v17[2] = v6;
    v8 = 2;
    if ( *(float *)&v17[v5 > (double)v4] >= v7 )
      v8 = v5 > (double)v4;
    v9 = dword_1005E110[v8];
    v10 = dword_1005E110[v9];
    v11 = &a2[v8];
    v12 = sqrt(flt_1005E130 + *(float *)&v17[v8] - *(float *)&v17[v9] - *(float *)&v17[v10]) * flt_1005E134;
    v13 = flt_1005E138 / v12;
    a1[v8] = v12;
    v14 = &a2[4 * v8];
    a1[v9] = (v14[v9] + v11[4 * v9]) * v13;
    a1[v10] = (v11[4 * v10] + v14[v10]) * v13;
    a1[3] = v13 * (a2[4 * v9 + v10] - a2[4 * v10 + v9]);
  }
  return result;
}

// sub_10026D10 @ 0x10026D10
void __stdcall sub_10026D10(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10026D21);
}

// sub_10026D1E @ 0x10026D1E
__m128 *__stdcall sub_10026D1E(__m128 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __m128 v4; // xmm0
  __m128 v5; // xmm1
  __m128 v6; // xmm3
  __m128 v7; // xmm2
  __m128 v8; // xmm3
  __m128 v10; // [esp+10h] [ebp-4Ch] BYREF
  __m128 v11[3]; // [esp+20h] [ebp-3Ch] BYREF

  v10 = _mm_mul_ps(
          _mm_shuffle_ps(
            _mm_unpacklo_ps((__m128)a3, (__m128)a4),
            _mm_unpacklo_ps((__m128)(unsigned int)dword_1005E160, (__m128)a2),
            17),
          (__m128)xmmword_1005E150);
  sub_10034900(&v10, &v10, v11);
  v4 = _mm_shuffle_ps(v10, v11[0], 0);
  v5 = _mm_shuffle_ps(v4, v4, 138);
  v6 = _mm_shuffle_ps(v10, v11[0], 153);
  v7 = _mm_shuffle_ps(v6, v6, 247);
  v8 = _mm_shuffle_ps(v6, v6, 168);
  v10 = _mm_add_ps(
          _mm_mul_ps(_mm_mul_ps(v5, v7), v8),
          _mm_xor_ps(
            _mm_mul_ps(_mm_mul_ps(_mm_shuffle_ps(v5, v5, 138), _mm_shuffle_ps(v7, v7, 81)), _mm_shuffle_ps(v8, v8, 1)),
            (__m128)xmmword_1005E140));
  *a1 = v10;
  return a1;
}

// sub_10026DE0 @ 0x10026DE0
void __stdcall sub_10026DE0(int a1, int a2, int a3)
{
  JUMPOUT(0x10026DF1);
}

// sub_10026DEE @ 0x10026DEE
int __stdcall sub_10026DEE(int a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v6; // xmm5
  __m128 v7; // xmm3

  if ( (a3 & 0xF) != 0 )
  {
    v6 = _mm_loadl_ps((const double *)a2);
    v7 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v6, v6, 0)),
             _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v6, v6, 85))),
           _mm_mul_ps(
             _mm_loadh_ps((const double *)(a3 + 40)),
             _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)));
    _mm_storel_ps((double *)a1, v7);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v7, v7).m128_u32[0];
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    v4 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
           _mm_mul_ps(
             _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
             *(__m128 *)(a3 + 32)));
    _mm_storel_ps((double *)a1, v4);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v4, v4).m128_u32[0];
  }
  return a1;
}

// sub_10026EA0 @ 0x10026EA0
void __stdcall sub_10026EA0(int a1, int a2, int a3)
{
  JUMPOUT(0x10026EB1);
}

// sub_10026EAE @ 0x10026EAE
__m128 *__stdcall sub_10026EAE(__m128 *a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v5; // xmm6

  if ( (a3 & 0xF) != 0 )
  {
    v5 = _mm_loadl_ps((const double *)a2);
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v5, v5, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v5, v5, 85))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_loadh_ps((const double *)(a3 + 40)),
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)),
              _mm_loadh_ps((const double *)(a3 + 56))));
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
              _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
                *(__m128 *)(a3 + 32)),
              *(__m128 *)(a3 + 48)));
  }
  return a1;
}

// sub_10026F60 @ 0x10026F60
void __stdcall sub_10026F60(int a1, int a2, int a3)
{
  JUMPOUT(0x10026F71);
}

// sub_10026F6E @ 0x10026F6E
int __stdcall sub_10026F6E(int a1, int a2, int a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm0
  __m128 v9; // xmm6
  __m128 v10; // xmm4
  __m128 v11; // xmm1
  __m128 v12; // xmm1
  __m128 v13; // xmm4

  if ( (a3 & 0xF) != 0 )
  {
    v9 = _mm_loadl_ps((const double *)a2);
    v10 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(v9, v9, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(v9, v9, 85))),
            _mm_add_ps(
              _mm_mul_ps(
                _mm_loadh_ps((const double *)(a3 + 40)),
                _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0)),
              _mm_loadh_ps((const double *)(a3 + 56))));
    v11 = _mm_rcp_ps(v10);
    v12 = _mm_sub_ps(_mm_add_ps(v11, v11), _mm_mul_ps(_mm_mul_ps(v11, v10), v11));
    v13 = _mm_mul_ps(v10, _mm_shuffle_ps(v12, v12, 255));
    _mm_storel_ps((double *)a1, v13);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v13, v13).m128_u32[0];
  }
  else
  {
    v3 = _mm_loadl_ps((const double *)a2);
    v4 = _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 0), *(__m128 *)a3),
             _mm_mul_ps(_mm_shuffle_ps(v3, v3, 85), *(__m128 *)(a3 + 16))),
           _mm_add_ps(
             _mm_mul_ps(
               _mm_shuffle_ps((__m128)*(unsigned int *)(a2 + 8), (__m128)*(unsigned int *)(a2 + 8), 0),
               *(__m128 *)(a3 + 32)),
             *(__m128 *)(a3 + 48)));
    v5 = _mm_rcp_ps(v4);
    v6 = _mm_sub_ps(_mm_add_ps(v5, v5), _mm_mul_ps(_mm_mul_ps(v5, v4), v5));
    v7 = _mm_mul_ps(v4, _mm_shuffle_ps(v6, v6, 255));
    _mm_storel_ps((double *)a1, v7);
    *(_DWORD *)(a1 + 8) = _mm_movehl_ps(v7, v7).m128_u32[0];
  }
  return a1;
}

// sub_10027060 @ 0x10027060
void __stdcall sub_10027060(int a1, int a2, int a3)
{
  JUMPOUT(0x10027071);
}

// sub_1002706E @ 0x1002706E
__m128 *__stdcall sub_1002706E(__m128 *a1, __m128 *a2, int a3)
{
  if ( (a3 & 0xF) != 0 )
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 8)), _mm_shuffle_ps(*a2, *a2, 0)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 24)), _mm_shuffle_ps(*a2, *a2, 85))),
            _mm_add_ps(
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 40)), _mm_shuffle_ps(*a2, *a2, 170)),
              _mm_mul_ps(_mm_loadh_ps((const double *)(a3 + 56)), _mm_shuffle_ps(*a2, *a2, 255))));
  else
    *a1 = _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 0), *(__m128 *)a3),
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 85), *(__m128 *)(a3 + 16))),
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 170), *(__m128 *)(a3 + 32)),
              _mm_mul_ps(_mm_shuffle_ps(*a2, *a2, 255), *(__m128 *)(a3 + 48))));
  return a1;
}

// sub_10027120 @ 0x10027120
void __stdcall sub_10027120(int a1, int a2)
{
  JUMPOUT(0x10027131);
}

// sub_1002712E @ 0x1002712E
float *__stdcall sub_1002712E(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm6_4
  float v4; // xmm5_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E180 <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E184 * v6)
       * (float)(*(float *)&dword_1005E188
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
  }
  return result;
}

// sub_100271F0 @ 0x100271F0
void __stdcall sub_100271F0(int a1, int a2)
{
  JUMPOUT(0x10027201);
}

// sub_100271FE @ 0x100271FE
float *__stdcall sub_100271FE(float *a1, float *a2)
{
  float *result; // eax
  float v3; // xmm4_4
  float v4; // xmm6_4
  float v5; // xmm3_4
  float v6; // xmm3_4
  float v7; // xmm0_4

  result = a1;
  v3 = a2[1];
  v4 = a2[2];
  v5 = (float)((float)(*a2 * *a2) + (float)(v3 * v3)) + (float)(v4 * v4);
  if ( *(float *)&dword_1005E18C <= v5 )
  {
    v6 = 1.0 / fsqrt(v5);
    v7 = (float)(*(float *)&dword_1005E190 * v6)
       * (float)(*(float *)&dword_1005E194
               - (float)((float)((float)((float)((float)(*a2 * *a2) + (float)(a2[1] * a2[1])) + (float)(a2[2] * a2[2]))
                               * v6)
                       * v6));
    *a1 = v7 * *a2;
    a1[1] = v7 * v3;
    a1[2] = v7 * v4;
    a1[3] = v7 * a2[3];
  }
  else
  {
    *a1 = 0.0;
    a1[1] = 0.0;
    a1[2] = 0.0;
    a1[3] = 0.0;
  }
  return result;
}

// sub_100272D0 @ 0x100272D0
void __stdcall sub_100272D0(int a1, int a2, int a3)
{
  JUMPOUT(0x100272E1);
}

// sub_100272DE @ 0x100272DE
double *__stdcall sub_100272DE(double *a1, _DWORD *a2, const double *a3)
{
  __m128 v3; // xmm4
  __m128 v4; // xmm1
  __m128 v5; // xmm5
  __m128 v6; // xmm0
  __m128 v7; // xmm4
  __m128 v8; // xmm5
  __m128 v9; // xmm6
  __m128 v10; // xmm5
  __m128 v11; // xmm7
  __m128 v12; // xmm3
  __m128 v13; // xmm1
  __m128 v14; // xmm7
  __m128 v15; // xmm3
  __m128 v16; // xmm5
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  __m128 v19; // xmm3
  __m128 v20; // xmm5
  __m128 v21; // xmm6
  __m128 v22; // xmm3
  __m128 v23; // xmm7
  __m128 v24; // xmm7
  __m128 v25; // xmm5
  __m128 v26; // xmm0
  __m128 v27; // xmm6
  __m128 v28; // xmm7
  __m128 v29; // xmm4
  __m128 v30; // xmm0
  __m128 v31; // xmm7
  __m128 v32; // xmm5
  __m128 v33; // xmm6
  __m128 v34; // xmm1
  __m128 v35; // xmm1
  __m128 v36; // xmm0
  __m128 v37; // xmm5
  __m128 v38; // xmm6
  __m128 v39; // xmm3
  __m128 v40; // xmm3
  __m128 v41; // xmm5
  __m128 v42; // xmm7
  __m128 v43; // xmm3
  __m128 v44; // xmm6
  __m128 v45; // xmm4
  __m128 v46; // xmm0
  __m128 v47; // xmm4
  __m128 v48; // xmm3
  __m128 v49; // xmm0
  __m128 v50; // xmm4
  __m128 v51; // xmm6
  __m128 v52; // xmm2
  __m128 v53; // xmm0
  __m128 v55; // xmm5
  __m128 v56; // xmm5
  __m128 v57; // xmm1
  __m128 v58; // xmm4
  __m128 v59; // xmm6
  __m128 v60; // xmm5
  __m128 v61; // [esp+20h] [ebp-FCh]
  __m128 v62; // [esp+30h] [ebp-ECh]
  __m128 v63; // [esp+40h] [ebp-DCh]
  __m128 v64; // [esp+50h] [ebp-CCh]
  __m128 v65; // [esp+60h] [ebp-BCh]
  __m128 v66; // [esp+70h] [ebp-ACh]
  __m128 v67; // [esp+80h] [ebp-9Ch]
  __m128 v68; // [esp+90h] [ebp-8Ch]
  __m128 v69; // [esp+A0h] [ebp-7Ch]
  __m128 v70; // [esp+B0h] [ebp-6Ch]
  __m128 v71; // [esp+E0h] [ebp-3Ch]

  v3 = _mm_loadh_ps(a3 + 7);
  v4 = _mm_loadh_ps(a3 + 2);
  v5 = _mm_loadh_ps(a3 + 3);
  v6 = _mm_shuffle_ps(v5, v3, 136);
  v7 = _mm_shuffle_ps(v3, v5, 221);
  v8 = _mm_mul_ps(v7, v6);
  v9 = _mm_shuffle_ps(v8, v8, 177);
  v10 = _mm_shuffle_ps(v9, v9, 78);
  v11 = _mm_loadh_ps(a3 + 6);
  v12 = _mm_shuffle_ps(v11, v4, 221);
  v13 = _mm_shuffle_ps(v4, v11, 136);
  v14 = v12;
  v15 = _mm_mul_ps(v12, v10);
  v62 = _mm_mul_ps(v10, v13);
  v16 = _mm_mul_ps(v14, v6);
  v17 = _mm_shuffle_ps(v16, v16, 177);
  v63 = _mm_mul_ps(v9, v13);
  v18 = _mm_add_ps(_mm_mul_ps(v7, v17), _mm_sub_ps(v15, _mm_mul_ps(v14, v9)));
  v19 = v17;
  v20 = _mm_shuffle_ps(v17, v17, 78);
  v64 = _mm_mul_ps(v19, v13);
  v21 = _mm_sub_ps(v18, _mm_mul_ps(v7, v20));
  v22 = v14;
  v23 = _mm_mul_ps(_mm_shuffle_ps(v14, v14, 78), v7);
  v24 = _mm_shuffle_ps(v23, v23, 177);
  v65 = _mm_mul_ps(v20, v13);
  v25 = _mm_shuffle_ps(v6, v6, 78);
  v26 = _mm_add_ps(_mm_mul_ps(v25, v24), v21);
  v27 = v24;
  v28 = _mm_shuffle_ps(v24, v24, 78);
  v66 = v7;
  v29 = v25;
  v30 = _mm_sub_ps(v26, _mm_mul_ps(v25, v28));
  v31 = _mm_sub_ps(_mm_mul_ps(v28, v13), _mm_mul_ps(v27, v13));
  v32 = v13;
  v33 = _mm_mul_ps(v13, v30);
  v61 = v30;
  v34 = _mm_add_ps(_mm_shuffle_ps(v33, v33, 78), v33);
  v30.m128_i32[0] = v34.m128_i32[0];
  v35 = _mm_shuffle_ps(v34, v34, 177);
  v35.m128_f32[0] = v35.m128_f32[0] + v30.m128_f32[0];
  v36 = v32;
  v37 = _mm_mul_ps(v32, v22);
  v38 = _mm_shuffle_ps(v37, v37, 177);
  v67 = v29;
  v68 = v22;
  v39 = _mm_mul_ps(v66, v36);
  v40 = _mm_shuffle_ps(v39, v39, 177);
  v69 = _mm_shuffle_ps(v38, v38, 78);
  v70 = v38;
  v41 = _mm_add_ps(
          _mm_mul_ps(v68, v40),
          _mm_sub_ps(_mm_mul_ps(v66, v69), _mm_add_ps(_mm_mul_ps(v66, v38), _mm_shuffle_ps(v31, v31, 78))));
  v42 = v40;
  v43 = _mm_shuffle_ps(v40, v40, 78);
  v44 = _mm_sub_ps(v41, _mm_mul_ps(v68, v43));
  v45 = _mm_sub_ps(v62, v63);
  v46 = _mm_mul_ps(v36, v67);
  v47 = _mm_add_ps(_mm_sub_ps(_mm_shuffle_ps(v45, v45, 78), _mm_mul_ps(v42, v67)), _mm_mul_ps(v43, v67));
  v48 = _mm_shuffle_ps(v46, v46, 177);
  v49 = _mm_shuffle_ps(v48, v48, 78);
  v71 = v44;
  v50 = _mm_sub_ps(_mm_add_ps(v47, _mm_mul_ps(v66, v48)), _mm_mul_ps(v66, v49));
  v51 = _mm_sub_ps(v65, v64);
  v52 = _mm_add_ps(
          _mm_mul_ps(v68, v49),
          _mm_sub_ps(
            _mm_sub_ps(_mm_sub_ps(_mm_mul_ps(v70, v67), _mm_shuffle_ps(v51, v51, 78)), _mm_mul_ps(v67, v69)),
            _mm_mul_ps(v48, v68)));
  if ( v35.m128_f32[0] == 0.0 )
    return 0;
  if ( a2 )
    *a2 = v35.m128_i32[0];
  v53 = v35;
  v53.m128_f32[0] = 1.0 / v35.m128_f32[0];
  v55 = v53;
  v55.m128_f32[0] = (float)(v55.m128_f32[0] + v55.m128_f32[0])
                  - (float)(v35.m128_f32[0] * (float)(v53.m128_f32[0] * v53.m128_f32[0]));
  v56 = _mm_shuffle_ps(v55, v55, 0);
  v57 = _mm_mul_ps(v61, v56);
  _mm_storel_ps(a1, v57);
  _mm_storeh_ps(a1 + 1, v57);
  v58 = _mm_mul_ps(v50, v56);
  _mm_storel_ps(a1 + 2, v58);
  _mm_storeh_ps(a1 + 3, v58);
  v59 = _mm_mul_ps(v71, v56);
  _mm_storel_ps(a1 + 4, v59);
  _mm_storeh_ps(a1 + 5, v59);
  v60 = _mm_mul_ps(v56, v52);
  _mm_storel_ps(a1 + 6, v60);
  _mm_storeh_ps(a1 + 7, v60);
  return a1;
}

// sub_10027590 @ 0x10027590
void __stdcall sub_10027590(int a1, int a2, int a3)
{
  JUMPOUT(0x100275A1);
}

// sub_1002759E @ 0x1002759E
double *__stdcall sub_1002759E(double *a1, unsigned int *a2, const double *a3)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm0
  __m128 v9; // xmm5
  __m128 v10; // xmm7
  __m128 v11; // xmm4
  __m128 v12; // xmm7
  __m128 v13; // xmm6
  __m128 v14; // xmm5
  __m128 v15; // xmm2
  __m128 v16; // xmm1
  __m128 v17; // xmm5
  __m128 v18; // xmm0
  __m128 v19; // xmm6
  __m128 v20; // xmm0

  v5 = _mm_loadh_ps(a3 + 1);
  v6 = _mm_loadh_ps(a3 + 3);
  v7 = _mm_loadh_ps(a3 + 5);
  v8 = _mm_loadh_ps(a3 + 7);
  v9 = _mm_add_ps(
         _mm_add_ps(
           _mm_add_ps(
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[4], (__m128)a2[4], 0), v5),
             _mm_mul_ps(_mm_shuffle_ps((__m128)a2[5], (__m128)a2[5], 0), v6)),
           _mm_mul_ps(_mm_shuffle_ps((__m128)a2[6], (__m128)a2[6], 0), v7)),
         _mm_mul_ps(_mm_shuffle_ps((__m128)a2[7], (__m128)a2[7], 0), v8));
  v10 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)*a2, (__m128)*a2, 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[1], (__m128)a2[1], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[2], (__m128)a2[2], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[3], (__m128)a2[3], 0), v8));
  v11 = _mm_unpacklo_ps(v10, v9);
  v12 = _mm_unpackhi_ps(v10, v9);
  v13 = _mm_add_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[8], (__m128)a2[8], 0), v5),
              _mm_mul_ps(_mm_shuffle_ps((__m128)a2[9], (__m128)a2[9], 0), v6)),
            _mm_mul_ps(_mm_shuffle_ps((__m128)a2[10], (__m128)a2[10], 0), v7)),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[11], (__m128)a2[11], 0), v8));
  v14 = _mm_add_ps(
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[12], (__m128)a2[12], 0), v5),
          _mm_mul_ps(_mm_shuffle_ps((__m128)a2[13], (__m128)a2[13], 0), v6));
  v15 = _mm_mul_ps(_mm_shuffle_ps((__m128)a2[14], (__m128)a2[14], 0), v7);
  v16 = (__m128)a2[15];
  _mm_storel_ps(a1, v11);
  v17 = _mm_add_ps(_mm_add_ps(v14, v15), _mm_mul_ps(_mm_shuffle_ps(v16, v16, 0), v8));
  _mm_storeh_ps(a1 + 2, v11);
  _mm_storel_ps(a1 + 4, v12);
  _mm_storeh_ps(a1 + 6, v12);
  v18 = v13;
  v19 = _mm_unpacklo_ps(v13, v17);
  _mm_storel_ps(a1 + 1, v19);
  _mm_storeh_ps(a1 + 3, v19);
  v20 = _mm_unpackhi_ps(v18, v17);
  _mm_storel_ps(a1 + 5, v20);
  _mm_storeh_ps(a1 + 7, v20);
  return a1;
}

// sub_100276F0 @ 0x100276F0
void __stdcall sub_100276F0(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027701);
}

// sub_100276FE @ 0x100276FE
__m128 *__stdcall sub_100276FE(__m128 *a1, int a2, int a3, int a4)
{
  __m128 v5; // xmm2
  __m128 v6; // xmm2
  __m128 v7; // xmm1
  __m128 v8; // xmm3
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm4
  __m128 v12; // xmm2
  __m128 v13; // xmm3
  __m128 v14; // xmm1

  v5 = _mm_loadh_ps((const double *)(a3 + 8));
  v6 = _mm_shuffle_ps(v5, v5, 57);
  v7 = _mm_loadh_ps((const double *)(a2 + 8));
  v8 = _mm_loadh_ps((const double *)(a4 + 8));
  v9 = _mm_shuffle_ps(v8, v8, 78);
  v10 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 57), v6);
  v11 = _mm_mul_ps(v9, v6);
  v12 = _mm_mul_ps(v6, v8);
  v13 = _mm_shuffle_ps(v7, v7, 57);
  v14 = _mm_shuffle_ps(v13, v13, 57);
  *a1 = _mm_xor_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v13, _mm_sub_ps(_mm_shuffle_ps(v11, v11, 57), _mm_shuffle_ps(v12, v12, 78))),
              _mm_mul_ps(_mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10), v14)),
            _mm_mul_ps(_mm_shuffle_ps(v14, v14, 57), _mm_sub_ps(v11, _mm_shuffle_ps(v12, v12, 57)))),
          (__m128)xmmword_10055700);
  return a1;
}

// sub_100277A0 @ 0x100277A0
void __stdcall sub_100277A0(int a1, int a2)
{
  JUMPOUT(0x100277B1);
}

// sub_100277AE @ 0x100277AE
int __stdcall sub_100277AE(int a1, int a2)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm2
  __m128 v5; // xmm3
  __m128 v6; // xmm0
  int v7; // [esp-14h] [ebp-44h]
  int v8; // [esp-10h] [ebp-40h]
  int v9; // [esp-Ch] [ebp-3Ch]
  int v10; // [esp-8h] [ebp-38h]
  void *vars0; // [esp+30h] [ebp+0h]
  void *retaddr; // [esp+38h] [ebp+8h]

  vars0 = retaddr;
  v2 = sub_10034AF0(v7, v8, v9, v10);
  v3 = (__m128)xmmword_1005E1B0;
  v5 = v2;
  v6 = (__m128)xmmword_1005E1C0;
  *(_OWORD *)a1 = xmmword_1005E1D0;
  *(_DWORD *)(a1 + 16) = v6.m128_i32[0];
  _mm_storel_ps((double *)(a1 + 20), v5);
  _mm_storel_ps((double *)(a1 + 28), v6);
  *(_DWORD *)(a1 + 44) = v6.m128_i32[0];
  _mm_storel_ps((double *)(a1 + 36), _mm_xor_ps(_mm_shuffle_ps(v5, v5, 17), v3));
  *(__m128 *)(a1 + 48) = v6;
  return a1;
}

// sub_10027820 @ 0x10027820
void __stdcall sub_10027820(int a1, int a2)
{
  JUMPOUT(0x10027831);
}

// sub_1002782E @ 0x1002782E
int __stdcall sub_1002782E(int a1, int a2)
{
  __m128 v2; // xmm0
  __m128 v3; // xmm0
  __int128 v5; // xmm1
  int v6; // [esp-14h] [ebp-64h]
  int v7; // [esp-10h] [ebp-60h]
  int v8; // [esp-Ch] [ebp-5Ch]
  int v9; // [esp-8h] [ebp-58h]
  __m128 v10; // [esp+1Ch] [ebp-34h]
  __m128 v11; // [esp+2Ch] [ebp-24h]
  void *vars0; // [esp+50h] [ebp+0h]
  void *retaddr; // [esp+58h] [ebp+8h]

  vars0 = retaddr;
  v11 = (__m128)xmmword_1005E210;
  v10 = (__m128)xmmword_1005E200;
  v2 = sub_10034AF0(v6, v7, v8, v9);
  v3 = _mm_and_ps(_mm_shuffle_ps(v2, v2, 80), v11);
  *(__m128 *)a1 = _mm_xor_ps(v10, v3);
  *(_OWORD *)(a1 + 16) = xmmword_1005E1F0;
  v5 = xmmword_1005E1E0;
  *(__m128 *)(a1 + 32) = _mm_shuffle_ps(v3, v3, 70);
  *(_OWORD *)(a1 + 48) = v5;
  return a1;
}

// sub_100278B0 @ 0x100278B0
void __stdcall sub_100278B0(int a1)
{
  JUMPOUT(0x100278C1);
}

// sub_100278BE @ 0x100278BE
double __stdcall sub_100278BE(int a1)
{
  __m128 v1; // xmm7
  __m128 v2; // xmm1
  __m128 v3; // xmm2
  __m128 v4; // xmm0
  __m128 v5; // xmm2
  __m128 v6; // xmm3
  __m128 v7; // xmm4
  __m128 v8; // xmm0
  __m128 v9; // xmm4
  __m128 v10; // xmm0
  __m128 v11; // xmm2
  __m128 v12; // xmm0
  __m128 v13; // xmm1
  __m128 v14; // xmm1
  __m128 v15; // xmm0

  if ( (a1 & 0xF) != 0 )
  {
    v2 = _mm_loadh_ps((const double *)(a1 + 24));
    v1 = _mm_loadh_ps((const double *)(a1 + 8));
    v3 = _mm_loadh_ps((const double *)(a1 + 40));
    v4 = _mm_loadh_ps((const double *)(a1 + 56));
  }
  else
  {
    v1 = *(__m128 *)a1;
    v2 = *(__m128 *)(a1 + 16);
    v3 = *(__m128 *)(a1 + 32);
    v4 = *(__m128 *)(a1 + 48);
  }
  v5 = _mm_shuffle_ps(v3, v3, 57);
  v6 = _mm_mul_ps(v4, v5);
  v7 = _mm_shuffle_ps(v4, v4, 78);
  v8 = _mm_shuffle_ps(v7, v7, 57);
  v9 = _mm_mul_ps(v7, v5);
  v10 = _mm_mul_ps(v5, v8);
  v11 = _mm_sub_ps(_mm_shuffle_ps(v10, v10, 78), v10);
  v12 = _mm_shuffle_ps(v2, v2, 57);
  v13 = _mm_shuffle_ps(v12, v12, 57);
  v14 = _mm_mul_ps(
          _mm_add_ps(
            _mm_add_ps(
              _mm_mul_ps(v12, _mm_sub_ps(_mm_shuffle_ps(v9, v9, 57), _mm_shuffle_ps(v6, v6, 78))),
              _mm_mul_ps(v11, v13)),
            _mm_mul_ps(_mm_shuffle_ps(v13, v13, 57), _mm_sub_ps(v9, _mm_shuffle_ps(v6, v6, 57)))),
          v1);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  return (float)(v15.m128_f32[0] - _mm_shuffle_ps(v15, v15, 1).m128_f32[0]);
}

// sub_10027980 @ 0x10027980
void __stdcall sub_10027980(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027991);
}

// sub_1002798E @ 0x1002798E
__m128 *__stdcall sub_1002798E(__m128 *a1, const double *a2, const double *a3, const double *a4)
{
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  __m128 v8; // xmm4
  __m128 v9; // xmm5
  __m128 v10; // xmm3
  __m128 v11; // xmm5
  __m128 v12; // xmm1
  __m128 v13; // xmm3
  __m128 v14; // xmm5
  __m128 v15; // xmm0
  __m128 v16; // xmm5
  __m128 v17; // xmm3
  __m128 v18; // xmm0

  v5 = _mm_loadh_ps(a2);
  v6 = _mm_sub_ps(v5, _mm_loadh_ps(a4));
  v7 = _mm_shuffle_ps(v6, v6, 120);
  v8 = v5;
  v9 = _mm_sub_ps(v5, _mm_loadh_ps(a3));
  v10 = _mm_shuffle_ps(v9, v9, 99);
  v11 = _mm_mul_ps(_mm_shuffle_ps(v9, v9, 120), _mm_shuffle_ps(v6, v6, 99));
  v12 = (__m128)xmmword_10055730;
  v13 = _mm_sub_ps(_mm_mul_ps(v7, v10), v11);
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v14, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = v15;
  v15.m128_f32[0] = fsqrt(v15.m128_f32[0]);
  v12.m128_f32[0] = (float)(*(float *)&xmmword_10055730 * (float)(1.0 / v15.m128_f32[0]))
                  * (float)(*(float *)&xmmword_10055720
                          - (float)((float)(v16.m128_f32[0] * (float)(1.0 / v15.m128_f32[0]))
                                  * (float)(1.0 / v15.m128_f32[0])));
  v17 = _mm_mul_ps(v13, _mm_shuffle_ps(v12, v12, 0));
  *a1 = v17;
  v18 = _mm_mul_ps(_mm_shuffle_ps(v8, v8, 14), v17);
  a1->m128_i32[3] = COERCE_UNSIGNED_INT(
                      v18.m128_f32[0]
                    + (float)(_mm_movehl_ps(v16, v18).m128_f32[0] + _mm_shuffle_ps(v18, v18, 85).m128_f32[0]))
                  ^ xmmword_10055710;
  return a1;
}

// sub_10027A70 @ 0x10027A70
void __stdcall sub_10027A70(int a1, int a2, int a3)
{
  JUMPOUT(0x10027A81);
}

// sub_10027A7E @ 0x10027A7E
double *__stdcall sub_10027A7E(double *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm3
  __m128 v6; // xmm1
  __m128 v7; // xmm0
  char v8; // al
  __m128 v9; // xmm4
  float v10; // xmm3_4
  float v11; // xmm5_4
  double *result; // eax
  __m128 v13; // xmm4
  __m128 v14; // xmm0
  __m128 v15; // xmm0
  __m128 v16; // xmm0
  __m128 v17; // xmm5
  __m128 v18; // xmm6
  float v19; // xmm7_4
  __m128 v20; // xmm0
  __m128 v21; // xmm1
  __m128 v22; // xmm2
  __m128 v23; // xmm3

  v3 = *a3;
  v4 = _mm_and_ps((__m128)xmmword_10055780, *a3);
  v5 = _mm_mul_ps(v4, v4);
  v6 = _mm_add_ps(v5, _mm_movehl_ps((__m128)0LL, v5));
  v7 = _mm_shuffle_ps(v6, v6, 1);
  v7.m128_f32[0] = v7.m128_f32[0] + v6.m128_f32[0];
  if ( v7.m128_f32[0] != 0.0 )
  {
    v8 = byte_1005DBF0;
    if ( (byte_1005DBF0 & 1) != 0 )
    {
      v9 = (__m128)xmmword_1005DBD0;
    }
    else
    {
      v8 = byte_1005DBF0 | 1;
      v9 = (__m128)(unsigned int)dword_1005E220;
      byte_1005DBF0 |= 1u;
      xmmword_1005DBD0 = (unsigned int)dword_1005E220;
    }
    if ( (v8 & 2) != 0 )
    {
      v10 = *(float *)&xmmword_1005DBE0;
    }
    else
    {
      v10 = *(float *)&dword_1005E224;
      byte_1005DBF0 = v8 | 2;
      xmmword_1005DBE0 = (unsigned int)dword_1005E224;
    }
    v11 = 1.0 / fsqrt(v7.m128_f32[0]);
    v9.m128_f32[0] = (float)(v9.m128_f32[0] * v11) * (float)(v10 - (float)((float)(v7.m128_f32[0] * v11) * v11));
    v7 = _mm_mul_ps(v3, _mm_shuffle_ps(v9, v9, 0));
  }
  result = a1;
  v13 = _mm_xor_ps((__m128)xmmword_10055740, v7);
  v14 = _mm_mul_ps(v7, *a2);
  v15 = _mm_add_ps(v14, _mm_movehl_ps(v6, v14));
  v15.m128_f32[0] = v15.m128_f32[0] + _mm_shuffle_ps(v15, v15, 1).m128_f32[0];
  v16 = _mm_shuffle_ps(v15, v15, 0);
  v17 = _mm_and_ps((__m128)xmmword_10055760, v16);
  v18 = _mm_and_ps((__m128)xmmword_10055770, v16);
  v19 = v16.m128_f32[0];
  v20 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 85), *a2), _mm_and_ps((__m128)xmmword_10055750, v16));
  v21 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), *a2), v17);
  v23 = _mm_mul_ps(_mm_shuffle_ps(v13, v13, 0), *a2);
  v22 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 255), *a2), v18);
  v23.m128_f32[0] = v23.m128_f32[0] + v19;
  if ( ((unsigned __int8)a1 & 0xF) != 0 )
  {
    _mm_storel_ps(a1, v23);
    _mm_storeh_ps(a1 + 1, v23);
    _mm_storel_ps(a1 + 2, v20);
    _mm_storeh_ps(a1 + 3, v20);
    _mm_storel_ps(a1 + 4, v21);
    _mm_storeh_ps(a1 + 5, v21);
    _mm_storel_ps(a1 + 6, v22);
    _mm_storeh_ps(a1 + 7, v22);
  }
  else
  {
    *(__m128 *)a1 = v23;
    *((__m128 *)a1 + 1) = v20;
    *((__m128 *)a1 + 2) = v21;
    *((__m128 *)a1 + 3) = v22;
  }
  return result;
}

// sub_10027C00 @ 0x10027C00
void __stdcall sub_10027C00(int a1, int a2)
{
  JUMPOUT(0x10027C11);
}

// sub_10027C0E @ 0x10027C0E
__m128 *__stdcall sub_10027C0E(__m128 *a1, const double *a2)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm0
  __m128 v5; // xmm3
  __m128 v6; // xmm4
  __m128 v7; // xmm0
  float v8; // xmm5_4
  __m128 v9; // xmm1
  __m128 v10; // xmm4
  __m128 v11; // xmm0
  __m128 v12; // xmm1
  __m128 v13; // xmm2
  __m128 v14; // xmm0
  __m128 v15; // xmm3
  __m128 v16; // xmm2
  __m128 v17; // xmm4

  v3 = _mm_loadl_ps(a2);
  v4 = _mm_and_ps((__m128)xmmword_10055800, v3);
  v5 = (__m128)(unsigned int)dword_100557F0;
  v6 = _mm_mul_ps(v4, v4);
  v7 = _mm_add_ps(v6, _mm_movehl_ps(v6, v6));
  v8 = v7.m128_f32[0] + _mm_shuffle_ps(v7, v7, 1).m128_f32[0];
  v7.m128_f32[0] = 1.0 / fsqrt(v8);
  v5.m128_f32[0] = (float)(*(float *)&dword_100557F0 * v7.m128_f32[0])
                 * (float)(*(float *)&dword_100557E0 - (float)((float)(v8 * v7.m128_f32[0]) * v7.m128_f32[0]));
  v9 = _mm_mul_ps(v3, _mm_shuffle_ps(v5, v5, 0));
  v10 = _mm_mul_ps((__m128)xmmword_100557D0, v9);
  v11 = v9;
  v12 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v9, v9, 0), v10), (__m128)xmmword_100557C0);
  v13 = v11;
  v14 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v11, v11, 255), v10), (__m128)xmmword_10055790);
  v15 = v13;
  v16 = _mm_add_ps(_mm_mul_ps(_mm_shuffle_ps(v13, v13, 170), v10), (__m128)xmmword_100557A0);
  v17 = _mm_add_ps(_mm_mul_ps(v10, _mm_shuffle_ps(v15, v15, 85)), (__m128)xmmword_100557B0);
  *a1 = v12;
  a1[1] = v17;
  a1[2] = v16;
  a1[3] = v14;
  return a1;
}

// sub_10027CE0 @ 0x10027CE0
float *__stdcall sub_10027CE0(float *a1, float *a2)
{
  float *result; // eax
  double v3; // st7
  float v4; // edi
  float v5; // esi
  int v6; // ebp
  double v7; // st7
  int v8; // ecx
  int v9; // ebx
  int v10; // ebp
  float *v11; // esi
  long double v12; // st6
  long double v13; // st7
  float *v14; // ecx
  long double v15; // st6
  long double v16; // st7
  _DWORD v17[7]; // [esp+0h] [ebp-1Ch]

  result = a1;
  v3 = *a2 + a2[5] + a2[10];
  v4 = *a2;
  v5 = a2[5];
  v6 = *((_DWORD *)a2 + 10);
  if ( flt_1005E27C < v3 )
  {
    v15 = sqrt(v3 + flt_1005E280) * flt_1005E284;
    v16 = flt_1005E288 / v15;
    a1[3] = v15;
    *a1 = (a2[6] - a2[9]) * v16;
    a1[1] = (a2[8] - a2[2]) * v16;
    a1[2] = v16 * (a2[1] - a2[4]);
  }
  else
  {
    v7 = a2[10];
    *(float *)v17 = *a2;
    *(float *)&v17[1] = v5;
    v17[2] = v6;
    v8 = 2;
    if ( *(float *)&v17[v5 > (double)v4] >= v7 )
      v8 = v5 > (double)v4;
    v9 = dword_1005E270[v8];
    v10 = dword_1005E270[v9];
    v11 = &a2[v8];
    v12 = sqrt(flt_1005E290 + *(float *)&v17[v8] - *(float *)&v17[v9] - *(float *)&v17[v10]) * flt_1005E294;
    v13 = flt_1005E298 / v12;
    a1[v8] = v12;
    v14 = &a2[4 * v8];
    a1[v9] = (v14[v9] + v11[4 * v9]) * v13;
    a1[v10] = (v11[4 * v10] + v14[v10]) * v13;
    a1[3] = v13 * (a2[4 * v9 + v10] - a2[4 * v10 + v9]);
  }
  return result;
}

// sub_10027E00 @ 0x10027E00
void __stdcall sub_10027E00(int a1, int a2, int a3, int a4)
{
  JUMPOUT(0x10027E11);
}

// sub_10027E0E @ 0x10027E0E
__m128 *__stdcall sub_10027E0E(__m128 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  __m128 v4; // xmm0
  __m128 v5; // xmm1
  __m128 v6; // xmm3
  __m128 v7; // xmm2
  __m128 v8; // xmm3
  __m128 v10; // [esp+10h] [ebp-4Ch] BYREF
  __m128 v11[3]; // [esp+20h] [ebp-3Ch] BYREF

  v10 = _mm_mul_ps(
          _mm_shuffle_ps(
            _mm_unpacklo_ps((__m128)a3, (__m128)a4),
            _mm_unpacklo_ps((__m128)(unsigned int)dword_1005E2C0, (__m128)a2),
            17),
          (__m128)xmmword_1005E2B0);
  sub_10034BE0(&v10, &v10, v11);
  v4 = _mm_shuffle_ps(v10, v11[0], 0);
  v5 = _mm_shuffle_ps(v4, v4, 138);
  v6 = _mm_shuffle_ps(v10, v11[0], 153);
  v7 = _mm_shuffle_ps(v6, v6, 247);
  v8 = _mm_shuffle_ps(v6, v6, 168);
  v10 = _mm_add_ps(
          _mm_mul_ps(_mm_mul_ps(v5, v7), v8),
          _mm_xor_ps(
            _mm_mul_ps(_mm_mul_ps(_mm_shuffle_ps(v5, v5, 138), _mm_shuffle_ps(v7, v7, 81)), _mm_shuffle_ps(v8, v8, 1)),
            (__m128)xmmword_1005E2A0));
  *a1 = v10;
  return a1;
}

// sub_10027ED0 @ 0x10027ED0
__m64 *__stdcall sub_10027ED0(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm3
  __m64 v4; // mm1
  __m64 v6; // mm6
  __m64 v7; // mm7
  unsigned __int64 v8; // mm4
  __m64 v9; // mm6
  __m64 v10; // mm5
  __m64 v11; // mm3

  v3 = a3[1];
  v4 = a2[1];
  v6 = _m_punpckldq(_m_punpckhdq((__m64)a3->m64_u64, (__m64)a3->m64_u64), (__m64)a3->m64_u64);
  v7 = _m_punpckldq(_m_punpckhdq(v3, v3), v3);
  v8 = (unsigned __int64)_m_pfacc(
                           _m_pfsub(_m_pfmul(v6, v4), _m_pfmul(_m_pxor(v7, (__m64)0x80000000LL), (__m64)a2->m64_u64)),
                           _m_pfadd(
                             _m_pxor(_m_pfmul((__m64)a3->m64_u64, v4), (__m64)0x80000000LL),
                             _m_pfmul(v3, (__m64)a2->m64_u64)));
  v9 = _m_pfmul(_m_pxor(v6, (__m64)0x80000000LL), (__m64)a2->m64_u64);
  v10 = _m_pxor(v3, (__m64)0x80000000LL);
  v11 = _m_pfmul((__m64)a3->m64_u64, (__m64)a2->m64_u64);
  a1->m64_u64 = v8;
  a1[1].m64_u64 = (unsigned __int64)_m_pfacc(_m_pfadd(v9, _m_pfmul(v7, v4)), _m_pfsub(_m_pfmul(v10, v4), v11));
  _m_femms();
  return a1;
}

// sub_10027F69 @ 0x10027F69
__m64 *__stdcall sub_10027F69(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v5 = _m_pfacc(v3, v3);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfcmpgt(v5, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v5, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v8);
  _m_femms();
  return a1;
}

// sub_10027FC6 @ 0x10027FC6
int __stdcall sub_10027FC6(__m64 *a1, int a2, _DWORD *a3)
{
  __m64 m64_u64; // mm2
  __m64 v4; // mm0
  __m64 v5; // mm5
  __m64 v6; // mm5
  __m64 v7; // mm1
  int result; // eax
  __m64 v9; // mm4
  __m64 v10; // mm1
  __m64 v11; // mm1

  m64_u64 = (__m64)a1->m64_u64;
  v4 = a1[1];
  v5 = _m_pfadd(_m_pfmul(m64_u64, m64_u64), _m_pfmul(v4, v4));
  v6 = _m_pfacc(v5, v5);
  v7 = _m_pfrsqrt(v6);
  result = _mm_cvtsi64_si32(_m_pfcmpge((__m64)0x80000000800000LL, v6));
  v9 = v7;
  if ( result )
  {
    if ( a2 )
    {
      *(_QWORD *)(a2 + 4) = 0;
      *(_DWORD *)a2 = _mm_cvtsi64_si32((__m64)0xBF8000003F800000uLL);
    }
    if ( a3 )
      *a3 = _mm_cvtsi64_si32(0);
  }
  else
  {
    v10 = _m_pfmul(v7, v7);
    if ( a2 )
    {
      v11 = _m_pfrcpit2(_m_pfrsqit1(v10, v6), v9);
      *(__m64 *)a2 = _m_pfmul(m64_u64, v11);
      *(_DWORD *)(a2 + 8) = _mm_cvtsi64_si32(_m_pfmul(v11, v4));
    }
    if ( a3 )
    {
      result = sub_10034F00(a3, a2);
      *a3 = _mm_cvtsi64_si32(_m_pfmul(_m_punpckhdq(v4, v4), (__m64)0x4000000040000000LL));
    }
  }
  _m_femms();
  return result;
}

// sub_10028079 @ 0x10028079
__m64 *__stdcall sub_10028079(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm4
  __m64 v3; // mm5
  __m64 v4; // mm3
  __m64 v5; // mm0
  __m64 v6; // mm1
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm3
  __m64 v12; // mm6
  int v13; // ecx
  __m64 v14; // mm0
  __m64 v15; // mm7
  __m64 v16; // mm2
  __m64 v17; // mm0
  __m64 v18; // mm4
  __m64 *result; // eax
  __m64 v20; // mm1
  __m64 v21; // mm1
  __m64 v22; // mm0
  __m64 v23; // mm1
  __m64 v24; // mm4
  __m64 v25; // mm1
  __m64 v26; // mm2
  __m64 v27; // mm0
  __m64 v28; // mm2
  __m64 v29; // mm4
  __m64 v30; // mm1
  __m64 v31; // mm3
  __m64 v32; // mm0
  __m64 v33; // mm3
  __m64 v34; // mm2
  __m64 v35; // mm3

  v2 = _mm_cvtsi32_si64(a2[2].m64_u32[1]);
  v3 = _mm_cvtsi32_si64(a2[5].m64_u32[0]);
  v4 = _m_pfsubr((__m64)a2->m64_u64, v3);
  v5 = _m_pfadd(_m_pfadd((__m64)a2->m64_u64, v2), v3);
  v6 = _m_pfsub(_m_pfsub((__m64)a2->m64_u64, v2), v3);
  v7 = _m_pfsub(_m_pfsubr((__m64)a2->m64_u64, v2), v3);
  v8 = a2[4];
  v9 = _m_pfsub(v4, v2);
  v10 = _m_punpckldq(v5, v7);
  v11 = _m_punpckldq(v9, v9);
  v12 = _m_packssdw(_m_pfcmpge(_m_punpckldq(0, v6), v10), _m_pfcmpge(_m_punpckldq(v7, v6), v11));
  v13 = _mm_cvtsi64_si32(_m_packsswb(v12, v12));
  if ( (v13 & 1) != 0 )
  {
    if ( (v13 & 0xFF00FF00) == 0xFF00FF00 )
    {
      v21 = _m_pfadd(v6, (__m64)0xBF8000003F800000uLL);
      v22 = _m_pfrsqrt(v21);
      v23 = _m_punpckldq(v21, v21);
      v24 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v22, v22), v23), v22), (__m64)0x3F0000003F000000LL);
      v25 = _m_punpckldq(
              _m_pfmul(v23, v24),
              _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a2[2].m64_u32[0]), _m_punpckhdq(v7, v7)), v24));
      a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_pxor(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8)),
                                              (__m64)0x8000000000000000uLL)),
                                          v24);
      a1->m64_u64 = (unsigned __int64)v25;
      _m_femms();
      return a1;
    }
    else
    {
      result = a1;
      if ( (v13 & 0x10000) != 0 )
      {
        v26 = _m_pfadd(v7, (__m64)0xBF8000003F800000uLL);
        v27 = _m_pfrsqrt(v26);
        v28 = _m_punpckldq(v26, v26);
        v29 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v27, v27), v28), v27), (__m64)0x3F0000003F000000LL);
        v30 = _m_punpckldq(
                _m_pfmul(_m_pfadd(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v29),
                _m_pfmul(v28, v29));
        a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                            _m_pfadd(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                              _m_pxor(
                                                _m_punpckldq(_m_punpckhdq(v8, v8), (__m64)a2[1].m64_u32[0]),
                                                (__m64)0x8000000000000000uLL)),
                                            v29);
        a1->m64_u64 = (unsigned __int64)v30;
      }
      else
      {
        v31 = _m_pfadd(v11, (__m64)0xBF8000003F800000uLL);
        v32 = _m_pfrsqrt(v31);
        v33 = _m_punpckldq(v31, v31);
        v34 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v32, v32), v33), v32), (__m64)0x3F0000003F000000LL);
        v35 = _m_punpckldq(
                _m_pfmul(v33, v34),
                _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v34));
        a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8))),
                                          v34);
        a1[1].m64_u64 = (unsigned __int64)v35;
      }
      _m_femms();
    }
  }
  else
  {
    v14 = _m_pfadd(v10, (__m64)0xBF8000003F800000uLL);
    v15 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
    v16 = _m_pfrsqrt(v14);
    v17 = _m_punpckldq(v14, v14);
    v18 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v16, v16), v17), v16), (__m64)0x3F0000003F000000LL);
    v20 = _m_punpckldq(
            _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v18),
            _m_pfmul(v17, v18));
    a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                      _m_pfsub(
                                        _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                        _m_punpckhdq(v8, _m_punpckldq(v15, v15))),
                                      v18);
    a1[1].m64_u64 = (unsigned __int64)v20;
    _m_femms();
    return a1;
  }
  return result;
}

// sub_10028295 @ 0x10028295
__m64 *__stdcall sub_10028295(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm4
  __m64 v3; // mm5
  __m64 v4; // mm3
  __m64 v5; // mm0
  __m64 v6; // mm1
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm3
  char v12; // cl
  __m64 v13; // mm0
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm0
  __m64 v17; // mm4
  __m64 *result; // eax
  __m64 v19; // mm1
  __m64 v20; // mm1
  __m64 v21; // mm0
  __m64 v22; // mm1
  __m64 v23; // mm4
  __m64 v24; // mm1
  __m64 v25; // mm2
  __m64 v26; // mm0
  __m64 v27; // mm2
  __m64 v28; // mm4
  __m64 v29; // mm1
  __m64 v30; // mm3
  __m64 v31; // mm0
  __m64 v32; // mm3
  __m64 v33; // mm2
  __m64 v34; // mm3

  v2 = _mm_cvtsi32_si64(a2[2].m64_u32[1]);
  v3 = _mm_cvtsi32_si64(a2[5].m64_u32[0]);
  v4 = _m_pfsubr((__m64)a2->m64_u64, v3);
  v5 = _m_pfadd(_m_pfadd((__m64)a2->m64_u64, v2), v3);
  v6 = _m_pfsub(_m_pfsub((__m64)a2->m64_u64, v2), v3);
  v7 = _m_pfsub(_m_pfsubr((__m64)a2->m64_u64, v2), v3);
  v8 = a2[4];
  v9 = _m_pfsub(v4, v2);
  v10 = _m_punpckldq(v5, v7);
  v11 = _m_punpckldq(v9, v9);
  v12 = _m_pmovmskb(_m_packssdw(_m_pfcmpge(_m_punpckldq(0, v6), v10), _m_pfcmpge(_m_punpckldq(v7, v6), v11)));
  if ( (v12 & 1) != 0 )
  {
    if ( (v12 & 0xCC) == 0xCC )
    {
      v20 = _m_pfadd(v6, (__m64)0xBF8000003F800000uLL);
      v21 = _m_pfrsqrt(v20);
      v22 = _m_punpckldq(v20, v20);
      v23 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v21, v21), v22), v21), (__m64)0x3F0000003F000000LL);
      v24 = _m_punpckldq(
              _m_pfmul(v22, v23),
              _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a2[2].m64_u32[0]), _m_punpckhdq(v7, v7)), v23));
      a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_pxor(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8)),
                                              (__m64)0x8000000000000000uLL)),
                                          v23);
      a1->m64_u64 = (unsigned __int64)v24;
      _m_femms();
      return a1;
    }
    else
    {
      result = a1;
      if ( (v12 & 0x10) != 0 )
      {
        v25 = _m_pfadd(v7, (__m64)0xBF8000003F800000uLL);
        v26 = _m_pfrsqrt(v25);
        v27 = _m_punpckldq(v25, v25);
        v28 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v26, v26), v27), v26), (__m64)0x3F0000003F000000LL);
        v29 = _m_punpckldq(
                _m_pfmul(_m_pfadd(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v28),
                _m_pfmul(v27, v28));
        a1[1].m64_u64 = (unsigned __int64)_m_pfmul(
                                            _m_pfadd(
                                              _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                              _m_pxor(
                                                _m_punpckldq(_m_punpckhdq(v8, v8), (__m64)a2[1].m64_u32[0]),
                                                (__m64)0x8000000000000000uLL)),
                                            v28);
        a1->m64_u64 = (unsigned __int64)v29;
      }
      else
      {
        v30 = _m_pfadd(v11, (__m64)0xBF8000003F800000uLL);
        v31 = _m_pfrsqrt(v30);
        v32 = _m_punpckldq(v30, v30);
        v33 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v31, v31), v32), v31), (__m64)0x3F0000003F000000LL);
        v34 = _m_punpckldq(
                _m_pfmul(v32, v33),
                _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v33));
        a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                          _m_pfadd(
                                            _m_punpckldq(v8, (__m64)a2[3].m64_u32[0]),
                                            _m_punpckldq(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _m_punpckhdq(v8, v8))),
                                          v33);
        a1[1].m64_u64 = (unsigned __int64)v34;
      }
      _m_femms();
    }
  }
  else
  {
    v13 = _m_pfadd(v10, (__m64)0xBF8000003F800000uLL);
    v14 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
    v15 = _m_pfrsqrt(v13);
    v16 = _m_punpckldq(v13, v13);
    v17 = _m_pfmul(_m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v15, v15), v16), v15), (__m64)0x3F0000003F000000LL);
    v19 = _m_punpckldq(
            _m_pfmul(_m_pfsub(_m_punpckhdq(v6, v6), _mm_cvtsi32_si64(a2[2].m64_u32[0])), v17),
            _m_pfmul(v16, v17));
    a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                      _m_pfsub(
                                        _m_punpckldq(_mm_cvtsi32_si64(a2[3].m64_u32[0]), v8),
                                        _m_punpckhdq(v8, _m_punpckldq(v14, v14))),
                                      v17);
    a1[1].m64_u64 = (unsigned __int64)v19;
    _m_femms();
    return a1;
  }
  return result;
}

// sub_100284AA @ 0x100284AA
__m64 *__userpurge sub_100284AA@<eax>(__m64 *a1, __m64 a2, __m64 a3)
{
  __m64 v3; // mm1
  __m64 v5; // mm6
  __m64 v6; // mm2
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v9; // [esp+10h] [ebp-10h]

  _m_femms();
  v9 = _m_pfmul((__m64)0x3F0000003F000000LL, a2);
  sub_100354E0();
  sub_100354E0();
  sub_100354E0();
  v3 = _m_pfmul((__m64)0x3F0000003F000000LL, a3);
  v5 = _m_punpckhdq(v9, v9);
  v6 = _m_punpckldq(v5, v5);
  v7 = _m_punpckhdq(v5, v5);
  v8 = _m_punpckldq(_m_punpckhdq(v3, v3), v3);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(
                                      _m_pfmul(_m_pxor(_m_punpckldq(v9, v9), (__m64)0x8000000000000000uLL), v7),
                                      v3),
                                    _m_pfmul(_m_pfmul(_m_punpckhdq(v9, v9), v6), v8));
  a1[1].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_pfmul(_m_punpckldq(v9, v9), v6), v8),
                                      _m_pfmul(
                                        _m_pfmul(
                                          _m_pxor(_m_punpckhdq(v9, v9), _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u)),
                                          v7),
                                        v3));
  _m_femms();
  return a1;
}

// sub_1002856F @ 0x1002856F
__m64 *__stdcall sub_1002856F(__m64 *a1, int a2, unsigned int a3)
{
  __m64 v3; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm2
  __m64 v7; // [esp+0h] [ebp-18h] BYREF
  unsigned int v8; // [esp+8h] [ebp-10h]

  _m_femms();
  sub_1002D2C2((int)&v7, a2);
  v3 = _m_pfmul(_mm_cvtsi32_si64(a3), (__m64)0x3F0000003F000000LL);
  sub_100354E0();
  v5 = _m_punpckhdq(v3, v3);
  v6 = _m_punpckldq(_m_pfmul(_mm_cvtsi32_si64(v8), v5), v3);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(v7, v5);
  a1[1].m64_u64 = (unsigned __int64)v6;
  _m_femms();
  return a1;
}

// sub_100285DB @ 0x100285DB
__m64 *__stdcall sub_100285DB(__m64 *a1, __m64 *a2, __m64 *a3, unsigned int a4)
{
  __m64 v4; // mm1
  __m64 v5; // mm4
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm7
  __m64 v9; // mm1
  __m64 v10; // mm3
  __m64 v11; // mm4
  __m64 v12; // mm0
  __m64 v13; // mm1
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm6
  __m64 v18; // mm0
  __m64 v19; // mm5
  unsigned int v20; // [esp+28h] [ebp+10h]

  _m_femms();
  v4 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64), _m_pfmul(a2[1], a3[1]));
  v5 = _mm_cvtsi32_si64(a4);
  v6 = _m_pfsub(_mm_cvtsi32_si64(0x3F800000u), v5);
  v7 = _m_pfacc(v4, v4);
  v8 = _m_pand(_m_pfcmpge(0, v7), (__m64)0x8000000080000000uLL);
  v9 = _m_pxor(v7, v8);
  v10 = _m_pfsubr(_m_pfmul(v9, v9), (__m64)0x3F8000003F800000LL);
  if ( _mm_cvtsi64_si32(_m_pfcmpge((__m64)0x3F7FFF583F7FFF58LL, v9)) )
  {
    v11 = _m_pfrsqrt(v10);
    sub_10034E00();
    sub_10035600();
    v20 = _mm_cvtsi64_si32(_m_pfmul(v9, _mm_cvtsi32_si64(a4)));
    v12 = _m_pfmul(_mm_cvtsi32_si64(_mm_cvtsi64_si32(v9)), _mm_cvtsi32_si64(_mm_cvtsi64_si32(v6)));
    sub_10035600();
    v13 = _mm_cvtsi32_si64(_mm_cvtsi64_si32(_m_pfrcpit2(_m_pfrsqit1(v10, _m_pfmul(v11, v11)), v11)));
    v8 = _mm_cvtsi32_si64(_mm_cvtsi64_si32(v8));
    v6 = _m_pfmul(v12, v13);
    v5 = _m_pfmul(_mm_cvtsi32_si64(v20), v13);
  }
  v15 = _m_pxor(v5, v8);
  v16 = _m_punpckldq(v6, v6);
  v17 = _m_punpckldq(v15, v15);
  v18 = _m_pfmul(v16, (__m64)a2->m64_u64);
  v19 = _m_pfadd(_m_pfmul(v16, a2[1]), _m_pfmul(v17, a3[1]));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(v18, _m_pfmul(v17, (__m64)a3->m64_u64));
  a1[1].m64_u64 = (unsigned __int64)v19;
  _m_femms();
  return a1;
}

// sub_10028712 @ 0x10028712
__m64 *__stdcall sub_10028712(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v9[2]; // [esp+Ch] [ebp-24h] BYREF
  __m64 v10[2]; // [esp+1Ch] [ebp-14h] BYREF
  unsigned int v11; // [esp+44h] [ebp+14h]

  _m_femms();
  v11 = _mm_cvtsi64_si32(_m_pfadd(_mm_cvtsi32_si64(a5), _mm_cvtsi32_si64(a6)));
  sub_100285DB(v9, a2, a3, v11);
  sub_100285DB(v10, a2, a4, v11);
  v6 = _mm_cvtsi32_si64(v11);
  v7 = _m_pfrcp(v6);
  sub_100285DB(a1, v9, v10, _mm_cvtsi64_si32(_m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v6, v7), v7), _mm_cvtsi32_si64(a6))));
  _m_femms();
  return a1;
}

// sub_1002879F @ 0x1002879F
__m64 *__stdcall sub_1002879F(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 *result; // eax
  __m64 v8[2]; // [esp+10h] [ebp-20h] BYREF
  __m64 v9[2]; // [esp+20h] [ebp-10h] BYREF

  sub_100285DB(v8, a2, a5, a6);
  sub_100285DB(v9, a3, a4, a6);
  v6 = _mm_cvtsi32_si64(a6);
  result = sub_100285DB(
             a1,
             v8,
             v9,
             _mm_cvtsi64_si32(_m_pfmul(_m_pfsub(v6, _m_pfmul(v6, v6)), (__m64)0x4000000040000000LL)));
  _m_femms();
  return result;
}

// sub_10028831 @ 0x10028831
__m64 *__stdcall sub_10028831(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v6 = _m_pfrcp(v4);
  v7 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrcpit1(v4, v6), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(_m_pxor((__m64)a2->m64_u64, (__m64)0x8000000080000000uLL), v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(_m_pxor(v2, (__m64)0x80000000LL), v7), v8);
  _m_femms();
  return a1;
}

// sub_10028895 @ 0x10028895
__m64 *__stdcall sub_10028895(__m64 *a1, __m64 *a2)
{
  __m64 *result; // eax
  __m64 m64_u64; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm0
  __m64 v6; // mm3
  __m64 v7; // mm4
  __m64 v8; // mm3
  unsigned int v9; // [esp+0h] [ebp-Ch]

  _m_femms();
  result = a1;
  m64_u64 = (__m64)a2->m64_u64;
  v4 = a2[1];
  v5 = _m_punpckhdq(v4, v4);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v5, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, a2);
    v9 = _mm_cvtsi64_si32(v5);
    sub_10035600();
    result = a1;
    m64_u64 = (__m64)a2->m64_u64;
    v4 = a2[1];
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v5, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v6 = _mm_cvtsi32_si64(v9);
      v7 = _m_pfrcp(v5);
      v8 = _m_pfmul(_m_punpckldq(v6, v6), _m_pfrcpit2(_m_pfrcpit1(v5, v7), v7));
      m64_u64 = _m_pfmul(m64_u64, v8);
      v4 = _m_pfmul(v4, v8);
    }
  }
  result->m64_u64 = (unsigned __int64)m64_u64;
  result[1].m64_u64 = (unsigned __int64)_m_pand(v4, (__m64)0xFFFFFFFFLL);
  _m_femms();
  return result;
}

// sub_1002893C @ 0x1002893C
__m64 *__userpurge sub_1002893C@<eax>(unsigned int a1@<esi>, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm2
  __m64 v7; // mm1
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 *result; // eax
  char v11; // cl
  __m64 m64_u64; // mm2
  __m64 v13; // mm0
  __m64 v14; // mm1
  __m64 v15; // mm3
  __m64 v16; // mm1
  __m64 v17; // [esp+0h] [ebp-Ch]

  v3 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v4 = _m_pfadd(_m_pfmul((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_pfmul(v3, v3));
  v5 = _m_pfacc(v4, v4);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v6, v6), v5), v6);
  v17.m64_u64 = __PAIR64__(a1, _mm_cvtsi64_si32(v7));
  sub_100354E0();
  v8 = _m_pfmul(v5, v7);
  v9 = _m_pfcmpge(_m_pand(v8, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  result = a2;
  v11 = _mm_cvtsi64_si32(_m_punpckhdq(v9, v9));
  m64_u64 = (__m64)a3->m64_u64;
  v13 = v8;
  v14 = _m_pfmul(_m_punpckhdq(v8, v8), v17);
  v15 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  if ( (v11 & 1) != 0 )
  {
    v16 = _m_punpckldq(v14, v14);
    v15 = _m_pfmul(v15, v16);
    m64_u64 = _m_pfmul(m64_u64, v16);
  }
  a2->m64_u64 = (unsigned __int64)m64_u64;
  a2[1].m64_u64 = (unsigned __int64)_m_punpckldq(v15, v13);
  _m_femms();
  return result;
}

// sub_100289E1 @ 0x100289E1
__m64 *__userpurge sub_100289E1@<eax>(
        unsigned int a1@<esi>,
        __m64 *a2,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v11; // mm3
  __m64 *v12; // edx
  __m64 v13; // mm0
  __m64 v14; // mm2
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm1
  __m64 v18; // mm3
  __m64 v19; // mm2
  int v20; // eax
  __m64 v21; // mm4
  __m64 v22; // mm6
  __m64 v23; // mm7
  __m64 v24; // mm3
  __m64 v25; // mm5
  __m64 v26; // mm6
  __m64 v27; // mm3
  __m64 v28; // mm0
  __m64 v29; // mm0
  __m64 v30; // mm4
  __m64 v31; // mm5
  __m64 v32; // mm0
  __m64 v33; // mm6
  __m64 v34; // mm7
  __m64 v35; // mm6
  __m64 v36; // mm7
  __m64 v37; // mm1
  __m64 v38; // mm2
  __m64 v39; // mm0
  __m64 v40; // mm3
  __m64 v41; // mm4
  __m64 v42; // mm3
  __m64 v43; // mm1
  __m64 v44; // mm2
  __m64 v45; // mm0
  __m64 v46; // mm3
  __m64 v47; // mm4
  __m64 v48; // mm3
  __m64 v49; // mm1
  __m64 v50; // mm0
  __m64 v51; // mm0
  __m64 v52; // mm2
  __m64 v53; // mm1
  __int32 v54; // edx
  __m64 v55; // mm1
  __m64 v56; // mm0
  char v57; // cl
  __m64 v58; // mm2
  __m64 v59; // mm0
  __m64 v60; // mm1
  __m64 v61; // mm3
  __m64 v62; // mm1
  __m64 v63; // mm6
  __m64 v64; // mm7
  __m64 v65; // mm0
  __m64 v66; // mm0
  __m64 v67; // mm4
  __m64 v68; // mm5
  __m64 v69; // mm0
  __m64 v70; // mm6
  __m64 v71; // mm7
  __m64 v72; // mm6
  __m64 v73; // mm7
  __m64 v74; // mm1
  __m64 v75; // mm2
  __m64 v76; // mm0
  __m64 v77; // mm3
  __m64 v78; // mm4
  __m64 v79; // mm3
  __m64 v80; // mm1
  __m64 v81; // mm2
  __m64 v82; // mm0
  __m64 v83; // mm3
  __m64 v84; // mm4
  __m64 v85; // mm3
  __m64 v86; // mm1
  __m64 v87; // mm0
  __m64 v88; // mm0
  __m64 v89; // mm2
  __m64 v90; // mm1
  __m64 v91; // mm1
  __m64 v92; // mm0
  char v93; // cl
  __m64 v94; // mm2
  __m64 v95; // mm0
  __m64 v96; // mm1
  __m64 v97; // mm3
  __m64 v98; // mm1
  __m64 v99; // mm6
  __m64 v100; // mm7
  unsigned int v102; // [esp+0h] [ebp-ACh]
  unsigned int v103; // [esp+0h] [ebp-ACh]
  __m64 v104; // [esp+0h] [ebp-ACh]
  unsigned int v105; // [esp+0h] [ebp-ACh]
  unsigned int v106; // [esp+0h] [ebp-ACh]
  __m64 v107; // [esp+0h] [ebp-ACh]
  __m64 m64_u64; // [esp+Ch] [ebp-A0h]
  __m64 v109; // [esp+14h] [ebp-98h]
  __m64 v110; // [esp+1Ch] [ebp-90h]
  __m64 v111; // [esp+24h] [ebp-88h]
  __m64 v112; // [esp+2Ch] [ebp-80h]
  __m64 v113; // [esp+34h] [ebp-78h]
  __m64 v114; // [esp+3Ch] [ebp-70h]
  __m64 v115; // [esp+44h] [ebp-68h]
  __m64 v116; // [esp+4Ch] [ebp-60h]
  __m64 v117; // [esp+4Ch] [ebp-60h]
  __m64 v118; // [esp+54h] [ebp-58h]
  __m64 v119; // [esp+54h] [ebp-58h]
  __m64 v120; // [esp+5Ch] [ebp-50h]
  __m64 v121; // [esp+5Ch] [ebp-50h]
  __m64 v122; // [esp+64h] [ebp-48h]
  __m64 v123; // [esp+64h] [ebp-48h]
  __m64 v124; // [esp+84h] [ebp-28h]
  __m64 v125; // [esp+84h] [ebp-28h]
  __m64 v126; // [esp+8Ch] [ebp-20h]
  __m64 v127; // [esp+8Ch] [ebp-20h]
  __m64 v128; // [esp+8Ch] [ebp-20h]
  __m64 v129; // [esp+8Ch] [ebp-20h]
  __m64 v130; // [esp+94h] [ebp-18h]
  unsigned int v131; // [esp+94h] [ebp-18h]
  __m64 v132; // [esp+94h] [ebp-18h]
  unsigned int v133; // [esp+94h] [ebp-18h]
  __m64 v134; // [esp+9Ch] [ebp-10h]
  __m64 v135; // [esp+9Ch] [ebp-10h]
  __m64 v136; // [esp+A4h] [ebp-8h]
  __m64 v137; // [esp+A4h] [ebp-8h]

  m64_u64 = (__m64)a5->m64_u64;
  v109 = a5[1];
  v110 = (__m64)a6->m64_u64;
  v8 = _m_pfadd((__m64)a5->m64_u64, (__m64)a6->m64_u64);
  v111 = a6[1];
  v9 = _m_pfadd(v109, v111);
  v10 = _m_pfsub((__m64)a5->m64_u64, (__m64)a6->m64_u64);
  v11 = _m_pfsub(v109, v111);
  v12 = a7;
  v13 = _m_pfadd(_m_pfmul(v8, v8), _m_pfmul(v9, v9));
  v14 = _m_pfadd(_m_pfmul(v10, v10), _m_pfmul(v11, v11));
  v112 = (__m64)a7->m64_u64;
  v113 = a7[1];
  v15 = _m_pfadd((__m64)a6->m64_u64, (__m64)a7->m64_u64);
  v16 = _m_pfadd(v111, v113);
  v17 = _m_pfsub((__m64)a6->m64_u64, (__m64)a7->m64_u64);
  v18 = _m_pfsub(v111, v113);
  v19 = _m_pfcmpgt(
          _m_pfacc(v14, _m_pfadd(_m_pfmul(v17, v17), _m_pfmul(v18, v18))),
          _m_pfacc(v13, _m_pfadd(_m_pfmul(v15, v15), _m_pfmul(v16, v16))));
  v20 = _mm_cvtsi64_si32(_m_packsswb(v19, v19));
  if ( (v20 & 1) != 0 )
  {
    v12 = a5;
    m64_u64 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a5->m64_u64);
    v109 = _m_pxor((__m64)0x8000000080000000uLL, a5[1]);
  }
  if ( (v20 & 0x10000) != 0 )
  {
    v112 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a7->m64_u64);
    v113 = _m_pxor((__m64)0x8000000080000000uLL, a7[1]);
  }
  v21 = a8[1];
  v22 = _m_pfadd(v112, (__m64)a8->m64_u64);
  v114 = (__m64)a8->m64_u64;
  v23 = _m_pfadd(v113, v21);
  v115 = v21;
  v24 = _m_pfsub(v112, (__m64)a8->m64_u64);
  v25 = _m_pfsub(v113, v21);
  v26 = _m_pfadd(_m_pfmul(v22, v22), _m_pfmul(v23, v23));
  v27 = _m_pfadd(_m_pfmul(v24, v24), _m_pfmul(v25, v25));
  if ( (_mm_cvtsi64_si32(_m_pfcmpgt(_m_pfacc(v27, v27), _m_pfacc(v26, v26))) & 1) != 0 )
  {
    v12 = a8;
    v114 = _m_pxor((__m64)0x8000000080000000uLL, (__m64)a8->m64_u64);
    v115 = _m_pxor((__m64)0x8000000080000000uLL, a8[1]);
  }
  v28 = _m_pfadd(_m_pfmul(v110, v110), _m_pfmul(v111, v111));
  v29 = _m_pfacc(v28, v28);
  v30 = _m_pfrcp(v29);
  v31 = _m_pfcmpgt(v29, (__m64)0x80000000800000LL);
  v32 = _m_pfrcpit2(_m_pfrcpit1(v29, v30), v30);
  v116 = _m_pfmul(_m_pand(_m_pxor(v110, (__m64)0x8000000080000000uLL), v31), v32);
  v118 = _m_pfmul(_m_pand(_m_pxor(v111, (__m64)0x80000000LL), v31), v32);
  v33 = _m_punpckldq(_m_punpckhdq(m64_u64, m64_u64), m64_u64);
  v34 = _m_punpckldq(_m_punpckhdq(v109, v109), v109);
  v126 = _m_pfacc(
           _m_pfsub(_m_pfmul(v33, v118), _m_pfmul(_m_pxor(v34, (__m64)0x80000000LL), v116)),
           _m_pfadd(_m_pxor(_m_pfmul(m64_u64, v118), (__m64)0x80000000LL), _m_pfmul(v109, v116)));
  v130 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v33, (__m64)0x80000000LL), v116), _m_pfmul(v34, v118)),
           _m_pfsub(_m_pfmul(_m_pxor(v109, (__m64)0x80000000LL), v118), _m_pfmul(m64_u64, v116)));
  v35 = _m_punpckldq(_m_punpckhdq(v112, v112), v112);
  v36 = _m_punpckldq(_m_punpckhdq(v113, v113), v113);
  v134 = _m_pfacc(
           _m_pfsub(_m_pfmul(v35, v118), _m_pfmul(_m_pxor(v36, (__m64)0x80000000LL), v116)),
           _m_pfadd(_m_pxor(_m_pfmul(v112, v118), (__m64)0x80000000LL), _m_pfmul(v113, v116)));
  v136 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v35, (__m64)0x80000000LL), v116), _m_pfmul(v36, v118)),
           _m_pfsub(_m_pfmul(_m_pxor(v113, (__m64)0x80000000LL), v118), _m_pfmul(v112, v116)));
  v37 = v126;
  v38 = v130;
  v39 = _m_punpckhdq(v130, v130);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v39, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v12);
    v102 = _mm_cvtsi64_si32(v39);
    sub_10035600();
    v12 = (__m64 *)m64_u64.m64_i32[1];
    v37 = v126;
    v38 = v130;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v39, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v40 = _mm_cvtsi32_si64(v102);
      v41 = _m_pfrcp(v39);
      v42 = _m_pfmul(_m_punpckldq(v40, v40), _m_pfrcpit2(_m_pfrcpit1(v39, v41), v41));
      v37 = _m_pfmul(v126, v42);
      v38 = _m_pfmul(v130, v42);
    }
  }
  v120 = v37;
  v122 = _m_pand(v38, (__m64)0xFFFFFFFFLL);
  v43 = v134;
  v44 = v136;
  v45 = _m_punpckhdq(v136, v136);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v45, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v12);
    v103 = _mm_cvtsi64_si32(v45);
    sub_10035600();
    v43 = v134;
    v44 = v136;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v45, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v46 = _mm_cvtsi32_si64(v103);
      v47 = _m_pfrcp(v45);
      v48 = _m_pfmul(_m_punpckldq(v46, v46), _m_pfrcpit2(_m_pfrcpit1(v45, v47), v47));
      v43 = _m_pfmul(v134, v48);
      v44 = _m_pfmul(v136, v48);
    }
  }
  v127 = _m_pfmul(_m_pfadd(v120, v43), (__m64)0xBE800000BE800000uLL);
  v131 = _m_pfmul(_m_pfadd(v122, _m_pand(v44, (__m64)0xFFFFFFFFLL)), (__m64)0xBE800000BE800000uLL).m64_u32[0];
  v49 = _mm_cvtsi32_si64(v131);
  v50 = _m_pfadd(_m_pfmul(v127, v127), _m_pfmul(v49, v49));
  v51 = _m_pfacc(v50, v50);
  v52 = _m_pfrsqrt(v51);
  v53 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v52, v52), v51), v52);
  v104.m64_u64 = __PAIR64__(a1, _mm_cvtsi64_si32(v53));
  sub_100354E0();
  v55 = _m_pfmul(v51, v53);
  v56 = _m_pfcmpge(_m_pand(v55, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  v57 = _mm_cvtsi64_si32(_m_punpckhdq(v56, v56));
  v58 = v127;
  v59 = v55;
  v60 = _m_pfmul(_m_punpckhdq(v55, v55), v104);
  v61 = _mm_cvtsi32_si64(v131);
  if ( (v57 & 1) != 0 )
  {
    v62 = _m_punpckldq(v60, v60);
    v61 = _m_pfmul(v61, v62);
    v58 = _m_pfmul(v127, v62);
  }
  v124 = _m_punpckldq(v61, v59);
  v63 = _m_punpckldq(_m_punpckhdq(v58, v58), v58);
  v64 = _m_punpckldq(_m_punpckhdq(v124, v124), v124);
  a2->m64_u64 = (unsigned __int64)_m_pfacc(
                                    _m_pfsub(_m_pfmul(v63, v111), _m_pfmul(_m_pxor(v64, (__m64)0x80000000LL), v110)),
                                    _m_pfadd(_m_pxor(_m_pfmul(v58, v111), (__m64)0x80000000LL), _m_pfmul(v124, v110)));
  a2[1].m64_u64 = (unsigned __int64)_m_pfacc(
                                      _m_pfadd(_m_pfmul(_m_pxor(v63, (__m64)0x80000000LL), v110), _m_pfmul(v64, v111)),
                                      _m_pfsub(_m_pfmul(_m_pxor(v124, (__m64)0x80000000LL), v111), _m_pfmul(v58, v110)));
  v65 = _m_pfadd(_m_pfmul(v112, v112), _m_pfmul(v113, v113));
  v66 = _m_pfacc(v65, v65);
  v67 = _m_pfrcp(v66);
  v68 = _m_pfcmpgt(v66, (__m64)0x80000000800000LL);
  v69 = _m_pfrcpit2(_m_pfrcpit1(v66, v67), v67);
  v117 = _m_pfmul(_m_pand(_m_pxor(v112, (__m64)0x8000000080000000uLL), v68), v69);
  v119 = _m_pfmul(_m_pand(_m_pxor(v113, (__m64)0x80000000LL), v68), v69);
  v70 = _m_punpckldq(_m_punpckhdq(v110, v110), v110);
  v71 = _m_punpckldq(_m_punpckhdq(v111, v111), v111);
  v128 = _m_pfacc(
           _m_pfsub(_m_pfmul(v70, v119), _m_pfmul(_m_pxor(v71, (__m64)0x80000000LL), v117)),
           _m_pfadd(_m_pxor(_m_pfmul(v110, v119), (__m64)0x80000000LL), _m_pfmul(v111, v117)));
  v132 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v70, (__m64)0x80000000LL), v117), _m_pfmul(v71, v119)),
           _m_pfsub(_m_pfmul(_m_pxor(v111, (__m64)0x80000000LL), v119), _m_pfmul(v110, v117)));
  v72 = _m_punpckldq(_m_punpckhdq(v114, v114), v114);
  v73 = _m_punpckldq(_m_punpckhdq(v115, v115), v115);
  v135 = _m_pfacc(
           _m_pfsub(_m_pfmul(v72, v119), _m_pfmul(_m_pxor(v73, (__m64)0x80000000LL), v117)),
           _m_pfadd(_m_pxor(_m_pfmul(v114, v119), (__m64)0x80000000LL), _m_pfmul(v115, v117)));
  v137 = _m_pfacc(
           _m_pfadd(_m_pfmul(_m_pxor(v72, (__m64)0x80000000LL), v117), _m_pfmul(v73, v119)),
           _m_pfsub(_m_pfmul(_m_pxor(v115, (__m64)0x80000000LL), v119), _m_pfmul(v114, v117)));
  v74 = v128;
  v75 = v132;
  v76 = _m_punpckhdq(v132, v132);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v76, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v54);
    v105 = _mm_cvtsi64_si32(v76);
    sub_10035600();
    v54 = m64_u64.m64_i32[1];
    v74 = v128;
    v75 = v132;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v76, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v77 = _mm_cvtsi32_si64(v105);
      v78 = _m_pfrcp(v76);
      v79 = _m_pfmul(_m_punpckldq(v77, v77), _m_pfrcpit2(_m_pfrcpit1(v76, v78), v78));
      v74 = _m_pfmul(v128, v79);
      v75 = _m_pfmul(v132, v79);
    }
  }
  v121 = v74;
  v123 = _m_pand(v75, (__m64)0xFFFFFFFFLL);
  v80 = v135;
  v81 = v137;
  v82 = _m_punpckhdq(v137, v137);
  if ( !_mm_cvtsi64_si32(_m_pfcmpge(v82, (__m64)0x3F8000003F800000LL)) )
  {
    sub_10034F00(0, v54);
    v106 = _mm_cvtsi64_si32(v82);
    sub_10035600();
    v80 = v135;
    v81 = v137;
    if ( _mm_cvtsi64_si32(_m_pfcmpge(_m_pand(v82, (__m64)0x7FFFFFFF7FFFFFFFLL), (__m64)0x3400000034000000LL)) )
    {
      v83 = _mm_cvtsi32_si64(v106);
      v84 = _m_pfrcp(v82);
      v85 = _m_pfmul(_m_punpckldq(v83, v83), _m_pfrcpit2(_m_pfrcpit1(v82, v84), v84));
      v80 = _m_pfmul(v135, v85);
      v81 = _m_pfmul(v137, v85);
    }
  }
  v129 = _m_pfmul(_m_pfadd(v121, v80), (__m64)0xBE800000BE800000uLL);
  v133 = _m_pfmul(_m_pfadd(v123, _m_pand(v81, (__m64)0xFFFFFFFFLL)), (__m64)0xBE800000BE800000uLL).m64_u32[0];
  v86 = _mm_cvtsi32_si64(v133);
  v87 = _m_pfadd(_m_pfmul(v129, v129), _m_pfmul(v86, v86));
  v88 = _m_pfacc(v87, v87);
  v89 = _m_pfrsqrt(v88);
  v90 = _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v89, v89), v88), v89);
  v107.m64_u64 = __PAIR64__(v104.m64_u32[1], _mm_cvtsi64_si32(v90));
  sub_100354E0();
  v91 = _m_pfmul(v88, v90);
  v92 = _m_pfcmpge(_m_pand(v91, (__m64)0x7FFFFFFFFFFFFFFFLL), (__m64)0x3400000034000000LL);
  v93 = _mm_cvtsi64_si32(_m_punpckhdq(v92, v92));
  v94 = v129;
  v95 = v91;
  v96 = _m_pfmul(_m_punpckhdq(v91, v91), v107);
  v97 = _mm_cvtsi32_si64(v133);
  if ( (v93 & 1) != 0 )
  {
    v98 = _m_punpckldq(v96, v96);
    v97 = _m_pfmul(v97, v98);
    v94 = _m_pfmul(v129, v98);
  }
  v125 = _m_punpckldq(v97, v95);
  v99 = _m_punpckldq(_m_punpckhdq(v94, v94), v94);
  v100 = _m_punpckldq(_m_punpckhdq(v125, v125), v125);
  a3->m64_u64 = (unsigned __int64)_m_pfacc(
                                    _m_pfsub(_m_pfmul(v99, v113), _m_pfmul(_m_pxor(v100, (__m64)0x80000000LL), v112)),
                                    _m_pfadd(_m_pxor(_m_pfmul(v94, v113), (__m64)0x80000000LL), _m_pfmul(v125, v112)));
  a3[1].m64_u64 = (unsigned __int64)_m_pfacc(
                                      _m_pfadd(_m_pfmul(_m_pxor(v99, (__m64)0x80000000LL), v112), _m_pfmul(v100, v113)),
                                      _m_pfsub(_m_pfmul(_m_pxor(v125, (__m64)0x80000000LL), v113), _m_pfmul(v94, v112)));
  a4->m64_u64 = (unsigned __int64)v112;
  a4[1].m64_u64 = (unsigned __int64)v113;
  _m_femms();
  return a4;
}

// sub_1002943A @ 0x1002943A
__m64 *__stdcall sub_1002943A(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm4
  __m64 v5; // mm5
  __m64 v6; // mm7
  __m64 v7; // mm1
  __m64 v8; // mm6
  __m64 v9; // mm4
  __m64 v10; // mm2
  __m64 v12; // mm5
  __m64 v13; // mm4
  __m64 v14; // mm4
  __m64 v15; // mm5
  __m64 v16; // mm4
  __m64 v17; // mm5
  __m64 v18; // mm4
  __m64 v19; // mm5
  __m64 v20; // [esp+0h] [ebp-44h]
  __m64 v21; // [esp+8h] [ebp-3Ch]
  __m64 v22; // [esp+10h] [ebp-34h]
  __m64 v23; // [esp+18h] [ebp-2Ch]
  __m64 v24; // [esp+28h] [ebp-1Ch]
  __m64 v25; // [esp+30h] [ebp-14h]
  __m64 v26; // [esp+38h] [ebp-Ch]

  _m_femms();
  v3 = a3[2];
  v4 = a3[7];
  v5 = a3[5];
  v20 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v22 = _m_punpckhdq((__m64)a3->m64_u64, v3);
  v6 = a3[3];
  v7 = a3[1];
  v24 = _m_punpckldq(v5, v4);
  v26 = _m_punpckhdq(v5, v4);
  v8 = _m_punpckldq(v7, v6);
  v9 = a3[6];
  v10 = a3[4];
  v25 = _m_punpckhdq(v7, v6);
  v23 = _m_punpckhdq(v10, v9);
  v21 = _m_punpckldq(v10, v9);
  v12 = a2[1];
  v13 = _m_pfadd(
          _m_pfacc(_m_pfmul((__m64)a2->m64_u64, v8), _m_pfmul((__m64)a2->m64_u64, v25)),
          _m_pfacc(_m_pfmul(v12, v24), _m_pfmul(v12, v26)));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfacc(_m_pfmul((__m64)a2->m64_u64, v20), _m_pfmul((__m64)a2->m64_u64, v22)),
                                    _m_pfacc(_m_pfmul(v12, v21), _m_pfmul(v12, v23)));
  a1[1].m64_u64 = (unsigned __int64)v13;
  v14 = a2[2];
  v15 = a2[3];
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v14, v20), _m_pfmul(v14, v22)),
                                      _m_pfacc(_m_pfmul(v15, v21), _m_pfmul(v15, v23)));
  a1[3].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v14, v8), _m_pfmul(v14, v25)),
                                      _m_pfacc(_m_pfmul(v15, v24), _m_pfmul(v15, v26)));
  v16 = a2[4];
  v17 = a2[5];
  a1[4].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v16, v20), _m_pfmul(v16, v22)),
                                      _m_pfacc(_m_pfmul(v17, v21), _m_pfmul(v17, v23)));
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v16, v8), _m_pfmul(v16, v25)),
                                      _m_pfacc(_m_pfmul(v17, v24), _m_pfmul(v17, v26)));
  v18 = a2[6];
  v19 = a2[7];
  a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, v20), _m_pfmul(v18, v22)),
                                      _m_pfacc(_m_pfmul(v19, v21), _m_pfmul(v19, v23)));
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, v8), _m_pfmul(v18, v25)),
                                      _m_pfacc(_m_pfmul(v19, v24), _m_pfmul(v19, v26)));
  _m_femms();
  return a1;
}

// sub_1002966C @ 0x1002966C
double __stdcall sub_1002966C(unsigned int *a1)
{
  __m64 v1; // mm0
  __m64 v2; // mm3
  __m64 v3; // mm4
  __m64 v4; // mm2
  __m64 v5; // mm3
  __m64 v6; // mm4

  v1 = *(__m64 *)(a1 + 9);
  v2 = *(__m64 *)(a1 + 13);
  v3 = _m_pfsub(
         _m_pfmul(_m_punpckhdq(*((__m64 *)a1 + 7), *((__m64 *)a1 + 7)), v1),
         _m_pfmul(_m_punpckhdq(*((__m64 *)a1 + 5), *((__m64 *)a1 + 5)), v2));
  v4 = _m_pfsub(
         _m_pfmul(_m_punpckldq(*((__m64 *)a1 + 4), *((__m64 *)a1 + 4)), *((__m64 *)a1 + 7)),
         _m_pfmul(_m_punpckldq(*((__m64 *)a1 + 6), *((__m64 *)a1 + 6)), *((__m64 *)a1 + 5)));
  v5 = _m_pfsub(_m_pfmul(v2, *((__m64 *)a1 + 4)), _m_pfmul(v1, *((__m64 *)a1 + 6)));
  v6 = _m_pfsub(
         _m_pfmul(
           _m_pfsub(
             _m_pfadd(
               _m_pfmul(v3, *((__m64 *)a1 + 2)),
               _m_pfmul(v5, _m_punpckhdq(*((__m64 *)a1 + 3), *((__m64 *)a1 + 3)))),
             _m_pfmul(_m_punpckldq(_m_punpckhdq(v4, v4), v3), *(__m64 *)(a1 + 5))),
           _m_punpckldq(*((__m64 *)a1 + 1), (__m64)*a1)),
         _m_pfmul(
           _m_pfsub(
             _m_pfadd(
               _m_pfmul(_m_punpckhdq(v5, v3), _m_punpckldq(*((__m64 *)a1 + 2), *((__m64 *)a1 + 2))),
               _m_pfmul(_m_punpckldq(v5, v4), *((__m64 *)a1 + 3))),
             _m_pfmul(v4, *(__m64 *)(a1 + 5))),
           _m_punpckhdq(*((__m64 *)a1 + 1), *(__m64 *)a1)));
  _m_femms();
  return COERCE_FLOAT(_mm_cvtsi64_si32(_m_pfacc(v6, v6)));
}

// sub_1002973B @ 0x1002973B
__m64 *__stdcall sub_1002973B(__m64 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  _m_femms();
  a1->m64_u64 = 1065353216;
  a1[1].m64_u64 = 0;
  a1[2].m64_u64 = 0x3F80000000000000LL;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = 1065353216;
  a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(_mm_cvtsi32_si64(a2), _mm_cvtsi32_si64(a3));
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(_mm_cvtsi32_si64(a4), (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_1002978B @ 0x1002978B
__m64 *__stdcall sub_1002978B(__m64 *a1, __m64 *a2, int a3)
{
  __m64 m64_u64; // mm6
  __m64 v5; // mm7
  __m64 v6; // mm3
  __m64 v7; // mm1
  __m64 v8; // mm0
  __m64 v9; // mm2
  __m64 v10; // mm1
  __m64 v11; // mm3
  __m64 v12; // mm1
  __m64 v13; // mm3
  __m64 v14; // [esp+0h] [ebp-14h] BYREF
  __m64 v15; // [esp+8h] [ebp-Ch]

  _m_femms();
  sub_1002E578((int)&v14, a3);
  m64_u64 = (__m64)a2->m64_u64;
  v5 = a2[1];
  v6 = _m_pfmul(v5, v15);
  v7 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, v14), v6);
  v8 = _m_pxor(v14, (__m64)0x8000000080000000uLL);
  v9 = _m_pxor(v15, (__m64)0x8000000080000000uLL);
  v10 = _m_pfacc(v7, v7);
  v11 = _m_punpckldq(v6, v10);
  v12 = _m_psllqi(v10, 0x20u);
  v13 = _m_psrlqi(v11, 0x20u);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckldq(v8, v8), (__m64)a2->m64_u64), v13);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckldq(v8, v8), v5);
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckhdq(v8, v8), m64_u64), v12);
  a1[3].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckhdq(v8, v8), v5);
  a1[4].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckldq(v9, v9), m64_u64);
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckldq(v9, v9), v5), v13);
  a1[6].m64_u64 = (unsigned __int64)_m_pfmul(_m_punpckhdq(v9, v9), m64_u64);
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_punpckhdq(v9, v9), v5), v12);
  _m_femms();
  return a1;
}

// sub_10029876 @ 0x10029876
__m64 *__stdcall sub_10029876(__m64 *a1, int a2)
{
  __m64 v3; // mm3
  __m64 v4; // mm0
  __m64 v5; // mm1
  __m64 v6; // mm6
  __m64 v7; // mm4
  __m64 v8; // mm6
  __m64 v9; // mm4
  __m64 v10; // mm6
  __m64 v11; // [esp+0h] [ebp-14h] BYREF
  __m64 v12; // [esp+8h] [ebp-Ch]

  _m_femms();
  sub_1002E578((int)&v11, a2);
  v3 = v12;
  v4 = _m_pfmul(v11, (__m64)0xC0000000C0000000uLL);
  v5 = _m_pfmul(v12, (__m64)0x3F800000C0000000LL);
  v6 = v11;
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckhdq(v6, v6);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(v7, v4), (__m64)1065353216LL);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_psrlqi(v7, 0x20u), v5);
  a1[2].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(v8, v4), (__m64)0x3F80000000000000LL);
  a1[3].m64_u64 = (unsigned __int64)_m_pfmul(_m_psrlqi(v8, 0x20u), v5);
  v9 = _m_punpckldq(v3, v3);
  v10 = _m_punpckhdq(v3, v3);
  a1[4].m64_u64 = (unsigned __int64)_m_pfmul(v9, v4);
  a1[5].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_psrlqi(v9, 0x20u), v5), (__m64)1065353216LL);
  a1[6].m64_u64 = (unsigned __int64)_m_pfmul(v10, v4);
  a1[7].m64_u64 = (unsigned __int64)_m_pfadd(_m_pfmul(_m_psrlqi(v10, 0x20u), v5), (__m64)0x3F80000000000000LL);
  _m_femms();
  return a1;
}

// sub_10029952 @ 0x10029952
__m64 *__stdcall sub_10029952(__m64 *a1, unsigned int a2)
{
  __m64 v2; // mm0
  __m64 v4; // mm4

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2);
  sub_100354E0();
  v4 = _m_psrlqi(v2, 0x20u);
  a1->m64_u64 = 1065353216;
  a1[1].m64_u64 = 0;
  a1[2].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[2].m64_i32[1] = _mm_cvtsi64_si32(v2);
  a1[3].m64_u64 = (unsigned __int64)v4;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[4].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[4].m64_i32[1] = _mm_cvtsi64_si32(_m_pxor(v4, (__m64)0x80000000LL));
  a1[5].m64_i32[0] = _mm_cvtsi64_si32(v2);
  a1[5].m64_i32[1] = _mm_cvtsi64_si32(0);
  _m_femms();
  return a1;
}

// sub_100299B5 @ 0x100299B5
__m64 *__stdcall sub_100299B5(__m64 *a1, unsigned int a2)
{
  __m64 v3; // mm4
  __m64 v4; // mm0
  __m64 v5; // mm4

  _m_femms();
  sub_100354E0();
  v3 = _mm_cvtsi32_si64(a2);
  v4 = _m_pand(v3, (__m64)0xFFFFFFFFLL);
  v5 = _m_psrlqi(v3, 0x20u);
  a1[2].m64_u64 = 0x3F80000000000000LL;
  a1[3].m64_u64 = 0;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[4].m64_u64 = (unsigned __int64)v5;
  a1->m64_u64 = (unsigned __int64)v4;
  a1[5].m64_u64 = (unsigned __int64)v4;
  a1[1].m64_u64 = (unsigned __int64)_m_pxor(v5, (__m64)0x80000000LL);
  _m_femms();
  return a1;
}

// sub_10029A13 @ 0x10029A13
__m64 *__stdcall sub_10029A13(__m64 *a1, unsigned int a2)
{
  __m64 v2; // mm0

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2);
  sub_100354E0();
  a1->m64_u64 = (unsigned __int64)v2;
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = 1065353216;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  a1[2].m64_u64 = (unsigned __int64)_m_pxor(_m_punpckldq(_m_punpckhdq(v2, v2), v2), (__m64)0x80000000LL);
  _m_femms();
  return a1;
}

// sub_10029A6C @ 0x10029A6C
__m64 *__stdcall sub_10029A6C(__m64 *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  _m_femms();
  a1->m64_u64 = (unsigned __int64)_mm_cvtsi32_si64(a2);
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[6].m64_u64 = 0;
  a1[2].m64_u64 = (unsigned __int64)_m_psllqi(_mm_cvtsi32_si64(a3), 0x20u);
  a1[5].m64_u64 = (unsigned __int64)_mm_cvtsi32_si64(a4);
  a1[7].m64_u64 = 0x3F80000000000000LL;
  _m_femms();
  return a1;
}

// sub_10029AB3 @ 0x10029AB3
__m64 *__stdcall sub_10029AB3(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm1
  __m64 v3; // mm4
  __m64 v5; // mm2
  __m64 v6; // mm5
  __m64 v7; // mm7
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm4

  v2 = a2[2];
  v3 = a2[7];
  v5 = _m_punpckhdq((__m64)a2->m64_u64, v2);
  v6 = a2[5];
  a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a2->m64_u64, v2);
  a1[2].m64_u64 = (unsigned __int64)v5;
  v7 = a2[3];
  v8 = a2[4];
  v9 = a2[1];
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(v6, v3);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v6, v3);
  v10 = a2[6];
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v9, v7);
  a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v9, v7);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v8, v10);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(v8, v10);
  _m_femms();
  return a1;
}

// sub_10029B22 @ 0x10029B22
__m64 *__cdecl sub_10029B22(__m64 *a1)
{
  __m64 v1; // mm1
  __m64 v3; // mm2

  v1 = _mm_cvtsi32_si64(0x3F800000u);
  a1->m64_u64 = (unsigned __int64)v1;
  a1[1].m64_u64 = 0;
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = (unsigned __int64)v1;
  v3 = _m_punpckldq(_m_punpckhdq(v1, v1), v1);
  a1[6].m64_u64 = 0;
  a1[2].m64_u64 = (unsigned __int64)v3;
  a1[7].m64_u64 = (unsigned __int64)v3;
  _m_femms();
  return a1;
}

// sub_10029B5B @ 0x10029B5B
__m64 *__stdcall sub_10029B5B(__m64 *a1, __m64 *a2)
{
  __m64 m64_u64; // mm3
  __m64 v4; // mm0
  __m64 v5; // mm7
  __m64 v6; // mm2
  __m64 v7; // mm4
  __m64 v8; // mm3
  __m64 v9; // mm1
  __m64 v10; // mm5
  __m64 v11; // mm7
  __m64 v12; // mm6
  __m64 v13; // mm2
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm7
  __m64 v17; // mm3
  __m64 v18; // mm2
  __m64 v19; // mm3
  __m64 v20; // mm5
  __m64 v21; // mm6

  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_pfadd(m64_u64, m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckhdq(v5, v5);
  v8 = _m_pfmul((__m64)a2->m64_u64, v4);
  v9 = _m_punpckldq(_m_pfadd(v5, v5), v4);
  v10 = _m_pfmul(v4, v7);
  v11 = _m_pfmul(_m_punpckldq(v5, v5), v9);
  v12 = _m_pfmul(v9, v7);
  v13 = _m_pfmul(v9, v6);
  v14 = _m_punpckhdq(v13, v11);
  a1[6].m64_u64 = 0;
  v15 = _m_punpckhdq(_m_punpckldq(v12, v12), v10);
  v16 = _m_pfsubr(_m_pfadd(_m_punpckldq(v11, v11), v8), (__m64)0x3F8000003F800000LL);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsubr(_m_pfacc(v8, v8), (__m64)0x3F8000003F800000LL), 0);
  v17 = v13;
  v18 = _m_pfadd(v13, v10);
  v19 = _m_pfsub(v17, v10);
  v20 = _m_pfsub(v14, v15);
  v21 = _m_pfadd(v14, v15);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v18, 0);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v20, 0);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v20, v16);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v16, _m_punpckldq(v21, v21));
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpckhdq(v21, v21), v19);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_10029C2D @ 0x10029C2D
__m64 *__stdcall sub_10029C2D(__m64 *a1, __m64 *a2)
{
  __m64 v3; // mm4
  __m64 v4; // mm1
  __m64 v5; // mm5
  __m64 v6; // mm0
  __m64 v7; // mm5
  __m64 v8; // mm2
  __m64 v9; // mm3
  __m64 v10; // mm1
  __m64 v11; // mm6
  __m64 v12; // mm3
  __m64 v13; // mm6
  __m64 v14; // mm2
  __m64 v15; // mm1

  v3 = a2[1];
  v4 = _m_pfadd(v3, v3);
  v5 = _m_pfadd((__m64)a2->m64_u64, (__m64)a2->m64_u64);
  v6 = _m_pfmul(v5, (__m64)a2->m64_u64);
  v7 = _m_punpckldq(v5, v4);
  v8 = _m_pfmul((__m64)a2->m64_u64, v4);
  v9 = _m_pfmul(_m_pswapd((__m64)a2->m64_u64), v4);
  v10 = _m_pfmul(v4, v3);
  v11 = _m_pfmul(_m_punpckhdq((__m64)a2->m64_u64, v3), v7);
  v12 = _m_pfpnacc(v9, v9);
  v13 = _m_pfpnacc(v11, v11);
  v14 = _m_pfpnacc(v8, v8);
  v15 = _m_pfsub(_m_pfsubr(v6, (__m64)0x3F8000003F800000LL), _m_punpckldq(v10, v10));
  a1[6].m64_u64 = 0;
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pswapd(v14), v12);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(v14, 0);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(_m_pfsubr(_m_pfacc(v6, v6), (__m64)0x3F8000003F800000LL), 0);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v15, v13);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v13, v15);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v12, 0);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_10029CE2 @ 0x10029CE2
__m64 *__stdcall sub_10029CE2(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, __m64 *a6, __m64 *a7)
{
  __m64 *result; // eax
  __m64 m64_u64; // mm3
  __m64 v9; // mm0
  __m64 v10; // mm7
  __m64 v11; // mm2
  __m64 v12; // mm4
  __m64 v13; // mm3
  __m64 v14; // mm1
  __m64 v15; // mm5
  __m64 v16; // mm7
  __m64 v17; // mm6
  __m64 v18; // mm2
  __m64 v19; // mm1
  __m64 v20; // mm6
  __m64 v21; // mm7
  __m64 v22; // mm3
  __m64 v23; // mm2
  __m64 v24; // mm3
  __m64 v25; // mm5
  __m64 v26; // mm6
  __m64 v27; // mm3
  __m64 v28; // mm4
  __m64 v29; // mm1
  __m64 v30; // mm2
  __m64 v31; // mm2
  __m64 v32; // mm1
  __m64 v33; // mm2
  __m64 v34; // mm3
  __m64 v35; // mm0
  __m64 v36; // mm1
  __m64 v37; // mm2
  __m64 v38; // mm5
  __m64 v39; // mm3
  __m64 v40; // mm2
  __m64 v41; // mm7
  __m64 v42; // mm0
  __m64 v43; // mm3
  __m64 v44; // mm1
  __m64 v45; // mm2
  __m64 v46; // mm3
  __m64 v47; // mm0
  __m64 v48; // mm1
  __m64 v49; // mm2
  __m64 v50; // mm5
  __m64 v51; // mm3
  __m64 v52; // mm2
  __m64 v53; // mm7
  __m64 v54; // mm0
  __m64 v55; // mm3
  __m64 v56; // mm1
  __m64 v57; // mm2
  __m64 v58; // mm3
  __m64 v59; // mm0
  __m64 v60; // mm1
  __m64 v61; // mm2
  __m64 v62; // mm5
  __m64 v63; // mm3
  __m64 v64; // mm2
  __m64 v65; // mm7
  __m64 v66; // mm0
  __m64 v67; // mm3
  __m64 v68; // mm1
  __m64 v69; // mm2
  __m64 v70; // mm3
  __m64 v71; // mm0
  __m64 v72; // mm1
  __m64 v73; // mm2
  __m64 v74; // mm5
  __m64 v75; // mm3
  __m64 v76; // mm7
  __m64 v77; // mm2
  __m64 v78; // mm3
  __m64 v79; // mm1
  __m64 v80; // mm2
  __m64 v81; // mm3
  __m64 v82; // mm0
  __m64 v83; // mm1
  __m64 v84; // mm2
  __m64 v85; // mm5
  __m64 v86; // mm3
  __m64 v87; // mm2
  __m64 v88; // mm7
  __m64 v89; // mm0
  __m64 v90; // mm3
  __m64 v91; // mm1
  __m64 v92; // mm2
  __m64 v93; // mm3
  __m64 v94; // mm0
  __m64 v95; // mm1
  __m64 v96; // mm2
  __m64 v97; // mm5
  __m64 v98; // mm3
  __m64 v99; // mm2
  __m64 v100; // mm7
  __m64 v101; // mm0
  __m64 v102; // mm3
  __m64 v103; // mm1
  __m64 v104; // mm2
  __m64 v105; // mm3
  __m64 v106; // mm0
  __m64 v107; // mm1
  __m64 v108; // mm2
  __m64 v109; // mm5
  __m64 v110; // mm3
  __m64 v111; // mm2
  __m64 v112; // mm7
  __m64 v113; // mm0
  __m64 v114; // mm3
  __m64 v115; // mm1
  __m64 v116; // mm2
  __m64 v117; // mm3
  __m64 v118; // mm0
  __m64 v119; // mm1
  __m64 v120; // mm2
  __m64 v121; // mm5
  __m64 v122; // mm3
  __m64 v123; // mm7
  __m64 v124; // mm2
  __m64 v125; // mm3
  __m64 v126; // mm1
  __m64 v127; // mm2
  __m64 v128; // mm3
  __m64 v129; // mm0
  __m64 v130; // mm1
  __m64 v131; // mm2
  __m64 v132; // mm5
  __m64 v133; // mm3
  __m64 v134; // mm2
  __m64 v135; // mm7
  __m64 v136; // mm0
  __m64 v137; // mm3
  __m64 v138; // mm1
  __m64 v139; // mm2
  __m64 v140; // mm3
  __m64 v141; // mm0
  __m64 v142; // mm1
  __m64 v143; // mm2
  __m64 v144; // mm5
  __m64 v145; // mm3
  __m64 v146; // mm2
  __m64 v147; // mm7
  __m64 v148; // mm0
  __m64 v149; // mm3
  __m64 v150; // mm1
  __m64 v151; // mm2
  __m64 v152; // mm3
  __m64 v153; // mm0
  __m64 v154; // mm1
  __m64 v155; // mm2
  __m64 v156; // mm5
  __m64 v157; // mm3
  __m64 v158; // mm2
  __m64 v159; // mm7
  __m64 v160; // mm0
  __m64 v161; // mm3
  __m64 v162; // mm1
  __m64 v163; // mm2
  __m64 v164; // mm3
  __m64 v165; // mm0
  __m64 v166; // mm1
  __m64 v167; // mm2
  __m64 v168; // mm3
  __m64 v169; // mm2
  __m64 v170; // mm3
  __m64 v171; // mm2
  __m64 v172; // mm1
  __m64 v173; // mm2
  __m64 v174; // mm3
  __m64 v175; // mm0
  __m64 v176; // mm1
  __m64 v177; // mm2
  __m64 v178; // mm5
  __m64 v179; // mm3
  __m64 v180; // mm2
  __m64 v181; // mm7
  __m64 v182; // mm0
  __m64 v183; // mm3
  __m64 v184; // mm1
  __m64 v185; // mm2
  __m64 v186; // mm3
  __m64 v187; // mm0
  __m64 v188; // mm1
  __m64 v189; // mm2
  __m64 v190; // mm5
  __m64 v191; // mm3
  __m64 v192; // mm2
  __m64 v193; // mm7
  __m64 v194; // mm0
  __m64 v195; // mm3
  __m64 v196; // mm1
  __m64 v197; // mm2
  __m64 v198; // mm3
  __m64 v199; // mm0
  __m64 v200; // mm1
  __m64 v201; // mm2
  __m64 v202; // mm5
  __m64 v203; // mm3
  __m64 v204; // mm2
  __m64 v205; // mm7
  __m64 v206; // mm0
  __m64 v207; // mm3
  __m64 v208; // mm1
  __m64 v209; // mm2
  __m64 v210; // mm3
  __m64 v211; // mm0
  __m64 v212; // mm1
  __m64 v213; // mm2
  __m64 v214; // mm5
  __m64 v215; // mm3
  __m64 v216; // mm7
  __m64 v217; // mm2
  __m64 v218; // mm3
  __m64 v219; // mm1
  __m64 v220; // mm2
  __m64 v221; // mm3
  __m64 v222; // mm0
  __m64 v223; // mm1
  __m64 v224; // mm2
  __m64 v225; // mm5
  __m64 v226; // mm3
  __m64 v227; // mm2
  __m64 v228; // mm7
  __m64 v229; // mm0
  __m64 v230; // mm3
  __m64 v231; // mm1
  __m64 v232; // mm2
  __m64 v233; // mm3
  __m64 v234; // mm0
  __m64 v235; // mm1
  __m64 v236; // mm2
  __m64 v237; // mm5
  __m64 v238; // mm3
  __m64 v239; // mm2
  __m64 v240; // mm7
  __m64 v241; // mm0
  __m64 v242; // mm3
  __m64 v243; // mm1
  __m64 v244; // mm2
  __m64 v245; // mm3
  __m64 v246; // mm0
  __m64 v247; // mm1
  __m64 v248; // mm2
  __m64 v249; // mm5
  __m64 v250; // mm3
  __m64 v251; // mm2
  __m64 v252; // mm7
  __m64 v253; // mm0
  __m64 v254; // mm3
  __m64 v255; // mm1
  __m64 v256; // mm2
  __m64 v257; // mm3
  __m64 v258; // mm0
  __m64 v259; // mm1
  __m64 v260; // mm2
  __m64 v261; // mm3
  __m64 v262; // mm4
  __m64 v263; // mm5
  __m64 v264; // mm1
  __m64 v265; // mm2
  __m64 v266; // mm3
  __m64 v267; // mm0
  __m64 v268; // mm7
  __m64 v269; // mm2
  __m64 v270; // mm4
  __m64 v271; // mm3
  __m64 v272; // mm1
  __m64 v273; // mm5
  __m64 v274; // mm7
  __m64 v275; // mm6
  __m64 v276; // mm2
  __m64 v277; // mm1
  __m64 v278; // mm6
  __m64 v279; // mm7
  __m64 v280; // mm3
  __m64 v281; // mm2
  __m64 v282; // mm3
  __m64 v283; // mm5
  __m64 v284; // mm2
  __m64 v285; // mm6
  __m64 v286; // mm2
  __m64 v287; // mm3
  __m64 v288; // mm1
  __m64 v289; // mm1
  __m64 v290; // mm2
  __m64 v291; // mm3
  __m64 v292; // mm0
  __m64 v293; // mm1
  __m64 v294; // mm2
  __m64 v295; // mm5
  __m64 v296; // mm3
  __m64 v297; // mm2
  __m64 v298; // mm7
  __m64 v299; // mm0
  __m64 v300; // mm3
  __m64 v301; // mm1
  __m64 v302; // mm2
  __m64 v303; // mm3
  __m64 v304; // mm0
  __m64 v305; // mm1
  __m64 v306; // mm2
  __m64 v307; // mm5
  __m64 v308; // mm3
  __m64 v309; // mm2
  __m64 v310; // mm7
  __m64 v311; // mm0
  __m64 v312; // mm3
  __m64 v313; // mm1
  __m64 v314; // mm2
  __m64 v315; // mm3
  __m64 v316; // mm0
  __m64 v317; // mm1
  __m64 v318; // mm2
  __m64 v319; // mm5
  __m64 v320; // mm3
  __m64 v321; // mm2
  __m64 v322; // mm7
  __m64 v323; // mm0
  __m64 v324; // mm3
  __m64 v325; // mm1
  __m64 v326; // mm2
  __m64 v327; // mm3
  __m64 v328; // mm0
  __m64 v329; // mm1
  __m64 v330; // mm2
  __m64 v331; // mm3
  __m64 v332; // mm1
  __m64 v333; // mm1
  __m64 v334; // mm2
  __m64 v335; // mm3
  __m64 v336; // mm0
  __m64 v337; // mm1
  __m64 v338; // mm2
  __m64 v339; // mm5
  __m64 v340; // mm3
  __m64 v341; // mm2
  __m64 v342; // mm7
  __m64 v343; // mm0
  __m64 v344; // mm3
  __m64 v345; // mm1
  __m64 v346; // mm2
  __m64 v347; // mm3
  __m64 v348; // mm0
  __m64 v349; // mm1
  __m64 v350; // mm2
  __m64 v351; // mm5
  __m64 v352; // mm3
  __m64 v353; // mm2
  __m64 v354; // mm7
  __m64 v355; // mm0
  __m64 v356; // mm3
  __m64 v357; // mm1
  __m64 v358; // mm2
  __m64 v359; // mm3
  __m64 v360; // mm0
  __m64 v361; // mm1
  __m64 v362; // mm2
  __m64 v363; // mm5
  __m64 v364; // mm3
  __m64 v365; // mm2
  __m64 v366; // mm7
  __m64 v367; // mm0
  __m64 v368; // mm3
  __m64 v369; // mm1
  __m64 v370; // mm2
  __m64 v371; // mm3
  __m64 v372; // mm0
  __m64 v373; // mm1
  __m64 v374; // mm2
  __m64 v375; // mm3
  __m64 v376; // mm1
  __m64 v377; // [esp+0h] [ebp-C0h]
  __m64 v378; // [esp+10h] [ebp-B0h]
  __m64 v379; // [esp+28h] [ebp-98h]
  __m64 v380; // [esp+40h] [ebp-80h]
  __m64 v381; // [esp+40h] [ebp-80h]
  __m64 v382; // [esp+48h] [ebp-78h]
  __m64 v383; // [esp+48h] [ebp-78h]
  __m64 v384; // [esp+50h] [ebp-70h]
  __m64 v385; // [esp+50h] [ebp-70h]
  __m64 v386; // [esp+58h] [ebp-68h]
  __m64 v387; // [esp+58h] [ebp-68h]
  __m64 v388; // [esp+60h] [ebp-60h]
  __m64 v389; // [esp+60h] [ebp-60h]
  __m64 v390; // [esp+68h] [ebp-58h]
  __m64 v391; // [esp+68h] [ebp-58h]
  __m64 v392; // [esp+78h] [ebp-48h]
  __m64 v393; // [esp+78h] [ebp-48h]
  __m64 v394; // [esp+80h] [ebp-40h]
  __m64 v395; // [esp+88h] [ebp-38h]
  __m64 v396; // [esp+90h] [ebp-30h]
  __m64 v397; // [esp+98h] [ebp-28h]
  __m64 v398; // [esp+A0h] [ebp-20h]
  __m64 v399; // [esp+A8h] [ebp-18h]
  __m64 v400; // [esp+B0h] [ebp-10h]
  __m64 v401; // [esp+B8h] [ebp-8h]

  result = a1;
  if ( a4 )
  {
    if ( a3 )
    {
      v377 = _m_punpckldq((__m64)a4->m64_u64, 0);
      v378 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      v379 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      m64_u64 = (__m64)a3->m64_u64;
      v9 = _m_pfadd(m64_u64, m64_u64);
      v10 = a3[1];
      v11 = _m_punpckhdq(m64_u64, m64_u64);
      v12 = _m_punpckhdq(v10, v10);
      v13 = _m_pfmul((__m64)a3->m64_u64, v9);
      v14 = _m_punpckldq(_m_pfadd(v10, v10), v9);
      v15 = _m_pfmul(v9, v12);
      v16 = _m_pfmul(_m_punpckldq(v10, v10), v14);
      v17 = _m_pfmul(v14, v12);
      v18 = _m_pfmul(v14, v11);
      v19 = _m_punpckhdq(v18, v16);
      v20 = _m_punpckhdq(_m_punpckldq(v17, v17), v15);
      v21 = _m_pfsubr(_m_pfadd(_m_punpckldq(v16, v16), v13), (__m64)0x3F8000003F800000LL);
      v390 = _m_punpckldq(_m_pfsubr(_m_pfacc(v13, v13), (__m64)0x3F8000003F800000LL), 0);
      v22 = v18;
      v23 = _m_pfadd(v18, v15);
      v24 = _m_pfsub(v22, v15);
      v25 = _m_pfsub(v19, v20);
      v26 = _m_pfadd(v19, v20);
      v386 = _m_punpckldq(v23, 0);
      v382 = _m_punpckhdq(v25, 0);
      v384 = _m_punpckldq(v25, v21);
      v380 = _m_punpckhdq(v21, _m_punpckldq(v26, v26));
      v388 = _m_punpckldq(_m_punpckhdq(v26, v26), v24);
      v392 = _m_punpckldq(0, (__m64)1065353216LL);
      if ( a2 )
      {
        v394 = _m_punpckldq(v380, v384);
        v396 = _m_punpckhdq(v380, v384);
        v399 = _m_punpckldq(v390, v392);
        v401 = _m_punpckhdq(v390, v392);
        v398 = _m_punpckldq(v382, v386);
        v400 = _m_punpckhdq(v382, v386);
        v397 = _m_punpckhdq(v388, 0);
        v395 = _m_punpckldq(v388, 0);
        result = a1;
        v27 = (__m64)a2->m64_u64;
        v28 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
        v29 = _mm_cvtsi32_si64(0x3F800000u);
        v30 = _m_punpckldq(_m_punpckhdq(v29, v29), v29);
        a1->m64_u64 = (unsigned __int64)v29;
        a1[1].m64_u64 = 0;
        a1[2].m64_u64 = (unsigned __int64)v30;
        a1[3].m64_u64 = 0;
        a1[4].m64_u64 = 0;
        a1[5].m64_u64 = (unsigned __int64)v29;
        v31 = _m_pfsub(v30, v28);
        a1[7].m64_u64 = (unsigned __int64)v31;
        a1[6].m64_u64 = (unsigned __int64)_m_pfsub(0, v27);
        v32 = a1[1];
        v33 = _m_punpckhdq(v31, (__m64)a1->m64_u64);
        v34 = _m_punpckhdq(v27, v32);
        v35 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v36 = _m_punpckldq(v32, v32);
        v37 = _m_punpckhdq(v33, v33);
        v38 = _m_pfmul(v396, v37);
        v39 = _m_punpckhdq(v34, v34);
        v40 = _m_pfadd(_m_pfadd(_m_pfmul(v37, v397), _m_pfmul(v35, v395)), _m_pfmul(v36, v399));
        v41 = _m_pfadd(_m_pfmul(v400, v39), _m_pfadd(_m_pfmul(v398, v36), _m_pfadd(v38, _m_pfmul(v394, v35))));
        v42 = a1[2];
        v43 = _m_pfadd(_m_pfmul(v39, v401), v40);
        v44 = a1[3];
        a1->m64_u64 = (unsigned __int64)v41;
        a1[1].m64_u64 = (unsigned __int64)v43;
        v45 = _m_punpckhdq(v40, v42);
        v46 = _m_punpckhdq(v43, v44);
        v47 = _m_punpckldq(v42, v42);
        v48 = _m_punpckldq(v44, v44);
        v49 = _m_punpckhdq(v45, v45);
        v50 = _m_pfmul(v396, v49);
        v51 = _m_punpckhdq(v46, v46);
        v52 = _m_pfadd(_m_pfadd(_m_pfmul(v49, v397), _m_pfmul(v47, v395)), _m_pfmul(v48, v399));
        v53 = _m_pfadd(_m_pfmul(v400, v51), _m_pfadd(_m_pfmul(v398, v48), _m_pfadd(v50, _m_pfmul(v394, v47))));
        v54 = a1[4];
        v55 = _m_pfadd(_m_pfmul(v51, v401), v52);
        v56 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v53;
        a1[3].m64_u64 = (unsigned __int64)v55;
        v57 = _m_punpckhdq(v52, v54);
        v58 = _m_punpckhdq(v55, v56);
        v59 = _m_punpckldq(v54, v54);
        v60 = _m_punpckldq(v56, v56);
        v61 = _m_punpckhdq(v57, v57);
        v62 = _m_pfmul(v396, v61);
        v63 = _m_punpckhdq(v58, v58);
        v64 = _m_pfadd(_m_pfadd(_m_pfmul(v61, v397), _m_pfmul(v59, v395)), _m_pfmul(v60, v399));
        v65 = _m_pfadd(_m_pfmul(v400, v63), _m_pfadd(_m_pfmul(v398, v60), _m_pfadd(v62, _m_pfmul(v394, v59))));
        v66 = a1[6];
        v67 = _m_pfadd(_m_pfmul(v63, v401), v64);
        v68 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v65;
        a1[5].m64_u64 = (unsigned __int64)v67;
        v69 = _m_punpckhdq(v64, v66);
        v70 = _m_punpckhdq(v67, v68);
        v71 = _m_punpckldq(v66, v66);
        v72 = _m_punpckldq(v68, v68);
        v73 = _m_punpckhdq(v69, v69);
        v74 = _m_pfmul(v396, v73);
        v75 = _m_punpckhdq(v70, v70);
        v76 = _m_pfmul(v400, v75);
        v77 = _m_pfadd(_m_pfadd(_m_pfmul(v73, v397), _m_pfmul(v71, v395)), _m_pfmul(v72, v399));
        v78 = _m_pfadd(_m_pfmul(v75, v401), v77);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v76,
                                            _m_pfadd(_m_pfmul(v398, v72), _m_pfadd(v74, _m_pfmul(v394, v71))));
        a1[7].m64_u64 = (unsigned __int64)v78;
        v79 = a1[1];
        v80 = _m_punpckhdq(v77, (__m64)a1->m64_u64);
        v81 = _m_punpckhdq(v78, v79);
        v82 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v83 = _m_punpckldq(v79, v79);
        v84 = _m_punpckhdq(v80, v80);
        v85 = _m_pfmul(v378, v84);
        v86 = _m_punpckhdq(v81, v81);
        v87 = _m_pfadd(_m_pfadd(_m_pfmul(v84, 0), _m_pfmul(v82, 0)), _m_pfmul(v83, v379));
        v88 = _m_pfadd(_m_pfmul(0, v86), _m_pfadd(_m_pfmul(0, v83), _m_pfadd(v85, _m_pfmul(v377, v82))));
        v89 = a1[2];
        v90 = _m_pfadd(_m_pfmul(v86, (__m64)0x3F80000000000000LL), v87);
        v91 = a1[3];
        a1->m64_u64 = (unsigned __int64)v88;
        a1[1].m64_u64 = (unsigned __int64)v90;
        v92 = _m_punpckhdq(v87, v89);
        v93 = _m_punpckhdq(v90, v91);
        v94 = _m_punpckldq(v89, v89);
        v95 = _m_punpckldq(v91, v91);
        v96 = _m_punpckhdq(v92, v92);
        v97 = _m_pfmul(v378, v96);
        v98 = _m_punpckhdq(v93, v93);
        v99 = _m_pfadd(_m_pfadd(_m_pfmul(v96, 0), _m_pfmul(v94, 0)), _m_pfmul(v95, v379));
        v100 = _m_pfadd(_m_pfmul(0, v98), _m_pfadd(_m_pfmul(0, v95), _m_pfadd(v97, _m_pfmul(v377, v94))));
        v101 = a1[4];
        v102 = _m_pfadd(_m_pfmul(v98, (__m64)0x3F80000000000000LL), v99);
        v103 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v100;
        a1[3].m64_u64 = (unsigned __int64)v102;
        v104 = _m_punpckhdq(v99, v101);
        v105 = _m_punpckhdq(v102, v103);
        v106 = _m_punpckldq(v101, v101);
        v107 = _m_punpckldq(v103, v103);
        v108 = _m_punpckhdq(v104, v104);
        v109 = _m_pfmul(v378, v108);
        v110 = _m_punpckhdq(v105, v105);
        v111 = _m_pfadd(_m_pfadd(_m_pfmul(v108, 0), _m_pfmul(v106, 0)), _m_pfmul(v107, v379));
        v112 = _m_pfadd(_m_pfmul(0, v110), _m_pfadd(_m_pfmul(0, v107), _m_pfadd(v109, _m_pfmul(v377, v106))));
        v113 = a1[6];
        v114 = _m_pfadd(_m_pfmul(v110, (__m64)0x3F80000000000000LL), v111);
        v115 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v112;
        a1[5].m64_u64 = (unsigned __int64)v114;
        v116 = _m_punpckhdq(v111, v113);
        v117 = _m_punpckhdq(v114, v115);
        v118 = _m_punpckldq(v113, v113);
        v119 = _m_punpckldq(v115, v115);
        v120 = _m_punpckhdq(v116, v116);
        v121 = _m_pfmul(v378, v120);
        v122 = _m_punpckhdq(v117, v117);
        v123 = _m_pfmul(0, v122);
        v124 = _m_pfadd(_m_pfadd(_m_pfmul(v120, 0), _m_pfmul(v118, 0)), _m_pfmul(v119, v379));
        v125 = _m_pfadd(_m_pfmul(v122, (__m64)0x3F80000000000000LL), v124);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v123,
                                            _m_pfadd(_m_pfmul(0, v119), _m_pfadd(v121, _m_pfmul(v377, v118))));
        a1[7].m64_u64 = (unsigned __int64)v125;
        v126 = a1[1];
        v127 = _m_punpckhdq(v124, (__m64)a1->m64_u64);
        v128 = _m_punpckhdq(v125, v126);
        v129 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v130 = _m_punpckldq(v126, v126);
        v131 = _m_punpckhdq(v127, v127);
        v132 = _m_pfmul(v384, v131);
        v133 = _m_punpckhdq(v128, v128);
        v134 = _m_pfadd(_m_pfadd(_m_pfmul(v131, v386), _m_pfmul(v129, v382)), _m_pfmul(v130, v390));
        v135 = _m_pfadd(_m_pfmul(0, v133), _m_pfadd(_m_pfmul(v388, v130), _m_pfadd(v132, _m_pfmul(v380, v129))));
        v136 = a1[2];
        v137 = _m_pfadd(_m_pfmul(v133, v392), v134);
        v138 = a1[3];
        a1->m64_u64 = (unsigned __int64)v135;
        a1[1].m64_u64 = (unsigned __int64)v137;
        v139 = _m_punpckhdq(v134, v136);
        v140 = _m_punpckhdq(v137, v138);
        v141 = _m_punpckldq(v136, v136);
        v142 = _m_punpckldq(v138, v138);
        v143 = _m_punpckhdq(v139, v139);
        v144 = _m_pfmul(v384, v143);
        v145 = _m_punpckhdq(v140, v140);
        v146 = _m_pfadd(_m_pfadd(_m_pfmul(v143, v386), _m_pfmul(v141, v382)), _m_pfmul(v142, v390));
        v147 = _m_pfadd(_m_pfmul(0, v145), _m_pfadd(_m_pfmul(v388, v142), _m_pfadd(v144, _m_pfmul(v380, v141))));
        v148 = a1[4];
        v149 = _m_pfadd(_m_pfmul(v145, v392), v146);
        v150 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v147;
        a1[3].m64_u64 = (unsigned __int64)v149;
        v151 = _m_punpckhdq(v146, v148);
        v152 = _m_punpckhdq(v149, v150);
        v153 = _m_punpckldq(v148, v148);
        v154 = _m_punpckldq(v150, v150);
        v155 = _m_punpckhdq(v151, v151);
        v156 = _m_pfmul(v384, v155);
        v157 = _m_punpckhdq(v152, v152);
        v158 = _m_pfadd(_m_pfadd(_m_pfmul(v155, v386), _m_pfmul(v153, v382)), _m_pfmul(v154, v390));
        v159 = _m_pfadd(_m_pfmul(0, v157), _m_pfadd(_m_pfmul(v388, v154), _m_pfadd(v156, _m_pfmul(v380, v153))));
        v160 = a1[6];
        v161 = _m_pfadd(_m_pfmul(v157, v392), v158);
        v162 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v159;
        a1[5].m64_u64 = (unsigned __int64)v161;
        v163 = _m_punpckhdq(v158, v160);
        v164 = _m_punpckhdq(v161, v162);
        v165 = _m_punpckldq(v160, v160);
        v166 = _m_punpckldq(v162, v162);
        v167 = _m_punpckhdq(v163, v163);
        v168 = _m_punpckhdq(v164, v164);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v168),
                                            _m_pfadd(
                                              _m_pfmul(v388, v166),
                                              _m_pfadd(_m_pfmul(v384, v167), _m_pfmul(v380, v165))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v168, v392),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v167, v386), _m_pfmul(v165, v382)),
                                              _m_pfmul(v166, v390)));
        v169 = _m_pfadd(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a2->m64_u64, a1[6]);
        a1[7].m64_i32[0] = _mm_cvtsi64_si32(v169);
      }
      else
      {
        result = a1;
        a1->m64_u64 = (unsigned __int64)_m_punpckldq(v380, v384);
        a1[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v380, v384);
        v170 = _m_punpckldq(v390, v392);
        a1[5].m64_u64 = (unsigned __int64)v170;
        a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v390, v392);
        a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v382, v386);
        v171 = _m_punpckldq(v388, 0);
        a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v382, v386);
        a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v388, 0);
        a1[1].m64_u64 = (unsigned __int64)v171;
        v172 = a1[1];
        v173 = _m_punpckhdq(v171, (__m64)a1->m64_u64);
        v174 = _m_punpckhdq(v170, v172);
        v175 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v176 = _m_punpckldq(v172, v172);
        v177 = _m_punpckhdq(v173, v173);
        v178 = _m_pfmul(v378, v177);
        v179 = _m_punpckhdq(v174, v174);
        v180 = _m_pfadd(_m_pfadd(_m_pfmul(v177, 0), _m_pfmul(v175, 0)), _m_pfmul(v176, v379));
        v181 = _m_pfadd(_m_pfmul(0, v179), _m_pfadd(_m_pfmul(0, v176), _m_pfadd(v178, _m_pfmul(v377, v175))));
        v182 = a1[2];
        v183 = _m_pfadd(_m_pfmul(v179, (__m64)0x3F80000000000000LL), v180);
        v184 = a1[3];
        a1->m64_u64 = (unsigned __int64)v181;
        a1[1].m64_u64 = (unsigned __int64)v183;
        v185 = _m_punpckhdq(v180, v182);
        v186 = _m_punpckhdq(v183, v184);
        v187 = _m_punpckldq(v182, v182);
        v188 = _m_punpckldq(v184, v184);
        v189 = _m_punpckhdq(v185, v185);
        v190 = _m_pfmul(v378, v189);
        v191 = _m_punpckhdq(v186, v186);
        v192 = _m_pfadd(_m_pfadd(_m_pfmul(v189, 0), _m_pfmul(v187, 0)), _m_pfmul(v188, v379));
        v193 = _m_pfadd(_m_pfmul(0, v191), _m_pfadd(_m_pfmul(0, v188), _m_pfadd(v190, _m_pfmul(v377, v187))));
        v194 = a1[4];
        v195 = _m_pfadd(_m_pfmul(v191, (__m64)0x3F80000000000000LL), v192);
        v196 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v193;
        a1[3].m64_u64 = (unsigned __int64)v195;
        v197 = _m_punpckhdq(v192, v194);
        v198 = _m_punpckhdq(v195, v196);
        v199 = _m_punpckldq(v194, v194);
        v200 = _m_punpckldq(v196, v196);
        v201 = _m_punpckhdq(v197, v197);
        v202 = _m_pfmul(v378, v201);
        v203 = _m_punpckhdq(v198, v198);
        v204 = _m_pfadd(_m_pfadd(_m_pfmul(v201, 0), _m_pfmul(v199, 0)), _m_pfmul(v200, v379));
        v205 = _m_pfadd(_m_pfmul(0, v203), _m_pfadd(_m_pfmul(0, v200), _m_pfadd(v202, _m_pfmul(v377, v199))));
        v206 = a1[6];
        v207 = _m_pfadd(_m_pfmul(v203, (__m64)0x3F80000000000000LL), v204);
        v208 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v205;
        a1[5].m64_u64 = (unsigned __int64)v207;
        v209 = _m_punpckhdq(v204, v206);
        v210 = _m_punpckhdq(v207, v208);
        v211 = _m_punpckldq(v206, v206);
        v212 = _m_punpckldq(v208, v208);
        v213 = _m_punpckhdq(v209, v209);
        v214 = _m_pfmul(v378, v213);
        v215 = _m_punpckhdq(v210, v210);
        v216 = _m_pfmul(0, v215);
        v217 = _m_pfadd(_m_pfadd(_m_pfmul(v213, 0), _m_pfmul(v211, 0)), _m_pfmul(v212, v379));
        v218 = _m_pfadd(_m_pfmul(v215, (__m64)0x3F80000000000000LL), v217);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v216,
                                            _m_pfadd(_m_pfmul(0, v212), _m_pfadd(v214, _m_pfmul(v377, v211))));
        a1[7].m64_u64 = (unsigned __int64)v218;
        v219 = a1[1];
        v220 = _m_punpckhdq(v217, (__m64)a1->m64_u64);
        v221 = _m_punpckhdq(v218, v219);
        v222 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v223 = _m_punpckldq(v219, v219);
        v224 = _m_punpckhdq(v220, v220);
        v225 = _m_pfmul(v384, v224);
        v226 = _m_punpckhdq(v221, v221);
        v227 = _m_pfadd(_m_pfadd(_m_pfmul(v224, v386), _m_pfmul(v222, v382)), _m_pfmul(v223, v390));
        v228 = _m_pfadd(_m_pfmul(0, v226), _m_pfadd(_m_pfmul(v388, v223), _m_pfadd(v225, _m_pfmul(v380, v222))));
        v229 = a1[2];
        v230 = _m_pfadd(_m_pfmul(v226, v392), v227);
        v231 = a1[3];
        a1->m64_u64 = (unsigned __int64)v228;
        a1[1].m64_u64 = (unsigned __int64)v230;
        v232 = _m_punpckhdq(v227, v229);
        v233 = _m_punpckhdq(v230, v231);
        v234 = _m_punpckldq(v229, v229);
        v235 = _m_punpckldq(v231, v231);
        v236 = _m_punpckhdq(v232, v232);
        v237 = _m_pfmul(v384, v236);
        v238 = _m_punpckhdq(v233, v233);
        v239 = _m_pfadd(_m_pfadd(_m_pfmul(v236, v386), _m_pfmul(v234, v382)), _m_pfmul(v235, v390));
        v240 = _m_pfadd(_m_pfmul(0, v238), _m_pfadd(_m_pfmul(v388, v235), _m_pfadd(v237, _m_pfmul(v380, v234))));
        v241 = a1[4];
        v242 = _m_pfadd(_m_pfmul(v238, v392), v239);
        v243 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v240;
        a1[3].m64_u64 = (unsigned __int64)v242;
        v244 = _m_punpckhdq(v239, v241);
        v245 = _m_punpckhdq(v242, v243);
        v246 = _m_punpckldq(v241, v241);
        v247 = _m_punpckldq(v243, v243);
        v248 = _m_punpckhdq(v244, v244);
        v249 = _m_pfmul(v384, v248);
        v250 = _m_punpckhdq(v245, v245);
        v251 = _m_pfadd(_m_pfadd(_m_pfmul(v248, v386), _m_pfmul(v246, v382)), _m_pfmul(v247, v390));
        v252 = _m_pfadd(_m_pfmul(0, v250), _m_pfadd(_m_pfmul(v388, v247), _m_pfadd(v249, _m_pfmul(v380, v246))));
        v253 = a1[6];
        v254 = _m_pfadd(_m_pfmul(v250, v392), v251);
        v255 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v252;
        a1[5].m64_u64 = (unsigned __int64)v254;
        v256 = _m_punpckhdq(v251, v253);
        v257 = _m_punpckhdq(v254, v255);
        v258 = _m_punpckldq(v253, v253);
        v259 = _m_punpckldq(v255, v255);
        v260 = _m_punpckhdq(v256, v256);
        v261 = _m_punpckhdq(v257, v257);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v261),
                                            _m_pfadd(
                                              _m_pfmul(v388, v259),
                                              _m_pfadd(_m_pfmul(v384, v260), _m_pfmul(v380, v258))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v261, v392),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v260, v386), _m_pfmul(v258, v382)),
                                              _m_pfmul(v259, v390)));
      }
    }
    else
    {
      v262 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v263 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a4->m64_u64, 0);
      a1[1].m64_u64 = 0;
      a1[2].m64_u64 = (unsigned __int64)v263;
      a1[3].m64_u64 = 0;
      a1[4].m64_u64 = 0;
      a1[5].m64_u64 = (unsigned __int64)v262;
      a1[6].m64_u64 = 0;
      a1[7].m64_u64 = 0x3F80000000000000LL;
    }
  }
  else
  {
    v264 = _mm_cvtsi32_si64(0x3F800000u);
    v265 = _m_punpckldq(_m_punpckhdq(v264, v264), v264);
    a1->m64_u64 = (unsigned __int64)v264;
    a1[1].m64_u64 = 0;
    a1[2].m64_u64 = (unsigned __int64)v265;
    a1[3].m64_u64 = 0;
    a1[4].m64_u64 = 0;
    a1[5].m64_u64 = (unsigned __int64)v264;
    a1[6].m64_u64 = 0;
    a1[7].m64_u64 = (unsigned __int64)v265;
  }
  if ( a6 )
  {
    v266 = (__m64)a6->m64_u64;
    v267 = _m_pfadd(v266, v266);
    v268 = a6[1];
    v269 = _m_punpckhdq(v266, v266);
    v270 = _m_punpckhdq(v268, v268);
    v271 = _m_pfmul((__m64)a6->m64_u64, v267);
    v272 = _m_punpckldq(_m_pfadd(v268, v268), v267);
    v273 = _m_pfmul(v267, v270);
    v274 = _m_pfmul(_m_punpckldq(v268, v268), v272);
    v275 = _m_pfmul(v272, v270);
    v276 = _m_pfmul(v272, v269);
    v277 = _m_punpckhdq(v276, v274);
    v278 = _m_punpckhdq(_m_punpckldq(v275, v275), v273);
    v279 = _m_pfsubr(_m_pfadd(_m_punpckldq(v274, v274), v271), (__m64)0x3F8000003F800000LL);
    v391 = _m_punpckldq(_m_pfsubr(_m_pfacc(v271, v271), (__m64)0x3F8000003F800000LL), 0);
    v280 = v276;
    v281 = _m_pfadd(v276, v273);
    v282 = _m_pfsub(v280, v273);
    v283 = _m_pfsub(v277, v278);
    v284 = _m_punpckldq(v281, 0);
    v285 = _m_pfadd(v277, v278);
    v387 = v284;
    v383 = _m_punpckhdq(v283, 0);
    v385 = _m_punpckldq(v283, v279);
    v381 = _m_punpckhdq(v279, _m_punpckldq(v285, v285));
    v389 = _m_punpckldq(_m_punpckhdq(v285, v285), v282);
    v393 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a5 )
    {
      v286 = (__m64)a5->m64_u64;
      v287 = _mm_cvtsi32_si64(a5[1].m64_u32[0]);
      v288 = _m_pfsub(_mm_cvtsi32_si64(result[7].m64_u32[0]), v287);
      result[6].m64_u64 = (unsigned __int64)_m_pfsub(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v288);
      v289 = result[1];
      v290 = _m_punpckhdq(v286, (__m64)result->m64_u64);
      v291 = _m_punpckhdq(v287, v289);
      v292 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v293 = _m_punpckldq(v289, v289);
      v294 = _m_punpckhdq(v290, v290);
      v295 = _m_pfmul(v385, v294);
      v296 = _m_punpckhdq(v291, v291);
      v297 = _m_pfadd(_m_pfadd(_m_pfmul(v294, v387), _m_pfmul(v292, v383)), _m_pfmul(v293, v391));
      v298 = _m_pfadd(_m_pfmul(0, v296), _m_pfadd(_m_pfmul(v389, v293), _m_pfadd(v295, _m_pfmul(v381, v292))));
      v299 = result[2];
      v300 = _m_pfadd(_m_pfmul(v296, v393), v297);
      v301 = result[3];
      result->m64_u64 = (unsigned __int64)v298;
      result[1].m64_u64 = (unsigned __int64)v300;
      v302 = _m_punpckhdq(v297, v299);
      v303 = _m_punpckhdq(v300, v301);
      v304 = _m_punpckldq(v299, v299);
      v305 = _m_punpckldq(v301, v301);
      v306 = _m_punpckhdq(v302, v302);
      v307 = _m_pfmul(v385, v306);
      v308 = _m_punpckhdq(v303, v303);
      v309 = _m_pfadd(_m_pfadd(_m_pfmul(v306, v387), _m_pfmul(v304, v383)), _m_pfmul(v305, v391));
      v310 = _m_pfadd(_m_pfmul(0, v308), _m_pfadd(_m_pfmul(v389, v305), _m_pfadd(v307, _m_pfmul(v381, v304))));
      v311 = result[4];
      v312 = _m_pfadd(_m_pfmul(v308, v393), v309);
      v313 = result[5];
      result[2].m64_u64 = (unsigned __int64)v310;
      result[3].m64_u64 = (unsigned __int64)v312;
      v314 = _m_punpckhdq(v309, v311);
      v315 = _m_punpckhdq(v312, v313);
      v316 = _m_punpckldq(v311, v311);
      v317 = _m_punpckldq(v313, v313);
      v318 = _m_punpckhdq(v314, v314);
      v319 = _m_pfmul(v385, v318);
      v320 = _m_punpckhdq(v315, v315);
      v321 = _m_pfadd(_m_pfadd(_m_pfmul(v318, v387), _m_pfmul(v316, v383)), _m_pfmul(v317, v391));
      v322 = _m_pfadd(_m_pfmul(0, v320), _m_pfadd(_m_pfmul(v389, v317), _m_pfadd(v319, _m_pfmul(v381, v316))));
      v323 = result[6];
      v324 = _m_pfadd(_m_pfmul(v320, v393), v321);
      v325 = result[7];
      result[4].m64_u64 = (unsigned __int64)v322;
      result[5].m64_u64 = (unsigned __int64)v324;
      v326 = _m_punpckhdq(v321, v323);
      v327 = _m_punpckhdq(v324, v325);
      v328 = _m_punpckldq(v323, v323);
      v329 = _m_punpckldq(v325, v325);
      v330 = _m_punpckhdq(v326, v326);
      v331 = _m_punpckhdq(v327, v327);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v331),
                                              _m_pfadd(
                                                _m_pfmul(v389, v329),
                                                _m_pfadd(_m_pfmul(v385, v330), _m_pfmul(v381, v328))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v331, v393),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v330, v387), _m_pfmul(v328, v383)),
                                                _m_pfmul(v329, v391)));
      v332 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a5[1].m64_u32[0]));
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v332);
    }
    else
    {
      v333 = result[1];
      v334 = _m_punpckhdq(v284, (__m64)result->m64_u64);
      v335 = _m_punpckhdq(v282, v333);
      v336 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v337 = _m_punpckldq(v333, v333);
      v338 = _m_punpckhdq(v334, v334);
      v339 = _m_pfmul(v385, v338);
      v340 = _m_punpckhdq(v335, v335);
      v341 = _m_pfadd(_m_pfadd(_m_pfmul(v338, v387), _m_pfmul(v336, v383)), _m_pfmul(v337, v391));
      v342 = _m_pfadd(_m_pfmul(0, v340), _m_pfadd(_m_pfmul(v389, v337), _m_pfadd(v339, _m_pfmul(v381, v336))));
      v343 = result[2];
      v344 = _m_pfadd(_m_pfmul(v340, v393), v341);
      v345 = result[3];
      result->m64_u64 = (unsigned __int64)v342;
      result[1].m64_u64 = (unsigned __int64)v344;
      v346 = _m_punpckhdq(v341, v343);
      v347 = _m_punpckhdq(v344, v345);
      v348 = _m_punpckldq(v343, v343);
      v349 = _m_punpckldq(v345, v345);
      v350 = _m_punpckhdq(v346, v346);
      v351 = _m_pfmul(v385, v350);
      v352 = _m_punpckhdq(v347, v347);
      v353 = _m_pfadd(_m_pfadd(_m_pfmul(v350, v387), _m_pfmul(v348, v383)), _m_pfmul(v349, v391));
      v354 = _m_pfadd(_m_pfmul(0, v352), _m_pfadd(_m_pfmul(v389, v349), _m_pfadd(v351, _m_pfmul(v381, v348))));
      v355 = result[4];
      v356 = _m_pfadd(_m_pfmul(v352, v393), v353);
      v357 = result[5];
      result[2].m64_u64 = (unsigned __int64)v354;
      result[3].m64_u64 = (unsigned __int64)v356;
      v358 = _m_punpckhdq(v353, v355);
      v359 = _m_punpckhdq(v356, v357);
      v360 = _m_punpckldq(v355, v355);
      v361 = _m_punpckldq(v357, v357);
      v362 = _m_punpckhdq(v358, v358);
      v363 = _m_pfmul(v385, v362);
      v364 = _m_punpckhdq(v359, v359);
      v365 = _m_pfadd(_m_pfadd(_m_pfmul(v362, v387), _m_pfmul(v360, v383)), _m_pfmul(v361, v391));
      v366 = _m_pfadd(_m_pfmul(0, v364), _m_pfadd(_m_pfmul(v389, v361), _m_pfadd(v363, _m_pfmul(v381, v360))));
      v367 = result[6];
      v368 = _m_pfadd(_m_pfmul(v364, v393), v365);
      v369 = result[7];
      result[4].m64_u64 = (unsigned __int64)v366;
      result[5].m64_u64 = (unsigned __int64)v368;
      v370 = _m_punpckhdq(v365, v367);
      v371 = _m_punpckhdq(v368, v369);
      v372 = _m_punpckldq(v367, v367);
      v373 = _m_punpckldq(v369, v369);
      v374 = _m_punpckhdq(v370, v370);
      v375 = _m_punpckhdq(v371, v371);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v375),
                                              _m_pfadd(
                                                _m_pfmul(v389, v373),
                                                _m_pfadd(_m_pfmul(v385, v374), _m_pfmul(v381, v372))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v375, v393),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v374, v387), _m_pfmul(v372, v383)),
                                                _m_pfmul(v373, v391)));
    }
  }
  if ( a7 )
  {
    v376 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a7[1].m64_u32[0]));
    result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a7->m64_u64);
    result[7].m64_i32[0] = _mm_cvtsi64_si32(v376);
  }
  _m_femms();
  return result;
}

// sub_1002AE7A @ 0x1002AE7A
__m64 *__userpurge sub_1002AE7A@<eax>(__m64 *a1, __m64 a2, __m64 a3)
{
  __m64 v3; // mm0
  __m64 v4; // mm6
  __m64 v5; // mm2
  __m64 v6; // mm6
  __m64 v7; // mm7
  __m64 v9; // mm3
  __m64 v10; // mm0
  __m64 v11; // mm7
  __m64 v12; // mm2
  __m64 v13; // mm4
  __m64 v14; // mm3
  __m64 v15; // mm1
  __m64 v16; // mm5
  __m64 v17; // mm7
  __m64 v18; // mm6
  __m64 v19; // mm2
  __m64 v20; // mm1
  __m64 v21; // mm6
  __m64 v22; // mm7
  __m64 v23; // mm3
  __m64 v24; // mm2
  __m64 v25; // mm3
  __m64 v26; // mm5
  __m64 v27; // mm6
  __m64 v28; // [esp+8h] [ebp-28h]
  __m64 v29; // [esp+28h] [ebp-8h]

  sub_100354E0();
  v28 = _m_pfmul((__m64)0x3F0000003F000000LL, a3);
  sub_100354E0();
  v3 = _m_pfmul((__m64)0x3F0000003F000000LL, a2);
  sub_100354E0();
  v4 = _m_punpckhdq(v3, v3);
  v5 = _m_punpckldq(v4, v4);
  v6 = _m_punpckhdq(v4, v4);
  v7 = _m_punpckldq(_m_punpckhdq(v28, v28), v28);
  v29 = _m_pfadd(
          _m_pfmul(_m_pfmul(_m_punpckldq(v3, v3), v5), v7),
          _m_pfmul(_m_pfmul(_m_pxor(_m_punpckhdq(v3, v3), _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u)), v6), v28));
  v9 = _m_pfadd(
         _m_pfmul(_m_pfmul(_m_pxor(_m_punpckldq(v3, v3), (__m64)0x8000000000000000uLL), v6), v28),
         _m_pfmul(_m_pfmul(_m_punpckhdq(v3, v3), v5), v7));
  v10 = _m_pfadd(v9, v9);
  v11 = v29;
  v12 = _m_punpckhdq(v9, v9);
  v13 = _m_punpckhdq(v11, v11);
  v14 = _m_pfmul(v9, v10);
  v15 = _m_punpckldq(_m_pfadd(v11, v11), v10);
  v16 = _m_pfmul(v10, v13);
  v17 = _m_pfmul(_m_punpckldq(v11, v11), v15);
  v18 = _m_pfmul(v15, v13);
  v19 = _m_pfmul(v15, v12);
  v20 = _m_punpckhdq(v19, v17);
  a1[6].m64_u64 = 0;
  v21 = _m_punpckhdq(_m_punpckldq(v18, v18), v16);
  v22 = _m_pfsubr(_m_pfadd(_m_punpckldq(v17, v17), v14), (__m64)0x3F8000003F800000LL);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsubr(_m_pfacc(v14, v14), (__m64)0x3F8000003F800000LL), 0);
  v23 = v19;
  v24 = _m_pfadd(v19, v16);
  v25 = _m_pfsub(v23, v16);
  v26 = _m_pfsub(v20, v21);
  v27 = _m_pfadd(v20, v21);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v24, 0);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v26, 0);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v26, v22);
  a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v22, _m_punpckldq(v27, v27));
  a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpckhdq(v27, v27), v25);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(0, (__m64)1065353216LL);
  _m_femms();
  return a1;
}

// sub_1002B01F @ 0x1002B01F
__m64 *__stdcall sub_1002B01F(__m64 *a1, unsigned int a2, __m64 *a3, __m64 *a4, __m64 *a5)
{
  __m64 *result; // eax
  __m64 v6; // mm6
  __m64 m64_u64; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm7
  __m64 v10; // mm2
  __m64 v11; // mm4
  __m64 v12; // mm3
  __m64 v13; // mm1
  __m64 v14; // mm5
  __m64 v15; // mm7
  __m64 v16; // mm6
  __m64 v17; // mm2
  __m64 v18; // mm1
  __m64 v19; // mm6
  __m64 v20; // mm7
  __m64 v21; // mm3
  __m64 v22; // mm2
  __m64 v23; // mm3
  __m64 v24; // mm5
  __m64 v25; // mm2
  __m64 v26; // mm6
  __m64 v27; // mm2
  __m64 v28; // mm3
  __m64 v29; // mm1
  __m64 v30; // mm1
  __m64 v31; // mm2
  __m64 v32; // mm3
  __m64 v33; // mm0
  __m64 v34; // mm1
  __m64 v35; // mm2
  __m64 v36; // mm5
  __m64 v37; // mm3
  __m64 v38; // mm2
  __m64 v39; // mm7
  __m64 v40; // mm0
  __m64 v41; // mm3
  __m64 v42; // mm1
  __m64 v43; // mm2
  __m64 v44; // mm3
  __m64 v45; // mm0
  __m64 v46; // mm1
  __m64 v47; // mm2
  __m64 v48; // mm5
  __m64 v49; // mm3
  __m64 v50; // mm2
  __m64 v51; // mm7
  __m64 v52; // mm0
  __m64 v53; // mm3
  __m64 v54; // mm1
  __m64 v55; // mm2
  __m64 v56; // mm3
  __m64 v57; // mm0
  __m64 v58; // mm1
  __m64 v59; // mm2
  __m64 v60; // mm5
  __m64 v61; // mm3
  __m64 v62; // mm2
  __m64 v63; // mm7
  __m64 v64; // mm0
  __m64 v65; // mm3
  __m64 v66; // mm1
  __m64 v67; // mm2
  __m64 v68; // mm3
  __m64 v69; // mm0
  __m64 v70; // mm1
  __m64 v71; // mm2
  __m64 v72; // mm3
  __m64 v73; // mm1
  __m64 v74; // mm1
  __m64 v75; // mm2
  __m64 v76; // mm3
  __m64 v77; // mm0
  __m64 v78; // mm1
  __m64 v79; // mm2
  __m64 v80; // mm5
  __m64 v81; // mm3
  __m64 v82; // mm2
  __m64 v83; // mm7
  __m64 v84; // mm0
  __m64 v85; // mm3
  __m64 v86; // mm1
  __m64 v87; // mm2
  __m64 v88; // mm3
  __m64 v89; // mm0
  __m64 v90; // mm1
  __m64 v91; // mm2
  __m64 v92; // mm5
  __m64 v93; // mm3
  __m64 v94; // mm2
  __m64 v95; // mm7
  __m64 v96; // mm0
  __m64 v97; // mm3
  __m64 v98; // mm1
  __m64 v99; // mm2
  __m64 v100; // mm3
  __m64 v101; // mm0
  __m64 v102; // mm1
  __m64 v103; // mm2
  __m64 v104; // mm5
  __m64 v105; // mm3
  __m64 v106; // mm2
  __m64 v107; // mm7
  __m64 v108; // mm0
  __m64 v109; // mm3
  __m64 v110; // mm1
  __m64 v111; // mm2
  __m64 v112; // mm3
  __m64 v113; // mm0
  __m64 v114; // mm1
  __m64 v115; // mm2
  __m64 v116; // mm3
  __m64 v117; // mm1
  __m64 v118; // [esp+0h] [ebp-40h]
  __m64 v119; // [esp+8h] [ebp-38h]
  __m64 v120; // [esp+10h] [ebp-30h]
  __m64 v121; // [esp+18h] [ebp-28h]
  __m64 v122; // [esp+20h] [ebp-20h]
  __m64 v123; // [esp+28h] [ebp-18h]
  __m64 v124; // [esp+38h] [ebp-8h]

  result = a1;
  v6 = _mm_cvtsi32_si64(a2);
  a1->m64_u64 = (unsigned __int64)v6;
  a1[1].m64_u64 = 0;
  a1[2].m64_i32[0] = _mm_cvtsi64_si32(0);
  a1[2].m64_i32[1] = _mm_cvtsi64_si32(v6);
  a1[3].m64_u64 = 0;
  a1[4].m64_u64 = 0;
  a1[5].m64_u64 = (unsigned __int64)v6;
  a1[6].m64_u64 = 0;
  a1[7].m64_u64 = 0x3F80000000000000LL;
  if ( a4 )
  {
    m64_u64 = (__m64)a4->m64_u64;
    v8 = _m_pfadd(m64_u64, m64_u64);
    v9 = a4[1];
    v10 = _m_punpckhdq(m64_u64, m64_u64);
    v11 = _m_punpckhdq(v9, v9);
    v12 = _m_pfmul((__m64)a4->m64_u64, v8);
    v13 = _m_punpckldq(_m_pfadd(v9, v9), v8);
    v14 = _m_pfmul(v8, v11);
    v15 = _m_pfmul(_m_punpckldq(v9, v9), v13);
    v16 = _m_pfmul(v13, v11);
    v17 = _m_pfmul(v13, v10);
    v18 = _m_punpckhdq(v17, v15);
    v19 = _m_punpckhdq(_m_punpckldq(v16, v16), v14);
    v20 = _m_pfsubr(_m_pfadd(_m_punpckldq(v15, v15), v12), (__m64)0x3F8000003F800000LL);
    v123 = _m_punpckldq(_m_pfsubr(_m_pfacc(v12, v12), (__m64)0x3F8000003F800000LL), 0);
    v21 = v17;
    v22 = _m_pfadd(v17, v14);
    v23 = _m_pfsub(v21, v14);
    v24 = _m_pfsub(v18, v19);
    v25 = _m_punpckldq(v22, 0);
    v26 = _m_pfadd(v18, v19);
    v121 = v25;
    v119 = _m_punpckhdq(v24, 0);
    v120 = _m_punpckldq(v24, v20);
    v118 = _m_punpckhdq(v20, _m_punpckldq(v26, v26));
    v122 = _m_punpckldq(_m_punpckhdq(v26, v26), v23);
    v124 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a3 )
    {
      v27 = (__m64)a3->m64_u64;
      v28 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
      v29 = _m_pfsub(_mm_cvtsi32_si64(a1[7].m64_u32[0]), v28);
      a1[6].m64_u64 = (unsigned __int64)_m_pfsub(a1[6], (__m64)a3->m64_u64);
      a1[7].m64_i32[0] = _mm_cvtsi64_si32(v29);
      v30 = a1[1];
      v31 = _m_punpckhdq(v27, (__m64)a1->m64_u64);
      v32 = _m_punpckhdq(v28, v30);
      v33 = _m_punpckldq((__m64)a1->m64_u64, (__m64)a1->m64_u64);
      v34 = _m_punpckldq(v30, v30);
      v35 = _m_punpckhdq(v31, v31);
      v36 = _m_pfmul(v120, v35);
      v37 = _m_punpckhdq(v32, v32);
      v38 = _m_pfadd(_m_pfadd(_m_pfmul(v35, v121), _m_pfmul(v33, v119)), _m_pfmul(v34, v123));
      v39 = _m_pfadd(_m_pfmul(0, v37), _m_pfadd(_m_pfmul(v122, v34), _m_pfadd(v36, _m_pfmul(v118, v33))));
      v40 = a1[2];
      v41 = _m_pfadd(_m_pfmul(v37, v124), v38);
      v42 = a1[3];
      a1->m64_u64 = (unsigned __int64)v39;
      a1[1].m64_u64 = (unsigned __int64)v41;
      v43 = _m_punpckhdq(v38, v40);
      v44 = _m_punpckhdq(v41, v42);
      v45 = _m_punpckldq(v40, v40);
      v46 = _m_punpckldq(v42, v42);
      v47 = _m_punpckhdq(v43, v43);
      v48 = _m_pfmul(v120, v47);
      v49 = _m_punpckhdq(v44, v44);
      v50 = _m_pfadd(_m_pfadd(_m_pfmul(v47, v121), _m_pfmul(v45, v119)), _m_pfmul(v46, v123));
      v51 = _m_pfadd(_m_pfmul(0, v49), _m_pfadd(_m_pfmul(v122, v46), _m_pfadd(v48, _m_pfmul(v118, v45))));
      v52 = a1[4];
      v53 = _m_pfadd(_m_pfmul(v49, v124), v50);
      v54 = a1[5];
      a1[2].m64_u64 = (unsigned __int64)v51;
      a1[3].m64_u64 = (unsigned __int64)v53;
      v55 = _m_punpckhdq(v50, v52);
      v56 = _m_punpckhdq(v53, v54);
      v57 = _m_punpckldq(v52, v52);
      v58 = _m_punpckldq(v54, v54);
      v59 = _m_punpckhdq(v55, v55);
      v60 = _m_pfmul(v120, v59);
      v61 = _m_punpckhdq(v56, v56);
      v62 = _m_pfadd(_m_pfadd(_m_pfmul(v59, v121), _m_pfmul(v57, v119)), _m_pfmul(v58, v123));
      v63 = _m_pfadd(_m_pfmul(0, v61), _m_pfadd(_m_pfmul(v122, v58), _m_pfadd(v60, _m_pfmul(v118, v57))));
      v64 = a1[6];
      v65 = _m_pfadd(_m_pfmul(v61, v124), v62);
      v66 = a1[7];
      a1[4].m64_u64 = (unsigned __int64)v63;
      a1[5].m64_u64 = (unsigned __int64)v65;
      v67 = _m_punpckhdq(v62, v64);
      v68 = _m_punpckhdq(v65, v66);
      v69 = _m_punpckldq(v64, v64);
      v70 = _m_punpckldq(v66, v66);
      v71 = _m_punpckhdq(v67, v67);
      v72 = _m_punpckhdq(v68, v68);
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(0, v72),
                                          _m_pfadd(
                                            _m_pfmul(v122, v70),
                                            _m_pfadd(_m_pfmul(v120, v71), _m_pfmul(v118, v69))));
      a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(v72, v124),
                                          _m_pfadd(
                                            _m_pfadd(_m_pfmul(v71, v121), _m_pfmul(v69, v119)),
                                            _m_pfmul(v70, v123)));
      v73 = _m_pfadd(_mm_cvtsi32_si64(a1[7].m64_u32[0]), _mm_cvtsi32_si64(a3[1].m64_u32[0]));
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(a1[6], (__m64)a3->m64_u64);
      a1[7].m64_i32[0] = _mm_cvtsi64_si32(v73);
    }
    else
    {
      v74 = a1[1];
      v75 = _m_punpckhdq(v25, (__m64)a1->m64_u64);
      v76 = _m_punpckhdq(v23, v74);
      v77 = _m_punpckldq((__m64)a1->m64_u64, (__m64)a1->m64_u64);
      v78 = _m_punpckldq(v74, v74);
      v79 = _m_punpckhdq(v75, v75);
      v80 = _m_pfmul(v120, v79);
      v81 = _m_punpckhdq(v76, v76);
      v82 = _m_pfadd(_m_pfadd(_m_pfmul(v79, v121), _m_pfmul(v77, v119)), _m_pfmul(v78, v123));
      v83 = _m_pfadd(_m_pfmul(0, v81), _m_pfadd(_m_pfmul(v122, v78), _m_pfadd(v80, _m_pfmul(v118, v77))));
      v84 = a1[2];
      v85 = _m_pfadd(_m_pfmul(v81, v124), v82);
      v86 = a1[3];
      a1->m64_u64 = (unsigned __int64)v83;
      a1[1].m64_u64 = (unsigned __int64)v85;
      v87 = _m_punpckhdq(v82, v84);
      v88 = _m_punpckhdq(v85, v86);
      v89 = _m_punpckldq(v84, v84);
      v90 = _m_punpckldq(v86, v86);
      v91 = _m_punpckhdq(v87, v87);
      v92 = _m_pfmul(v120, v91);
      v93 = _m_punpckhdq(v88, v88);
      v94 = _m_pfadd(_m_pfadd(_m_pfmul(v91, v121), _m_pfmul(v89, v119)), _m_pfmul(v90, v123));
      v95 = _m_pfadd(_m_pfmul(0, v93), _m_pfadd(_m_pfmul(v122, v90), _m_pfadd(v92, _m_pfmul(v118, v89))));
      v96 = a1[4];
      v97 = _m_pfadd(_m_pfmul(v93, v124), v94);
      v98 = a1[5];
      a1[2].m64_u64 = (unsigned __int64)v95;
      a1[3].m64_u64 = (unsigned __int64)v97;
      v99 = _m_punpckhdq(v94, v96);
      v100 = _m_punpckhdq(v97, v98);
      v101 = _m_punpckldq(v96, v96);
      v102 = _m_punpckldq(v98, v98);
      v103 = _m_punpckhdq(v99, v99);
      v104 = _m_pfmul(v120, v103);
      v105 = _m_punpckhdq(v100, v100);
      v106 = _m_pfadd(_m_pfadd(_m_pfmul(v103, v121), _m_pfmul(v101, v119)), _m_pfmul(v102, v123));
      v107 = _m_pfadd(_m_pfmul(0, v105), _m_pfadd(_m_pfmul(v122, v102), _m_pfadd(v104, _m_pfmul(v118, v101))));
      v108 = a1[6];
      v109 = _m_pfadd(_m_pfmul(v105, v124), v106);
      v110 = a1[7];
      a1[4].m64_u64 = (unsigned __int64)v107;
      a1[5].m64_u64 = (unsigned __int64)v109;
      v111 = _m_punpckhdq(v106, v108);
      v112 = _m_punpckhdq(v109, v110);
      v113 = _m_punpckldq(v108, v108);
      v114 = _m_punpckldq(v110, v110);
      v115 = _m_punpckhdq(v111, v111);
      v116 = _m_punpckhdq(v112, v112);
      a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(0, v116),
                                          _m_pfadd(
                                            _m_pfmul(v122, v114),
                                            _m_pfadd(_m_pfmul(v120, v115), _m_pfmul(v118, v113))));
      a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                          _m_pfmul(v116, v124),
                                          _m_pfadd(
                                            _m_pfadd(_m_pfmul(v115, v121), _m_pfmul(v113, v119)),
                                            _m_pfmul(v114, v123)));
    }
  }
  if ( a5 )
  {
    v117 = _m_pfadd(_mm_cvtsi32_si64(a5[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a5->m64_u64, a1[6]);
    a1[7].m64_i32[0] = _mm_cvtsi64_si32(v117);
  }
  _m_femms();
  return result;
}

// sub_1002B553 @ 0x1002B553
__m64 *__stdcall sub_1002B553(__m64 *a1, __m64 *a2, unsigned int a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm1
  __m64 v5; // mm0
  __m64 v6; // mm7
  __m64 v7; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v12; // mm3
  __m64 v13; // mm4
  __m64 v14; // mm5
  __m64 v15; // mm1
  __m64 v16; // mm1
  __m64 v17; // mm6
  __m64 v18; // mm7
  __m64 v19; // mm1
  __m64 v20; // mm6
  __m64 v21; // mm2
  __m64 v22; // mm1
  unsigned __int64 m64_u64; // [esp+0h] [ebp-18h] BYREF
  unsigned int v24; // [esp+8h] [ebp-10h]
  unsigned int v25; // [esp+Ch] [ebp-Ch]

  v3 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  m64_u64 = a2->m64_u64;
  v24 = _mm_cvtsi64_si32(v3);
  sub_1002D2C2((int)&m64_u64, (int)&m64_u64);
  sub_100354E0();
  v4 = _mm_cvtsi32_si64(a3);
  v5 = _m_pfsubr(v4, (__m64)0x3F8000003F800000LL);
  v25 = _mm_cvtsi64_si32(_m_punpckhdq(v4, v4));
  v6 = _mm_cvtsi32_si64(v24);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v5, v5);
  v9 = _m_punpckldq(v4, v4);
  v10 = _m_pfmul(_m_pfmul(_m_punpckhdq((__m64)m64_u64, v7), (__m64)m64_u64), v8);
  v12 = _m_pfmul(_m_pfmul(v7, (__m64)m64_u64), v8);
  v13 = _m_pfadd(_m_pfmul(_m_pfmul((__m64)m64_u64, (__m64)m64_u64), v8), v9);
  v14 = _m_pfadd(_m_pfmul(_m_pfmul(v6, v6), v8), v9);
  v15 = _mm_cvtsi32_si64(v25);
  v16 = _m_punpckldq(v15, v15);
  v17 = _m_pfmul((__m64)m64_u64, v16);
  a1[6].m64_u64 = 0;
  v18 = _m_punpckldq(_m_pfmul(v6, v16), v17);
  v19 = v10;
  v20 = _m_punpckhdq(v17, v17);
  a1[5].m64_u64 = (unsigned __int64)_m_punpckldq(v14, 0);
  v21 = _m_pfsub(v10, v18);
  v22 = _m_pfadd(v19, v18);
  a1->m64_u64 = (unsigned __int64)_m_punpckldq(v13, v22);
  a1[1].m64_u64 = (unsigned __int64)_m_punpckldq(_m_pfsub(v12, v20), 0);
  a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v22, 0);
  a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(0, (__m64)0x3F8000003F800000LL);
  a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(_m_pfadd(_m_punpckldq(v12, v12), v20), v21);
  a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v21, _m_punpckhdq(v13, v13));
  _m_femms();
  return a1;
}

// sub_1002B66C @ 0x1002B66C
__m64 *__stdcall sub_1002B66C(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, __m64 *a6, __m64 *a7)
{
  __m64 *result; // eax
  __m64 v8; // mm4
  __m64 v9; // mm1
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm2
  __m64 v14; // mm3
  __m64 v15; // mm1
  __m64 v16; // mm6
  __m64 v17; // mm3
  __m64 v18; // mm6
  __m64 v19; // mm2
  __m64 v20; // mm1
  __m64 m64_u64; // mm3
  __m64 v22; // mm4
  __m64 v23; // mm1
  __m64 v24; // mm2
  __m64 v25; // mm2
  __m64 v26; // mm1
  __m64 v27; // mm2
  __m64 v28; // mm3
  __m64 v29; // mm0
  __m64 v30; // mm1
  __m64 v31; // mm2
  __m64 v32; // mm5
  __m64 v33; // mm3
  __m64 v34; // mm2
  __m64 v35; // mm7
  __m64 v36; // mm0
  __m64 v37; // mm3
  __m64 v38; // mm1
  __m64 v39; // mm2
  __m64 v40; // mm3
  __m64 v41; // mm0
  __m64 v42; // mm1
  __m64 v43; // mm2
  __m64 v44; // mm5
  __m64 v45; // mm3
  __m64 v46; // mm2
  __m64 v47; // mm7
  __m64 v48; // mm0
  __m64 v49; // mm3
  __m64 v50; // mm1
  __m64 v51; // mm2
  __m64 v52; // mm3
  __m64 v53; // mm0
  __m64 v54; // mm1
  __m64 v55; // mm2
  __m64 v56; // mm5
  __m64 v57; // mm3
  __m64 v58; // mm2
  __m64 v59; // mm7
  __m64 v60; // mm0
  __m64 v61; // mm3
  __m64 v62; // mm1
  __m64 v63; // mm2
  __m64 v64; // mm3
  __m64 v65; // mm0
  __m64 v66; // mm1
  __m64 v67; // mm2
  __m64 v68; // mm5
  __m64 v69; // mm3
  __m64 v70; // mm7
  __m64 v71; // mm2
  __m64 v72; // mm3
  __m64 v73; // mm1
  __m64 v74; // mm2
  __m64 v75; // mm3
  __m64 v76; // mm0
  __m64 v77; // mm1
  __m64 v78; // mm2
  __m64 v79; // mm5
  __m64 v80; // mm3
  __m64 v81; // mm2
  __m64 v82; // mm7
  __m64 v83; // mm0
  __m64 v84; // mm3
  __m64 v85; // mm1
  __m64 v86; // mm2
  __m64 v87; // mm3
  __m64 v88; // mm0
  __m64 v89; // mm1
  __m64 v90; // mm2
  __m64 v91; // mm5
  __m64 v92; // mm3
  __m64 v93; // mm2
  __m64 v94; // mm7
  __m64 v95; // mm0
  __m64 v96; // mm3
  __m64 v97; // mm1
  __m64 v98; // mm2
  __m64 v99; // mm3
  __m64 v100; // mm0
  __m64 v101; // mm1
  __m64 v102; // mm2
  __m64 v103; // mm5
  __m64 v104; // mm3
  __m64 v105; // mm2
  __m64 v106; // mm7
  __m64 v107; // mm0
  __m64 v108; // mm3
  __m64 v109; // mm1
  __m64 v110; // mm2
  __m64 v111; // mm3
  __m64 v112; // mm0
  __m64 v113; // mm1
  __m64 v114; // mm2
  __m64 v115; // mm5
  __m64 v116; // mm3
  __m64 v117; // mm7
  __m64 v118; // mm2
  __m64 v119; // mm3
  __m64 v120; // mm1
  __m64 v121; // mm2
  __m64 v122; // mm3
  __m64 v123; // mm0
  __m64 v124; // mm1
  __m64 v125; // mm2
  __m64 v126; // mm5
  __m64 v127; // mm3
  __m64 v128; // mm2
  __m64 v129; // mm7
  __m64 v130; // mm0
  __m64 v131; // mm3
  __m64 v132; // mm1
  __m64 v133; // mm2
  __m64 v134; // mm3
  __m64 v135; // mm0
  __m64 v136; // mm1
  __m64 v137; // mm2
  __m64 v138; // mm5
  __m64 v139; // mm3
  __m64 v140; // mm2
  __m64 v141; // mm7
  __m64 v142; // mm0
  __m64 v143; // mm3
  __m64 v144; // mm1
  __m64 v145; // mm2
  __m64 v146; // mm3
  __m64 v147; // mm0
  __m64 v148; // mm1
  __m64 v149; // mm2
  __m64 v150; // mm5
  __m64 v151; // mm3
  __m64 v152; // mm2
  __m64 v153; // mm7
  __m64 v154; // mm0
  __m64 v155; // mm3
  __m64 v156; // mm1
  __m64 v157; // mm2
  __m64 v158; // mm3
  __m64 v159; // mm0
  __m64 v160; // mm1
  __m64 v161; // mm2
  __m64 v162; // mm3
  __m64 v163; // mm2
  __m64 v164; // mm3
  __m64 v165; // mm2
  __m64 v166; // mm1
  __m64 v167; // mm2
  __m64 v168; // mm3
  __m64 v169; // mm0
  __m64 v170; // mm1
  __m64 v171; // mm2
  __m64 v172; // mm5
  __m64 v173; // mm3
  __m64 v174; // mm2
  __m64 v175; // mm7
  __m64 v176; // mm0
  __m64 v177; // mm3
  __m64 v178; // mm1
  __m64 v179; // mm2
  __m64 v180; // mm3
  __m64 v181; // mm0
  __m64 v182; // mm1
  __m64 v183; // mm2
  __m64 v184; // mm5
  __m64 v185; // mm3
  __m64 v186; // mm2
  __m64 v187; // mm7
  __m64 v188; // mm0
  __m64 v189; // mm3
  __m64 v190; // mm1
  __m64 v191; // mm2
  __m64 v192; // mm3
  __m64 v193; // mm0
  __m64 v194; // mm1
  __m64 v195; // mm2
  __m64 v196; // mm5
  __m64 v197; // mm3
  __m64 v198; // mm2
  __m64 v199; // mm7
  __m64 v200; // mm0
  __m64 v201; // mm3
  __m64 v202; // mm1
  __m64 v203; // mm2
  __m64 v204; // mm3
  __m64 v205; // mm0
  __m64 v206; // mm1
  __m64 v207; // mm2
  __m64 v208; // mm5
  __m64 v209; // mm3
  __m64 v210; // mm7
  __m64 v211; // mm2
  __m64 v212; // mm3
  __m64 v213; // mm1
  __m64 v214; // mm2
  __m64 v215; // mm3
  __m64 v216; // mm0
  __m64 v217; // mm1
  __m64 v218; // mm2
  __m64 v219; // mm5
  __m64 v220; // mm3
  __m64 v221; // mm2
  __m64 v222; // mm7
  __m64 v223; // mm0
  __m64 v224; // mm3
  __m64 v225; // mm1
  __m64 v226; // mm2
  __m64 v227; // mm3
  __m64 v228; // mm0
  __m64 v229; // mm1
  __m64 v230; // mm2
  __m64 v231; // mm5
  __m64 v232; // mm3
  __m64 v233; // mm2
  __m64 v234; // mm7
  __m64 v235; // mm0
  __m64 v236; // mm3
  __m64 v237; // mm1
  __m64 v238; // mm2
  __m64 v239; // mm3
  __m64 v240; // mm0
  __m64 v241; // mm1
  __m64 v242; // mm2
  __m64 v243; // mm5
  __m64 v244; // mm3
  __m64 v245; // mm2
  __m64 v246; // mm7
  __m64 v247; // mm0
  __m64 v248; // mm3
  __m64 v249; // mm1
  __m64 v250; // mm2
  __m64 v251; // mm3
  __m64 v252; // mm0
  __m64 v253; // mm1
  __m64 v254; // mm2
  __m64 v255; // mm3
  __m64 v256; // mm4
  __m64 v257; // mm5
  __m64 v258; // mm1
  __m64 v259; // mm2
  __m64 v260; // mm4
  __m64 v261; // mm1
  __m64 v262; // mm5
  __m64 v263; // mm0
  __m64 v264; // mm5
  __m64 v265; // mm2
  __m64 v266; // mm3
  __m64 v267; // mm1
  __m64 v268; // mm6
  __m64 v269; // mm3
  __m64 v270; // mm6
  __m64 v271; // mm2
  __m64 v272; // mm1
  __m64 v273; // mm5
  __m64 v274; // mm2
  __m64 v275; // mm3
  __m64 v276; // mm2
  __m64 v277; // mm3
  __m64 v278; // mm1
  __m64 v279; // mm1
  __m64 v280; // mm2
  __m64 v281; // mm3
  __m64 v282; // mm0
  __m64 v283; // mm1
  __m64 v284; // mm2
  __m64 v285; // mm5
  __m64 v286; // mm3
  __m64 v287; // mm2
  __m64 v288; // mm7
  __m64 v289; // mm0
  __m64 v290; // mm3
  __m64 v291; // mm1
  __m64 v292; // mm2
  __m64 v293; // mm3
  __m64 v294; // mm0
  __m64 v295; // mm1
  __m64 v296; // mm2
  __m64 v297; // mm5
  __m64 v298; // mm3
  __m64 v299; // mm2
  __m64 v300; // mm7
  __m64 v301; // mm0
  __m64 v302; // mm3
  __m64 v303; // mm1
  __m64 v304; // mm2
  __m64 v305; // mm3
  __m64 v306; // mm0
  __m64 v307; // mm1
  __m64 v308; // mm2
  __m64 v309; // mm5
  __m64 v310; // mm3
  __m64 v311; // mm2
  __m64 v312; // mm7
  __m64 v313; // mm0
  __m64 v314; // mm3
  __m64 v315; // mm1
  __m64 v316; // mm2
  __m64 v317; // mm3
  __m64 v318; // mm0
  __m64 v319; // mm1
  __m64 v320; // mm2
  __m64 v321; // mm3
  __m64 v322; // mm1
  __m64 v323; // mm1
  __m64 v324; // mm2
  __m64 v325; // mm3
  __m64 v326; // mm0
  __m64 v327; // mm1
  __m64 v328; // mm2
  __m64 v329; // mm5
  __m64 v330; // mm3
  __m64 v331; // mm2
  __m64 v332; // mm7
  __m64 v333; // mm0
  __m64 v334; // mm3
  __m64 v335; // mm1
  __m64 v336; // mm2
  __m64 v337; // mm3
  __m64 v338; // mm0
  __m64 v339; // mm1
  __m64 v340; // mm2
  __m64 v341; // mm5
  __m64 v342; // mm3
  __m64 v343; // mm2
  __m64 v344; // mm7
  __m64 v345; // mm0
  __m64 v346; // mm3
  __m64 v347; // mm1
  __m64 v348; // mm2
  __m64 v349; // mm3
  __m64 v350; // mm0
  __m64 v351; // mm1
  __m64 v352; // mm2
  __m64 v353; // mm5
  __m64 v354; // mm3
  __m64 v355; // mm2
  __m64 v356; // mm7
  __m64 v357; // mm0
  __m64 v358; // mm3
  __m64 v359; // mm1
  __m64 v360; // mm2
  __m64 v361; // mm3
  __m64 v362; // mm0
  __m64 v363; // mm1
  __m64 v364; // mm2
  __m64 v365; // mm3
  __m64 v366; // mm1
  __m64 v367; // [esp+0h] [ebp-C0h]
  __m64 v368; // [esp+10h] [ebp-B0h]
  __m64 v369; // [esp+28h] [ebp-98h]
  __m64 v370; // [esp+40h] [ebp-80h]
  __m64 v371; // [esp+40h] [ebp-80h]
  __m64 v372; // [esp+48h] [ebp-78h]
  __m64 v373; // [esp+48h] [ebp-78h]
  __m64 v374; // [esp+50h] [ebp-70h]
  __m64 v375; // [esp+50h] [ebp-70h]
  __m64 v376; // [esp+58h] [ebp-68h]
  __m64 v377; // [esp+58h] [ebp-68h]
  __m64 v378; // [esp+60h] [ebp-60h]
  __m64 v379; // [esp+60h] [ebp-60h]
  __m64 v380; // [esp+68h] [ebp-58h]
  __m64 v381; // [esp+68h] [ebp-58h]
  __m64 v382; // [esp+78h] [ebp-48h]
  __m64 v383; // [esp+78h] [ebp-48h]
  __m64 v384; // [esp+80h] [ebp-40h]
  __m64 v385; // [esp+88h] [ebp-38h]
  __m64 v386; // [esp+90h] [ebp-30h]
  __m64 v387; // [esp+98h] [ebp-28h]
  __m64 v388; // [esp+A0h] [ebp-20h]
  __m64 v389; // [esp+A8h] [ebp-18h]
  __m64 v390; // [esp+B0h] [ebp-10h]
  __m64 v391; // [esp+B8h] [ebp-8h]

  result = a1;
  if ( a4 )
  {
    if ( a3 )
    {
      v367 = _m_punpckldq((__m64)a4->m64_u64, 0);
      v368 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      v369 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v8 = a3[1];
      v9 = _m_pfadd(v8, v8);
      v10 = _m_pfadd((__m64)a3->m64_u64, (__m64)a3->m64_u64);
      v11 = _m_pfmul(v10, (__m64)a3->m64_u64);
      v12 = _m_punpckldq(v10, v9);
      v13 = _m_pfmul((__m64)a3->m64_u64, v9);
      v14 = _m_pfmul(_m_pswapd((__m64)a3->m64_u64), v9);
      v15 = _m_pfmul(v9, v8);
      v16 = _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v8), v12);
      v17 = _m_pfpnacc(v14, v14);
      v18 = _m_pfpnacc(v16, v16);
      v19 = _m_pfpnacc(v13, v13);
      v20 = _m_pfsub(_m_pfsubr(v11, (__m64)0x3F8000003F800000LL), _m_punpckldq(v15, v15));
      v378 = _m_punpckldq(_m_pswapd(v19), v17);
      v372 = _m_punpckldq(v19, 0);
      v380 = _m_punpckhdq(_m_pfsubr(_m_pfacc(v11, v11), (__m64)0x3F8000003F800000LL), 0);
      v370 = _m_punpckhdq(v20, v18);
      v374 = _m_punpckldq(v18, v20);
      v376 = _m_punpckhdq(v17, 0);
      v382 = _m_punpckldq(0, (__m64)1065353216LL);
      if ( a2 )
      {
        v384 = _m_punpckldq(v370, v374);
        v386 = _m_punpckhdq(v370, v374);
        v389 = _m_punpckldq(v380, v382);
        v391 = _m_punpckhdq(v380, v382);
        v388 = _m_punpckldq(v372, v376);
        v390 = _m_punpckhdq(v372, v376);
        v387 = _m_punpckhdq(v378, 0);
        v385 = _m_punpckldq(v378, 0);
        result = a1;
        m64_u64 = (__m64)a2->m64_u64;
        v22 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
        v23 = _mm_cvtsi32_si64(0x3F800000u);
        v24 = _m_pswapd(v23);
        a1->m64_u64 = (unsigned __int64)v23;
        a1[1].m64_u64 = 0;
        a1[2].m64_u64 = (unsigned __int64)v24;
        a1[3].m64_u64 = 0;
        a1[4].m64_u64 = 0;
        a1[5].m64_u64 = (unsigned __int64)v23;
        v25 = _m_pfsub(v24, v22);
        a1[7].m64_u64 = (unsigned __int64)v25;
        a1[6].m64_u64 = (unsigned __int64)_m_pfsub(0, m64_u64);
        v26 = a1[1];
        v27 = _m_punpckhdq(v25, (__m64)a1->m64_u64);
        v28 = _m_punpckhdq(m64_u64, v26);
        v29 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v30 = _m_punpckldq(v26, v26);
        v31 = _m_punpckhdq(v27, v27);
        v32 = _m_pfmul(v386, v31);
        v33 = _m_punpckhdq(v28, v28);
        v34 = _m_pfadd(_m_pfadd(_m_pfmul(v31, v387), _m_pfmul(v29, v385)), _m_pfmul(v30, v389));
        v35 = _m_pfadd(_m_pfmul(v390, v33), _m_pfadd(_m_pfmul(v388, v30), _m_pfadd(v32, _m_pfmul(v384, v29))));
        v36 = a1[2];
        v37 = _m_pfadd(_m_pfmul(v33, v391), v34);
        v38 = a1[3];
        a1->m64_u64 = (unsigned __int64)v35;
        a1[1].m64_u64 = (unsigned __int64)v37;
        v39 = _m_punpckhdq(v34, v36);
        v40 = _m_punpckhdq(v37, v38);
        v41 = _m_punpckldq(v36, v36);
        v42 = _m_punpckldq(v38, v38);
        v43 = _m_punpckhdq(v39, v39);
        v44 = _m_pfmul(v386, v43);
        v45 = _m_punpckhdq(v40, v40);
        v46 = _m_pfadd(_m_pfadd(_m_pfmul(v43, v387), _m_pfmul(v41, v385)), _m_pfmul(v42, v389));
        v47 = _m_pfadd(_m_pfmul(v390, v45), _m_pfadd(_m_pfmul(v388, v42), _m_pfadd(v44, _m_pfmul(v384, v41))));
        v48 = a1[4];
        v49 = _m_pfadd(_m_pfmul(v45, v391), v46);
        v50 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v47;
        a1[3].m64_u64 = (unsigned __int64)v49;
        v51 = _m_punpckhdq(v46, v48);
        v52 = _m_punpckhdq(v49, v50);
        v53 = _m_punpckldq(v48, v48);
        v54 = _m_punpckldq(v50, v50);
        v55 = _m_punpckhdq(v51, v51);
        v56 = _m_pfmul(v386, v55);
        v57 = _m_punpckhdq(v52, v52);
        v58 = _m_pfadd(_m_pfadd(_m_pfmul(v55, v387), _m_pfmul(v53, v385)), _m_pfmul(v54, v389));
        v59 = _m_pfadd(_m_pfmul(v390, v57), _m_pfadd(_m_pfmul(v388, v54), _m_pfadd(v56, _m_pfmul(v384, v53))));
        v60 = a1[6];
        v61 = _m_pfadd(_m_pfmul(v57, v391), v58);
        v62 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v59;
        a1[5].m64_u64 = (unsigned __int64)v61;
        v63 = _m_punpckhdq(v58, v60);
        v64 = _m_punpckhdq(v61, v62);
        v65 = _m_punpckldq(v60, v60);
        v66 = _m_punpckldq(v62, v62);
        v67 = _m_punpckhdq(v63, v63);
        v68 = _m_pfmul(v386, v67);
        v69 = _m_punpckhdq(v64, v64);
        v70 = _m_pfmul(v390, v69);
        v71 = _m_pfadd(_m_pfadd(_m_pfmul(v67, v387), _m_pfmul(v65, v385)), _m_pfmul(v66, v389));
        v72 = _m_pfadd(_m_pfmul(v69, v391), v71);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v70,
                                            _m_pfadd(_m_pfmul(v388, v66), _m_pfadd(v68, _m_pfmul(v384, v65))));
        a1[7].m64_u64 = (unsigned __int64)v72;
        v73 = a1[1];
        v74 = _m_punpckhdq(v71, (__m64)a1->m64_u64);
        v75 = _m_punpckhdq(v72, v73);
        v76 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v77 = _m_punpckldq(v73, v73);
        v78 = _m_punpckhdq(v74, v74);
        v79 = _m_pfmul(v368, v78);
        v80 = _m_punpckhdq(v75, v75);
        v81 = _m_pfadd(_m_pfadd(_m_pfmul(v78, 0), _m_pfmul(v76, 0)), _m_pfmul(v77, v369));
        v82 = _m_pfadd(_m_pfmul(0, v80), _m_pfadd(_m_pfmul(0, v77), _m_pfadd(v79, _m_pfmul(v367, v76))));
        v83 = a1[2];
        v84 = _m_pfadd(_m_pfmul(v80, (__m64)0x3F80000000000000LL), v81);
        v85 = a1[3];
        a1->m64_u64 = (unsigned __int64)v82;
        a1[1].m64_u64 = (unsigned __int64)v84;
        v86 = _m_punpckhdq(v81, v83);
        v87 = _m_punpckhdq(v84, v85);
        v88 = _m_punpckldq(v83, v83);
        v89 = _m_punpckldq(v85, v85);
        v90 = _m_punpckhdq(v86, v86);
        v91 = _m_pfmul(v368, v90);
        v92 = _m_punpckhdq(v87, v87);
        v93 = _m_pfadd(_m_pfadd(_m_pfmul(v90, 0), _m_pfmul(v88, 0)), _m_pfmul(v89, v369));
        v94 = _m_pfadd(_m_pfmul(0, v92), _m_pfadd(_m_pfmul(0, v89), _m_pfadd(v91, _m_pfmul(v367, v88))));
        v95 = a1[4];
        v96 = _m_pfadd(_m_pfmul(v92, (__m64)0x3F80000000000000LL), v93);
        v97 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v94;
        a1[3].m64_u64 = (unsigned __int64)v96;
        v98 = _m_punpckhdq(v93, v95);
        v99 = _m_punpckhdq(v96, v97);
        v100 = _m_punpckldq(v95, v95);
        v101 = _m_punpckldq(v97, v97);
        v102 = _m_punpckhdq(v98, v98);
        v103 = _m_pfmul(v368, v102);
        v104 = _m_punpckhdq(v99, v99);
        v105 = _m_pfadd(_m_pfadd(_m_pfmul(v102, 0), _m_pfmul(v100, 0)), _m_pfmul(v101, v369));
        v106 = _m_pfadd(_m_pfmul(0, v104), _m_pfadd(_m_pfmul(0, v101), _m_pfadd(v103, _m_pfmul(v367, v100))));
        v107 = a1[6];
        v108 = _m_pfadd(_m_pfmul(v104, (__m64)0x3F80000000000000LL), v105);
        v109 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v106;
        a1[5].m64_u64 = (unsigned __int64)v108;
        v110 = _m_punpckhdq(v105, v107);
        v111 = _m_punpckhdq(v108, v109);
        v112 = _m_punpckldq(v107, v107);
        v113 = _m_punpckldq(v109, v109);
        v114 = _m_punpckhdq(v110, v110);
        v115 = _m_pfmul(v368, v114);
        v116 = _m_punpckhdq(v111, v111);
        v117 = _m_pfmul(0, v116);
        v118 = _m_pfadd(_m_pfadd(_m_pfmul(v114, 0), _m_pfmul(v112, 0)), _m_pfmul(v113, v369));
        v119 = _m_pfadd(_m_pfmul(v116, (__m64)0x3F80000000000000LL), v118);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v117,
                                            _m_pfadd(_m_pfmul(0, v113), _m_pfadd(v115, _m_pfmul(v367, v112))));
        a1[7].m64_u64 = (unsigned __int64)v119;
        v120 = a1[1];
        v121 = _m_punpckhdq(v118, (__m64)a1->m64_u64);
        v122 = _m_punpckhdq(v119, v120);
        v123 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v124 = _m_punpckldq(v120, v120);
        v125 = _m_punpckhdq(v121, v121);
        v126 = _m_pfmul(v374, v125);
        v127 = _m_punpckhdq(v122, v122);
        v128 = _m_pfadd(_m_pfadd(_m_pfmul(v125, v376), _m_pfmul(v123, v372)), _m_pfmul(v124, v380));
        v129 = _m_pfadd(_m_pfmul(0, v127), _m_pfadd(_m_pfmul(v378, v124), _m_pfadd(v126, _m_pfmul(v370, v123))));
        v130 = a1[2];
        v131 = _m_pfadd(_m_pfmul(v127, v382), v128);
        v132 = a1[3];
        a1->m64_u64 = (unsigned __int64)v129;
        a1[1].m64_u64 = (unsigned __int64)v131;
        v133 = _m_punpckhdq(v128, v130);
        v134 = _m_punpckhdq(v131, v132);
        v135 = _m_punpckldq(v130, v130);
        v136 = _m_punpckldq(v132, v132);
        v137 = _m_punpckhdq(v133, v133);
        v138 = _m_pfmul(v374, v137);
        v139 = _m_punpckhdq(v134, v134);
        v140 = _m_pfadd(_m_pfadd(_m_pfmul(v137, v376), _m_pfmul(v135, v372)), _m_pfmul(v136, v380));
        v141 = _m_pfadd(_m_pfmul(0, v139), _m_pfadd(_m_pfmul(v378, v136), _m_pfadd(v138, _m_pfmul(v370, v135))));
        v142 = a1[4];
        v143 = _m_pfadd(_m_pfmul(v139, v382), v140);
        v144 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v141;
        a1[3].m64_u64 = (unsigned __int64)v143;
        v145 = _m_punpckhdq(v140, v142);
        v146 = _m_punpckhdq(v143, v144);
        v147 = _m_punpckldq(v142, v142);
        v148 = _m_punpckldq(v144, v144);
        v149 = _m_punpckhdq(v145, v145);
        v150 = _m_pfmul(v374, v149);
        v151 = _m_punpckhdq(v146, v146);
        v152 = _m_pfadd(_m_pfadd(_m_pfmul(v149, v376), _m_pfmul(v147, v372)), _m_pfmul(v148, v380));
        v153 = _m_pfadd(_m_pfmul(0, v151), _m_pfadd(_m_pfmul(v378, v148), _m_pfadd(v150, _m_pfmul(v370, v147))));
        v154 = a1[6];
        v155 = _m_pfadd(_m_pfmul(v151, v382), v152);
        v156 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v153;
        a1[5].m64_u64 = (unsigned __int64)v155;
        v157 = _m_punpckhdq(v152, v154);
        v158 = _m_punpckhdq(v155, v156);
        v159 = _m_punpckldq(v154, v154);
        v160 = _m_punpckldq(v156, v156);
        v161 = _m_punpckhdq(v157, v157);
        v162 = _m_punpckhdq(v158, v158);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v162),
                                            _m_pfadd(
                                              _m_pfmul(v378, v160),
                                              _m_pfadd(_m_pfmul(v374, v161), _m_pfmul(v370, v159))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v162, v382),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v161, v376), _m_pfmul(v159, v372)),
                                              _m_pfmul(v160, v380)));
        v163 = _m_pfadd(_mm_cvtsi32_si64(a2[1].m64_u32[0]), _mm_cvtsi32_si64(a1[7].m64_u32[0]));
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd((__m64)a2->m64_u64, a1[6]);
        a1[7].m64_i32[0] = _mm_cvtsi64_si32(v163);
      }
      else
      {
        result = a1;
        a1->m64_u64 = (unsigned __int64)_m_punpckldq(v370, v374);
        a1[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v370, v374);
        v164 = _m_punpckldq(v380, v382);
        a1[5].m64_u64 = (unsigned __int64)v164;
        a1[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v380, v382);
        a1[4].m64_u64 = (unsigned __int64)_m_punpckldq(v372, v376);
        v165 = _m_punpckldq(v378, 0);
        a1[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v372, v376);
        a1[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v378, 0);
        a1[1].m64_u64 = (unsigned __int64)v165;
        v166 = a1[1];
        v167 = _m_punpckhdq(v165, (__m64)a1->m64_u64);
        v168 = _m_punpckhdq(v164, v166);
        v169 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v170 = _m_punpckldq(v166, v166);
        v171 = _m_punpckhdq(v167, v167);
        v172 = _m_pfmul(v368, v171);
        v173 = _m_punpckhdq(v168, v168);
        v174 = _m_pfadd(_m_pfadd(_m_pfmul(v171, 0), _m_pfmul(v169, 0)), _m_pfmul(v170, v369));
        v175 = _m_pfadd(_m_pfmul(0, v173), _m_pfadd(_m_pfmul(0, v170), _m_pfadd(v172, _m_pfmul(v367, v169))));
        v176 = a1[2];
        v177 = _m_pfadd(_m_pfmul(v173, (__m64)0x3F80000000000000LL), v174);
        v178 = a1[3];
        a1->m64_u64 = (unsigned __int64)v175;
        a1[1].m64_u64 = (unsigned __int64)v177;
        v179 = _m_punpckhdq(v174, v176);
        v180 = _m_punpckhdq(v177, v178);
        v181 = _m_punpckldq(v176, v176);
        v182 = _m_punpckldq(v178, v178);
        v183 = _m_punpckhdq(v179, v179);
        v184 = _m_pfmul(v368, v183);
        v185 = _m_punpckhdq(v180, v180);
        v186 = _m_pfadd(_m_pfadd(_m_pfmul(v183, 0), _m_pfmul(v181, 0)), _m_pfmul(v182, v369));
        v187 = _m_pfadd(_m_pfmul(0, v185), _m_pfadd(_m_pfmul(0, v182), _m_pfadd(v184, _m_pfmul(v367, v181))));
        v188 = a1[4];
        v189 = _m_pfadd(_m_pfmul(v185, (__m64)0x3F80000000000000LL), v186);
        v190 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v187;
        a1[3].m64_u64 = (unsigned __int64)v189;
        v191 = _m_punpckhdq(v186, v188);
        v192 = _m_punpckhdq(v189, v190);
        v193 = _m_punpckldq(v188, v188);
        v194 = _m_punpckldq(v190, v190);
        v195 = _m_punpckhdq(v191, v191);
        v196 = _m_pfmul(v368, v195);
        v197 = _m_punpckhdq(v192, v192);
        v198 = _m_pfadd(_m_pfadd(_m_pfmul(v195, 0), _m_pfmul(v193, 0)), _m_pfmul(v194, v369));
        v199 = _m_pfadd(_m_pfmul(0, v197), _m_pfadd(_m_pfmul(0, v194), _m_pfadd(v196, _m_pfmul(v367, v193))));
        v200 = a1[6];
        v201 = _m_pfadd(_m_pfmul(v197, (__m64)0x3F80000000000000LL), v198);
        v202 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v199;
        a1[5].m64_u64 = (unsigned __int64)v201;
        v203 = _m_punpckhdq(v198, v200);
        v204 = _m_punpckhdq(v201, v202);
        v205 = _m_punpckldq(v200, v200);
        v206 = _m_punpckldq(v202, v202);
        v207 = _m_punpckhdq(v203, v203);
        v208 = _m_pfmul(v368, v207);
        v209 = _m_punpckhdq(v204, v204);
        v210 = _m_pfmul(0, v209);
        v211 = _m_pfadd(_m_pfadd(_m_pfmul(v207, 0), _m_pfmul(v205, 0)), _m_pfmul(v206, v369));
        v212 = _m_pfadd(_m_pfmul(v209, (__m64)0x3F80000000000000LL), v211);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            v210,
                                            _m_pfadd(_m_pfmul(0, v206), _m_pfadd(v208, _m_pfmul(v367, v205))));
        a1[7].m64_u64 = (unsigned __int64)v212;
        v213 = a1[1];
        v214 = _m_punpckhdq(v211, (__m64)a1->m64_u64);
        v215 = _m_punpckhdq(v212, v213);
        v216 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
        v217 = _m_punpckldq(v213, v213);
        v218 = _m_punpckhdq(v214, v214);
        v219 = _m_pfmul(v374, v218);
        v220 = _m_punpckhdq(v215, v215);
        v221 = _m_pfadd(_m_pfadd(_m_pfmul(v218, v376), _m_pfmul(v216, v372)), _m_pfmul(v217, v380));
        v222 = _m_pfadd(_m_pfmul(0, v220), _m_pfadd(_m_pfmul(v378, v217), _m_pfadd(v219, _m_pfmul(v370, v216))));
        v223 = a1[2];
        v224 = _m_pfadd(_m_pfmul(v220, v382), v221);
        v225 = a1[3];
        a1->m64_u64 = (unsigned __int64)v222;
        a1[1].m64_u64 = (unsigned __int64)v224;
        v226 = _m_punpckhdq(v221, v223);
        v227 = _m_punpckhdq(v224, v225);
        v228 = _m_punpckldq(v223, v223);
        v229 = _m_punpckldq(v225, v225);
        v230 = _m_punpckhdq(v226, v226);
        v231 = _m_pfmul(v374, v230);
        v232 = _m_punpckhdq(v227, v227);
        v233 = _m_pfadd(_m_pfadd(_m_pfmul(v230, v376), _m_pfmul(v228, v372)), _m_pfmul(v229, v380));
        v234 = _m_pfadd(_m_pfmul(0, v232), _m_pfadd(_m_pfmul(v378, v229), _m_pfadd(v231, _m_pfmul(v370, v228))));
        v235 = a1[4];
        v236 = _m_pfadd(_m_pfmul(v232, v382), v233);
        v237 = a1[5];
        a1[2].m64_u64 = (unsigned __int64)v234;
        a1[3].m64_u64 = (unsigned __int64)v236;
        v238 = _m_punpckhdq(v233, v235);
        v239 = _m_punpckhdq(v236, v237);
        v240 = _m_punpckldq(v235, v235);
        v241 = _m_punpckldq(v237, v237);
        v242 = _m_punpckhdq(v238, v238);
        v243 = _m_pfmul(v374, v242);
        v244 = _m_punpckhdq(v239, v239);
        v245 = _m_pfadd(_m_pfadd(_m_pfmul(v242, v376), _m_pfmul(v240, v372)), _m_pfmul(v241, v380));
        v246 = _m_pfadd(_m_pfmul(0, v244), _m_pfadd(_m_pfmul(v378, v241), _m_pfadd(v243, _m_pfmul(v370, v240))));
        v247 = a1[6];
        v248 = _m_pfadd(_m_pfmul(v244, v382), v245);
        v249 = a1[7];
        a1[4].m64_u64 = (unsigned __int64)v246;
        a1[5].m64_u64 = (unsigned __int64)v248;
        v250 = _m_punpckhdq(v245, v247);
        v251 = _m_punpckhdq(v248, v249);
        v252 = _m_punpckldq(v247, v247);
        v253 = _m_punpckldq(v249, v249);
        v254 = _m_punpckhdq(v250, v250);
        v255 = _m_punpckhdq(v251, v251);
        a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(0, v255),
                                            _m_pfadd(
                                              _m_pfmul(v378, v253),
                                              _m_pfadd(_m_pfmul(v374, v254), _m_pfmul(v370, v252))));
        a1[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                            _m_pfmul(v255, v382),
                                            _m_pfadd(
                                              _m_pfadd(_m_pfmul(v254, v376), _m_pfmul(v252, v372)),
                                              _m_pfmul(v253, v380)));
      }
    }
    else
    {
      v256 = _mm_cvtsi32_si64(a4[1].m64_u32[0]);
      v257 = _m_punpckhdq(0, (__m64)a4->m64_u64);
      a1->m64_u64 = (unsigned __int64)_m_punpckldq((__m64)a4->m64_u64, 0);
      a1[1].m64_u64 = 0;
      a1[2].m64_u64 = (unsigned __int64)v257;
      a1[3].m64_u64 = 0;
      a1[4].m64_u64 = 0;
      a1[5].m64_u64 = (unsigned __int64)v256;
      a1[6].m64_u64 = 0;
      a1[7].m64_u64 = 0x3F80000000000000LL;
    }
  }
  else
  {
    v258 = _mm_cvtsi32_si64(0x3F800000u);
    v259 = _m_pswapd(v258);
    a1->m64_u64 = (unsigned __int64)v258;
    a1[1].m64_u64 = 0;
    a1[2].m64_u64 = (unsigned __int64)v259;
    a1[3].m64_u64 = 0;
    a1[4].m64_u64 = 0;
    a1[5].m64_u64 = (unsigned __int64)v258;
    a1[6].m64_u64 = 0;
    a1[7].m64_u64 = (unsigned __int64)v259;
  }
  if ( a6 )
  {
    v260 = a6[1];
    v261 = _m_pfadd(v260, v260);
    v262 = _m_pfadd((__m64)a6->m64_u64, (__m64)a6->m64_u64);
    v263 = _m_pfmul(v262, (__m64)a6->m64_u64);
    v264 = _m_punpckldq(v262, v261);
    v265 = _m_pfmul((__m64)a6->m64_u64, v261);
    v266 = _m_pfmul(_m_pswapd((__m64)a6->m64_u64), v261);
    v267 = _m_pfmul(v261, v260);
    v268 = _m_pfmul(_m_punpckhdq((__m64)a6->m64_u64, v260), v264);
    v269 = _m_pfpnacc(v266, v266);
    v270 = _m_pfpnacc(v268, v268);
    v271 = _m_pfpnacc(v265, v265);
    v272 = _m_pfsub(_m_pfsubr(v263, (__m64)0x3F8000003F800000LL), _m_punpckldq(v267, v267));
    v273 = _m_punpckldq(_m_pswapd(v271), v269);
    v274 = _m_punpckldq(v271, 0);
    v379 = v273;
    v275 = _m_punpckhdq(v269, 0);
    v373 = v274;
    v381 = _m_punpckhdq(_m_pfsubr(_m_pfacc(v263, v263), (__m64)0x3F8000003F800000LL), 0);
    v371 = _m_punpckhdq(v272, v270);
    v375 = _m_punpckldq(v270, v272);
    v377 = v275;
    v383 = _m_punpckldq(0, (__m64)1065353216LL);
    if ( a5 )
    {
      v276 = (__m64)a5->m64_u64;
      v277 = _mm_cvtsi32_si64(a5[1].m64_u32[0]);
      v278 = _m_pfsub(_mm_cvtsi32_si64(result[7].m64_u32[0]), v277);
      result[6].m64_u64 = (unsigned __int64)_m_pfsub(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v278);
      v279 = result[1];
      v280 = _m_punpckhdq(v276, (__m64)result->m64_u64);
      v281 = _m_punpckhdq(v277, v279);
      v282 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v283 = _m_punpckldq(v279, v279);
      v284 = _m_punpckhdq(v280, v280);
      v285 = _m_pfmul(v375, v284);
      v286 = _m_punpckhdq(v281, v281);
      v287 = _m_pfadd(_m_pfadd(_m_pfmul(v284, v377), _m_pfmul(v282, v373)), _m_pfmul(v283, v381));
      v288 = _m_pfadd(_m_pfmul(0, v286), _m_pfadd(_m_pfmul(v379, v283), _m_pfadd(v285, _m_pfmul(v371, v282))));
      v289 = result[2];
      v290 = _m_pfadd(_m_pfmul(v286, v383), v287);
      v291 = result[3];
      result->m64_u64 = (unsigned __int64)v288;
      result[1].m64_u64 = (unsigned __int64)v290;
      v292 = _m_punpckhdq(v287, v289);
      v293 = _m_punpckhdq(v290, v291);
      v294 = _m_punpckldq(v289, v289);
      v295 = _m_punpckldq(v291, v291);
      v296 = _m_punpckhdq(v292, v292);
      v297 = _m_pfmul(v375, v296);
      v298 = _m_punpckhdq(v293, v293);
      v299 = _m_pfadd(_m_pfadd(_m_pfmul(v296, v377), _m_pfmul(v294, v373)), _m_pfmul(v295, v381));
      v300 = _m_pfadd(_m_pfmul(0, v298), _m_pfadd(_m_pfmul(v379, v295), _m_pfadd(v297, _m_pfmul(v371, v294))));
      v301 = result[4];
      v302 = _m_pfadd(_m_pfmul(v298, v383), v299);
      v303 = result[5];
      result[2].m64_u64 = (unsigned __int64)v300;
      result[3].m64_u64 = (unsigned __int64)v302;
      v304 = _m_punpckhdq(v299, v301);
      v305 = _m_punpckhdq(v302, v303);
      v306 = _m_punpckldq(v301, v301);
      v307 = _m_punpckldq(v303, v303);
      v308 = _m_punpckhdq(v304, v304);
      v309 = _m_pfmul(v375, v308);
      v310 = _m_punpckhdq(v305, v305);
      v311 = _m_pfadd(_m_pfadd(_m_pfmul(v308, v377), _m_pfmul(v306, v373)), _m_pfmul(v307, v381));
      v312 = _m_pfadd(_m_pfmul(0, v310), _m_pfadd(_m_pfmul(v379, v307), _m_pfadd(v309, _m_pfmul(v371, v306))));
      v313 = result[6];
      v314 = _m_pfadd(_m_pfmul(v310, v383), v311);
      v315 = result[7];
      result[4].m64_u64 = (unsigned __int64)v312;
      result[5].m64_u64 = (unsigned __int64)v314;
      v316 = _m_punpckhdq(v311, v313);
      v317 = _m_punpckhdq(v314, v315);
      v318 = _m_punpckldq(v313, v313);
      v319 = _m_punpckldq(v315, v315);
      v320 = _m_punpckhdq(v316, v316);
      v321 = _m_punpckhdq(v317, v317);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v321),
                                              _m_pfadd(
                                                _m_pfmul(v379, v319),
                                                _m_pfadd(_m_pfmul(v375, v320), _m_pfmul(v371, v318))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v321, v383),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v320, v377), _m_pfmul(v318, v373)),
                                                _m_pfmul(v319, v381)));
      v322 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a5[1].m64_u32[0]));
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a5->m64_u64);
      result[7].m64_i32[0] = _mm_cvtsi64_si32(v322);
    }
    else
    {
      v323 = result[1];
      v324 = _m_punpckhdq(v274, (__m64)result->m64_u64);
      v325 = _m_punpckhdq(v275, v323);
      v326 = _m_punpckldq((__m64)result->m64_u64, (__m64)result->m64_u64);
      v327 = _m_punpckldq(v323, v323);
      v328 = _m_punpckhdq(v324, v324);
      v329 = _m_pfmul(v375, v328);
      v330 = _m_punpckhdq(v325, v325);
      v331 = _m_pfadd(_m_pfadd(_m_pfmul(v328, v377), _m_pfmul(v326, v373)), _m_pfmul(v327, v381));
      v332 = _m_pfadd(_m_pfmul(0, v330), _m_pfadd(_m_pfmul(v379, v327), _m_pfadd(v329, _m_pfmul(v371, v326))));
      v333 = result[2];
      v334 = _m_pfadd(_m_pfmul(v330, v383), v331);
      v335 = result[3];
      result->m64_u64 = (unsigned __int64)v332;
      result[1].m64_u64 = (unsigned __int64)v334;
      v336 = _m_punpckhdq(v331, v333);
      v337 = _m_punpckhdq(v334, v335);
      v338 = _m_punpckldq(v333, v333);
      v339 = _m_punpckldq(v335, v335);
      v340 = _m_punpckhdq(v336, v336);
      v341 = _m_pfmul(v375, v340);
      v342 = _m_punpckhdq(v337, v337);
      v343 = _m_pfadd(_m_pfadd(_m_pfmul(v340, v377), _m_pfmul(v338, v373)), _m_pfmul(v339, v381));
      v344 = _m_pfadd(_m_pfmul(0, v342), _m_pfadd(_m_pfmul(v379, v339), _m_pfadd(v341, _m_pfmul(v371, v338))));
      v345 = result[4];
      v346 = _m_pfadd(_m_pfmul(v342, v383), v343);
      v347 = result[5];
      result[2].m64_u64 = (unsigned __int64)v344;
      result[3].m64_u64 = (unsigned __int64)v346;
      v348 = _m_punpckhdq(v343, v345);
      v349 = _m_punpckhdq(v346, v347);
      v350 = _m_punpckldq(v345, v345);
      v351 = _m_punpckldq(v347, v347);
      v352 = _m_punpckhdq(v348, v348);
      v353 = _m_pfmul(v375, v352);
      v354 = _m_punpckhdq(v349, v349);
      v355 = _m_pfadd(_m_pfadd(_m_pfmul(v352, v377), _m_pfmul(v350, v373)), _m_pfmul(v351, v381));
      v356 = _m_pfadd(_m_pfmul(0, v354), _m_pfadd(_m_pfmul(v379, v351), _m_pfadd(v353, _m_pfmul(v371, v350))));
      v357 = result[6];
      v358 = _m_pfadd(_m_pfmul(v354, v383), v355);
      v359 = result[7];
      result[4].m64_u64 = (unsigned __int64)v356;
      result[5].m64_u64 = (unsigned __int64)v358;
      v360 = _m_punpckhdq(v355, v357);
      v361 = _m_punpckhdq(v358, v359);
      v362 = _m_punpckldq(v357, v357);
      v363 = _m_punpckldq(v359, v359);
      v364 = _m_punpckhdq(v360, v360);
      v365 = _m_punpckhdq(v361, v361);
      result[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(0, v365),
                                              _m_pfadd(
                                                _m_pfmul(v379, v363),
                                                _m_pfadd(_m_pfmul(v375, v364), _m_pfmul(v371, v362))));
      result[7].m64_u64 = (unsigned __int64)_m_pfadd(
                                              _m_pfmul(v365, v383),
                                              _m_pfadd(
                                                _m_pfadd(_m_pfmul(v364, v377), _m_pfmul(v362, v373)),
                                                _m_pfmul(v363, v381)));
    }
  }
  if ( a7 )
  {
    v366 = _m_pfadd(_mm_cvtsi32_si64(result[7].m64_u32[0]), _mm_cvtsi32_si64(a7[1].m64_u32[0]));
    result[6].m64_u64 = (unsigned __int64)_m_pfadd(result[6], (__m64)a7->m64_u64);
    result[7].m64_i32[0] = _mm_cvtsi64_si32(v366);
  }
  _m_femms();
  return result;
}

// sub_1002C7C0 @ 0x1002C7C0
int __stdcall sub_1002C7C0(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm0
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm7
  __m64 v11; // mm2
  __m64 v12; // rt1
  __m64 v13; // mm1
  __m64 v14; // mm0
  __m64 v15; // mm5
  __m64 v16; // mm6
  __m64 v17; // mm1
  __m64 v18; // mm0
  __m64 v19; // mm7
  __m64 v20; // mm2
  __m64 v21; // mm0
  __m64 v22; // mm0
  __m64 v23; // mm1
  int result; // eax
  __m64 v25; // mm0
  __m64 v26; // mm1
  __m64 v27; // mm3
  __m64 v28; // mm6
  __m64 v29; // mm4
  __m64 v30; // mm7
  __m64 v31; // mm3
  __m64 v32; // mm6
  __m64 v33; // mm4
  __m64 v34; // mm7
  __m64 v35; // [esp+0h] [ebp-40h]
  __m64 v36; // [esp+8h] [ebp-38h]
  __m64 v37; // [esp+10h] [ebp-30h]
  __m64 v38; // [esp+18h] [ebp-28h]
  __m64 v39; // [esp+20h] [ebp-20h]
  __m64 v40; // [esp+28h] [ebp-18h]
  __m64 v41; // [esp+30h] [ebp-10h]
  __m64 v42; // [esp+38h] [ebp-8h]

  v3 = a3[2];
  v4 = a3[4];
  v5 = _m_pswapd(a3[6]);
  v6 = _m_pfnacc(_m_pfmul(_m_pswapd(v3), (__m64)a3->m64_u64), _m_pfmul(_m_pswapd(v4), (__m64)a3->m64_u64));
  v7 = _m_pfnacc(_m_pfmul(v5, (__m64)a3->m64_u64), _m_pfmul(_m_pswapd(v4), v3));
  v8 = _m_pfnacc(_m_pfmul(v3, v5), _m_pfmul(v4, v5));
  v9 = a3[7];
  v10 = a3[5];
  v36 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v7, v7), v9), _m_pfmul(_m_punpckhdq(v8, v8), a3[3])),
          _m_pfmul(_m_punpckldq(v8, v8), v10));
  v38 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v6, v6), v9), _m_pfmul(_m_punpckldq(v7, v7), v10)),
          _m_pfmul(_m_punpckhdq(v8, v8), a3[1]));
  v11 = _m_punpckldq(v6, v6);
  v40 = _m_pfsub(
          _m_pfadd(_m_pfmul(v9, v11), _m_pfmul(_m_punpckldq(v8, v8), a3[1])),
          _m_pfmul(_m_punpckldq(v7, v7), a3[3]));
  v12 = a3[1];
  v42 = _m_pfadd(
          _m_pfsub(_m_pfmul(v11, v10), _m_pfmul(_m_punpckhdq(v6, v6), a3[3])),
          _m_pfmul(_m_punpckhdq(v7, v7), v12));
  v13 = a3[3];
  v14 = _m_pswapd(v9);
  v15 = _m_pfnacc(_m_pfmul(_m_pswapd(v13), v12), _m_pfmul(_m_pswapd(v10), v12));
  v16 = _m_pfnacc(_m_pfmul(v14, v12), _m_pfmul(_m_pswapd(v10), v13));
  v17 = _m_pfnacc(_m_pfmul(v13, v14), _m_pfmul(v10, v14));
  v18 = a3[6];
  v19 = a3[4];
  v35 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v16, v16), v18), _m_pfmul(_m_punpckhdq(v17, v17), a3[2])),
          _m_pfmul(_m_punpckldq(v17, v17), v19));
  v37 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v15, v15), v18), _m_pfmul(_m_punpckldq(v16, v16), v19)),
          _m_pfmul(_m_punpckhdq(v17, v17), (__m64)a3->m64_u64));
  v20 = _m_punpckldq(v15, v15);
  v39 = _m_pfsub(
          _m_pfadd(_m_pfmul(v18, v20), _m_pfmul(_m_punpckldq(v17, v17), (__m64)a3->m64_u64)),
          _m_pfmul(_m_punpckldq(v16, v16), a3[2]));
  v41 = _m_pfadd(
          _m_pfsub(_m_pfmul(v20, v19), _m_pfmul(_m_punpckhdq(v15, v15), a3[2])),
          _m_pfmul(_m_punpckhdq(v16, v16), (__m64)a3->m64_u64));
  v21 = _m_pfnacc(
          _m_pfmul(_m_punpckhdq(v39, v41), _m_punpckldq(v19, v18)),
          _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3[2].m64_u32[0]), _m_punpckhdq(v35, v37)));
  v22 = _m_pfacc(v21, v21);
  if ( a2 )
    *a2 = _mm_cvtsi64_si32(v22);
  v23 = _m_pfrcp(v22);
  result = _mm_cvtsi64_si32(_m_pfcmpeq(0, v22));
  v25 = _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(_m_punpckldq(v22, v22), v23), v23), (__m64)0xBF8000003F800000uLL);
  v26 = _m_pswapd(v25);
  if ( !result )
  {
    result = (int)a1;
    v27 = _m_pfmul(v37, v25);
    v28 = _m_pfmul(v38, v25);
    v29 = _m_pfmul(v35, v26);
    v30 = _m_pfmul(v36, v26);
    a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v29, v27);
    a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v29, v27);
    a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(v30, v28);
    a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(v30, v28);
    v31 = _m_pfmul(v41, v25);
    v32 = _m_pfmul(v42, v25);
    v33 = _m_pfmul(v39, v26);
    v34 = _m_pfmul(v40, v26);
    a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v33, v31);
    a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v33, v31);
    a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(v34, v32);
    a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(v34, v32);
  }
  _m_femms();
  return result;
}

// sub_1002CAA2 @ 0x1002CAA2
__m64 *__stdcall sub_1002CAA2(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm4
  __m64 v5; // mm5
  __m64 v6; // mm7
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm4
  __m64 *result; // eax
  __m64 v11; // mm4
  __m64 v12; // mm4
  __m64 v13; // mm4
  __m64 v14; // mm4
  __m64 v15; // mm4
  __m64 v16; // mm4
  __m64 v17; // mm4
  __m64 v18; // [esp+0h] [ebp-44h]
  __m64 v19; // [esp+0h] [ebp-44h]
  __m64 v20; // [esp+8h] [ebp-3Ch]
  __m64 v21; // [esp+8h] [ebp-3Ch]
  __m64 v22; // [esp+10h] [ebp-34h]
  __m64 v23; // [esp+10h] [ebp-34h]
  __m64 v24; // [esp+18h] [ebp-2Ch]
  __m64 v25; // [esp+18h] [ebp-2Ch]
  __m64 v26; // [esp+20h] [ebp-24h]
  __m64 v27; // [esp+20h] [ebp-24h]
  __m64 v28; // [esp+28h] [ebp-1Ch]
  __m64 v29; // [esp+28h] [ebp-1Ch]
  __m64 v30; // [esp+30h] [ebp-14h]
  __m64 v31; // [esp+38h] [ebp-Ch]

  _m_femms();
  v3 = a3[2];
  v4 = a3[7];
  v5 = a3[5];
  v18 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v22 = _m_punpckhdq((__m64)a3->m64_u64, v3);
  v6 = a3[3];
  v7 = a3[4];
  v8 = a3[1];
  v28 = _m_punpckldq(v5, v4);
  v31 = _m_punpckhdq(v5, v4);
  v9 = a3[6];
  v26 = _m_punpckldq(v8, v6);
  v30 = _m_punpckhdq(v8, v6);
  v24 = _m_punpckhdq(v7, v9);
  v20 = _m_punpckldq(v7, v9);
  result = a1;
  v11 = _m_pfadd(
          _m_pfacc(_m_pfmul(v18, a2[4]), _m_pfmul(v18, a2[6])),
          _m_pfacc(_m_pfmul(v20, a2[5]), _m_pfmul(v20, a2[7])));
  if ( a2 == a1 )
  {
    v19 = _m_pfadd(
            _m_pfacc(_m_pfmul(v18, (__m64)a2->m64_u64), _m_pfmul(v18, a2[2])),
            _m_pfacc(_m_pfmul(v20, a2[1]), _m_pfmul(v20, a2[3])));
    v21 = v11;
    v15 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, a2[4]), _m_pfmul(v22, a2[6])),
            _m_pfacc(_m_pfmul(v24, a2[5]), _m_pfmul(v24, a2[7])));
    v23 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v22, a2[2])),
            _m_pfacc(_m_pfmul(v24, a2[1]), _m_pfmul(v24, a2[3])));
    v25 = v15;
    v16 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, a2[4]), _m_pfmul(v26, a2[6])),
            _m_pfacc(_m_pfmul(v28, a2[5]), _m_pfmul(v28, a2[7])));
    v27 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, (__m64)a2->m64_u64), _m_pfmul(v26, a2[2])),
            _m_pfacc(_m_pfmul(v28, a2[1]), _m_pfmul(v28, a2[3])));
    v29 = v16;
    v17 = _m_pfadd(
            _m_pfacc(_m_pfmul(v30, a2[4]), _m_pfmul(v30, a2[6])),
            _m_pfacc(_m_pfmul(v31, a2[5]), _m_pfmul(v31, a2[7])));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v30, (__m64)a2->m64_u64), _m_pfmul(v30, a2[2])),
                                        _m_pfacc(_m_pfmul(v31, a2[1]), _m_pfmul(v31, a2[3])));
    a1[7].m64_u64 = (unsigned __int64)v17;
    a1->m64_u64 = (unsigned __int64)v19;
    a1[1].m64_u64 = (unsigned __int64)v21;
    a1[2].m64_u64 = (unsigned __int64)v23;
    a1[3].m64_u64 = (unsigned __int64)v25;
    a1[4].m64_u64 = (unsigned __int64)v27;
    a1[5].m64_u64 = (unsigned __int64)v29;
  }
  else
  {
    a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfacc(_m_pfmul(v18, (__m64)a2->m64_u64), _m_pfmul(v18, a2[2])),
                                      _m_pfacc(_m_pfmul(v20, a2[1]), _m_pfmul(v20, a2[3])));
    a1[1].m64_u64 = (unsigned __int64)v11;
    v12 = _m_pfadd(
            _m_pfacc(_m_pfmul(v22, a2[4]), _m_pfmul(v22, a2[6])),
            _m_pfacc(_m_pfmul(v24, a2[5]), _m_pfmul(v24, a2[7])));
    a1[2].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v22, a2[2])),
                                        _m_pfacc(_m_pfmul(v24, a2[1]), _m_pfmul(v24, a2[3])));
    a1[3].m64_u64 = (unsigned __int64)v12;
    v13 = _m_pfadd(
            _m_pfacc(_m_pfmul(v26, a2[4]), _m_pfmul(v26, a2[6])),
            _m_pfacc(_m_pfmul(v28, a2[5]), _m_pfmul(v28, a2[7])));
    a1[4].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v26, (__m64)a2->m64_u64), _m_pfmul(v26, a2[2])),
                                        _m_pfacc(_m_pfmul(v28, a2[1]), _m_pfmul(v28, a2[3])));
    a1[5].m64_u64 = (unsigned __int64)v13;
    v14 = _m_pfadd(
            _m_pfacc(_m_pfmul(v30, a2[4]), _m_pfmul(v30, a2[6])),
            _m_pfacc(_m_pfmul(v31, a2[5]), _m_pfmul(v31, a2[7])));
    a1[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                        _m_pfacc(_m_pfmul(v30, (__m64)a2->m64_u64), _m_pfmul(v30, a2[2])),
                                        _m_pfacc(_m_pfmul(v31, a2[1]), _m_pfmul(v31, a2[3])));
    a1[7].m64_u64 = (unsigned __int64)v14;
  }
  _m_femms();
  return result;
}

// sub_1002CE9A @ 0x1002CE9A
int __stdcall sub_1002CE9A(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  __m64 v3; // mm1
  __m64 v4; // mm2
  __m64 v5; // mm5
  __m64 v6; // mm0
  __m64 v7; // mm4
  __m64 v8; // mm3
  __m64 v9; // mm6
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm1
  __m64 v13; // mm0
  __m64 v14; // mm7
  __m64 v15; // mm2
  __m64 v16; // mm0
  __m64 v17; // mm1
  __m64 v18; // mm5
  __m64 v19; // mm0
  __m64 v20; // mm4
  __m64 v21; // mm3
  __m64 v22; // mm6
  __m64 v23; // mm4
  __m64 v24; // mm6
  __m64 v25; // mm1
  __m64 v26; // mm0
  __m64 v27; // mm7
  __m64 v28; // mm2
  __m64 v29; // mm2
  __m64 v30; // mm0
  __m64 v31; // mm0
  __m64 v32; // mm1
  int result; // eax
  __m64 v34; // mm0
  __m64 v35; // mm1
  __m64 v36; // mm3
  __m64 v37; // mm6
  __m64 v38; // mm4
  __m64 v39; // mm7
  __m64 v40; // mm3
  __m64 v41; // mm6
  __m64 v42; // mm4
  __m64 v43; // mm7
  __m64 v44; // [esp+0h] [ebp-44h]
  __m64 v45; // [esp+8h] [ebp-3Ch]
  __m64 v46; // [esp+10h] [ebp-34h]
  __m64 v47; // [esp+18h] [ebp-2Ch]
  __m64 v48; // [esp+20h] [ebp-24h]
  __m64 v49; // [esp+28h] [ebp-1Ch]
  __m64 v50; // [esp+38h] [ebp-Ch]

  v3 = a3[2];
  v4 = a3[4];
  v5 = _m_pfsub(
         _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_punpckhdq(v3, v4)),
         _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, (__m64)a3->m64_u64), _m_punpckldq(v3, v4)));
  v6 = _m_punpckldq((__m64)a3->m64_u64, v3);
  v7 = a3[6];
  v8 = _m_punpckhdq(v7, v7);
  v9 = _m_punpckhdq(v7, v4);
  v10 = _m_punpckldq(v7, v4);
  v11 = _m_pfsub(_m_pfmul(v9, v6), _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v3), v10));
  v12 = _m_pfsubr(_m_pfmul(_m_punpckhdq(v3, v4), _m_punpckldq(v10, v10)), _m_pfmul(_m_punpckhdq(v6, v10), v8));
  v13 = a3[7];
  v14 = a3[5];
  v45 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v11, v11), v13), _m_pfmul(_m_punpckhdq(v12, v12), a3[3])),
          _m_pfmul(_m_punpckldq(v12, v12), v14));
  v47 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v5, v5), v13), _m_pfmul(_m_punpckldq(v11, v11), v14)),
          _m_pfmul(_m_punpckhdq(v12, v12), a3[1]));
  v15 = _m_punpckldq(v5, v5);
  v49 = _m_pfsub(
          _m_pfadd(_m_pfmul(v13, v15), _m_pfmul(_m_punpckldq(v12, v12), a3[1])),
          _m_pfmul(_m_punpckldq(v11, v11), a3[3]));
  v50 = _m_pfadd(
          _m_pfsub(_m_pfmul(v15, v14), _m_pfmul(_m_punpckhdq(v5, v5), a3[3])),
          _m_pfmul(_m_punpckhdq(v11, v11), a3[1]));
  v16 = a3[1];
  v17 = a3[3];
  v18 = _m_pfsub(
          _m_pfmul(_m_punpckldq(v16, v16), _m_punpckhdq(v17, v14)),
          _m_pfmul(_m_punpckhdq(v16, v16), _m_punpckldq(v17, v14)));
  v19 = _m_punpckldq(v16, v17);
  v20 = a3[7];
  v21 = _m_punpckhdq(v20, v20);
  v22 = _m_punpckhdq(v20, v14);
  v23 = _m_punpckldq(v20, v14);
  v24 = _m_pfsub(_m_pfmul(v22, v19), _m_pfmul(_m_punpckhdq(a3[1], v17), v23));
  v25 = _m_pfsubr(_m_pfmul(_m_punpckhdq(v17, v14), _m_punpckldq(v23, v23)), _m_pfmul(_m_punpckhdq(v19, v23), v21));
  v26 = a3[6];
  v27 = a3[4];
  v44 = _m_pfsub(
          _m_pfadd(_m_pfmul(_m_punpckhdq(v24, v24), v26), _m_pfmul(_m_punpckhdq(v25, v25), a3[2])),
          _m_pfmul(_m_punpckldq(v25, v25), v27));
  v46 = _m_pfadd(
          _m_pfsub(_m_pfmul(_m_punpckhdq(v18, v18), v26), _m_pfmul(_m_punpckldq(v24, v24), v27)),
          _m_pfmul(_m_punpckhdq(v25, v25), (__m64)a3->m64_u64));
  v28 = _m_punpckldq(v18, v18);
  v48 = _m_pfsub(
          _m_pfadd(_m_pfmul(v26, v28), _m_pfmul(_m_punpckldq(v25, v25), (__m64)a3->m64_u64)),
          _m_pfmul(_m_punpckldq(v24, v24), a3[2]));
  v29 = _m_pfadd(
          _m_pfsub(_m_pfmul(v28, v27), _m_pfmul(_m_punpckhdq(v18, v18), a3[2])),
          _m_pfmul(_m_punpckhdq(v24, v24), (__m64)a3->m64_u64));
  v30 = _m_pfadd(
          _m_pfmul(_m_punpckhdq(v48, v29), _m_pfmul(_m_punpckldq(v27, v26), (__m64)0xBF8000003F800000uLL)),
          _m_pfmul(
            _m_pfmul(_m_punpckldq((__m64)a3->m64_u64, (__m64)a3[2].m64_u32[0]), (__m64)0xBF8000003F800000uLL),
            _m_punpckhdq(v44, v46)));
  v31 = _m_pfacc(v30, v30);
  if ( a2 )
    *a2 = _mm_cvtsi64_si32(v31);
  v32 = _m_pfrcp(v31);
  result = _mm_cvtsi64_si32(_m_pfcmpeq(0, v31));
  v34 = _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(_m_punpckldq(v31, v31), v32), v32), (__m64)0xBF8000003F800000uLL);
  v35 = _m_punpckhdq(v34, _m_punpckldq(v29, v34));
  if ( !result )
  {
    v36 = _m_pfmul(v46, v34);
    v37 = _m_pfmul(v47, v34);
    v38 = _m_pfmul(v44, v35);
    v39 = _m_pfmul(v45, v35);
    a1->m64_u64 = (unsigned __int64)_m_punpckhdq(v38, v36);
    a1[2].m64_u64 = (unsigned __int64)_m_punpckldq(v38, v36);
    a1[4].m64_u64 = (unsigned __int64)_m_punpckhdq(v39, v37);
    a1[6].m64_u64 = (unsigned __int64)_m_punpckldq(v39, v37);
    v40 = _m_pfmul(v29, v34);
    v41 = _m_pfmul(v50, v34);
    v42 = _m_pfmul(v48, v35);
    v43 = _m_pfmul(v49, v35);
    a1[1].m64_u64 = (unsigned __int64)_m_punpckhdq(v42, v40);
    a1[3].m64_u64 = (unsigned __int64)_m_punpckldq(v42, v40);
    a1[5].m64_u64 = (unsigned __int64)_m_punpckhdq(v43, v41);
    a1[7].m64_u64 = (unsigned __int64)_m_punpckldq(v43, v41);
    return (int)a1;
  }
  return result;
}

// sub_1002D1CE @ 0x1002D1CE
__m64 *__stdcall sub_1002D1CE(__m64 *a1, _DWORD *a2, __m64 *a3)
{
  _m_femms();
  sub_1002CE9A(a1, a2, a3);
  _m_femms();
  return a1;
}

// sub_1002D1EA @ 0x1002D1EA
__m64 *__stdcall sub_1002D1EA(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]),
                                    _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4])));
  a1[1].m64_u64 = (unsigned __int64)v8;
  _m_femms();
  return a1;
}

// sub_1002D25B @ 0x1002D25B
__m64 *__stdcall sub_1002D25B(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfmul(v4, a3[1]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(v4, (__m64)a3->m64_u64),
                                    _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4])));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v8);
  _m_femms();
  return a1;
}

// sub_1002D2C2 @ 0x1002D2C2
__m64 *__stdcall sub_1002D2C2(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm5
  __m64 v8; // mm0

  _m_femms();
  v2 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v5 = _m_pfrsqrt(v4);
  v6 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v4, _m_pfmul(v5, v5)), v5);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v6), v8);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(_m_pand(v2, v6), v8));
  _m_femms();
  return a1;
}

// sub_1002D321 @ 0x1002D321
__m64 *__stdcall sub_1002D321(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm5
  __m64 v8; // mm7
  __m64 v10; // mm6
  __m64 v11; // mm7
  __m64 v12; // mm1

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v8 = _mm_cvtsi32_si64(a6);
  v10 = _m_punpckldq(v6, v6);
  v11 = _m_punpckldq(v8, v8);
  v12 = _m_pfadd(
          _m_pfadd(_m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a3[1].m64_u32[0]), v7), v10), v7),
          _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v7), v11));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), v10),
                                      (__m64)a2->m64_u64),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), v11));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v12);
  _m_femms();
  return a1;
}

// sub_1002D392 @ 0x1002D392
__m64 *__stdcall sub_1002D392(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2
  __m64 v17; // mm5
  __m64 v18; // mm0
  __m64 v19; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm3
  __m64 v23; // mm0

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  v17 = _m_punpckldq(v9, v9);
  v18 = _m_punpckldq(v14, v14);
  v19 = _m_pfmul(v18, (__m64)a4->m64_u64);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v16, v16);
  v23 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, _mm_cvtsi32_si64(a4[1].m64_u32[0])), _m_pfmul(v17, _mm_cvtsi32_si64(a5[1].m64_u32[0]))),
          _m_pfadd(_m_pfmul(v22, _mm_cvtsi32_si64(a2[1].m64_u32[0])), _m_pfmul(v21, _mm_cvtsi32_si64(a3[1].m64_u32[0]))));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(v19, _m_pfmul(v17, (__m64)a5->m64_u64)),
                                    _m_pfadd(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v21, (__m64)a3->m64_u64)));
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v23);
  _m_femms();
  return a1;
}

// sub_1002D466 @ 0x1002D466
__m64 *__stdcall sub_1002D466(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm0
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 v17; // mm4
  __m64 v18; // mm5
  __m64 v19; // mm6
  __m64 v21; // mm7
  __m64 v22; // mm0
  __m64 v23; // mm4

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  v17 = _m_punpckhdq(v15, v15);
  v18 = _m_punpckldq(v16, v16);
  v19 = _m_punpckldq(v15, v15);
  v21 = _m_punpckhdq(v16, v16);
  v22 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, (__m64)a3->m64_u64), _m_pfmul(v17, (__m64)a2->m64_u64)),
          _m_pfmul(v19, (__m64)a4->m64_u64));
  v23 = _m_pfadd(
          _m_pfadd(
            _m_pfadd(
              _m_pfmul(v17, _mm_cvtsi32_si64(a2[1].m64_u32[0])),
              _m_pfmul(v18, _mm_cvtsi32_si64(a3[1].m64_u32[0]))),
            _m_pfmul(v19, _mm_cvtsi32_si64(a4[1].m64_u32[0]))),
          _m_pfmul(v21, _mm_cvtsi32_si64(a5[1].m64_u32[0])));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(v22, _m_pfmul(v21, (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(v23, (__m64)0x3F0000003F000000LL));
  _m_femms();
  return a1;
}

// sub_1002D550 @ 0x1002D550
__m64 *__stdcall sub_1002D550(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm2
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm1
  __m64 v9; // mm3
  __m64 v10; // mm5
  __m64 v11; // mm4
  __m64 v12; // mm5

  _m_femms();
  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_punpckldq(m64_u64, m64_u64);
  v5 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_pfadd(_m_pfmul(v6, a3[2]), _m_pfmul(v7, a3[4]));
  v9 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfadd(_m_pfmul(v6, a3[3]), _m_pfmul(v7, a3[5])));
  v10 = _m_punpckhdq(v9, v9);
  v11 = _m_pfrcp(v10);
  v12 = _m_pfrcpit2(_m_pfrcpit1(v10, v11), v11);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), v8), v12);
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(_m_pfmul(v9, v12));
  _m_femms();
  return a1;
}

// sub_1002D5DB @ 0x1002D5DB
__m64 *__userpurge sub_1002D5DB@<eax>(__m64 a1@<mm2>, __m64 a2@<mm3>, __m64 *a3, __m64 *a4, __m64 *a5)
{
  __m64 v5; // mm1
  __m64 v6; // mm2
  __m64 v7; // mm3
  __m64 v8; // mm0
  __m64 v9; // mm1
  __m64 v10; // mm2
  __m64 v11; // mm5
  __m64 v12; // mm3
  __m64 v13; // mm2
  __m64 v14; // mm7
  __m64 v15; // mm0
  __m64 v16; // mm3
  __m64 v17; // mm1
  __m64 m64_u64; // mm4
  __m64 v19; // mm2
  __m64 v20; // mm3
  __m64 v21; // mm0
  __m64 v22; // mm1
  __m64 v23; // mm2
  __m64 v24; // mm5
  __m64 v25; // mm3
  __m64 v26; // mm2
  __m64 v27; // mm7
  __m64 v28; // mm0
  __m64 v29; // mm3
  __m64 v30; // mm1
  __m64 v31; // mm4
  __m64 v32; // mm2
  __m64 v33; // mm3
  __m64 v34; // mm0
  __m64 v35; // mm1
  __m64 v36; // mm2
  __m64 v37; // mm5
  __m64 v38; // mm3
  __m64 v39; // mm2
  __m64 v40; // mm7
  __m64 v41; // mm0
  __m64 v42; // mm3
  __m64 v43; // mm1
  __m64 v44; // mm4
  __m64 v45; // mm2
  __m64 v46; // mm3
  __m64 v47; // mm0
  __m64 v48; // mm1
  __m64 v49; // mm2
  __m64 v50; // mm3
  __m64 v51; // mm7
  __m64 v52; // mm3

  v5 = a4[1];
  v6 = _m_punpckhdq(a1, (__m64)a4->m64_u64);
  v7 = _m_punpckhdq(a2, v5);
  v8 = _m_punpckldq((__m64)a4->m64_u64, (__m64)a4->m64_u64);
  v9 = _m_punpckldq(v5, v5);
  v10 = _m_punpckhdq(v6, v6);
  v11 = _m_pfmul(a5[2], v10);
  v12 = _m_punpckhdq(v7, v7);
  v13 = _m_pfadd(_m_pfadd(_m_pfmul(v10, a5[3]), _m_pfmul(v8, a5[1])), _m_pfmul(v9, a5[5]));
  v14 = _m_pfadd(_m_pfmul(a5[6], v12), _m_pfadd(_m_pfmul(a5[4], v9), _m_pfadd(v11, _m_pfmul((__m64)a5->m64_u64, v8))));
  v15 = a4[2];
  v16 = _m_pfadd(_m_pfmul(v12, a5[7]), v13);
  v17 = a4[3];
  a3->m64_u64 = (unsigned __int64)v14;
  m64_u64 = (__m64)a5->m64_u64;
  a3[1].m64_u64 = (unsigned __int64)v16;
  v19 = _m_punpckhdq(v13, v15);
  v20 = _m_punpckhdq(v16, v17);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v17, v17);
  v23 = _m_punpckhdq(v19, v19);
  v24 = _m_pfmul(a5[2], v23);
  v25 = _m_punpckhdq(v20, v20);
  v26 = _m_pfadd(_m_pfadd(_m_pfmul(v23, a5[3]), _m_pfmul(v21, a5[1])), _m_pfmul(v22, a5[5]));
  v27 = _m_pfadd(_m_pfmul(a5[6], v25), _m_pfadd(_m_pfmul(a5[4], v22), _m_pfadd(v24, _m_pfmul(m64_u64, v21))));
  v28 = a4[4];
  v29 = _m_pfadd(_m_pfmul(v25, a5[7]), v26);
  v30 = a4[5];
  a3[2].m64_u64 = (unsigned __int64)v27;
  v31 = (__m64)a5->m64_u64;
  a3[3].m64_u64 = (unsigned __int64)v29;
  v32 = _m_punpckhdq(v26, v28);
  v33 = _m_punpckhdq(v29, v30);
  v34 = _m_punpckldq(v28, v28);
  v35 = _m_punpckldq(v30, v30);
  v36 = _m_punpckhdq(v32, v32);
  v37 = _m_pfmul(a5[2], v36);
  v38 = _m_punpckhdq(v33, v33);
  v39 = _m_pfadd(_m_pfadd(_m_pfmul(v36, a5[3]), _m_pfmul(v34, a5[1])), _m_pfmul(v35, a5[5]));
  v40 = _m_pfadd(_m_pfmul(a5[6], v38), _m_pfadd(_m_pfmul(a5[4], v35), _m_pfadd(v37, _m_pfmul(v31, v34))));
  v41 = a4[6];
  v42 = _m_pfadd(_m_pfmul(v38, a5[7]), v39);
  v43 = a4[7];
  a3[4].m64_u64 = (unsigned __int64)v40;
  v44 = (__m64)a5->m64_u64;
  a3[5].m64_u64 = (unsigned __int64)v42;
  v45 = _m_punpckhdq(v39, v41);
  v46 = _m_punpckhdq(v42, v43);
  v47 = _m_punpckldq(v41, v41);
  v48 = _m_punpckldq(v43, v43);
  v49 = _m_punpckhdq(v45, v45);
  v50 = _m_punpckhdq(v46, v46);
  v51 = _m_pfmul(a5[6], v50);
  v52 = _m_pfadd(
          _m_pfmul(v50, a5[7]),
          _m_pfadd(_m_pfadd(_m_pfmul(v49, a5[3]), _m_pfmul(v47, a5[1])), _m_pfmul(v48, a5[5])));
  a3[6].m64_u64 = (unsigned __int64)_m_pfadd(
                                      v51,
                                      _m_pfadd(_m_pfmul(a5[4], v48), _m_pfadd(_m_pfmul(a5[2], v49), _m_pfmul(v44, v47))));
  a3[7].m64_u64 = (unsigned __int64)v52;
  _m_femms();
  return a3;
}

// sub_1002D7A7 @ 0x1002D7A7
__m64 *__userpurge sub_1002D7A7@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 *v8; // esi
  __m64 v9; // mm1
  __m64 v11; // [esp+Ch] [ebp-40h] BYREF
  float v12; // [esp+14h] [ebp-38h]
  float v13; // [esp+18h] [ebp-34h]
  float v14; // [esp+1Ch] [ebp-30h]
  float v15; // [esp+20h] [ebp-2Ch]
  float v16; // [esp+24h] [ebp-28h]
  float v17; // [esp+28h] [ebp-24h]
  float v18; // [esp+2Ch] [ebp-20h]
  float v19; // [esp+30h] [ebp-1Ch]
  float v20; // [esp+34h] [ebp-18h]
  float v21; // [esp+38h] [ebp-14h]
  float v22; // [esp+3Ch] [ebp-10h]
  float v23; // [esp+40h] [ebp-Ch]
  float v24; // [esp+44h] [ebp-8h]
  float v25; // [esp+48h] [ebp-4h]

  v8 = &v11;
  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      v24 = 0.0;
      v23 = 0.0;
      v22 = 0.0;
      v21 = 0.0;
      v19 = 0.0;
      v18 = 0.0;
      v17 = 0.0;
      v16 = 0.0;
      v14 = 0.0;
      v13 = 0.0;
      v12 = 0.0;
      v11.m64_f32[1] = 0.0;
      v25 = 1.0;
      v20 = 1.0;
      v15 = 1.0;
      v11.m64_f32[0] = 1.0;
      break;
    case 1:
      v8 = a6;
      break;
    case 2:
      v8 = a7;
      break;
    case 3:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a7, a6);
      _m_femms();
      break;
    case 4:
      v8 = a8;
      break;
    case 5:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a6);
      _m_femms();
      break;
    case 6:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a7);
      _m_femms();
      break;
    case 7:
      _m_femms();
      sub_1002D5DB(a1, a2, &v11, a8, a7);
      sub_1002D5DB(a1, a2, &v11, &v11, a6);
      _m_femms();
      break;
    default:
      break;
  }
  sub_1002D550(a3, a4, v8);
  if ( a5 )
  {
    _m_femms();
    v9 = _m_pfadd(_m_pfmul(_mm_cvtsi32_si64(a3[1].m64_u32[0]), _m_pfsub(_m_punpckhdq(a5[2], a5[2]), a5[2])), a5[2]);
    a3->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(
                                        _m_pfadd(
                                          _m_pxor((__m64)a3->m64_u64, (__m64)0x8000000000000000uLL),
                                          (__m64)0x3F8000003F800000LL),
                                        _m_pfmul(_m_pi2fd(a5[1]), (__m64)0x3F0000003F000000LL)),
                                      _m_pi2fd((__m64)a5->m64_u64));
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v9);
    _m_femms();
  }
  return a3;
}

// sub_1002D92F @ 0x1002D92F
__m64 *__userpurge sub_1002D92F@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm4
  __m64 v9; // mm2
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm6
  __m64 v14; // mm3
  __m64 v16; // [esp+Ch] [ebp-40h] BYREF
  float v17; // [esp+14h] [ebp-38h]
  float v18; // [esp+18h] [ebp-34h]
  float v19; // [esp+1Ch] [ebp-30h]
  float v20; // [esp+20h] [ebp-2Ch]
  float v21; // [esp+24h] [ebp-28h]
  float v22; // [esp+28h] [ebp-24h]
  float v23; // [esp+2Ch] [ebp-20h]
  float v24; // [esp+30h] [ebp-1Ch]
  float v25; // [esp+34h] [ebp-18h]
  float v26; // [esp+38h] [ebp-14h]
  float v27; // [esp+3Ch] [ebp-10h]
  float v28; // [esp+40h] [ebp-Ch]
  float v29; // [esp+44h] [ebp-8h]
  float v30; // [esp+48h] [ebp-4h]

  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      v29 = 0.0;
      v28 = 0.0;
      v27 = 0.0;
      v26 = 0.0;
      v24 = 0.0;
      v23 = 0.0;
      v22 = 0.0;
      v21 = 0.0;
      v19 = 0.0;
      v18 = 0.0;
      v17 = 0.0;
      v16.m64_f32[1] = 0.0;
      v30 = 1.0;
      v25 = 1.0;
      v20 = 1.0;
      v16.m64_f32[0] = 1.0;
      break;
    case 1:
      _m_femms();
      sub_1002CE9A(&v16, 0, a6);
      _m_femms();
      break;
    case 2:
      _m_femms();
      sub_1002CE9A(&v16, 0, a7);
      _m_femms();
      break;
    case 3:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a7, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 4:
      _m_femms();
      sub_1002CE9A(&v16, 0, a8);
      _m_femms();
      break;
    case 5:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 6:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a7);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    case 7:
      _m_femms();
      sub_1002D5DB(a1, a2, &v16, a8, a7);
      sub_1002D5DB(a1, a2, &v16, &v16, a6);
      sub_1002CE9A(&v16, 0, &v16);
      _m_femms();
      break;
    default:
      break;
  }
  if ( a5 )
  {
    _m_femms();
    v8 = a5[2];
    v9 = _m_pi2fd(a5[1]);
    v10 = _m_punpckldq(_m_pfrcp(v9), _m_pfrcp(_m_punpckhdq(v9, v9)));
    v11 = _m_pfmul(
            _m_pfsub((__m64)a4->m64_u64, _m_pi2fd((__m64)a5->m64_u64)),
            _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v9, v10), v10), (__m64)0x4000000040000000LL));
    v12 = _m_pfsub(_m_punpckhdq(v8, v8), v8);
    v13 = _m_pfrcp(v12);
    v14 = _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v8), _m_pfrcpit2(_m_pfrcpit1(v12, v13), v13));
    a3->m64_u64 = (unsigned __int64)_m_pxor(_m_pfsub(v11, (__m64)0x3F8000003F800000LL), (__m64)0x8000000000000000uLL);
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v14);
    _m_femms();
    sub_1002D550(a3, a3, &v16);
  }
  else
  {
    sub_1002D550(a3, a4, &v16);
  }
  return a3;
}

// sub_1002DB55 @ 0x1002DB55
__m64 *__userpurge sub_1002DB55@<eax>(
        __m64 a1@<mm2>,
        __m64 a2@<mm3>,
        __m64 *a3,
        __m64 *a4,
        __m64 *a5,
        __m64 *a6,
        __m64 *a7,
        __m64 *a8)
{
  __m64 v8; // mm4
  __m64 v9; // mm2
  __m64 v10; // mm5
  __m64 v11; // mm0
  __m64 v12; // mm5
  __m64 v13; // mm6
  __m64 v14; // mm3
  __m64 *v16; // [esp-4h] [ebp-50h]
  __m64 v17[8]; // [esp+Ch] [ebp-40h] BYREF

  switch ( (a6 != 0) | (2 * ((a7 != 0) | (2 * (a8 != 0)))) )
  {
    case 0:
      sub_10029B22(v17);
      break;
    case 1:
      sub_1002C7C0(v17, 0, a6);
      break;
    case 2:
      sub_1002C7C0(v17, 0, a7);
      break;
    case 3:
      sub_1002D5DB(a1, a2, v17, a7, a6);
      goto LABEL_11;
    case 4:
      sub_1002C7C0(v17, 0, a8);
      break;
    case 5:
      v16 = a6;
      goto LABEL_9;
    case 6:
      v16 = a7;
LABEL_9:
      sub_1002D5DB(a1, a2, v17, a8, v16);
      goto LABEL_11;
    case 7:
      sub_1002D5DB(a1, a2, v17, a8, a7);
      sub_1002D5DB(a1, a2, v17, v17, a6);
LABEL_11:
      sub_1002C7C0(v17, 0, v17);
      break;
    default:
      break;
  }
  if ( a5 )
  {
    _m_femms();
    v8 = a5[2];
    v9 = _m_pi2fd(a5[1]);
    v10 = _m_punpckldq(_m_pfrcp(v9), _m_pfrcp(_m_punpckhdq(v9, v9)));
    v11 = _m_pfmul(
            _m_pfsub((__m64)a4->m64_u64, _m_pi2fd((__m64)a5->m64_u64)),
            _m_pfmul(_m_pfrcpit2(_m_pfrcpit1(v9, v10), v10), (__m64)0x4000000040000000LL));
    v12 = _m_pfsub(_m_punpckhdq(v8, v8), v8);
    v13 = _m_pfrcp(v12);
    v14 = _m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v8), _m_pfrcpit2(_m_pfrcpit1(v12, v13), v13));
    a3->m64_u64 = (unsigned __int64)_m_pxor(_m_pfsub(v11, (__m64)0x3F8000003F800000LL), (__m64)0x8000000000000000uLL);
    a3[1].m64_i32[0] = _mm_cvtsi64_si32(v14);
    _m_femms();
    sub_1002D550(a3, a3, v17);
  }
  else
  {
    sub_1002D550(a3, a4, v17);
  }
  return a3;
}

// sub_1002DCA8 @ 0x1002DCA8
__m64 *__stdcall sub_1002DCA8(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm3

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v6 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfmul(v5, a3[3]));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), _m_pfmul(v5, a3[2]));
  a1[1].m64_u64 = (unsigned __int64)v6;
  _m_femms();
  return a1;
}

// sub_1002DCFD @ 0x1002DCFD
__m64 *__stdcall sub_1002DCFD(__m64 *a1, __m64 *a2, __m64 *a3)
{
  _m_femms();
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfmul(_m_punpckldq((__m64)a2->m64_u64, (__m64)a2->m64_u64), (__m64)a3->m64_u64),
                                    _m_pfmul(_m_punpckhdq((__m64)a2->m64_u64, (__m64)a2->m64_u64), a3[2]));
  _m_femms();
  return a1;
}

// sub_1002DD36 @ 0x1002DD36
__m64 *__stdcall sub_1002DD36(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm4
  __m64 v6; // mm1
  __m64 v7; // mm3
  __m64 v8; // mm3
  __m64 v9; // mm4

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v6 = _m_pfmul(v5, a3[2]);
  v7 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), a3[7]), _m_pfmul(v5, a3[3]));
  v8 = _m_punpckhdq(v7, v7);
  v9 = _m_pfrcp(v8);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(_m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), a3[6]), v6),
                                    _m_pfrcpit2(_m_pfrcpit1(v8, v9), v9));
  _m_femms();
  return a1;
}

// sub_1002DD9A @ 0x1002DD9A
__m64 *__stdcall sub_1002DD9A(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_punpckldq(v16, v16), (__m64)a2->m64_u64),
                                      _m_pfmul(_m_punpckldq(v15, v15), (__m64)a3->m64_u64)),
                                    _m_pfadd(
                                      _m_pfmul(_m_punpckldq(v14, v14), (__m64)a4->m64_u64),
                                      _m_pfmul(_m_punpckldq(v9, v9), (__m64)a5->m64_u64)));
  _m_femms();
  return a1;
}

// sub_1002DE32 @ 0x1002DE32
__m64 *__stdcall sub_1002DE32(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm7

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a6);
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      (__m64)a2->m64_u64,
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), _m_punpckldq(v6, v6))),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), _m_punpckldq(v7, v7)));
  _m_femms();
  return a1;
}

// sub_1002DE7B @ 0x1002DE7B
__m64 *__stdcall sub_1002DE7B(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm0
  __m64 v4; // mm0
  __m64 v5; // mm5

  v2 = _m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64);
  v4 = _m_pfacc(v2, v2);
  v5 = _m_pfrsqrt(v4);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pand((__m64)a2->m64_u64, _m_pfcmpgt(v4, (__m64)0x80000000800000LL)),
                                    _m_pfrcpit2(_m_pfrsqit1(_m_pfmul(v5, v5), v4), v5));
  _m_femms();
  return a1;
}

// sub_1002DEBE @ 0x1002DEBE
__m64 *__stdcall sub_1002DEBE(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm4
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm1
  __m64 v16; // mm3

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(
                                      _m_pfadd(
                                        _m_pfadd(
                                          _m_pfmul(_m_punpckldq(v16, v16), (__m64)a3->m64_u64),
                                          _m_pfmul(_m_punpckhdq(v15, v15), (__m64)a2->m64_u64)),
                                        _m_pfmul(_m_punpckldq(v15, v15), (__m64)a4->m64_u64)),
                                      _m_pfmul(_m_punpckhdq(v16, v16), (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  _m_femms();
  return a1;
}

// sub_1002DF69 @ 0x1002DF69
__m64 *__stdcall sub_1002DF69(__m64 *a1, __m64 *a2, __m64 *a3)
{
  unsigned __int64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v9; // mm4

  _m_femms();
  m64_u64 = a2->m64_u64;
  v4 = _m_punpckldq((__m64)m64_u64, (__m64)m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq((__m64)m64_u64, (__m64)m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_punpckhdq(v5, v5);
  v9 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), _m_pfmul(v6, a3[3])), _m_pfadd(_m_pfmul(v7, a3[5]), _m_pfmul(v8, a3[7])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), _m_pfmul(v6, a3[2])),
                                    _m_pfadd(_m_pfmul(v7, a3[4]), _m_pfmul(v8, a3[6])));
  a1[1].m64_u64 = (unsigned __int64)v9;
  _m_femms();
  return a1;
}

// sub_1002DFEB @ 0x1002DFEB
__m64 *__stdcall sub_1002DFEB(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm0
  __m64 v4; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v8; // mm0

  _m_femms();
  v2 = a2[1];
  v3 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v2, v2));
  v4 = _m_pfacc(v3, v3);
  v6 = _m_pfrsqrt(v4);
  v7 = _m_pfcmpgt(v4, (__m64)0x80000000800000LL);
  v8 = _m_pfrcpit2(_m_pfrsqit1(v4, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v8);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v8);
  _m_femms();
  return a1;
}

// sub_1002E04A @ 0x1002E04A
__m64 *__stdcall sub_1002E04A(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v5; // mm2
  __m64 v6; // mm3
  __m64 v7; // mm4
  __m64 v8; // mm5
  __m64 v9; // mm6
  __m64 v10; // mm1
  __m64 m64_u64; // mm0
  __m64 v12; // mm7
  __m64 v13; // mm2
  __m64 v14; // mm6
  __m64 v15; // mm7

  _m_femms();
  v5 = a3[1];
  v6 = a4[1];
  v7 = _m_pfsub(
         _m_pfmul(_m_punpckhdq(v6, v6), _m_punpckhdq(_m_punpckldq(v5, v5), (__m64)a3->m64_u64)),
         _m_pfmul(_m_punpckhdq(v5, v5), _m_punpckhdq(_m_punpckldq(v6, v6), (__m64)a4->m64_u64)));
  v8 = _m_pfsub(
         _m_pfmul(_m_punpckhdq((__m64)a3->m64_u64, v5), _m_punpckldq(v6, (__m64)a4->m64_u64)),
         _m_pfmul(_m_punpckhdq((__m64)a4->m64_u64, v6), _m_punpckldq(v5, (__m64)a3->m64_u64)));
  v9 = _m_pfsub(
         _m_pfmul(
           _m_punpckldq((__m64)a4->m64_u64, (__m64)a4->m64_u64),
           _m_punpckhdq(_m_punpckldq(v5, v5), (__m64)a3->m64_u64)),
         _m_pfmul(
           _m_punpckldq((__m64)a3->m64_u64, (__m64)a3->m64_u64),
           _m_punpckhdq(_m_punpckldq(v6, v6), (__m64)a4->m64_u64)));
  v10 = a2[1];
  m64_u64 = (__m64)a2->m64_u64;
  a1->m64_u64 = (unsigned __int64)_m_pfsub(
                                    _m_pfmul(
                                      _m_pxor(_m_punpckldq(v7, v7), (__m64)0x8000000000000000uLL),
                                      _m_punpckhdq(
                                        (__m64)a2->m64_u64,
                                        _m_punpckldq((__m64)a2->m64_u64, (__m64)a2->m64_u64))),
                                    _m_pfacc(
                                      _m_pxor(
                                        _m_pfmul(_m_punpckldq(_m_punpckhdq(v7, v7), v8), v10),
                                        (__m64)0x8000000000000000uLL),
                                      _m_pxor(
                                        _m_pfmul(_m_punpckldq(_m_punpckhdq(v8, v8), v9), v10),
                                        (__m64)0x8000000000000000uLL)));
  v12 = _m_psrlqi((__m64)0x8000000000000000uLL, 0x20u);
  v13 = _m_pxor(_m_punpckldq(v8, v9), v12);
  v14 = _m_pxor(_m_punpckhdq(v9, v9), v12);
  v15 = _m_psllqi(v12, 0x20u);
  a1[1].m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_punpckhdq(v10, _m_punpckldq(v10, v10)), v14),
                                      _m_pfacc(
                                        _m_pxor(
                                          _m_pfmul(_m_pxor(_m_punpckhdq(v7, v8), (__m64)0x8000000000000000uLL), m64_u64),
                                          v15),
                                        _m_pxor(_m_pfmul(v13, m64_u64), v15)));
  _m_femms();
  return a1;
}

// sub_1002E17C @ 0x1002E17C
__m64 *__stdcall sub_1002E17C(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, unsigned int a5, unsigned int a6)
{
  __m64 v6; // mm6
  __m64 v7; // mm7
  __m64 v9; // mm6
  __m64 v10; // mm7
  __m64 v11; // mm1

  v6 = _mm_cvtsi32_si64(a5);
  v7 = _mm_cvtsi32_si64(a6);
  v9 = _m_punpckldq(v6, v6);
  v10 = _m_punpckldq(v7, v7);
  v11 = _m_pfadd(_m_pfadd(_m_pfmul(_m_pfsub(a3[1], a2[1]), v9), a2[1]), _m_pfmul(_m_pfsub(a4[1], a2[1]), v10));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a3->m64_u64, (__m64)a2->m64_u64), v9),
                                      (__m64)a2->m64_u64),
                                    _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a2->m64_u64), v10));
  a1[1].m64_u64 = (unsigned __int64)v11;
  _m_femms();
  return a1;
}

// sub_1002E1ED @ 0x1002E1ED
__m64 *__stdcall sub_1002E1ED(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm1
  __m64 v8; // mm2
  __m64 v9; // mm7
  __m64 v10; // mm4
  __m64 v11; // mm6
  __m64 v12; // mm2
  __m64 v13; // mm5
  __m64 v14; // mm1
  __m64 v15; // mm6
  __m64 v16; // mm2
  __m64 v17; // mm5
  __m64 v18; // mm0
  __m64 v19; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm3
  __m64 v23; // mm0

  _m_femms();
  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_pfmul(v6, v6);
  v8 = _m_pfmul(v7, v6);
  v9 = _m_pfsub(v8, v7);
  v10 = _m_pfmul(v7, (__m64)0x4000000040000000LL);
  v11 = v8;
  v12 = _m_pfmul(v8, (__m64)0x4000000040000000LL);
  v13 = _m_pfmul(v7, (__m64)0x4040000040400000LL);
  v14 = _m_pfsub(v13, v12);
  v15 = _m_pfadd(_m_pfsub(v11, v10), v6);
  v16 = _m_pfadd(_m_pfsub(v12, v13), (__m64)0x3F8000003F800000LL);
  v17 = _m_punpckldq(v9, v9);
  v18 = _m_punpckldq(v14, v14);
  v19 = _m_pfmul(v18, (__m64)a4->m64_u64);
  v21 = _m_punpckldq(v15, v15);
  v22 = _m_punpckldq(v16, v16);
  v23 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, a4[1]), _m_pfmul(v17, a5[1])),
          _m_pfadd(_m_pfmul(v22, a2[1]), _m_pfmul(v21, a3[1])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(v19, _m_pfmul(v17, (__m64)a5->m64_u64)),
                                    _m_pfadd(_m_pfmul(v22, (__m64)a2->m64_u64), _m_pfmul(v21, (__m64)a3->m64_u64)));
  a1[1].m64_u64 = (unsigned __int64)v23;
  _m_femms();
  return a1;
}

// sub_1002E2B5 @ 0x1002E2B5
__m64 *__stdcall sub_1002E2B5(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4, __m64 *a5, unsigned int a6)
{
  __m64 v6; // mm1
  __m64 v7; // mm0
  __m64 v8; // mm1
  __m64 v9; // mm0
  __m64 v10; // mm3
  __m64 v11; // mm1
  __m64 v12; // mm0
  __m64 v13; // mm5
  __m64 v14; // mm0
  __m64 v15; // mm2
  __m64 v16; // mm3
  __m64 v17; // mm4
  __m64 v18; // mm5
  __m64 v19; // mm6
  __m64 v20; // mm7
  __m64 v22; // mm0
  __m64 v23; // mm4

  v6 = _mm_cvtsi32_si64(a6);
  v7 = _m_punpckldq(v6, v6);
  v8 = _m_punpckldq(v6, (__m64)1065353216LL);
  v9 = _m_pfmul(_m_pfmul(v7, v7), v8);
  v10 = v8;
  v11 = _m_pfmul(v8, v8);
  v12 = _m_pfsub(v9, v11);
  v13 = _m_pfmul(v12, (__m64)0x4000000040400000LL);
  v14 = _m_punpckldq(v13, v12);
  v15 = _m_pfsub(_m_pfadd(_m_punpckldq(v11, v11), _m_pxor(_m_punpckldq(v10, v10), (__m64)0x8000000000000000uLL)), v14);
  v16 = _m_pfsub(v14, _m_punpckhdq(v13, 0));
  v17 = _m_punpckhdq(v15, v15);
  v18 = _m_punpckldq(v16, v16);
  v19 = _m_punpckldq(v15, v15);
  v20 = _m_punpckhdq(v16, v16);
  v22 = _m_pfadd(
          _m_pfadd(_m_pfmul(v18, (__m64)a3->m64_u64), _m_pfmul(v17, (__m64)a2->m64_u64)),
          _m_pfmul(v19, (__m64)a4->m64_u64));
  v23 = _m_pfadd(
          _m_pfadd(_m_pfadd(_m_pfmul(v17, a2[1]), _m_pfmul(v18, a3[1])), _m_pfmul(v19, a4[1])),
          _m_pfmul(v20, a5[1]));
  a1->m64_u64 = (unsigned __int64)_m_pfmul(
                                    _m_pfadd(v22, _m_pfmul(v20, (__m64)a5->m64_u64)),
                                    (__m64)0x3F0000003F000000LL);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(v23, (__m64)0x3F0000003F000000LL);
  _m_femms();
  return a1;
}

// sub_1002E393 @ 0x1002E393
__m64 *__stdcall sub_1002E393(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 v4; // mm1
  __m64 v5; // mm2
  __m64 v6; // mm2

  _m_femms();
  v4 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v5 = _m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  v6 = _m_pfadd(_m_pfacc(v5, v5), _m_pfmul(_mm_cvtsi32_si64(a2[1].m64_u32[0]), v4));
  a1->m64_u64 = a3->m64_u64;
  a1[1].m64_i32[0] = _mm_cvtsi64_si32(v4);
  a1[1].m64_i32[1] = _mm_cvtsi64_si32(_m_pxor(v6, (__m64)0x80000000LL));
  _m_femms();
  return a1;
}

// sub_1002E3D6 @ 0x1002E3D6
__m64 *__stdcall sub_1002E3D6(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v4; // mm2
  __m64 v5; // mm1
  __m64 v6; // mm4
  __m64 v7; // mm7
  __m64 v8; // mm5
  __m64 v9; // mm0
  __m64 v10; // mm1
  __m64 v11; // mm1
  __m64 v12; // mm7
  __m64 v13; // mm6
  __m64 v14; // mm6
  __m64 v15; // mm4
  __m64 v16; // mm5
  __m64 v17; // mm6
  unsigned __int64 v19; // mm4
  __m64 v20; // mm5
  __m64 v21; // mm0

  _m_femms();
  v4 = _mm_cvtsi32_si64(a2[1].m64_u32[0]);
  v5 = _m_pfsub(_m_punpckldq(v4, v4), _m_punpckldq(_mm_cvtsi32_si64(a4[1].m64_u32[0]), (__m64)a3[1].m64_u32[0]));
  v6 = _m_pfsub((__m64)a2->m64_u64, (__m64)a4->m64_u64);
  v7 = _m_pfsub(0, v6);
  v8 = _m_pfsub((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  v9 = _m_pxor(
         _m_pfacc(
           _m_pfmul(_m_punpckhdq(v8, v7), v5),
           _m_pfmul(_m_punpckldq(_m_punpckhdq(v5, (__m64)0x8000000000000000uLL), v8), _m_punpckldq(v7, v5))),
         (__m64)0x8000000000000000uLL);
  v10 = _m_pfmul(_m_punpckhdq(v6, _m_punpckldq(v6, v7)), v8);
  v11 = _m_pfacc(v10, v10);
  v12 = _m_psllqi(v11, 0x20u);
  v13 = _m_pfadd(_m_pfmul(v9, v9), _m_pfmul(v12, v12));
  v14 = _m_pfacc(v13, v13);
  v15 = _m_pfrsqrt(v14);
  v16 = _m_pfcmpgt(v14, (__m64)0x80000000800000LL);
  v17 = _m_pfrcpit2(_m_pfrsqit1(v14, _m_pfmul(v15, v15)), v15);
  v19 = (unsigned __int64)_m_pfmul(_m_pand(v9, v16), v17);
  v20 = _m_pfmul(_m_pand(v11, v16), v17);
  v21 = _m_pfmul((__m64)v19, (__m64)a2->m64_u64);
  a1->m64_u64 = v19;
  a1[1].m64_u64 = (unsigned __int64)_m_pxor(
                                      _m_punpckldq(v20, _m_pfadd(_m_pfacc(v21, v21), _m_pfmul(v20, v4))),
                                      (__m64)0x8000000000000000uLL);
  _m_femms();
  return a1;
}

// sub_1002E4BA @ 0x1002E4BA
__m64 *__stdcall sub_1002E4BA(__m64 *a1, __m64 *a2, __m64 *a3, __m64 *a4)
{
  __m64 v4; // mm7
  __m64 v5; // mm4
  __m64 v6; // mm7
  __m64 v7; // mm4
  __m64 v8; // mm5
  __m64 *result; // eax
  __m64 v10; // mm2
  __m64 v11; // mm2
  __m64 v12; // mm2
  __m64 v13; // mm5

  v4 = _mm_cvtsi32_si64(a3[1].m64_u32[0]);
  v5 = _m_pfsub(
         _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64), _m_pfmul(a2[1], v4)),
         _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a4->m64_u64), _m_pfmul(a2[1], _mm_cvtsi32_si64(a4[1].m64_u32[0]))));
  v6 = _m_punpckldq(v4, (__m64)1065353216LL);
  v7 = _m_pfacc(v5, v5);
  v8 = _m_pfrcp(v7);
  result = a1;
  v10 = _m_pfmul((__m64)a2->m64_u64, (__m64)a3->m64_u64);
  if ( _mm_cvtsi64_si32(_m_pfcmpeq(0, v7)) )
  {
    result = 0;
  }
  else
  {
    v11 = _m_pfadd(v10, _m_pfmul(a2[1], v6));
    v12 = _m_pfmul(_m_pfacc(v11, v11), _m_pfrcpit2(_m_pfrcpit1(v7, v8), v8));
    v13 = _m_pfadd(_m_pfmul(_m_pfsub(_mm_cvtsi32_si64(a4[1].m64_u32[0]), v6), v12), v6);
    a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                      _m_pfmul(_m_pfsub((__m64)a4->m64_u64, (__m64)a3->m64_u64), v12),
                                      (__m64)a3->m64_u64);
    a1[1].m64_i32[0] = _mm_cvtsi64_si32(v13);
  }
  _m_femms();
  return result;
}

// sub_1002E578 @ 0x1002E578
__m64 *__stdcall sub_1002E578(__m64 *a1, __m64 *a2)
{
  __m64 v2; // mm3
  __m64 v3; // mm2
  __m64 v4; // mm0
  __m64 v5; // mm0
  __m64 v6; // mm4
  __m64 v7; // mm5
  __m64 v9; // mm0

  v2 = a2[1];
  v3 = _m_pand(v2, (__m64)0xFFFFFFFFLL);
  v4 = _m_pfadd(_m_pfmul((__m64)a2->m64_u64, (__m64)a2->m64_u64), _m_pfmul(v3, v3));
  v5 = _m_pfacc(v4, v4);
  v6 = _m_pfrsqrt(v5);
  v7 = _m_pfcmpgt(v5, (__m64)0x80000000800000LL);
  v9 = _m_pfrcpit2(_m_pfrsqit1(v5, _m_pfmul(v6, v6)), v6);
  a1->m64_u64 = (unsigned __int64)_m_pfmul(_m_pand((__m64)a2->m64_u64, v7), v9);
  a1[1].m64_u64 = (unsigned __int64)_m_pfmul(_m_pand(v2, v7), v9);
  _m_femms();
  return a1;
}

// sub_1002E5DC @ 0x1002E5DC
__m64 *__stdcall sub_1002E5DC(__m64 *a1, __m64 *a2, __m64 *a3)
{
  __m64 m64_u64; // mm1
  __m64 v4; // mm0
  __m64 v5; // mm3
  __m64 v6; // mm5
  __m64 v7; // mm6
  __m64 v8; // mm7
  __m64 v10; // mm4

  _m_femms();
  m64_u64 = (__m64)a2->m64_u64;
  v4 = _m_punpckldq(m64_u64, m64_u64);
  v5 = a2[1];
  v6 = _m_punpckhdq(m64_u64, m64_u64);
  v7 = _m_punpckldq(v5, v5);
  v8 = _m_punpckhdq(v5, v5);
  v10 = _m_pfadd(_m_pfadd(_m_pfmul(v4, a3[1]), _m_pfmul(v6, a3[3])), _m_pfadd(_m_pfmul(v7, a3[5]), _m_pfmul(v8, a3[7])));
  a1->m64_u64 = (unsigned __int64)_m_pfadd(
                                    _m_pfadd(_m_pfmul(v4, (__m64)a3->m64_u64), _m_pfmul(v6, a3[2])),
                                    _m_pfadd(_m_pfmul(v7, a3[4]), _m_pfmul(v8, a3[6])));
  a1[1].m64_u64 = (unsigned __int64)v10;
  _m_femms();
  return a1;
}

// FUN_1002e65a @ 0x1002E65A
// [binja] int32_t sub_1002e65a(uint32_t arg1)
void *__cdecl sub_1002E65A(int a1, size_t Size)
{
  return malloc(Size);
}

// zcfree @ 0x1002E665
// zlib (internal): default free wrapper
void __cdecl sub_1002E665(int a1, void *Block)
{
  free(Block);
}

// FUN_1002e670 @ 0x1002E670
// [binja] int32_t sub_1002e670(int32_t arg1) __pure
int __cdecl sub_1002E670(int a1, int a2, int a3)
{
  return a3;
}

// sub_1002E675 @ 0x1002E675
int __cdecl sub_1002E675(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_1002E689 @ 0x1002E689
int sub_1002E689()
{
  return 0;
}

// sub_1002E68C @ 0x1002E68C
int __usercall sub_1002E68C@<eax>(int a1@<esi>)
{
  int v1; // ebx
  int v2; // edi
  int v3; // eax
  int result; // eax
  _DWORD *v5; // ecx
  int v6; // edi
  int v7; // eax
  int v8; // ecx
  int v9; // [esp+8h] [ebp-10h]
  int v10; // [esp+Ch] [ebp-Ch]
  _DWORD *i; // [esp+10h] [ebp-8h]
  int v12; // [esp+14h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 384);
  v2 = *(_DWORD *)(a1 + 276);
  v3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD *)(a1 + 32));
  v12 = 0;
  *(_DWORD *)(v1 + 56) = v3;
  *(_DWORD *)(v1 + 60) = v3 + 4 * *(_DWORD *)(a1 + 32);
  result = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 32) > 0 )
  {
    v5 = (_DWORD *)(result + 12);
    v10 = v2 + 4;
    for ( i = (_DWORD *)(result + 12); ; v5 = i )
    {
      v6 = *v5 * v5[6] / *(_DWORD *)(a1 + 276) * v10;
      v9 = *v5 * v5[6] / *(_DWORD *)(a1 + 276);
      i += 21;
      v7 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * v6) + 4 * v9;
      v8 = 4 * v12;
      *(_DWORD *)(v8 + *(_DWORD *)(v1 + 56)) = v7;
      ++v12;
      *(_DWORD *)(v8 + *(_DWORD *)(v1 + 60)) = v7 + 4 * v6;
      result = v12;
      if ( v12 >= *(_DWORD *)(a1 + 32) )
        break;
    }
  }
  return result;
}

// sub_1002E734 @ 0x1002E734
int __usercall sub_1002E734@<eax>(_DWORD *a1@<edi>)
{
  _DWORD *v1; // ebx
  int result; // eax
  _DWORD *v3; // ecx
  int v4; // eax
  int v5; // edx
  int v6; // esi
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // ecx
  int *v10; // ecx
  int v11; // edx
  _DWORD *v12; // esi
  bool v13; // zf
  _DWORD *v14; // ecx
  int *v15; // [esp+4h] [ebp-2Ch]
  _DWORD *v16; // [esp+8h] [ebp-28h]
  _DWORD *v17; // [esp+Ch] [ebp-24h]
  int v18; // [esp+10h] [ebp-20h]
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  _DWORD *v21; // [esp+18h] [ebp-18h]
  int *v22; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h]
  int v24; // [esp+20h] [ebp-10h]
  int v25; // [esp+24h] [ebp-Ch]
  _DWORD *v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+2Ch] [ebp-4h]

  v25 = 0;
  v1 = (_DWORD *)a1[96];
  v20 = a1[69];
  result = a1[49];
  v16 = v1;
  if ( (int)a1[8] > 0 )
  {
    v3 = (_DWORD *)(result + 12);
    v21 = (_DWORD *)(result + 12);
    v22 = v1 + 2;
    while ( 1 )
    {
      v4 = *v3 * v3[6] / a1[69];
      v17 = *(_DWORD **)(4 * v25 + v1[14]);
      v5 = *(_DWORD *)(4 * v25 + v1[15]);
      v6 = *v22;
      v7 = v4 * (v20 + 2);
      v18 = v4;
      if ( v7 > 0 )
      {
        v8 = *(_DWORD **)(4 * v25 + v1[15]);
        v23 = v7;
        do
        {
          v9 = *(_DWORD *)((char *)v8 + v6 - v5);
          *v8 = v9;
          *(_DWORD *)((char *)v8++ + (_DWORD)v17 - v5) = v9;
          --v23;
        }
        while ( v23 );
        v1 = v16;
        v4 = v18;
      }
      if ( 2 * v4 > 0 )
      {
        v26 = (_DWORD *)(v5 + 4 * v20 * v4);
        v4 = v18;
        v15 = (int *)(v6 + 4 * v18 * (v20 - 2));
        v27 = v6 - v5;
        v24 = v5 - v6;
        v19 = 2 * v18;
        v10 = v15;
        do
        {
          *(int *)((char *)v10 + v24) = *(_DWORD *)((char *)v26 + v27);
          v11 = *v10;
          v12 = v26++;
          ++v10;
          v13 = v19-- == 1;
          *v12 = v11;
        }
        while ( !v13 );
      }
      if ( v4 > 0 )
      {
        v14 = &v17[-v4];
        do
        {
          *v14++ = *v17;
          --v4;
        }
        while ( v4 );
      }
      result = ++v25;
      ++v22;
      v21 += 21;
      if ( v25 >= a1[8] )
        break;
      v3 = v21;
    }
  }
  return result;
}

// sub_1002E865 @ 0x1002E865
int __usercall sub_1002E865@<eax>(_DWORD *a1@<edi>)
{
  int v1; // ecx
  int result; // eax
  int v3; // esi
  _DWORD *v4; // ebx
  int *v5; // edx
  int *v6; // ebx
  int *v7; // ecx
  int *v8; // eax
  int v9; // esi
  int v10; // edx
  int v11; // [esp+4h] [ebp-1Ch]
  int v12; // [esp+8h] [ebp-18h]
  int v13; // [esp+Ch] [ebp-14h]
  _DWORD *v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+18h] [ebp-8h]
  int *v17; // [esp+1Ch] [ebp-4h]

  v1 = a1[96];
  v16 = 0;
  result = a1[49];
  v3 = a1[69];
  v11 = v1;
  v12 = v3;
  if ( (int)a1[8] > 0 )
  {
    v4 = (_DWORD *)(result + 12);
    v14 = (_DWORD *)(result + 12);
    do
    {
      v15 = *v4 * v4[6] / a1[69];
      v13 = *(_DWORD *)(4 * v16 + *(_DWORD *)(v1 + 56));
      v5 = *(int **)(4 * v16 + *(_DWORD *)(v1 + 60));
      if ( v15 > 0 )
      {
        v6 = &v5[v15 * (v3 + 2)];
        v7 = &v5[-v15];
        v8 = &v5[v15 * (v3 + 1)];
        v17 = v5;
        v9 = v13 - (_DWORD)v5;
        do
        {
          *(int *)((char *)v7 + v9) = *(int *)((char *)v8 + v9);
          *v7 = *v8;
          *(int *)((char *)v6 + v9) = *(int *)((char *)v17 + v9);
          v10 = *v17++;
          *v6 = v10;
          ++v8;
          ++v7;
          ++v6;
          --v15;
        }
        while ( v15 );
        v3 = v12;
        v1 = v11;
        v4 = v14;
      }
      result = ++v16;
      v4 += 21;
      v14 = v4;
    }
    while ( v16 < a1[8] );
  }
  return result;
}

// sub_1002E939 @ 0x1002E939
int __usercall sub_1002E939@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax
  int v2; // ebx
  _DWORD *v3; // edi
  int v4; // eax
  _DWORD *v5; // edx
  int v6; // [esp+4h] [ebp-Ch]
  int v7; // [esp+4h] [ebp-Ch]
  unsigned int v8; // [esp+8h] [ebp-8h]
  int v9; // [esp+Ch] [ebp-4h]

  v9 = 0;
  result = a1[49];
  v2 = a1[96];
  if ( (int)a1[8] > 0 )
  {
    v3 = (_DWORD *)(result + 12);
    do
    {
      v6 = *v3 * v3[6] / a1[69];
      v8 = v3[8] % (unsigned int)(*v3 * v3[6]);
      if ( !v8 )
        v8 = *v3 * v3[6];
      if ( !v9 )
        *(_DWORD *)(v2 + 72) = (int)(v8 - 1) / v6 + 1;
      if ( 2 * v6 > 0 )
      {
        v4 = *(_DWORD *)(*(_DWORD *)(v2 + 4 * *(_DWORD *)(v2 + 64) + 56) + 4 * v9) + 4 * v8;
        v5 = (_DWORD *)v4;
        v7 = 2 * v6;
        do
        {
          *v5++ = *(_DWORD *)(v4 - 4);
          --v7;
        }
        while ( v7 );
      }
      result = ++v9;
      v3 += 21;
    }
    while ( v9 < a1[8] );
  }
  return result;
}

// sub_1002E9CF @ 0x1002E9CF
int __cdecl sub_1002E9CF(_DWORD *a1, int a2, int a3, int a4)
{
  int v5; // esi
  int result; // eax
  unsigned int v7; // [esp+10h] [ebp+8h]

  v5 = a1[96];
  if ( !*(_BYTE *)(v5 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[97] + 12))(a1, v5 + 8);
    if ( !result )
      return result;
    *(_BYTE *)(v5 + 48) = 1;
  }
  v7 = a1[69];
  (*(void (__cdecl **)(_DWORD *, int, int, _DWORD, int, int, int))(a1[98] + 4))(a1, v5 + 8, v5 + 52, a1[69], a2, a3, a4);
  result = v7;
  if ( *(_DWORD *)(v5 + 52) >= v7 )
  {
    *(_BYTE *)(v5 + 48) = 0;
    *(_DWORD *)(v5 + 52) = 0;
  }
  return result;
}

// sub_1002EA37 @ 0x1002EA37
unsigned int __cdecl sub_1002EA37(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4)
{
  int v4; // ebx
  unsigned int result; // eax
  int v6; // eax
  int v7; // eax

  v4 = a1[96];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[97] + 12))(a1, *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56));
    if ( !result )
      return result;
    ++*(_DWORD *)(v4 + 76);
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = *(_DWORD *)(v4 + 68);
  if ( !v6 )
  {
LABEL_9:
    *(_DWORD *)(v4 + 52) = 0;
    *(_DWORD *)(v4 + 72) = a1[69] - 1;
    if ( *(_DWORD *)(v4 + 76) == a1[70] )
      sub_1002E939(a1);
    *(_DWORD *)(v4 + 68) = 1;
    goto LABEL_12;
  }
  v7 = v6 - 1;
  if ( v7 )
  {
    result = v7 - 1;
    if ( result )
      return result;
    (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
      a1,
      *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
      v4 + 52,
      *(_DWORD *)(v4 + 72),
      a2,
      a3,
      a4);
    result = *(_DWORD *)(v4 + 52);
    if ( result < *(_DWORD *)(v4 + 72) )
      return result;
    result = a4;
    *(_DWORD *)(v4 + 68) = 0;
    if ( *a3 >= a4 )
      return result;
    goto LABEL_9;
  }
LABEL_12:
  (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
    a1,
    *(_DWORD *)(v4 + 4 * *(_DWORD *)(v4 + 64) + 56),
    v4 + 52,
    *(_DWORD *)(v4 + 72),
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 52);
  if ( result >= *(_DWORD *)(v4 + 72) )
  {
    if ( *(_DWORD *)(v4 + 76) == 1 )
      sub_1002E865(a1);
    *(_DWORD *)(v4 + 64) ^= 1u;
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = a1[69] + 1;
    *(_DWORD *)(v4 + 72) = a1[69] + 2;
    *(_DWORD *)(v4 + 68) = 2;
    return 2;
  }
  return result;
}

// sub_1002EB3F @ 0x1002EB3F
int __cdecl sub_1002EB3F(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD *)(a1 + 392) + 4))(
           a1,
           0,
           0,
           0,
           a2,
           a3,
           a4);
}

// sub_1002EB62 @ 0x1002EB62
int __cdecl sub_1002EB62(_DWORD *a1, int a2)
{
  int v2; // esi
  int result; // eax

  v2 = a1[96];
  if ( a2 )
  {
    result = a2 - 2;
    if ( a2 == 2 )
    {
      *(_DWORD *)(v2 + 4) = sub_1002EB3F;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 4;
      return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  else
  {
    result = a1[103];
    if ( *(_BYTE *)(result + 8) )
    {
      *(_DWORD *)(v2 + 4) = sub_1002EA37;
      result = sub_1002E734(a1);
      *(_DWORD *)(v2 + 64) = 0;
      *(_DWORD *)(v2 + 68) = 0;
      *(_DWORD *)(v2 + 76) = 0;
    }
    else
    {
      *(_DWORD *)(v2 + 4) = sub_1002E9CF;
    }
    *(_BYTE *)(v2 + 48) = 0;
    *(_DWORD *)(v2 + 52) = 0;
  }
  return result;
}

// sub_1002EBCA @ 0x1002EBCA
int __cdecl sub_1002EBCA(int a1, char a2)
{
  _DWORD *v3; // ebx
  int result; // eax
  int v5; // ecx
  _DWORD *v6; // edi
  _DWORD *v7; // ebx
  int v8; // [esp+14h] [ebp+8h]
  int v9; // [esp+18h] [ebp+Ch]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 384) = v3;
  *v3 = sub_1002EB62;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 412) + 8) )
  {
    if ( *(int *)(a1 + 276) < 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    result = sub_1002E68C(a1);
    v5 = *(_DWORD *)(a1 + 276) + 2;
    v9 = v5;
  }
  else
  {
    result = *(_DWORD *)(a1 + 276);
    v9 = result;
    v5 = result;
  }
  v8 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    v7 = v3 + 2;
    while ( 1 )
    {
      ++v8;
      *v7 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
              a1,
              1,
              *v6 * *(v6 - 2),
              v5 * (*v6 * *(v6 - 6) / *(_DWORD *)(a1 + 276)));
      result = v8;
      ++v7;
      v6 += 21;
      if ( v8 >= *(_DWORD *)(a1 + 32) )
        break;
      v5 = v9;
    }
  }
  return result;
}

// FUN_1002ec9d @ 0x1002EC9D
// [binja] void* __fastcall sub_1002ec9d(void* arg1)
_DWORD *__thiscall sub_1002EC9D(_DWORD *this)
{
  _DWORD *result; // eax
  bool v2; // cf
  int v3; // ecx
  int v4; // ecx

  result = (_DWORD *)*(this + 97);
  if ( (int)*(this + 72) <= 1 )
  {
    v2 = *(this + 32) < (unsigned int)(*(this + 70) - 1);
    v3 = *(this + 73);
    if ( v2 )
      v4 = *(_DWORD *)(v3 + 12);
    else
      v4 = *(_DWORD *)(v3 + 72);
    result[7] = v4;
  }
  else
  {
    result[7] = 1;
  }
  result[5] = 0;
  result[6] = 0;
  return result;
}

// sub_1002ECDC @ 0x1002ECDC
_DWORD *__cdecl sub_1002ECDC(_DWORD *a1)
{
  a1[32] = 0;
  return FUN_1002ec9d(a1);
}

// sub_1002ECEC @ 0x1002ECEC
int __cdecl sub_1002ECEC(_DWORD *a1, int a2)
{
  int v3; // ebx
  unsigned int v4; // esi
  int v5; // eax
  int v6; // eax
  _DWORD *v7; // esi
  int v8; // ecx
  int v9; // ebx
  void (__cdecl *v12)(_DWORD *, _DWORD *, _DWORD, int, int); // [esp+Ch] [ebp-38h]
  unsigned int v13; // [esp+10h] [ebp-34h]
  unsigned int v14; // [esp+14h] [ebp-30h]
  int v15; // [esp+18h] [ebp-2Ch]
  int v16; // [esp+1Ch] [ebp-28h]
  _DWORD *v17; // [esp+20h] [ebp-24h]
  int v18; // [esp+24h] [ebp-20h]
  int i; // [esp+28h] [ebp-1Ch]
  int v20; // [esp+2Ch] [ebp-18h]
  _DWORD *v21; // [esp+30h] [ebp-14h]
  int v22; // [esp+34h] [ebp-10h]
  int v23; // [esp+38h] [ebp-Ch]
  int v24; // [esp+3Ch] [ebp-8h]
  int v25; // [esp+40h] [ebp-4h]
  unsigned int v26; // [esp+4Ch] [ebp+8h]

  v3 = a1[97];
  v4 = a1[77] - 1;
  v13 = a1[70] - 1;
  v5 = *(_DWORD *)(v3 + 24);
  v18 = v3;
  v14 = v4;
  while ( 1 )
  {
    v25 = v5;
    if ( v5 >= *(_DWORD *)(v3 + 28) )
    {
      ++a1[34];
      if ( ++a1[32] >= a1[70] )
      {
        (*(void (__cdecl **)(_DWORD *))(a1[99] + 12))(a1);
        return 4;
      }
      else
      {
        FUN_1002ec9d(a1);
        return 3;
      }
    }
    v26 = *(_DWORD *)(v3 + 20);
    if ( v26 <= v4 )
      break;
LABEL_24:
    *(_DWORD *)(v3 + 20) = 0;
    ++v5;
  }
  while ( 1 )
  {
    memzero(*(void **)(v3 + 32), a1[79] << 7);
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, int))(a1[101] + 4))(a1, v3 + 32) )
      break;
    v6 = 0;
    v20 = 0;
    v23 = 0;
    if ( (int)a1[72] > 0 )
    {
      v17 = a1 + 73;
      do
      {
        v7 = (_DWORD *)*v17;
        if ( *(_BYTE *)(*v17 + 48) )
        {
          v12 = *(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, int))(a1[102] + 4 * v7[1] + 4);
          if ( v26 >= v14 )
            v8 = v7[17];
          else
            v8 = v7[13];
          v9 = v26 * v7[16];
          v24 = 0;
          v16 = v8;
          for ( i = *(_DWORD *)(a2 + 4 * v23) + 4 * v25 * v7[9]; v24 < v7[14]; v20 = v6 )
          {
            if ( a1[32] < v13 || v25 + v24 < v7[18] )
            {
              v22 = v9;
              if ( v16 > 0 )
              {
                v21 = (_DWORD *)(v18 + 4 * v6 + 32);
                v15 = v16;
                do
                {
                  v12(a1, v7, *v21, i, v22);
                  v22 += v7[9];
                  ++v21;
                  --v15;
                }
                while ( v15 );
                v6 = v20;
              }
            }
            v6 += v7[13];
            ++v24;
            i += 4 * v7[9];
          }
          v3 = v18;
        }
        else
        {
          v6 += v7[15];
          v20 = v6;
        }
        ++v23;
        ++v17;
      }
      while ( v23 < a1[72] );
      v4 = v14;
    }
    if ( ++v26 > v4 )
    {
      v5 = v25;
      goto LABEL_24;
    }
  }
  *(_DWORD *)(v3 + 24) = v25;
  *(_DWORD *)(v3 + 20) = v26;
  return 0;
}

// sub_1002EEC6 @ 0x1002EEC6
int sub_1002EEC6()
{
  return 0;
}

// sub_1002EEC9 @ 0x1002EEC9
int __cdecl sub_1002EEC9(_DWORD *a1)
{
  _DWORD *v2; // edi
  int v3; // eax
  _DWORD *i; // eax
  unsigned int v5; // ebx
  bool v6; // cf
  bool v7; // cc
  int v8; // ecx
  int v9; // ebx
  int v10; // edx
  int *j; // ebx
  _DWORD v14[4]; // [esp+Ch] [ebp-34h]
  int *v15; // [esp+1Ch] [ebp-24h]
  int v16; // [esp+20h] [ebp-20h]
  unsigned int v17; // [esp+24h] [ebp-1Ch]
  _DWORD *v18; // [esp+28h] [ebp-18h]
  int v19; // [esp+2Ch] [ebp-14h]
  _DWORD *v20; // [esp+30h] [ebp-10h]
  int v21; // [esp+34h] [ebp-Ch]
  int v22; // [esp+38h] [ebp-8h]
  _DWORD *v23; // [esp+3Ch] [ebp-4h]
  int v24; // [esp+48h] [ebp+8h]
  int v25; // [esp+48h] [ebp+8h]

  v24 = 0;
  v2 = (_DWORD *)a1[97];
  if ( (int)a1[72] > 0 )
  {
    v23 = a1 + 73;
    do
    {
      v3 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(a1[1] + 32))(
             a1,
             v2[*(_DWORD *)(*v23 + 4) + 18],
             *(_DWORD *)(*v23 + 12) * a1[32],
             *(_DWORD *)(*v23 + 12),
             1);
      ++v23;
      v14[v24++] = v3;
    }
    while ( v24 < a1[72] );
  }
  for ( i = (_DWORD *)v2[6]; ; i = (_DWORD *)((char *)i + 1) )
  {
    v7 = (int)i < v2[7];
    v23 = i;
    if ( !v7 )
    {
      if ( ++a1[32] >= a1[70] )
      {
        (*(void (__cdecl **)(_DWORD *))(a1[99] + 12))(a1);
        return 4;
      }
      else
      {
        FUN_1002ec9d(a1);
        return 3;
      }
    }
    v5 = v2[5];
    v6 = v5 < a1[77];
    v17 = v5;
    if ( v6 )
      break;
LABEL_20:
    v2[5] = 0;
  }
  while ( 1 )
  {
    v7 = a1[72] <= 0;
    v22 = 0;
    v25 = 0;
    if ( !v7 )
    {
      v18 = a1 + 73;
      do
      {
        v8 = *v18;
        v9 = *(_DWORD *)(*v18 + 52);
        v19 = 0;
        if ( *(int *)(v8 + 56) > 0 )
        {
          v16 = (v17 * v9) << 7;
          v20 = (_DWORD *)(v14[v25] + 4 * (_DWORD)v23);
          do
          {
            v10 = v16 + *v20;
            v21 = 0;
            if ( v9 > 0 )
            {
              for ( j = &v2[v22 + 8]; ; j = v15 )
              {
                ++v22;
                *j = v10;
                v10 += 128;
                ++v21;
                v15 = j + 1;
                v9 = *(_DWORD *)(v8 + 52);
                if ( v21 >= v9 )
                  break;
              }
            }
            ++v19;
            ++v20;
          }
          while ( v19 < *(_DWORD *)(v8 + 56) );
        }
        ++v25;
        ++v18;
      }
      while ( v25 < a1[72] );
      v5 = v17;
    }
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(a1[101] + 4))(a1, v2 + 8) )
      break;
    v6 = ++v5 < a1[77];
    v17 = v5;
    if ( !v6 )
    {
      i = v23;
      goto LABEL_20;
    }
  }
  v2[6] = v23;
  v2[5] = v5;
  return 0;
}

// sub_1002F068 @ 0x1002F068
int __cdecl sub_1002F068(int a1, int a2)
{
  unsigned int v3; // ebx
  int v4; // eax
  int v5; // ecx
  int result; // eax
  int v7; // edi
  int v8; // ecx
  unsigned int v9; // eax
  int v10; // ebx
  unsigned int v11; // [esp+8h] [ebp-24h]
  void (__cdecl *v12)(int, int, int, int, int); // [esp+Ch] [ebp-20h]
  int v13; // [esp+10h] [ebp-1Ch]
  int v14; // [esp+14h] [ebp-18h]
  _DWORD *v15; // [esp+18h] [ebp-14h]
  int v16; // [esp+1Ch] [ebp-10h]
  unsigned int v17; // [esp+20h] [ebp-Ch]
  int i; // [esp+24h] [ebp-8h]
  int v19; // [esp+28h] [ebp-4h]
  int v20; // [esp+34h] [ebp+8h]
  int v21; // [esp+34h] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 280) - 1;
  v20 = *(_DWORD *)(a1 + 388);
  v11 = v3;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 124);
    v5 = *(_DWORD *)(a1 + 132);
    if ( v4 >= v5 && (v4 != v5 || *(_DWORD *)(a1 + 128) > *(_DWORD *)(a1 + 136)) )
      break;
    result = (**(int (__cdecl ***)(int))(a1 + 396))(a1);
    if ( !result )
      return result;
  }
  v19 = 0;
  v7 = *(_DWORD *)(a1 + 196);
  if ( *(int *)(a1 + 32) > 0 )
  {
    v15 = (_DWORD *)(v20 + 72);
    do
    {
      if ( *(_BYTE *)(v7 + 48) )
      {
        v13 = (*(int (__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 4) + 32))(
                a1,
                *v15,
                *(_DWORD *)(v7 + 12) * *(_DWORD *)(a1 + 136),
                *(_DWORD *)(v7 + 12),
                0);
        if ( *(_DWORD *)(a1 + 136) >= v3 )
        {
          v21 = *(_DWORD *)(v7 + 32) % *(_DWORD *)(v7 + 12);
          if ( !v21 )
            v21 = *(_DWORD *)(v7 + 12);
        }
        else
        {
          v21 = *(_DWORD *)(v7 + 12);
        }
        v12 = *(void (__cdecl **)(int, int, int, int, int))(*(_DWORD *)(a1 + 408) + 4 * v19 + 4);
        v8 = 0;
        v16 = *(_DWORD *)(4 * v19 + a2);
        v14 = 0;
        if ( v21 > 0 )
        {
          v9 = *(_DWORD *)(v7 + 28);
          do
          {
            v10 = 0;
            v17 = 0;
            for ( i = *(_DWORD *)(v13 + 4 * v8); v17 < v9; ++v17 )
            {
              v12(a1, v7, i, v16, v10);
              i += 128;
              v10 += *(_DWORD *)(v7 + 36);
              v9 = *(_DWORD *)(v7 + 28);
            }
            v16 += 4 * *(_DWORD *)(v7 + 36);
            v8 = ++v14;
          }
          while ( v14 < v21 );
          v3 = v11;
        }
      }
      ++v19;
      ++v15;
      v7 += 84;
    }
    while ( v19 < *(_DWORD *)(a1 + 32) );
  }
  return 4 - (++*(_DWORD *)(a1 + 136) < *(_DWORD *)(a1 + 280));
}

// sub_1002F1CE @ 0x1002F1CE
char __usercall sub_1002F1CE@<al>(int a1@<esi>)
{
  int v1; // edi
  _WORD **v2; // eax
  _WORD *v3; // eax
  int *v4; // eax
  _DWORD *v5; // ecx
  int v6; // edx
  int v7; // eax
  _WORD **i; // [esp+8h] [ebp-14h]
  int v10; // [esp+Ch] [ebp-10h]
  int v11; // [esp+10h] [ebp-Ch]
  int v12; // [esp+14h] [ebp-8h]
  char v13; // [esp+1Bh] [ebp-1h]

  v1 = *(_DWORD *)(a1 + 388);
  v13 = 0;
  if ( *(_BYTE *)(a1 + 200) && *(_DWORD *)(a1 + 140) )
  {
    if ( !*(_DWORD *)(v1 + 112) )
      *(_DWORD *)(v1 + 112) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD *)(a1 + 32));
    v12 = *(_DWORD *)(v1 + 112);
    v10 = 0;
    if ( *(int *)(a1 + 32) <= 0 )
      return v13;
    v2 = (_WORD **)(*(_DWORD *)(a1 + 196) + 76);
    v11 = 0;
    for ( i = v2; ; i += 21 )
    {
      v3 = *v2;
      if ( !v3 )
        break;
      if ( !*v3 )
        break;
      if ( !v3[1] )
        break;
      if ( !v3[8] )
        break;
      if ( !v3[16] )
        break;
      if ( !v3[9] )
        break;
      if ( !v3[2] )
        break;
      v4 = (int *)(v11 + *(_DWORD *)(a1 + 140));
      if ( *v4 < 0 )
        break;
      v5 = v4 + 1;
      v6 = v12 - (_DWORD)v4;
      v7 = 5;
      do
      {
        *(_DWORD *)((char *)v5 + v6) = *v5;
        if ( *v5 )
          v13 = 1;
        ++v5;
        --v7;
      }
      while ( v7 );
      v12 += 24;
      ++v10;
      v11 += 256;
      v2 = i + 21;
      if ( v10 >= *(_DWORD *)(a1 + 32) )
        return v13;
    }
  }
  return 0;
}

// sub_1002F2B1 @ 0x1002F2B1
int __cdecl sub_1002F2B1(_DWORD *a1, int a2)
{
  int v3; // eax
  bool v4; // cc
  int v5; // esi
  unsigned int v6; // ebx
  unsigned int v7; // ecx
  int v8; // eax
  int v10; // eax
  _DWORD *v11; // eax
  unsigned __int16 *v12; // eax
  int v13; // ecx
  int v14; // eax
  __int16 **v15; // edx
  __int16 *v16; // ecx
  __int16 *v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  int v24; // eax
  int v25; // ecx
  int v26; // ecx
  int v27; // ebx
  int v28; // eax
  int v29; // edx
  int v30; // eax
  int v31; // eax
  int v32; // edx
  int v33; // ecx
  int v34; // eax
  int v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // eax
  int v43; // ecx
  int v44; // eax
  int v45; // ecx
  int v46; // edx
  int v47; // ecx
  int v48; // eax
  int v49; // eax
  int v50; // ecx
  int v51; // eax
  int v52; // ecx
  int v53; // eax
  _BYTE v54[2]; // [esp+8h] [ebp-98h] BYREF
  __int16 v55; // [esp+Ah] [ebp-96h]
  __int16 v56; // [esp+Ch] [ebp-94h]
  __int16 v57; // [esp+18h] [ebp-88h]
  __int16 v58; // [esp+1Ah] [ebp-86h]
  __int16 v59; // [esp+28h] [ebp-78h]
  void (__cdecl *v60)(_DWORD *, int, _BYTE *, int, int); // [esp+88h] [ebp-18h]
  unsigned int v61; // [esp+8Ch] [ebp-14h]
  int v62; // [esp+90h] [ebp-10h]
  int v63; // [esp+94h] [ebp-Ch]
  int v64; // [esp+98h] [ebp-8h]
  unsigned int v65; // [esp+9Ch] [ebp-4h]
  int v66; // [esp+A0h] [ebp+0h]
  int v67; // [esp+A4h] [ebp+4h]
  int v68; // [esp+A8h] [ebp+8h]
  int i; // [esp+ACh] [ebp+Ch]
  __int16 *v70; // [esp+B0h] [ebp+10h]
  int v71; // [esp+B4h] [ebp+14h]
  __int16 *v72; // [esp+B8h] [ebp+18h]
  int v73; // [esp+BCh] [ebp+1Ch]
  int v74; // [esp+C0h] [ebp+20h]
  int v75; // [esp+C4h] [ebp+24h]
  unsigned int v76; // [esp+C8h] [ebp+28h]
  int v77; // [esp+CCh] [ebp+2Ch]
  int v78; // [esp+D0h] [ebp+30h]
  int v79; // [esp+D4h] [ebp+34h]
  int v80; // [esp+D8h] [ebp+38h]
  int v81; // [esp+DCh] [ebp+3Ch]
  int v82; // [esp+E0h] [ebp+40h]
  int v83; // [esp+E4h] [ebp+44h]
  int v84; // [esp+E8h] [ebp+48h]
  int v85; // [esp+ECh] [ebp+4Ch]
  _DWORD *v86; // [esp+F0h] [ebp+50h]
  int v87; // [esp+F4h] [ebp+54h]
  int v88; // [esp+F8h] [ebp+58h]
  int v89; // [esp+FCh] [ebp+5Ch]
  int v90; // [esp+100h] [ebp+60h]
  __int16 *v91; // [esp+104h] [ebp+64h]
  char v92; // [esp+10Bh] [ebp+6Bh]
  _DWORD *v93; // [esp+10Ch] [ebp+6Ch]
  char v94; // [esp+11Bh] [ebp+7Bh]

  v66 = a1[97];
  v61 = a1[70] - 1;
  while ( a1[31] <= a1[33] )
  {
    v3 = a1[99];
    if ( *(_BYTE *)(v3 + 17) || a1[31] == a1[33] && a1[32] > a1[34] + (unsigned int)(a1[90] == 0) )
      break;
    if ( !(*(int (__cdecl **)(_DWORD *))v3)(a1) )
      return 0;
  }
  v4 = a1[8] <= 0;
  v5 = a1[49];
  v74 = 0;
  if ( !v4 )
  {
    v67 = 0;
    v68 = -72 - v66;
    v86 = (_DWORD *)(v66 + 72);
    do
    {
      if ( *(_BYTE *)(v5 + 48) )
      {
        v6 = a1[34];
        v7 = *(_DWORD *)(v5 + 12);
        if ( v6 >= v61 )
        {
          v90 = *(_DWORD *)(v5 + 32) % v7;
          if ( !v90 )
            v90 = v7;
          v8 = v90;
          v92 = 1;
        }
        else
        {
          v90 = *(_DWORD *)(v5 + 12);
          v8 = 2 * v7;
          v92 = 0;
        }
        if ( v6 )
        {
          v94 = 0;
          v10 = (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                  a1,
                  *v86,
                  v7 * (v6 - 1),
                  v7 + v8,
                  0)
              + 4 * *(_DWORD *)(v5 + 12);
        }
        else
        {
          v10 = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v86, 0, v8, 0);
          v94 = 1;
        }
        v64 = v10;
        v11 = (_DWORD *)(v67 + *(_DWORD *)(v66 + 112));
        v88 = 0;
        v93 = v11;
        v12 = *(unsigned __int16 **)(v5 + 76);
        v87 = *v12;
        v78 = v12[1];
        v83 = v12[8];
        v75 = v12[16];
        v13 = v12[9];
        v77 = v12[2];
        v14 = v68 + a1[102];
        v81 = v13;
        v60 = *(void (__cdecl **)(_DWORD *, int, _BYTE *, int, int))((char *)v86 + v14 + 4);
        for ( i = *(_DWORD *)(a2 + 4 * v74); v88 < v90; i += 4 * v53 )
        {
          v15 = (__int16 **)(v64 + 4 * v88);
          v16 = *v15;
          v91 = *v15;
          if ( !v94 || v88 )
            v16 = *(v15 - 1);
          if ( !v92 || (v17 = v91, v88 != v90 - 1) )
            v17 = v15[1];
          v18 = *v16;
          v71 = 0;
          v76 = 0;
          v79 = v18;
          v84 = v18;
          v62 = v18;
          v89 = *v91;
          v82 = v89;
          v73 = v89;
          v80 = *v17;
          v85 = v80;
          v63 = v80;
          v65 = *(_DWORD *)(v5 + 28) - 1;
          v72 = v17 + 64;
          v70 = v16 + 64;
          do
          {
            sub_10022BF2(v91, v54, 1);
            if ( v76 < v65 )
            {
              v79 = *v70;
              v89 = v91[64];
              v80 = *v72;
            }
            if ( v93[1] && !v55 )
            {
              v19 = v78 << 8;
              v20 = v78 << 7;
              v21 = 36 * v87 * (v73 - v89);
              if ( v21 < 0 )
              {
                v24 = (v20 - v21) / v19;
                v25 = v93[1];
                if ( v25 > 0 && v24 >= 1 << v25 )
                  v24 = (1 << v25) - 1;
                v22 = -v24;
              }
              else
              {
                v22 = (v21 + v20) / v19;
                v23 = v93[1];
                if ( v23 > 0 && v22 >= 1 << v23 )
                  LOWORD(v22) = (1 << v23) - 1;
              }
              v55 = v22;
            }
            v26 = v93[2];
            if ( v26 && !v57 )
            {
              v27 = v83 << 8;
              v28 = v83 << 7;
              v29 = 36 * v87 * (v84 - v85);
              if ( v29 < 0 )
              {
                v31 = (v28 - v29) / v27;
                if ( v26 > 0 && v31 >= 1 << v26 )
                  v31 = (1 << v26) - 1;
                v30 = -v31;
              }
              else
              {
                v30 = (v29 + v28) / v27;
                if ( v26 > 0 && v30 >= 1 << v26 )
                  LOWORD(v30) = (1 << v26) - 1;
              }
              v57 = v30;
            }
            if ( v93[3] && !v59 )
            {
              v32 = 9 * v87 * (v84 + v85 - 2 * v82);
              v33 = v75 << 8;
              v34 = v75 << 7;
              if ( v32 < 0 )
              {
                v37 = (v34 - v32) / v33;
                v38 = v93[3];
                if ( v38 > 0 && v37 >= 1 << v38 )
                  v37 = (1 << v38) - 1;
                v35 = -v37;
              }
              else
              {
                v35 = (v32 + v34) / v33;
                v36 = v93[3];
                if ( v36 > 0 && v35 >= 1 << v36 )
                  LOWORD(v35) = (1 << v36) - 1;
              }
              v59 = v35;
            }
            if ( v93[4] && !v58 )
            {
              v39 = 5 * v87 * (v62 + v80 - v63 - v79);
              v40 = v81 << 8;
              v41 = v81 << 7;
              if ( v39 < 0 )
              {
                v44 = (v41 - v39) / v40;
                v45 = v93[4];
                if ( v45 > 0 && v44 >= 1 << v45 )
                  v44 = (1 << v45) - 1;
                v42 = -v44;
              }
              else
              {
                v42 = (v39 + v41) / v40;
                v43 = v93[4];
                if ( v43 > 0 && v42 >= 1 << v43 )
                  LOWORD(v42) = (1 << v43) - 1;
              }
              v58 = v42;
            }
            if ( v93[5] && !v56 )
            {
              v46 = 9 * v87 * (v73 + v89 - 2 * v82);
              v47 = v77 << 8;
              v48 = v77 << 7;
              if ( v46 < 0 )
              {
                v51 = (v48 - v46) / v47;
                v52 = v93[5];
                if ( v52 > 0 && v51 >= 1 << v52 )
                  v51 = (1 << v52) - 1;
                v49 = -v51;
              }
              else
              {
                v49 = (v46 + v48) / v47;
                v50 = v93[5];
                if ( v50 > 0 && v49 >= 1 << v50 )
                  LOWORD(v49) = (1 << v50) - 1;
              }
              v56 = v49;
            }
            v60(a1, v5, v54, i, v71);
            v91 += 64;
            v70 += 64;
            v72 += 64;
            v62 = v84;
            v84 = v79;
            v73 = v82;
            v82 = v89;
            v63 = v85;
            v85 = v80;
            v71 += *(_DWORD *)(v5 + 36);
            ++v76;
          }
          while ( v76 <= v65 );
          v53 = *(_DWORD *)(v5 + 36);
          ++v88;
        }
      }
      ++v74;
      v67 += 24;
      ++v86;
      v5 += 84;
    }
    while ( v74 < a1[8] );
  }
  return 4 - (++a1[34] < a1[70]);
}

// sub_1002F7CE @ 0x1002F7CE
void __cdecl sub_1002F7CE(int a1)
{
  int v1; // edi

  v1 = *(_DWORD *)(a1 + 388);
  if ( *(_DWORD *)(v1 + 16) )
  {
    if ( *(_BYTE *)(a1 + 73) && sub_1002F1CE(a1) )
      *(_DWORD *)(v1 + 12) = sub_1002F2B1;
    else
      *(_DWORD *)(v1 + 12) = sub_1002F068;
  }
  *(_DWORD *)(a1 + 136) = 0;
}

// sub_1002F809 @ 0x1002F809
int __cdecl sub_1002F809(int a1, char a2)
{
  _DWORD *v3; // ebx
  int v4; // eax
  int *v5; // edi
  int v6; // ecx
  int v7; // ebx
  int v8; // eax
  int v9; // eax
  int *v10; // ecx
  int result; // eax
  int *v12; // ecx
  int v13; // edx
  int v14; // [esp-8h] [ebp-18h]
  int v15; // [esp-4h] [ebp-14h]
  _DWORD *v16; // [esp+Ch] [ebp-4h]
  int v17; // [esp+18h] [ebp+8h]
  int *v18; // [esp+1Ch] [ebp+Ch]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 116);
  *(_DWORD *)(a1 + 388) = v3;
  v16 = v3;
  *v3 = sub_1002ECDC;
  v3[2] = sub_1002F7CE;
  v3[28] = 0;
  if ( a2 )
  {
    v4 = *(_DWORD *)(a1 + 196);
    v17 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v5 = (int *)(v4 + 12);
      v18 = v3 + 18;
      do
      {
        v6 = *v5;
        if ( *(_BYTE *)(a1 + 200) )
          v6 *= 3;
        v7 = *(_DWORD *)(a1 + 4);
        v15 = v6;
        v14 = sub_10022B93(v5[5], *v5);
        v8 = sub_10022B93(v5[4], *(v5 - 1));
        v9 = (*(int (__cdecl **)(int, int, int, int, int, int))(v7 + 20))(a1, 1, 1, v8, v14, v15);
        v10 = v18++;
        ++v17;
        *v10 = v9;
        v5 += 21;
      }
      while ( v17 < *(_DWORD *)(a1 + 32) );
      v3 = v16;
    }
    v3[1] = sub_1002EEC9;
    v3[3] = sub_1002F068;
    v3[4] = v3 + 18;
    return (int)(v3 + 18);
  }
  else
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v12 = v3 + 8;
    v13 = 10;
    do
    {
      *v12++ = result;
      result += 128;
      --v13;
    }
    while ( v13 );
    v3[1] = sub_1002EEC6;
    v3[3] = sub_1002ECEC;
    v3[4] = 0;
  }
  return result;
}

// sub_1002F901 @ 0x1002F901
int __cdecl sub_1002F901(int a1, int a2, int a3)
{
  _DWORD *v3; // esi
  int v4; // ebx
  int v5; // eax
  int v6; // ecx
  _BYTE *v7; // edi
  int v8; // edx
  unsigned int v9; // ecx
  int v10; // eax
  int v11; // edi
  int v12; // ecx
  int v13; // edx
  char *v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // edx
  _DWORD *v18; // eax
  int v19; // edi
  int result; // eax
  unsigned __int8 *v21; // edi
  bool v22; // cf
  int v23; // edx
  _BYTE *v24; // ebx
  int v25; // eax
  _BYTE *v26; // edi
  int *v27; // eax
  _DWORD v28[258]; // [esp+8h] [ebp-520h]
  _BYTE v29[260]; // [esp+410h] [ebp-118h] BYREF
  unsigned __int8 *v30; // [esp+514h] [ebp-14h]
  int v31; // [esp+518h] [ebp-10h]
  int j; // [esp+51Ch] [ebp-Ch]
  int v33; // [esp+520h] [ebp-8h]
  int v34; // [esp+524h] [ebp-4h]
  int i; // [esp+538h] [ebp+10h]
  int v36; // [esp+538h] [ebp+10h]

  if ( !*(_DWORD *)a3 )
    *(_DWORD *)a3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1492);
  v3 = *(_DWORD **)a3;
  v4 = a2;
  v5 = 0;
  *(_DWORD *)(*(_DWORD *)a3 + 208) = a2;
  v34 = 0;
  for ( i = 1; i <= 16; ++i )
  {
    v6 = *(unsigned __int8 *)(i + v4);
    v33 = v6;
    if ( v6 >= 1 )
    {
      v7 = &v29[v5];
      LOBYTE(v4) = i;
      BYTE1(v4) = i;
      v8 = v6;
      v9 = (unsigned int)v6 >> 2;
      v10 = v4 << 16;
      LOWORD(v10) = v4;
      v4 = a2;
      memset32(v7, v10, v9);
      memset(&v7[4 * v9], v10, v8 & 3);
      v5 = v8 + v34;
      v34 += v8;
    }
  }
  v29[v5] = 0;
  v11 = v29[0];
  v12 = 0;
  v13 = 0;
  if ( v29[0] )
  {
    v14 = v29;
    do
    {
      v15 = *v14;
      while ( v15 == v11 )
      {
        v15 = (char)v29[v12 + 1];
        v28[++v12] = v13++;
      }
      v13 *= 2;
      v14 = &v29[v12];
      ++v11;
    }
    while ( v29[v12] );
  }
  v16 = 0;
  v17 = 1;
  v18 = v3 + 18;
  do
  {
    if ( *(_BYTE *)(v17 + v4) )
    {
      v19 = v28[v16 + 1];
      v18[18] = v16;
      *(v18 - 17) = v19;
      v16 += *(unsigned __int8 *)(v17 + v4);
      *v18 = v28[v16];
    }
    else
    {
      *v18 = -1;
    }
    ++v17;
    ++v18;
  }
  while ( v17 <= 16 );
  v34 = 0;
  v3[34] = 0xFFFFF;
  memset(v3 + 53, 0, 0x400u);
  v36 = 1;
  for ( j = 7; j >= 0; --j )
  {
    result = v36;
    v21 = (unsigned __int8 *)(v36 + v4);
    v22 = *(_BYTE *)(v36 + v4) == 0;
    v31 = 1;
    v30 = (unsigned __int8 *)(v36 + v4);
    if ( !v22 )
    {
      v23 = 1 << j;
      v24 = (_BYTE *)(v34 + v4 + 17);
      do
      {
        v25 = v28[v34 + 1] << j;
        if ( v23 > 0 )
        {
          v26 = (char *)v3 + v25 + 1236;
          v27 = &v3[v25 + 53];
          v33 = v23;
          do
          {
            *v27++ = v36;
            *v26++ = *v24;
            --v33;
          }
          while ( v33 );
          v21 = v30;
        }
        ++v31;
        result = *v21;
        ++v34;
        ++v24;
      }
      while ( v31 <= result );
      v4 = a2;
    }
    ++v36;
  }
  return result;
}

// sub_1002FAAB @ 0x1002FAAB
char __cdecl sub_1002FAAB(unsigned __int8 **a1, int a2, int a3, int a4)
{
  unsigned __int8 *v4; // ebx
  unsigned __int8 *v5; // edi
  unsigned __int8 **v6; // eax
  int v7; // ecx
  unsigned __int8 **v8; // eax
  unsigned __int8 *v9; // ecx

  v4 = a1[1];
  v5 = *a1;
  while ( 1 )
  {
    if ( a3 >= 25 )
    {
LABEL_20:
      a1[3] = (unsigned __int8 *)a2;
      a1[6] = (unsigned __int8 *)a3;
      *a1 = v5;
      a1[1] = v4;
      return 1;
    }
    if ( a1[2] )
      goto LABEL_14;
    if ( !v4 )
      break;
LABEL_6:
    v7 = *v5;
    --v4;
    ++v5;
    if ( v7 != 255 )
      goto LABEL_18;
    do
    {
      if ( !v4 )
      {
        if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[7] + 5) + 12))(a1[7]) )
          return 0;
        v8 = (unsigned __int8 **)*((_DWORD *)a1[7] + 5);
        v5 = *v8;
        v4 = v8[1];
      }
      v9 = (unsigned __int8 *)*v5;
      --v4;
      ++v5;
    }
    while ( v9 == (unsigned __int8 *)255 );
    if ( !v9 )
    {
      v7 = 255;
      goto LABEL_18;
    }
    a1[2] = v9;
LABEL_14:
    if ( a3 >= a4 )
      goto LABEL_20;
    if ( !*a1[8] )
    {
      *(_DWORD *)(*(_DWORD *)a1[7] + 20) = 113;
      (*(void (__cdecl **)(unsigned __int8 *, int))(*(_DWORD *)a1[7] + 4))(a1[7], -1);
      *a1[8] = 1;
    }
    v7 = 0;
LABEL_18:
    a3 += 8;
    a2 = v7 | (a2 << 8);
  }
  if ( (*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[7] + 5) + 12))(a1[7]) )
  {
    v6 = (unsigned __int8 **)*((_DWORD *)a1[7] + 5);
    v5 = *v6;
    v4 = v6[1];
    goto LABEL_6;
  }
  return 0;
}

// sub_1002FB95 @ 0x1002FB95
int __cdecl sub_1002FB95(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // edx
  int v8; // eax
  int v9; // esi
  int v10; // ebx
  int v11; // esi
  int v12; // [esp+8h] [ebp-4h]
  int *v13; // [esp+24h] [ebp+18h]

  v5 = a3;
  v12 = a5;
  if ( a3 >= a5 )
  {
    v7 = a2;
  }
  else
  {
    if ( !sub_1002FAAB((unsigned __int8 **)a1, a2, a3, a5) )
      return -1;
    v7 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 24);
  }
  v8 = v5 - a5;
  v9 = ((1 << a5) - 1) & (v7 >> v8);
  v10 = a4;
  if ( v9 > *(_DWORD *)(a4 + 4 * a5 + 68) )
  {
    v13 = (int *)(a4 + 4 * a5 + 68);
    while ( 1 )
    {
      v11 = 2 * v9;
      if ( v8 < 1 )
      {
        if ( !sub_1002FAAB((unsigned __int8 **)a1, v7, v8, 1) )
          return -1;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(_DWORD *)(a1 + 24);
      }
      ++v13;
      v9 = (v7 >> --v8) & 1 | v11;
      ++v12;
      if ( v9 <= *v13 )
      {
        v10 = a4;
        break;
      }
    }
  }
  *(_DWORD *)(a1 + 24) = v8;
  *(_DWORD *)(a1 + 12) = v7;
  if ( v12 <= 16 )
    return *(unsigned __int8 *)(*(_DWORD *)(v10 + 208)
                              + *(_DWORD *)(v10 + 4 * v12 + 140)
                              - *(_DWORD *)(v10 + 4 * v12)
                              + v9
                              + 17);
  *(_DWORD *)(**(_DWORD **)(a1 + 28) + 20) = 114;
  (*(void (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 28) + 4))(*(_DWORD *)(a1 + 28), -1);
  return 0;
}

// sub_1002FC7F @ 0x1002FC7F
char __cdecl sub_1002FC7F(_DWORD *a1)
{
  int v1; // esi
  char result; // al
  int v3; // edx
  _DWORD *v4; // ecx

  v1 = a1[101];
  *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v1 + 20) / 8;
  *(_DWORD *)(v1 + 20) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[100] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[72] > 0 )
    {
      v4 = (_DWORD *)(v1 + 32);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[72] );
    }
    *(_DWORD *)(v1 + 48) = a1[63];
    *(_BYTE *)(v1 + 24) = 0;
    return 1;
  }
  return result;
}

// sub_1002FCDD @ 0x1002FCDD
char __cdecl sub_1002FCDD(_DWORD *a1, int a2)
{
  _DWORD *v2; // ecx
  _DWORD *v3; // ebx
  char result; // al
  int v5; // eax
  unsigned __int8 *v6; // edx
  int v7; // eax
  bool v8; // cc
  int v9; // eax
  int v10; // edx
  int v11; // eax
  int v12; // esi
  int v13; // edi
  int v14; // ecx
  int v15; // ecx
  int v16; // esi
  int v17; // ecx
  int v18; // esi
  int v19; // esi
  int v20; // ecx
  int *v21; // ecx
  int v22; // ecx
  int v23; // esi
  int v24; // esi
  int v25; // edi
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // esi
  __int16 v30; // cx
  int v31; // ecx
  int v32; // esi
  int v33; // esi
  int v34; // edi
  int v35; // esi
  int v36; // ecx
  int v37; // esi
  unsigned __int8 *v38; // [esp+4h] [ebp-54h] BYREF
  int v39; // [esp+8h] [ebp-50h]
  int v40; // [esp+Ch] [ebp-4Ch]
  int v41; // [esp+10h] [ebp-48h]
  int v42; // [esp+1Ch] [ebp-3Ch]
  _DWORD *v43; // [esp+20h] [ebp-38h]
  _DWORD *v44; // [esp+24h] [ebp-34h]
  int v45; // [esp+2Ch] [ebp-2Ch] BYREF
  int v46; // [esp+30h] [ebp-28h]
  int v47; // [esp+34h] [ebp-24h]
  int v48; // [esp+38h] [ebp-20h]
  int v49; // [esp+3Ch] [ebp-1Ch]
  _WORD *v50; // [esp+40h] [ebp-18h]
  int v51; // [esp+44h] [ebp-14h]
  int *v52; // [esp+48h] [ebp-10h]
  int v53; // [esp+4Ch] [ebp-Ch]
  int v54; // [esp+50h] [ebp-8h]
  int i; // [esp+54h] [ebp-4h]

  v2 = a1;
  v3 = (_DWORD *)a1[101];
  if ( a1[63] && !v3[12] )
  {
    result = sub_1002FC7F(a1);
    if ( !result )
      return result;
    v2 = a1;
  }
  v5 = v2[5];
  v6 = *(unsigned __int8 **)v5;
  v7 = *(_DWORD *)(v5 + 4);
  v53 = 0;
  v8 = v2[79] <= 0;
  v44 = v3 + 6;
  v45 = v3[8];
  v46 = v3[9];
  v39 = v7;
  v9 = v2[94];
  v47 = v3[10];
  v38 = v6;
  v10 = v3[4];
  v40 = v9;
  v11 = v3[5];
  v43 = v2;
  v48 = v3[11];
  if ( v8 )
    goto LABEL_66;
  v52 = v2 + 80;
  do
  {
    v50 = *(_WORD **)(a2 + 4 * v53);
    v12 = *v52;
    v13 = v2[*v52 + 73];
    i = v3[*(_DWORD *)(v13 + 20) + 13];
    v14 = v3[*(_DWORD *)(v13 + 24) + 17];
    v49 = v12;
    v51 = v13;
    v54 = v14;
    if ( v11 < 8 )
    {
      if ( !sub_1002FAAB(&v38, v10, v11, 0) )
        return 0;
      v11 = v42;
      v10 = v41;
      if ( v42 < 8 )
      {
        v15 = 1;
LABEL_14:
        v18 = sub_1002FB95((int)&v38, v10, v11, i, v15);
        if ( v18 < 0 )
          return 0;
        v10 = v41;
        v11 = v42;
        goto LABEL_16;
      }
    }
    v16 = (unsigned __int8)(v10 >> (v11 - 8));
    v17 = *(_DWORD *)(i + 4 * v16 + 212);
    if ( !v17 )
    {
      v15 = 9;
      goto LABEL_14;
    }
    v11 -= v17;
    v18 = *(unsigned __int8 *)(v16 + i + 1236);
LABEL_16:
    if ( v18 )
    {
      if ( v11 < v18 )
      {
        if ( !sub_1002FAAB(&v38, v10, v11, v18) )
          return 0;
        v10 = v41;
        v11 = v42;
      }
      v11 -= v18;
      i = (1 << v18) - 1;
      v19 = v18;
      v20 = (v10 >> v11) & i;
      v13 = v51;
      if ( v20 >= dword_1004F3A8[v19] )
        v18 = (v10 >> v11) & i;
      else
        v18 = v20 + dword_1004F3E8[v19];
    }
    if ( *(_BYTE *)(v13 + 48) )
    {
      v21 = &v45 + v49;
      *v21 += v18;
      *v50 = *v21;
      if ( *(int *)(v13 + 36) > 1 )
      {
        i = 1;
        while ( 1 )
        {
          if ( v11 < 8 )
          {
            if ( !sub_1002FAAB(&v38, v10, v11, 0) )
              return 0;
            v11 = v42;
            v10 = v41;
            if ( v42 < 8 )
              break;
          }
          v22 = v54;
          v24 = (unsigned __int8)(v10 >> (v11 - 8));
          v25 = *(_DWORD *)(v54 + 4 * v24 + 212);
          if ( !v25 )
          {
            v23 = 9;
            goto LABEL_33;
          }
          v11 -= v25;
          v26 = *(unsigned __int8 *)(v24 + v54 + 1236);
LABEL_35:
          v27 = v26 >> 4;
          v28 = v26 & 0xF;
          v49 = v28;
          if ( v28 )
          {
            i += v27;
            if ( v11 < v28 )
            {
              if ( !sub_1002FAAB(&v38, v10, v11, v28) )
                return 0;
              v10 = v41;
              v11 = v42;
            }
            v11 -= v28;
            v29 = (v10 >> v11) & ((1 << v28) - 1);
            if ( v29 >= dword_1004F3A8[v49] )
              v30 = (v10 >> v11) & ((1 << v28) - 1);
            else
              v30 = v29 + dword_1004F3E8[v49];
            v50[dword_1004E8C0[i]] = v30;
          }
          else
          {
            if ( v27 != 15 )
              goto LABEL_65;
            i += 15;
          }
          if ( ++i >= 64 )
            goto LABEL_65;
        }
        v22 = v54;
        v23 = 1;
LABEL_33:
        v26 = sub_1002FB95((int)&v38, v10, v11, v22, v23);
        if ( v26 < 0 )
          return 0;
        v10 = v41;
        v11 = v42;
        goto LABEL_35;
      }
    }
    for ( i = 1; i < 64; ++i )
    {
      if ( v11 >= 8 )
        goto LABEL_52;
      if ( !sub_1002FAAB(&v38, v10, v11, 0) )
        return 0;
      v11 = v42;
      v10 = v41;
      if ( v42 >= 8 )
      {
LABEL_52:
        v31 = v54;
        v33 = (unsigned __int8)(v10 >> (v11 - 8));
        v34 = *(_DWORD *)(v54 + 4 * v33 + 212);
        if ( v34 )
        {
          v35 = *(unsigned __int8 *)(v33 + v54 + 1236);
          v11 -= v34;
          goto LABEL_57;
        }
        v32 = 9;
      }
      else
      {
        v31 = v54;
        v32 = 1;
      }
      v35 = sub_1002FB95((int)&v38, v10, v11, v31, v32);
      if ( v35 < 0 )
        return 0;
      v10 = v41;
      v11 = v42;
LABEL_57:
      v36 = v35 >> 4;
      v37 = v35 & 0xF;
      if ( v37 )
      {
        i += v36;
        if ( v11 < v37 )
        {
          if ( !sub_1002FAAB(&v38, v10, v11, v37) )
            return 0;
          v10 = v41;
          v11 = v42;
        }
        v11 -= v37;
      }
      else
      {
        if ( v36 != 15 )
          break;
        i += 15;
      }
    }
LABEL_65:
    ++v53;
    v2 = a1;
    ++v52;
  }
  while ( v53 < a1[79] );
LABEL_66:
  *(_DWORD *)v2[5] = v38;
  *(_DWORD *)(v2[5] + 4) = v39;
  v2[94] = v40;
  --v3[12];
  v3[8] = v45;
  v3[9] = v46;
  v3[10] = v47;
  v3[5] = v11;
  v3[4] = v10;
  v3[11] = v48;
  return 1;
}

// sub_100300AA @ 0x100300AA
int __cdecl sub_100300AA(_DWORD *a1)
{
  int v2; // edi
  unsigned int v3; // ebx
  unsigned int v4; // eax
  int result; // eax
  unsigned int v6; // [esp+Ch] [ebp-Ch]
  int v7; // [esp+10h] [ebp-8h]
  _DWORD *v8; // [esp+14h] [ebp-4h]
  _DWORD *v9; // [esp+20h] [ebp+8h]

  v2 = a1[101];
  if ( a1[90] || a1[91] != 63 || a1[92] || a1[93] )
  {
    *(_DWORD *)(*a1 + 20) = 118;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v7 = 0;
  if ( (int)a1[72] > 0 )
  {
    v8 = (_DWORD *)(v2 + 32);
    v9 = a1 + 73;
    do
    {
      v3 = *(_DWORD *)(*v9 + 20);
      v4 = *(_DWORD *)(*v9 + 24);
      v6 = v4;
      if ( v3 >= 4 || !a1[v3 + 40] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v3;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        v4 = v6;
      }
      if ( v4 >= 4 || !a1[v4 + 44] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v4;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_1002F901((int)a1, a1[v3 + 40], v2 + 4 * v3 + 52);
      sub_1002F901((int)a1, a1[v6 + 44], v2 + 4 * v6 + 68);
      *v8 = 0;
      ++v9;
      ++v8;
      ++v7;
    }
    while ( v7 < a1[72] );
  }
  *(_BYTE *)(v2 + 24) = 0;
  *(_DWORD *)(v2 + 20) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 16) = 0;
  result = a1[63];
  *(_DWORD *)(v2 + 48) = result;
  return result;
}

// sub_100301D9 @ 0x100301D9
_DWORD *__cdecl sub_100301D9(int a1)
{
  _DWORD *v1; // eax
  int v2; // ecx
  _DWORD *result; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 88);
  *(_DWORD *)(a1 + 404) = v1;
  v2 = 4;
  *v1 = sub_100300AA;
  v1[1] = sub_1002FCDD;
  result = v1 + 13;
  do
  {
    result[4] = 0;
    *result++ = 0;
    --v2;
  }
  while ( v2 );
  return result;
}

// sub_10030213 @ 0x10030213
char __usercall sub_10030213@<al>(_DWORD *a1@<edi>)
{
  int v1; // esi
  char result; // al
  int v3; // edx
  _DWORD *v4; // ecx

  v1 = a1[101];
  *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v1 + 20) / 8;
  *(_DWORD *)(v1 + 20) = 0;
  result = (*(int (__cdecl **)(_DWORD *))(a1[100] + 8))(a1);
  if ( result )
  {
    v3 = 0;
    if ( (int)a1[72] > 0 )
    {
      v4 = (_DWORD *)(v1 + 36);
      do
      {
        *v4 = 0;
        ++v3;
        ++v4;
      }
      while ( v3 < a1[72] );
    }
    *(_DWORD *)(v1 + 32) = 0;
    *(_DWORD *)(v1 + 52) = a1[63];
    *(_BYTE *)(v1 + 24) = 0;
    return 1;
  }
  return result;
}

// sub_1003026E @ 0x1003026E
char __cdecl sub_1003026E(_DWORD *a1, int a2)
{
  bool v3; // zf
  _DWORD *v4; // eax
  int v5; // ecx
  char result; // al
  int v7; // ecx
  bool v8; // cc
  int v9; // edx
  int v10; // edi
  int v11; // eax
  int v12; // esi
  int v13; // ecx
  int v14; // esi
  int v15; // esi
  int v16; // ecx
  _DWORD *v17; // ecx
  int v18; // esi
  unsigned __int8 *v19; // [esp+8h] [ebp-58h] BYREF
  int v20; // [esp+Ch] [ebp-54h]
  int v21; // [esp+10h] [ebp-50h]
  int v22; // [esp+14h] [ebp-4Ch]
  int v23; // [esp+20h] [ebp-40h]
  _DWORD *v24; // [esp+24h] [ebp-3Ch]
  _DWORD *v25; // [esp+28h] [ebp-38h]
  _DWORD v26[5]; // [esp+30h] [ebp-30h] BYREF
  _WORD *v27; // [esp+44h] [ebp-1Ch]
  int v28; // [esp+48h] [ebp-18h]
  int v29; // [esp+4Ch] [ebp-14h]
  int *v30; // [esp+50h] [ebp-10h]
  int v31; // [esp+54h] [ebp-Ch]
  _DWORD *v32; // [esp+58h] [ebp-8h]
  int v33; // [esp+5Ch] [ebp-4h]
  int v34; // [esp+68h] [ebp+8h]

  v3 = a1[63] == 0;
  v4 = (_DWORD *)a1[101];
  v5 = a1[93];
  v32 = v4;
  v28 = v5;
  if ( !v3 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
    v4 = v32;
  }
  v7 = a1[5];
  v31 = 0;
  v8 = a1[79] <= 0;
  v24 = a1;
  v19 = *(unsigned __int8 **)v7;
  v20 = *(_DWORD *)(v7 + 4);
  v21 = a1[94];
  v9 = v4[5];
  v34 = v4[4];
  v25 = v4 + 6;
  qmemcpy(v26, v4 + 8, sizeof(v26));
  if ( !v8 )
  {
    v30 = a1 + 80;
    do
    {
      v27 = *(_WORD **)(a2 + 4 * v31);
      v29 = *v30;
      v10 = v4[*(_DWORD *)(a1[v29 + 73] + 20) + 14];
      if ( v9 < 8 )
      {
        if ( !sub_1002FAAB(&v19, v34, v9, 0) )
          return 0;
        v9 = v23;
        v34 = v22;
        if ( v23 < 8 )
        {
          v11 = 1;
          goto LABEL_15;
        }
        v4 = v32;
      }
      v12 = (unsigned __int8)(v34 >> (v9 - 8));
      v13 = *(_DWORD *)(v10 + 4 * v12 + 212);
      if ( v13 )
      {
        v14 = *(unsigned __int8 *)(v12 + v10 + 1236);
        v9 -= v13;
        goto LABEL_17;
      }
      v11 = 9;
LABEL_15:
      v14 = sub_1002FB95((int)&v19, v34, v9, v10, v11);
      if ( v14 < 0 )
        return 0;
      v9 = v23;
      v34 = v22;
      v4 = v32;
LABEL_17:
      if ( v14 )
      {
        if ( v9 < v14 )
        {
          if ( !sub_1002FAAB(&v19, v34, v9, v14) )
            return 0;
          v9 = v23;
          v34 = v22;
          v4 = v32;
        }
        v9 -= v14;
        v33 = (1 << v14) - 1;
        v15 = v14;
        v16 = (v34 >> v9) & v33;
        if ( v16 >= dword_1004F490[v15] )
          v14 = (v34 >> v9) & v33;
        else
          v14 = v16 + dword_1004F4D0[v15];
      }
      ++v30;
      v17 = &v26[v29 + 1];
      *v17 += v14;
      v18 = *v17 << v28;
      ++v31;
      *v27 = v18;
    }
    while ( v31 < a1[79] );
  }
  *(_DWORD *)a1[5] = v19;
  *(_DWORD *)(a1[5] + 4) = v20;
  a1[94] = v21;
  --v4[13];
  v4[4] = v34;
  v4[5] = v9;
  qmemcpy(v4 + 8, v26, 0x14u);
  return 1;
}

// sub_1003046B @ 0x1003046B
char __cdecl sub_1003046B(_DWORD *a1, int *a2)
{
  bool v3; // zf
  _DWORD *v4; // esi
  char result; // al
  int v6; // eax
  int v7; // eax
  int v8; // ebx
  int v9; // eax
  int v10; // ecx
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // ecx
  int v15; // edx
  int v16; // ebx
  unsigned __int8 *v17; // [esp+8h] [ebp-48h] BYREF
  int v18; // [esp+Ch] [ebp-44h]
  int v19; // [esp+10h] [ebp-40h]
  int v20; // [esp+14h] [ebp-3Ch]
  int v21; // [esp+20h] [ebp-30h]
  _DWORD *v22; // [esp+24h] [ebp-2Ch]
  _DWORD *v23; // [esp+28h] [ebp-28h]
  int v24; // [esp+30h] [ebp-20h]
  int v25; // [esp+34h] [ebp-1Ch]
  int v26; // [esp+38h] [ebp-18h]
  int v27; // [esp+3Ch] [ebp-14h]
  int v28; // [esp+40h] [ebp-10h]
  int v29; // [esp+44h] [ebp-Ch]
  int v30; // [esp+48h] [ebp-8h]
  int v31; // [esp+4Ch] [ebp-4h]
  int v32; // [esp+58h] [ebp+8h]
  int v33; // [esp+58h] [ebp+8h]
  int v34; // [esp+58h] [ebp+8h]

  v3 = a1[63] == 0;
  v4 = (_DWORD *)a1[101];
  v26 = a1[91];
  v25 = a1[93];
  if ( !v3 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
  }
  v30 = v4[8];
  if ( v30 )
  {
    v6 = v30 - 1;
    goto LABEL_37;
  }
  v7 = a1[5];
  v22 = a1;
  v17 = *(unsigned __int8 **)v7;
  v18 = *(_DWORD *)(v7 + 4);
  v19 = a1[94];
  v8 = v4[4];
  v9 = v4[5];
  v23 = v4 + 6;
  v24 = *a2;
  v27 = v4[18];
  v10 = a1[90];
  v29 = v8;
  v31 = v10;
  while ( v10 <= v26 )
  {
    if ( v9 >= 8 )
      goto LABEL_11;
    if ( !sub_1002FAAB(&v17, v8, v9, 0) )
      return 0;
    v9 = v21;
    v8 = v20;
    v29 = v20;
    if ( v21 >= 8 )
    {
LABEL_11:
      v12 = (unsigned __int8)(v8 >> (v9 - 8));
      v13 = *(_DWORD *)(v27 + 4 * v12 + 212);
      if ( v13 )
      {
        v9 -= v13;
        v32 = *(unsigned __int8 *)(v12 + v27 + 1236);
        goto LABEL_16;
      }
      v11 = 9;
    }
    else
    {
      v11 = 1;
    }
    v32 = sub_1002FB95((int)&v17, v8, v9, v27, v11);
    if ( v32 < 0 )
      return 0;
    v8 = v20;
    v9 = v21;
    v29 = v20;
LABEL_16:
    v14 = v32 >> 4;
    v3 = (v32 & 0xF) == 0;
    v33 = v32 & 0xF;
    v28 = v14;
    if ( v3 )
    {
      if ( v14 != 15 )
      {
        v34 = 1 << v14;
        v30 = 1 << v14;
        if ( v28 )
        {
          if ( v9 < v28 )
          {
            if ( !sub_1002FAAB(&v17, v8, v9, v28) )
              return 0;
            v8 = v20;
            v9 = v21;
          }
          v9 -= v28;
          v30 += (v34 - 1) & (v8 >> v9);
        }
        --v30;
        break;
      }
      v31 += 15;
    }
    else
    {
      v31 += v14;
      if ( v9 < v33 )
      {
        if ( !sub_1002FAAB(&v17, v8, v9, v33) )
          return 0;
        v8 = v20;
        v9 = v21;
        v29 = v20;
      }
      v9 -= v33;
      v15 = (v8 >> v9) & ((1 << v33) - 1);
      if ( v15 >= dword_1004F490[v33] )
        v16 = (v8 >> v9) & ((1 << v33) - 1);
      else
        v16 = v15 + dword_1004F4D0[v33];
      *(_WORD *)(v24 + 2 * dword_1004E8C0[v31]) = v16 << v25;
      v8 = v29;
    }
    v10 = ++v31;
  }
  *(_DWORD *)a1[5] = v17;
  *(_DWORD *)(a1[5] + 4) = v18;
  a1[94] = v19;
  v4[5] = v9;
  v6 = v30;
  v4[4] = v8;
LABEL_37:
  --v4[13];
  v4[8] = v6;
  return 1;
}

// sub_10030694 @ 0x10030694
char __cdecl sub_10030694(_DWORD *a1, int a2)
{
  _DWORD *v3; // esi
  bool v4; // zf
  bool v5; // cc
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _WORD *v9; // ebx
  unsigned __int8 *v11; // [esp+Ch] [ebp-2Ch] BYREF
  int v12; // [esp+10h] [ebp-28h]
  int v13; // [esp+14h] [ebp-24h]
  int v14; // [esp+18h] [ebp-20h]
  int v15; // [esp+24h] [ebp-14h]
  _DWORD *v16; // [esp+28h] [ebp-10h]
  _DWORD *v17; // [esp+2Ch] [ebp-Ch]
  int v18; // [esp+34h] [ebp-4h]
  int v19; // [esp+40h] [ebp+8h]

  v3 = (_DWORD *)a1[101];
  v4 = a1[63] == 0;
  v18 = 1 << a1[93];
  if ( !v4 && !v3[13] && !sub_10030213(a1) )
    return 0;
  v5 = a1[79] <= 0;
  v6 = a1[5];
  v16 = a1;
  v11 = *(unsigned __int8 **)v6;
  v12 = *(_DWORD *)(v6 + 4);
  v13 = a1[94];
  v7 = v3[4];
  v8 = v3[5];
  v17 = v3 + 6;
  v19 = 0;
  if ( !v5 )
  {
    do
    {
      v9 = *(_WORD **)(a2 + 4 * v19);
      if ( v8 < 1 )
      {
        if ( !sub_1002FAAB(&v11, v7, v8, 1) )
          return 0;
        v7 = v14;
        v8 = v15;
      }
      if ( ((v7 >> --v8) & 1) != 0 )
        *v9 |= v18;
      ++v19;
    }
    while ( v19 < a1[79] );
  }
  *(_DWORD *)a1[5] = v11;
  *(_DWORD *)(a1[5] + 4) = v12;
  a1[94] = v13;
  --v3[13];
  v3[4] = v7;
  v3[5] = v8;
  return 1;
}

// sub_10030776 @ 0x10030776
char __cdecl sub_10030776(_DWORD *a1, int *a2)
{
  int v3; // ecx
  _DWORD *v4; // esi
  bool v5; // zf
  char result; // al
  int v7; // eax
  int v8; // ebx
  int v9; // ecx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int v13; // ecx
  int v14; // ecx
  int v15; // eax
  int v16; // ecx
  __int16 *v17; // eax
  __int16 v18; // dx
  int v19; // eax
  int v20; // ecx
  int v21; // eax
  int i; // eax
  __int16 *v23; // eax
  __int16 v24; // dx
  int j; // eax
  int v26; // ecx
  _DWORD v27[65]; // [esp+4h] [ebp-158h]
  unsigned __int8 *v28; // [esp+108h] [ebp-54h] BYREF
  int v29; // [esp+10Ch] [ebp-50h]
  int v30; // [esp+110h] [ebp-4Ch]
  int v31; // [esp+114h] [ebp-48h]
  int v32; // [esp+120h] [ebp-3Ch]
  _DWORD *v33; // [esp+124h] [ebp-38h]
  _DWORD *v34; // [esp+128h] [ebp-34h]
  int v35; // [esp+130h] [ebp-2Ch]
  int v36; // [esp+134h] [ebp-28h]
  __int16 *v37; // [esp+138h] [ebp-24h]
  int v38; // [esp+13Ch] [ebp-20h]
  int v39; // [esp+140h] [ebp-1Ch]
  int v40; // [esp+144h] [ebp-18h]
  int v41; // [esp+148h] [ebp-14h]
  int v42; // [esp+14Ch] [ebp-10h]
  int v43; // [esp+150h] [ebp-Ch]
  int v44; // [esp+154h] [ebp-8h]
  int v45; // [esp+158h] [ebp-4h]
  int v46; // [esp+164h] [ebp+8h]

  v3 = a1[93];
  v4 = (_DWORD *)a1[101];
  v42 = a1[91];
  v36 = 1 << v3;
  v5 = a1[63] == 0;
  v35 = -1 << v3;
  if ( !v5 && !v4[13] )
  {
    result = sub_10030213(a1);
    if ( !result )
      return result;
  }
  v7 = a1[5];
  v40 = 0;
  v33 = a1;
  v28 = *(unsigned __int8 **)v7;
  v29 = *(_DWORD *)(v7 + 4);
  v30 = a1[94];
  v46 = v4[4];
  v8 = v4[5];
  v34 = v4 + 6;
  v9 = v4[8];
  v41 = *a2;
  v39 = v4[18];
  v10 = a1[90];
  v43 = v9;
  v45 = v10;
  if ( v9 )
  {
LABEL_47:
    if ( v43 )
    {
      for ( i = v45; i <= v42; i = ++v45 )
      {
        v23 = (__int16 *)(v41 + 2 * dword_1004E8C0[i]);
        v5 = *v23 == 0;
        v37 = v23;
        if ( !v5 )
        {
          if ( v8 < 1 )
          {
            if ( !sub_1002FAAB(&v28, v46, v8, 1) )
              goto LABEL_63;
            v8 = v32;
            v46 = v31;
            v23 = v37;
          }
          if ( ((v46 >> --v8) & 1) != 0 )
          {
            v24 = v36;
            if ( (*v23 & v36) == 0 )
            {
              if ( *v23 < 0 )
                v24 = v35;
              *v23 += v24;
            }
          }
        }
      }
      --v43;
    }
LABEL_61:
    *(_DWORD *)a1[5] = v28;
    *(_DWORD *)(a1[5] + 4) = v29;
    a1[94] = v30;
    --v4[13];
    v4[4] = v46;
    v4[8] = v43;
    v4[5] = v8;
    return 1;
  }
  while ( 1 )
  {
    if ( v10 > v42 )
      goto LABEL_61;
    if ( v8 >= 8 )
      goto LABEL_10;
    if ( !sub_1002FAAB(&v28, v46, v8, 0) )
      goto LABEL_63;
    v8 = v32;
    v46 = v31;
    if ( v32 >= 8 )
    {
LABEL_10:
      v12 = (unsigned __int8)(v46 >> (v8 - 8));
      v13 = *(_DWORD *)(v39 + 4 * v12 + 212);
      if ( v13 )
      {
        v8 -= v13;
        v44 = *(unsigned __int8 *)(v12 + v39 + 1236);
        goto LABEL_15;
      }
      v11 = 9;
    }
    else
    {
      v11 = 1;
    }
    v44 = sub_1002FB95((int)&v28, v46, v8, v39, v11);
    if ( v44 < 0 )
      goto LABEL_63;
    v8 = v32;
    v46 = v31;
LABEL_15:
    v14 = v44 >> 4;
    v5 = (v44 & 0xF) == 0;
    v44 &= 0xFu;
    v38 = v14;
    if ( v5 )
      break;
    if ( v44 != 1 )
    {
      *(_DWORD *)(*a1 + 20) = 114;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    }
    if ( v8 < 1 )
    {
      if ( !sub_1002FAAB(&v28, v46, v8, 1) )
        goto LABEL_63;
      v8 = v32;
      v46 = v31;
    }
    --v8;
    v15 = v36;
    if ( ((v46 >> v8) & 1) == 0 )
      v15 = v35;
    v44 = v15;
LABEL_25:
    v16 = v45;
    do
    {
      v17 = (__int16 *)(v41 + 2 * dword_1004E8C0[v16]);
      v5 = *v17 == 0;
      v37 = v17;
      if ( v5 )
      {
        if ( --v38 < 0 )
          break;
      }
      else
      {
        if ( v8 < 1 )
        {
          if ( !sub_1002FAAB(&v28, v46, v8, 1) )
            goto LABEL_63;
          v8 = v32;
          v46 = v31;
          v17 = v37;
        }
        if ( ((v46 >> --v8) & 1) != 0 )
        {
          v18 = v36;
          if ( (*v17 & v36) == 0 )
          {
            if ( *v17 < 0 )
              v18 = v35;
            *v17 += v18;
          }
        }
      }
      v16 = ++v45;
    }
    while ( v45 <= v42 );
    if ( v44 )
    {
      v19 = dword_1004E8C0[v16];
      *(_WORD *)(v41 + 2 * v19) = v44;
      v20 = v40++;
      v27[v20 + 1] = v19;
    }
    v10 = ++v45;
  }
  if ( v14 == 15 )
    goto LABEL_25;
  v21 = 1 << v14;
  v39 = 1 << v14;
  v43 = 1 << v14;
  if ( !v14 )
    goto LABEL_47;
  if ( v8 >= v14 )
    goto LABEL_46;
  if ( sub_1002FAAB(&v28, v46, v8, v14) )
  {
    v8 = v32;
    v46 = v31;
    v21 = v39;
LABEL_46:
    v8 -= v38;
    v43 += (v21 - 1) & (v46 >> v8);
    goto LABEL_47;
  }
LABEL_63:
  for ( j = v40; j > 0; --j )
  {
    v26 = v27[j];
    *(_WORD *)(v41 + 2 * v26) = 0;
  }
  return 0;
}

// sub_10030AE4 @ 0x10030AE4
int __cdecl sub_10030AE4(int *a1)
{
  int v2; // eax
  int v3; // ebx
  char v4; // dl
  bool v5; // zf
  int v6; // ecx
  int v7; // eax
  int v8; // eax
  int *v9; // ebx
  int i; // edi
  int v11; // ecx
  int v12; // eax
  unsigned int v13; // edi
  unsigned int v14; // edi
  _DWORD *v15; // eax
  int result; // eax
  int v17; // [esp+10h] [ebp-10h]
  _DWORD *v18; // [esp+10h] [ebp-10h]
  _DWORD *v19; // [esp+14h] [ebp-Ch]
  int *v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  int v22; // [esp+1Ch] [ebp-4h]
  int v23; // [esp+1Ch] [ebp-4h]
  bool v24; // [esp+2Bh] [ebp+Bh]

  v2 = a1[90];
  v3 = a1[101];
  v24 = v2 == 0;
  v4 = 0;
  v21 = v3;
  if ( v2 )
  {
    v6 = a1[91];
    if ( v2 > v6 || v6 >= 64 )
      v4 = 1;
    v5 = a1[72] == 1;
  }
  else
  {
    v5 = a1[91] == 0;
  }
  if ( !v5 )
    v4 = 1;
  v7 = a1[92];
  if ( v7 && a1[93] != v7 - 1 )
    v4 = 1;
  if ( a1[93] > 13 )
    v4 = 1;
  if ( v4 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a1[90];
    *(_DWORD *)(*a1 + 28) = a1[91];
    *(_DWORD *)(*a1 + 32) = a1[92];
    *(_DWORD *)(*a1 + 36) = a1[93];
    (*(void (__cdecl **)(int *))*a1)(a1);
  }
  v22 = 0;
  if ( a1[72] > 0 )
  {
    v19 = a1 + 73;
    do
    {
      v8 = *(_DWORD *)(*v19 + 4);
      v9 = (int *)(a1[35] + (v8 << 8));
      v17 = v8;
      if ( !v24 && *v9 < 0 )
      {
        *(_DWORD *)(*a1 + 20) = 111;
        *(_DWORD *)(*a1 + 24) = v8;
        *(_DWORD *)(*a1 + 28) = 0;
        (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
        v8 = v17;
      }
      for ( i = a1[90]; i <= a1[91]; ++i )
      {
        v11 = v9[i];
        if ( v11 < 0 )
          v11 = 0;
        if ( a1[92] != v11 )
        {
          *(_DWORD *)(*a1 + 20) = 111;
          *(_DWORD *)(*a1 + 24) = v8;
          *(_DWORD *)(*a1 + 28) = i;
          (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
          v8 = v17;
        }
        v9[i] = a1[93];
      }
      ++v22;
      ++v19;
    }
    while ( v22 < a1[72] );
    v3 = v21;
  }
  if ( a1[92] )
  {
    if ( v24 )
      *(_DWORD *)(v3 + 4) = sub_10030694;
    else
      *(_DWORD *)(v3 + 4) = sub_10030776;
  }
  else if ( v24 )
  {
    *(_DWORD *)(v3 + 4) = sub_1003026E;
  }
  else
  {
    *(_DWORD *)(v3 + 4) = sub_1003046B;
  }
  v23 = 0;
  if ( a1[72] > 0 )
  {
    v18 = (_DWORD *)(v3 + 36);
    v20 = a1 + 73;
    while ( 1 )
    {
      v12 = *v20;
      if ( !v24 )
        break;
      if ( !a1[92] )
      {
        v13 = *(_DWORD *)(v12 + 20);
        if ( v13 >= 4 || !a1[v13 + 40] )
        {
          *(_DWORD *)(*a1 + 20) = 49;
          *(_DWORD *)(*a1 + 24) = v13;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        sub_1002F901((int)a1, a1[v13 + 40], v21 + 4 * v13 + 56);
LABEL_49:
        v3 = v21;
      }
      v15 = v18;
      ++v23;
      ++v20;
      ++v18;
      *v15 = 0;
      if ( v23 >= a1[72] )
        goto LABEL_51;
    }
    v14 = *(_DWORD *)(v12 + 24);
    if ( v14 >= 4 || !a1[v14 + 44] )
    {
      *(_DWORD *)(*a1 + 20) = 49;
      *(_DWORD *)(*a1 + 24) = v14;
      (*(void (__cdecl **)(int *))*a1)(a1);
    }
    sub_1002F901((int)a1, a1[v14 + 44], v21 + 4 * v14 + 56);
    *(_DWORD *)(v21 + 72) = *(_DWORD *)(v21 + 4 * v14 + 56);
    goto LABEL_49;
  }
LABEL_51:
  *(_BYTE *)(v3 + 24) = 0;
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 16) = 0;
  *(_DWORD *)(v3 + 32) = 0;
  result = a1[63];
  *(_DWORD *)(v3 + 52) = result;
  return result;
}

// sub_10030D87 @ 0x10030D87
int __cdecl sub_10030D87(int a1)
{
  int (__cdecl **v1)(int *); // eax
  int result; // eax
  int v3; // edx
  bool v4; // cc
  char *v5; // ebx
  void *v6; // edi

  v1 = (int (__cdecl **)(int *))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_10030AE4;
  v1[14] = 0;
  v1[15] = 0;
  v1[16] = 0;
  v1[17] = 0;
  result = (**(int (__cdecl ***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD *)(a1 + 32) << 8);
  v3 = 0;
  v4 = *(_DWORD *)(a1 + 32) <= 0;
  *(_DWORD *)(a1 + 140) = result;
  v5 = (char *)result;
  if ( !v4 )
  {
    do
    {
      result = -1;
      v6 = v5;
      v5 += 256;
      ++v3;
      memset(v6, 0xFFu, 0x100u);
    }
    while ( v3 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10030DE8 @ 0x10030DE8
int __cdecl sub_10030DE8(_DWORD *a1)
{
  bool v2; // cc
  int result; // eax
  int v4; // edi
  int *v5; // ebx
  int v6; // edi
  int v7; // eax
  int v8; // eax
  int v9; // edx
  int v10; // edx
  int v11; // eax
  double *v12; // ecx
  double v13; // st7
  __int16 *v14; // eax
  int v15; // edx
  _WORD *v16; // eax
  int v17; // ecx
  int v18; // edx
  int v19; // [esp+Ch] [ebp-14h]
  int i; // [esp+10h] [ebp-10h]
  int v21; // [esp+14h] [ebp-Ch]
  double *v22; // [esp+18h] [ebp-8h]
  int v23; // [esp+18h] [ebp-8h]
  int v24; // [esp+1Ch] [ebp-4h]
  int (__cdecl *v25)(int, int, int, int, int); // [esp+28h] [ebp+8h]

  v2 = a1[8] <= 0;
  result = a1[102];
  v4 = a1[49];
  v24 = 0;
  v25 = 0;
  v21 = 0;
  if ( !v2 )
  {
    v5 = (int *)(result + 44);
    v6 = v4 + 36;
    for ( i = result + 44; ; i += 4 )
    {
      if ( *(_DWORD *)v6 == 1 )
      {
        v25 = sub_10035ECB;
        goto LABEL_19;
      }
      if ( *(_DWORD *)v6 == 2 )
      {
        v25 = sub_10035D0D;
        goto LABEL_19;
      }
      if ( *(_DWORD *)v6 == 4 )
        break;
      if ( *(_DWORD *)v6 != 8 )
      {
        *(_DWORD *)(*a1 + 20) = 6;
        *(_DWORD *)(*a1 + 24) = *(_DWORD *)v6;
LABEL_12:
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        goto LABEL_20;
      }
      v7 = a1[17];
      if ( !v7 )
      {
        v25 = sub_10035F08;
LABEL_19:
        v24 = 0;
        goto LABEL_20;
      }
      v8 = v7 - 1;
      if ( v8 )
      {
        if ( v8 != 1 )
        {
          *(_DWORD *)(*a1 + 20) = 47;
          goto LABEL_12;
        }
        v25 = sub_10035FA0;
        v24 = 2;
      }
      else
      {
        v25 = sub_10035F54;
        v24 = 1;
      }
LABEL_20:
      *(v5 - 10) = (int)v25;
      if ( *(_BYTE *)(v6 + 12) )
      {
        if ( *v5 != v24 )
        {
          v9 = *(_DWORD *)(v6 + 40);
          v19 = v9;
          if ( v9 )
          {
            *v5 = v24;
            if ( v24 )
            {
              if ( v24 == 1 )
              {
                v14 = (__int16 *)&unk_1004F510;
                v15 = v9 - (_DWORD)&unk_1004F510;
                v23 = *(_DWORD *)(v6 + 44) - (_DWORD)&unk_1004F510;
                do
                {
                  *(__int16 *)((char *)v14 + v23) = (*v14 * *(__int16 *)((char *)v14 + v15) + 2048) >> 12;
                  ++v14;
                }
                while ( (int)v14 < (int)word_1004F590 );
              }
              else
              {
                v10 = *(_DWORD *)(v6 + 44);
                v11 = 0;
                v22 = (double *)word_1004F590;
                do
                {
                  v12 = (double *)word_1004F590;
                  do
                  {
                    v13 = (double)*(unsigned __int16 *)(v19 + 2 * v11) * *v12++;
                    *(float *)(v10 + 4 * v11++) = v13 * *v22;
                  }
                  while ( (int)v12 < (int)dbl_1004F5D0 );
                  ++v22;
                }
                while ( (int)v22 < (int)dbl_1004F5D0 );
              }
            }
            else
            {
              v16 = *(_WORD **)(v6 + 44);
              v17 = v9 - (_DWORD)v16;
              v18 = 64;
              do
              {
                *v16 = *(_WORD *)((char *)v16 + v17);
                ++v16;
                --v18;
              }
              while ( v18 );
            }
          }
        }
      }
      result = ++v21;
      v5 = (int *)(i + 4);
      v6 += 84;
      if ( v21 >= a1[8] )
        return result;
    }
    v25 = sub_100359F8;
    goto LABEL_19;
  }
  return result;
}

// sub_10030F9F @ 0x10030F9F
_DWORD *__cdecl sub_10030F9F(int a1)
{
  _DWORD *result; // eax
  _DWORD *v3; // ebx
  void *v4; // edi
  _DWORD *v5; // eax
  int v6; // [esp+4h] [ebp-4h]
  int v7; // [esp+10h] [ebp+8h]

  result = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  v6 = 0;
  *(_DWORD *)(a1 + 408) = result;
  *result = sub_10030DE8;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = *(_DWORD *)(a1 + 196) + 80;
    v3 = result + 11;
    do
    {
      v4 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
      v5 = (_DWORD *)v7;
      v7 += 84;
      *v5 = v4;
      memset(v4, 0, 0x100u);
      *v3 = -1;
      result = (_DWORD *)++v6;
      ++v3;
    }
    while ( v6 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10031013 @ 0x10031013
int __cdecl sub_10031013(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v7; // ebx
  int v8; // esi
  _DWORD *v9; // edi
  unsigned int v10; // eax
  int result; // eax

  v7 = a1;
  v8 = *(_DWORD *)(a1 + 392);
  v9 = a6;
  v10 = a7 - *a6;
  if ( v10 > *(_DWORD *)(v8 + 16) )
    v10 = *(_DWORD *)(v8 + 16);
  a1 = 0;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, int *, unsigned int))(*(_DWORD *)(v7 + 412) + 4))(
    v7,
    a2,
    a3,
    a4,
    *(_DWORD *)(v8 + 12),
    &a1,
    v10);
  (*(void (__cdecl **)(int, _DWORD, int, int))(*(_DWORD *)(v7 + 420) + 4))(v7, *(_DWORD *)(v8 + 12), a5 + 4 * *v9, a1);
  result = a1;
  *v9 += a1;
  return result;
}

// FUN_10031078 @ 0x10031078
// [binja] int32_t sub_10031078(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t* arg5)
unsigned int __cdecl sub_10031078(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  _DWORD *v7; // esi
  unsigned int *v8; // edi
  unsigned int v9; // ecx
  unsigned int result; // eax
  unsigned int v11; // [esp+14h] [ebp+8h]
  unsigned int v12; // [esp+14h] [ebp+8h]

  v7 = (_DWORD *)a1[98];
  v8 = v7 + 6;
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, int))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 1);
  v11 = *v8;
  (*(void (__cdecl **)(_DWORD *, int, int, int, _DWORD, _DWORD *, _DWORD))(a1[103] + 4))(
    a1,
    a2,
    a3,
    a4,
    v7[3],
    v7 + 6,
    v7[4]);
  v9 = v11;
  if ( *v8 > v11 )
  {
    v12 = *v8 - v11;
    (*(void (__cdecl **)(_DWORD *, unsigned int, _DWORD, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v9, 0, v12);
    *a6 += v12;
  }
  result = v7[4];
  if ( *v8 >= result )
  {
    v7[5] += result;
    *v8 = 0;
  }
  return result;
}

// FUN_10031108 @ 0x10031108
// [binja] int32_t sub_10031108(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
unsigned int __cdecl sub_10031108(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // esi
  unsigned int v8; // edi
  unsigned int result; // eax

  v7 = (_DWORD *)a1[98];
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, _DWORD))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 0);
  v8 = v7[4] - v7[6];
  if ( v8 > a7 - *a6 )
    v8 = a7 - *a6;
  if ( v8 > a1[24] - v7[5] )
    v8 = a1[24] - v7[5];
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v7[6], a5 + 4 * *a6, v8);
  *a6 += v8;
  v7[6] += v8;
  result = v7[4];
  if ( v7[6] >= result )
  {
    v7[5] += result;
    v7[6] = 0;
  }
  return result;
}

// sub_10031194 @ 0x10031194
int __cdecl sub_10031194(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // esi
  bool v4; // zf

  result = a1;
  v3 = *(_DWORD **)(a1 + 392);
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10031108;
    }
    else if ( a2 == 3 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10031078;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (**(int (__cdecl ***)(int))a1)(a1);
    }
  }
  else if ( *(_BYTE *)(a1 + 74) )
  {
    v4 = v3[3] == 0;
    v3[1] = sub_10031013;
    if ( v4 )
    {
      result = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 4) + 28))(a1, v3[2], 0, v3[4], 1);
      v3[3] = result;
    }
  }
  else
  {
    result = *(_DWORD *)(*(_DWORD *)(a1 + 412) + 4);
    v3[1] = result;
  }
  v3[6] = 0;
  v3[5] = 0;
  return result;
}

// sub_1003123A @ 0x1003123A
int (__cdecl **__cdecl sub_1003123A(int a1, char a2))(int a1, int a2)
{
  int (__cdecl **result)(int, int); // eax
  int (__cdecl **v3)(int, int); // edi
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v7; // [esp-8h] [ebp-14h]

  result = (int (__cdecl **)(int, int))(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  v3 = result;
  *(_DWORD *)(a1 + 392) = result;
  *result = sub_10031194;
  result[2] = 0;
  result[3] = 0;
  if ( *(_BYTE *)(a1 + 74) )
  {
    v4 = *(_DWORD *)(a1 + 272);
    v3[4] = (int (__cdecl *)(int, int))v4;
    if ( a2 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      v7 = v4;
      v6 = sub_10022B93(*(_DWORD *)(a1 + 96), v4);
      result = (int (__cdecl **)(int, int))(*(int (__cdecl **)(int, int, _DWORD, int, int, int))(v5 + 16))(
                                             a1,
                                             1,
                                             0,
                                             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
                                             v6,
                                             v7);
      v3[2] = (int (__cdecl *)(int, int))result;
    }
    else
    {
      result = (int (__cdecl **)(int, int))(*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
                                             a1,
                                             1,
                                             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
                                             v4);
      v3[3] = (int (__cdecl *)(int, int))result;
    }
  }
  return result;
}

// sub_100312BD @ 0x100312BD
int __cdecl sub_100312BD(_DWORD *a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1[103];
  *(_DWORD *)(v1 + 92) = a1[68];
  result = a1[24];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

// FUN_100312d7 @ 0x100312D7
// [binja] int32_t* sub_100312d7(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5, int32_t arg6)
_DWORD *__cdecl sub_100312D7(_DWORD *a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v8; // esi
  int v9; // edi
  unsigned int v10; // edi
  _DWORD *result; // eax
  int v12; // [esp+Ch] [ebp-4h]
  int v13; // [esp+18h] [ebp+8h]
  unsigned int v14; // [esp+30h] [ebp+20h]

  v8 = a1[103];
  if ( *(_DWORD *)(v8 + 92) >= a1[68] )
  {
    v13 = 0;
    v12 = a1[49];
    if ( (int)a1[8] > 0 )
    {
      v9 = v8 + 12;
      do
      {
        (*(void (__cdecl **)(_DWORD *, int, int, int))(v9 + 40))(
          a1,
          v12,
          *(_DWORD *)(a2 + 4 * v13) + 4 * *a3 * *(_DWORD *)(v9 + 88),
          v9);
        v12 += 84;
        ++v13;
        v9 += 4;
      }
      while ( v13 < a1[8] );
    }
    *(_DWORD *)(v8 + 92) = 0;
  }
  v10 = a1[68] - *(_DWORD *)(v8 + 92);
  if ( v10 > *(_DWORD *)(v8 + 96) )
    v10 = *(_DWORD *)(v8 + 96);
  v14 = a7 - *a6;
  if ( v10 > v14 )
    v10 = v14;
  (*(void (__cdecl **)(_DWORD *, int, _DWORD, int, unsigned int))(a1[104] + 4))(
    a1,
    v8 + 12,
    *(_DWORD *)(v8 + 92),
    a5 + 4 * *a6,
    v10);
  result = a6;
  *a6 += v10;
  *(_DWORD *)(v8 + 96) -= v10;
  *(_DWORD *)(v8 + 92) += v10;
  if ( *(_DWORD *)(v8 + 92) >= a1[68] )
  {
    ++*a3;
    return a3;
  }
  return result;
}

// sub_1003139D @ 0x1003139D
_DWORD *__cdecl sub_1003139D(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = a3;
  return a4;
}

// sub_100313A8 @ 0x100313A8
_DWORD *__cdecl sub_100313A8(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = 0;
  return a4;
}

// sub_100313B0 @ 0x100313B0
const void **__cdecl sub_100313B0(unsigned int *a1, int a2, char **a3, int *a4)
{
  int v4; // ebx
  int v6; // eax
  int v7; // ecx
  const void **result; // eax
  int v9; // edi
  char *v10; // edx
  char *v11; // eax
  unsigned int v12; // ecx
  char v13; // al
  int v14; // eax
  unsigned int v15; // [esp+Ch] [ebp-14h]
  int v16; // [esp+14h] [ebp-Ch]
  int i; // [esp+18h] [ebp-8h]
  int v18; // [esp+1Ch] [ebp-4h]
  char *v19; // [esp+28h] [ebp+8h]
  int v21; // [esp+34h] [ebp+14h]

  v4 = *a4;
  v6 = *(_DWORD *)(a2 + 4) + a1[103];
  v7 = *(unsigned __int8 *)(v6 + 140);
  result = (const void **)*(unsigned __int8 *)(v6 + 150);
  v9 = 0;
  v16 = *a4;
  v21 = v7;
  v18 = (int)result;
  for ( i = 0; v9 < (int)a1[68]; i = v9 )
  {
    v10 = *a3;
    v11 = *(char **)(v4 + 4 * v9);
    v12 = (unsigned int)&v11[a1[23]];
    v19 = v11;
    v15 = v12;
    while ( (unsigned int)v19 < v12 )
    {
      v13 = *v10++;
      if ( v21 > 0 )
      {
        LOBYTE(v4) = v13;
        BYTE1(v4) = v13;
        v14 = v4 << 16;
        LOWORD(v14) = v4;
        v4 = v16;
        memset32(v19, v14, (unsigned int)v21 >> 2);
        memset(&v19[4 * ((unsigned int)v21 >> 2)], v14, v21 & 3);
        v9 = i;
        v12 = v15;
        v19 += v21;
      }
    }
    result = (const void **)v18;
    if ( v18 > 1 )
      result = sub_10022BAB(v4, v9, v4, v9 + 1, v18 - 1, a1[23]);
    v9 += v18;
    ++a3;
  }
  return result;
}

// FUN_1003148d @ 0x1003148D
// [binja] int32_t* sub_1003148d(int32_t* arg1, int32_t arg2, int32_t* arg3)
_BYTE ***__cdecl sub_1003148D(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE ***result; // eax
  _BYTE **v6; // esi
  int v7; // edx
  _BYTE *v8; // eax
  char *v9; // edi
  unsigned int v10; // ecx
  char v11; // dl
  _BYTE *v12; // eax
  int v13; // [esp+10h] [ebp+8h]
  int v14; // [esp+1Ch] [ebp+14h]

  result = a4;
  v14 = 0;
  v6 = *result;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v7 = a3 - (_DWORD)v6;
    v13 = a3 - (_DWORD)v6;
    do
    {
      v8 = *v6;
      v9 = *(_BYTE **)((char *)v6 + v7);
      v10 = (unsigned int)&(*v6)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v6 < v10 )
      {
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v12 = v8 + 1;
          *v12 = v11;
          v8 = v12 + 1;
        }
        while ( (unsigned int)v8 < v10 );
        v7 = v13;
      }
      result = (_BYTE ***)++v14;
      ++v6;
    }
    while ( v14 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// FUN_100314e4 @ 0x100314E4
// [binja] int32_t* sub_100314e4(void* arg1, int32_t* arg2, int32_t* arg3)
const void **__cdecl sub_100314E4(int a1, int a2, char **a3, int *a4)
{
  const void **result; // eax
  int v5; // ebx
  int v6; // esi
  char *v7; // edx
  _BYTE *v8; // ecx
  _BYTE *v9; // eax
  char v10; // bl
  _BYTE *v11; // ecx
  int i; // [esp+Ch] [ebp-4h]

  result = (const void **)a4;
  v5 = *a4;
  v6 = 0;
  for ( i = *a4; v6 < *(_DWORD *)(a1 + 272); v6 += 2 )
  {
    v7 = *a3;
    v8 = *(_BYTE **)(v5 + 4 * v6);
    v9 = &v8[*(_DWORD *)(a1 + 92)];
    if ( v8 < v9 )
    {
      do
      {
        v10 = *v7++;
        *v8 = v10;
        v11 = v8 + 1;
        *v11 = v10;
        v8 = v11 + 1;
      }
      while ( v8 < v9 );
      v5 = i;
    }
    result = sub_10022BAB(v5, v6, v5, v6 + 1, 1, *(_DWORD *)(a1 + 92));
    ++a3;
  }
  return result;
}

// sub_1003154E @ 0x1003154E
int __cdecl sub_1003154E(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v5; // esi
  int result; // eax
  int v7; // ebx
  unsigned __int8 *v8; // eax
  int v9; // edx
  _BYTE *v10; // ecx
  unsigned __int8 *v11; // eax
  _BYTE *v12; // ecx
  int v13; // edi
  int v14; // edx
  _BYTE *v15; // ecx
  int v16; // edx
  int v17; // [esp+4h] [ebp-4h]
  int v18; // [esp+1Ch] [ebp+14h]

  v18 = 0;
  v5 = *a4;
  result = a1;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v7 = a3 - (_DWORD)v5;
    do
    {
      v8 = *(_BYTE **)((char *)v5 + v7);
      v9 = *v8;
      v10 = *v5;
      *v10 = v9;
      v11 = v8 + 1;
      *++v10 = (3 * v9 + *v11 + 2) >> 2;
      v12 = v10 + 1;
      if ( *(_DWORD *)(a2 + 40) != 2 )
      {
        v17 = *(_DWORD *)(a2 + 40) - 2;
        do
        {
          v13 = *v11;
          v14 = *(v11++ - 1);
          v13 *= 3;
          *v12 = (v14 + v13 + 1) >> 2;
          v15 = v12 + 1;
          *v15 = (*v11 + v13 + 2) >> 2;
          v12 = v15 + 1;
          --v17;
        }
        while ( v17 );
      }
      v16 = *v11;
      ++v18;
      *v12 = (*(v11 - 1) + 3 * v16 + 1) >> 2;
      result = a1;
      v12[1] = v16;
      ++v5;
    }
    while ( v18 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_100315F2 @ 0x100315F2
unsigned __int8 **__cdecl sub_100315F2(unsigned __int8 **a1, int a2, unsigned __int8 **a3, int *a4)
{
  unsigned __int8 **result; // eax
  unsigned __int8 *v5; // edx
  unsigned __int8 *v6; // edi
  _BYTE *v7; // esi
  int v8; // ecx
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // edx
  int v11; // eax
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // edx
  _BYTE *v14; // esi
  _BYTE *v15; // esi
  bool v16; // zf
  int v17; // [esp+0h] [ebp-14h]
  int v18; // [esp+4h] [ebp-10h]
  unsigned __int8 **v19; // [esp+8h] [ebp-Ch]
  int v20; // [esp+Ch] [ebp-8h]
  int v21; // [esp+10h] [ebp-4h]
  int v22; // [esp+28h] [ebp+14h]

  v21 = 0;
  v17 = *a4;
  result = a1;
  if ( (int)a1[68] > 0 )
  {
    result = a3;
    v19 = a3;
    do
    {
      v22 = 0;
      do
      {
        v5 = *result;
        if ( v22 )
          v6 = result[1];
        else
          v6 = *(result - 1);
        v7 = *(_BYTE **)(v17 + 4 * v21++);
        v8 = *v6 + 3 * *v5;
        v9 = v6 + 1;
        v10 = v5 + 1;
        v11 = *v9 + 3 * *v10;
        *v7 = (4 * v8 + 8) >> 4;
        v12 = v9 + 1;
        v13 = v10 + 1;
        *++v7 = (v8 + v11 + 2 * v8 + 7) >> 4;
        v14 = v7 + 1;
        v20 = v11;
        if ( *(_DWORD *)(a2 + 40) != 2 )
        {
          v18 = *(_DWORD *)(a2 + 40) - 2;
          do
          {
            v11 = *v12 + 3 * *v13;
            *v14 = (3 * v20 + v8 + 8) >> 4;
            ++v12;
            ++v13;
            v15 = v14 + 1;
            *v15 = (3 * v20 + v11 + 7) >> 4;
            v8 = v20;
            v14 = v15 + 1;
            v16 = v18-- == 1;
            v20 = v11;
          }
          while ( !v16 );
        }
        ++v22;
        *v14 = (v11 + v8 + 2 * v11 + 8) >> 4;
        v14[1] = (4 * v11 + 7) >> 4;
        result = v19;
      }
      while ( v22 < 2 );
      result = ++v19;
    }
    while ( v21 < (int)a1[68] );
  }
  return result;
}

// sub_100316F9 @ 0x100316F9
int __cdecl sub_100316F9(int a1)
{
  int result; // eax
  int v3; // ebx
  _DWORD *v4; // ecx
  int v5; // edi
  int v6; // ebx
  int v7; // eax
  int v8; // edx
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // [esp-4h] [ebp-28h]
  _DWORD *v13; // [esp+10h] [ebp-14h]
  int v14; // [esp+14h] [ebp-10h]
  int v15; // [esp+18h] [ebp-Ch]
  int v16; // [esp+1Ch] [ebp-8h]
  int v17; // [esp+20h] [ebp-4h]
  bool v18; // [esp+2Fh] [ebp+Bh]

  result = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  v3 = result;
  *(_DWORD *)(a1 + 412) = result;
  *(_BYTE *)(result + 8) = 0;
  *(_DWORD *)result = sub_100312BD;
  *(_DWORD *)(result + 4) = FUN_100312d7;
  v14 = result;
  if ( *(_BYTE *)(a1 + 264) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 23;
    result = (**(int (__cdecl ***)(int))a1)(a1);
  }
  v18 = *(_BYTE *)(a1 + 72) && *(int *)(a1 + 276) > 1;
  v16 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v4 = (_DWORD *)(v3 + 52);
    v5 = *(_DWORD *)(a1 + 196) + 36;
    v13 = (_DWORD *)(v3 + 52);
    do
    {
      v6 = *(_DWORD *)(a1 + 276);
      v15 = *(_DWORD *)v5 * *(_DWORD *)(v5 - 28) / v6;
      v7 = *(_DWORD *)v5 * *(_DWORD *)(v5 - 24) / v6;
      v8 = *(_DWORD *)(a1 + 268);
      v17 = *(_DWORD *)(a1 + 272);
      v4[12] = v7;
      if ( *(_BYTE *)(v5 + 12) )
      {
        if ( v15 != v8 || v7 != v17 )
        {
          if ( 2 * v15 == v8 )
          {
            if ( v7 == v17 )
            {
              if ( v18 && *(_DWORD *)(v5 + 4) > 2u )
                *v4 = sub_1003154E;
              else
                *v4 = FUN_1003148d;
LABEL_30:
              v12 = *(_DWORD *)(a1 + 272);
              v9 = *(_DWORD *)(a1 + 4);
              v10 = sub_10022B93(*(_DWORD *)(a1 + 92), *(_DWORD *)(a1 + 268));
              v11 = (*(int (__cdecl **)(int, int, int, int))(v9 + 8))(a1, 1, v10, v12);
              v4 = v13;
              *(v13 - 10) = v11;
              goto LABEL_31;
            }
            if ( 2 * v15 == v8 && 2 * v7 == v17 )
            {
              if ( v18 && *(_DWORD *)(v5 + 4) > 2u )
              {
                *v4 = sub_100315F2;
                *(_BYTE *)(v14 + 8) = 1;
              }
              else
              {
                *v4 = FUN_100314e4;
              }
              goto LABEL_30;
            }
          }
          if ( v8 % v15 || v17 % v7 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 37;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            *v4 = sub_100313B0;
            *(_BYTE *)(v16 + v14 + 140) = v8 / v15;
            *(_BYTE *)(v16 + v14 + 150) = v17 / v7;
          }
          goto LABEL_30;
        }
        *v4 = sub_1003139D;
      }
      else
      {
        *v4 = sub_100313A8;
      }
LABEL_31:
      result = ++v16;
      ++v4;
      v5 += 84;
      v13 = v4;
    }
    while ( v16 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_100318BA @ 0x100318BA
int __usercall sub_100318BA@<eax>(int a1@<eax>)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // edx
  int i; // ecx
  int v6; // edi
  int v7; // edi
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 416);
  v2[2] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[3] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v4 = 5990656;
  v8 = -14831872;
  v9 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    v6 = v9;
    v9 += 91881;
    *(_DWORD *)(result + v2[2]) = v6 >> 16;
    v7 = v8;
    v8 += 116130;
    *(_DWORD *)(result + v2[3]) = v7 >> 16;
    *(_DWORD *)(result + v2[4]) = v4;
    *(_DWORD *)(result + v2[5]) = i;
    v4 -= 46802;
    result += 4;
  }
  return result;
}

// sub_1003196A @ 0x1003196A
_BYTE *__cdecl sub_1003196A(int a1, int a2, int a3, _DWORD *a4, _BYTE *a5)
{
  int v5; // ebx
  _BYTE *result; // eax
  int v8; // edi
  int i; // esi
  _BYTE *v10; // ecx
  int v11; // [esp+4h] [ebp-8h]
  _BYTE *v12; // [esp+8h] [ebp-4h]
  int v13; // [esp+14h] [ebp+8h]
  int v14; // [esp+24h] [ebp+18h]

  v5 = *(_DWORD *)(a1 + 92);
  result = a5 - 1;
  v13 = *(_DWORD *)(a1 + 32);
  v11 = v5;
  if ( (int)(a5 - 1) >= 0 )
  {
    v8 = 4 * a3;
    result = a5;
    v12 = a5;
    do
    {
      for ( i = 0; i < v13; ++i )
      {
        v10 = *(_BYTE **)(v8 + *(_DWORD *)(a2 + 4 * i));
        result = (_BYTE *)(i + *a4);
        if ( v5 )
        {
          v14 = v5;
          do
          {
            *result = *v10;
            result += v13;
            ++v10;
            --v14;
          }
          while ( v14 );
          v5 = v11;
        }
      }
      v8 += 4;
      ++a4;
      --v12;
    }
    while ( v12 );
  }
  return result;
}

// sub_100319D5 @ 0x100319D5
const void **__cdecl sub_100319D5(int a1, int *a2, int a3, int a4, int a5)
{
  return sub_10022BAB(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 92));
}

// sub_100319F8 @ 0x100319F8
_BYTE *__cdecl sub_100319F8(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edi
  int v7; // ecx
  _BYTE *result; // eax
  int v9; // edx
  _DWORD *v10; // esi
  unsigned __int8 *v11; // ecx
  _BYTE **v12; // eax
  int v13; // ebx
  int v14; // esi
  int v15; // esi
  int v16; // edi
  int v17; // [esp+8h] [ebp-28h]
  int v18; // [esp+Ch] [ebp-24h]
  int v19; // [esp+10h] [ebp-20h]
  int v20; // [esp+14h] [ebp-1Ch]
  int v21; // [esp+18h] [ebp-18h]
  int v22; // [esp+1Ch] [ebp-14h]
  int v23; // [esp+20h] [ebp-10h]
  int v24; // [esp+24h] [ebp-Ch]
  int v25; // [esp+24h] [ebp-Ch]
  int v26; // [esp+28h] [ebp-8h]
  int v27; // [esp+2Ch] [ebp-4h]
  int v28; // [esp+2Ch] [ebp-4h]
  int v29; // [esp+38h] [ebp+8h]
  int v30; // [esp+48h] [ebp+18h]
  int v31; // [esp+48h] [ebp+18h]

  v5 = (_DWORD *)a1[104];
  v6 = a1[23];
  v29 = a1[71];
  v21 = v5[2];
  v18 = v5[3];
  v7 = v5[4];
  v20 = v5[5];
  result = (_BYTE *)(a5 - 1);
  v17 = v6;
  v19 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = 4 * a3;
    v10 = a2;
    v26 = a5;
    do
    {
      v30 = *(_DWORD *)(v9 + *v10);
      v11 = *(unsigned __int8 **)(v9 + v10[1]);
      v27 = *(_DWORD *)(v9 + v10[2]);
      v24 = *(_DWORD *)(v9 + v10[3]);
      v12 = a4++;
      result = *v12;
      v9 += 4;
      if ( v6 )
      {
        v13 = v30 - (_DWORD)v11;
        v14 = v27 - (_DWORD)v11;
        v23 = v30 - (_DWORD)v11;
        v22 = v27 - (_DWORD)v11;
        v25 = v24 - (_DWORD)v11;
        v28 = v6;
        while ( 1 )
        {
          v31 = v11[v13];
          v15 = 4 * v11[v14];
          v16 = 4 * *v11;
          *result = *(_BYTE *)(v29 - *(_DWORD *)(v15 + v21) - v31 + 255);
          result += 4;
          *(result - 3) = *(_BYTE *)(v29 - ((*(_DWORD *)(v15 + v19) + *(_DWORD *)(v16 + v20)) >> 16) - v31 + 255);
          *(result - 2) = *(_BYTE *)(v29 - *(_DWORD *)(v16 + v18) - v31 + 255);
          *(result - 1) = (v11++)[v25];
          if ( !--v28 )
            break;
          v13 = v23;
          v14 = v22;
        }
        v6 = v17;
        v10 = a2;
      }
      --v26;
    }
    while ( v26 );
  }
  return result;
}

// sub_10031B2A @ 0x10031B2A
unsigned int *__cdecl sub_10031B2A(unsigned int a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, int a5)
{
  unsigned int *result; // eax
  unsigned int v8; // edi
  __m64 v10; // mm0
  __m64 v11; // mm3
  __m64 v12; // mm4
  __m64 v13; // mm6
  __m64 v14; // mm2
  __m64 v15; // mm5
  __m64 v16; // mm6
  __m64 v17; // mm7
  __m64 v18; // mm1
  __m64 v19; // mm0
  __m64 v20; // mm1
  __m64 v21; // mm4
  __m64 v22; // mm0
  __m64 v23; // mm3
  __m64 v24; // mm2
  __m64 v25; // mm3

  result = a2;
  v8 = a1 >> 2;
  do
  {
    v10 = _m_punpcklbw(_mm_cvtsi32_si64(*result), 0);
    v11 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a4), 0), (__m64)qword_10055840);
    v12 = _m_psubsw(_m_punpcklbw(_mm_cvtsi32_si64(*a3), 0), (__m64)qword_10055840);
    v13 = _m_psllwi(v10, 8u);
    v14 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpcklwd(v12, v11), (__m64)qword_10055848), _m_punpcklwd(v13, 0)), 8u);
    v15 = _m_psradi(_m_paddd(_m_pmaddwd(_m_punpckhwd(v12, v11), (__m64)qword_10055848), _m_punpckhwd(v13, 0)), 8u);
    v16 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v11, v10), (__m64)qword_10055850), 8u);
    v17 = _m_pmaddwd(_m_punpckhwd(v12, v10), (__m64)qword_10055858);
    v18 = _m_pmaddwd(_m_punpckhwd(v11, v10), (__m64)qword_10055850);
    v19 = _m_psradi(_m_pmaddwd(_m_punpcklwd(v12, v10), (__m64)qword_10055858), 8u);
    v20 = _m_psradi(v18, 8u);
    v21 = _m_psradi(v17, 8u);
    v22 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v16, v14), _m_punpckldq(v19, (__m64)(unsigned int)qword_1005DBA0)),
            _m_packssdw(_m_punpckhdq(v16, v14), _m_punpckhdq(v19, (__m64)qword_1005DBA0)));
    v23 = _m_psrlqi(_m_pand(v22, (__m64)qword_10055860), 8u);
    a5 += 12;
    v24 = _m_packuswb(
            _m_packssdw(_m_punpckldq(v20, v15), _m_punpckldq(v21, (__m64)(unsigned int)qword_1005DBA0)),
            _m_packssdw(_m_punpckhdq(v20, v15), _m_punpckhdq(v21, (__m64)qword_1005DBA0)));
    ++result;
    *(_DWORD *)(a5 - 12) = _mm_cvtsi64_si32(_m_por(v22, v23));
    v25 = _m_punpcklwd(_m_psrlqi(v23, 0x20u), v24);
    ++a4;
    *(_DWORD *)(a5 - 8) = _mm_cvtsi64_si32(v25);
    ++a3;
    *(_DWORD *)(a5 - 4) = _mm_cvtsi64_si32(_m_por(_m_psrlqi(v24, 0x18u), _m_psrlqi(v25, 0x30u)));
    --v8;
  }
  while ( v8 );
  return result;
}

// sub_10031C66 @ 0x10031C66
unsigned int *__cdecl sub_10031C66(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // esi
  unsigned int v7; // edi
  int v8; // ecx
  unsigned int *result; // eax
  unsigned int v10; // ebx
  int v11; // eax
  unsigned int *v12; // edx
  unsigned int *v13; // edi
  unsigned int *v14; // ecx
  int *v15; // eax
  int v16; // edi
  _BYTE *v17; // edi
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  bool v21; // zf
  _DWORD *v22; // ebx
  int v23; // edx
  unsigned int **v24; // eax
  unsigned __int8 *v25; // ecx
  int v26; // edx
  int v27; // edx
  int v28; // ebx
  unsigned int v29; // [esp+Ch] [ebp-34h]
  int v30; // [esp+Ch] [ebp-34h]
  int v31; // [esp+10h] [ebp-30h]
  int v32; // [esp+10h] [ebp-30h]
  int v33; // [esp+14h] [ebp-2Ch]
  int v34; // [esp+18h] [ebp-28h]
  int v35; // [esp+1Ch] [ebp-24h]
  unsigned int *v36; // [esp+20h] [ebp-20h]
  int v37; // [esp+24h] [ebp-1Ch]
  int v38; // [esp+28h] [ebp-18h]
  unsigned int v39; // [esp+28h] [ebp-18h]
  unsigned int v40; // [esp+2Ch] [ebp-14h]
  int v41; // [esp+2Ch] [ebp-14h]
  unsigned int v42; // [esp+30h] [ebp-10h]
  unsigned int *v43; // [esp+38h] [ebp-8h]
  int v44; // [esp+38h] [ebp-8h]
  int v45; // [esp+38h] [ebp-8h]
  int v46; // [esp+38h] [ebp-8h]
  unsigned int *v47; // [esp+3Ch] [ebp-4h]
  int v48; // [esp+3Ch] [ebp-4h]
  int v49; // [esp+3Ch] [ebp-4h]
  int v50; // [esp+3Ch] [ebp-4h]
  unsigned int *v51; // [esp+48h] [ebp+8h]
  int v52; // [esp+48h] [ebp+8h]
  unsigned __int8 *v53; // [esp+48h] [ebp+8h]

  v5 = (_DWORD *)a1[104];
  v6 = a1[71];
  v7 = a1[23];
  v37 = v5[2];
  v34 = v5[3];
  v8 = v5[4];
  result = (unsigned int *)v5[5];
  v10 = v7 & 0xFFFFFFF8;
  v42 = v7;
  v29 = v7 & 0xFFFFFFF8;
  v35 = v8;
  v36 = result;
  if ( byte_100554E8 )
  {
    if ( a5 - 1 >= 0 )
    {
      v31 = 3 * v10;
      v11 = 4 * a3;
      v38 = a5;
      while ( 1 )
      {
        v12 = *(unsigned int **)(v11 + *a2);
        v13 = *(unsigned int **)(v11 + a2[1]);
        v14 = *(unsigned int **)(v11 + a2[2]);
        v33 = v11 + 4;
        v15 = a4++;
        v51 = v13;
        v16 = *v15;
        v47 = v12;
        v43 = v14;
        result = sub_10031B2A(v10, v12, v51, v14, *v15);
        v17 = (_BYTE *)(v31 + v16);
        if ( v10 < v42 )
        {
          v48 = (char *)v47 - (char *)v51;
          v18 = (char *)v43 - (char *)v51;
          result = (unsigned int *)((char *)v51 + v10);
          v44 = (char *)v43 - (char *)v51;
          v40 = v42 - v10;
          while ( 1 )
          {
            v19 = 4 * *((unsigned __int8 *)result + v18);
            v52 = *((unsigned __int8 *)result + v48);
            v20 = *(unsigned __int8 *)result;
            *v17 = *(_BYTE *)(v52 + *(_DWORD *)(v19 + v37) + v6);
            v17 += 3;
            *(v17 - 2) = *(_BYTE *)(v52 + ((int)(*(_DWORD *)(v19 + v35) + v36[v20]) >> 16) + v6);
            result = (unsigned int *)((char *)result + 1);
            v21 = v40-- == 1;
            *(v17 - 1) = *(_BYTE *)(v52 + *(_DWORD *)(4 * v20 + v34) + v6);
            if ( v21 )
              break;
            v18 = v44;
          }
          v10 = v29;
        }
        if ( !--v38 )
          break;
        v11 = v33;
      }
    }
    _m_empty();
  }
  else
  {
    result = (unsigned int *)(a5 - 1);
    if ( a5 - 1 >= 0 )
    {
      v22 = a2;
      v23 = 4 * a3;
      v41 = a5;
      do
      {
        v49 = *(_DWORD *)(v23 + *v22);
        v53 = *(unsigned __int8 **)(v23 + v22[1]);
        v45 = *(_DWORD *)(v23 + v22[2]);
        v24 = (unsigned int **)a4++;
        result = *v24;
        v23 += 4;
        v32 = v23;
        if ( v7 )
        {
          v25 = v53;
          v50 = v49 - (_DWORD)v53;
          v26 = v45 - (_DWORD)v53;
          v46 = v45 - (_DWORD)v53;
          v39 = v7;
          while ( 1 )
          {
            v27 = v25[v26];
            v28 = v25[v50];
            v30 = *v25;
            *(_BYTE *)result = *(_BYTE *)(v28 + *(_DWORD *)(4 * v27 + v37) + v6);
            result = (unsigned int *)((char *)result + 3);
            *((_BYTE *)result - 2) = *(_BYTE *)(v28 + ((int)(*(_DWORD *)(4 * v27 + v35) + v36[v30]) >> 16) + v6);
            ++v25;
            v21 = v39-- == 1;
            *((_BYTE *)result - 1) = *(_BYTE *)(v28 + *(_DWORD *)(4 * v30 + v34) + v6);
            if ( v21 )
              break;
            v26 = v46;
          }
          v23 = v32;
          v22 = a2;
          v7 = v42;
        }
        --v41;
      }
      while ( v41 );
    }
  }
  return result;
}

// sub_10031E84 @ 0x10031E84
int __cdecl sub_10031E84(int a1)
{
  void (**v1)(); // edi
  int v2; // eax
  bool v3; // zf
  int result; // eax
  bool v5; // zf
  int v6; // eax
  int v7; // ecx

  v1 = (void (**)())(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 416) = v1;
  *v1 = nullsub_2;
  v2 = *(_DWORD *)(a1 + 36);
  if ( v2 == 1 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 1;
LABEL_10:
    if ( v3 )
      goto LABEL_12;
    goto LABEL_11;
  }
  if ( v2 <= 1 )
    goto LABEL_7;
  if ( v2 <= 3 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 3;
    goto LABEL_10;
  }
  if ( v2 <= 5 )
  {
    v3 = *(_DWORD *)(a1 + 32) == 4;
    goto LABEL_10;
  }
LABEL_7:
  if ( *(int *)(a1 + 32) >= 1 )
    goto LABEL_12;
LABEL_11:
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
  (**(void (__cdecl ***)(int))a1)(a1);
LABEL_12:
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    if ( *(_DWORD *)(a1 + 40) == 2 )
    {
      result = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 3;
      if ( result == 3 )
      {
        v1[1] = (void (*)())sub_10031C66;
        goto LABEL_23;
      }
      v5 = result == 2;
    }
    else
    {
      if ( *(_DWORD *)(a1 + 40) != 4 )
      {
        if ( *(_DWORD *)(a1 + 40) == *(_DWORD *)(a1 + 36) )
        {
          result = *(_DWORD *)(a1 + 32);
          *(_DWORD *)(a1 + 100) = result;
LABEL_26:
          v1[1] = (void (*)())sub_1003196A;
          goto LABEL_32;
        }
LABEL_17:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
        result = (**(int (__cdecl ***)(int))a1)(a1);
        goto LABEL_32;
      }
      result = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 4;
      if ( result == 5 )
      {
        v1[1] = (void (*)())sub_100319F8;
LABEL_23:
        result = sub_100318BA(a1);
        goto LABEL_32;
      }
      v5 = result == 4;
    }
    if ( v5 )
      goto LABEL_26;
    goto LABEL_17;
  }
  v6 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 100) = 1;
  if ( v6 != 1 && v6 != 3 )
    goto LABEL_17;
  v1[1] = (void (*)())sub_100319D5;
  result = 1;
  if ( *(int *)(a1 + 32) > 1 )
  {
    v7 = 84;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 196) + v7 + 48) = 0;
      ++result;
      v7 += 84;
    }
    while ( result < *(_DWORD *)(a1 + 32) );
  }
LABEL_32:
  if ( *(_BYTE *)(a1 + 74) )
  {
    *(_DWORD *)(a1 + 104) = 1;
  }
  else
  {
    result = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 104) = result;
  }
  return result;
}

// sub_10031FA5 @ 0x10031FA5
int __usercall sub_10031FA5@<eax>(int a1@<eax>)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // edx
  int i; // ecx
  int v6; // edi
  int v7; // edi
  int v8; // [esp+Ch] [ebp-8h]
  int v9; // [esp+10h] [ebp-4h]

  v2 = *(_DWORD **)(a1 + 412);
  v2[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[6] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v2[7] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v4 = 5990656;
  v8 = -14831872;
  v9 = -11728000;
  for ( i = 2919680; i >= -2831590; i -= 22554 )
  {
    v6 = v9;
    v9 += 91881;
    *(_DWORD *)(result + v2[4]) = v6 >> 16;
    v7 = v8;
    v8 += 116130;
    *(_DWORD *)(result + v2[5]) = v7 >> 16;
    *(_DWORD *)(result + v2[6]) = v4;
    *(_DWORD *)(result + v2[7]) = i;
    v4 -= 46802;
    result += 4;
  }
  return result;
}

// sub_10032055 @ 0x10032055
int __cdecl sub_10032055(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 412);
  *(_BYTE *)(result + 36) = 0;
  *(_DWORD *)(result + 44) = *(_DWORD *)(a1 + 96);
  return result;
}

// sub_1003206A @ 0x1003206A
const void **__cdecl sub_1003206A(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v7; // esi
  _DWORD *v8; // ebx
  unsigned int v9; // edi
  const void **result; // eax
  int *v11; // eax
  int v12; // [esp+Ch] [ebp-8h] BYREF
  int v13; // [esp+10h] [ebp-4h]
  unsigned int v14; // [esp+34h] [ebp+20h]

  v7 = *(_DWORD *)(a1 + 412);
  if ( *(_BYTE *)(v7 + 36) )
  {
    v8 = a6;
    v9 = 1;
    result = sub_10022BAB(v7 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v7 + 40));
    *(_BYTE *)(v7 + 36) = 0;
  }
  else
  {
    v9 = 2;
    if ( *(_DWORD *)(v7 + 44) < 2u )
      v9 = *(_DWORD *)(v7 + 44);
    v8 = a6;
    v14 = a7 - *a6;
    if ( v9 > v14 )
      v9 = v14;
    v11 = (int *)(a5 + 4 * *a6);
    v12 = *v11;
    if ( v9 <= 1 )
    {
      v13 = *(_DWORD *)(v7 + 32);
      *(_BYTE *)(v7 + 36) = 1;
    }
    else
    {
      v13 = v11[1];
    }
    result = (const void **)(*(int (__cdecl **)(int, int, _DWORD, int *))(v7 + 12))(a1, a2, *a3, &v12);
  }
  *v8 += v9;
  *(_DWORD *)(v7 + 44) -= v9;
  if ( !*(_BYTE *)(v7 + 36) )
  {
    ++*a3;
    return (const void **)a3;
  }
  return result;
}

// FUN_10032110 @ 0x10032110
// [binja] int32_t sub_10032110(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t* arg5)
int __cdecl sub_10032110(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax

  result = (*(int (__cdecl **)(int, int, _DWORD, int))(*(_DWORD *)(a1 + 412) + 12))(a1, a2, *a3, a5 + 4 * *a6);
  ++*a6;
  ++*a3;
  return result;
}

// sub_10032141 @ 0x10032141
_BYTE *__cdecl sub_10032141(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4)
{
  _DWORD *v4; // eax
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // edx
  unsigned __int8 *v8; // esi
  _BYTE *result; // eax
  int v10; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // edx
  unsigned __int8 *v14; // edi
  int v15; // edx
  _BYTE *v16; // eax
  int v17; // edi
  int v18; // ebx
  int v19; // esi
  int v20; // [esp+Ch] [ebp-18h]
  int v21; // [esp+10h] [ebp-14h]
  int v22; // [esp+14h] [ebp-10h]
  int v23; // [esp+18h] [ebp-Ch]
  unsigned __int8 *v24; // [esp+1Ch] [ebp-8h]
  unsigned __int8 *v25; // [esp+20h] [ebp-4h]
  int v26; // [esp+30h] [ebp+Ch]
  int v27; // [esp+34h] [ebp+10h]
  int v28; // [esp+34h] [ebp+10h]
  int v29; // [esp+34h] [ebp+10h]
  int v30; // [esp+38h] [ebp+14h]

  v4 = (_DWORD *)a1[103];
  v5 = a1[71];
  v20 = v4[4];
  v21 = v4[5];
  v23 = v4[7];
  v22 = v4[6];
  v6 = *(unsigned __int8 **)(4 * a3 + *a2);
  v7 = *(unsigned __int8 **)(4 * a3 + a2[1]);
  v8 = *(unsigned __int8 **)(4 * a3 + a2[2]);
  result = *a4;
  if ( a1[23] >> 1 )
  {
    v30 = a1[23] >> 1;
    do
    {
      v10 = *v7;
      v25 = v7 + 1;
      v11 = 4 * *v8;
      v24 = v8 + 1;
      v26 = *(_DWORD *)(v11 + v20);
      v12 = *(_DWORD *)(v11 + v22) + *(_DWORD *)(4 * v10 + v23);
      v27 = *(_DWORD *)(4 * v10 + v21);
      v13 = *v6;
      *result = *(_BYTE *)(v13 + v26 + v5);
      v12 >>= 16;
      result[1] = *(_BYTE *)(v13 + v12 + v5);
      result[2] = *(_BYTE *)(v27 + v13 + v5);
      v14 = v6 + 1;
      v15 = *v14;
      v16 = result + 3;
      *v16 = *(_BYTE *)(v15 + v26 + v5);
      LOBYTE(v10) = *(_BYTE *)(v15 + v12 + v5);
      v8 = v24;
      v16[1] = v10;
      v16[2] = *(_BYTE *)(v27 + v15 + v5);
      v7 = v25;
      v6 = v14 + 1;
      result = v16 + 3;
      --v30;
    }
    while ( v30 );
  }
  if ( (a1[23] & 1) != 0 )
  {
    v17 = *v6;
    v28 = 4 * *v7;
    v18 = 4 * *v8;
    v19 = *(_DWORD *)(v18 + v22) + *(_DWORD *)(v28 + v23);
    v29 = *(_DWORD *)(v28 + v21);
    *result = *(_BYTE *)(v17 + *(_DWORD *)(v18 + v20) + v5);
    result[1] = *(_BYTE *)(v17 + (v19 >> 16) + v5);
    result[2] = *(_BYTE *)(v29 + v17 + v5);
  }
  return result;
}

// sub_10032297 @ 0x10032297
char __cdecl sub_10032297(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ecx
  int v5; // eax
  unsigned __int8 **v6; // edx
  unsigned __int8 *v7; // edi
  int v8; // esi
  int v9; // ecx
  unsigned __int8 *v10; // edx
  unsigned __int8 *v11; // edi
  _BYTE *v12; // ecx
  _BYTE *v13; // esi
  int v14; // ebx
  int v15; // edx
  int v16; // edi
  int v17; // edx
  int v18; // edx
  _BYTE *v19; // ecx
  int v20; // edx
  int v21; // edx
  _BYTE *v22; // esi
  int v23; // ebx
  int v24; // edx
  int v25; // edi
  int v26; // edx
  int v27; // ecx
  int v29; // [esp+Ch] [ebp-20h]
  int v30; // [esp+10h] [ebp-1Ch]
  int v31; // [esp+14h] [ebp-18h]
  int v32; // [esp+18h] [ebp-14h]
  unsigned __int8 *v33; // [esp+1Ch] [ebp-10h]
  unsigned __int8 *v34; // [esp+20h] [ebp-Ch]
  int v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+28h] [ebp-4h]
  int v37; // [esp+28h] [ebp-4h]
  unsigned __int8 *v38; // [esp+38h] [ebp+Ch]
  unsigned __int8 *v39; // [esp+38h] [ebp+Ch]
  unsigned __int8 *v40; // [esp+3Ch] [ebp+10h]
  unsigned __int8 *v41; // [esp+3Ch] [ebp+10h]
  int v42; // [esp+40h] [ebp+14h]
  int v43; // [esp+40h] [ebp+14h]

  v4 = (_DWORD *)a1[103];
  v5 = a1[71];
  v32 = v4[4];
  v29 = v4[5];
  v30 = v4[6];
  v31 = v4[7];
  v6 = (unsigned __int8 **)(*a2 + 8 * a3);
  v7 = *v6;
  v8 = 4 * a3;
  v40 = v6[1];
  v9 = a2[2];
  v10 = *(unsigned __int8 **)(v8 + a2[1]);
  v38 = v7;
  v11 = *(unsigned __int8 **)(v8 + v9);
  v12 = *(_BYTE **)a4;
  v13 = *(_BYTE **)(a4 + 4);
  if ( a1[23] >> 1 )
  {
    v35 = a1[23] >> 1;
    do
    {
      v14 = *v10;
      v34 = v10 + 1;
      v15 = 4 * *v11;
      v33 = v11 + 1;
      v42 = *(_DWORD *)(v15 + v32);
      v16 = *(_DWORD *)(v15 + v30) + *(_DWORD *)(4 * v14 + v31);
      v36 = *(_DWORD *)(4 * v14 + v29);
      v17 = *v38;
      *v12 = *(_BYTE *)(v17 + v42 + v5);
      v16 >>= 16;
      v39 = v38 + 1;
      v12[1] = *(_BYTE *)(v17 + v16 + v5);
      v12[2] = *(_BYTE *)(v36 + v17 + v5);
      v18 = *v39;
      v19 = v12 + 3;
      *v19 = *(_BYTE *)(v18 + v42 + v5);
      v19[1] = *(_BYTE *)(v18 + v16 + v5);
      v19[2] = *(_BYTE *)(v36 + v18 + v5);
      v20 = *v40;
      v38 = v39 + 1;
      *v13 = *(_BYTE *)(v20 + v42 + v5);
      v13[1] = *(_BYTE *)(v20 + v16 + v5);
      v13[2] = *(_BYTE *)(v36 + v20 + v5);
      v12 = v19 + 3;
      v41 = v40 + 1;
      v21 = *v41;
      v22 = v13 + 3;
      v40 = v41 + 1;
      *v22 = *(_BYTE *)(v21 + v42 + v5);
      v22[1] = *(_BYTE *)(v21 + v16 + v5);
      v22[2] = *(_BYTE *)(v36 + v21 + v5);
      v11 = v33;
      v10 = v34;
      v13 = v22 + 3;
      --v35;
    }
    while ( v35 );
  }
  if ( (a1[23] & 1) != 0 )
  {
    v23 = *v10;
    v24 = 4 * *v11;
    v43 = *(_DWORD *)(v24 + v32);
    v25 = *(_DWORD *)(v24 + v30) + *(_DWORD *)(4 * v23 + v31);
    v37 = *(_DWORD *)(4 * v23 + v29);
    v26 = *v38;
    *v12 = *(_BYTE *)(v26 + v43 + v5);
    v25 >>= 16;
    v12[1] = *(_BYTE *)(v26 + v25 + v5);
    v12[2] = *(_BYTE *)(v37 + v26 + v5);
    v27 = *v40;
    *v13 = *(_BYTE *)(v27 + v43 + v5);
    v13[1] = *(_BYTE *)(v27 + v25 + v5);
    LOBYTE(v5) = *(_BYTE *)(v37 + v27 + v5);
    v13[2] = v5;
  }
  return v5;
}

// sub_1003247D @ 0x1003247D
int __cdecl sub_1003247D(int a1)
{
  int v1; // esi
  int v3; // [esp-4h] [ebp-Ch]

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 412) = v1;
  *(_BYTE *)(v1 + 8) = 0;
  *(_DWORD *)v1 = sub_10032055;
  *(_DWORD *)(v1 + 40) = *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100);
  if ( *(_DWORD *)(a1 + 272) == 2 )
  {
    v3 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = sub_1003206A;
    *(_DWORD *)(v1 + 12) = sub_10032297;
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v3);
  }
  else
  {
    *(_DWORD *)(v1 + 32) = 0;
    *(_DWORD *)(v1 + 4) = FUN_10032110;
    *(_DWORD *)(v1 + 12) = sub_10032141;
  }
  return sub_10031FA5(a1);
}

// FUN_100324f2 @ 0x100324F2
// [binja] int16_t* sub_100324f2(int16_t* arg1, int16_t* arg2, int32_t arg3)
_WORD *__cdecl sub_100324F2(int a1, _WORD *a2, int a3, int a4)
{
  _WORD *result; // eax
  int v5; // ebx
  int v6; // esi
  int i; // edi
  unsigned __int8 *v8; // ecx
  int v9; // [esp+14h] [ebp+8h]

  result = (_WORD *)a1;
  v5 = *(_DWORD *)(a1 + 92);
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  for ( i = 0; i < a4; ++i )
  {
    result = a2;
    v8 = *(unsigned __int8 **)&a2[2 * i];
    if ( v5 )
    {
      v9 = v5;
      do
      {
        result = (_WORD *)(*(_DWORD *)(v6 + 4 * (*v8 >> 3)) + 2 * ((v8[2] >> 3) + 32 * (v8[1] >> 2)));
        if ( !++*result )
          *result = -1;
        v8 += 3;
        --v9;
      }
      while ( v9 );
    }
  }
  return result;
}

// sub_1003255E @ 0x1003255E
int __usercall sub_1003255E@<eax>(int a1@<eax>, int *a2@<esi>)
{
  int v2; // ecx
  int v3; // edi
  int v4; // eax
  int v6; // ecx
  int v7; // eax
  int v9; // ebx
  int v10; // ecx
  int v11; // edx
  _WORD *v12; // eax
  int v14; // ecx
  int v15; // edx
  _WORD *v16; // eax
  _WORD *v18; // eax
  int v19; // edx
  _WORD *v20; // eax
  int v21; // edx
  int v22; // edx
  int v23; // eax
  int v24; // ecx
  int v25; // edi
  int v27; // [esp+8h] [ebp-28h]
  int v28; // [esp+Ch] [ebp-24h]
  int v29; // [esp+10h] [ebp-20h]
  _WORD *v30; // [esp+14h] [ebp-1Ch]
  _WORD *v31; // [esp+14h] [ebp-1Ch]
  int v32; // [esp+14h] [ebp-1Ch]
  int v33; // [esp+14h] [ebp-1Ch]
  _WORD *v34; // [esp+14h] [ebp-1Ch]
  int v35; // [esp+18h] [ebp-18h]
  int v36; // [esp+18h] [ebp-18h]
  int v37; // [esp+1Ch] [ebp-14h]
  int v38; // [esp+20h] [ebp-10h]
  int v39; // [esp+24h] [ebp-Ch]
  int v40; // [esp+28h] [ebp-8h]
  int v41; // [esp+28h] [ebp-8h]
  int v42; // [esp+28h] [ebp-8h]
  int v43; // [esp+28h] [ebp-8h]
  int v44; // [esp+28h] [ebp-8h]
  int v45; // [esp+2Ch] [ebp-4h]
  int v46; // [esp+2Ch] [ebp-4h]
  int v47; // [esp+2Ch] [ebp-4h]
  int v48; // [esp+2Ch] [ebp-4h]
  int v49; // [esp+2Ch] [ebp-4h]
  int v50; // [esp+2Ch] [ebp-4h]

  v2 = *a2;
  v29 = a2[3];
  v28 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v3 = a2[2];
  v39 = a2[4];
  v35 = *a2;
  v38 = a2[1];
  v27 = v3;
  v37 = a2[5];
  if ( *a2 < v38 )
  {
    while ( 1 )
    {
      v40 = a2[2];
      if ( v3 <= v29 )
        break;
LABEL_8:
      if ( ++v2 > v38 )
        goto LABEL_11;
    }
    v4 = *(_DWORD *)(v28 + 4 * v2) + 2 * (v39 + 32 * v3);
    while ( 1 )
    {
      v45 = a2[4];
      v30 = (_WORD *)v4;
      if ( v39 <= v37 )
        break;
LABEL_7:
      ++v40;
      v4 += 64;
      if ( v40 > v29 )
        goto LABEL_8;
    }
    while ( !*v30++ )
    {
      if ( ++v45 > v37 )
        goto LABEL_7;
    }
    v35 = v2;
    *a2 = v2;
LABEL_11:
    v6 = v38;
    if ( v38 > v35 )
    {
      while ( 1 )
      {
        v41 = v3;
        if ( v3 <= v29 )
          break;
LABEL_18:
        if ( --v6 < v35 )
          goto LABEL_21;
      }
      v7 = *(_DWORD *)(v28 + 4 * v6) + 2 * (v39 + 32 * v3);
      while ( 1 )
      {
        v46 = v39;
        v31 = (_WORD *)v7;
        if ( v39 <= v37 )
          break;
LABEL_17:
        ++v41;
        v7 += 64;
        if ( v41 > v29 )
          goto LABEL_18;
      }
      while ( !*v31++ )
      {
        if ( ++v46 > v37 )
          goto LABEL_17;
      }
      v38 = v6;
      a2[1] = v6;
    }
  }
LABEL_21:
  v9 = v29;
  if ( v3 < v29 )
  {
    v42 = v3;
    v10 = 2 * (v39 + 32 * v3);
    while ( 1 )
    {
      v11 = v35;
      if ( v35 <= v38 )
        break;
LABEL_29:
      ++v42;
      v10 += 64;
      if ( v42 > v29 )
        goto LABEL_32;
    }
    while ( 1 )
    {
      v12 = (_WORD *)(v10 + *(_DWORD *)(v28 + 4 * v11));
      v47 = v39;
      if ( v39 <= v37 )
        break;
LABEL_27:
      if ( ++v11 > v38 )
      {
        v3 = v27;
        goto LABEL_29;
      }
    }
    while ( !*v12++ )
    {
      if ( ++v47 > v37 )
        goto LABEL_27;
    }
    v3 = v42;
    v27 = v42;
    a2[2] = v42;
LABEL_32:
    v9 = v29;
    if ( v29 > v3 )
    {
      v43 = v29;
      v14 = 2 * (v39 + 32 * v29);
      while ( 1 )
      {
        v15 = v35;
        if ( v35 <= v38 )
          break;
LABEL_40:
        --v43;
        v14 -= 64;
        if ( v43 < v3 )
        {
          v9 = v29;
          goto LABEL_43;
        }
      }
      while ( 1 )
      {
        v16 = (_WORD *)(v14 + *(_DWORD *)(v28 + 4 * v15));
        v48 = v39;
        if ( v39 <= v37 )
          break;
LABEL_38:
        if ( ++v15 > v38 )
        {
          v3 = v27;
          goto LABEL_40;
        }
      }
      while ( !*v16++ )
      {
        if ( ++v48 > v37 )
          goto LABEL_38;
      }
      v3 = v27;
      v9 = v43;
      v29 = v43;
      a2[3] = v43;
    }
  }
LABEL_43:
  if ( v39 < v37 )
  {
    v49 = v39;
    while ( 1 )
    {
      v32 = v35;
      if ( v35 <= v38 )
        break;
LABEL_50:
      if ( ++v49 > v37 )
        goto LABEL_53;
    }
    while ( 1 )
    {
      v18 = (_WORD *)(2 * (v49 + 32 * v3) + *(_DWORD *)(v28 + 4 * v32));
      v19 = v3;
      if ( v3 <= v9 )
        break;
LABEL_49:
      if ( ++v32 > v38 )
        goto LABEL_50;
    }
    while ( !*v18 )
    {
      ++v19;
      v18 += 32;
      if ( v19 > v9 )
        goto LABEL_49;
    }
    v39 = v49;
    a2[4] = v49;
LABEL_53:
    if ( v37 > v39 )
    {
      v50 = v37;
      while ( 1 )
      {
        v33 = v35;
        if ( v35 <= v38 )
          break;
LABEL_60:
        if ( --v50 < v39 )
          goto LABEL_63;
      }
      while ( 1 )
      {
        v20 = (_WORD *)(2 * (v50 + 32 * v3) + *(_DWORD *)(v28 + 4 * v33));
        v21 = v3;
        if ( v3 <= v9 )
          break;
LABEL_59:
        if ( ++v33 > v38 )
          goto LABEL_60;
      }
      while ( !*v20 )
      {
        ++v21;
        v20 += 32;
        if ( v21 > v9 )
          goto LABEL_59;
      }
      v37 = v50;
      a2[5] = v50;
    }
  }
LABEL_63:
  v22 = v9 - v3;
  v44 = 0;
  v23 = v35;
  a2[6] = 16 * (v38 - v35) * 16 * (v38 - v35) + 12 * (v9 - v3) * 12 * (v9 - v3) + 8 * (v37 - v39) * 8 * (v37 - v39);
  while ( v23 <= v38 )
  {
    if ( v27 <= v29 )
    {
      v24 = *(_DWORD *)(v28 + 4 * v23) + 2 * (v39 + 32 * v27);
      v25 = v22 + 1;
      do
      {
        v34 = (_WORD *)v24;
        if ( v39 <= v37 )
        {
          v36 = v37 - v39 + 1;
          do
          {
            if ( *v34 )
              ++v44;
            ++v34;
            --v36;
          }
          while ( v36 );
        }
        v24 += 64;
        --v25;
      }
      while ( v25 );
    }
    ++v23;
  }
  a2[7] = v44;
  return v44;
}

// sub_10032896 @ 0x10032896
int __cdecl sub_10032896(int a1, int a2, int a3, int a4)
{
  int result; // eax
  int v5; // ecx
  _DWORD *v6; // edi
  int *v7; // esi
  int v8; // ebx
  int *v9; // ecx
  int *v10; // ecx
  int v11; // eax
  int v12; // ebx
  int v13; // ebx
  int v14; // eax
  int v15; // eax
  int v16; // eax
  int v17; // [esp+0h] [ebp-8h]
  int v18; // [esp+0h] [ebp-8h]
  int v19; // [esp+4h] [ebp-4h]

  result = a3;
  v5 = a2;
  if ( a3 < a4 )
  {
    v19 = 2 * a3;
    v6 = (_DWORD *)(32 * a3 + a2 + 12);
    while ( 1 )
    {
      v7 = 0;
      v8 = 0;
      if ( v19 > a4 )
      {
        if ( v19 > 0 )
        {
          v10 = (int *)(v5 + 24);
          v18 = result;
          do
          {
            if ( *v10 > v8 )
            {
              v7 = v10 - 6;
              v8 = *v10;
            }
            v10 += 8;
            --v18;
          }
          while ( v18 );
        }
      }
      else if ( v19 > 0 )
      {
        v9 = (int *)(v5 + 28);
        v17 = result;
        do
        {
          if ( *v9 > v8 && *(v9 - 1) > 0 )
          {
            v7 = v9 - 7;
            v8 = *v9;
          }
          v9 += 8;
          --v17;
        }
        while ( v17 );
      }
      if ( !v7 )
        break;
      *(v6 - 2) = v7[1];
      *v6 = v7[3];
      v6[2] = v7[5];
      *(v6 - 3) = *v7;
      *(v6 - 1) = v7[2];
      v6[1] = v7[4];
      v11 = 12 * (v7[3] - v7[2]);
      v12 = 1;
      if ( 16 * (v7[1] - *v7) > v11 )
      {
        v11 = 16 * (v7[1] - *v7);
        v12 = 0;
      }
      if ( 8 * (v7[5] - v7[4]) > v11 )
        v12 = 2;
      if ( v12 )
      {
        v13 = v12 - 1;
        if ( v13 )
        {
          if ( v13 == 1 )
          {
            v14 = (v7[4] + v7[5]) / 2;
            v7[5] = v14;
            v6[1] = v14 + 1;
          }
        }
        else
        {
          v15 = (v7[2] + v7[3]) / 2;
          v7[3] = v15;
          *(v6 - 1) = v15 + 1;
        }
      }
      else
      {
        v16 = (*v7 + v7[1]) / 2;
        v7[1] = v16;
        *(v6 - 3) = v16 + 1;
      }
      sub_1003255E(a1, v7);
      sub_1003255E(a1, v6 - 3);
      v19 += 2;
      result = a3 + 1;
      v6 += 8;
      if ( ++a3 >= a4 )
        break;
      v5 = a2;
    }
  }
  return result;
}

// sub_100329E9 @ 0x100329E9
int __usercall sub_100329E9@<eax>(int *a1@<eax>, int a2@<esi>, int a3)
{
  int v3; // ebx
  int v4; // ecx
  int v5; // edx
  int v6; // eax
  int v7; // edi
  int v8; // edi
  int v9; // edi
  int result; // eax
  int v11; // [esp+Ch] [ebp-3Ch]
  int v12; // [esp+10h] [ebp-38h]
  int v13; // [esp+14h] [ebp-34h]
  int v14; // [esp+20h] [ebp-28h]
  int v15; // [esp+24h] [ebp-24h]
  int v16; // [esp+28h] [ebp-20h]
  int v17; // [esp+2Ch] [ebp-1Ch]
  int v18; // [esp+30h] [ebp-18h]
  int v19; // [esp+34h] [ebp-14h]
  int v20; // [esp+38h] [ebp-10h]
  int v21; // [esp+3Ch] [ebp-Ch]
  int v22; // [esp+40h] [ebp-8h]
  unsigned __int16 *v23; // [esp+44h] [ebp-4h]

  v18 = 0;
  v17 = 0;
  v16 = 0;
  v15 = 0;
  v3 = a1[5];
  v11 = a1[1];
  v4 = a1[2];
  v14 = a1[3];
  v5 = a1[4];
  v6 = *a1;
  v7 = a3;
  if ( v6 <= v11 )
  {
    v19 = 8 * v6 + 4;
    do
    {
      if ( v4 <= v14 )
      {
        v20 = 4 * v4 + 2;
        v21 = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)(a2 + 420) + 24) + 4 * v6) + 2 * (v5 + 32 * v4);
        v8 = v14 - v4 + 1;
        v12 = v8;
        do
        {
          v23 = (unsigned __int16 *)v21;
          if ( v5 <= v3 )
          {
            v22 = 8 * v5 + 4;
            v13 = v3 - v5 + 1;
            do
            {
              v9 = *v23++;
              if ( v9 )
              {
                v18 += v9;
                v16 += v9 * v20;
                v17 += v9 * v19;
                v15 += v9 * v22;
              }
              v22 += 8;
              --v13;
            }
            while ( v13 );
            v8 = v12;
          }
          v21 += 64;
          v20 += 4;
          v12 = --v8;
        }
        while ( v8 );
        v7 = a3;
      }
      v19 += 8;
      ++v6;
    }
    while ( v6 <= v11 );
  }
  *(_BYTE *)(v7 + **(_DWORD **)(a2 + 116)) = ((v18 >> 1) + v17) / v18;
  *(_BYTE *)(v7 + *(_DWORD *)(*(_DWORD *)(a2 + 116) + 4)) = ((v18 >> 1) + v16) / v18;
  result = ((v18 >> 1) + v15) / v18;
  *(_BYTE *)(v7 + *(_DWORD *)(*(_DWORD *)(a2 + 116) + 8)) = result;
  return result;
}

// sub_10032B21 @ 0x10032B21
int __usercall sub_10032B21@<eax>(int a1@<edi>, int a2)
{
  int *v2; // esi
  int v3; // eax
  int v4; // ebx
  int v5; // eax
  int *v7; // [esp+8h] [ebp-4h]
  int v8; // [esp+14h] [ebp+8h]

  v2 = (int *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 32 * a2);
  v2[1] = 31;
  v2[5] = 31;
  *v2 = 0;
  v2[2] = 0;
  v2[3] = 63;
  v2[4] = 0;
  sub_1003255E(a1, v2);
  v3 = sub_10032896(a1, (int)v2, 1, a2);
  v8 = 0;
  v4 = v3;
  if ( v3 > 0 )
  {
    v7 = v2;
    do
    {
      sub_100329E9(v7, a1, v8++);
      v7 += 8;
    }
    while ( v8 < v4 );
  }
  v5 = *(_DWORD *)a1;
  *(_DWORD *)(a1 + 112) = v4;
  *(_DWORD *)(v5 + 20) = 95;
  *(_DWORD *)(*(_DWORD *)a1 + 24) = v4;
  return (*(int (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
}

// sub_10032BAE @ 0x10032BAE
int __usercall sub_10032BAE@<eax>(int a1@<eax>, int a2@<edi>, int a3, int a4, int a5)
{
  int v5; // edx
  int v6; // ebx
  int *v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // eax
  int v11; // ecx
  int v12; // esi
  int v13; // eax
  int v14; // ecx
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // edx
  int v20; // eax
  int v21; // edx
  int v22; // eax
  int v23; // ecx
  bool v24; // cc
  int v25; // ecx
  int result; // eax
  _DWORD v27[256]; // [esp+8h] [ebp-428h]
  int v28; // [esp+408h] [ebp-28h]
  int v29; // [esp+40Ch] [ebp-24h]
  int v30; // [esp+410h] [ebp-20h]
  int v31; // [esp+414h] [ebp-1Ch]
  int v32; // [esp+418h] [ebp-18h]
  int v33; // [esp+41Ch] [ebp-14h]
  int v34; // [esp+420h] [ebp-10h]
  int v35; // [esp+424h] [ebp-Ch]
  int v36; // [esp+428h] [ebp-8h]
  int v37; // [esp+42Ch] [ebp-4h]

  v5 = a3;
  v37 = 0;
  v32 = (2 * a3 + 24) >> 1;
  v6 = a4;
  v30 = (2 * a2 + 28) >> 1;
  v35 = *(_DWORD *)(a1 + 112);
  v29 = (2 * a4 + 24) >> 1;
  v36 = 0x7FFFFFFF;
  if ( v35 > 0 )
  {
    v7 = *(int **)(a1 + 116);
    v28 = *v7;
    v8 = v7[1];
    v9 = v7[2];
    v34 = v8;
    v33 = v9;
    do
    {
      v10 = *(unsigned __int8 *)(v28 + v37);
      v11 = v5 + 24;
      if ( v10 >= v5 )
      {
        if ( v10 > v11 )
        {
          v12 = 2 * (v10 - v11) * 2 * (v10 - v11);
LABEL_7:
          v13 = v10 - v5;
          goto LABEL_8;
        }
        v12 = 0;
        if ( v10 > v32 )
          goto LABEL_7;
      }
      else
      {
        v12 = 2 * (v10 - v5) * 2 * (v10 - v5);
      }
      v13 = v10 - v11;
LABEL_8:
      v14 = 2 * v13 * 2 * v13;
      v15 = *(unsigned __int8 *)(v34 + v37);
      if ( v15 < a2 )
      {
        v12 += 3 * (v15 - a2) * 3 * (v15 - a2);
        v6 = a4;
        v16 = v15 - (a2 + 28);
        goto LABEL_15;
      }
      if ( v15 > a2 + 28 )
      {
        v12 += 3 * (v15 - (a2 + 28)) * 3 * (v15 - (a2 + 28));
        v6 = a4;
LABEL_14:
        v16 = v15 - a2;
        goto LABEL_15;
      }
      if ( v15 > v30 )
        goto LABEL_14;
      v16 = v15 - (a2 + 28);
LABEL_15:
      v17 = 3 * v16 * 3 * v16 + v14;
      v18 = *(unsigned __int8 *)(v33 + v37);
      if ( v18 < v6 )
      {
        v12 += (v18 - v6) * (v18 - v6);
        v6 = a4;
        v19 = a4 + 24;
LABEL_31:
        v20 = v18 - v19;
        goto LABEL_22;
      }
      v19 = v6 + 24;
      v31 = v6 + 24;
      if ( v18 <= v6 + 24 )
      {
        if ( v18 <= v29 )
          goto LABEL_31;
      }
      else
      {
        v12 += (v18 - v31) * (v18 - v31);
        v6 = a4;
      }
      v20 = v18 - v6;
LABEL_22:
      v21 = v20 * v20;
      v22 = v37;
      v23 = v21 + v17;
      v24 = v23 < v36;
      v5 = a3;
      v27[v37] = v12;
      if ( v24 )
        v36 = v23;
      v37 = v22 + 1;
    }
    while ( v22 + 1 < v35 );
  }
  v25 = 0;
  for ( result = 0; v25 < v35; ++v25 )
  {
    if ( v27[v25] <= v36 )
    {
      *(_BYTE *)(result + a5) = v25;
      ++result;
    }
  }
  return result;
}

// sub_10032D2E @ 0x10032D2E
int __cdecl sub_10032D2E(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7)
{
  int result; // eax
  int v8; // ebx
  _DWORD *v9; // edx
  int v10; // ecx
  int v11; // esi
  int v12; // edx
  int v13; // eax
  int v14; // esi
  int v15; // edx
  int v16; // ecx
  _DWORD v17[128]; // [esp+4h] [ebp-228h] BYREF
  int v18; // [esp+204h] [ebp-28h]
  int v19; // [esp+208h] [ebp-24h]
  int v20; // [esp+20Ch] [ebp-20h]
  _BYTE *v21; // [esp+210h] [ebp-1Ch]
  int v22; // [esp+214h] [ebp-18h]
  int v23; // [esp+218h] [ebp-14h]
  int *v24; // [esp+21Ch] [ebp-10h]
  int v25; // [esp+220h] [ebp-Ch]
  int v26; // [esp+224h] [ebp-8h]
  int v27; // [esp+228h] [ebp-4h]

  v26 = 0;
  result = 0x7FFFFFFF;
  memset32(v17, 0x7FFFFFFF, 0x80u);
  if ( a5 > 0 )
  {
    do
    {
      v8 = *(unsigned __int8 *)(v26 + a6);
      v9 = *(_DWORD **)(a1 + 116);
      v10 = a2 - *(unsigned __int8 *)(v8 + *v9);
      v11 = 3 * (a3 - *(unsigned __int8 *)(v9[1] + v8));
      v12 = a4 - *(unsigned __int8 *)(v9[2] + v8);
      v10 *= 2;
      v13 = v10 * v10 + v11 * v11 + v12 * v12;
      v14 = 8 * (3 * v11 + 18);
      v15 = 16 * (v12 + 4);
      v24 = v17;
      v21 = a7;
      v27 = 32 * (v10 + 8);
      v19 = 4;
      do
      {
        v22 = v13;
        v25 = v14;
        v18 = 8;
        do
        {
          v16 = v22;
          v23 = v15;
          v20 = 4;
          do
          {
            if ( v16 < *v24 )
            {
              *v24 = v16;
              *v21 = v8;
            }
            v16 += v23;
            v23 += 128;
            ++v24;
            ++v21;
            --v20;
          }
          while ( v20 );
          v22 += v25;
          v25 += 288;
          --v18;
        }
        while ( v18 );
        v13 += v27;
        v27 += 512;
        --v19;
      }
      while ( v19 );
      result = ++v26;
    }
    while ( v26 < a5 );
  }
  return result;
}

// sub_10032E48 @ 0x10032E48
_WORD *__usercall sub_10032E48@<eax>(int a1@<eax>, int a2, int a3, int a4)
{
  int v4; // esi
  int v5; // eax
  unsigned __int8 *v6; // edx
  _DWORD *v7; // ecx
  int v8; // ebx
  _WORD *result; // eax
  int v10; // edi
  _BYTE v11[256]; // [esp+Ch] [ebp-188h] BYREF
  _BYTE v12[128]; // [esp+10Ch] [ebp-88h] BYREF
  int v13; // [esp+18Ch] [ebp-8h]
  int v14; // [esp+190h] [ebp-4h]
  int v15; // [esp+19Ch] [ebp+8h]
  int v16; // [esp+1A0h] [ebp+Ch]
  int v17; // [esp+1A0h] [ebp+Ch]
  int v18; // [esp+1A4h] [ebp+10h]
  int v19; // [esp+1A4h] [ebp+10h]

  v18 = a4 >> 2;
  v16 = a3 >> 2;
  v14 = *(_DWORD *)(*(_DWORD *)(a2 + 420) + 24);
  v4 = a1 >> 3;
  v13 = 32 * v18 + 4;
  v5 = sub_10032BAE(a2, 32 * (a1 >> 3) + 2, 32 * v16 + 4, v13, (int)v11);
  sub_10032D2E(a2, 32 * v16 + 4, 32 * v4 + 2, v13, v5, (int)v11, v12);
  v6 = v12;
  v15 = 2 * (4 * v18 + (v4 << 8));
  v7 = (_DWORD *)(v14 + 16 * v16);
  v17 = 4;
  do
  {
    v8 = v15;
    v19 = 8;
    do
    {
      result = (_WORD *)(v8 + *v7);
      v10 = 4;
      do
      {
        *result++ = *v6++ + 1;
        --v10;
      }
      while ( v10 );
      v8 += 64;
      --v19;
    }
    while ( v19 );
    ++v7;
    --v17;
  }
  while ( v17 );
  return result;
}

// sub_10032F18 @ 0x10032F18
int __cdecl sub_10032F18(int a1, int a2, _DWORD *a3, int a4)
{
  int result; // eax
  int v5; // ecx
  unsigned __int8 *v6; // esi
  int v7; // ecx
  unsigned __int8 *v8; // esi
  int v9; // eax
  int v10; // edx
  _WORD *v11; // edi
  _BYTE *v12; // ecx
  bool v13; // zf
  int v14; // [esp+4h] [ebp-14h]
  int v15; // [esp+8h] [ebp-10h]
  int v16; // [esp+Ch] [ebp-Ch]
  int v17; // [esp+10h] [ebp-8h]
  _DWORD *v18; // [esp+14h] [ebp-4h]
  _BYTE *v19; // [esp+2Ch] [ebp+14h]

  result = a1;
  v15 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v5 = *(_DWORD *)(a1 + 92);
  v14 = v5;
  if ( a4 > 0 )
  {
    result = a2 - (_DWORD)a3;
    v18 = a3;
    v16 = a4;
    do
    {
      v6 = *(unsigned __int8 **)((char *)v18 + result);
      v19 = (_BYTE *)*v18;
      if ( v5 )
      {
        v17 = v5;
        do
        {
          v7 = *v6 >> 3;
          v8 = v6 + 1;
          v9 = *v8++ >> 2;
          v10 = *v8 >> 3;
          v11 = (_WORD *)(*(_DWORD *)(v15 + 4 * v7) + 2 * (v10 + 32 * v9));
          v6 = v8 + 1;
          if ( !*v11 )
            sub_10032E48(v9, a1, v7, v10);
          v12 = v19++;
          v13 = v17-- == 1;
          *v12 = *(_BYTE *)v11 - 1;
        }
        while ( !v13 );
        v5 = v14;
        result = a2 - (_DWORD)a3;
      }
      ++v18;
      --v16;
    }
    while ( v16 );
  }
  return result;
}

// sub_10032FC1 @ 0x10032FC1
__int16 __cdecl sub_10032FC1(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ecx
  int v5; // edx
  int *v6; // eax
  int v7; // esi
  __int16 result; // ax
  int v9; // esi
  unsigned __int8 *v10; // eax
  _BYTE *v11; // esi
  _WORD *v12; // esi
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ebx
  _WORD *v17; // eax
  int v18; // eax
  int v19; // edi
  int v20; // ebx
  int v21; // eax
  int v22; // ecx
  int v23; // edi
  int v24; // ecx
  int v25; // ebx
  __int16 v26; // dx
  int v27; // ecx
  int v28; // eax
  __int16 v29; // dx
  bool v30; // zf
  int v31; // [esp+4h] [ebp-68h]
  int v32; // [esp+Ch] [ebp-60h]
  int v33; // [esp+10h] [ebp-5Ch]
  int v34; // [esp+14h] [ebp-58h]
  _WORD *v35; // [esp+18h] [ebp-54h]
  int v36; // [esp+20h] [ebp-4Ch]
  int v37; // [esp+28h] [ebp-44h]
  int v38; // [esp+2Ch] [ebp-40h]
  int v39; // [esp+30h] [ebp-3Ch]
  int v40; // [esp+34h] [ebp-38h]
  __int16 v41; // [esp+38h] [ebp-34h]
  __int16 v42; // [esp+3Ch] [ebp-30h]
  __int16 v43; // [esp+40h] [ebp-2Ch]
  int v44; // [esp+44h] [ebp-28h]
  _DWORD *v45; // [esp+48h] [ebp-24h]
  __int16 v46; // [esp+4Ch] [ebp-20h]
  __int16 v47; // [esp+50h] [ebp-1Ch]
  __int16 v48; // [esp+54h] [ebp-18h]
  int v49; // [esp+58h] [ebp-14h]
  _BYTE *v50; // [esp+5Ch] [ebp-10h]
  int v51; // [esp+64h] [ebp-8h]
  int v52; // [esp+68h] [ebp-4h]
  int v53; // [esp+80h] [ebp+14h]
  int v54; // [esp+80h] [ebp+14h]
  __int16 v55; // [esp+80h] [ebp+14h]
  __int16 v56; // [esp+80h] [ebp+14h]
  __int16 v57; // [esp+80h] [ebp+14h]

  v4 = a1[105];
  v49 = a1[71];
  v36 = *(_DWORD *)(v4 + 24);
  v5 = a1[23];
  v6 = (int *)a1[29];
  v44 = *(_DWORD *)(v4 + 40);
  v34 = *v6;
  v7 = v6[1];
  v32 = v6[2];
  result = a4;
  v31 = v4;
  v38 = v5;
  v33 = v7;
  if ( a4 > 0 )
  {
    v9 = a2 - (_DWORD)a3;
    v45 = a3;
    v37 = a4;
    while ( 1 )
    {
      v10 = *(unsigned __int8 **)((char *)v45 + v9);
      v11 = (_BYTE *)*v45;
      v51 = (int)v10;
      v50 = (_BYTE *)*v45;
      if ( *(_BYTE *)(v4 + 36) )
      {
        v40 = -1;
        *(_BYTE *)(v4 + 36) = 0;
        v51 = (int)&v10[2 * v5 - 3 + v5];
        v50 = &v11[v5 - 1];
        v12 = (_WORD *)(*(_DWORD *)(v4 + 32) + 2 * (3 * v5 + 3));
        v10 = (unsigned __int8 *)v51;
        v52 = -3;
      }
      else
      {
        v12 = *(_WORD **)(v4 + 32);
        v40 = 1;
        v52 = 3;
        *(_BYTE *)(v4 + 36) = 1;
      }
      v5 = v38;
      v13 = 0;
      v46 = 0;
      v47 = 0;
      v48 = 0;
      v14 = 0;
      v53 = 0;
      v41 = 0;
      v42 = 0;
      v43 = 0;
      if ( v38 )
      {
        v39 = v38;
        while ( 1 )
        {
          v15 = *(unsigned __int8 *)(*v10 + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52] + v14 + 8) >> 4)) + v49);
          v16 = *(unsigned __int8 *)(v10[1] + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52 + 1] + v13 + 8) >> 4)) + v49);
          v54 = *(unsigned __int8 *)(v10[2] + *(_DWORD *)(v44 + 4 * (((__int16)v12[v52 + 2] + v53 + 8) >> 4)) + v49);
          v17 = (_WORD *)(*(_DWORD *)(v36 + 4 * (v15 >> 3)) + 2 * ((v54 >> 3) + 32 * (v16 >> 2)));
          v35 = v17;
          if ( !*v17 )
          {
            sub_10032E48(v16 >> 2, (int)a1, v15 >> 3, v54 >> 3);
            v17 = v35;
          }
          v18 = (unsigned __int16)*v17 - 1;
          *v50 = v18;
          v19 = v15 - *(unsigned __int8 *)(v18 + v34);
          v20 = v16 - *(unsigned __int8 *)(v18 + v33);
          v21 = v54 - *(unsigned __int8 *)(v18 + v32);
          v55 = v19;
          v22 = 2 * v19;
          v19 *= 3;
          *v12 = v19 + v48;
          v23 = v22 + v19;
          v48 = v23 + v43;
          v43 = v55;
          v14 = v22 + v23;
          v56 = v20;
          v24 = 2 * v20;
          v20 *= 3;
          v12[1] = v20 + v47;
          v25 = v24 + v20;
          v47 = v25 + v42;
          v26 = v56;
          v57 = v21;
          v42 = v26;
          v13 = v24 + v25;
          v27 = 2 * v21;
          v21 *= 3;
          v12[2] = v21 + v46;
          v12 += v52;
          v28 = v27 + v21;
          v46 = v28 + v41;
          v29 = v57;
          v53 = v27 + v28;
          v51 += v52;
          v50 += v40;
          v30 = v39-- == 1;
          v41 = v29;
          if ( v30 )
            break;
          v10 = (unsigned __int8 *)v51;
        }
        v4 = v31;
        v5 = v38;
      }
      ++v45;
      v30 = v37-- == 1;
      *v12 = v48;
      v12[1] = v47;
      result = v46;
      v12[2] = v46;
      if ( v30 )
        break;
      v9 = a2 - (_DWORD)a3;
    }
  }
  return result;
}

// sub_1003322F @ 0x1003322F
int __usercall sub_1003322F@<eax>(int a1@<eax>)
{
  int v1; // esi
  int result; // eax
  int v3; // edx
  int v4; // ecx
  int v5; // edi
  _DWORD *v6; // esi
  _DWORD *v7; // esi
  _DWORD *v8; // esi

  v1 = *(_DWORD *)(a1 + 420);
  result = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020;
  *(_DWORD *)(v1 + 40) = result;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = (_DWORD *)result;
  do
  {
    *(_DWORD *)(result + 4 * v4) = v3;
    *v6 = v5;
    ++v4;
    --v6;
    ++v3;
    --v5;
  }
  while ( v4 < 16 );
  if ( v4 < 48 )
  {
    v7 = (_DWORD *)(result - 4 * v4);
    do
    {
      *(_DWORD *)(result + 4 * v4) = v3;
      *v7 = -v3;
      ++v4;
      --v7;
      v3 += (v4 & 1) == 0;
    }
    while ( v4 < 48 );
  }
  if ( v4 <= 255 )
  {
    v8 = (_DWORD *)(result - 4 * v4);
    do
    {
      *(_DWORD *)(result + 4 * v4) = v3;
      *v8 = -v3;
      ++v4;
      --v8;
    }
    while ( v4 <= 255 );
  }
  return result;
}

// sub_100332BF @ 0x100332BF
int __cdecl sub_100332BF(int a1)
{
  int v1; // esi
  int result; // eax

  v1 = *(_DWORD *)(a1 + 420);
  *(_DWORD *)(a1 + 116) = *(_DWORD *)(v1 + 16);
  result = sub_10032B21(a1, *(_DWORD *)(v1 + 20));
  *(_BYTE *)(v1 + 28) = 1;
  return result;
}

// sub_100332E1 @ 0x100332E1
int __cdecl sub_100332E1(_DWORD *a1, char a2)
{
  bool v3; // zf
  int v4; // edi
  int result; // eax
  int v6; // ebx
  unsigned int v7; // ebx
  int i; // esi
  int v9; // [esp+10h] [ebp+8h]

  v3 = a1[19] == 0;
  v4 = a1[105];
  result = *(_DWORD *)(v4 + 24);
  v9 = result;
  if ( !v3 )
    a1[19] = 2;
  if ( a2 )
  {
    *(_DWORD *)(v4 + 4) = FUN_100324f2;
    *(_DWORD *)(v4 + 8) = sub_100332BF;
    *(_BYTE *)(v4 + 28) = 1;
  }
  else
  {
    if ( a1[19] == 2 )
      *(_DWORD *)(v4 + 4) = sub_10032FC1;
    else
      *(_DWORD *)(v4 + 4) = sub_10032F18;
    *(_DWORD *)(v4 + 8) = nullsub_2;
    v6 = a1[28];
    if ( v6 < 1 )
    {
      *(_DWORD *)(*a1 + 20) = 55;
      *(_DWORD *)(*a1 + 24) = 1;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    result = 256;
    if ( v6 > 256 )
    {
      *(_DWORD *)(*a1 + 20) = 56;
      *(_DWORD *)(*a1 + 24) = 256;
      result = (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( a1[19] == 2 )
    {
      v7 = 6 * (a1[23] + 2);
      if ( !*(_DWORD *)(v4 + 32) )
        *(_DWORD *)(v4 + 32) = (*(int (__cdecl **)(_DWORD *, int, unsigned int))(a1[1] + 4))(a1, 1, v7);
      result = memzero(*(void **)(v4 + 32), v7);
      if ( !*(_DWORD *)(v4 + 40) )
        result = sub_1003322F((int)a1);
      *(_BYTE *)(v4 + 36) = 0;
    }
  }
  if ( *(_BYTE *)(v4 + 28) )
  {
    for ( i = 0; i < 32; ++i )
      result = memzero(*(void **)(v9 + 4 * i), 0x1000u);
    *(_BYTE *)(v4 + 28) = 0;
  }
  return result;
}

// sub_100333E3 @ 0x100333E3
int __cdecl sub_100333E3(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 420);
  *(_BYTE *)(result + 28) = 1;
  return result;
}

// sub_100333F2 @ 0x100333F2
int __cdecl sub_100333F2(int a1)
{
  int v1; // edi
  int v2; // ebp
  int result; // eax
  int v4; // ebp

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 420) = v1;
  v2 = 0;
  *(_DWORD *)v1 = sub_100332E1;
  *(_DWORD *)(v1 + 12) = sub_100333E3;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v1 + 24) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  do
  {
    result = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 4096);
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + v2) = result;
    v2 += 4;
  }
  while ( v2 < 128 );
  *(_BYTE *)(v1 + 28) = 1;
  if ( *(_BYTE *)(a1 + 90) )
  {
    v4 = *(_DWORD *)(a1 + 84);
    if ( v4 < 8 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 55;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( v4 > 256 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    result = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, v4, 3);
    *(_DWORD *)(v1 + 16) = result;
    *(_DWORD *)(v1 + 20) = v4;
  }
  else
  {
    *(_DWORD *)(v1 + 16) = 0;
  }
  if ( *(_DWORD *)(a1 + 76) )
    *(_DWORD *)(a1 + 76) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                             a1,
                             1,
                             6 * (*(_DWORD *)(a1 + 92) + 2));
    return sub_1003322F(a1);
  }
  return result;
}

// sub_10033505 @ 0x10033505
int __cdecl sub_10033505(_DWORD *a1, char *a2)
{
  _DWORD *v2; // esi
  signed int v3; // ebx
  int v4; // edi
  int v5; // eax
  int v6; // ecx
  int v7; // edi
  signed int v8; // edx
  int v9; // eax
  int *v10; // ecx
  int v11; // edi
  int v12; // eax
  int v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+10h] [ebp-Ch]
  signed int v16; // [esp+14h] [ebp-8h]
  char v17; // [esp+1Bh] [ebp-1h]

  v2 = a1;
  v3 = a1[25];
  v14 = a1[21];
  v4 = 1;
  do
  {
    v5 = ++v4;
    if ( v3 > 1 )
    {
      v6 = v3 - 1;
      do
      {
        v5 *= v4;
        --v6;
      }
      while ( v6 );
    }
  }
  while ( v5 <= a1[21] );
  v7 = v4 - 1;
  if ( v7 < 2 )
  {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = v5;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v15 = 1;
  if ( v3 > 0 )
  {
    v8 = v3;
    memset32(a2, v7, v3);
    do
    {
      --v8;
      v15 *= v7;
    }
    while ( v8 );
  }
  while ( 1 )
  {
    v17 = 0;
    v16 = 0;
    if ( v3 <= 0 )
      break;
    while ( 1 )
    {
      v9 = v16;
      if ( v2[10] == 2 )
        v9 = dword_1004F6D0[v16];
      v10 = (int *)&a2[4 * v9];
      v11 = *v10 + 1;
      v12 = v11 * (v15 / *v10);
      if ( v12 > v14 )
        break;
      ++v16;
      *v10 = v11;
      v15 = v12;
      v17 = 1;
      if ( v16 >= v3 )
        break;
      v2 = a1;
    }
    if ( !v17 )
      break;
    v2 = a1;
  }
  return v15;
}

// sub_100335D0 @ 0x100335D0
int __usercall sub_100335D0@<eax>(_DWORD *a1@<esi>)
{
  int v1; // ebx
  int v2; // eax
  int *v3; // eax
  int result; // eax
  int v5; // ecx
  int v6; // edi
  int i; // edx
  int v8; // eax
  int v9; // [esp+8h] [ebp-34h]
  int v10; // [esp+14h] [ebp-28h]
  int v11; // [esp+18h] [ebp-24h]
  int v12; // [esp+1Ch] [ebp-20h]
  _DWORD *v13; // [esp+20h] [ebp-1Ch]
  int *v14; // [esp+24h] [ebp-18h]
  int v15; // [esp+28h] [ebp-14h]
  int v16; // [esp+2Ch] [ebp-10h]
  int v17; // [esp+34h] [ebp-8h]
  int j; // [esp+38h] [ebp-4h]

  v10 = a1[105];
  v1 = sub_10033505(a1, (char *)(v10 + 32));
  v2 = *a1;
  if ( a1[25] == 3 )
  {
    v3 = (int *)(v2 + 24);
    *v3 = v1;
    v3[1] = *(_DWORD *)(v10 + 32);
    v3[2] = *(_DWORD *)(v10 + 36);
    v3[3] = *(_DWORD *)(v10 + 40);
    *(_DWORD *)(*a1 + 20) = 93;
  }
  else
  {
    *(_DWORD *)(v2 + 20) = 94;
    *(_DWORD *)(*a1 + 24) = v1;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  result = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v1, a1[25]);
  v12 = 0;
  v9 = result;
  v15 = v1;
  if ( (int)a1[25] > 0 )
  {
    v13 = (_DWORD *)result;
    v14 = (int *)(v10 + 32);
    do
    {
      v5 = *v14;
      v6 = 0;
      v17 = v15 / *v14;
      if ( *v14 > 0 )
      {
        v16 = 0;
        v11 = *v14;
        do
        {
          for ( i = v16; i < v1; i += v15 )
          {
            for ( j = 0; j < v17; *(_BYTE *)(v8 + i) = (v6 + (v5 - 1) / 2) / (v5 - 1) )
            {
              v8 = j + *v13;
              ++j;
            }
          }
          v16 += v17;
          v6 += 255;
          --v11;
        }
        while ( v11 );
      }
      ++v12;
      ++v14;
      ++v13;
      v15 = v17;
    }
    while ( v12 < a1[25] );
    result = v9;
  }
  *(_DWORD *)(v10 + 20) = v1;
  *(_DWORD *)(v10 + 16) = result;
  return result;
}

// sub_100336FD @ 0x100336FD
int __cdecl sub_100336FD(_DWORD *a1)
{
  int v1; // esi
  int v2; // ebx
  int result; // eax
  int v4; // ecx
  _BYTE *v5; // edi
  int v6; // edx
  int i; // eax
  int v8; // ebx
  int v9; // edx
  _BYTE *v10; // ecx
  int v11; // [esp+10h] [ebp-18h]
  int v12; // [esp+14h] [ebp-14h]
  int *v13; // [esp+18h] [ebp-10h]
  int v14; // [esp+1Ch] [ebp-Ch]
  int v15; // [esp+20h] [ebp-8h]
  int v16; // [esp+24h] [ebp-4h]

  v1 = a1[105];
  if ( a1[19] == 1 )
  {
    v14 = 510;
    *(_BYTE *)(v1 + 28) = 1;
  }
  else
  {
    v14 = 0;
    *(_BYTE *)(v1 + 28) = 0;
  }
  v2 = 0;
  *(_DWORD *)(v1 + 24) = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v14 + 256, a1[25]);
  result = *(_DWORD *)(v1 + 20);
  v11 = 0;
  if ( (int)a1[25] > 0 )
  {
    v13 = (int *)(v1 + 32);
    while ( 1 )
    {
      v4 = *v13;
      v12 = result / *v13;
      if ( v14 )
        *(_DWORD *)(*(_DWORD *)(v1 + 24) + 4 * v2) += 255;
      v5 = *(_BYTE **)(*(_DWORD *)(v1 + 24) + 4 * v2);
      v15 = 0;
      v16 = 0;
      v6 = (v4 + 254) / (2 * v4 - 2);
      do
      {
        if ( v16 > v6 )
        {
          for ( i = 510 * v15; ; i += 510 )
          {
            ++v15;
            v6 = (i + 510 + v4 + 254) / (2 * v4 - 2);
            if ( v16 <= v6 )
              break;
          }
        }
        v8 = v16++;
        v5[v8] = v12 * v15;
      }
      while ( v16 <= 255 );
      if ( v14 )
      {
        v9 = 1;
        v10 = v5 - 1;
        do
        {
          *v10 = *v5;
          v5[v9++ + 255] = v5[255];
          --v10;
        }
        while ( v9 <= 255 );
      }
      result = (int)a1;
      ++v13;
      v2 = ++v11;
      if ( v11 >= a1[25] )
        break;
      result = v12;
    }
  }
  return result;
}

// sub_10033828 @ 0x10033828
void __usercall sub_10033828(int a1@<edi>)
{
  int v1; // edx
  int *v2; // ecx
  int v3; // esi
  int v4; // eax
  _DWORD *v5; // ebx
  int v6; // eax
  int v7; // ebx
  int *v8; // ecx
  int i; // esi
  int v10; // eax
  int v11; // [esp+0h] [ebp-14h]
  int v12; // [esp+4h] [ebp-10h]
  int *v13; // [esp+8h] [ebp-Ch]
  double *v14; // [esp+Ch] [ebp-8h]
  int v15; // [esp+10h] [ebp-4h]

  v1 = *(_DWORD *)(a1 + 420);
  v15 = 0;
  v11 = v1;
  if ( *(int *)(a1 + 100) > 0 )
  {
    v2 = (int *)(v1 + 52);
    v13 = (int *)(v1 + 52);
    do
    {
      v3 = *(v2 - 5);
      v4 = 0;
      if ( v15 <= 0 )
        goto LABEL_9;
      v5 = (_DWORD *)(v1 + 32);
      while ( v3 != *v5 )
      {
        ++v4;
        ++v5;
        if ( v4 >= v15 )
          goto LABEL_9;
      }
      v6 = *(_DWORD *)(v1 + 4 * v4 + 52);
      if ( !v6 )
      {
LABEL_9:
        v12 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
        v7 = (v3 << 9) - 512;
        v14 = dbl_1004F5D0;
        v8 = (int *)v12;
        do
        {
          for ( i = 0; i < 16; ++i )
          {
            v10 = (65025 - 510 * *((unsigned __int8 *)v14 + i)) / v7;
            *v8++ = v10;
          }
          v14 += 2;
        }
        while ( (int)v14 < (int)dword_1004F6D0 );
        v6 = v12;
        v1 = v11;
        v2 = v13;
      }
      ++v15;
      *v2++ = v6;
      v13 = v2;
    }
    while ( v15 < *(_DWORD *)(a1 + 100) );
  }
}

// sub_100338ED @ 0x100338ED
int __cdecl sub_100338ED(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // esi
  int result; // eax
  _DWORD *v6; // ecx
  unsigned __int8 *v7; // edx
  int v8; // esi
  _BYTE *v9; // esi
  bool v10; // zf
  int v11; // [esp+4h] [ebp-14h]
  int v12; // [esp+8h] [ebp-10h]
  int v13; // [esp+Ch] [ebp-Ch]
  int v14; // [esp+10h] [ebp-8h]
  int v15; // [esp+14h] [ebp-4h]
  char v16; // [esp+20h] [ebp+8h]
  _BYTE *v17; // [esp+2Ch] [ebp+14h]

  v4 = a1[23];
  result = a1[25];
  v13 = *(_DWORD *)(a1[105] + 24);
  v11 = v4;
  v12 = result;
  if ( a4 > 0 )
  {
    v6 = a3;
    v14 = a4;
    do
    {
      v7 = *(unsigned __int8 **)((char *)v6 + a2 - (_DWORD)a3);
      v17 = (_BYTE *)*v6;
      if ( v4 )
      {
        v15 = v4;
        do
        {
          v16 = 0;
          v8 = 0;
          if ( result > 0 )
          {
            do
            {
              v16 += *(_BYTE *)(*(_DWORD *)(v13 + 4 * v8) + *v7);
              result = v12;
              ++v7;
              ++v8;
            }
            while ( v8 < v12 );
          }
          v9 = v17++;
          v10 = v15-- == 1;
          *v9 = v16;
        }
        while ( !v10 );
        v4 = v11;
      }
      ++v6;
      --v14;
    }
    while ( v14 );
  }
  return result;
}

// sub_10033975 @ 0x10033975
int __cdecl sub_10033975(int a1, int a2, _DWORD *a3, int a4)
{
  int *v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // edx
  _DWORD *v8; // edi
  unsigned __int8 *v9; // ecx
  _BYTE *v10; // esi
  char v11; // dl
  unsigned __int8 *v12; // ecx
  char v13; // dl
  char v14; // al
  int v15; // [esp+4h] [ebp-10h]
  int v16; // [esp+8h] [ebp-Ch]
  int v17; // [esp+Ch] [ebp-8h]
  int v18; // [esp+10h] [ebp-4h]
  int v19; // [esp+1Ch] [ebp+8h]

  v4 = *(int **)(*(_DWORD *)(a1 + 420) + 24);
  v18 = *v4;
  v5 = v4[1];
  result = v4[2];
  v17 = v5;
  v7 = *(_DWORD *)(a1 + 92);
  v16 = result;
  v15 = v7;
  if ( a4 > 0 )
  {
    v8 = a3;
    result = a2 - (_DWORD)a3;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v8 + result);
      v10 = (_BYTE *)*v8;
      if ( v7 )
      {
        v19 = v7;
        do
        {
          v11 = *(_BYTE *)(*v9 + v18);
          v12 = v9 + 1;
          v13 = *(_BYTE *)(*v12++ + v17) + v11;
          v14 = *(_BYTE *)(*v12 + v16);
          v9 = v12 + 1;
          *v10++ = v14 + v13;
          --v19;
        }
        while ( v19 );
        v7 = v15;
        result = a2 - (_DWORD)a3;
      }
      ++v8;
      --a4;
    }
    while ( a4 );
  }
  return result;
}

// sub_10033A02 @ 0x10033A02
int __cdecl sub_10033A02(_DWORD *a1, int a2, void **a3, int a4)
{
  _DWORD *v4; // esi
  int result; // eax
  void **v6; // ebx
  int v7; // edi
  int v8; // eax
  _BYTE *v9; // edi
  unsigned __int8 *v10; // eax
  int v11; // ecx
  int v12; // edx
  bool v13; // zf
  char v14; // [esp+4h] [ebp-2Ch]
  int v15; // [esp+Ch] [ebp-24h]
  int v16; // [esp+10h] [ebp-20h]
  _DWORD *v17; // [esp+14h] [ebp-1Ch]
  int v18; // [esp+18h] [ebp-18h]
  void **v19; // [esp+1Ch] [ebp-14h]
  unsigned int v20; // [esp+20h] [ebp-10h]
  unsigned int v21; // [esp+24h] [ebp-Ch]
  int v22; // [esp+28h] [ebp-8h]
  _DWORD *v23; // [esp+2Ch] [ebp-4h]
  int v24; // [esp+38h] [ebp+8h]
  int v25; // [esp+44h] [ebp+14h]

  v4 = (_DWORD *)a1[105];
  v21 = a1[23];
  result = a4;
  v22 = a1[25];
  if ( a4 > 0 )
  {
    v6 = a3;
    v7 = a2 - (_DWORD)a3;
    v19 = a3;
    v18 = a4;
    do
    {
      memzero(*v6, v21);
      v8 = v4[12];
      v24 = 0;
      v14 = v8;
      if ( v22 > 0 )
      {
        v16 = v8 << 6;
        v17 = (void **)((char *)v6 + v7);
        v23 = v4 + 13;
        do
        {
          v25 = 0;
          v9 = *v6;
          v10 = (unsigned __int8 *)(v24 + *v17);
          v15 = *(_DWORD *)(v4[6] + 4 * v24);
          v11 = v16 + *v23;
          if ( v21 )
          {
            v20 = v21;
            do
            {
              v12 = *v10;
              v10 += v22;
              *v9++ += *(_BYTE *)(v12 + *(_DWORD *)(v11 + 4 * v25) + v15);
              v13 = v20-- == 1;
              v25 = ((_BYTE)v25 + 1) & 0xF;
            }
            while ( !v13 );
            v6 = v19;
          }
          ++v24;
          ++v23;
        }
        while ( v24 < v22 );
        v7 = a2 - (_DWORD)a3;
        LOBYTE(v8) = v14;
      }
      result = ((_BYTE)v8 + 1) & 0xF;
      ++v6;
      v13 = v18-- == 1;
      v4[12] = result;
      v19 = v6;
    }
    while ( !v13 );
  }
  return result;
}

// sub_10033AED @ 0x10033AED
_DWORD *__cdecl sub_10033AED(int a1, int a2, _BYTE **a3, int a4)
{
  _DWORD *result; // eax
  int *v5; // ecx
  int v6; // edx
  unsigned __int8 *v7; // ecx
  int v8; // edx
  int v9; // esi
  unsigned __int8 *v10; // ecx
  bool v11; // zf
  int v12; // [esp+4h] [ebp-30h]
  int v13; // [esp+8h] [ebp-2Ch]
  int v14; // [esp+Ch] [ebp-28h]
  int v15; // [esp+10h] [ebp-24h]
  int v16; // [esp+14h] [ebp-20h]
  int v17; // [esp+18h] [ebp-1Ch]
  int v18; // [esp+1Ch] [ebp-18h]
  int v19; // [esp+24h] [ebp-10h]
  int v20; // [esp+28h] [ebp-Ch]
  _BYTE **v21; // [esp+2Ch] [ebp-8h]
  _BYTE *v22; // [esp+30h] [ebp-4h]
  int v23; // [esp+3Ch] [ebp+8h]
  char v24; // [esp+48h] [ebp+14h]
  char v25; // [esp+48h] [ebp+14h]

  result = *(_DWORD **)(a1 + 420);
  v5 = (int *)result[6];
  v16 = *v5;
  v13 = v5[2];
  v18 = *(_DWORD *)(a1 + 92);
  v15 = v5[1];
  if ( a4 > 0 )
  {
    v6 = a2 - (_DWORD)a3;
    v21 = a3;
    v19 = a4;
    while ( 1 )
    {
      v7 = *(_BYTE **)((char *)v21 + v6);
      v23 = 0;
      v12 = result[12];
      v22 = *v21;
      v8 = (v12 << 6) + result[14];
      v9 = (v12 << 6) + result[13];
      v17 = v8;
      v14 = (v12 << 6) + result[15];
      if ( v18 )
      {
        v20 = v18;
        while ( 1 )
        {
          v24 = *(_BYTE *)(*v7 + *(_DWORD *)(v9 + 4 * v23) + v16);
          v10 = v7 + 1;
          v25 = *(_BYTE *)(*v10++ + *(_DWORD *)(v8 + 4 * v23) + v15) + v24;
          *v22 = *(_BYTE *)(*v10 + *(_DWORD *)(v14 + 4 * v23) + v13) + v25;
          v7 = v10 + 1;
          ++v22;
          v11 = v20-- == 1;
          v23 = ((_BYTE)v23 + 1) & 0xF;
          if ( v11 )
            break;
          v8 = v17;
        }
      }
      ++v21;
      v11 = v19-- == 1;
      result[12] = ((_BYTE)v12 + 1) & 0xF;
      if ( v11 )
        break;
      v6 = a2 - (_DWORD)a3;
    }
  }
  return result;
}

// sub_10033BEC @ 0x10033BEC
char __cdecl sub_10033BEC(_DWORD *a1, int a2, void **a3, int a4)
{
  int v4; // ebx
  int v5; // eax
  int v7; // esi
  unsigned __int8 *v8; // edi
  _BYTE *v9; // esi
  _WORD *v10; // ecx
  int v11; // eax
  int v12; // eax
  int v13; // edx
  bool v14; // zf
  int v16; // [esp+8h] [ebp-40h]
  int v17; // [esp+10h] [ebp-38h]
  int v18; // [esp+14h] [ebp-34h]
  int v19; // [esp+18h] [ebp-30h]
  int v20; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v21; // [esp+20h] [ebp-28h]
  int v22; // [esp+24h] [ebp-24h]
  unsigned int v23; // [esp+28h] [ebp-20h]
  int v24; // [esp+2Ch] [ebp-1Ch]
  __int16 v25; // [esp+30h] [ebp-18h]
  __int16 v26; // [esp+34h] [ebp-14h]
  int v27; // [esp+38h] [ebp-10h]
  unsigned int v28; // [esp+3Ch] [ebp-Ch]
  _DWORD *v29; // [esp+40h] [ebp-8h]
  int v30; // [esp+44h] [ebp-4h]
  int v31; // [esp+50h] [ebp+8h]
  void **v32; // [esp+5Ch] [ebp+14h]

  v30 = a1[25];
  v4 = a1[105];
  v5 = a1[71];
  v28 = a1[23];
  v16 = v4;
  v20 = v5;
  if ( a4 > 0 )
  {
    v7 = a2 - (_DWORD)a3;
    v32 = a3;
    v22 = a4;
    do
    {
      memzero(*v32, v28);
      v31 = 0;
      if ( v30 > 0 )
      {
        v21 = (void **)((char *)v32 + v7);
        v29 = (_DWORD *)(v4 + 68);
        do
        {
          v8 = (unsigned __int8 *)(v31 + *v21);
          v9 = *v32;
          if ( *(_BYTE *)(v4 + 84) )
          {
            v27 = -1;
            v9 += v28 - 1;
            v8 += v30 * (v28 - 1);
            v24 = -v30;
            v10 = (_WORD *)(*v29 + 2 * v28 + 2);
          }
          else
          {
            v24 = v30;
            v10 = (_WORD *)*v29;
            v27 = 1;
          }
          v19 = *(_DWORD *)(4 * v31 + *(_DWORD *)(v4 + 24));
          v18 = *(_DWORD *)(4 * v31 + *(_DWORD *)(v4 + 16));
          v11 = 0;
          v26 = 0;
          v25 = 0;
          if ( v28 )
          {
            v23 = v28;
            do
            {
              v12 = *(unsigned __int8 *)(*v8 + (((__int16)v10[v27] + v11 + 8) >> 4) + v20);
              v13 = *(unsigned __int8 *)(v12 + v19);
              *v9 += v13;
              v8 += v24;
              v9 += v27;
              v17 = v12 - *(unsigned __int8 *)(v13 + v18);
              *v10 = 3 * v17 + v26;
              v26 = 5 * v17 + v25;
              v11 = 7 * v17;
              v14 = v23-- == 1;
              v25 = v17;
              v10 += v27;
            }
            while ( !v14 );
            v4 = v16;
          }
          ++v31;
          ++v29;
          *v10 = v26;
        }
        while ( v31 < v30 );
        v7 = a2 - (_DWORD)a3;
      }
      LOBYTE(v5) = *(_BYTE *)(v4 + 84) == 0;
      ++v32;
      v14 = v22-- == 1;
      *(_BYTE *)(v4 + 84) = v5;
    }
    while ( !v14 );
  }
  return v5;
}

// sub_10033D70 @ 0x10033D70
int __usercall sub_10033D70@<eax>(_DWORD *a1@<esi>)
{
  int result; // eax
  int v2; // edi
  int v3; // ebp
  int *v4; // ebx

  result = a1[105];
  v2 = 0;
  v3 = 2 * a1[23] + 4;
  if ( (int)a1[25] > 0 )
  {
    v4 = (int *)(result + 68);
    do
    {
      result = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v3);
      *v4 = result;
      ++v2;
      ++v4;
    }
    while ( v2 < a1[25] );
  }
  return result;
}

// sub_10033DA6 @ 0x10033DA6
void __cdecl sub_10033DA6(_DWORD *a1)
{
  int v1; // edi
  int v2; // eax
  int v3; // eax
  void **v4; // ebx
  bool v5; // zf
  int v6; // edi
  unsigned int i; // ebp

  v1 = a1[105];
  a1[29] = *(_DWORD *)(v1 + 16);
  a1[28] = *(_DWORD *)(v1 + 20);
  v2 = a1[19];
  if ( v2 )
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      if ( v3 == 1 )
      {
        *(_BYTE *)(v1 + 84) = 0;
        v4 = (void **)(v1 + 68);
        v5 = *(_DWORD *)(v1 + 68) == 0;
        *(_DWORD *)(v1 + 4) = sub_10033BEC;
        if ( v5 )
          sub_10033D70(a1);
        v6 = 0;
        for ( i = 2 * a1[23] + 4; v6 < a1[25]; ++v4 )
        {
          memzero(*v4, i);
          ++v6;
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 47;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      if ( a1[25] == 3 )
        *(_DWORD *)(v1 + 4) = sub_10033AED;
      else
        *(_DWORD *)(v1 + 4) = sub_10033A02;
      v5 = *(_BYTE *)(v1 + 28) == 0;
      *(_DWORD *)(v1 + 48) = 0;
      if ( v5 )
        sub_100336FD(a1);
      if ( !*(_DWORD *)(v1 + 52) )
        sub_10033828((int)a1);
    }
  }
  else if ( a1[25] == 3 )
  {
    *(_DWORD *)(v1 + 4) = sub_10033975;
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_100338ED;
  }
}

// sub_10033E70 @ 0x10033E70
int __cdecl sub_10033E70(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_10033E84 @ 0x10033E84
int __cdecl sub_10033E84(_DWORD *a1)
{
  _DWORD *v1; // eax
  int result; // eax

  v1 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 88);
  a1[105] = v1;
  v1[17] = 0;
  v1[13] = 0;
  *v1 = sub_10033DA6;
  v1[2] = nullsub_2;
  v1[3] = sub_10033E70;
  if ( (int)a1[25] > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[21] > 256 )
  {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  sub_100335D0(a1);
  result = sub_100336FD(a1);
  if ( a1[19] == 2 )
    return sub_10033D70(a1);
  return result;
}

// inflate_blocks_reset @ 0x10033F0B
// zlib (internal): reset inflate blocks state
int (__cdecl *__cdecl sub_10033F0B(_DWORD *a1, int a2, _DWORD *a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax

  if ( a3 )
    *a3 = a1[15];
  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    inflate_codes_free(a1[1], a2);
  v3 = a1[10];
  a1[13] = v3;
  a1[12] = v3;
  result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  *a1 = 0;
  a1[7] = 0;
  a1[8] = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    a1[15] = result;
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

// inflate_blocks_new @ 0x10033F76
// zlib (internal): allocate inflate blocks state
_DWORD *__cdecl sub_10033F76(int a1, int a2, int a3)
{
  _DWORD *v3; // edi
  int v4; // eax
  int v6; // eax

  v3 = (_DWORD *)(*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  if ( !v3 )
    return 0;
  v4 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
  v3[9] = v4;
  if ( !v4 )
  {
    (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v3);
    return 0;
  }
  v6 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
  v3[10] = v6;
  if ( v6 )
  {
    *v3 = 0;
    v3[11] = a3 + v6;
    v3[14] = a2;
    inflate_blocks_reset(v3, a1, 0);
    return v3;
  }
  else
  {
    (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v3[9]);
    (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v3);
    return 0;
  }
}

// inflate_blocks @ 0x10034003
// zlib (internal): process inflate blocks
int __cdecl sub_10034003(int *a1, int *a2, int a3)
{
  unsigned int v4; // ecx
  int *v5; // esi
  char *v6; // eax
  unsigned __int8 *v7; // edi
  unsigned int v8; // ecx
  int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // eax
  int v13; // eax
  int v14; // eax
  int v15; // eax
  int v16; // eax
  unsigned int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // ecx
  unsigned int v21; // eax
  unsigned int v22; // ecx
  int v23; // eax
  char *v24; // ecx
  unsigned int v25; // eax
  unsigned int v26; // edx
  int v27; // eax
  unsigned int v28; // ecx
  char *v29; // edx
  unsigned int v30; // eax
  const void *v31; // esi
  void *v32; // edi
  unsigned int v33; // ecx
  int v34; // eax
  unsigned int v35; // eax
  unsigned int v36; // ecx
  unsigned int v37; // eax
  int v38; // eax
  unsigned int i; // ecx
  int v40; // eax
  char v41; // al
  int v42; // ecx
  int v43; // edx
  unsigned int v44; // eax
  int v45; // edx
  int v46; // eax
  unsigned int v47; // ecx
  unsigned int v48; // edx
  int v49; // eax
  int v50; // edx
  int v51; // ecx
  int v52; // eax
  unsigned int v53; // eax
  unsigned int v54; // eax
  int v55; // eax
  char *v56; // eax
  int v57; // eax
  char *v58; // ecx
  unsigned int v59; // eax
  int v60; // eax
  bool v61; // zf
  int v62; // eax
  char *v63; // eax
  unsigned __int8 *v64; // ecx
  int v65; // [esp-28h] [ebp-68h]
  int v66; // [esp-1Ch] [ebp-5Ch]
  int v67; // [esp-14h] [ebp-54h]
  int v68; // [esp-8h] [ebp-48h]
  int v69; // [esp-8h] [ebp-48h]
  int v70; // [esp-4h] [ebp-44h]
  int v71; // [esp+Ch] [ebp-34h] BYREF
  int v72; // [esp+10h] [ebp-30h] BYREF
  unsigned int v73; // [esp+14h] [ebp-2Ch]
  int v74; // [esp+18h] [ebp-28h] BYREF
  int v75; // [esp+1Ch] [ebp-24h] BYREF
  int v76; // [esp+20h] [ebp-20h] BYREF
  int v77; // [esp+24h] [ebp-1Ch] BYREF
  unsigned int v78; // [esp+28h] [ebp-18h] BYREF
  int v79; // [esp+2Ch] [ebp-14h] BYREF
  unsigned int v80; // [esp+30h] [ebp-10h]
  char *v81; // [esp+34h] [ebp-Ch]
  unsigned int v82; // [esp+38h] [ebp-8h]
  unsigned int v83; // [esp+3Ch] [ebp-4h]
  unsigned int v84; // [esp+48h] [ebp+8h]
  unsigned int v85; // [esp+48h] [ebp+8h]
  int v86; // [esp+50h] [ebp+10h]

  v4 = a1[12];
  v5 = a2;
  v82 = a2[1];
  v83 = a1[8];
  v84 = a1[7];
  v6 = (char *)a1[13];
  v7 = (unsigned __int8 *)*a2;
  v79 = *a2;
  v81 = v6;
  if ( (unsigned int)v6 >= v4 )
    v8 = a1[11] - (_DWORD)v6;
  else
    v8 = v4 - (_DWORD)v6 - 1;
  v9 = *a1;
  v80 = v8;
  while ( 2 )
  {
    switch ( v9 )
    {
      case 0:
        while ( v84 < 3 )
        {
          if ( !v82 )
            goto LABEL_114;
          v13 = *v7;
          a3 = 0;
          --v82;
          v83 |= v13 << v84;
          ++v7;
          v84 += 8;
          v79 = (int)v7;
        }
        v14 = (unsigned __int8)(v83 & 7) >> 1;
        a1[6] = v83 & 1;
        if ( !v14 )
        {
          v85 = v84 - 3;
          v20 = v85 & 7;
          v21 = v83 >> 3 >> v20;
          v84 = v85 - v20;
          *a1 = 1;
          v83 = v21;
          goto LABEL_107;
        }
        v15 = v14 - 1;
        if ( v15 )
        {
          v16 = v15 - 1;
          if ( !v16 )
          {
            v83 >>= 3;
            v18 = 3;
            v84 -= 3;
            goto LABEL_22;
          }
          if ( v16 != 1 )
            goto LABEL_107;
          v17 = v83 >> 3;
          *a1 = 9;
          v5[6] = (int)"invalid block type";
          a1[8] = v17;
          v10 = v84 - 3;
          v70 = -3;
          goto LABEL_7;
        }
        sub_10036E31(&v74, &v75, &v76, &v77);
        v19 = inflate_codes_new(v74, v75, v76, v77, v5);
        a1[1] = v19;
        if ( !v19 )
          goto LABEL_120;
        v83 >>= 3;
        v84 -= 3;
        *a1 = 6;
        goto LABEL_107;
      case 1:
        v22 = v84;
        while ( 2 )
        {
          if ( v22 < 0x20 )
          {
            if ( v82 )
            {
              v23 = *v7;
              a3 = 0;
              --v82;
              v83 |= v23 << v22;
              ++v7;
              v22 += 8;
              v79 = (int)v7;
              v84 = v22;
              continue;
            }
LABEL_114:
            v70 = a3;
            a1[8] = v83;
            a1[7] = v84;
            v5[1] = 0;
LABEL_8:
            v5[2] += (int)&v7[-*v5];
            v11 = (unsigned int)v81;
LABEL_9:
            *v5 = (int)v7;
            a1[13] = v11;
            return inflate_flush(a1, v5, v70);
          }
          break;
        }
        if ( ~v83 >> 16 != (unsigned __int16)v83 )
        {
          *a1 = 9;
          v5[6] = (int)"invalid stored block lengths";
          goto LABEL_110;
        }
        a1[1] = (unsigned __int16)v83;
        v61 = a1[1] == 0;
        v84 = 0;
        v83 = 0;
        if ( v61 )
LABEL_57:
          v18 = a1[6] != 0 ? 7 : 0;
        else
          v18 = 2;
LABEL_22:
        *a1 = v18;
LABEL_107:
        v9 = *a1;
        v5 = a2;
        v7 = (unsigned __int8 *)v79;
        if ( (unsigned int)*a1 > 9 )
        {
LABEL_5:
          v70 = -2;
          goto LABEL_6;
        }
        v8 = v80;
        continue;
      case 2:
        if ( !v82 )
          goto LABEL_114;
        if ( !v8 )
        {
          if ( (v24 = (char *)a1[11], v81 != v24)
            || (v25 = a1[12], v26 = a1[10], v26 == v25)
            || ((v81 = (char *)a1[10], v26 >= v25) ? (v8 = (unsigned int)&v24[-v26]) : (v8 = v25 - v26 - 1),
                (v80 = v8) == 0) )
          {
            a1[13] = (int)v81;
            v27 = inflate_flush(a1, v5, a3);
            v28 = a1[12];
            v86 = v27;
            v81 = (char *)a1[13];
            v11 = (unsigned int)v81;
            v78 = v28;
            if ( (unsigned int)v81 >= v28 )
              v8 = a1[11] - (_DWORD)v81;
            else
              v8 = v28 - (_DWORD)v81 - 1;
            v29 = (char *)a1[11];
            v80 = v8;
            v73 = (unsigned int)v29;
            if ( v81 == v29 )
            {
              v11 = a1[10];
              if ( v11 == v78 )
              {
                v11 = (unsigned int)v81;
              }
              else
              {
                v81 = (char *)a1[10];
                if ( v11 >= v78 )
                  v8 = v73 - v11;
                else
                  v8 = v78 - v11 - 1;
                v80 = v8;
              }
            }
            if ( !v8 )
            {
              v70 = v86;
              a1[8] = v83;
              a1[7] = v84;
              v5[1] = v82;
              v5[2] += (int)&v7[-*v5];
              goto LABEL_9;
            }
          }
        }
        v30 = a1[1];
        a3 = 0;
        if ( v30 > v82 )
          v30 = v82;
        if ( v30 > v8 )
          v30 = v8;
        v31 = (const void *)v79;
        v32 = v81;
        v79 += v30;
        v82 -= v30;
        v81 += v30;
        v80 -= v30;
        qmemcpy(v32, v31, v30);
        v61 = a1[1] == v30;
        a1[1] -= v30;
        if ( v61 )
          goto LABEL_57;
        goto LABEL_107;
      case 3:
        v33 = v84;
        while ( 2 )
        {
          if ( v33 < 0xE )
          {
            if ( v82 )
            {
              v34 = *v7;
              a3 = 0;
              --v82;
              v83 |= v34 << v33;
              ++v7;
              v33 += 8;
              v84 = v33;
              continue;
            }
            goto LABEL_114;
          }
          break;
        }
        v35 = v83 & 0x3FFF;
        v36 = v83 & 0x1F;
        a1[1] = v35;
        if ( v36 > 0x1D || (v37 = (v35 >> 5) & 0x1F, v37 > 0x1D) )
        {
          *a1 = 9;
          v5[6] = (int)"too many length or distance symbols";
LABEL_110:
          v70 = -3;
LABEL_6:
          a1[8] = v83;
          v10 = v84;
LABEL_7:
          a1[7] = v10;
          v5[1] = v82;
          goto LABEL_8;
        }
        v38 = ((int (__cdecl *)(int, unsigned int, int))v5[8])(v5[10], v37 + v36 + 258, 4);
        a1[3] = v38;
        if ( !v38 )
          goto LABEL_120;
        v83 >>= 14;
        v84 -= 14;
        a1[2] = 0;
        *a1 = 4;
LABEL_71:
        while ( a1[2] < ((unsigned int)a1[1] >> 10) + 4 )
        {
          for ( i = v84; i < 3; v84 = i )
          {
            if ( !v82 )
              goto LABEL_114;
            v40 = *v7;
            a3 = 0;
            --v82;
            v83 |= v40 << i;
            ++v7;
            i += 8;
          }
          v41 = v83;
          v42 = dword_1004F6E0[a1[2]];
          v43 = a1[3];
          v83 >>= 3;
          *(_DWORD *)(v43 + 4 * v42) = v41 & 7;
          ++a1[2];
          v84 -= 3;
        }
        while ( (unsigned int)a1[2] < 0x13 )
          *(_DWORD *)(a1[3] + 4 * dword_1004F6E0[a1[2]++]) = 0;
        v68 = a1[9];
        v67 = a1[3];
        a1[4] = 7;
        v80 = inflate_trees_bits(v67, a1 + 4, a1 + 5, v68, v5);
        if ( v80 )
        {
          ((void (__cdecl *)(int, int))v5[9])(v5[10], a1[3]);
          v61 = v80 == -3;
LABEL_117:
          if ( v61 )
            *a1 = 9;
          v70 = v80;
          goto LABEL_6;
        }
        a1[2] = 0;
        *a1 = 5;
LABEL_97:
        while ( a1[2] < (((unsigned int)a1[1] >> 5) & 0x1F) + (a1[1] & 0x1F) + 258 )
        {
          v44 = a1[4];
          while ( v84 < v44 )
          {
            if ( !v82 )
              goto LABEL_114;
            v45 = *v7;
            a3 = 0;
            --v82;
            v83 |= v45 << v84;
            ++v7;
            v84 += 8;
          }
          v46 = a1[5] + 8 * (v83 & dword_10057020[v44]);
          v47 = *(unsigned __int8 *)(v46 + 1);
          v48 = *(_DWORD *)(v46 + 4);
          v80 = v47;
          v73 = v48;
          if ( v48 >= 0x10 )
          {
            if ( v48 == 18 )
              v49 = 7;
            else
              v49 = v48 - 14;
            v79 = 8 * (v48 == 18) + 3;
            while ( v84 < v49 + v80 )
            {
              if ( !v82 )
                goto LABEL_114;
              v50 = *v7;
              a3 = 0;
              --v82;
              v83 |= v50 << v84;
              ++v7;
              v84 += 8;
            }
            v83 >>= v80;
            v79 += v83 & dword_10057020[v49];
            v83 >>= v49;
            v84 -= v80 + v49;
            v51 = a1[2];
            if ( v51 + v79 > (((unsigned int)a1[1] >> 5) & 0x1F) + (a1[1] & 0x1F) + 258 )
            {
LABEL_115:
              ((void (__cdecl *)(int, int))v5[9])(v5[10], a1[3]);
              v62 = v83;
              *a1 = 9;
              v5[6] = (int)"invalid bit length repeat";
              a1[8] = v62;
              a1[7] = v84;
              v5[1] = v82;
              v5[2] += (int)&v7[-*v5];
              v63 = v81;
              *v5 = (int)v7;
              a1[13] = (int)v63;
              return inflate_flush(a1, v5, -3);
            }
            if ( v73 == 16 )
            {
              if ( !v51 )
                goto LABEL_115;
              v52 = *(_DWORD *)(a1[3] + 4 * v51 - 4);
            }
            else
            {
              v52 = 0;
            }
            do
            {
              *(_DWORD *)(a1[3] + 4 * v51++) = v52;
              --v79;
            }
            while ( v79 );
            a1[2] = v51;
          }
          else
          {
            v83 >>= v47;
            v84 -= v47;
            *(_DWORD *)(a1[3] + 4 * a1[2]++) = v48;
          }
        }
        v53 = a1[1];
        a1[5] = 0;
        v69 = a1[9];
        v66 = a1[3];
        v78 = 9;
        v79 = 6;
        v54 = inflate_trees_dynamic((v53 & 0x1F) + 257, ((v53 >> 5) & 0x1F) + 1, v66, &v78, &v79, &v71, &v72, v69, v5);
        v65 = a1[3];
        v80 = v54;
        ((void (__cdecl *)(int, int))v5[9])(v5[10], v65);
        if ( v80 )
        {
          v61 = v80 == -3;
          goto LABEL_117;
        }
        v55 = inflate_codes_new(v78, v79, v71, v72, v5);
        if ( !v55 )
        {
LABEL_120:
          v70 = -4;
          goto LABEL_6;
        }
        a1[1] = v55;
        *a1 = 6;
LABEL_101:
        a1[8] = v83;
        a1[7] = v84;
        v5[1] = v82;
        v5[2] += (int)&v7[-*v5];
        v56 = v81;
        *v5 = (int)v7;
        a1[13] = (int)v56;
        v57 = inflate_codes(a1, v5, a3);
        if ( v57 != 1 )
          return inflate_flush(a1, v5, v57);
        a3 = 0;
        inflate_codes_free(a1[1], v5);
        v7 = (unsigned __int8 *)*v5;
        v82 = v5[1];
        v83 = a1[8];
        v58 = (char *)a1[13];
        v84 = a1[7];
        v59 = a1[12];
        v79 = (int)v7;
        v81 = v58;
        if ( (unsigned int)v58 >= v59 )
          v60 = a1[11] - (_DWORD)v81;
        else
          v60 = v59 - (_DWORD)v58 - 1;
        v61 = a1[6] == 0;
        v80 = v60;
        if ( v61 )
        {
          *a1 = 0;
          goto LABEL_107;
        }
        *a1 = 7;
LABEL_122:
        a1[13] = (int)v81;
        v57 = inflate_flush(a1, v5, a3);
        v61 = a1[12] == a1[13];
        v81 = (char *)a1[13];
        if ( v61 )
        {
          *a1 = 8;
LABEL_126:
          v70 = 1;
          goto LABEL_6;
        }
        a1[8] = v83;
        a1[7] = v84;
        v5[1] = v82;
        v64 = &v7[-*v5];
        *v5 = (int)v7;
        v5[2] += (int)v64;
        a1[13] = (int)v81;
        return inflate_flush(a1, v5, v57);
      case 4:
        goto LABEL_71;
      case 5:
        goto LABEL_97;
      case 6:
        goto LABEL_101;
      case 7:
        goto LABEL_122;
      case 8:
        goto LABEL_126;
      case 9:
        goto LABEL_110;
      default:
        goto LABEL_5;
    }
  }
}

// inflate_blocks_free @ 0x1003479E
// zlib (internal): free inflate blocks state
int __cdecl sub_1003479E(_DWORD *a1, int a2)
{
  inflate_blocks_reset(a1, a2, 0);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[10]);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[9]);
  (*(void (__cdecl **)(_DWORD, _DWORD *))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

// adler32 @ 0x100347D2
// zlib: adler32 checksum
int __cdecl sub_100347D2(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // ecx
  unsigned int v4; // esi
  unsigned int v5; // edi
  int v7; // edx
  unsigned int v8; // eax
  int v9; // esi
  int v10; // edi
  int v11; // esi
  int v12; // edi
  int v13; // esi
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // esi
  int v18; // edi
  int v19; // esi
  int v20; // edi
  int v21; // esi
  int v22; // edi
  int v23; // esi
  int v24; // edi
  int v25; // esi
  int v26; // edi
  int v27; // esi
  int v28; // edi
  int v29; // esi
  int v30; // edi
  int v31; // esi
  int v32; // edi
  int v33; // esi
  int v34; // edi
  int v35; // esi
  int v36; // edi
  int v37; // esi
  int v38; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( ; a3; v5 %= 0xFFF1u )
  {
    v7 = 5552;
    if ( a3 < 0x15B0 )
      v7 = a3;
    a3 -= v7;
    if ( v7 >= 16 )
    {
      v8 = (unsigned int)v7 >> 4;
      v7 += -16 * ((unsigned int)v7 >> 4);
      do
      {
        v9 = *v3 + v4;
        v10 = v9 + v5;
        v11 = v3[1] + v9;
        v12 = v11 + v10;
        v13 = v3[2] + v11;
        v14 = v13 + v12;
        v15 = v3[3] + v13;
        v16 = v15 + v14;
        v17 = v3[4] + v15;
        v18 = v17 + v16;
        v19 = v3[5] + v17;
        v20 = v19 + v18;
        v21 = v3[6] + v19;
        v22 = v21 + v20;
        v23 = v3[7] + v21;
        v24 = v23 + v22;
        v25 = v3[8] + v23;
        v26 = v25 + v24;
        v27 = v3[9] + v25;
        v28 = v27 + v26;
        v29 = v3[10] + v27;
        v30 = v29 + v28;
        v31 = v3[11] + v29;
        v32 = v31 + v30;
        v33 = v3[12] + v31;
        v34 = v33 + v32;
        v35 = v3[13] + v33;
        v36 = v35 + v34;
        v37 = v3[14] + v35;
        v38 = v37 + v36;
        v4 = v3[15] + v37;
        v5 = v4 + v38;
        v3 += 16;
        --v8;
      }
      while ( v8 );
    }
    for ( ; v7; --v7 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

// zcalloc @ 0x100348EB
// zlib (internal): default alloc wrapper (calloc)
void *__cdecl sub_100348EB(int a1, size_t Count, size_t Size)
{
  return calloc(Count, Size);
}

// sub_10034900 @ 0x10034900
__m128 *__cdecl sub_10034900(__m128 *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm1
  __m128 v4; // xmm2
  __m128 *v5; // edx
  __m128 v6; // xmm3
  __m128 v7; // xmm0
  __m128 v8; // xmm5
  __m128 v9; // xmm6
  __m128 v10; // xmm2
  __m128 v11; // xmm4
  __m128 v12; // xmm3
  __m128 v13; // xmm3
  __m128 v14; // xmm0
  __m128 v15; // xmm5
  __m128 v16; // xmm6
  __m128 v17; // xmm1
  __m128 v18; // xmm0
  int savedregs; // [esp+0h] [ebp+0h] BYREF

  v3 = _mm_and_ps(*a1, (__m128)xmmword_10055B50);
  v4 = _mm_and_ps(*a1, (__m128)xmmword_10055B60);
  v5 = (__m128 *)(&savedregs - 16);
  v6 = _mm_add_ps(_mm_mul_ps(v4, (__m128)xmmword_10055B40), (__m128)xmmword_10055AF0);
  v7 = _mm_sub_ps(v6, (__m128)xmmword_10055AF0);
  v8 = (__m128)xmmword_10055AE0;
  v9 = (__m128)xmmword_10055AD0;
  v10 = _mm_sub_ps(
          _mm_sub_ps(
            _mm_sub_ps(
              _mm_sub_ps(v4, _mm_mul_ps((__m128)xmmword_10055B30, v7)),
              _mm_mul_ps((__m128)xmmword_10055B20, v7)),
            _mm_mul_ps((__m128)xmmword_10055B10, v7)),
          _mm_mul_ps((__m128)xmmword_10055B00, v7));
  v11 = _mm_mul_ps(v10, v10);
  v12 = _mm_and_ps(v6, (__m128)xmmword_10055AC0);
  *v5 = _mm_and_ps(v12, (__m128)xmmword_10055AB0);
  v5[1] = v12;
  v5[2] = v12;
  v5[1].m128_i32[0] = (dword_10055AA0 & (v5[1].m128_i32[0] - v5->m128_i32[0])) << 30;
  v5[1].m128_i32[1] = (dword_10055AA0 & (v5[1].m128_i32[1] - v5->m128_i32[1])) << 30;
  v5[1].m128_i32[2] = (dword_10055AA0 & (v5[1].m128_i32[2] - v5->m128_i32[2])) << 30;
  v5[1].m128_i32[3] = (dword_10055AA0 & (v5[1].m128_i32[3] - v5->m128_i32[3])) << 30;
  v5[2].m128_i32[0] = (dword_10055AA0 & (v5->m128_i32[0] + v5[2].m128_i32[0])) << 30;
  v5[2].m128_i32[1] = (dword_10055AA0 & (v5->m128_i32[1] + v5[2].m128_i32[1])) << 30;
  v5[2].m128_i32[2] = (dword_10055AA0 & (v5->m128_i32[2] + v5[2].m128_i32[2])) << 30;
  v5[2].m128_i32[3] = (dword_10055AA0 & (v5->m128_i32[3] + v5[2].m128_i32[3])) << 30;
  v5->m128_i32[0] = *(&savedregs - 16) << 30;
  v5->m128_i32[1] <<= 30;
  v5->m128_i32[2] <<= 30;
  v5->m128_i32[3] = *(&savedregs - 13) << 30;
  v13 = _mm_xor_ps(*((__m128 *)&savedregs - 3), v3);
  v14 = _mm_cmpneq_ps(*((__m128 *)&savedregs - 4), (__m128)0LL);
  v15 = _mm_mul_ps(
          _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_mul_ps(_mm_add_ps(_mm_mul_ps(v8, v11), (__m128)xmmword_10055A90), v11),
                (__m128)xmmword_10055A70),
              v11),
            (__m128)xmmword_10055A50),
          v10);
  v16 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps(v9, v11), (__m128)xmmword_10055A80), v11),
                  (__m128)xmmword_10055A60),
                v11),
              (__m128)xmmword_10055A40),
            v11),
          (__m128)xmmword_10055A30);
  v17 = _mm_or_ps(_mm_andnot_ps(v14, v15), _mm_and_ps(v14, v16));
  v18 = _mm_xor_ps(_mm_or_ps(_mm_and_ps(v14, v15), _mm_andnot_ps(v14, v16)), *((__m128 *)&savedregs - 2));
  *a2 = _mm_xor_ps(v17, v13);
  *a3 = v18;
  return a2;
}

// sub_10034AF0 @ 0x10034AF0
__m128 __userpurge sub_10034AF0@<xmm0>(__m128i a1@<xmm0>, int a2, int a3, int a4, int a5)
{
  __m128 v6; // xmm2
  __m128 v7; // xmm3
  __m128 v8; // xmm4
  __m128 v9; // xmm2
  __m128 v10; // xmm4
  __m128 v11; // xmm2
  __m128 v12; // xmm4
  __m128 v13; // xmm2
  __m128 v14; // xmm4
  __m128 v15; // xmm7
  __m128i v16; // xmm0
  __m128i v17; // xmm3
  __m128 v18; // xmm7
  __m128 v19; // xmm5
  __m128 v20; // xmm2
  __m128 v21; // xmm0
  __m128 v22; // xmm2

  v6 = (__m128)_mm_and_si128(a1, (__m128i)xmmword_10055C40);
  v7 = _mm_add_ps(_mm_mul_ps(v6, (__m128)xmmword_10055C20), (__m128)xmmword_10055C00);
  v8 = _mm_mul_ps((__m128)xmmword_10055C10, _mm_sub_ps(v7, (__m128)xmmword_10055C00));
  v9 = _mm_sub_ps(v6, v8);
  v10 = _mm_shuffle_ps(v8, v8, 57);
  v11 = _mm_sub_ps(v9, v10);
  v12 = _mm_shuffle_ps(v10, v10, 57);
  v13 = _mm_sub_ps(_mm_sub_ps(v11, v12), _mm_shuffle_ps(v12, v12, 57));
  v14 = _mm_mul_ps(v13, v13);
  v15 = _mm_and_ps(v7, (__m128)xmmword_10055BF0);
  v16 = (__m128i)_mm_and_ps(v15, (__m128)xmmword_10055BE0);
  v17 = _mm_sub_epi32((__m128i)v15, v16);
  v18 = (__m128)_mm_slli_epi32(_mm_and_si128(_mm_add_epi32((__m128i)v15, v16), (__m128i)xmmword_10055BD0), 0x1Eu);
  v19 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055BC0, v14), (__m128)xmmword_10055BB0), v14),
                  (__m128)xmmword_10055BA0),
                v14),
              (__m128)xmmword_10055B90),
            _mm_unpacklo_ps(v13, v14)),
          (__m128)xmmword_10055B80);
  v20 = _mm_cmpneq_ps((__m128)_mm_slli_epi32(v16, 0x1Eu), (__m128)0LL);
  v21 = _mm_and_ps(v20, v19);
  v22 = _mm_andnot_ps(v20, v19);
  return _mm_xor_ps(
           _mm_or_ps(v21, _mm_shuffle_ps(v22, v22, 177)),
           _mm_unpacklo_ps(
             v18,
             (__m128)_mm_xor_si128(
                       _mm_slli_epi32(_mm_and_si128(v17, (__m128i)xmmword_10055BD0), 0x1Eu),
                       _mm_and_si128(a1, (__m128i)xmmword_10055C30))));
}

// sub_10034BE0 @ 0x10034BE0
__m128 *__cdecl sub_10034BE0(__m128i *a1, __m128 *a2, __m128 *a3)
{
  __m128 v3; // xmm2
  __m128 v4; // xmm3
  __m128 v5; // xmm0
  __m128 v6; // xmm2
  __m128 v7; // xmm4
  __m128 v8; // xmm7
  __m128i v9; // xmm0
  __m128i v10; // xmm3
  __m128 v11; // xmm7
  __m128 v12; // xmm0
  __m128 v13; // xmm5
  __m128 v14; // xmm6

  v3 = (__m128)_mm_and_si128(*a1, (__m128i)xmmword_10055D80);
  v4 = _mm_add_ps(_mm_mul_ps(v3, (__m128)xmmword_10055D60), (__m128)xmmword_10055D10);
  v5 = _mm_sub_ps(v4, (__m128)xmmword_10055D10);
  v6 = _mm_sub_ps(
         _mm_sub_ps(
           _mm_sub_ps(
             _mm_sub_ps(v3, _mm_mul_ps((__m128)xmmword_10055D50, v5)),
             _mm_mul_ps((__m128)xmmword_10055D40, v5)),
           _mm_mul_ps((__m128)xmmword_10055D30, v5)),
         _mm_mul_ps((__m128)xmmword_10055D20, v5));
  v7 = _mm_mul_ps(v6, v6);
  v8 = _mm_and_ps(v4, (__m128)xmmword_10055CE0);
  v9 = (__m128i)_mm_and_ps(v8, (__m128)xmmword_10055CD0);
  v10 = _mm_sub_epi32((__m128i)v8, v9);
  v11 = (__m128)_mm_slli_epi32(_mm_and_si128(_mm_add_epi32((__m128i)v8, v9), (__m128i)xmmword_10055CC0), 0x1Eu);
  v12 = _mm_cmpneq_ps((__m128)_mm_slli_epi32(v9, 0x1Eu), (__m128)0LL);
  v13 = _mm_mul_ps(
          _mm_add_ps(
            _mm_mul_ps(
              _mm_add_ps(
                _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055D00, v7), (__m128)xmmword_10055CB0), v7),
                (__m128)xmmword_10055C90),
              v7),
            (__m128)xmmword_10055C70),
          v6);
  v14 = _mm_add_ps(
          _mm_mul_ps(
            _mm_add_ps(
              _mm_mul_ps(
                _mm_add_ps(
                  _mm_mul_ps(_mm_add_ps(_mm_mul_ps((__m128)xmmword_10055CF0, v7), (__m128)xmmword_10055CA0), v7),
                  (__m128)xmmword_10055C80),
                v7),
              (__m128)xmmword_10055C60),
            v7),
          (__m128)xmmword_10055C50);
  *a2 = _mm_xor_ps(
          _mm_or_ps(_mm_andnot_ps(v12, v13), _mm_and_ps(v12, v14)),
          (__m128)_mm_xor_si128(
                    _mm_slli_epi32(_mm_and_si128(v10, (__m128i)xmmword_10055CC0), 0x1Eu),
                    _mm_and_si128(*a1, (__m128i)xmmword_10055D70)));
  *a3 = _mm_xor_ps(_mm_or_ps(_mm_and_ps(v12, v13), _mm_andnot_ps(v12, v14)), v11);
  return a2;
}

// sub_10034E00 @ 0x10034E00
void sub_10034E00()
{
  ;
}

// sub_10034F00 @ 0x10034F00
void sub_10034F00()
{
  ;
}

// sub_10035100 @ 0x10035100
void sub_10035100()
{
  ;
}

// sub_100354E0 @ 0x100354E0
unsigned int __usercall sub_100354E0@<eax>(__m64 a1@<mm0>)
{
  int v1; // eax

  v1 = _mm_cvtsi64_si32(a1);
  return v1 & 0x80000000 ^ v1;
}

// sub_10035600 @ 0x10035600
unsigned int __usercall sub_10035600@<eax>(__m64 a1@<mm0>)
{
  int v1; // eax

  v1 = _mm_cvtsi64_si32(a1);
  return v1 & 0x80000000 ^ v1;
}

// sub_100359F8 @ 0x100359F8
_BYTE *__cdecl sub_100359F8(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // edx
  unsigned __int16 *v7; // esi
  int *v8; // edi
  _WORD *v9; // ecx
  unsigned __int16 v10; // ax
  unsigned __int16 v11; // bx
  __int16 v12; // ax
  unsigned __int16 v13; // bx
  bool v14; // zf
  int v15; // eax
  int v16; // eax
  int v17; // edx
  int v18; // eax
  int v19; // esi
  int v20; // eax
  int v21; // edi
  int v22; // edx
  int v23; // edi
  int v24; // ebx
  int v25; // esi
  int v26; // esi
  int v27; // eax
  char *v28; // ecx
  int v29; // ebx
  _BYTE *result; // eax
  char v31; // bl
  int v32; // esi
  int v33; // edx
  int v34; // edi
  int v35; // edx
  int v36; // esi
  int v37; // ebx
  int v38; // esi
  int v39; // edx
  int v40; // ebx
  int v41; // edi
  int v42; // edi
  char v43; // [esp+Ch] [ebp-98h] BYREF
  _BYTE v44[96]; // [esp+2Ch] [ebp-78h] BYREF
  int v45; // [esp+8Ch] [ebp-18h]
  unsigned __int16 *v46; // [esp+90h] [ebp-14h]
  int *v47; // [esp+94h] [ebp-10h]
  int v48; // [esp+98h] [ebp-Ch]
  int v49; // [esp+9Ch] [ebp-8h]
  int v50; // [esp+A0h] [ebp-4h]
  int v51; // [esp+ACh] [ebp+8h]
  int v52; // [esp+ACh] [ebp+8h]
  __int16 v53; // [esp+B0h] [ebp+Ch]
  __int16 v54; // [esp+B0h] [ebp+Ch]
  int v55; // [esp+B0h] [ebp+Ch]
  unsigned __int16 v56; // [esp+B4h] [ebp+10h]
  __int16 v57; // [esp+B4h] [ebp+10h]
  int v58; // [esp+B4h] [ebp+10h]
  int v59; // [esp+B4h] [ebp+10h]

  v5 = *(_DWORD *)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (unsigned __int16 *)(a3 + 96);
  v8 = (int *)v44;
  v48 = v6;
  v51 = 8;
  v47 = (int *)v44;
  v46 = (unsigned __int16 *)(a3 + 96);
  v9 = (_WORD *)(v5 + 96);
  do
  {
    if ( v51 != 4 )
    {
      v56 = v7[8];
      v10 = *v7;
      v53 = *(v7 - 8);
      LOWORD(v50) = *(v7 - 24);
      v11 = *(v7 - 40);
      v45 = v10;
      v49 = v11;
      v12 = v53 | v50 | v11 | v10;
      v13 = *(v7 - 32);
      v14 = (v13 | (unsigned __int16)(v56 | v12)) == 0;
      v15 = (__int16)*(v9 - 48);
      if ( v14 )
      {
        v16 = 4 * (__int16)*(v7 - 48) * v15;
        *(v8 - 8) = v16;
        *v8 = v16;
        v8[16] = v16;
      }
      else
      {
        v17 = 15137 * (__int16)(v13 * *(v9 - 32)) - 6270 * (__int16)(v45 * *v9);
        v18 = ((__int16)*(v7 - 48) * v15) << 14;
        v19 = v17 + v18;
        v20 = v18 - v17;
        LOWORD(v17) = v56 * v9[8];
        v57 = v50 * *(v9 - 24);
        v54 = v53 * *(v9 - 8);
        v49 = (__int16)v49 * (__int16)*(v9 - 40);
        v21 = v57;
        v50 = (__int16)v49;
        v58 = (__int16)v17;
        v22 = 8697 * (__int16)v49 + 11893 * v54 - 1730 * (__int16)v17 - 17799 * v21;
        v23 = 20995 * (__int16)v49 + 7373 * v21 - 4926 * v54 - 4176 * v58;
        v24 = v19 + v23 + 2048;
        v25 = v19 - v23;
        v8 = v47;
        *(v47 - 8) = v24 >> 12;
        v8[16] = (v25 + 2048) >> 12;
        v26 = v20 + v22 + 2048;
        v27 = v20 - v22;
        v6 = v48;
        *v8 = v26 >> 12;
        v7 = v46;
        v16 = (v27 + 2048) >> 12;
      }
      v8[8] = v16;
    }
    ++v7;
    ++v8;
    ++v9;
    --v51;
    v46 = v7;
    v47 = v8;
  }
  while ( v51 > 0 );
  v52 = 0;
  v28 = &v43;
  do
  {
    v29 = *((_DWORD *)v28 + 5);
    result = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * v52));
    if ( *((_DWORD *)v28 + 2)
       | *((_DWORD *)v28 + 6)
       | *((_DWORD *)v28 + 7)
       | v29
       | *((_DWORD *)v28 + 3)
       | *((_DWORD *)v28 + 1) )
    {
      v32 = 15137 * *((__int16 *)v28 + 4) - 6270 * *((__int16 *)v28 + 12);
      v33 = *(_DWORD *)v28 << 14;
      v34 = v32 + v33;
      v35 = v33 - v32;
      v50 = *((__int16 *)v28 + 2);
      v59 = *((__int16 *)v28 + 14);
      v55 = (__int16)v29;
      v36 = 8697 * v50 + 11893 * (__int16)v29 - 1730 * v59;
      v49 = v35;
      v37 = *((__int16 *)v28 + 6);
      v38 = v36 - 17799 * v37;
      v39 = 20995 * v50 + 7373 * v37 - 4926 * v55 - 4176 * v59;
      v40 = (v34 + v39 + 0x40000) >> 19;
      v41 = v34 - v39;
      v6 = v48;
      *result = *(_BYTE *)((v40 & 0x3FF) + v48);
      LOBYTE(v40) = *(_BYTE *)((((v41 + 0x40000) >> 19) & 0x3FF) + v6);
      v42 = v49;
      result[3] = v40;
      result[1] = *(_BYTE *)((((v42 + v38 + 0x40000) >> 19) & 0x3FF) + v6);
      v31 = *(_BYTE *)((((v42 - v38 + 0x40000) >> 19) & 0x3FF) + v6);
    }
    else
    {
      v31 = *(_BYTE *)((((*(_DWORD *)v28 + 16) >> 5) & 0x3FF) + v6);
      *result = v31;
      result[1] = v31;
      result[3] = v31;
    }
    v28 += 32;
    ++v52;
    result[2] = v31;
  }
  while ( v52 < 4 );
  return result;
}

// sub_10035D0D @ 0x10035D0D
_BYTE *__cdecl sub_10035D0D(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // ecx
  int v6; // ebx
  int *v7; // edi
  _WORD *v8; // esi
  _WORD *v9; // ecx
  int v10; // eax
  int v11; // edx
  int v12; // eax
  int v13; // eax
  int v14; // edx
  _BYTE *result; // eax
  _BYTE *v16; // edi
  int v17; // ecx
  char v18; // cl
  int v19; // ecx
  int v20; // esi
  _BYTE v21[64]; // [esp+Ch] [ebp-48h] BYREF
  int v22; // [esp+4Ch] [ebp-8h]
  int *v23; // [esp+50h] [ebp-4h]
  int v24; // [esp+5Ch] [ebp+8h]
  int v25; // [esp+5Ch] [ebp+8h]

  v5 = *(_DWORD *)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (int *)v21;
  v8 = (_WORD *)(a3 + 48);
  v22 = v6;
  v23 = (int *)v21;
  v24 = 8;
  v9 = (_WORD *)(v5 + 48);
  do
  {
    if ( v24 != 6 && v24 != 4 && v24 != 2 )
    {
      v10 = (__int16)*(v9 - 24);
      v11 = (__int16)*(v8 - 24);
      if ( *v8 | (unsigned __int16)(*(v8 - 16) | v8[16] | v8[32]) )
      {
        v13 = (v11 * v10) << 15;
        v14 = 29692 * (__int16)(*(v8 - 16) * *(v9 - 16))
            + 6967 * (__int16)(v8[16] * v9[16])
            - 5906 * (__int16)(v8[32] * v9[32])
            - 10426 * (__int16)(*v8 * *v9);
        v7 = v23;
        *v23 = (v14 + v13 + 4096) >> 13;
        v6 = v22;
        v12 = (v13 - v14 + 4096) >> 13;
      }
      else
      {
        v12 = 4 * v11 * v10;
        *v7 = v12;
      }
      v7[8] = v12;
    }
    ++v8;
    ++v7;
    ++v9;
    --v24;
    v23 = v7;
  }
  while ( v24 > 0 );
  v25 = 0;
  result = v21;
  do
  {
    v16 = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * v25));
    v17 = *(_DWORD *)result;
    if ( *((_DWORD *)result + 5) | *((_DWORD *)result + 1) | *((_DWORD *)result + 3) | *((_DWORD *)result + 7) )
    {
      v19 = v17 << 15;
      v20 = 6967 * *((__int16 *)result + 10)
          + 29692 * *((__int16 *)result + 2)
          + -10426 * *((__int16 *)result + 6)
          - 5906 * *((__int16 *)result + 14);
      v6 = v22;
      *v16 = *(_BYTE *)((((v20 + v19 + 0x80000) >> 20) & 0x3FF) + v22);
      v18 = *(_BYTE *)((((v19 - v20 + 0x80000) >> 20) & 0x3FF) + v6);
    }
    else
    {
      v18 = *(_BYTE *)((((v17 + 16) >> 5) & 0x3FF) + v6);
      *v16 = v18;
    }
    result += 32;
    ++v25;
    v16[1] = v18;
  }
  while ( v25 < 2 );
  return result;
}

// sub_10035ECB @ 0x10035ECB
char __cdecl sub_10035ECB(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  char result; // al

  result = *(_BYTE *)((((*a3 * **(__int16 **)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD *)(a1 + 284) + 128);
  *(_BYTE *)(a5 + *a4) = result;
  return result;
}

// sub_10035F08 @ 0x10035F08
int __cdecl sub_10035F08(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp-14h] [ebp-A4h]
  int v7; // [esp-4h] [ebp-94h]
  _BYTE v8[136]; // [esp+8h] [ebp-88h] BYREF

  v7 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(_DWORD *)(a2 + 80);
  if ( byte_100554E8 )
    return sub_100373D7(a3, v6, v8, a4, a5, v7);
  else
    return sub_10036F75(a3, v6, v8, a4, a5, v7);
}

// sub_10035F54 @ 0x10035F54
int __cdecl sub_10035F54(int a1, int a2, int a3, int a4, int a5)
{
  int v6; // [esp-10h] [ebp-A0h]
  int v7; // [esp-4h] [ebp-94h]
  _BYTE v8[136]; // [esp+8h] [ebp-88h] BYREF

  v7 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(_DWORD *)(a2 + 80);
  if ( byte_100554E8 )
    return sub_10037DEA(a3, v8, v6, a4, a5, v7);
  else
    return sub_10037A8F(a3, v8, v6, a4, a5, v7);
}

// sub_10035FA0 @ 0x10035FA0
char __cdecl sub_10035FA0(int a1, int a2, __int16 *a3, int a4, int a5)
{
  float *v6; // ecx
  float *v7; // eax
  __int16 v8; // si
  __int16 v9; // di
  double v10; // st5
  int v11; // edi
  double v12; // st4
  double v13; // st5
  double v14; // st4
  double v15; // st3
  double v16; // st5
  double v17; // st4
  double v18; // st3
  double v19; // st2
  double v20; // st2
  double v21; // st4
  double v22; // st3
  double v23; // st2
  double v24; // st1
  float *v25; // esi
  _BYTE *v26; // edi
  double v27; // st5
  double v28; // st4
  double v29; // st3
  double v30; // st5
  double v31; // st4
  double v32; // st4
  double v33; // st3
  double v34; // st2
  double v35; // st1
  double v36; // st3
  double v37; // st4
  double v38; // st5
  __int64 v39; // rax
  double v40; // st5
  __int64 v41; // rax
  double v42; // st5
  char result; // al
  bool v44; // cc
  char v45; // [esp+Ch] [ebp-118h] BYREF
  char v46; // [esp+14h] [ebp-110h] BYREF
  int v47; // [esp+10Ch] [ebp-18h]
  float v48; // [esp+110h] [ebp-14h]
  int v49; // [esp+114h] [ebp-10h]
  float v50; // [esp+118h] [ebp-Ch]
  float v51; // [esp+11Ch] [ebp-8h]
  float v52; // [esp+120h] [ebp-4h]
  float v53; // [esp+12Ch] [ebp+8h]
  float v54; // [esp+12Ch] [ebp+8h]
  float v55; // [esp+12Ch] [ebp+8h]
  float v56; // [esp+130h] [ebp+Ch]
  float v57; // [esp+130h] [ebp+Ch]
  float v58; // [esp+130h] [ebp+Ch]
  float v59; // [esp+130h] [ebp+Ch]
  float v60; // [esp+130h] [ebp+Ch]
  float v61; // [esp+130h] [ebp+Ch]
  int v62; // [esp+134h] [ebp+10h]
  float v63; // [esp+134h] [ebp+10h]
  float v64; // [esp+134h] [ebp+10h]
  float v65; // [esp+134h] [ebp+10h]

  v49 = *(_DWORD *)(a1 + 284) + 128;
  v6 = *(float **)(a2 + 80);
  v7 = (float *)&v45;
  v47 = 8;
  do
  {
    v8 = a3[56];
    v9 = a3[48];
    v10 = (double)*a3 * *v6;
    if ( (unsigned __int16)v8 | (unsigned __int16)(v9 | a3[40] | a3[32] | a3[24] | a3[16] | a3[8]) )
    {
      v53 = v6[16] * (double)a3[16];
      v62 = v9;
      v11 = a3[8];
      v12 = v6[32] * (double)a3[32];
      v63 = v6[48] * (double)v62;
      v56 = v12 + v10;
      v13 = v10 - v12;
      v14 = v63 + v53;
      v15 = (v53 - v63) * 1.4142135 - v14;
      v48 = v14 + v56;
      v64 = v56 - v14;
      v54 = v15 + v13;
      v16 = v13 - v15;
      v17 = v6[8] * (double)v11;
      v18 = v6[24] * (double)a3[24];
      v19 = v6[40] * (double)a3[40];
      LODWORD(v50) = v8;
      v57 = v19;
      v20 = v6[56] * (double)v8;
      v51 = v57 + v18;
      v58 = v57 - v18;
      v52 = v20 + v17;
      v21 = v17 - v20;
      v22 = v52 + v51;
      v50 = (v21 + v58) * 1.847759;
      v23 = v50 - v58 * 2.613126 - v22;
      v24 = (v52 - v51) * 1.4142135 - v23;
      v52 = v24;
      v51 = v21 * 1.0823922 - v50 + v24;
      *v7 = v22 + v48;
      v7[56] = v48 - v22;
      v7[8] = v54 + v23;
      v7[48] = v54 - v23;
      v7[16] = v52 + v16;
      v7[40] = v16 - v52;
      v7[32] = v51 + v64;
      v7[24] = v64 - v51;
    }
    else
    {
      *v7 = v10;
      v7[8] = v10;
      v7[16] = v10;
      v7[24] = v10;
      v7[32] = v10;
      v7[40] = v10;
      v7[48] = v10;
      v7[56] = v10;
    }
    ++v6;
    ++a3;
    ++v7;
    --v47;
  }
  while ( *(float *)&v47 != 0.0 );
  v50 = 0.0;
  v25 = (float *)&v46;
  do
  {
    v26 = (_BYTE *)(a5 + *(_DWORD *)(a4 + 4 * LODWORD(v50)));
    v59 = v25[2] + *(v25 - 2);
    v27 = *(v25 - 2) - v25[2];
    v28 = *v25 + v25[4];
    v29 = (*v25 - v25[4]) * 1.4142135 - v28;
    v48 = v28 + v59;
    v65 = v59 - v28;
    v55 = v29 + v27;
    v30 = v27 - v29;
    v31 = v25[3] + v25[1];
    v51 = v31;
    v60 = v25[3] - v25[1];
    v52 = v25[5] + *(v25 - 1);
    *(float *)&v47 = *(v25 - 1) - v25[5];
    v32 = v31 + v52;
    v33 = (*(float *)&v47 + v60) * 1.847759;
    v34 = v33 - v60 * 2.613126 - v32;
    v61 = v34;
    v35 = (v52 - v51) * 1.4142135 - v34;
    v52 = v35;
    v51 = *(float *)&v47 * 1.0823922 - v33 + v35;
    v36 = v48 - v32;
    *v26 = *(_BYTE *)((((int)((__int64)(v48 + v32) + 4) >> 3) & 0x3FF) + v49);
    v26[7] = *(_BYTE *)((((int)((__int64)v36 + 4) >> 3) & 0x3FF) + v49);
    v26[1] = *(_BYTE *)((((int)((__int64)(v61 + v55) + 4) >> 3) & 0x3FF) + v49);
    v37 = v52 + v30;
    v26[6] = *(_BYTE *)((((int)((__int64)(v55 - v61) + 4) >> 3) & 0x3FF) + v49);
    v38 = v30 - v52;
    v26[2] = *(_BYTE *)((((int)((__int64)v37 + 4) >> 3) & 0x3FF) + v49);
    v39 = (__int64)v38;
    v40 = v51 + v65;
    v26[5] = *(_BYTE *)(((((int)v39 + 4) >> 3) & 0x3FF) + v49);
    v41 = (__int64)v40;
    v42 = v65 - v51;
    v26[4] = *(_BYTE *)(((((int)v41 + 4) >> 3) & 0x3FF) + v49);
    result = *(_BYTE *)((((int)((__int64)v42 + 4) >> 3) & 0x3FF) + v49);
    v25 += 8;
    v44 = ++LODWORD(v50) < 8;
    v26[3] = result;
  }
  while ( v44 );
  return result;
}

// inflate_codes_new @ 0x10036381
// zlib (internal): allocate codes state
int __cdecl sub_10036381(char a1, char a2, int a3, int a4, int a5)
{
  int result; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( result )
  {
    *(_DWORD *)result = 0;
    *(_BYTE *)(result + 16) = a1;
    *(_BYTE *)(result + 17) = a2;
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
  }
  return result;
}

// inflate_codes @ 0x100363B5
// zlib (internal): decode codes
int __cdecl sub_100363B5(_DWORD *a1, _DWORD *a2, int a3)
{
  _BYTE *v5; // edx
  int v6; // ebx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v9; // eax
  unsigned int v10; // eax
  int v11; // eax
  unsigned int v12; // eax
  unsigned __int8 *v13; // eax
  unsigned __int8 *v14; // eax
  unsigned int v15; // eax
  int v16; // ecx
  unsigned int v17; // eax
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  int v20; // eax
  unsigned int v21; // eax
  int v22; // ecx
  unsigned int v23; // eax
  unsigned int v24; // eax
  unsigned int v25; // ecx
  int v26; // eax
  unsigned int v27; // eax
  unsigned int v28; // ecx
  unsigned int v29; // eax
  unsigned int v30; // ecx
  int v31; // eax
  unsigned int v32; // eax
  unsigned int v33; // ecx
  unsigned __int8 *v34; // ecx
  int v36; // eax
  unsigned __int8 *v37; // ebx
  int v38; // [esp-4h] [ebp-28h]
  int v39; // [esp+Ch] [ebp-18h]
  unsigned int v40; // [esp+Ch] [ebp-18h]
  unsigned int v41; // [esp+Ch] [ebp-18h]
  _BYTE *v42; // [esp+10h] [ebp-14h]
  _BYTE *v43; // [esp+14h] [ebp-10h]
  _BYTE *v44; // [esp+14h] [ebp-10h]
  unsigned int v45; // [esp+18h] [ebp-Ch]
  unsigned int v46; // [esp+1Ch] [ebp-8h]
  unsigned __int8 *v47; // [esp+20h] [ebp-4h]
  unsigned int v48; // [esp+2Ch] [ebp+8h]
  unsigned int v49; // [esp+30h] [ebp+Ch]
  int v50; // [esp+34h] [ebp+10h]

  v47 = (unsigned __int8 *)*a2;
  v5 = (_BYTE *)a1[13];
  v6 = a1[1];
  v46 = a2[1];
  v49 = a1[8];
  v48 = a1[7];
  v7 = a1[12];
  if ( (unsigned int)v5 >= v7 )
    v8 = a1[11] - (_DWORD)v5;
  else
    v8 = v7 - (_DWORD)v5 - 1;
LABEL_83:
  v45 = v8;
  while ( 2 )
  {
    switch ( *(_DWORD *)v6 )
    {
      case 0:
        if ( v8 >= 0x102 && v46 >= 0xA )
        {
          a1[8] = v49;
          a1[7] = v48;
          a2[1] = v46;
          a2[2] += &v47[-*a2];
          *a2 = v47;
          a1[13] = v5;
          v9 = sub_10038BBD(
                 *(unsigned __int8 *)(v6 + 16),
                 *(unsigned __int8 *)(v6 + 17),
                 *(_DWORD *)(v6 + 20),
                 *(_DWORD *)(v6 + 24),
                 a1,
                 a2);
          v5 = (_BYTE *)a1[13];
          a3 = v9;
          v47 = (unsigned __int8 *)*a2;
          v46 = a2[1];
          v49 = a1[8];
          v48 = a1[7];
          v10 = a1[12];
          v11 = (unsigned int)v5 >= v10 ? a1[11] - (_DWORD)v5 : v10 - (_DWORD)v5 - 1;
          v45 = v11;
          if ( a3 )
          {
            *(_DWORD *)v6 = 2 * (a3 != 1) + 7;
            goto LABEL_36;
          }
        }
        *(_DWORD *)(v6 + 12) = *(unsigned __int8 *)(v6 + 16);
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 20);
        *(_DWORD *)v6 = 1;
        goto LABEL_15;
      case 1:
LABEL_15:
        while ( 2 )
        {
          v12 = *(_DWORD *)(v6 + 12);
          if ( v48 >= v12 )
          {
            v13 = (unsigned __int8 *)(*(_DWORD *)(v6 + 8) + 8 * (v49 & dword_10057020[v12]));
            v49 >>= v13[1];
            v48 -= v13[1];
            v39 = *v13;
            if ( *v13 )
            {
              if ( (v39 & 0x10) != 0 )
              {
                *(_DWORD *)(v6 + 8) = v39 & 0xF;
                *(_DWORD *)(v6 + 4) = *((_DWORD *)v13 + 1);
                *(_DWORD *)v6 = 2;
                goto LABEL_36;
              }
              if ( (v39 & 0x40) != 0 )
              {
                if ( (v39 & 0x20) != 0 )
                {
                  *(_DWORD *)v6 = 7;
                  goto LABEL_36;
                }
                *(_DWORD *)v6 = 9;
                a2[6] = "invalid literal/length code";
LABEL_89:
                v38 = -3;
                goto LABEL_85;
              }
              *(_DWORD *)(v6 + 12) = v39;
              v14 = &v13[8 * *((_DWORD *)v13 + 1)];
            }
            else
            {
              v14 = (unsigned __int8 *)*((_DWORD *)v13 + 1);
              *(_DWORD *)v6 = 6;
            }
            goto LABEL_35;
          }
          if ( v46 )
          {
            a3 = 0;
            --v46;
            v49 |= *v47++ << v48;
            v48 += 8;
            continue;
          }
          goto LABEL_91;
        }
      case 2:
        while ( 2 )
        {
          v15 = *(_DWORD *)(v6 + 8);
          if ( v48 < v15 )
          {
            if ( v46 )
            {
              a3 = 0;
              --v46;
              v49 |= *v47++ << v48;
              v48 += 8;
              continue;
            }
LABEL_91:
            v38 = a3;
            a1[8] = v49;
            a1[7] = v48;
            a2[1] = 0;
            goto LABEL_86;
          }
          break;
        }
        v16 = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v6 + 4) += v49 & dword_10057020[v15];
        v49 >>= v16;
        v48 -= v16;
        *(_DWORD *)(v6 + 12) = *(unsigned __int8 *)(v6 + 17);
        *(_DWORD *)(v6 + 8) = *(_DWORD *)(v6 + 24);
        *(_DWORD *)v6 = 3;
LABEL_30:
        while ( 1 )
        {
          v17 = *(_DWORD *)(v6 + 12);
          if ( v48 >= v17 )
            break;
          if ( !v46 )
            goto LABEL_91;
          a3 = 0;
          --v46;
          v49 |= *v47++ << v48;
          v48 += 8;
        }
        v18 = (unsigned __int8 *)(*(_DWORD *)(v6 + 8) + 8 * (v49 & dword_10057020[v17]));
        v49 >>= v18[1];
        v48 -= v18[1];
        v19 = v18;
        v20 = *v18;
        if ( (v20 & 0x10) != 0 )
        {
          *(_DWORD *)(v6 + 8) = v20 & 0xF;
          *(_DWORD *)(v6 + 12) = *((_DWORD *)v19 + 1);
          *(_DWORD *)v6 = 4;
          goto LABEL_36;
        }
        if ( (v20 & 0x40) != 0 )
        {
          *(_DWORD *)v6 = 9;
          a2[6] = "invalid distance code";
          goto LABEL_89;
        }
        *(_DWORD *)(v6 + 12) = v20;
        v14 = &v19[8 * *((_DWORD *)v19 + 1)];
LABEL_35:
        *(_DWORD *)(v6 + 8) = v14;
LABEL_36:
        v8 = v45;
        continue;
      case 3:
        goto LABEL_30;
      case 4:
        while ( 2 )
        {
          v21 = *(_DWORD *)(v6 + 8);
          if ( v48 < v21 )
          {
            if ( v46 )
            {
              a3 = 0;
              --v46;
              v49 |= *v47++ << v48;
              v48 += 8;
              continue;
            }
            goto LABEL_91;
          }
          break;
        }
        v22 = *(_DWORD *)(v6 + 8);
        *(_DWORD *)(v6 + 12) += v49 & dword_10057020[v21];
        v49 >>= v22;
        v48 -= v22;
        *(_DWORD *)v6 = 5;
LABEL_41:
        v23 = *(_DWORD *)(v6 + 12);
        if ( (unsigned int)&v5[-a1[10]] >= v23 )
          v42 = &v5[-v23];
        else
          v42 = &v5[a1[11] - a1[10] - *(_DWORD *)(v6 + 12)];
        v8 = v45;
LABEL_45:
        if ( !*(_DWORD *)(v6 + 4) )
        {
          *(_DWORD *)v6 = 0;
          continue;
        }
        if ( v8 )
          goto LABEL_62;
        if ( v5 == (_BYTE *)a1[11] )
        {
          v24 = a1[12];
          v25 = a1[10];
          if ( v24 != v25 )
          {
            v5 = (_BYTE *)a1[10];
            v8 = v25 >= v24 ? a1[11] - v25 : v24 - v25 - 1;
            if ( v8 )
              goto LABEL_62;
          }
        }
        a1[13] = v5;
        v26 = inflate_flush(a1, a2, a3);
        v5 = (_BYTE *)a1[13];
        v50 = v26;
        v27 = a1[12];
        v40 = v27;
        if ( (unsigned int)v5 >= v27 )
          v8 = a1[11] - (_DWORD)v5;
        else
          v8 = v27 - (_DWORD)v5 - 1;
        v43 = (_BYTE *)a1[11];
        if ( v5 == v43 )
        {
          v28 = a1[10];
          if ( v40 != v28 )
          {
            v5 = (_BYTE *)a1[10];
            if ( v28 >= v40 )
              v8 = (unsigned int)&v43[-v28];
            else
              v8 = v40 - v28 - 1;
          }
        }
        if ( v8 )
        {
LABEL_62:
          a3 = 0;
          *v5++ = *v42++;
          v45 = --v8;
          if ( v42 == (_BYTE *)a1[11] )
            v42 = (_BYTE *)a1[10];
          --*(_DWORD *)(v6 + 4);
          goto LABEL_45;
        }
LABEL_92:
        v38 = v50;
LABEL_85:
        a1[8] = v49;
        a1[7] = v48;
        a2[1] = v46;
LABEL_86:
        v34 = &v47[-*a2];
        *a2 = v47;
        a2[2] += v34;
LABEL_87:
        a1[13] = v5;
        return inflate_flush(a1, a2, v38);
      case 5:
        goto LABEL_41;
      case 6:
        if ( !v8 )
        {
          if ( v5 != (_BYTE *)a1[11]
            || (v29 = a1[12], v30 = a1[10], v29 == v30)
            || ((v5 = (_BYTE *)a1[10], v30 >= v29) ? (v8 = a1[11] - v30) : (v8 = v29 - v30 - 1), !v8) )
          {
            a1[13] = v5;
            v31 = inflate_flush(a1, a2, a3);
            v5 = (_BYTE *)a1[13];
            v50 = v31;
            v32 = a1[12];
            v41 = v32;
            if ( (unsigned int)v5 >= v32 )
              v8 = a1[11] - (_DWORD)v5;
            else
              v8 = v32 - (_DWORD)v5 - 1;
            v44 = (_BYTE *)a1[11];
            if ( v5 == v44 )
            {
              v33 = a1[10];
              if ( v41 != v33 )
              {
                v5 = (_BYTE *)a1[10];
                if ( v33 >= v41 )
                  v8 = (unsigned int)&v44[-v33];
                else
                  v8 = v41 - v33 - 1;
              }
            }
            if ( !v8 )
              goto LABEL_92;
          }
        }
        a3 = 0;
        *v5++ = *(_BYTE *)(v6 + 8);
        --v8;
        *(_DWORD *)v6 = 0;
        goto LABEL_83;
      case 7:
        if ( v48 > 7 )
        {
          v48 -= 8;
          ++v46;
          --v47;
        }
        a1[13] = v5;
        v36 = inflate_flush(a1, a2, a3);
        v5 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] != v5 )
        {
          a1[8] = v49;
          a1[7] = v48;
          a2[1] = v46;
          v37 = &v47[-*a2];
          *a2 = v47;
          a2[2] += v37;
          v38 = v36;
          goto LABEL_87;
        }
        *(_DWORD *)v6 = 8;
LABEL_98:
        v38 = 1;
        goto LABEL_85;
      case 8:
        goto LABEL_98;
      case 9:
        goto LABEL_89;
      default:
        v38 = -2;
        goto LABEL_85;
    }
  }
}

// inflate_codes_free @ 0x10036919
// zlib (internal): free codes state
int __cdecl sub_10036919(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

// huft_build @ 0x1003692A
// zlib (internal): build Huffman decoding tables
int __usercall sub_1003692A@<eax>(
        unsigned int *a1@<eax>,
        _DWORD *a2,
        unsigned int a3,
        unsigned int a4,
        int a5,
        int a6,
        _DWORD *a7,
        int a8,
        unsigned int *a9,
        unsigned int *a10)
{
  _DWORD *v10; // ecx
  unsigned int v12; // edx
  unsigned int v14; // ebx
  unsigned int v15; // ecx
  unsigned int v16; // eax
  int v17; // edx
  int v18; // edx
  unsigned int v19; // esi
  int *v20; // ecx
  int v21; // ebx
  int v22; // edx
  int v23; // ecx
  unsigned int v24; // eax
  int v25; // ebx
  int *v26; // ecx
  unsigned int v27; // ebx
  int v28; // eax
  int *v29; // eax
  int v30; // ecx
  int v31; // eax
  int v32; // ebx
  unsigned int v33; // eax
  unsigned int j; // ecx
  unsigned int v35; // esi
  unsigned int v36; // ecx
  unsigned int v37; // eax
  unsigned int v38; // eax
  _DWORD *v39; // edx
  unsigned int v40; // edx
  unsigned int v41; // eax
  unsigned int v42; // eax
  unsigned int v43; // esi
  _DWORD *v44; // edx
  unsigned int v45; // esi
  unsigned int v46; // eax
  int v47; // ecx
  int v48; // edx
  unsigned int v49; // eax
  int v50; // eax
  int v51; // esi
  unsigned int v52; // eax
  _DWORD *v53; // ecx
  unsigned int v54; // esi
  unsigned int i; // eax
  int v56; // ecx
  int v57; // eax
  _DWORD v59[15]; // [esp+Ch] [ebp-A4h] BYREF
  int v60; // [esp+48h] [ebp-68h] BYREF
  _DWORD v61[15]; // [esp+4Ch] [ebp-64h]
  int v62; // [esp+88h] [ebp-28h] BYREF
  _DWORD v63[15]; // [esp+8Ch] [ebp-24h] BYREF
  unsigned int v64; // [esp+C8h] [ebp+18h]
  signed int v65; // [esp+CCh] [ebp+1Ch]
  int v66; // [esp+D0h] [ebp+20h]
  int v67; // [esp+D4h] [ebp+24h]
  signed int v68; // [esp+D8h] [ebp+28h]
  int v69; // [esp+DCh] [ebp+2Ch]
  _DWORD *v70; // [esp+E0h] [ebp+30h]
  unsigned int v71; // [esp+E4h] [ebp+34h]
  int v72; // [esp+E8h] [ebp+38h]
  int v73; // [esp+ECh] [ebp+3Ch]
  unsigned int v74; // [esp+F0h] [ebp+40h]
  unsigned int v75; // [esp+F4h] [ebp+44h]
  int v76; // [esp+F8h] [ebp+48h]
  signed int v77; // [esp+FCh] [ebp+4Ch]
  unsigned int v78; // [esp+100h] [ebp+50h]
  int *v79; // [esp+10Ch] [ebp+5Ch]
  unsigned int *v80; // [esp+10Ch] [ebp+5Ch]
  int v81; // [esp+110h] [ebp+60h]

  v10 = a2;
  v62 = 0;
  memset(v63, 0, sizeof(v63));
  v12 = a3;
  do
  {
    ++v63[*v10++ - 1];
    --v12;
  }
  while ( v12 );
  if ( v62 != a3 )
  {
    v14 = *a1;
    v78 = *a1;
    v15 = 1;
    v16 = 15;
    do
    {
      if ( v63[v15 - 1] )
        break;
      ++v15;
    }
    while ( v15 <= 0xF );
    v77 = v15;
    if ( v14 < v15 )
      v78 = v15;
    do
    {
      if ( v63[v16 - 1] )
        break;
      --v16;
    }
    while ( v16 );
    v68 = v16;
    if ( v78 > v16 )
      v78 = v16;
    *a1 = v78;
    v17 = 1 << v15;
    while ( v15 < v16 )
    {
      v18 = v17 - v63[v15 - 1];
      if ( v18 < 0 )
        return -3;
      ++v15;
      v17 = 2 * v18;
    }
    v19 = v16;
    v20 = &v63[v16 - 1];
    v21 = *v20;
    v22 = v17 - *v20;
    v66 = v22;
    if ( v22 < 0 )
      return -3;
    *v20 = v22 + v21;
    v23 = 0;
    v24 = v16 - 1;
    v61[0] = 0;
    if ( v24 )
    {
      v25 = 0;
      do
      {
        v23 += v63[v25++];
        --v24;
        v61[v25] = v23;
      }
      while ( v24 );
    }
    v26 = a2;
    v27 = 0;
    do
    {
      v28 = *v26++;
      v79 = v26;
      if ( v28 )
      {
        v29 = &v61[v28 - 1];
        v30 = *v29;
        a10[v30] = v27;
        v22 = v66;
        *v29 = v30 + 1;
        v26 = v79;
      }
      ++v27;
    }
    while ( v27 < a3 );
    v31 = v61[v19 - 1];
    v76 = -1;
    v81 = v31;
    v80 = a10;
    v32 = -v78;
    v71 = 0;
    v60 = 0;
    v59[0] = 0;
    v69 = 0;
    v75 = 0;
    if ( v77 > v68 )
    {
LABEL_68:
      if ( !v22 || v68 == 1 )
        return 0;
      return -5;
    }
    else
    {
      v67 = v77 - 1;
      v70 = &v63[v77 - 1];
      while ( 1 )
      {
        v72 = *v70;
        if ( v72 )
          break;
LABEL_67:
        ++v77;
        ++v70;
        ++v67;
        if ( v77 > v68 )
          goto LABEL_68;
      }
      while ( 1 )
      {
        --v72;
        v33 = v32 + v78;
        if ( v77 > (int)(v32 + v78) )
          break;
LABEL_50:
        BYTE1(v73) = v77 - v32;
        if ( v80 < &a10[v81] )
        {
          v49 = *v80;
          if ( *v80 >= a4 )
          {
            v50 = 4 * (v49 - a4);
            LOBYTE(v73) = *(_BYTE *)(v50 + a6) + 80;
            v49 = *(_DWORD *)(v50 + a5);
          }
          else
          {
            LOBYTE(v73) = v49 < 0x100 ? 0 : 0x60;
          }
          ++v80;
          v74 = v49;
        }
        else
        {
          LOBYTE(v73) = -64;
        }
        v51 = 1 << (v77 - v32);
        v52 = v71 >> v32;
        if ( v71 >> v32 < v75 )
        {
          v53 = (_DWORD *)(v69 + 8 * v52);
          do
          {
            *v53 = v73;
            v53[1] = v74;
            v52 += v51;
            v53 += 2 * v51;
          }
          while ( v52 < v75 );
          v22 = v66;
        }
        v54 = v71;
        for ( i = 1 << v67; (i & v54) != 0; i >>= 1 )
          v54 ^= i;
        v71 = i ^ v54;
        v56 = (i ^ v54) & ((1 << v32) - 1);
        v57 = v76;
        if ( v56 != v61[v76 - 1] )
        {
          do
          {
            v32 -= v78;
            --v57;
          }
          while ( (v71 & ((1 << v32) - 1)) != v61[v57 - 1] );
          v76 = v57;
        }
        if ( !v72 )
          goto LABEL_67;
      }
      for ( j = v32 - v78; ; j = v64 )
      {
        ++v76;
        v32 += v78;
        v35 = v68 - v32;
        v64 = v78 + j;
        v65 = v78 + v33;
        if ( v68 - v32 > v78 )
          v35 = v78;
        v36 = v77 - v32;
        v37 = 1 << (v77 - v32);
        if ( v37 > v72 + 1 )
        {
          v38 = -1 - v72 + v37;
          v39 = v70;
          if ( v36 < v35 && ++v36 < v35 )
          {
            while ( 1 )
            {
              v75 = (unsigned int)(v39 + 1);
              v40 = v39[1];
              v41 = 2 * v38;
              if ( v41 <= v40 )
                break;
              v38 = v41 - v40;
              if ( ++v36 >= v35 )
                break;
              v39 = (_DWORD *)v75;
            }
          }
        }
        v42 = *a9;
        v43 = *a9 + (1 << v36);
        v75 = 1 << v36;
        if ( v43 > 0x5A0 )
          break;
        v44 = &v59[v76];
        v69 = a8 + 8 * v42;
        *v44 = v69;
        *a9 = v43;
        if ( v76 )
        {
          v45 = v71;
          v61[v76 - 1] = v71;
          BYTE1(v73) = v78;
          LOBYTE(v73) = v36;
          v46 = v45 >> v64;
          v47 = *(v44 - 1);
          v48 = ((v69 - v47) >> 3) - (v45 >> v64);
          *(_DWORD *)(v47 + 8 * v46) = v73;
          v74 = v48;
          *(_DWORD *)(v47 + 8 * v46 + 4) = v48;
        }
        else
        {
          *a7 = v69;
        }
        v33 = v65;
        if ( v77 <= v65 )
        {
          v22 = v66;
          goto LABEL_50;
        }
      }
      return -4;
    }
  }
  *a7 = 0;
  *a1 = 0;
  return 0;
}

// inflate_trees_bits @ 0x10036CAF
// zlib (internal): build bit length Huffman tree
int __cdecl sub_10036CAF(_DWORD *a1, unsigned int *a2, _DWORD *a3, int a4, int a5)
{
  unsigned int *v6; // eax
  int v8; // eax
  int v9; // ebx
  unsigned int v10; // [esp+4h] [ebp-4h] BYREF
  unsigned int *v11; // [esp+20h] [ebp+18h]

  v10 = 0;
  v6 = (unsigned int *)(*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  v11 = v6;
  if ( !v6 )
    return -4;
  v8 = huft_build(a2, a1, 0x13u, 0x13u, 0, 0, a3, a4, &v10, v6);
  v9 = v8;
  if ( v8 == -3 )
  {
    *(_DWORD *)(a5 + 24) = "oversubscribed dynamic bit lengths tree";
  }
  else if ( v8 == -5 || !*a2 )
  {
    *(_DWORD *)(a5 + 24) = "incomplete dynamic bit lengths tree";
    v9 = -3;
  }
  (*(void (__cdecl **)(_DWORD, unsigned int *))(a5 + 36))(*(_DWORD *)(a5 + 40), v11);
  return v9;
}

// inflate_trees_dynamic @ 0x10036D2E
// zlib (internal): build dynamic Huffman trees
int __cdecl sub_10036D2E(
        unsigned int a1,
        unsigned int a2,
        _DWORD *a3,
        unsigned int *a4,
        unsigned int *a5,
        _DWORD *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v10; // eax
  int v12; // eax
  int v13; // edi
  unsigned int v14; // [esp+4h] [ebp-4h] BYREF
  unsigned int *v15; // [esp+30h] [ebp+28h]

  v14 = 0;
  v10 = (unsigned int *)(*(int (__cdecl **)(_DWORD, int, int))(a9 + 32))(*(_DWORD *)(a9 + 40), 288, 4);
  v15 = v10;
  if ( !v10 )
    return -4;
  v12 = huft_build(a4, a3, a1, 0x101u, (int)&unk_1004F868, (int)&unk_1004F8E8, a6, a8, &v14, v10);
  if ( v12 )
  {
    if ( v12 == -3 )
    {
      *(_DWORD *)(a9 + 24) = "oversubscribed literal/length tree";
      goto LABEL_20;
    }
    if ( v12 == -4 )
      goto LABEL_20;
LABEL_18:
    *(_DWORD *)(a9 + 24) = "incomplete literal/length tree";
    goto LABEL_19;
  }
  if ( !*a4 )
    goto LABEL_18;
  v12 = huft_build(a5, &a3[a1], a2, 0, (int)&unk_1004F968, (int)&unk_1004F9E0, a7, a8, &v14, v15);
  if ( v12 )
  {
    switch ( v12 )
    {
      case -3:
        *(_DWORD *)(a9 + 24) = "oversubscribed distance tree";
        break;
      case -5:
        *(_DWORD *)(a9 + 24) = "incomplete distance tree";
LABEL_19:
        v12 = -3;
        break;
      case -4:
        break;
      default:
LABEL_14:
        *(_DWORD *)(a9 + 24) = "empty distance tree with lengths";
        goto LABEL_19;
    }
LABEL_20:
    v13 = v12;
    goto LABEL_21;
  }
  if ( !*a5 && a1 > 0x101 )
    goto LABEL_14;
  v13 = 0;
LABEL_21:
  (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v15);
  return v13;
}

// sub_10036E31 @ 0x10036E31
int __cdecl sub_10036E31(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_10055F18;
  *a2 = dword_10055F1C;
  *a3 = &unk_10055F20;
  *a4 = &unk_10056F20;
  return 0;
}

// inflate_flush @ 0x10036E60
// zlib (internal): flush pending output
int __cdecl sub_10036E60(_DWORD *a1, _DWORD *a2, int a3)
{
  char *v4; // edx
  unsigned int v5; // edi
  unsigned int v6; // eax
  unsigned int v7; // edi
  int (__cdecl *v8)(_DWORD, char *, unsigned int); // eax
  int v9; // eax
  char v10; // al
  unsigned int v11; // ecx
  char *v12; // edi
  char *v13; // eax
  char *v14; // edx
  unsigned int v15; // eax
  unsigned int v16; // edi
  int (__cdecl *v17)(_DWORD, char *, unsigned int); // eax
  int v18; // eax
  char v19; // al
  unsigned int v20; // ecx
  char *v21; // edi
  char *v23; // [esp+Ch] [ebp-8h]
  char *v24; // [esp+Ch] [ebp-8h]
  unsigned int v25; // [esp+10h] [ebp-4h]
  unsigned int v26; // [esp+10h] [ebp-4h]
  char *v27; // [esp+1Ch] [ebp+8h]
  char *v28; // [esp+1Ch] [ebp+8h]
  char *v29; // [esp+1Ch] [ebp+8h]

  v4 = (char *)a1[12];
  v5 = a1[13];
  v23 = (char *)a2[3];
  v27 = v4;
  if ( (unsigned int)v4 > v5 )
    v5 = a1[11];
  v6 = a2[4];
  v7 = v5 - (_DWORD)v4;
  v25 = v7;
  if ( v7 > v6 )
  {
    v25 = a2[4];
    v7 = v25;
  }
  if ( v7 && a3 == -5 )
    a3 = 0;
  a2[5] += v7;
  a2[4] = v6 - v7;
  v8 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
  if ( v8 )
  {
    v9 = v8(a1[15], v4, v7);
    v4 = v27;
    a1[15] = v9;
    a2[12] = v9;
  }
  v10 = v7;
  v11 = v7 >> 2;
  qmemcpy(v23, v4, 4 * (v7 >> 2));
  v12 = &v23[4 * (v7 >> 2)];
  v24 = &v23[v25];
  v28 = &v27[v25];
  qmemcpy(v12, &v4[4 * v11], v10 & 3);
  v13 = (char *)a1[11];
  if ( v28 == v13 )
  {
    v14 = (char *)a1[10];
    v29 = v14;
    if ( (char *)a1[13] == v13 )
      a1[13] = v14;
    v15 = a2[4];
    v16 = a1[13] - (_DWORD)v14;
    v26 = v16;
    if ( v16 > v15 )
    {
      v26 = a2[4];
      v16 = v26;
    }
    if ( v16 && a3 == -5 )
      a3 = 0;
    a2[5] += v16;
    a2[4] = v15 - v16;
    v17 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
    if ( v17 )
    {
      v18 = v17(a1[15], v14, v16);
      v14 = v29;
      a1[15] = v18;
      a2[12] = v18;
    }
    v19 = v16;
    v20 = v16 >> 2;
    qmemcpy(v24, v14, 4 * (v16 >> 2));
    v21 = &v24[4 * (v16 >> 2)];
    v24 += v26;
    v28 = &v29[v26];
    qmemcpy(v21, &v14[4 * v20], v19 & 3);
  }
  a2[3] = v24;
  a1[12] = v28;
  return a3;
}

// sub_10036F75 @ 0x10036F75
int __cdecl sub_10036F75(__int16 *a1, __int16 *a2, int *a3, int a4, int a5, int a6)
{
  int v6; // ecx
  int v7; // ebx
  int v8; // eax
  int v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ebx
  int v16; // edx
  int v17; // esi
  int v18; // ecx
  int v19; // ebx
  int v20; // eax
  int v21; // ecx
  int v22; // eax
  int v23; // edx
  int v24; // ecx
  int v25; // esi
  int v26; // edi
  int *v27; // edi
  int v28; // ecx
  int v29; // ebx
  int v30; // eax
  int v31; // ebx
  int v32; // edx
  int v33; // ebx
  int v34; // edx
  int v35; // eax
  int v36; // edx
  int v37; // esi
  int v38; // ecx
  int v39; // ebx
  int v40; // eax
  int v41; // ecx
  int v42; // eax
  int v43; // edx
  int v44; // esi
  int result; // eax
  int *v48; // [esp+14h] [ebp-3Ch]
  int *v49; // [esp+14h] [ebp-3Ch]
  int v50; // [esp+18h] [ebp-38h]
  int v51; // [esp+18h] [ebp-38h]
  int v52; // [esp+1Ch] [ebp-34h]
  int v53; // [esp+1Ch] [ebp-34h]
  int v54; // [esp+1Ch] [ebp-34h]
  int v55; // [esp+1Ch] [ebp-34h]
  int v56; // [esp+1Ch] [ebp-34h]
  int v57; // [esp+20h] [ebp-30h]
  int v58; // [esp+20h] [ebp-30h]
  int v59; // [esp+20h] [ebp-30h]
  int v60; // [esp+20h] [ebp-30h]
  int v61; // [esp+24h] [ebp-2Ch]
  int v62; // [esp+24h] [ebp-2Ch]
  int v63; // [esp+28h] [ebp-28h]
  int v64; // [esp+28h] [ebp-28h]
  int v65; // [esp+2Ch] [ebp-24h]
  int v66; // [esp+2Ch] [ebp-24h]
  int v67; // [esp+30h] [ebp-20h]
  int v68; // [esp+30h] [ebp-20h]
  int v69; // [esp+34h] [ebp-1Ch]
  int v70; // [esp+34h] [ebp-1Ch]
  int v71; // [esp+34h] [ebp-1Ch]
  int v72; // [esp+38h] [ebp-18h]
  int v73; // [esp+40h] [ebp-10h]
  int v74; // [esp+4Ch] [ebp-4h]

  v48 = a3;
  v50 = 8;
  do
  {
    v6 = a2[48] * a1[48];
    v7 = a2[16] * a1[16];
    v8 = 6270 * v7;
    v9 = 4433 * (v6 + v7);
    v52 = v9 - 15137 * v6;
    v57 = v9 + v8;
    v10 = *a2 * *a1;
    v11 = a2[32] * a1[32];
    v12 = (v10 + v11) << 13;
    v13 = (v10 - v11) << 13;
    v61 = v57 + v12;
    v63 = v52 + v13;
    v65 = v12 - v57;
    v67 = v13 - v52;
    v69 = a2[56] * a1[56];
    v53 = a2[24] * a1[24];
    v58 = a2[8] * a1[8];
    v14 = a2[40] * a1[40];
    v15 = v58 + v14;
    v16 = -20995 * (v53 + v14);
    v17 = 9633 * (v15 + v53 + v69);
    v18 = v17 - 16069 * (v53 + v69);
    v19 = v17 - 3196 * v15;
    v20 = v18 - 7373 * (v58 + v69);
    v21 = v16 + v18;
    v22 = 2446 * v69 + v20;
    v23 = 16819 * a2[40] * a1[40] + v19 + v16;
    v24 = 25172 * v53 + v21;
    v25 = 12299 * v58 + v19 - 7373 * (v58 + v69);
    v48[32] = (v65 - v22 + 1024) >> 11;
    v48[24] = (v65 + v22 + 1024) >> 11;
    v48[40] = (v67 - v23 + 1024) >> 11;
    v48[48] = (v63 - v24 + 1024) >> 11;
    v48[16] = (v67 + v23 + 1024) >> 11;
    v48[8] = (v63 + v24 + 1024) >> 11;
    v48[56] = (v61 - v25 + 1024) >> 11;
    *v48 = (v25 + v61 + 1024) >> 11;
    ++a1;
    ++v48;
    ++a2;
    --v50;
  }
  while ( v50 );
  v51 = 8;
  v74 = 0;
  v49 = a3;
  do
  {
    v26 = *(_DWORD *)(v74 + a4);
    v74 += 4;
    v27 = (int *)(a5 + v26);
    v28 = v49[6];
    v29 = v49[2];
    v30 = 6270 * v29;
    v31 = 4433 * (v28 + v29);
    v54 = v31 - 15137 * v28;
    v59 = v31 + v30;
    v32 = v49[4];
    v33 = (*v49 + v32) << 13;
    v34 = (*v49 - v32) << 13;
    v62 = v59 + v33;
    v64 = v54 + v34;
    v66 = v33 - v59;
    v68 = v34 - v54;
    v70 = v49[7];
    v55 = v49[3];
    v35 = v49[5];
    v60 = v49[1];
    v73 = 16819 * v35;
    v36 = -20995 * (v55 + v35);
    v37 = 9633 * (v60 + v35 + v55 + v70);
    v38 = v37 - 16069 * (v55 + v70);
    v39 = v37 - 3196 * (v60 + v35);
    v40 = v38 - 7373 * (v60 + v70);
    v41 = v36 + v38;
    v42 = 2446 * v70 + v40;
    v43 = v73 + v39 + v36;
    v44 = 12299 * v60 + v39 - 7373 * (v60 + v70);
    v71 = v42;
    v72 = v43;
    v56 = 25172 * v55 + v41;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v42 + v66 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v62 - v44 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v72 + v68 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v64 - v56 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v56 + v64 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v68 - v72 + 0x20000) >> 18) & 0x3FF));
    v42 <<= 8;
    v43 <<= 8;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((v44 + v62 + 0x20000) >> 18) & 0x3FF));
    LOBYTE(v43) = *(_BYTE *)(a6 + (((v66 - v71 + 0x20000) >> 18) & 0x3FF));
    *v27 = v42;
    v27[1] = v43;
    v49 += 8;
    result = --v51;
  }
  while ( v51 );
  return result;
}

// sub_100373D7 @ 0x100373D7
int __cdecl sub_100373D7(__m64 *a1, __m64 *a2, __m64 *a3, int a4, int a5, int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v8; // mm4
  __m64 v9; // mm5
  __m64 v10; // mm0
  __m64 v11; // mm6
  __m64 v12; // mm0
  __m64 v13; // mm6
  __m64 v14; // mm4
  __m64 v15; // mm3
  __m64 v16; // mm5
  __m64 v17; // mm6
  __m64 v18; // mm1
  __m64 v19; // mm0
  __m64 v20; // mm1
  __m64 v21; // mm6
  __m64 v22; // mm0
  __m64 v23; // mm6
  __m64 v24; // mm2
  __m64 v25; // mm1
  __m64 v26; // mm0
  __m64 v27; // mm2
  __m64 v28; // mm1
  __m64 v29; // mm3
  __m64 v30; // mm6
  __m64 v31; // mm4
  __m64 v32; // mm5
  __m64 v33; // mm7
  __m64 v34; // mm0
  __m64 v35; // mm2
  __m64 v36; // mm4
  __m64 v37; // mm1
  __m64 v38; // mm5
  __m64 v39; // mm3
  __m64 v40; // mm0
  __m64 v41; // mm7
  __m64 v42; // mm6
  __m64 v43; // mm1
  __m64 v44; // mm5
  __m64 v45; // mm2
  __m64 v46; // mm4
  __m64 v47; // mm6
  __m64 v48; // mm0
  __m64 v49; // mm1
  __m64 v50; // mm0
  __m64 v51; // mm2
  __m64 v52; // mm0
  __m64 v53; // mm1
  __m64 v54; // mm4
  __m64 v55; // mm7
  __m64 v56; // mm1
  __m64 v57; // mm0
  __m64 v58; // mm6
  __m64 v59; // mm2
  __m64 v60; // mm6
  __m64 v61; // mm0
  __m64 v62; // mm3
  __m64 v63; // mm1
  int result; // eax
  __m64 v65; // mm1
  __m64 v66; // mm4
  __m64 v67; // mm2
  __m64 v68; // mm5
  __m64 v69; // mm7
  __m64 v70; // mm5
  __m64 v71; // mm3
  __m64 v72; // mm4
  __m64 v73; // mm7
  __m64 v74; // mm5
  __m64 v75; // mm3
  __m64 v76; // mm5
  __m64 v77; // mm1
  __m64 v78; // mm0
  __m64 v79; // mm1
  __m64 v80; // mm3
  __m64 v81; // mm2
  __m64 v82; // mm1
  __m64 v83; // mm0
  int v84; // edi
  __m64 v85; // mm3
  unsigned int v86; // eax
  __m64 v87; // mm4
  __m64 v88; // mm2
  __m64 v89; // [esp+Ch] [ebp-9Ch]
  __m64 v90; // [esp+14h] [ebp-94h]
  __m64 v91; // [esp+1Ch] [ebp-8Ch]
  __m64 v92; // [esp+24h] [ebp-84h]
  __m64 v93; // [esp+2Ch] [ebp-7Ch]
  __m64 v94; // [esp+3Ch] [ebp-6Ch]
  __m64 v95; // [esp+44h] [ebp-64h]
  __m64 v96; // [esp+4Ch] [ebp-5Ch]
  __m64 v97; // [esp+5Ch] [ebp-4Ch]
  __m64 v98; // [esp+6Ch] [ebp-3Ch]
  __m64 v99; // [esp+74h] [ebp-34h]
  __m64 v100; // [esp+7Ch] [ebp-2Ch]
  __m64 v101; // [esp+84h] [ebp-24h]
  __m64 v102; // [esp+8Ch] [ebp-1Ch]
  __m64 v103; // [esp+9Ch] [ebp-Ch]
  __m64 v104; // [esp+ACh] [ebp+4h]
  __m64 v105; // [esp+B4h] [ebp+Ch]
  __m64 v106; // [esp+BCh] [ebp+14h]
  __m64 v107; // [esp+CCh] [ebp+24h]
  __m64 v108; // [esp+D4h] [ebp+2Ch]
  __m64 v109; // [esp+DCh] [ebp+34h]
  __m64 v110; // [esp+E4h] [ebp+3Ch]
  __m64 v111; // [esp+ECh] [ebp+44h]
  __m64 *v113; // [esp+F8h] [ebp+50h]
  __m64 *v114; // [esp+F8h] [ebp+50h]
  int v116; // [esp+100h] [ebp+58h]
  int v117; // [esp+104h] [ebp+5Ch]
  int v118; // [esp+104h] [ebp+5Ch]

  v117 = 2;
  v113 = a3;
  do
  {
    v6 = _m_pmullw(a1[4], a2[4]);
    v7 = _m_pmullw(a1[12], a2[12]);
    v8 = _m_pmaddwd(v6, (__m64)0x187E0000187ELL);
    v9 = _m_pmaddwd(_m_psrlqi(v6, 0x10u), (__m64)0x187E0000187ELL);
    v10 = _m_paddw(v6, v7);
    v11 = _m_psrlqi(v10, 0x10u);
    v12 = _m_pmaddwd(v10, (__m64)0x115100001151LL);
    v13 = _m_pmaddwd(v11, (__m64)0x115100001151LL);
    v14 = _m_paddd(v8, v12);
    v15 = _m_paddd(
            _m_paddd(
              _m_pxor(_m_pmaddwd(_m_psrlqi(v7, 0x10u), (__m64)0x3B2100003B21LL), (__m64)-1LL),
              (__m64)0x100000001LL),
            v13);
    v16 = _m_paddd(v9, v13);
    v89 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v7, (__m64)0x3B2100003B21LL), (__m64)-1LL), (__m64)0x100000001LL), v12);
    v17 = _m_pmullw(a1[8], a2[8]);
    v18 = _m_pmullw((__m64)a1->m64_u64, (__m64)a2->m64_u64);
    v19 = _m_paddw(v18, v17);
    v20 = _m_psubw(v18, v17);
    v21 = v19;
    v22 = _m_pslldi(_m_pmaddwd(v19, (__m64)0x100000001LL), 0xDu);
    v23 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v21, 0x10u), (__m64)0x100000001LL), 0xDu);
    v24 = _m_pslldi(_m_pmaddwd(_m_psrlqi(v20, 0x10u), (__m64)0x100000001LL), 0xDu);
    v91 = _m_psubd(v22, v14);
    v93 = _m_paddd(v16, v23);
    v94 = _m_psubd(v23, v16);
    v96 = _m_paddd(v14, v22);
    v25 = _m_pslldi(_m_pmaddwd(v20, (__m64)0x100000001LL), 0xDu);
    v97 = _m_paddd(v15, v24);
    v98 = _m_psubd(v24, v15);
    v100 = _m_paddd(v89, v25);
    v102 = _m_psubd(v25, v89);
    v103 = _m_pmullw(a1[2], a2[2]);
    v104 = _m_pmullw(a1[14], a2[14]);
    v26 = _m_paddw(v104, v103);
    v106 = _m_pmullw(a1[10], a2[10]);
    v107 = _m_pmullw(a1[6], a2[6]);
    v27 = _m_paddw(v106, v107);
    v28 = _m_paddw(v104, v107);
    v29 = _m_paddw(v106, v103);
    v30 = _m_paddw(v28, v29);
    v109 = _m_pmaddwd(v30, (__m64)0x25A1000025A1LL);
    v31 = _m_psrlqi(v27, 0x10u);
    v110 = _m_pmaddwd(_m_psrlqi(v30, 0x10u), (__m64)0x25A1000025A1LL);
    v32 = _m_psrlqi(v28, 0x10u);
    v95 = _m_paddd(_m_pxor(_m_pmaddwd(v26, (__m64)0x1CCD00001CCDLL), (__m64)-1LL), (__m64)0x100000001LL);
    v33 = _m_pmaddwd(_m_psrlqi(v26, 0x10u), (__m64)0x1CCD00001CCDLL);
    v34 = _m_psrlqi(v29, 0x10u);
    v35 = _m_paddd(_m_pxor(_m_pmaddwd(v27, (__m64)0x520300005203LL), (__m64)-1LL), (__m64)0x100000001LL);
    v36 = _m_paddd(_m_pxor(_m_pmaddwd(v31, (__m64)0x520300005203LL), (__m64)-1LL), (__m64)0x100000001LL);
    v101 = _m_paddd(_m_pxor(v33, (__m64)-1LL), (__m64)0x100000001LL);
    v37 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v28, (__m64)0x3EC500003EC5LL), (__m64)-1LL), (__m64)0x100000001LL), v109);
    v38 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v32, (__m64)0x3EC500003EC5LL), (__m64)-1LL), (__m64)0x100000001LL), v110);
    v39 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v29, (__m64)0xC7C00000C7CLL), (__m64)-1LL), (__m64)0x100000001LL), v109);
    v40 = _m_paddd(_m_paddd(_m_pxor(_m_pmaddwd(v34, (__m64)0xC7C00000C7CLL), (__m64)-1LL), (__m64)0x100000001LL), v110);
    v111 = _m_paddd(v37, v35);
    v105 = _m_paddd(v38, v36);
    v92 = _m_paddd(_m_pmaddwd(v104, (__m64)0x98E0000098ELL), _m_paddd(v95, v37));
    v108 = _m_paddd(_m_pmaddwd(_m_psrlqi(v104, 0x10u), (__m64)0x98E0000098ELL), _m_paddd(v101, v38));
    v41 = _m_paddd(_m_pmaddwd(v103, (__m64)0x300B0000300BLL), _m_paddd(v39, v95));
    v42 = _m_paddd(_m_pmaddwd(_m_psrlqi(v103, 0x10u), (__m64)0x300B0000300BLL), _m_paddd(v40, v101));
    v99 = _m_paddd(_m_pmaddwd(v106, (__m64)0x41B3000041B3LL), _m_paddd(v35, v39));
    v90 = _m_paddd(_m_pmaddwd(_m_psrlqi(v106, 0x10u), (__m64)0x41B3000041B3LL), _m_paddd(v36, v40));
    v43 = _m_psradi(_m_paddd(_m_psubd(v93, v42), (__m64)0x40000000400LL), 0xBu);
    v44 = _m_paddd(_m_pmaddwd(v107, (__m64)0x625400006254LL), v111);
    v45 = _m_psradi(_m_paddd(_m_psubd(v96, v41), (__m64)0x40000000400LL), 0xBu);
    v46 = _m_paddd(_m_pmaddwd(_m_psrlqi(v107, 0x10u), (__m64)0x625400006254LL), v105);
    v113[14].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v45, v43), _m_punpckhwd(v45, v43));
    v47 = _m_psradi(_m_paddd(_m_paddd(v42, v93), (__m64)0x40000000400LL), 0xBu);
    v48 = _m_psradi(_m_paddd(_m_paddd(v41, v96), (__m64)0x40000000400LL), 0xBu);
    v113->m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v48, v47), _m_punpckhwd(v48, v47));
    v49 = _m_psradi(_m_paddd(_m_psubd(v97, v46), (__m64)0x40000000400LL), 0xBu);
    v50 = _m_psradi(_m_paddd(_m_psubd(v100, v44), (__m64)0x40000000400LL), 0xBu);
    v51 = _m_punpcklwd(v50, v49);
    v52 = _m_punpckhwd(v50, v49);
    v53 = _m_psradi(_m_paddd(_m_paddd(v44, v100), (__m64)0x40000000400LL), 0xBu);
    v113[12].m64_u64 = (unsigned __int64)_m_punpckldq(v51, v52);
    v54 = _m_psradi(_m_paddd(_m_paddd(v46, v97), (__m64)0x40000000400LL), 0xBu);
    v113[2].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v53, v54), _m_punpckhwd(v53, v54));
    v55 = _m_psradi(_m_paddd(_m_paddd(v98, v90), (__m64)0x40000000400LL), 0xBu);
    v56 = _m_psradi(_m_paddd(_m_paddd(v102, v99), (__m64)0x40000000400LL), 0xBu);
    v57 = _m_psradi(_m_paddd(_m_psubd(v98, v90), (__m64)0x40000000400LL), 0xBu);
    v113[4].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v56, v55), _m_punpckhwd(v56, v55));
    v58 = _m_psradi(_m_paddd(_m_psubd(v102, v99), (__m64)0x40000000400LL), 0xBu);
    v59 = _m_punpckldq(_m_punpcklwd(v58, v57), _m_punpckhwd(v58, v57));
    v60 = _m_psradi(_m_paddd(_m_paddd(v91, v92), (__m64)0x40000000400LL), 0xBu);
    v61 = _m_psradi(_m_paddd(_m_paddd(v94, v108), (__m64)0x40000000400LL), 0xBu);
    v62 = _m_psradi(_m_paddd(_m_psubd(v91, v92), (__m64)0x40000000400LL), 0xBu);
    v113[10].m64_u64 = (unsigned __int64)v59;
    v63 = _m_psradi(_m_paddd(_m_psubd(v94, v108), (__m64)0x40000000400LL), 0xBu);
    v113[6].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v60, v61), _m_punpckhwd(v60, v61));
    ++a1;
    ++a2;
    v113[8].m64_u64 = (unsigned __int64)_m_punpckldq(_m_punpcklwd(v62, v63), _m_punpckhwd(v62, v63));
    ++v113;
    result = --v117;
  }
  while ( v117 );
  v118 = 8;
  v114 = a3;
  v116 = 0;
  do
  {
    v65 = v114[1];
    v66 = _m_paddw((__m64)v114->m64_u64, v65);
    v67 = _m_pmaddwd(v66, (__m64)0x115100000000LL);
    v68 = _m_pmaddwd(_m_punpckhdq((__m64)v114->m64_u64, v65), (__m64)0x3B210000187ELL);
    v69 = _m_psradi(_m_pslldi(_m_punpckldq(v66, _m_psubw((__m64)v114->m64_u64, v65)), 0x10u), 3u);
    v70 = _m_paddd(
            _m_punpckldq(v68, _m_psrlqi(_m_paddd(_m_pxor(v68, (__m64)-1LL), (__m64)0x100000001LL), 0x20u)),
            _m_punpckhdq(v67, v67));
    v71 = v66;
    v72 = _m_paddd(v69, v70);
    v73 = _m_psubd(v69, v70);
    v74 = _m_pmaddwd(_m_paddw(_m_punpckldq(v71, v71), v71), (__m64)0x25A1000000000000LL);
    v75 = _m_paddd(
            _m_paddd(_m_pxor(_m_pmaddwd(v71, (__m64)0x3EC500000C7C0000LL), (__m64)-1LL), (__m64)0x100000001LL),
            _m_punpckhdq(v74, v74));
    v76 = _m_paddd(
            _m_pxor(
              _m_pmaddwd(
                _m_paddw(
                  _m_punpckhdq((__m64)v114->m64_u64, _m_punpckldq((__m64)v114->m64_u64, (__m64)v114->m64_u64)),
                  v65),
                (__m64)0x1CCD000052030000LL),
              (__m64)-1LL),
            (__m64)0x100000001LL);
    v77 = _m_paddd(_m_pmaddwd(v65, (__m64)0x98E000041B30000LL), _m_paddd(v76, v75));
    v78 = _m_paddd(
            _m_pmaddwd((__m64)v114->m64_u64, (__m64)0x62540000300B0000LL),
            _m_paddd(_m_punpckhdq(v76, _m_punpckldq(v76, v76)), v75));
    v79 = _m_punpckhdq(v77, _m_punpckldq(v77, v77));
    v80 = _m_psubd(v72, v78);
    v81 = _m_psubd(v73, v79);
    v82 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v79, v73), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    v83 = _m_pand(_m_psradi(_m_paddd(_m_paddd(v78, v72), (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    BYTE1(result) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v82));
    v84 = *(_DWORD *)(v116 + a4);
    LOBYTE(result) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v82, 0x20u)));
    v116 += 4;
    v85 = _m_pand(_m_psradi(_m_paddd(v80, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    v86 = result << 16;
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v83));
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v83, 0x20u)));
    v87 = _mm_cvtsi32_si64(v86);
    v88 = _m_pand(_m_psradi(_m_paddd(v81, (__m64)0x2000000020000LL), 0x12u), (__m64)0x3FF000003FFLL);
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v85));
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v85, 0x20u)));
    v86 <<= 16;
    LOBYTE(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(v88));
    BYTE1(v86) = *(_BYTE *)(a6 + _mm_cvtsi64_si32(_m_psrlqi(v88, 0x20u)));
    v114 += 2;
    *(__m64 *)(a5 + v84) = _m_punpckldq(v87, _mm_cvtsi32_si64(v86));
    result = v118 - 1;
    v118 = result;
  }
  while ( result );
  _m_empty();
  return result;
}

// sub_10037A8F @ 0x10037A8F
__int16 __cdecl sub_10037A8F(_WORD *a1, _WORD *a2, _WORD *a3, int a4, int a5, int a6)
{
  __int16 v6; // bx
  __int16 v7; // dx
  __int16 v8; // ax
  __int16 v9; // bx
  __int16 v10; // bx
  __int16 v11; // ax
  __int16 v12; // bx
  __int16 v13; // cx
  __int16 v14; // ax
  __int16 v15; // bx
  __int16 v16; // dx
  __int16 v17; // bx
  __int16 v18; // cx
  __int16 v19; // ax
  int v20; // ecx
  __int16 v21; // dx
  int v22; // ebx
  __int16 v23; // dx
  __int16 v24; // dx
  _BYTE *v25; // edi
  __int16 v26; // bx
  __int16 v27; // dx
  __int16 v28; // ax
  __int16 v29; // bx
  __int16 v30; // bx
  __int16 v31; // ax
  __int16 v32; // bx
  __int16 v33; // cx
  __int16 v34; // ax
  __int16 v35; // bx
  __int16 v36; // dx
  __int16 v37; // bx
  __int16 v38; // cx
  __int16 v39; // ax
  int v40; // ecx
  __int16 v41; // dx
  int v42; // ebx
  __int16 v43; // dx
  __int16 result; // ax
  _WORD *v47; // [esp+14h] [ebp-24h]
  _WORD *v48; // [esp+14h] [ebp-24h]
  int v49; // [esp+18h] [ebp-20h]
  __int16 v50; // [esp+1Ch] [ebp-1Ch]
  __int16 v51; // [esp+1Ch] [ebp-1Ch]
  __int16 v52; // [esp+20h] [ebp-18h]
  __int16 v53; // [esp+20h] [ebp-18h]
  __int16 v54; // [esp+20h] [ebp-18h]
  __int16 v55; // [esp+20h] [ebp-18h]
  __int16 v56; // [esp+20h] [ebp-18h]
  __int16 v57; // [esp+24h] [ebp-14h]
  __int16 v58; // [esp+24h] [ebp-14h]
  __int16 v59; // [esp+28h] [ebp-10h]
  __int16 v60; // [esp+28h] [ebp-10h]
  __int16 v61; // [esp+2Ch] [ebp-Ch]
  __int16 v62; // [esp+2Ch] [ebp-Ch]
  __int16 v63; // [esp+30h] [ebp-8h]
  __int16 v64; // [esp+30h] [ebp-8h]
  __int16 v65; // [esp+30h] [ebp-8h]
  __int16 v66; // [esp+30h] [ebp-8h]
  __int16 v67; // [esp+34h] [ebp-4h]

  v47 = a2;
  v50 = 8;
  do
  {
    v6 = a3[32] * a1[32];
    v7 = a3[48] * a1[48];
    v52 = *a3 * *a1;
    v8 = v6 + v52;
    v53 = v52 - v6;
    v9 = a3[16] * a1[16];
    v57 = v7 + v9 + v8;
    v59 = v8 - (v7 + v9);
    v10 = ((362 * (__int16)(v9 - v7)) >> 8) - (v7 + v9);
    v11 = v10 + v53;
    v54 = v53 - v10;
    v61 = v11;
    v12 = a3[56] * a1[56];
    v13 = a3[24] * a1[24];
    v63 = a3[8] * a1[8];
    v14 = v12 + v63;
    v64 = v63 - v12;
    v15 = a3[40] * a1[40];
    v16 = v13 + v15;
    v17 = v15 - v13;
    v18 = v14;
    v19 = v16 + v14;
    v20 = (__int16)(v18 - v16);
    v21 = v17;
    v22 = (473 * (__int16)(v64 + v17)) >> 8;
    v23 = v22 + ((-669 * v21) >> 8) - v19;
    *v47 = v57 + v19;
    v47[56] = v57 - v19;
    v47[8] = v61 + v23;
    v47[48] = v61 - v23;
    v24 = ((362 * v20) >> 8) - v23;
    v47[16] = v54 + v24;
    v47[40] = v54 - v24;
    LOWORD(v20) = v24 + ((277 * v64) >> 8) - v22;
    v47[32] = v59 + v20;
    v47[24] = v59 - v20;
    ++a1;
    ++a3;
    ++v47;
    --v50;
  }
  while ( v50 );
  v49 = 0;
  v51 = 8;
  v48 = a2;
  do
  {
    v25 = (_BYTE *)(a5 + *(_DWORD *)(v49 + a4));
    v49 += 4;
    v26 = v48[4];
    v27 = v48[6];
    v28 = v26 + *v48;
    v55 = *v48 - v26;
    v29 = v48[2];
    v58 = v27 + v29 + v28;
    v60 = v28 - (v27 + v29);
    v30 = ((362 * (__int16)(v29 - v27)) >> 8) - (v27 + v29);
    v31 = v30 + v55;
    v56 = v55 - v30;
    v62 = v31;
    v32 = v48[7];
    v33 = v48[3];
    v65 = v48[1];
    v34 = v32 + v65;
    v66 = v65 - v32;
    v35 = v48[5];
    v36 = v33 + v35;
    v37 = v35 - v33;
    v38 = v34;
    v39 = v36 + v34;
    v40 = (__int16)(v38 - v36);
    v41 = v37;
    v42 = (473 * (__int16)(v66 + v37)) >> 8;
    v43 = v42 + ((-669 * v41) >> 8) - v39;
    LOWORD(v40) = ((362 * v40) >> 8) - v43;
    v67 = v40 + ((277 * v66) >> 8) - v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v58 - v39) >> 5) & 0x3FF));
    *v25 = *(_BYTE *)(a6 + (((__int16)(v58 + v39) >> 5) & 0x3FF));
    v25[7] = v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v62 - v43) >> 5) & 0x3FF));
    v25[1] = *(_BYTE *)(a6 + (((__int16)(v62 + v43) >> 5) & 0x3FF));
    v25[6] = v42;
    LOBYTE(v42) = *(_BYTE *)(a6 + (((__int16)(v56 - v40) >> 5) & 0x3FF));
    v25[2] = *(_BYTE *)(a6 + (((__int16)(v56 + v40) >> 5) & 0x3FF));
    v25[5] = v42;
    LOBYTE(v39) = *(_BYTE *)(a6 + (((__int16)(v60 - v67) >> 5) & 0x3FF));
    v25[4] = *(_BYTE *)(a6 + (((__int16)(v60 + v67) >> 5) & 0x3FF));
    v25[3] = v39;
    v48 += 8;
    result = --v51;
  }
  while ( v51 );
  return result;
}

// sub_10037DEA @ 0x10037DEA
char __cdecl sub_10037DEA(__m64 *a1, __m64 *a2, __m64 *a3, _DWORD *a4, int a5, int a6)
{
  __m64 v6; // mm0
  __m64 v7; // mm2
  __m64 v8; // mm5
  __m64 v9; // mm6
  __m64 v10; // mm2
  __m64 v11; // mm4
  __m64 v12; // mm3
  __m64 v13; // mm4
  __m64 v14; // mm5
  __m64 v15; // mm6
  __m64 v16; // mm0
  __m64 v17; // mm3
  __m64 v18; // mm7
  __m64 v19; // mm4
  __m64 v20; // mm3
  __m64 v21; // mm0
  __m64 v22; // mm5
  __m64 v23; // mm4
  __m64 v24; // mm0
  __m64 v25; // mm4
  __m64 v26; // mm5
  __m64 v27; // mm2
  __m64 v28; // mm1
  __m64 v29; // mm0
  __m64 v30; // mm3
  __m64 v31; // mm4
  __m64 v32; // mm1
  __m64 v33; // mm2
  __m64 v34; // mm4
  __m64 v35; // mm0
  __m64 v36; // mm6
  __m64 v37; // mm3
  __m64 v38; // mm0
  __m64 v39; // mm1
  __m64 m64_u64; // mm6
  __m64 v41; // mm1
  __m64 v42; // mm7
  __m64 v43; // mm5
  __m64 v44; // mm2
  __m64 v45; // mm4
  __m64 v46; // mm0
  __m64 v47; // mm1
  __m64 v48; // mm4
  __m64 v49; // mm3
  __m64 v50; // mm1
  __m64 v51; // mm6
  __m64 v52; // mm5
  __m64 v53; // mm6
  __m64 v54; // mm7
  __m64 v55; // mm3
  __m64 v56; // mm0
  __m64 v57; // mm3
  __m64 v58; // mm4
  __m64 v59; // mm6
  __m64 v60; // mm5
  __m64 v61; // mm6
  __m64 v62; // mm4
  __m64 v63; // mm5
  __m64 v64; // mm1
  __m64 v65; // mm2
  __m64 v66; // mm7
  __m64 v67; // mm3
  __m64 v68; // mm6
  __m64 v69; // mm3
  __m64 v70; // mm1
  __m64 v71; // mm4
  __m64 v72; // mm0
  __m64 v73; // mm2
  __m64 v74; // mm6
  __m64 v75; // mm1
  __m64 v76; // mm0
  __m64 v77; // mm5
  __m64 v78; // mm6
  __m64 v79; // mm0
  __m64 v80; // mm5
  __m64 v81; // mm0
  __m64 v82; // mm6
  __m64 v83; // mm2
  __m64 v84; // mm3
  __m64 v85; // mm7
  __m64 v86; // mm2
  __m64 v87; // mm5
  __m64 v88; // mm4
  __m64 v89; // mm3
  __m64 v90; // mm2
  __m64 v91; // mm7
  __m64 v92; // mm3
  __m64 v93; // mm1
  __m64 v94; // mm2
  __m64 v95; // mm0
  __m64 v96; // mm2
  __m64 v97; // mm1
  __m64 v98; // mm4
  __m64 v99; // mm3
  __m64 v100; // mm4
  __m64 v101; // mm1
  __m64 v102; // mm5
  __m64 v103; // mm0
  __m64 v104; // mm1
  __m64 v105; // mm3
  __m64 v106; // mm2
  __m64 v107; // mm5
  __m64 v108; // mm4
  __m64 v109; // mm1
  __m64 v110; // mm0
  __m64 v111; // mm3
  __m64 v112; // mm1
  __m64 v113; // mm4
  __m64 v114; // mm2
  __m64 v115; // mm0
  __m64 v116; // mm2
  __m64 v117; // mm0
  __m64 v118; // mm2
  __m64 v119; // mm5
  __m64 v120; // mm4
  __m64 v121; // mm2
  __m64 v122; // mm1
  __m64 v123; // mm4
  __m64 v124; // mm6
  __m64 v125; // mm5
  __m64 v126; // mm0
  __m64 v127; // mm3
  __m64 v128; // mm7
  __m64 v129; // mm4
  __m64 v130; // mm3
  __m64 v131; // mm0
  __m64 v132; // mm2
  __m64 v133; // mm6
  __m64 v134; // mm4
  __m64 v135; // mm5
  __m64 v136; // mm1
  __m64 v137; // mm0
  __m64 v138; // mm3
  __m64 v139; // mm1
  __m64 v140; // mm2
  __m64 v141; // mm4
  __m64 v142; // mm0
  __m64 v143; // mm6
  __m64 v144; // mm3
  __m64 v145; // mm0
  __m64 v146; // mm1
  __m64 v147; // mm6
  __m64 v148; // mm1
  __m64 v149; // mm7
  __m64 v150; // mm5
  __m64 v151; // mm2
  __m64 v152; // mm6
  __m64 v153; // mm4
  __m64 v154; // mm3
  __m64 v155; // mm1
  __m64 v156; // mm5
  __m64 v157; // mm7
  __m64 v158; // mm6
  __m64 v159; // mm4
  __m64 v160; // mm3
  __m64 v161; // mm0
  __m64 v162; // mm3
  __m64 v163; // mm6
  __m64 v164; // mm5
  __m64 v165; // mm6
  __m64 v166; // mm4
  __m64 v167; // mm5
  __m64 v168; // mm1
  __m64 v169; // mm2
  __m64 v170; // mm4
  __m64 v171; // mm2
  __m64 v172; // mm3
  __m64 v173; // mm6
  __m64 v174; // mm3
  __m64 v175; // mm1
  __m64 v176; // mm4
  __m64 v177; // mm2
  __m64 v178; // mm6
  __m64 v179; // mm1
  __m64 v180; // mm5
  __m64 v181; // mm0
  __m64 v182; // mm6
  _BYTE *v183; // ebx
  __m64 v184; // mm0
  __m64 v185; // mm5
  __m64 v186; // mm0
  __m64 v187; // mm2
  __m64 v188; // mm6
  __m64 v189; // mm3
  __m64 v190; // mm7
  __m64 v191; // mm2
  __m64 v192; // mm4
  __m64 v193; // mm5
  __m64 v194; // mm5
  __m64 v195; // mm5
  _BYTE *v196; // ebx
  __m64 v197; // mm4
  __m64 v198; // mm3
  __m64 v199; // mm4
  __m64 v200; // mm4
  __m64 v201; // mm4
  _BYTE *v202; // ecx
  __m64 v203; // mm0
  __m64 v204; // mm0
  __m64 v205; // mm0
  _BYTE *v206; // ebx
  __m64 v207; // mm3
  __m64 v208; // mm3
  __m64 v209; // mm3
  _BYTE *v210; // ebx
  __m64 v211; // mm4
  __m64 v212; // mm5
  __m64 v213; // mm2
  __m64 v214; // mm3
  __m64 v215; // mm7
  __m64 v216; // mm3
  __m64 v217; // mm1
  __m64 v218; // mm6
  __m64 v219; // mm6
  __m64 v220; // mm6
  _BYTE *v221; // ebx
  __m64 v222; // mm2
  __m64 v223; // mm2
  __m64 v224; // mm2
  _BYTE *v225; // ecx
  __m64 v226; // mm5
  __m64 v227; // mm5
  __m64 v228; // mm5
  _BYTE *v229; // ebx
  __m64 v230; // mm1
  __m64 v231; // mm1
  __m64 v232; // mm1
  _BYTE *v233; // ebx
  __m64 v234; // mm1
  __m64 v235; // mm2
  __m64 v236; // mm0
  __m64 v237; // mm2
  __m64 v238; // mm4
  __m64 v239; // mm1
  __m64 v240; // mm5
  __m64 v241; // mm3
  __m64 v242; // mm4
  __m64 v243; // mm1
  __m64 v244; // mm0
  __m64 v245; // mm1
  __m64 v246; // mm3
  __m64 v247; // mm0
  __m64 v248; // mm0
  __m64 v249; // mm0
  _BYTE *v250; // ebx
  __m64 v251; // mm2
  __m64 v252; // mm5
  __m64 v253; // mm4
  __m64 v254; // mm1
  __m64 v255; // mm1
  __m64 v256; // mm1
  _BYTE *v257; // ecx
  __m64 v258; // mm0
  __m64 v259; // mm1
  __m64 v260; // mm3
  __m64 v261; // mm1
  __m64 v262; // mm4
  __m64 v263; // mm2
  __m64 v264; // mm2
  __m64 v265; // mm2
  _BYTE *v266; // ebx
  __m64 v267; // mm2
  __m64 v268; // mm5
  __m64 v269; // mm5
  __m64 v270; // mm5
  __m64 v271; // mm0
  __m64 v272; // mm2
  __m64 v273; // mm4
  __m64 v274; // mm5
  _BYTE *v275; // ebx
  __m64 v276; // mm3
  __m64 v277; // mm3
  __m64 v278; // mm3
  _BYTE *v279; // ebx
  __m64 v280; // mm4
  __m64 v281; // mm4
  __m64 v282; // mm4
  _BYTE *v283; // ecx
  __m64 v284; // mm1
  __m64 v285; // mm1
  __m64 v286; // mm1
  _BYTE *v287; // ebx
  __m64 v288; // mm5
  __m64 v289; // mm5
  __m64 v290; // mm5
  char result; // al
  __m64 v292; // [esp+14h] [ebp-10h]
  __m64 v293; // [esp+14h] [ebp-10h]
  __m64 v294; // [esp+1Ch] [ebp-8h]

  v6 = _m_pmullw(a1[12], a3[12]);
  v7 = _m_pmullw(a1[4], a3[4]);
  v8 = _m_pmullw(a1[8], a3[8]);
  v9 = _m_psubw(v7, v6);
  v10 = _m_paddw(v7, v6);
  v11 = _m_pmullw((__m64)a1->m64_u64, (__m64)a3->m64_u64);
  v12 = _m_paddw(v11, v8);
  v13 = _m_psubw(v11, v8);
  v14 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v9, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v9, 0), (__m64)0x16A0000016ALL), 8u)),
          v10);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v12, v10);
  a2[12].m64_u64 = (unsigned __int64)_m_paddw(v14, v13);
  v15 = _m_psubw(v12, v10);
  a2->m64_u64 = (unsigned __int64)_m_psubw(v13, v14);
  v16 = _m_pmullw(a1[6], a3[6]);
  v17 = _m_pmullw(a1[10], a3[10]);
  v18 = _m_psubw(v17, v16);
  v19 = _m_pmullw(a1[14], a3[14]);
  v20 = _m_paddw(v17, v16);
  v21 = _m_pmullw(a1[2], a3[2]);
  v22 = _m_paddw(v21, v19);
  v23 = _m_psubw(v21, v19);
  v292 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v23, 0), (__m64)0x11500000115LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v23, 0), (__m64)0x11500000115LL), 8u));
  v24 = _m_paddw(v18, v23);
  v25 = v22;
  v26 = _m_paddw(v22, v20);
  v27 = _m_psubw(v25, v20);
  v28 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v24, 0), (__m64)0x1D9000001D9LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v24, 0), (__m64)0x1D9000001D9LL), 8u));
  v29 = _m_psubw(v292, v28);
  v30 = v15;
  v31 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v27, 0), (__m64)0x16A0000016ALL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v27, 0), (__m64)0x16A0000016ALL), 8u));
  v32 = _m_psubw(
          _m_paddw(
            v28,
            _m_packssdw(
              _m_psradi(_m_pmaddwd(_m_punpcklwd(v18, 0), (__m64)0xFD630000FD63LL), 8u),
              _m_psradi(_m_pmaddwd(_m_punpckhwd(v18, 0), (__m64)0xFD630000FD63LL), 8u))),
          v26);
  v33 = a2[12];
  v34 = _m_psubw(v31, v32);
  v35 = _m_paddw(v29, v34);
  v36 = _m_psubw(v15, v35);
  v37 = _m_paddw(v30, v35);
  v38 = v32;
  v39 = a2[4];
  a2[8].m64_u64 = (unsigned __int64)v37;
  a2[6].m64_u64 = (unsigned __int64)v36;
  m64_u64 = (__m64)a2->m64_u64;
  a2->m64_u64 = (unsigned __int64)_m_paddw(v39, v26);
  a2[14].m64_u64 = (unsigned __int64)_m_psubw(v39, v26);
  a2[2].m64_u64 = (unsigned __int64)_m_paddw(v33, v38);
  a2[12].m64_u64 = (unsigned __int64)_m_psubw(v33, v38);
  v41 = _m_pmullw(a1[5], a3[5]);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(m64_u64, v34);
  a2[10].m64_u64 = (unsigned __int64)_m_psubw(m64_u64, v34);
  v42 = _m_pmullw(a1[13], a3[13]);
  v43 = _m_pmullw(a1[9], a3[9]);
  v44 = _m_paddw(v41, v42);
  v45 = _m_psubw(v41, v42);
  v46 = _m_pmullw(a1[11], a3[11]);
  v47 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v45, 0), (__m64)0x16A0000016ALL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v45, 0), (__m64)0x16A0000016ALL), 8u));
  v48 = _m_pmullw(a1[1], a3[1]);
  v49 = _m_paddw(v48, v43);
  v50 = _m_psubw(v47, v44);
  v51 = a1[7];
  v52 = _m_psubw(v48, v43);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v49, v44);
  v53 = _m_pmullw(v51, a3[7]);
  v54 = _m_psubw(v49, v44);
  a2[13].m64_u64 = (unsigned __int64)_m_paddw(v52, v50);
  v55 = v46;
  a2[9].m64_u64 = (unsigned __int64)_m_psubw(v52, v50);
  v56 = _m_paddw(v46, v53);
  v57 = _m_psubw(v55, v53);
  v58 = _m_pmullw(a1[15], a3[15]);
  v294 = v54;
  v59 = _m_pmullw(a1[3], a3[3]);
  v60 = _m_paddw(v59, v58);
  v61 = _m_psubw(v59, v58);
  v62 = v60;
  v63 = _m_paddw(v60, v56);
  v64 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v57, 0), (__m64)0xFD630000FD63LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v57, 0), (__m64)0xFD630000FD63LL), 8u));
  v65 = _m_psubw(v62, v56);
  v66 = _m_paddw(v57, v61);
  v67 = _m_packssdw(
          _m_psradi(_m_pmaddwd(_m_punpcklwd(v66, 0), (__m64)0x1D9000001D9LL), 8u),
          _m_psradi(_m_pmaddwd(_m_punpckhwd(v66, 0), (__m64)0x1D9000001D9LL), 8u));
  v68 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v61, 0), (__m64)0x11500000115LL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v61, 0), (__m64)0x11500000115LL), 8u)),
          v67);
  v69 = _m_psubw(_m_paddw(v67, v64), v63);
  v70 = a2[5];
  v71 = _m_psubw(
          _m_packssdw(
            _m_psradi(_m_pmaddwd(_m_punpcklwd(v65, 0), (__m64)0x16A0000016ALL), 8u),
            _m_psradi(_m_pmaddwd(_m_punpckhwd(v65, 0), (__m64)0x16A0000016ALL), 8u)),
          v69);
  v72 = _m_paddw(v70, v63);
  v73 = a2[13];
  v74 = _m_paddw(v68, v71);
  v75 = _m_psubw(v70, v63);
  a2[1].m64_u64 = (unsigned __int64)v72;
  v76 = a2[9];
  v77 = _m_paddw(v294, v74);
  a2[7].m64_u64 = (unsigned __int64)_m_psubw(v294, v74);
  a2[3].m64_u64 = (unsigned __int64)_m_paddw(v73, v69);
  v78 = _m_psubw(v76, v71);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v76, v71);
  v79 = v77;
  v80 = _m_punpcklwd(v77, v78);
  v81 = _m_punpckhwd(v79, v78);
  v82 = (__m64)a2->m64_u64;
  v83 = _m_psubw(v73, v69);
  v84 = _m_punpcklwd(v83, v75);
  v85 = a2[2];
  v86 = _m_punpckhwd(v83, v75);
  a2[9].m64_u64 = (unsigned __int64)_m_punpckldq(v80, v84);
  a2[11].m64_u64 = (unsigned __int64)_m_punpckhdq(v80, v84);
  a2[13].m64_u64 = (unsigned __int64)_m_punpckldq(v81, v86);
  a2[15].m64_u64 = (unsigned __int64)_m_punpckhdq(v81, v86);
  v87 = _m_punpckhwd(v82, v85);
  v88 = a2[6];
  v89 = a2[4];
  v90 = _m_punpcklwd(v82, v85);
  v91 = _m_punpcklwd(v89, v88);
  v92 = _m_punpckhwd(v89, v88);
  a2->m64_u64 = (unsigned __int64)_m_punpckldq(v90, v91);
  a2[2].m64_u64 = (unsigned __int64)_m_punpckhdq(v90, v91);
  a2[4].m64_u64 = (unsigned __int64)_m_punpckldq(v87, v92);
  a2[6].m64_u64 = (unsigned __int64)_m_punpckhdq(v87, v92);
  v93 = a2[3];
  v94 = a2[1];
  v95 = _m_punpcklwd(v94, v93);
  v96 = _m_punpckhwd(v94, v93);
  v97 = a2[7];
  v98 = a2[5];
  v99 = _m_punpcklwd(v98, v97);
  v100 = _m_punpckhwd(v98, v97);
  v101 = v95;
  v102 = v96;
  v103 = _m_punpckldq(v95, v99);
  v104 = _m_punpckhdq(v101, v99);
  v105 = a2[8];
  a2[8].m64_u64 = (unsigned __int64)v103;
  v106 = _m_punpckldq(v96, v100);
  v107 = _m_punpckhdq(v102, v100);
  v108 = a2[10];
  a2[10].m64_u64 = (unsigned __int64)v104;
  v109 = v105;
  v110 = a2[12];
  v111 = _m_punpcklwd(v105, v108);
  v112 = _m_punpckhwd(v109, v108);
  v113 = a2[14];
  a2[12].m64_u64 = (unsigned __int64)v106;
  v114 = v110;
  a2[14].m64_u64 = (unsigned __int64)v107;
  v115 = _m_punpcklwd(v110, v113);
  v116 = _m_punpckhwd(v114, v113);
  a2[1].m64_u64 = (unsigned __int64)_m_punpckldq(v111, v115);
  a2[3].m64_u64 = (unsigned __int64)_m_punpckhdq(v111, v115);
  a2[5].m64_u64 = (unsigned __int64)_m_punpckldq(v112, v116);
  a2[7].m64_u64 = (unsigned __int64)_m_punpckhdq(v112, v116);
  v117 = a2[12];
  v118 = a2[4];
  v119 = a2[8];
  v120 = _m_psubw(v118, v117);
  v121 = _m_paddw(v118, v117);
  v122 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v120, 0), (__m64)0x16A0000016ALL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v120, 0), (__m64)0x16A0000016ALL), 8u));
  v123 = _m_psubw((__m64)a2->m64_u64, v119);
  v124 = _m_paddw((__m64)a2->m64_u64, v119);
  v125 = _m_psubw(v122, v121);
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v124, v121);
  a2[12].m64_u64 = (unsigned __int64)_m_paddw(v125, v123);
  a2->m64_u64 = (unsigned __int64)_m_psubw(v123, v125);
  v126 = a2[6];
  v127 = a2[10];
  v128 = _m_psubw(v127, v126);
  v129 = a2[14];
  v130 = _m_paddw(v127, v126);
  v293 = _m_psubw(v124, v121);
  v131 = a2[2];
  v132 = _m_psubw(v131, v129);
  v133 = _m_paddw(v128, v132);
  v134 = _m_paddw(v131, v129);
  v135 = _m_paddw(v134, v130);
  v136 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v133, 0), (__m64)0x1D9000001D9LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v133, 0), (__m64)0x1D9000001D9LL), 8u));
  v137 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v132, 0), (__m64)0x11500000115LL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v132, 0), (__m64)0x11500000115LL), 8u)),
           v136);
  v138 = _m_psubw(v134, v130);
  v139 = _m_psubw(
           _m_paddw(
             v136,
             _m_packssdw(
               _m_psradi(_m_pmaddwd(_m_punpcklwd(v128, 0), (__m64)0xFD630000FD63LL), 8u),
               _m_psradi(_m_pmaddwd(_m_punpckhwd(v128, 0), (__m64)0xFD630000FD63LL), 8u))),
           v135);
  v140 = a2[12];
  v141 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v138, 0), (__m64)0x16A0000016ALL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v138, 0), (__m64)0x16A0000016ALL), 8u)),
           v139);
  v142 = _m_paddw(v137, v141);
  v143 = _m_psubw(v293, v142);
  v144 = _m_paddw(v293, v142);
  v145 = v139;
  v146 = a2[4];
  a2[8].m64_u64 = (unsigned __int64)v144;
  a2[6].m64_u64 = (unsigned __int64)v143;
  v147 = (__m64)a2->m64_u64;
  a2->m64_u64 = (unsigned __int64)_m_paddw(v146, v135);
  a2[14].m64_u64 = (unsigned __int64)_m_psubw(v146, v135);
  a2[2].m64_u64 = (unsigned __int64)_m_paddw(v140, v145);
  a2[12].m64_u64 = (unsigned __int64)_m_psubw(v140, v145);
  v148 = a2[5];
  a2[4].m64_u64 = (unsigned __int64)_m_paddw(v147, v141);
  a2[10].m64_u64 = (unsigned __int64)_m_psubw(v147, v141);
  v149 = a2[13];
  v150 = a2[9];
  v151 = _m_paddw(v148, v149);
  v152 = _m_psubw(v148, v149);
  v153 = a2[1];
  v154 = _m_paddw(v153, v150);
  v155 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v152, 0), (__m64)0x16A0000016ALL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v152, 0), (__m64)0x16A0000016ALL), 8u)),
           v151);
  v156 = _m_psubw(v153, v150);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v154, v151);
  a2[13].m64_u64 = (unsigned __int64)_m_paddw(v156, v155);
  v157 = _m_psubw(v154, v151);
  a2[9].m64_u64 = (unsigned __int64)_m_psubw(v156, v155);
  v158 = a2[7];
  v159 = a2[15];
  v160 = a2[11];
  v161 = _m_paddw(v160, v158);
  v162 = _m_psubw(v160, v158);
  v163 = a2[3];
  v164 = _m_paddw(v163, v159);
  v165 = _m_psubw(v163, v159);
  v166 = v164;
  v167 = _m_paddw(v164, v161);
  v168 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v162, 0), (__m64)0xFD630000FD63LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v162, 0), (__m64)0xFD630000FD63LL), 8u));
  v169 = _m_psubw(v166, v161);
  v170 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v169, 0), (__m64)0x16A0000016ALL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v169, 0), (__m64)0x16A0000016ALL), 8u));
  v171 = _m_paddw(v162, v165);
  v172 = _m_packssdw(
           _m_psradi(_m_pmaddwd(_m_punpcklwd(v171, 0), (__m64)0x1D9000001D9LL), 8u),
           _m_psradi(_m_pmaddwd(_m_punpckhwd(v171, 0), (__m64)0x1D9000001D9LL), 8u));
  v173 = _m_psubw(
           _m_packssdw(
             _m_psradi(_m_pmaddwd(_m_punpcklwd(v165, 0), (__m64)0x11500000115LL), 8u),
             _m_psradi(_m_pmaddwd(_m_punpckhwd(v165, 0), (__m64)0x11500000115LL), 8u)),
           v172);
  v174 = _m_psubw(_m_paddw(v172, v168), v167);
  v175 = a2[5];
  v176 = _m_psubw(v170, v174);
  v177 = a2[13];
  v178 = _m_paddw(v173, v176);
  a2[1].m64_u64 = (unsigned __int64)_m_paddw(v175, v167);
  v179 = _m_psubw(v175, v167);
  v180 = _m_paddw(v157, v178);
  v181 = a2[9];
  a2[7].m64_u64 = (unsigned __int64)_m_psubw(v157, v178);
  a2[3].m64_u64 = (unsigned __int64)_m_paddw(v177, v174);
  v182 = _m_psubw(v181, v176);
  a2[5].m64_u64 = (unsigned __int64)_m_paddw(v181, v176);
  v183 = (_BYTE *)(a5 + a4[4]);
  v184 = v180;
  v185 = _m_punpcklwd(v180, v182);
  v186 = _m_punpckhwd(v184, v182);
  v187 = _m_psubw(v177, v174);
  v188 = (__m64)a2->m64_u64;
  v189 = _m_punpcklwd(v187, v179);
  v190 = a2[2];
  v191 = _m_punpckhwd(v187, v179);
  v192 = v185;
  v193 = _m_psrlwi(_m_punpckldq(v185, v189), 5u);
  v183[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v193) & 0x3FF));
  v194 = _m_psrlqi(v193, 0x10u);
  v183[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v194) & 0x3FF));
  v195 = _m_psrlqi(v194, 0x10u);
  v183[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v195) & 0x3FF));
  v183[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v195, 0x10u)) & 0x3FF));
  v196 = (_BYTE *)(a5 + a4[5]);
  v197 = _m_punpckhdq(v192, v189);
  v198 = v186;
  v199 = _m_psrlwi(v197, 5u);
  v196[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v199) & 0x3FF));
  v200 = _m_psrlqi(v199, 0x10u);
  v196[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v200) & 0x3FF));
  v201 = _m_psrlqi(v200, 0x10u);
  v196[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v201) & 0x3FF));
  v196[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v201, 0x10u)) & 0x3FF));
  v202 = (_BYTE *)(a5 + a4[6]);
  v203 = _m_psrlwi(_m_punpckldq(v186, v191), 5u);
  v202[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v203) & 0x3FF));
  v204 = _m_psrlqi(v203, 0x10u);
  v202[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v204) & 0x3FF));
  v205 = _m_psrlqi(v204, 0x10u);
  v202[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v205) & 0x3FF));
  v202[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v205, 0x10u)) & 0x3FF));
  v206 = (_BYTE *)(a5 + a4[7]);
  v207 = _m_psrlwi(_m_punpckhdq(v198, v191), 5u);
  v206[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v207) & 0x3FF));
  v208 = _m_psrlqi(v207, 0x10u);
  v206[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v208) & 0x3FF));
  v209 = _m_psrlqi(v208, 0x10u);
  v206[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v209) & 0x3FF));
  v206[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v209, 0x10u)) & 0x3FF));
  v210 = (_BYTE *)(a5 + *a4);
  v211 = a2[6];
  v212 = _m_punpckhwd(v188, v190);
  v213 = _m_punpcklwd(v188, v190);
  v214 = a2[4];
  v215 = _m_punpcklwd(v214, v211);
  v216 = _m_punpckhwd(v214, v211);
  v217 = v212;
  v218 = _m_psrlwi(_m_punpckldq(v213, v215), 5u);
  *v210 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v218) & 0x3FF));
  v219 = _m_psrlqi(v218, 0x10u);
  v210[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v219) & 0x3FF));
  v220 = _m_psrlqi(v219, 0x10u);
  v210[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v220) & 0x3FF));
  v210[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v220, 0x10u)) & 0x3FF));
  v221 = (_BYTE *)(a5 + a4[1]);
  v222 = _m_psrlwi(_m_punpckhdq(v213, v215), 5u);
  *v221 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v222) & 0x3FF));
  v223 = _m_psrlqi(v222, 0x10u);
  v221[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v223) & 0x3FF));
  v224 = _m_psrlqi(v223, 0x10u);
  v221[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v224) & 0x3FF));
  v221[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v224, 0x10u)) & 0x3FF));
  v225 = (_BYTE *)(a5 + a4[2]);
  v226 = _m_psrlwi(_m_punpckldq(v212, v216), 5u);
  *v225 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v226) & 0x3FF));
  v227 = _m_psrlqi(v226, 0x10u);
  v225[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v227) & 0x3FF));
  v228 = _m_psrlqi(v227, 0x10u);
  v225[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v228) & 0x3FF));
  v225[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v228, 0x10u)) & 0x3FF));
  v229 = (_BYTE *)(a5 + a4[3]);
  v230 = _m_psrlwi(_m_punpckhdq(v217, v216), 5u);
  *v229 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v230) & 0x3FF));
  v231 = _m_psrlqi(v230, 0x10u);
  v229[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v231) & 0x3FF));
  v232 = _m_psrlqi(v231, 0x10u);
  v229[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v232) & 0x3FF));
  v229[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v232, 0x10u)) & 0x3FF));
  v233 = (_BYTE *)(a5 + a4[4]);
  v234 = a2[3];
  v235 = a2[1];
  v236 = _m_punpcklwd(v235, v234);
  v237 = _m_punpckhwd(v235, v234);
  v238 = a2[5];
  v239 = a2[7];
  v240 = v237;
  v241 = _m_punpcklwd(v238, v239);
  v242 = _m_punpckhwd(v238, v239);
  v243 = v236;
  v244 = _m_punpckldq(v236, v241);
  v245 = _m_punpckhdq(v243, v241);
  v246 = a2[8];
  v247 = _m_psrlwi(v244, 5u);
  *v233 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v247) & 0x3FF));
  v248 = _m_psrlqi(v247, 0x10u);
  v233[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v248) & 0x3FF));
  v249 = _m_psrlqi(v248, 0x10u);
  v233[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v249) & 0x3FF));
  v233[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v249, 0x10u)) & 0x3FF));
  v250 = (_BYTE *)(a5 + a4[5]);
  v251 = _m_punpckldq(v237, v242);
  v252 = _m_punpckhdq(v240, v242);
  v253 = a2[10];
  v254 = _m_psrlwi(v245, 5u);
  *v250 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v254) & 0x3FF));
  v255 = _m_psrlqi(v254, 0x10u);
  v250[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v255) & 0x3FF));
  v256 = _m_psrlqi(v255, 0x10u);
  v250[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v256) & 0x3FF));
  v250[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v256, 0x10u)) & 0x3FF));
  v257 = (_BYTE *)(a5 + a4[6]);
  v258 = a2[12];
  v259 = v246;
  v260 = _m_punpcklwd(v246, v253);
  v261 = _m_punpckhwd(v259, v253);
  v262 = a2[14];
  v263 = _m_psrlwi(v251, 5u);
  *v257 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v263) & 0x3FF));
  v264 = _m_psrlqi(v263, 0x10u);
  v257[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v264) & 0x3FF));
  v265 = _m_psrlqi(v264, 0x10u);
  v257[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v265) & 0x3FF));
  v257[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v265, 0x10u)) & 0x3FF));
  v266 = (_BYTE *)(a5 + a4[7]);
  v267 = v258;
  v268 = _m_psrlwi(v252, 5u);
  *v266 = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v268) & 0x3FF));
  v269 = _m_psrlqi(v268, 0x10u);
  v266[1] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v269) & 0x3FF));
  v270 = _m_psrlqi(v269, 0x10u);
  v266[2] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v270) & 0x3FF));
  v266[3] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v270, 0x10u)) & 0x3FF));
  v271 = _m_punpcklwd(v258, v262);
  v272 = _m_punpckhwd(v267, v262);
  v273 = v260;
  v274 = v261;
  v275 = (_BYTE *)(a5 + *a4);
  v276 = _m_psrlwi(_m_punpckldq(v260, v271), 5u);
  v275[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v276) & 0x3FF));
  v277 = _m_psrlqi(v276, 0x10u);
  v275[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v277) & 0x3FF));
  v278 = _m_psrlqi(v277, 0x10u);
  v275[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v278) & 0x3FF));
  v275[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v278, 0x10u)) & 0x3FF));
  v279 = (_BYTE *)(a5 + a4[1]);
  v280 = _m_psrlwi(_m_punpckhdq(v273, v271), 5u);
  v279[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v280) & 0x3FF));
  v281 = _m_psrlqi(v280, 0x10u);
  v279[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v281) & 0x3FF));
  v282 = _m_psrlqi(v281, 0x10u);
  v279[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v282) & 0x3FF));
  v279[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v282, 0x10u)) & 0x3FF));
  v283 = (_BYTE *)(a5 + a4[2]);
  v284 = _m_psrlwi(_m_punpckldq(v261, v272), 5u);
  v283[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v284) & 0x3FF));
  v285 = _m_psrlqi(v284, 0x10u);
  v283[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v285) & 0x3FF));
  v286 = _m_psrlqi(v285, 0x10u);
  v283[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v286) & 0x3FF));
  v283[7] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v286, 0x10u)) & 0x3FF));
  v287 = (_BYTE *)(a5 + a4[3]);
  v288 = _m_psrlwi(_m_punpckhdq(v274, v272), 5u);
  v287[4] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v288) & 0x3FF));
  v289 = _m_psrlqi(v288, 0x10u);
  v287[5] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v289) & 0x3FF));
  v290 = _m_psrlqi(v289, 0x10u);
  v287[6] = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(v290) & 0x3FF));
  result = *(_BYTE *)(a6 + (_mm_cvtsi64_si32(_m_psrlqi(v290, 0x10u)) & 0x3FF));
  v287[7] = result;
  _m_empty();
  return result;
}

// sub_10038BBD @ 0x10038BBD
int __cdecl sub_10038BBD(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6)
{
  _DWORD *v7; // edi
  _BYTE *v8; // ecx
  unsigned int v9; // ebx
  unsigned int j; // edx
  unsigned int v11; // eax
  int v12; // eax
  unsigned __int8 *v13; // eax
  bool i; // zf
  unsigned __int8 v15; // cl
  int v16; // ecx
  unsigned int v17; // ebx
  unsigned int v18; // edx
  int v19; // eax
  unsigned __int8 *v20; // eax
  int v21; // ecx
  int v22; // ebx
  unsigned int v23; // ebx
  unsigned int v24; // ecx
  int v25; // eax
  _BYTE *v26; // ecx
  char *v27; // eax
  unsigned int v28; // ecx
  _BYTE *v29; // ebx
  char v30; // cl
  _BYTE *v31; // ecx
  unsigned int v32; // ecx
  unsigned int v33; // eax
  unsigned __int8 *v34; // ecx
  unsigned __int8 *v35; // eax
  int v36; // ecx
  int v38; // [esp+Ch] [ebp-18h]
  int v39; // [esp+10h] [ebp-14h]
  unsigned int v40; // [esp+14h] [ebp-10h]
  unsigned int v41; // [esp+18h] [ebp-Ch]
  unsigned __int8 *v42; // [esp+1Ch] [ebp-8h]
  unsigned int v43; // [esp+20h] [ebp-4h]
  unsigned int v44; // [esp+2Ch] [ebp+8h]
  unsigned int v45; // [esp+2Ch] [ebp+8h]
  unsigned int v46; // [esp+2Ch] [ebp+8h]
  int v47; // [esp+30h] [ebp+Ch]
  unsigned int v48; // [esp+30h] [ebp+Ch]
  unsigned int v49; // [esp+30h] [ebp+Ch]
  int v50; // [esp+30h] [ebp+Ch]
  _BYTE *v51; // [esp+40h] [ebp+1Ch]

  v42 = *a6;
  v7 = a5;
  v8 = (_BYTE *)a5[13];
  v9 = a5[8];
  j = a5[7];
  v43 = (unsigned int)a6[1];
  v11 = a5[12];
  v51 = v8;
  if ( (unsigned int)v8 >= v11 )
    v12 = a5[11] - (_DWORD)v8;
  else
    v12 = v11 - (_DWORD)v8 - 1;
  v40 = v12;
  v39 = dword_10057020[a1];
  v38 = dword_10057020[a2];
LABEL_6:
  while ( j < 0x14 )
  {
    --v43;
    v9 |= *v42++ << j;
    j += 8;
  }
  v13 = (unsigned __int8 *)(a3 + 8 * (v9 & v39));
  v47 = *v13;
  for ( i = v47 == 0; ; i = v47 == 0 )
  {
    v15 = v13[1];
    if ( i )
    {
      v9 >>= v15;
      j -= v13[1];
      v31 = v51++;
      --v40;
      *v31 = v13[4];
LABEL_32:
      if ( v40 < 0x102 || v43 < 0xA )
      {
        v32 = (unsigned int)&a6[1][-v43];
        if ( j >> 3 < v32 )
          v32 = j >> 3;
        v50 = 0;
        goto LABEL_47;
      }
      goto LABEL_6;
    }
    v9 >>= v15;
    j -= v13[1];
    if ( (v47 & 0x10) != 0 )
    {
      v41 = *((_DWORD *)v13 + 1) + (v9 & dword_10057020[v47 & 0xF]);
      v16 = v47 & 0xF;
      v17 = v9 >> v16;
      v18 = j - v16;
      v44 = v17;
      if ( v18 < 0xF )
      {
        do
        {
          --v43;
          v19 = *v42 << v18;
          v18 += 8;
          v17 |= v19;
          ++v42;
        }
        while ( v18 < 0xF );
        v44 = v17;
      }
      v20 = (unsigned __int8 *)(a4 + 8 * (v17 & v38));
      v45 = v44 >> v20[1];
      for ( j = v18 - v20[1]; ; j -= v21 )
      {
        v22 = *v20;
        if ( (v22 & 0x10) != 0 )
        {
          v23 = v22 & 0xF;
          while ( j < v23 )
          {
            --v43;
            v45 |= *v42++ << j;
            j += 8;
          }
          v7 = a5;
          v24 = *((_DWORD *)v20 + 1) + (v45 & dword_10057020[v23]);
          v40 -= v41;
          v25 = a5[10];
          v48 = v24;
          v46 = v45 >> v23;
          j -= v23;
          if ( (unsigned int)&v51[-v25] < v24 )
          {
            v28 = v24 + v25 - (_DWORD)v51;
            v27 = (char *)(a5[11] - v28);
            v49 = v28;
            if ( v41 > v28 )
            {
              v41 -= v28;
              do
              {
                v29 = v51;
                v30 = *v27;
                ++v51;
                ++v27;
                i = v49-- == 1;
                *v29 = v30;
              }
              while ( !i );
              v27 = (char *)a5[10];
            }
            v26 = v51;
          }
          else
          {
            *v51 = v51[-v24];
            v51[1] = v51[-v24 + 1];
            v26 = v51 + 2;
            v27 = &v51[-v48 + 2];
            v41 -= 2;
          }
          do
          {
            *v26++ = *v27++;
            --v41;
          }
          while ( v41 );
          v9 = v46;
          v51 = v26;
          goto LABEL_32;
        }
        if ( (v22 & 0x40) != 0 )
          break;
        v20 += 8 * *((_DWORD *)v20 + 1) + 8 * (v45 & dword_10057020[v22]);
        v21 = v20[1];
        v45 >>= v21;
      }
      v32 = (unsigned int)&a6[1][-v43];
      a6[6] = "invalid distance code";
      if ( j >> 3 < v32 )
        v32 = j >> 3;
      v7 = a5;
      v9 = v45;
      goto LABEL_46;
    }
    if ( (v47 & 0x40) != 0 )
      break;
    v13 += 8 * *((_DWORD *)v13 + 1) + 8 * (v9 & dword_10057020[v47]);
    v47 = *v13;
  }
  v33 = j >> 3;
  v34 = a6[1];
  if ( (v47 & 0x20) == 0 )
  {
    v32 = (unsigned int)&v34[-v43];
    a6[6] = "invalid literal/length code";
    if ( v33 < v32 )
      v32 = j >> 3;
LABEL_46:
    v50 = -3;
    goto LABEL_47;
  }
  v32 = (unsigned int)&v34[-v43];
  if ( v33 < v32 )
    v32 = j >> 3;
  v50 = 1;
LABEL_47:
  v7[8] = v9;
  v7[7] = j - 8 * v32;
  v35 = &v42[-v32];
  a6[1] = (unsigned __int8 *)(v43 + v32);
  v36 = &v42[-v32] - *a6;
  *a6 = v35;
  a6[2] += v36;
  v7[13] = v51;
  return v50;
}

// nullsub_7 @ 0x1003A4F4
void nullsub_7()
{
  ;
}

// nullsub_8 @ 0x1003A504
void nullsub_8()
{
  ;
}

// nullsub_9 @ 0x1003A574
int nullsub_9()
{
  _BYTE retaddr[8]; // [esp+0h] [ebp+0h]

  return MK_FP(*(_WORD *)retaddr, *(_DWORD *)retaddr)();
}

// nullsub_10 @ 0x1003A584
int nullsub_10()
{
  _BYTE retaddr[8]; // [esp+0h] [ebp+0h]

  return MK_FP(*(_WORD *)retaddr, *(_DWORD *)retaddr)();
}

// sub_1003A990 @ 0x1003A990
_DWORD *__cdecl sub_1003A990(int a1, int a2, int a3)
{
  int v3; // eax
  int (__cdecl **v4)(int, _DWORD, int); // ecx
  _DWORD *result; // eax

  if ( !*(_DWORD *)(a1 + 20) )
  {
    v3 = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 48);
    v4 = *(int (__cdecl ***)(int, _DWORD, int))(a1 + 4);
    *(_DWORD *)(a1 + 20) = v3;
    *(_DWORD *)(v3 + 40) = (*v4)(a1, 0, 4096);
  }
  result = *(_DWORD **)(a1 + 20);
  result[2] = sub_1003AA10;
  result[3] = sub_1003AA20;
  result[4] = sub_1003AAC0;
  result[5] = sub_1003B560;
  result[6] = nullsub_4;
  result[7] = a2;
  result[8] = a3;
  result[9] = 0;
  result[1] = 0;
  *result = 0;
  return result;
}

// sub_1003AA10 @ 0x1003AA10
int __cdecl sub_1003AA10(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 20) + 44) = 1;
  return a1;
}

// sub_1003AA20 @ 0x1003AA20
char __cdecl sub_1003AA20(_DWORD *a1)
{
  int v1; // ebx
  int v2; // edx
  int v3; // eax
  signed int v4; // eax
  int v5; // ecx
  int v7; // ecx

  v1 = a1[5];
  v2 = *(_DWORD *)(v1 + 36);
  v3 = *(_DWORD *)(v1 + 32);
  if ( v2 >= v3 )
  {
    if ( *(_BYTE *)(v1 + 44) )
    {
      *(_DWORD *)(*a1 + 20) = 41;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    *(_DWORD *)(*a1 + 20) = 116;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    **(_BYTE **)(v1 + 40) = -1;
    *(_BYTE *)(*(_DWORD *)(v1 + 40) + 1) = -39;
    v7 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = 2;
    *(_DWORD *)v1 = v7;
    *(_BYTE *)(v1 + 44) = 0;
    return 1;
  }
  else
  {
    v4 = v3 - v2;
    if ( v4 > 4096 )
      v4 = 4096;
    qmemcpy(*(void **)(v1 + 40), (const void *)(v2 + *(_DWORD *)(v1 + 28)), v4);
    *(_DWORD *)(v1 + 36) += v4;
    v5 = *(_DWORD *)(v1 + 40);
    *(_DWORD *)(v1 + 4) = v4;
    *(_DWORD *)v1 = v5;
    *(_BYTE *)(v1 + 44) = 0;
    return 1;
  }
}

// sub_1003AAC0 @ 0x1003AAC0
void __cdecl sub_1003AAC0(_DWORD *a1, int a2)
{
  int v2; // esi
  _DWORD *v3; // edi
  int v4; // eax
  int v5; // eax

  v2 = a2;
  v3 = (_DWORD *)a1[5];
  if ( a2 > 0 )
  {
    v4 = v3[1];
    if ( a2 > v4 )
    {
      do
      {
        v2 -= v4;
        sub_1003AA20(a1);
        v4 = v3[1];
      }
      while ( v2 > v4 );
    }
    v5 = v3[1] - v2;
    *v3 += v2;
    v3[1] = v5;
  }
}

// nullsub_4 @ 0x1003AB00
void nullsub_4()
{
  ;
}

// sub_1003AB10 @ 0x1003AB10
_DWORD *__cdecl sub_1003AB10(_DWORD *a1)
{
  *a1 = sub_1003AB60;
  a1[1] = sub_1003ABC0;
  a1[2] = sub_1003AB80;
  a1[3] = sub_1003AC00;
  a1[4] = sub_1003ACB0;
  a1[26] = 0;
  a1[27] = 0;
  a1[5] = 0;
  a1[28] = off_1005035C;
  a1[29] = 119;
  a1[30] = 0;
  a1[31] = 0;
  a1[32] = 0;
  return a1;
}

// sub_1003AB60 @ 0x1003AB60
int __cdecl sub_1003AB60(int a1)
{
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 8))(a1);
  return sub_1003DD30(a1);
}

// sub_1003AB80 @ 0x1003AB80
int __cdecl sub_1003AB80(int a1)
{
  HWND ActiveWindow; // eax
  CHAR Text[200]; // [esp+0h] [ebp-C8h] BYREF

  (*(void (__cdecl **)(int, CHAR *))(*(_DWORD *)a1 + 12))(a1, Text);
  ActiveWindow = GetActiveWindow();
  return MessageBoxA(ActiveWindow, Text, aJpegError, 0);
}

// sub_1003ABC0 @ 0x1003ABC0
int __cdecl sub_1003ABC0(int *a1, int a2)
{
  int result; // eax
  int v3; // esi

  result = a2;
  v3 = *a1;
  if ( a2 >= 0 )
  {
    if ( *(_DWORD *)(v3 + 104) >= a2 )
      return (*(int (__cdecl **)(int *))(v3 + 8))(a1);
  }
  else
  {
    result = *(_DWORD *)(v3 + 108);
    if ( !result || *(int *)(v3 + 104) >= 3 )
      result = (*(int (__cdecl **)(int *))(v3 + 8))(a1);
    ++*(_DWORD *)(v3 + 108);
  }
  return result;
}

// sub_1003AC00 @ 0x1003AC00
int __cdecl sub_1003AC00(int a1, char *Buffer)
{
  _DWORD *v2; // eax
  int v3; // ecx
  const char *v4; // edx
  int v5; // esi
  int v6; // edx
  char v7; // cl
  char *v8; // esi
  bool v9; // zf

  v2 = *(_DWORD **)a1;
  v3 = *(_DWORD *)(*(_DWORD *)a1 + 20);
  if ( v3 <= 0 || v3 > v2[29] )
  {
    v5 = v2[30];
    if ( !v5 )
      goto LABEL_9;
    v6 = v2[31];
    if ( v3 < v6 || v3 > v2[32] )
      goto LABEL_9;
    v4 = *(const char **)(v5 + 4 * (v3 - v6));
  }
  else
  {
    v4 = *(const char **)(v2[28] + 4 * v3);
  }
  if ( !v4 )
  {
LABEL_9:
    v2[6] = v3;
    v4 = *(const char **)v2[28];
  }
  v7 = *v4;
  v8 = (char *)(v4 + 1);
  if ( !*v4 )
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  while ( 1 )
  {
    v9 = v7 == 37;
    v7 = *v8;
    if ( v9 )
      break;
    ++v8;
    if ( !v7 )
      return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
  }
  if ( v7 == 115 )
    return sprintf(Buffer, v4, v2 + 6);
  else
    return sprintf(Buffer, v4, v2[6], v2[7], v2[8], v2[9], v2[10], v2[11], v2[12], v2[13]);
}

// sub_1003ACB0 @ 0x1003ACB0
int __cdecl sub_1003ACB0(int *a1)
{
  int result; // eax

  *(_DWORD *)(*a1 + 108) = 0;
  result = *a1;
  *(_DWORD *)(*a1 + 20) = 0;
  return result;
}

// sub_1003ACD0 @ 0x1003ACD0
int __cdecl sub_1003ACD0(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 24);
  *(_DWORD *)(a1 + 396) = result;
  *(_DWORD *)result = sub_1003AFC0;
  *(_DWORD *)(result + 4) = sub_1003B520;
  *(_DWORD *)(result + 8) = sub_1003AD20;
  *(_DWORD *)(result + 12) = sub_1003AFA0;
  *(_BYTE *)(result + 16) = 0;
  *(_BYTE *)(result + 17) = 0;
  *(_BYTE *)(result + 20) = 1;
  return result;
}

// sub_1003AD20 @ 0x1003AD20
int __cdecl sub_1003AD20(int a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // esi
  int v5; // edx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  _DWORD *v9; // ecx
  unsigned int v10; // esi
  unsigned int v11; // ebp
  int v12; // edx
  int v13; // edi
  unsigned int v14; // eax
  int v15; // edx
  int v16; // edi
  int v17; // eax
  bool v18; // cc
  int v19; // ebp
  unsigned int v20; // esi
  void *v21; // eax
  int result; // eax
  int v23; // [esp+10h] [ebp-4h]
  int v24; // [esp+10h] [ebp-4h]
  int v25; // [esp+18h] [ebp+4h]
  int *v26; // [esp+18h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 288);
  if ( v2 == 1 )
  {
    v3 = *(_DWORD **)(a1 + 292);
    *(_DWORD *)(a1 + 308) = v3[7];
    *(_DWORD *)(a1 + 312) = v3[8];
    v4 = v3[3];
    v3[16] = v3[9];
    v5 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[17] = 1;
    if ( !v5 )
      v5 = v4;
    v3[18] = v5;
    *(_DWORD *)(a1 + 316) = 1;
    *(_DWORD *)(a1 + 320) = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 288);
      *(_DWORD *)(*(_DWORD *)a1 + 28) = 4;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v6 = sub_1003E460(*(_DWORD *)(a1 + 24), 8 * *(_DWORD *)(a1 + 268));
    v7 = 8 * *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 308) = v6;
    *(_DWORD *)(a1 + 312) = sub_1003E460(*(_DWORD *)(a1 + 28), v7);
    v8 = *(_DWORD *)(a1 + 288);
    *(_DWORD *)(a1 + 316) = 0;
    v25 = 0;
    if ( v8 > 0 )
    {
      v23 = a1 + 292;
      do
      {
        v9 = *(_DWORD **)v23;
        v10 = *(_DWORD *)(*(_DWORD *)v23 + 8);
        v11 = *(_DWORD *)(*(_DWORD *)v23 + 12);
        v9[16] = v10 * *(_DWORD *)(*(_DWORD *)v23 + 36);
        v12 = v9[7] % v10;
        v13 = v10 * v11;
        v9[13] = v10;
        v9[14] = v11;
        v9[15] = v10 * v11;
        if ( !v12 )
          v12 = v10;
        v14 = v9[8];
        v9[17] = v12;
        v15 = v14 % v11;
        if ( !(v14 % v11) )
          v15 = v11;
        v9[18] = v15;
        if ( v13 + *(_DWORD *)(a1 + 316) > 10 )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 11;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v10 * v11) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            *(_DWORD *)(a1 + 4 * *(_DWORD *)(a1 + 316) + 320) = v25;
            --v17;
            ++*(_DWORD *)(a1 + 316);
          }
          while ( v17 );
        }
        v18 = ++v25 < *(_DWORD *)(a1 + 288);
        v23 += 4;
      }
      while ( v18 );
    }
  }
  v24 = 0;
  if ( *(int *)(a1 + 288) > 0 )
  {
    v26 = (int *)(a1 + 292);
    do
    {
      v19 = *v26;
      if ( !*(_DWORD *)(*v26 + 76) )
      {
        v20 = *(_DWORD *)(v19 + 16);
        if ( v20 >= 4 || !*(_DWORD *)(a1 + 4 * v20 + 144) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
          *(_DWORD *)(*(_DWORD *)a1 + 24) = v20;
          (**(void (__cdecl ***)(int))a1)(a1);
        }
        v21 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
        qmemcpy(v21, *(const void **)(a1 + 4 * v20 + 144), 0x82u);
        *(_DWORD *)(v19 + 76) = v21;
      }
      v18 = ++v24 < *(_DWORD *)(a1 + 288);
      ++v26;
    }
    while ( v18 );
  }
  (**(void (__cdecl ***)(int))(a1 + 404))(a1);
  (**(void (__cdecl ***)(int))(a1 + 388))(a1);
  result = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
  **(_DWORD **)(a1 + 396) = result;
  return result;
}

// sub_1003AFA0 @ 0x1003AFA0
int __cdecl sub_1003AFA0(int a1)
{
  **(_DWORD **)(a1 + 396) = sub_1003AFC0;
  return a1;
}

// sub_1003AFC0 @ 0x1003AFC0
int __cdecl sub_1003AFC0(int a1)
{
  char v3; // al
  int v4; // eax
  int v5; // esi
  int v6; // edi
  int *v7; // esi
  int v8; // eax
  int v9; // eax
  int v10; // eax
  int v11; // eax
  int v12; // esi
  int v13; // edi
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // ecx
  int v18; // eax
  int v19; // ecx
  int v20; // ebx
  unsigned int v21; // esi
  void *v22; // eax
  bool v23; // cc
  int v24; // [esp+8h] [ebp-8h]
  int v25; // [esp+Ch] [ebp-4h]
  _BYTE *v26; // [esp+14h] [ebp+4h]
  int *v27; // [esp+14h] [ebp+4h]

  v26 = *(_BYTE **)(a1 + 396);
  if ( v26[17] )
    return 2;
  v25 = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 400) + 4))(a1);
  if ( v25 != 1 )
  {
    if ( v25 == 2 )
    {
      v3 = v26[20];
      v26[17] = 1;
      if ( v3 )
      {
        if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) )
        {
          *(_DWORD *)(*(_DWORD *)a1 + 20) = 58;
          (**(void (__cdecl ***)(int))a1)(a1);
          return v25;
        }
      }
      else
      {
        v4 = *(_DWORD *)(a1 + 124);
        if ( *(_DWORD *)(a1 + 132) > v4 )
        {
          *(_DWORD *)(a1 + 132) = v4;
          return v25;
        }
      }
    }
    return v25;
  }
  if ( !v26[20] )
  {
    if ( !v26[16] )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 34;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    sub_1003B370(a1);
    v24 = 0;
    if ( *(int *)(a1 + 288) > 0 )
    {
      v27 = (int *)(a1 + 292);
      do
      {
        v20 = *v27;
        if ( !*(_DWORD *)(*v27 + 76) )
        {
          v21 = *(_DWORD *)(v20 + 16);
          if ( v21 >= 4 || !*(_DWORD *)(a1 + 4 * v21 + 144) )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 51;
            *(_DWORD *)(*(_DWORD *)a1 + 24) = v21;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          v22 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 130);
          qmemcpy(v22, *(const void **)(a1 + 4 * v21 + 144), 0x82u);
          *(_DWORD *)(v20 + 76) = v22;
        }
        v23 = ++v24 < *(_DWORD *)(a1 + 288);
        ++v27;
      }
      while ( v23 );
    }
    (**(void (__cdecl ***)(int))(a1 + 404))(a1);
    (**(void (__cdecl ***)(int))(a1 + 388))(a1);
    **(_DWORD **)(a1 + 396) = *(_DWORD *)(*(_DWORD *)(a1 + 388) + 4);
    return v25;
  }
  if ( *(int *)(a1 + 28) > 65500 || *(int *)(a1 + 24) > 65500 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 40;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = 65500;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_DWORD *)(a1 + 192) != 8 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 13;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 192);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(int *)(a1 + 32) > 10 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 24;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 32);
    *(_DWORD *)(*(_DWORD *)a1 + 28) = 10;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v5 = *(_DWORD *)(a1 + 196);
  *(_DWORD *)(a1 + 268) = 1;
  *(_DWORD *)(a1 + 272) = 1;
  v6 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = (int *)(v5 + 12);
    do
    {
      v8 = *(v7 - 1);
      if ( v8 <= 0 || v8 > 4 || *v7 <= 0 || *v7 > 4 )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 16;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      v9 = *(_DWORD *)(a1 + 268);
      if ( v9 <= *(v7 - 1) )
        v9 = *(v7 - 1);
      *(_DWORD *)(a1 + 268) = v9;
      v10 = *(_DWORD *)(a1 + 272);
      if ( v10 <= *v7 )
        v10 = *v7;
      *(_DWORD *)(a1 + 272) = v10;
      ++v6;
      v7 += 21;
    }
    while ( v6 < *(_DWORD *)(a1 + 32) );
  }
  v11 = *(_DWORD *)(a1 + 32);
  v12 = *(_DWORD *)(a1 + 196);
  v13 = 0;
  *(_DWORD *)(a1 + 276) = 8;
  if ( v11 > 0 )
  {
    v14 = v12 + 28;
    do
    {
      v15 = *(_DWORD *)(v14 - 20);
      *(_DWORD *)(v14 + 8) = 8;
      *(_DWORD *)v14 = sub_1003E460(*(_DWORD *)(a1 + 24) * v15, 8 * *(_DWORD *)(a1 + 268));
      v16 = sub_1003E460(*(_DWORD *)(v14 - 16) * *(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
      v17 = *(_DWORD *)(v14 - 20);
      *(_DWORD *)(v14 + 4) = v16;
      *(_DWORD *)(v14 + 12) = sub_1003E460(*(_DWORD *)(a1 + 24) * v17, *(_DWORD *)(a1 + 268));
      *(_DWORD *)(v14 + 16) = sub_1003E460(*(_DWORD *)(v14 - 16) * *(_DWORD *)(a1 + 28), *(_DWORD *)(a1 + 272));
      *(_BYTE *)(v14 + 20) = 1;
      *(_DWORD *)(v14 + 48) = 0;
      ++v13;
      v14 += 84;
    }
    while ( v13 < *(_DWORD *)(a1 + 32) );
  }
  v18 = sub_1003E460(*(_DWORD *)(a1 + 28), 8 * *(_DWORD *)(a1 + 272));
  v19 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 280) = v18;
  if ( *(_DWORD *)(a1 + 288) < v19 || *(_BYTE *)(a1 + 200) )
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) = 1;
    v26[20] = 0;
    return 1;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) = 0;
    v26[20] = 0;
    return 1;
  }
}

// sub_1003B370 @ 0x1003B370
int __cdecl sub_1003B370(_DWORD *a1)
{
  int v2; // eax
  _DWORD *v3; // ecx
  unsigned int v4; // edi
  int result; // eax
  int v6; // edx
  int v7; // eax
  int v8; // edx
  _DWORD *v9; // ecx
  unsigned int v10; // edi
  unsigned int v11; // ebp
  int v12; // edx
  int v13; // ebx
  unsigned int v14; // eax
  int v15; // edx
  int v16; // ebx
  int v17; // eax
  bool v18; // cc
  _DWORD *v19; // [esp+Ch] [ebp-4h]
  int v20; // [esp+14h] [ebp+4h]

  v2 = a1[72];
  if ( v2 == 1 )
  {
    v3 = (_DWORD *)a1[73];
    a1[77] = v3[7];
    a1[78] = v3[8];
    v4 = v3[3];
    v3[16] = v3[9];
    result = v3[8] / v4;
    v6 = v3[8] % v4;
    v3[13] = 1;
    v3[14] = 1;
    v3[15] = 1;
    v3[17] = 1;
    if ( !v6 )
      v6 = v4;
    v3[18] = v6;
    a1[79] = 1;
    a1[80] = 0;
  }
  else
  {
    if ( v2 <= 0 || v2 > 4 )
    {
      *(_DWORD *)(*a1 + 20) = 24;
      *(_DWORD *)(*a1 + 24) = a1[72];
      *(_DWORD *)(*a1 + 28) = 4;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v7 = sub_1003E460(a1[6], 8 * a1[67]);
    v8 = 8 * a1[68];
    a1[77] = v7;
    a1[78] = sub_1003E460(a1[7], v8);
    result = a1[72];
    a1[79] = 0;
    v20 = 0;
    if ( result > 0 )
    {
      v19 = a1 + 73;
      do
      {
        v9 = (_DWORD *)*v19;
        v10 = *(_DWORD *)(*v19 + 8);
        v11 = *(_DWORD *)(*v19 + 12);
        v9[16] = v10 * *(_DWORD *)(*v19 + 36);
        v12 = v9[7] % v10;
        v13 = v10 * v11;
        v9[13] = v10;
        v9[14] = v11;
        v9[15] = v10 * v11;
        if ( !v12 )
          v12 = v10;
        v14 = v9[8];
        v9[17] = v12;
        v15 = v14 % v11;
        if ( !(v14 % v11) )
          v15 = v11;
        v9[18] = v15;
        if ( v13 + a1[79] > 10 )
        {
          *(_DWORD *)(*a1 + 20) = 11;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
        v16 = v13 - 1;
        if ( (int)(v10 * v11) > 0 )
        {
          v17 = v16 + 1;
          do
          {
            a1[a1[79] + 80] = v20;
            --v17;
            ++a1[79];
          }
          while ( v17 );
        }
        result = v20 + 1;
        v18 = ++v20 < a1[72];
        ++v19;
      }
      while ( v18 );
    }
  }
  return result;
}

// sub_1003B520 @ 0x1003B520
int __cdecl sub_1003B520(int a1)
{
  int v1; // eax
  int result; // eax

  v1 = *(_DWORD *)(a1 + 396);
  *(_DWORD *)v1 = sub_1003AFC0;
  *(_BYTE *)(v1 + 16) = 0;
  *(_BYTE *)(v1 + 17) = 0;
  *(_BYTE *)(v1 + 20) = 1;
  (*(void (__cdecl **)(int))(*(_DWORD *)a1 + 16))(a1);
  result = (**(int (__cdecl ***)(int))(a1 + 400))(a1);
  *(_DWORD *)(a1 + 140) = 0;
  return result;
}

// sub_1003B560 @ 0x1003B560
char __cdecl sub_1003B560(_DWORD *a1, int a2)
{
  int v2; // esi
  int v3; // ebx
  int v4; // ebx
  int v5; // ebx

  v2 = a1[94];
  *(_DWORD *)(*a1 + 20) = 117;
  *(_DWORD *)(*a1 + 24) = v2;
  *(_DWORD *)(*a1 + 28) = a2;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  while ( 1 )
  {
    if ( v2 < 192 )
    {
LABEL_3:
      v3 = 2;
      goto LABEL_12;
    }
    if ( v2 < 208 || v2 > 215 || v2 == (((_BYTE)a2 + 1) & 7) + 208 || v2 == (((_BYTE)a2 + 2) & 7) + 208 )
    {
      v3 = 3;
    }
    else
    {
      if ( v2 == (((_BYTE)a2 - 1) & 7) + 208 || v2 == (((_BYTE)a2 - 2) & 7) + 208 )
        goto LABEL_3;
      v3 = 1;
    }
LABEL_12:
    *(_DWORD *)(*a1 + 20) = 96;
    *(_DWORD *)(*a1 + 24) = v2;
    *(_DWORD *)(*a1 + 28) = v3;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 4);
    v4 = v3 - 1;
    if ( !v4 )
      break;
    v5 = v4 - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
        return 1;
    }
    else
    {
      if ( !(unsigned __int8)sub_1003B660(a1) )
        return 0;
      v2 = a1[94];
    }
  }
  a1[94] = 0;
  return 1;
}

// sub_1003B660 @ 0x1003B660
char __cdecl sub_1003B660(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // esi
  unsigned __int8 *v4; // edi
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v9; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  while ( 1 )
  {
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    --v3;
    ++v4;
    if ( v5 == 255 )
      goto LABEL_10;
    do
    {
      ++*(_DWORD *)(a1[100] + 88);
      *v2 = v4;
      v2[1] = v3;
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
      }
      v6 = *v4;
      --v3;
      ++v4;
    }
    while ( v6 != 255 );
    do
    {
LABEL_10:
      if ( !v3 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v4 = *v2;
        v3 = v2[1];
      }
      v7 = *v4;
      --v3;
      ++v4;
      v9 = v7;
    }
    while ( v7 == 255 );
    if ( v7 )
      break;
    *(_DWORD *)(a1[100] + 88) += 2;
    *v2 = v4;
    v2[1] = v3;
  }
  if ( *(_DWORD *)(a1[100] + 88) )
  {
    *(_DWORD *)(*a1 + 20) = 112;
    *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 88);
    *(_DWORD *)(*a1 + 28) = v7;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    v7 = v9;
    *(_DWORD *)(a1[100] + 88) = 0;
  }
  a1[94] = v7;
  *v2 = v4;
  v2[1] = v3;
  return 1;
}

// sub_1003B770 @ 0x1003B770
int __cdecl sub_1003B770(int a1)
{
  _DWORD *v1; // eax
  int i; // eax
  int v3; // ecx
  int result; // eax

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 92);
  *(_DWORD *)(a1 + 400) = v1;
  *v1 = sub_1003D090;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 4) = sub_1003BD30;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 8) = sub_1003D000;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 12) = sub_1003BC90;
  for ( i = 16; i < 80; i += 4 )
    *(_DWORD *)(*(_DWORD *)(a1 + 400) + i) = sub_1003BC90;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 16) = sub_1003B820;
  *(_DWORD *)(*(_DWORD *)(a1 + 400) + 72) = sub_1003BAC0;
  v3 = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(a1 + 196) = 0;
  *(_DWORD *)(a1 + 124) = 0;
  *(_DWORD *)(a1 + 376) = 0;
  *(_BYTE *)(v3 + 80) = 0;
  *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) = 0;
  result = *(_DWORD *)(a1 + 400);
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// sub_1003B820 @ 0x1003B820
char __cdecl sub_1003B820(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 v12; // dl
  int v13; // ecx
  unsigned __int8 v14; // al
  __int16 v15; // bx
  __int16 v17; // ax
  __int16 v18; // dx
  unsigned __int16 v19; // cx
  __int16 v20; // dx
  __int16 v21; // ax
  __int16 v22; // dx
  _DWORD *v23; // eax
  unsigned __int8 v24; // bl
  unsigned __int8 v25; // al
  int v26; // [esp+10h] [ebp-1Ch]
  unsigned __int8 **v27; // [esp+14h] [ebp-18h]
  _BYTE v28[5]; // [esp+18h] [ebp-14h]
  unsigned __int8 v29; // [esp+1Dh] [ebp-Fh]
  __int16 v30; // [esp+1Eh] [ebp-Eh]
  unsigned __int8 v31; // [esp+20h] [ebp-Ch]
  unsigned __int8 v32; // [esp+21h] [ebp-Bh]
  unsigned __int8 v33; // [esp+22h] [ebp-Ah]
  unsigned __int8 v34; // [esp+23h] [ebp-9h]
  __int16 v35; // [esp+24h] [ebp-8h]
  int v36; // [esp+30h] [ebp+4h]
  int v37; // [esp+30h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  v27 = v2;
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v36 = (unsigned __int16)v5;
  if ( v6 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v7 = *v2;
  v6 = v2[1];
  v5 = v36;
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  v37 = v9;
  if ( v9 < 14 )
  {
    *(_DWORD *)(*a1 + 20) = 76;
  }
  else
  {
    v11 = 0;
    v26 = 0;
    do
    {
      if ( !v8 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v10 = *v2;
        v8 = v2[1];
        v11 = v26;
        v9 = v37;
      }
      v12 = *v10;
      --v8;
      ++v10;
      v28[v11++] = v12;
      v26 = v11;
    }
    while ( v11 < 14 );
    v13 = v9 - 14;
    v37 = v13;
    if ( v28[0] == 74 && v28[1] == 70 && v28[2] == 73 && v28[3] == 70 && !v28[4] )
    {
      v14 = v29;
      if ( v29 == 1 )
      {
        v15 = v30;
        if ( (unsigned __int8)v30 > 2u )
        {
          *(_DWORD *)(*a1 + 20) = 88;
          *(_DWORD *)(*a1 + 24) = 1;
          *(_DWORD *)(*a1 + 28) = (unsigned __int8)v15;
          (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        }
      }
      else
      {
        v15 = v30;
        *(_DWORD *)(*a1 + 20) = 115;
        *(_DWORD *)(*a1 + 24) = v14;
        *(_DWORD *)(*a1 + 28) = (unsigned __int8)v15;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
      }
      v17 = v32;
      v18 = v31;
      *((_BYTE *)a1 + 257) = HIBYTE(v15);
      *((_BYTE *)a1 + 256) = 1;
      v19 = (v18 << 8) + v17;
      v20 = v33;
      v21 = v34;
      *((_WORD *)a1 + 129) = v19;
      v22 = v21 + (v20 << 8);
      v23 = (_DWORD *)*a1;
      *((_WORD *)a1 + 130) = v22;
      v23 += 6;
      *v23 = v19;
      v23[1] = *((unsigned __int16 *)a1 + 130);
      v23[2] = *((unsigned __int8 *)a1 + 257);
      *(_DWORD *)(*a1 + 20) = 86;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      v24 = HIBYTE(v35);
      v25 = v35;
      if ( v35 )
      {
        *(_DWORD *)(*a1 + 20) = 89;
        *(_DWORD *)(*a1 + 24) = v25;
        *(_DWORD *)(*a1 + 28) = v24;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        v25 = v35;
      }
      if ( v37 != 3 * v25 * v24 )
      {
        *(_DWORD *)(*a1 + 20) = 87;
        *(_DWORD *)(*a1 + 24) = v37;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      }
      v2 = v27;
      goto LABEL_28;
    }
    *(_DWORD *)(*a1 + 20) = 76;
    v9 = v13 + 14;
  }
  *(_DWORD *)(*a1 + 24) = v9;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
LABEL_28:
  *v2 = v10;
  v2[1] = v8;
  if ( v37 > 0 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v37);
  return 1;
}

// sub_1003BAC0 @ 0x1003BAC0
char __cdecl sub_1003BAC0(_DWORD *a1)
{
  unsigned __int8 **v2; // ebx
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // edi
  int v5; // ecx
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // edi
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 v12; // dl
  int v13; // ecx
  unsigned __int8 v14; // dl
  _DWORD *v15; // eax
  int v16; // ecx
  unsigned __int8 v17; // dl
  int v19; // [esp+10h] [ebp-14h]
  int v20; // [esp+10h] [ebp-14h]
  _BYTE v21[16]; // [esp+14h] [ebp-10h]
  int v22; // [esp+28h] [ebp+4h]
  int v23; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v22 = (unsigned __int16)v5;
  if ( v6 )
    goto LABEL_7;
  if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    return 0;
  v7 = *v2;
  v6 = v2[1];
  v5 = v22;
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  v23 = v9;
  if ( v9 < 12 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    goto LABEL_22;
  }
  v11 = 0;
  v19 = 0;
  do
  {
    if ( !v8 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v10 = *v2;
      v8 = v2[1];
      v9 = v23;
      v11 = v19;
    }
    v12 = *v10;
    --v8;
    ++v10;
    v21[v11++] = v12;
    v19 = v11;
  }
  while ( v11 < 12 );
  v13 = v9 - 12;
  v23 = v13;
  if ( v21[0] != 65 || v21[1] != 100 || v21[2] != 111 || v21[3] != 98 || v21[4] != 101 )
  {
    *(_DWORD *)(*a1 + 20) = 77;
    v9 = v13 + 12;
LABEL_22:
    *(_DWORD *)(*a1 + 24) = v9;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    goto LABEL_23;
  }
  v14 = v21[8];
  v20 = v21[11];
  v15 = (_DWORD *)*a1;
  v15[6] = v21[6] + (v21[5] << 8);
  v15 += 6;
  v16 = v14 + (v21[7] << 8);
  v17 = v21[10];
  v15[1] = v16;
  v15[2] = v17 + (v21[9] << 8);
  v15[3] = v20;
  *(_DWORD *)(*a1 + 20) = 75;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  *((_BYTE *)a1 + 262) = 1;
  *((_BYTE *)a1 + 263) = v20;
LABEL_23:
  *v2 = v10;
  v2[1] = v8;
  if ( v23 > 0 )
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v23);
  return 1;
}

// sub_1003BC90 @ 0x1003BC90
char __cdecl sub_1003BC90(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // ebp
  unsigned __int16 v5; // ax
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  int v8; // ecx
  int v10; // [esp+14h] [ebp+4h]
  int v11; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v10 = v5;
  if ( v6 )
  {
LABEL_7:
    v8 = *v7;
    *(_DWORD *)(*a1 + 20) = 90;
    v11 = v8 + v10;
    *(_DWORD *)(*a1 + 24) = a1[94];
    *(_DWORD *)(*a1 + 28) = v11;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    *v2 = v7 + 1;
    v2[1] = v6 - 1;
    (*(void (__cdecl **)(_DWORD *, int))(a1[5] + 16))(a1, v11 - 2);
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v7 = *v2;
    v6 = v2[1];
    goto LABEL_7;
  }
  return 0;
}

// sub_1003BD30 @ 0x1003BD30
int __cdecl sub_1003BD30(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // ebp
  int v5; // ecx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  int v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  _BYTE *v12; // eax
  int v13; // eax
  char v14; // al
  unsigned __int8 **v15; // ebx
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // ebp
  unsigned __int16 v18; // cx
  unsigned __int8 *v19; // eax
  unsigned __int8 *v20; // ebp
  int v21; // edi
  unsigned __int8 *v22; // eax
  int v23; // edi
  unsigned __int8 *v24; // ebp
  int v25; // ecx
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // ebp
  int v28; // edi
  int v29; // ebx
  char v31; // [esp-4h] [ebp-1Ch]
  int v32; // [esp+10h] [ebp-8h]
  unsigned __int8 **v33; // [esp+14h] [ebp-4h]
  int v34; // [esp+1Ch] [ebp+4h]
  int v35; // [esp+1Ch] [ebp+4h]
  unsigned __int8 *v36; // [esp+1Ch] [ebp+4h]

  while ( 1 )
  {
    if ( a1[94] )
      goto LABEL_14;
    if ( *(_BYTE *)(a1[100] + 80) )
      break;
    v2 = (unsigned __int8 **)a1[5];
    v3 = v2[1];
    v4 = *v2;
    if ( !v3 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v4 = *v2;
      v3 = v2[1];
    }
    v5 = *v4;
    v6 = v3 - 1;
    v7 = v4 + 1;
    v34 = v5;
    if ( !v6 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v7 = *v2;
      v6 = v2[1];
      v5 = v34;
    }
    v8 = *v7;
    v9 = v6 - 1;
    v10 = v7 + 1;
    v35 = v8;
    if ( v5 != 255 || v8 != 216 )
    {
      *(_DWORD *)(*a1 + 20) = 52;
      *(_DWORD *)(*a1 + 24) = v5;
      *(_DWORD *)(*a1 + 28) = v8;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      v8 = v35;
    }
    a1[94] = v8;
    *v2 = v10;
    v2[1] = v9;
LABEL_14:
    v11 = a1[94];
    switch ( v11 )
    {
      case 1:
      case 208:
      case 209:
      case 210:
      case 211:
      case 212:
      case 213:
      case 214:
      case 215:
        *(_DWORD *)(*a1 + 20) = 91;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[94] = 0;
        continue;
      case 192:
      case 193:
        v14 = sub_1003C320(a1, 0, 0);
        goto LABEL_25;
      case 194:
        v31 = 0;
        goto LABEL_24;
      case 195:
      case 197:
      case 198:
      case 199:
      case 200:
      case 203:
      case 205:
      case 206:
      case 207:
        *(_DWORD *)(*a1 + 20) = 59;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[94] = 0;
        continue;
      case 196:
        if ( !(unsigned __int8)sub_1003C950(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 201:
        v14 = sub_1003C320(a1, 0, 1);
        goto LABEL_25;
      case 202:
        v31 = 1;
LABEL_24:
        v14 = sub_1003C320(a1, 1, v31);
LABEL_25:
        if ( !v14 )
          return 0;
        a1[94] = 0;
        continue;
      case 204:
        v15 = (unsigned __int8 **)a1[5];
        v16 = v15[1];
        v17 = *v15;
        v33 = v15;
        if ( v16 )
          goto LABEL_31;
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v17 = *v15;
        v16 = v15[1];
LABEL_31:
        LOBYTE(v18) = 0;
        HIBYTE(v18) = *v17;
        v19 = v16 - 1;
        v20 = v17 + 1;
        v21 = v18;
        if ( v19 )
          goto LABEL_34;
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v20 = *v15;
        v19 = v15[1];
LABEL_34:
        v22 = v19 - 1;
        v23 = *v20 + v21 - 2;
        v24 = v20 + 1;
        v32 = v23;
        if ( v23 <= 0 )
          goto LABEL_48;
        break;
      case 216:
        *(_DWORD *)(*a1 + 20) = 101;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        if ( *(_BYTE *)(a1[100] + 80) )
        {
          *(_DWORD *)(*a1 + 20) = 60;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
        v12 = (char *)a1 + 218;
        do
        {
          *(v12 - 16) = 0;
          *v12 = 1;
          v12[16] = 5;
          ++v12;
        }
        while ( (int)&v12[-218 - (_DWORD)a1] < 16 );
        v13 = a1[100];
        a1[63] = 0;
        a1[9] = 0;
        *((_BYTE *)a1 + 264) = 0;
        *((_BYTE *)a1 + 256) = 0;
        *((_BYTE *)a1 + 257) = 0;
        *((_WORD *)a1 + 129) = 1;
        *((_WORD *)a1 + 130) = 1;
        *((_BYTE *)a1 + 262) = 0;
        *((_BYTE *)a1 + 263) = 0;
        *(_BYTE *)(v13 + 80) = 1;
        a1[94] = 0;
        continue;
      case 217:
        *(_DWORD *)(*a1 + 20) = 84;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
        a1[94] = 0;
        return 2;
      case 218:
        if ( !(unsigned __int8)sub_1003C640(a1) )
          return 0;
        a1[94] = 0;
        return 1;
      case 219:
        if ( !(unsigned __int8)sub_1003CCA0(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 220:
        if ( !sub_1003BC90(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 221:
        if ( !(unsigned __int8)sub_1003CF10(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 224:
      case 225:
      case 226:
      case 227:
      case 228:
      case 229:
      case 230:
      case 231:
      case 232:
      case 233:
      case 234:
      case 235:
      case 236:
      case 237:
      case 238:
      case 239:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 4 * v11 - 880))(a1) )
          return 0;
        a1[94] = 0;
        continue;
      case 254:
        if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 12))(a1) )
          return 0;
        a1[94] = 0;
        continue;
      default:
        *(_DWORD *)(*a1 + 20) = 67;
        *(_DWORD *)(*a1 + 24) = a1[94];
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        a1[94] = 0;
        continue;
    }
    do
    {
      if ( !v22 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v24 = *v15;
        v22 = v15[1];
      }
      v25 = *v24;
      v26 = v22 - 1;
      v27 = v24 + 1;
      v28 = v25;
      if ( !v26 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
          return 0;
        v27 = *v15;
        v26 = v15[1];
      }
      v29 = *v27;
      v36 = v26 - 1;
      *(_DWORD *)(*a1 + 20) = 78;
      *(_DWORD *)(*a1 + 24) = v28;
      v32 -= 2;
      *(_DWORD *)(*a1 + 28) = v29;
      v24 = v27 + 1;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      if ( v28 >= 32 )
      {
        *(_DWORD *)(*a1 + 20) = 26;
        *(_DWORD *)(*a1 + 24) = v28;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      if ( v28 < 16 )
      {
        *((_BYTE *)a1 + v28 + 202) = v29 & 0xF;
        *((_BYTE *)a1 + v28 + 218) = v29 >> 4;
        if ( *((_BYTE *)a1 + v28 + 202) > (unsigned __int8)(v29 >> 4) )
        {
          *(_DWORD *)(*a1 + 20) = 27;
          *(_DWORD *)(*a1 + 24) = v29;
          (*(void (__cdecl **)(_DWORD *))*a1)(a1);
        }
      }
      else
      {
        *((_BYTE *)a1 + v28 + 218) = v29;
      }
      v15 = v33;
      v22 = v36;
    }
    while ( v32 > 0 );
LABEL_48:
    *v15 = v24;
    v15[1] = v22;
    a1[94] = 0;
  }
  if ( sub_1003B660(a1) )
    goto LABEL_14;
  return 0;
}

// sub_1003C320 @ 0x1003C320
char __cdecl sub_1003C320(int a1, char a2, char a3)
{
  unsigned __int8 **v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned __int16 v7; // dx
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // edi
  unsigned __int8 *v10; // ebx
  int v11; // ecx
  unsigned __int8 *v12; // edi
  int v13; // ecx
  unsigned __int8 *v14; // ebx
  unsigned __int8 *v15; // edi
  unsigned __int16 v16; // dx
  unsigned __int8 *v17; // ebx
  unsigned __int8 *v18; // edi
  unsigned __int8 *v19; // ebx
  int v20; // ecx
  unsigned __int8 *v21; // edi
  unsigned __int16 v22; // cx
  unsigned __int8 *v23; // ebx
  unsigned __int8 *v24; // edi
  unsigned __int8 *v25; // ebx
  int v26; // ecx
  unsigned __int8 *v27; // edi
  int v28; // ecx
  int v29; // eax
  unsigned __int8 *v30; // ebx
  unsigned __int8 *v31; // edi
  _DWORD *v32; // eax
  _DWORD *v33; // ebp
  int v34; // edx
  unsigned __int8 *v35; // ebx
  unsigned __int8 *v36; // edi
  int v37; // eax
  unsigned __int8 *v38; // ebx
  unsigned __int8 *v39; // edi
  int v40; // edx
  _DWORD *v41; // eax
  unsigned __int8 **v43; // [esp+14h] [ebp+4h]
  int v44; // [esp+18h] [ebp+8h]
  int v45; // [esp+18h] [ebp+8h]
  int v46; // [esp+18h] [ebp+8h]
  int i; // [esp+18h] [ebp+8h]

  v4 = *(unsigned __int8 ***)(a1 + 20);
  v5 = v4[1];
  v6 = *v4;
  v43 = v4;
  *(_BYTE *)(a1 + 200) = a2;
  *(_BYTE *)(a1 + 201) = a3;
  if ( !v5 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v6 = *v4;
    v5 = v4[1];
  }
  LOBYTE(v7) = 0;
  HIBYTE(v7) = *v6;
  v8 = v5 - 1;
  v9 = v6 + 1;
  v44 = v7;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v9 = *v4;
    v8 = v4[1];
  }
  v10 = v8 - 1;
  v11 = *v9 + v44;
  v12 = v9 + 1;
  v45 = v11;
  if ( !v10 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v12 = *v4;
    v10 = v4[1];
  }
  v13 = *v12;
  v14 = v10 - 1;
  v15 = v12 + 1;
  *(_DWORD *)(a1 + 192) = v13;
  if ( !v14 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v15 = *v4;
    v14 = v4[1];
  }
  LOBYTE(v16) = 0;
  HIBYTE(v16) = *v15;
  v17 = v14 - 1;
  v18 = v15 + 1;
  *(_DWORD *)(a1 + 28) = v16;
  if ( !v17 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v18 = *v4;
    v17 = v4[1];
  }
  v19 = v17 - 1;
  v20 = *v18 + *(_DWORD *)(a1 + 28);
  v21 = v18 + 1;
  *(_DWORD *)(a1 + 28) = v20;
  if ( !v19 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v21 = *v4;
    v19 = v4[1];
  }
  LOBYTE(v22) = 0;
  HIBYTE(v22) = *v21;
  v23 = v19 - 1;
  v24 = v21 + 1;
  *(_DWORD *)(a1 + 24) = v22;
  if ( !v23 )
  {
    if ( !((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
      return 0;
    v24 = *v4;
    v23 = v4[1];
  }
  v25 = v23 - 1;
  v26 = *v24 + *(_DWORD *)(a1 + 24);
  v27 = v24 + 1;
  *(_DWORD *)(a1 + 24) = v26;
  if ( !v25 )
  {
    if ( ((unsigned __int8 (__cdecl *)(int))v4[3])(a1) )
    {
      v27 = *v4;
      v25 = v4[1];
      goto LABEL_25;
    }
    return 0;
  }
LABEL_25:
  v28 = *(_DWORD *)(a1 + 376);
  v29 = *v27;
  v46 = v45 - 8;
  v30 = v25 - 1;
  v31 = v27 + 1;
  *(_DWORD *)(a1 + 32) = v29;
  v32 = (_DWORD *)(*(_DWORD *)a1 + 24);
  *v32 = v28;
  v32[1] = *(_DWORD *)(a1 + 24);
  v32[2] = *(_DWORD *)(a1 + 28);
  v32[3] = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 99;
  (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 57;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 28) || !*(_DWORD *)(a1 + 24) || *(int *)(a1 + 32) <= 0 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 31;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( v46 != 3 * *(_DWORD *)(a1 + 32) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 9;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_DWORD *)(a1 + 196) )
    *(_DWORD *)(a1 + 196) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84 * *(_DWORD *)(a1 + 32));
  v33 = *(_DWORD **)(a1 + 196);
  for ( i = 0; i < *(_DWORD *)(a1 + 32); ++i )
  {
    v33[1] = i;
    if ( !v30 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v31 = *v43;
      v30 = v43[1];
    }
    v34 = *v31;
    v35 = v30 - 1;
    v36 = v31 + 1;
    *v33 = v34;
    if ( !v35 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v36 = *v43;
      v35 = v43[1];
    }
    v37 = *v36;
    v38 = v35 - 1;
    v39 = v36 + 1;
    v33[2] = (v37 >> 4) & 0xF;
    v33[3] = v37 & 0xF;
    if ( !v38 )
    {
      if ( !((unsigned __int8 (__cdecl *)(int))v43[3])(a1) )
        return 0;
      v39 = *v43;
      v38 = v43[1];
    }
    v40 = *v39;
    v30 = v38 - 1;
    v31 = v39 + 1;
    v33[4] = v40;
    v41 = (_DWORD *)(*(_DWORD *)a1 + 24);
    *v41 = *v33;
    v41[1] = v33[2];
    v41[2] = v33[3];
    v41[3] = v33[4];
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 100;
    (*(void (__cdecl **)(int, int))(*(_DWORD *)a1 + 4))(a1, 1);
    v33 += 21;
  }
  *(_BYTE *)(*(_DWORD *)(a1 + 400) + 81) = 1;
  *v43 = v31;
  v43[1] = v30;
  return 1;
}

// sub_1003C640 @ 0x1003C640
char __cdecl sub_1003C640(_DWORD *a1)
{
  unsigned __int8 **v2; // edi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  unsigned __int16 v5; // cx
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // ebp
  unsigned __int8 *v8; // ebx
  int v9; // ecx
  unsigned __int8 *v10; // ebp
  int v11; // eax
  unsigned __int8 *v12; // ebx
  unsigned __int8 *v13; // ebp
  int v14; // edx
  unsigned __int8 *v15; // ebx
  unsigned __int8 *v16; // ebp
  int v17; // ecx
  _DWORD *v18; // edi
  int v19; // ebx
  int v20; // eax
  _DWORD *v21; // eax
  bool v22; // cc
  int v23; // eax
  unsigned __int8 *v24; // ebx
  unsigned __int8 *v25; // ebp
  int v26; // eax
  unsigned __int8 *v27; // ebx
  unsigned __int8 *v28; // ebp
  int v29; // edx
  int v30; // ecx
  _DWORD *v31; // eax
  int v33; // [esp+10h] [ebp-14h]
  int v34; // [esp+10h] [ebp-14h]
  int v35; // [esp+10h] [ebp-14h]
  _DWORD *v36; // [esp+14h] [ebp-10h]
  int v37; // [esp+18h] [ebp-Ch]
  int v38; // [esp+1Ch] [ebp-8h]
  unsigned __int8 **v39; // [esp+20h] [ebp-4h]
  unsigned __int8 *v40; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  v39 = v2;
  if ( !*(_BYTE *)(a1[100] + 81) )
  {
    *(_DWORD *)(*a1 + 20) = 61;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  LOBYTE(v5) = 0;
  HIBYTE(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v33 = v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
  }
  v8 = v6 - 1;
  v9 = *v7 + v33;
  v10 = v7 + 1;
  v34 = v9;
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  v11 = *v10;
  v12 = v8 - 1;
  v13 = v10 + 1;
  v37 = v11;
  if ( v34 != 2 * v11 + 6 || v11 < 1 || v11 > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    v11 = v37;
  }
  *(_DWORD *)(*a1 + 20) = 102;
  *(_DWORD *)(*a1 + 24) = v11;
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  a1[72] = v37;
  v38 = 0;
  if ( v37 > 0 )
  {
    v36 = a1 + 73;
    do
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v13 = *v2;
        v12 = v2[1];
      }
      v14 = *v13;
      v15 = v12 - 1;
      v16 = v13 + 1;
      v35 = v14;
      if ( !v15 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
          return 0;
        v16 = *v2;
        v15 = v2[1];
      }
      v17 = a1[8];
      v18 = (_DWORD *)a1[49];
      v40 = v15 - 1;
      v19 = *v16;
      v13 = v16 + 1;
      v20 = 0;
      if ( v17 <= 0 )
      {
LABEL_27:
        *(_DWORD *)(*a1 + 20) = 5;
        *(_DWORD *)(*a1 + 24) = v35;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      else
      {
        while ( v35 != *v18 )
        {
          ++v20;
          v18 += 21;
          if ( v20 >= v17 )
            goto LABEL_27;
        }
      }
      *v36 = v18;
      v18[5] = (v19 >> 4) & 0xF;
      v18[6] = v19 & 0xF;
      v21 = (_DWORD *)(*a1 + 24);
      *v21 = v35;
      v21[1] = v18[5];
      v21[2] = v18[6];
      *(_DWORD *)(*a1 + 20) = 103;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
      v12 = v40;
      v2 = v39;
      v22 = ++v38 < v37;
      ++v36;
    }
    while ( v22 );
  }
  if ( !v12 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v13 = *v2;
    v12 = v2[1];
  }
  v23 = *v13;
  v24 = v12 - 1;
  v25 = v13 + 1;
  a1[90] = v23;
  if ( !v24 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v25 = *v2;
    v24 = v2[1];
  }
  v26 = *v25;
  v27 = v24 - 1;
  v28 = v25 + 1;
  a1[91] = v26;
  if ( v27 )
  {
LABEL_38:
    v29 = a1[90];
    v30 = *v28;
    a1[93] = v30 & 0xF;
    v31 = (_DWORD *)(*a1 + 24);
    a1[92] = (v30 >> 4) & 0xF;
    *v31 = v29;
    v31[1] = a1[91];
    v31[2] = a1[92];
    v31[3] = a1[93];
    *(_DWORD *)(*a1 + 20) = 104;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    *(_DWORD *)(a1[100] + 84) = 0;
    ++a1[31];
    *v2 = v28 + 1;
    v2[1] = v27 - 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v28 = *v2;
    v27 = v2[1];
    goto LABEL_38;
  }
  return 0;
}

// sub_1003C950 @ 0x1003C950
char __cdecl sub_1003C950(_DWORD *a1)
{
  unsigned __int8 **v1; // esi
  unsigned __int8 *v2; // ebx
  unsigned __int8 *v3; // edi
  int v4; // eax
  unsigned __int8 *v5; // edi
  unsigned __int8 *v6; // ebx
  unsigned __int8 *v7; // edi
  int v8; // eax
  unsigned __int8 *v9; // ebx
  unsigned int v10; // eax
  int v11; // edx
  unsigned __int8 *v12; // edi
  int j; // esi
  int v14; // eax
  int v15; // edx
  _DWORD *v16; // eax
  unsigned __int8 v17; // cl
  unsigned __int8 v18; // cl
  unsigned __int8 v19; // cl
  unsigned __int8 v20; // cl
  _DWORD *v21; // eax
  unsigned __int8 v22; // dl
  unsigned __int8 v23; // cl
  unsigned __int8 v24; // dl
  unsigned __int8 v25; // cl
  unsigned __int8 v26; // dl
  unsigned __int8 v27; // cl
  int v28; // esi
  int v29; // eax
  unsigned __int8 v30; // cl
  unsigned int v31; // eax
  int v32; // edi
  int v33; // eax
  int v34; // edx
  int v35; // ecx
  int v36; // edx
  unsigned __int8 *v38; // [esp+10h] [ebp-128h]
  int v39; // [esp+14h] [ebp-124h]
  int i; // [esp+14h] [ebp-124h]
  int v41; // [esp+14h] [ebp-124h]
  int v42; // [esp+18h] [ebp-120h]
  int k; // [esp+18h] [ebp-120h]
  unsigned __int8 **v44; // [esp+1Ch] [ebp-11Ch]
  int v45; // [esp+20h] [ebp-118h]
  int v46; // [esp+24h] [ebp-114h]
  int v47; // [esp+28h] [ebp-110h]
  int v48; // [esp+2Ch] [ebp-10Ch]
  unsigned __int8 v49; // [esp+30h] [ebp-108h]
  unsigned int v50; // [esp+34h] [ebp-104h]
  _BYTE v51[256]; // [esp+38h] [ebp-100h] BYREF

  v1 = (unsigned __int8 **)a1[5];
  v2 = *v1;
  v3 = v1[1];
  v44 = v1;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
      return 0;
    v2 = *v1;
    v3 = v1[1];
  }
  v4 = 0;
  BYTE1(v4) = *v2;
  v5 = v3 - 1;
  v6 = v2 + 1;
  v39 = (unsigned __int16)v4;
  if ( !v5 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
    {
      v6 = *v1;
      v4 = v39;
      v5 = v1[1];
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v7 = v5 - 1;
  v8 = *v6 + v4 - 2;
  v9 = v6 + 1;
  for ( i = v8; i > 0; v1 = v44 )
  {
    if ( !v7 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v1[3])(a1) )
        return 0;
      v9 = *v1;
      v7 = v1[1];
    }
    v10 = *v9;
    *(_DWORD *)(*a1 + 20) = 79;
    v11 = *a1;
    v12 = v7 - 1;
    ++v9;
    v50 = v10;
    *(_DWORD *)(v11 + 24) = v10;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    LOBYTE(v45) = 0;
    v42 = 0;
    for ( j = 1; j <= 16; ++j )
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v44[3])(a1) )
          return 0;
        v9 = *v44;
        v12 = v44[1];
      }
      v14 = *v9;
      *((_BYTE *)&v45 + j) = *v9;
      --v12;
      ++v9;
      v38 = v12;
      v42 += v14;
    }
    v15 = BYTE2(v45);
    v41 = i - 17;
    v16 = (_DWORD *)(*a1 + 24);
    *v16 = BYTE1(v45);
    v17 = HIBYTE(v45);
    v16[1] = v15;
    LOBYTE(v15) = v46;
    v16[2] = v17;
    v18 = BYTE1(v46);
    v16[3] = (unsigned __int8)v15;
    LOBYTE(v15) = BYTE2(v46);
    v16[4] = v18;
    v19 = HIBYTE(v46);
    v16[5] = (unsigned __int8)v15;
    LOBYTE(v15) = v47;
    v16[6] = v19;
    v16[7] = (unsigned __int8)v15;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v20 = BYTE2(v47);
    v21 = (_DWORD *)(*a1 + 24);
    *v21 = BYTE1(v47);
    v22 = HIBYTE(v47);
    v21[1] = v20;
    v23 = v48;
    v21[2] = v22;
    v24 = BYTE1(v48);
    v21[3] = v23;
    v25 = BYTE2(v48);
    v21[4] = v24;
    v26 = HIBYTE(v48);
    v21[5] = v25;
    v27 = v49;
    v21[6] = v26;
    v21[7] = v27;
    *(_DWORD *)(*a1 + 20) = 85;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
    v28 = v42;
    if ( v42 > 256 || v42 > v41 )
    {
      *(_DWORD *)(*a1 + 20) = 28;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    v29 = 0;
    for ( k = 0; v29 < v28; k = v29 )
    {
      if ( !v12 )
      {
        if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v44[3])(a1) )
          return 0;
        v9 = *v44;
        v12 = v44[1];
        v29 = k;
      }
      v30 = *v9;
      --v12;
      ++v9;
      v51[v29++] = v30;
      v38 = v12;
    }
    v31 = v50;
    i = v41 - v28;
    if ( (v50 & 0x10) != 0 )
    {
      v31 = v50 - 16;
      v32 = (int)&a1[v50 + 28];
    }
    else
    {
      v32 = (int)&a1[v50 + 40];
    }
    if ( v31 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 29;
      *(_DWORD *)(*a1 + 24) = v31;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !*(_DWORD *)v32 )
      *(_DWORD *)v32 = sub_1003DD70(a1);
    v33 = *(_DWORD *)v32;
    v34 = v46;
    *(_DWORD *)v33 = v45;
    v35 = v47;
    *(_DWORD *)(v33 + 4) = v34;
    v36 = v48;
    *(_DWORD *)(v33 + 8) = v35;
    LOBYTE(v35) = v49;
    *(_DWORD *)(v33 + 12) = v36;
    *(_BYTE *)(v33 + 16) = v35;
    qmemcpy((void *)(*(_DWORD *)v32 + 17), v51, 0x100u);
    v7 = v38;
  }
  v1[1] = v7;
  *v1 = v9;
  return 1;
}

// sub_1003CCA0 @ 0x1003CCA0
char __cdecl sub_1003CCA0(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebp
  unsigned __int8 *v4; // ebx
  int v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // ebp
  int v9; // eax
  unsigned __int8 *v10; // ebx
  int v11; // edx
  int v12; // esi
  int v13; // eax
  int *v14; // esi
  unsigned __int8 **v15; // esi
  __int16 v16; // cx
  unsigned __int8 *v17; // ebp
  unsigned __int8 *v18; // ebx
  __int16 v19; // ax
  int v20; // ecx
  unsigned __int16 *v21; // esi
  _DWORD *v22; // eax
  int v23; // ecx
  unsigned __int8 **v25; // [esp+10h] [ebp-14h]
  __int16 v26; // [esp+14h] [ebp-10h]
  __int16 v27; // [esp+14h] [ebp-10h]
  int *v28; // [esp+18h] [ebp-Ch]
  int v29; // [esp+18h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-8h]
  int v31; // [esp+20h] [ebp-4h]
  int v32; // [esp+28h] [ebp+4h]
  int i; // [esp+28h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = v2[1];
  v4 = *v2;
  v25 = v2;
  if ( !v3 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v4 = *v2;
    v3 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v4;
  v6 = v3 - 1;
  v7 = v4 + 1;
  v32 = (unsigned __int16)v5;
  if ( !v6 )
  {
    if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
    {
      v7 = *v2;
      v6 = v2[1];
      v5 = v32;
      goto LABEL_7;
    }
    return 0;
  }
LABEL_7:
  v8 = v6 - 1;
  v9 = *v7 + v5 - 2;
  v10 = v7 + 1;
  for ( i = v9; i > 0; v2 = v25 )
  {
    if ( !v8 )
    {
      if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
        return 0;
      v10 = *v2;
      v8 = v2[1];
    }
    v11 = *v10;
    *(_DWORD *)(*a1 + 20) = 80;
    --v8;
    ++v10;
    v12 = v11 & 0xF;
    *(_DWORD *)(*a1 + 24) = v12;
    *(_DWORD *)(*a1 + 28) = v11 >> 4;
    v30 = v11 >> 4;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    if ( v12 >= 4 )
    {
      *(_DWORD *)(*a1 + 20) = 30;
      *(_DWORD *)(*a1 + 24) = v12;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( !a1[v12 + 36] )
      a1[v12 + 36] = sub_1003DD50(a1);
    v13 = a1[v12 + 36];
    v14 = &dword_10050550;
    v31 = v13;
    v28 = &dword_10050550;
    do
    {
      if ( v30 )
      {
        if ( v8 )
        {
          v15 = v25;
        }
        else
        {
          v15 = v25;
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v25[3])(a1) )
            return 0;
          v10 = *v25;
          v8 = v25[1];
        }
        LOBYTE(v16) = 0;
        HIBYTE(v16) = *v10;
        v17 = v8 - 1;
        v18 = v10 + 1;
        v26 = v16;
        if ( !v17 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v15[3])(a1) )
            return 0;
          v18 = *v15;
          v17 = v15[1];
        }
        v14 = v28;
        v8 = v17 - 1;
        v27 = *v18 + v26;
        v10 = v18 + 1;
      }
      else
      {
        if ( !v8 )
        {
          if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v25[3])(a1) )
            return 0;
          v10 = *v25;
          v8 = v25[1];
        }
        v19 = *v10;
        --v8;
        ++v10;
        v27 = v19;
      }
      v20 = *v14++;
      *(_WORD *)(v31 + 2 * v20) = v27;
      v28 = v14;
    }
    while ( (int)v14 < (int)dword_10050650 );
    if ( *(int *)(*a1 + 104) >= 2 )
    {
      v21 = (unsigned __int16 *)(v31 + 4);
      v29 = 8;
      do
      {
        v22 = (_DWORD *)(*a1 + 24);
        *v22 = *(v21 - 2);
        v22[1] = *(v21 - 1);
        v22[2] = *v21;
        v22[3] = v21[1];
        v22[4] = v21[2];
        v22[5] = v21[3];
        v22[6] = v21[4];
        v22[7] = v21[5];
        *(_DWORD *)(*a1 + 20) = 92;
        (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 2);
        v21 += 8;
        --v29;
      }
      while ( v29 );
    }
    v23 = i - 65;
    i -= 65;
    if ( v30 )
      i = v23 - 64;
  }
  *v2 = v10;
  v2[1] = v8;
  return 1;
}

// sub_1003CF10 @ 0x1003CF10
char __cdecl sub_1003CF10(_DWORD *a1)
{
  unsigned __int8 **v2; // esi
  unsigned __int8 *v3; // ebx
  unsigned __int8 *v4; // edi
  int v5; // eax
  unsigned __int8 *v6; // edi
  unsigned __int8 *v7; // ebx
  unsigned __int8 *v8; // edi
  int v9; // eax
  unsigned __int8 *v10; // ebx
  unsigned __int16 v11; // cx
  unsigned __int8 *v12; // edi
  unsigned __int8 *v13; // ebx
  int v15; // [esp+14h] [ebp+4h]
  int v16; // [esp+14h] [ebp+4h]
  int v17; // [esp+14h] [ebp+4h]

  v2 = (unsigned __int8 **)a1[5];
  v3 = *v2;
  v4 = v2[1];
  if ( !v4 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v3 = *v2;
    v4 = v2[1];
  }
  v5 = 0;
  BYTE1(v5) = *v3;
  v6 = v4 - 1;
  v7 = v3 + 1;
  v15 = (unsigned __int16)v5;
  if ( !v6 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v7 = *v2;
    v6 = v2[1];
    v5 = v15;
  }
  v8 = v6 - 1;
  v9 = *v7 + v5;
  v10 = v7 + 1;
  if ( v9 != 4 )
  {
    *(_DWORD *)(*a1 + 20) = 9;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( !v8 )
  {
    if ( !((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
      return 0;
    v10 = *v2;
    v8 = v2[1];
  }
  LOBYTE(v11) = 0;
  HIBYTE(v11) = *v10;
  v12 = v8 - 1;
  v13 = v10 + 1;
  v16 = v11;
  if ( v12 )
  {
LABEL_15:
    v17 = *v13 + v16;
    *(_DWORD *)(*a1 + 20) = 81;
    *(_DWORD *)(*a1 + 24) = v17;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
    a1[63] = v17;
    v2[1] = v12 - 1;
    *v2 = v13 + 1;
    return 1;
  }
  if ( ((unsigned __int8 (__cdecl *)(_DWORD *))v2[3])(a1) )
  {
    v13 = *v2;
    v12 = v2[1];
    goto LABEL_15;
  }
  return 0;
}

// sub_1003D000 @ 0x1003D000
char __cdecl sub_1003D000(_DWORD *a1)
{
  char result; // al
  int v2; // eax

  if ( a1[94] || (result = sub_1003B660(a1)) != 0 )
  {
    v2 = *(_DWORD *)(a1[100] + 84);
    if ( a1[94] == v2 + 208 )
    {
      *(_DWORD *)(*a1 + 20) = 97;
      *(_DWORD *)(*a1 + 24) = *(_DWORD *)(a1[100] + 84);
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 3);
      a1[94] = 0;
LABEL_5:
      *(_DWORD *)(a1[100] + 84) = ((unsigned __int8)*(_DWORD *)(a1[100] + 84) + 1) & 7;
      return 1;
    }
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[5] + 20))(a1, v2);
    if ( result )
      goto LABEL_5;
  }
  return result;
}

// sub_1003D090 @ 0x1003D090
int __cdecl sub_1003D090(_DWORD *a1)
{
  int v1; // edx
  int result; // eax

  v1 = a1[100];
  a1[49] = 0;
  a1[31] = 0;
  a1[94] = 0;
  *(_BYTE *)(v1 + 80) = 0;
  *(_BYTE *)(a1[100] + 81) = 0;
  result = a1[100];
  *(_DWORD *)(result + 88) = 0;
  return result;
}

// FUN_1003d0d0 @ 0x1003D0D0
// [binja] char* __fastcall sub_1003d0d0(int32_t arg1)
const char *__cdecl sub_1003D0D0(_DWORD *a1)
{
  _DWORD *v1; // edi
  _DWORD *v2; // esi
  _DWORD *v3; // eax
  int v4; // ecx
  const char *result; // eax
  _DWORD *v6; // [esp-4h] [ebp-14h]
  int v7; // [esp+Ch] [ebp-4h] BYREF

  v1 = a1;
  v6 = a1;
  a1[1] = 0;
  v7 = sub_1003E560(v6);
  v2 = operator new(0x50u);
  if ( !v2 )
  {
    grim_noop();
    *(_DWORD *)(*v1 + 20) = 53;
    *(_DWORD *)(*v1 + 24) = 0;
    (*(void (__cdecl **)(_DWORD *, _DWORD *))*v1)(v1, v1);
  }
  *v2 = sub_1003D210;
  v2[1] = sub_1003D360;
  v2[2] = sub_1003D420;
  v2[3] = sub_1003D4D0;
  v2[4] = sub_1003D580;
  v2[5] = sub_1003D5F0;
  v2[6] = sub_1003D660;
  v2[7] = sub_1003D7E0;
  v2[8] = sub_1003D9D0;
  v2[9] = sub_1003DBC0;
  v2[10] = sub_1003DCC0;
  v2[11] = v7;
  v3 = v2 + 15;
  v4 = 2;
  do
  {
    *(v3 - 2) = 0;
    *v3-- = 0;
    --v4;
  }
  while ( v4 );
  v2[16] = 0;
  v2[17] = 0;
  v2[18] = 80;
  v1[1] = v2;
  result = getenv(VarName);
  if ( result )
  {
    LOBYTE(a1) = 120;
    result = (const char *)sscanf(result, "%ld%c", &v7, &a1);
    if ( (int)result > 0 )
    {
      if ( (_BYTE)a1 == 109 || (_BYTE)a1 == 77 )
      {
        result = (const char *)(1000000 * v7);
        v2[11] = 1000000 * v7;
      }
      else
      {
        result = (const char *)(1000 * v7);
        v2[11] = 1000 * v7;
      }
    }
  }
  return result;
}

// sub_1003D210 @ 0x1003D210
int __cdecl sub_1003D210(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v4; // edi
  _DWORD *i; // eax
  _DWORD *v6; // ebp
  unsigned int v7; // edi
  unsigned int v8; // esi
  int v9; // ecx
  int v11; // [esp+14h] [ebp+4h]

  v4 = a3;
  v11 = a1[1];
  if ( a3 > 0xFFE0 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 1;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (a3 & 7) != 0 )
  {
    v4 = 8 - (a3 & 7) + a3;
    a3 = v4;
  }
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  i = *(_DWORD **)(v11 + 4 * a2 + 48);
  v6 = 0;
  if ( i )
  {
    while ( i[2] < v4 )
    {
      v6 = i;
      i = (_DWORD *)*i;
      if ( !i )
        goto LABEL_12;
    }
  }
  else
  {
LABEL_12:
    v7 = v4 + 16;
    if ( v6 )
      v8 = dword_10050548[a2];
    else
      v8 = dword_10050540[a2];
    if ( v8 > 65520 - v7 )
      v8 = 65520 - v7;
    for ( i = operator new(v8 + v7); !i; i = operator new(v8 + v7) )
    {
      v8 >>= 1;
      if ( v8 < 0x32 )
      {
        *(_DWORD *)(*a1 + 20) = 53;
        *(_DWORD *)(*a1 + 24) = 2;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    *(_DWORD *)(v11 + 72) += v8 + v7;
    *i = 0;
    i[1] = 0;
    i[2] = a3 + v8;
    if ( v6 )
      *v6 = i;
    else
      *(_DWORD *)(v11 + 4 * a2 + 48) = i;
    v4 = a3;
  }
  v9 = i[1];
  i[1] = v4 + v9;
  i[2] -= v4;
  return (int)i + v9 + 16;
}

// sub_1003D360 @ 0x1003D360
_DWORD *__cdecl sub_1003D360(_DWORD *a1, unsigned int a2, unsigned int a3)
{
  unsigned int v3; // ebx
  int v4; // ebp
  _DWORD *v5; // esi
  int v6; // edx

  v3 = a3;
  v4 = a1[1];
  if ( a3 > 0xFFE0 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 3;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (a3 & 7) != 0 )
    v3 = 8 - (a3 & 7) + a3;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v5 = operator new(v3 + 16);
  if ( !v5 )
  {
    *(_DWORD *)(*a1 + 20) = 53;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  *(_DWORD *)(v4 + 72) += v3 + 16;
  v6 = *(_DWORD *)(v4 + 4 * a2 + 56);
  v5[1] = v3;
  *v5 = v6;
  v5[2] = 0;
  *(_DWORD *)(v4 + 4 * a2 + 56) = v5;
  return v5 + 4;
}

// sub_1003D420 @ 0x1003D420
int __cdecl sub_1003D420(_DWORD *a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int v5; // edi
  unsigned int v6; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  unsigned int v11; // edx
  int v12; // [esp+1Ch] [ebp+Ch]

  v5 = a1[1];
  v6 = 0xFFE0 / a3;
  if ( (int)(0xFFE0 / a3) <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)v6 >= (int)a4 )
    v6 = a4;
  *(_DWORD *)(v5 + 76) = v6;
  result = sub_1003D210(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v6 >= a4 - v8 )
        v6 = a4 - v8;
      v9 = sub_1003D360(a1, a2, a3 * v6);
      if ( v6 )
      {
        v10 = (_DWORD *)(v12 + 4 * v8);
        v11 = v6;
        v8 += v6;
        do
        {
          *v10++ = v9;
          v9 = (_DWORD *)((char *)v9 + a3);
          --v11;
        }
        while ( v11 );
      }
    }
    while ( v8 < a4 );
    return v12;
  }
  return result;
}

// sub_1003D4D0 @ 0x1003D4D0
int __cdecl sub_1003D4D0(_DWORD *a1, unsigned int a2, int a3, signed int a4)
{
  int v4; // edi
  signed int v5; // esi
  int result; // eax
  unsigned int v8; // edi
  _DWORD *v9; // eax
  _DWORD *v10; // ecx
  signed int v11; // edx
  int v12; // [esp+20h] [ebp+10h]

  v4 = a1[1];
  v5 = 0xFFE0u / (a3 << 7);
  if ( v5 <= 0 )
  {
    *(_DWORD *)(*a1 + 20) = 69;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( v5 >= a4 )
    v5 = a4;
  *(_DWORD *)(v4 + 76) = v5;
  result = sub_1003D210(a1, a2, 4 * a4);
  v8 = 0;
  v12 = result;
  if ( a4 )
  {
    do
    {
      if ( v5 >= a4 - v8 )
        v5 = a4 - v8;
      v9 = sub_1003D360(a1, a2, (a3 * v5) << 7);
      if ( v5 )
      {
        v10 = (_DWORD *)(v12 + 4 * v8);
        v11 = v5;
        v8 += v5;
        do
        {
          *v10++ = v9;
          v9 += 32 * a3;
          --v11;
        }
        while ( v11 );
      }
    }
    while ( v8 < a4 );
    return v12;
  }
  return result;
}

// sub_1003D580 @ 0x1003D580
int __cdecl sub_1003D580(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1003D210(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 64);
  *(_DWORD *)(v6 + 64) = result;
  return result;
}

// sub_1003D5F0 @ 0x1003D5F0
int __cdecl sub_1003D5F0(_DWORD *a1, unsigned int a2, char a3, int a4, int a5, int a6)
{
  int v6; // edi
  int result; // eax

  v6 = a1[1];
  if ( a2 != 1 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  result = sub_1003D210(a1, a2, 0x78u);
  *(_DWORD *)(result + 4) = a5;
  *(_DWORD *)(result + 8) = a4;
  *(_DWORD *)result = 0;
  *(_DWORD *)(result + 12) = a6;
  *(_BYTE *)(result + 32) = a3;
  *(_BYTE *)(result + 34) = 0;
  *(_DWORD *)(result + 36) = *(_DWORD *)(v6 + 68);
  *(_DWORD *)(v6 + 68) = result;
  return result;
}

// sub_1003D660 @ 0x1003D660
int __cdecl sub_1003D660(_DWORD *a1)
{
  _DWORD *v1; // ebx
  _DWORD *v2; // eax
  int v3; // esi
  int i; // edi
  int v5; // ecx
  int result; // eax
  int v7; // ecx
  signed int v8; // edi
  int j; // esi
  int k; // esi

  v1 = (_DWORD *)a1[1];
  v2 = (_DWORD *)v1[16];
  v3 = 0;
  for ( i = 0; v2; v2 = (_DWORD *)v2[9] )
  {
    if ( !*v2 )
    {
      v5 = v2[2];
      v3 += v5 * v2[3];
      i += v5 * v2[1];
    }
  }
  for ( result = v1[17]; result; result = *(_DWORD *)(result + 36) )
  {
    if ( !*(_DWORD *)result )
    {
      v7 = *(_DWORD *)(result + 8);
      v3 += (v7 * *(_DWORD *)(result + 12)) << 7;
      i += (v7 * *(_DWORD *)(result + 4)) << 7;
    }
  }
  if ( v3 > 0 )
  {
    result = FUN_1003e530(a1, v3, i);
    if ( result < i )
    {
      result /= v3;
      v8 = result;
      if ( result <= 0 )
        v8 = 1;
    }
    else
    {
      v8 = 1000000000;
    }
    for ( j = v1[16]; j; j = *(_DWORD *)(j + 36) )
    {
      if ( !*(_DWORD *)j )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(j + 4) - 1) / *(_DWORD *)(j + 12) + 1) > v8 )
        {
          *(_DWORD *)(j + 16) = v8 * *(_DWORD *)(j + 12);
          sub_1003E540(a1);
          *(_BYTE *)(j + 34) = 1;
        }
        else
        {
          *(_DWORD *)(j + 16) = *(_DWORD *)(j + 4);
        }
        *(_DWORD *)j = sub_1003D420(a1, 1u, *(_DWORD *)(j + 8), *(_DWORD *)(j + 16));
        result = 0;
        *(_DWORD *)(j + 20) = v1[19];
        *(_DWORD *)(j + 24) = 0;
        *(_DWORD *)(j + 28) = 0;
        *(_BYTE *)(j + 33) = 0;
      }
    }
    for ( k = v1[17]; k; k = *(_DWORD *)(k + 36) )
    {
      if ( !*(_DWORD *)k )
      {
        if ( (int)((unsigned int)(*(_DWORD *)(k + 4) - 1) / *(_DWORD *)(k + 12) + 1) > v8 )
        {
          *(_DWORD *)(k + 16) = v8 * *(_DWORD *)(k + 12);
          sub_1003E540(a1);
          *(_BYTE *)(k + 34) = 1;
        }
        else
        {
          *(_DWORD *)(k + 16) = *(_DWORD *)(k + 4);
        }
        *(_DWORD *)k = sub_1003D4D0(a1, 1u, *(_DWORD *)(k + 8), *(_DWORD *)(k + 16));
        result = 0;
        *(_DWORD *)(k + 20) = v1[19];
        *(_DWORD *)(k + 24) = 0;
        *(_DWORD *)(k + 28) = 0;
        *(_BYTE *)(k + 33) = 0;
      }
    }
  }
  return result;
}

// sub_1003D7E0 @ 0x1003D7E0
int __cdecl sub_1003D7E0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebp
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  int v10; // ebx
  unsigned int v11; // edi
  unsigned int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      FUN_1003d930(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    FUN_1003d930(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = *(_DWORD *)(a2 + 8);
    v11 = v8 - v9;
    for ( i = v5 - v9; v11 < i; ++v11 )
      sub_1003E510(*(_DWORD *)(*(_DWORD *)a2 + 4 * v11), v10);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// FUN_1003d930 @ 0x1003D930
// [binja] int32_t sub_1003d930(int32_t* arg1)
int __cdecl sub_1003D930(int a1, int a2, char a3)
{
  int v4; // ebp
  int result; // eax
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  int v9; // ebp
  int v10; // [esp+18h] [ebp+8h]

  v4 = *(_DWORD *)(a2 + 8);
  result = *(_DWORD *)(a2 + 16);
  v6 = v4 * *(_DWORD *)(a2 + 24);
  v7 = 0;
  v10 = v4;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v7;
      if ( *(_DWORD *)(a2 + 20) < result )
        result = *(_DWORD *)(a2 + 20);
      v8 = v7 + *(_DWORD *)(a2 + 24);
      if ( result >= *(_DWORD *)(a2 + 28) - v8 )
        result = *(_DWORD *)(a2 + 28) - v8;
      if ( result >= *(_DWORD *)(a2 + 4) - v8 )
        result = *(_DWORD *)(a2 + 4) - v8;
      if ( result <= 0 )
        break;
      v9 = v4 * result;
      if ( a3 )
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v7),
          v6,
          v9);
      else
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v7),
          v6,
          v9);
      result = *(_DWORD *)(a2 + 16);
      v7 += *(_DWORD *)(a2 + 20);
      v6 += v9;
      if ( v7 >= result )
        break;
      v4 = v10;
    }
  }
  return result;
}

// sub_1003D9D0 @ 0x1003D9D0
int __cdecl sub_1003D9D0(int a1, int a2, unsigned int a3, unsigned int a4, char a5)
{
  unsigned int v5; // ebx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // edi
  int v9; // eax
  unsigned int v10; // edi
  unsigned int v11; // ebx
  int i; // ebp

  v5 = a3 + a4;
  if ( a3 + a4 > *(_DWORD *)(a2 + 4) || a4 > *(_DWORD *)(a2 + 12) || !*(_DWORD *)a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v6 = *(_DWORD *)(a2 + 24);
  if ( a3 < v6 || v5 > v6 + *(_DWORD *)(a2 + 16) )
  {
    if ( !*(_BYTE *)(a2 + 34) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 68;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_BYTE *)(a2 + 33) )
    {
      FUN_1003db20(a1, a2, 1);
      *(_BYTE *)(a2 + 33) = 0;
    }
    if ( a3 <= *(_DWORD *)(a2 + 24) )
    {
      v7 = v5 - *(_DWORD *)(a2 + 16);
      if ( v7 < 0 )
        v7 = 0;
      *(_DWORD *)(a2 + 24) = v7;
    }
    else
    {
      *(_DWORD *)(a2 + 24) = a3;
    }
    FUN_1003db20(a1, a2, 0);
  }
  v8 = *(_DWORD *)(a2 + 28);
  if ( v8 >= v5 )
  {
LABEL_27:
    if ( !a5 )
      return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
LABEL_28:
    *(_BYTE *)(a2 + 33) = 1;
    return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
  }
  if ( v8 < a3 )
  {
    if ( a5 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v8 = a3;
  }
  if ( a5 )
    *(_DWORD *)(a2 + 28) = v5;
  if ( *(_BYTE *)(a2 + 32) )
  {
    v9 = *(_DWORD *)(a2 + 24);
    v10 = v8 - v9;
    v11 = v5 - v9;
    for ( i = *(_DWORD *)(a2 + 8) << 7; v10 < v11; ++v10 )
      sub_1003E510(*(_DWORD *)(*(_DWORD *)a2 + 4 * v10), i);
    goto LABEL_27;
  }
  if ( a5 )
    goto LABEL_28;
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 20;
  (**(void (__cdecl ***)(int))a1)(a1);
  return *(_DWORD *)a2 + 4 * (a3 - *(_DWORD *)(a2 + 24));
}

// FUN_1003db20 @ 0x1003DB20
// [binja] int32_t sub_1003db20(int32_t arg1)
int __cdecl sub_1003DB20(int a1, int a2, char a3)
{
  int result; // eax
  int v5; // ebp
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  int v9; // ebp
  int v10; // [esp+18h] [ebp+8h]

  result = *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 8) << 7;
  v6 = *(_DWORD *)(a2 + 24) * v5;
  v7 = 0;
  v10 = v5;
  if ( result > 0 )
  {
    while ( 1 )
    {
      result -= v7;
      if ( *(_DWORD *)(a2 + 20) < result )
        result = *(_DWORD *)(a2 + 20);
      v8 = *(_DWORD *)(a2 + 24) + v7;
      if ( result >= *(_DWORD *)(a2 + 28) - v8 )
        result = *(_DWORD *)(a2 + 28) - v8;
      if ( result >= *(_DWORD *)(a2 + 4) - v8 )
        result = *(_DWORD *)(a2 + 4) - v8;
      if ( result <= 0 )
        break;
      v9 = v5 * result;
      if ( a3 )
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 44))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v7),
          v6,
          v9);
      else
        (*(void (__cdecl **)(int, int, _DWORD, int, int))(a2 + 40))(
          a1,
          a2 + 40,
          *(_DWORD *)(*(_DWORD *)a2 + 4 * v7),
          v6,
          v9);
      result = *(_DWORD *)(a2 + 16);
      v7 += *(_DWORD *)(a2 + 20);
      v6 += v9;
      if ( v7 >= result )
        break;
      v5 = v10;
    }
  }
  return result;
}

// sub_1003DBC0 @ 0x1003DBC0
_DWORD *__cdecl sub_1003DBC0(_DWORD *a1, unsigned int a2)
{
  _DWORD *v2; // esi
  unsigned int v3; // edi
  int i; // edi
  int v5; // edi
  _DWORD *v6; // eax
  _DWORD *v7; // edi
  int v8; // ebp
  _DWORD *result; // eax
  _DWORD *v10; // edi
  int v11; // ebp

  v2 = (_DWORD *)a1[1];
  v3 = a2;
  if ( a2 >= 2 )
  {
    *(_DWORD *)(*a1 + 20) = 12;
    *(_DWORD *)(*a1 + 24) = a2;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( a2 == 1 )
  {
    for ( i = v2[16]; i; i = *(_DWORD *)(i + 36) )
    {
      if ( *(_BYTE *)(i + 34) )
      {
        *(_BYTE *)(i + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(i + 48))(a1, i + 40);
      }
    }
    v5 = v2[17];
    for ( v2[16] = 0; v5; v5 = *(_DWORD *)(v5 + 36) )
    {
      if ( *(_BYTE *)(v5 + 34) )
      {
        *(_BYTE *)(v5 + 34) = 0;
        (*(void (__cdecl **)(_DWORD *, int))(v5 + 48))(a1, v5 + 40);
      }
    }
    v3 = a2;
    v2[17] = 0;
  }
  v6 = (_DWORD *)v2[v3 + 14];
  v2[v3 + 14] = 0;
  if ( v6 )
  {
    do
    {
      v7 = (_DWORD *)*v6;
      v8 = v6[2] + v6[1] + 16;
      if ( v6 )
        operator delete(v6);
      v2[18] -= v8;
      v6 = v7;
    }
    while ( v7 );
    v3 = a2;
  }
  result = (_DWORD *)v2[v3 + 12];
  v2[v3 + 12] = 0;
  if ( result )
  {
    do
    {
      v10 = (_DWORD *)*result;
      v11 = result[2] + result[1] + 16;
      if ( result )
        operator delete(result);
      v2[18] -= v11;
      result = v10;
    }
    while ( v10 );
  }
  return result;
}

// sub_1003DCC0 @ 0x1003DCC0
void __cdecl sub_1003DCC0(int a1)
{
  signed int i; // esi

  for ( i = 1; i >= 0; --i )
    sub_1003DBC0((_DWORD *)a1, i);
  operator delete(*(void **)(a1 + 4));
  *(_DWORD *)(a1 + 4) = 0;
  grim_noop();
}

// sub_1003DD00 @ 0x1003DD00
int __cdecl sub_1003DD00(int a1)
{
  int result; // eax

  result = (*(int (__cdecl **)(int, int))(*(_DWORD *)(a1 + 4) + 36))(a1, 1);
  *(_DWORD *)(a1 + 16) = *(_BYTE *)(a1 + 12) != 0 ? 200 : 100;
  return result;
}

// sub_1003DD30 @ 0x1003DD30
int __cdecl sub_1003DD30(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 4);
  if ( result )
    result = (*(int (__cdecl **)(int))(result + 40))(a1);
  *(_DWORD *)(a1 + 4) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  return result;
}

// sub_1003DD50 @ 0x1003DD50
int __cdecl sub_1003DD50(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 130);
  *(_BYTE *)(result + 128) = 0;
  return result;
}

// sub_1003DD70 @ 0x1003DD70
int __cdecl sub_1003DD70(int a1)
{
  int result; // eax

  result = (**(int (__cdecl ***)(int, _DWORD, int))(a1 + 4))(a1, 0, 274);
  *(_BYTE *)(result + 273) = 0;
  return result;
}

// sub_1003DD90 @ 0x1003DD90
int __cdecl sub_1003DD90(int a1)
{
  int v2; // eax
  unsigned int v3; // ecx
  int v4; // eax
  int v5; // eax
  int v6; // eax
  int v7; // eax
  int v8; // ecx
  _DWORD *v9; // ecx
  int v10; // edx
  int i; // eax
  int v12; // ebx
  _DWORD *v13; // edi
  int v14; // eax
  int v15; // ecx
  int v16; // eax
  int result; // eax
  int v18; // [esp-10h] [ebp-18h]
  int v19; // [esp-10h] [ebp-18h]
  int v20; // [esp-10h] [ebp-18h]
  int v21; // [esp+Ch] [ebp+4h]

  if ( *(_DWORD *)(a1 + 16) != 202 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 18;
    *(_DWORD *)(*(_DWORD *)a1 + 24) = *(_DWORD *)(a1 + 16);
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  v2 = *(_DWORD *)(a1 + 44);
  v3 = *(_DWORD *)(a1 + 48);
  if ( 8 * v2 > v3 )
  {
    if ( 4 * v2 > v3 )
    {
      if ( 2 * v2 > v3 )
      {
        v7 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = *(_DWORD *)(a1 + 24);
        *(_DWORD *)(a1 + 96) = v7;
        *(_DWORD *)(a1 + 276) = 8;
      }
      else
      {
        v6 = sub_1003E460(*(_DWORD *)(a1 + 24), 2);
        v20 = *(_DWORD *)(a1 + 28);
        *(_DWORD *)(a1 + 92) = v6;
        *(_DWORD *)(a1 + 96) = sub_1003E460(v20, 2);
        *(_DWORD *)(a1 + 276) = 4;
      }
    }
    else
    {
      v5 = sub_1003E460(*(_DWORD *)(a1 + 24), 4);
      v19 = *(_DWORD *)(a1 + 28);
      *(_DWORD *)(a1 + 92) = v5;
      *(_DWORD *)(a1 + 96) = sub_1003E460(v19, 4);
      *(_DWORD *)(a1 + 276) = 2;
    }
  }
  else
  {
    v4 = sub_1003E460(*(_DWORD *)(a1 + 24), 8);
    v18 = *(_DWORD *)(a1 + 28);
    *(_DWORD *)(a1 + 92) = v4;
    *(_DWORD *)(a1 + 96) = sub_1003E460(v18, 8);
    *(_DWORD *)(a1 + 276) = 1;
  }
  v8 = *(_DWORD *)(a1 + 196);
  v21 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v9 = (_DWORD *)(v8 + 12);
    do
    {
      v10 = *(_DWORD *)(a1 + 276);
      for ( i = v10; i < 8; i *= 2 )
      {
        if ( 2 * i * *(v9 - 1) > v10 * *(_DWORD *)(a1 + 268) )
          break;
        if ( 2 * i * *v9 > v10 * *(_DWORD *)(a1 + 272) )
          break;
      }
      v9[6] = i;
      v9 += 21;
      ++v21;
    }
    while ( v21 < *(_DWORD *)(a1 + 32) );
  }
  v12 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v13 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 36);
    do
    {
      v14 = sub_1003E460(*(_DWORD *)(a1 + 24) * *v13 * *(v13 - 7), 8 * *(_DWORD *)(a1 + 268));
      v15 = *v13 * *(v13 - 6);
      v13[1] = v14;
      v13[2] = sub_1003E460(*(_DWORD *)(a1 + 28) * v15, 8 * *(_DWORD *)(a1 + 272));
      ++v12;
      v13 += 21;
    }
    while ( v12 < *(_DWORD *)(a1 + 32) );
  }
  switch ( *(_DWORD *)(a1 + 40) )
  {
    case 1:
      *(_DWORD *)(a1 + 100) = 1;
      break;
    case 2:
    case 3:
      *(_DWORD *)(a1 + 100) = 3;
      break;
    case 4:
    case 5:
      *(_DWORD *)(a1 + 100) = 4;
      break;
    default:
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      break;
  }
  v16 = 1;
  if ( !*(_BYTE *)(a1 + 74) )
    v16 = *(_DWORD *)(a1 + 100);
  *(_DWORD *)(a1 + 104) = v16;
  result = sub_1003DFB0(a1);
  if ( (_BYTE)result )
  {
    result = *(_DWORD *)(a1 + 272);
    *(_DWORD *)(a1 + 108) = result;
  }
  else
  {
    *(_DWORD *)(a1 + 108) = 1;
  }
  return result;
}

// sub_1003DFB0 @ 0x1003DFB0
char __cdecl sub_1003DFB0(int a1)
{
  _DWORD *v1; // ecx
  char result; // al
  int v3; // edx

  if ( *(_BYTE *)(a1 + 72) )
    return 0;
  if ( *(_BYTE *)(a1 + 264) )
    return 0;
  if ( *(_DWORD *)(a1 + 36) != 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 32) != 3 )
    return 0;
  if ( *(_DWORD *)(a1 + 40) != 2 )
    return 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
    return 0;
  v1 = *(_DWORD **)(a1 + 196);
  if ( v1[2] != 2 )
    return 0;
  result = 1;
  if ( v1[23] != 1 )
    return 0;
  if ( v1[44] != 1 )
    return 0;
  if ( (int)v1[3] > 2 )
    return 0;
  if ( v1[24] != 1 )
    return 0;
  if ( v1[45] != 1 )
    return 0;
  v3 = *(_DWORD *)(a1 + 276);
  if ( v1[9] != v3 || v1[30] != v3 || v1[51] != v3 )
    return 0;
  return result;
}

// sub_1003E040 @ 0x1003E040
char __cdecl sub_1003E040(int a1)
{
  int v1; // ebp
  int v2; // eax
  int v3; // ebx
  int v4; // edx
  int v5; // eax
  int v6; // edx
  char v7; // al
  char result; // al
  int v9; // ecx
  int v10; // eax

  v1 = a1;
  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 380) = v2;
  *(_DWORD *)v2 = sub_1003E2D0;
  *(_DWORD *)(v2 + 4) = sub_1003E430;
  *(_BYTE *)(v2 + 8) = 0;
  v3 = *(_DWORD *)(a1 + 380);
  sub_1003DD90(a1);
  v4 = (**(int (__cdecl ***)(int, int, int))(v1 + 4))(v1, 1, 1408) + 256;
  v5 = 0;
  *(_DWORD *)(a1 + 284) = v4;
  memset((void *)(v4 - 256), 0, 0x100u);
  do
  {
    *(_BYTE *)(v5 + v4) = v5;
    ++v5;
  }
  while ( v5 <= 255 );
  v6 = v4 + 128;
  memset((void *)(v6 + 128), 0xFFu, 0x180u);
  memset((void *)(v6 + 512), 0, 0x180u);
  qmemcpy((void *)(v6 + 896), *(const void **)(a1 + 284), 0x80u);
  *(_DWORD *)(v3 + 12) = 0;
  *(_BYTE *)(v3 + 16) = sub_1003DFB0(a1);
  *(_DWORD *)(v3 + 20) = 0;
  *(_DWORD *)(v3 + 24) = 0;
  v7 = *(_BYTE *)(a1 + 74);
  if ( !v7 || !*(_BYTE *)(a1 + 64) )
  {
    *(_BYTE *)(a1 + 88) = 0;
    *(_BYTE *)(a1 + 89) = 0;
    *(_BYTE *)(a1 + 90) = 0;
  }
  if ( v7 )
  {
    if ( *(_BYTE *)(a1 + 65) )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( *(_DWORD *)(a1 + 100) == 3 )
    {
      if ( *(_DWORD *)(a1 + 116) )
      {
        *(_BYTE *)(a1 + 89) = 1;
      }
      else if ( *(_BYTE *)(a1 + 80) )
      {
        *(_BYTE *)(a1 + 90) = 1;
      }
      else
      {
        *(_BYTE *)(a1 + 88) = 1;
      }
    }
    else
    {
      *(_BYTE *)(a1 + 88) = 1;
      *(_BYTE *)(a1 + 89) = 0;
      *(_BYTE *)(a1 + 90) = 0;
      *(_DWORD *)(a1 + 116) = 0;
    }
    if ( *(_BYTE *)(a1 + 88) )
    {
      sub_10044210(a1);
      *(_DWORD *)(v3 + 20) = *(_DWORD *)(a1 + 420);
    }
    if ( *(_BYTE *)(a1 + 90) || *(_BYTE *)(a1 + 89) )
    {
      sub_10042EA0(a1);
      *(_DWORD *)(v3 + 24) = *(_DWORD *)(a1 + 420);
    }
  }
  if ( !*(_BYTE *)(a1 + 65) )
  {
    if ( *(_BYTE *)(v3 + 16) )
    {
      sub_100428E0(a1);
    }
    else
    {
      sub_10042310(a1);
      sub_10041BA0(a1);
    }
    sub_10041850(a1, *(_BYTE *)(a1 + 90));
  }
  sub_10041590(a1);
  if ( *(_BYTE *)(a1 + 201) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 1;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  else if ( *(_BYTE *)(a1 + 200) )
  {
    sub_100406A0(a1);
  }
  else
  {
    sub_10040070(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 396) + 16) || (LOBYTE(a1) = 0, *(_BYTE *)(v1 + 64)) )
    LOBYTE(a1) = 1;
  sub_1003EC50(v1, a1);
  if ( !*(_BYTE *)(v1 + 65) )
    sub_1003E570(v1, 0);
  (*(void (__cdecl **)(int))(*(_DWORD *)(v1 + 4) + 24))(v1);
  result = (*(int (__cdecl **)(int))(*(_DWORD *)(v1 + 396) + 8))(v1);
  v9 = *(_DWORD *)(v1 + 8);
  if ( v9 )
  {
    result = *(_BYTE *)(v1 + 64);
    if ( !result )
    {
      result = *(_BYTE *)(*(_DWORD *)(v1 + 396) + 16);
      if ( result )
      {
        v10 = *(_DWORD *)(v1 + 32);
        if ( *(_BYTE *)(v1 + 200) )
          v10 = 3 * v10 + 2;
        *(_DWORD *)(v9 + 4) = 0;
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 8) = v10 * *(_DWORD *)(v1 + 280);
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 12) = 0;
        result = *(_BYTE *)(v1 + 90);
        *(_DWORD *)(*(_DWORD *)(v1 + 8) + 16) = (result != 0) + 2;
        ++*(_DWORD *)(v3 + 12);
      }
    }
  }
  return result;
}

// sub_1003E2D0 @ 0x1003E2D0
char __cdecl sub_1003E2D0(int a1)
{
  int v1; // edi
  int v2; // eax

  v1 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(v1 + 8) )
  {
    *(_BYTE *)(v1 + 8) = 0;
    (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, 0);
    (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, 2);
    (**(void (__cdecl ***)(int, int))(a1 + 384))(a1, 2);
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) && !*(_DWORD *)(a1 + 116) )
    {
      if ( *(_BYTE *)(a1 + 80) && *(_BYTE *)(a1 + 90) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 24);
        *(_BYTE *)(v1 + 8) = 1;
      }
      else if ( *(_BYTE *)(a1 + 88) )
      {
        *(_DWORD *)(a1 + 420) = *(_DWORD *)(v1 + 20);
      }
      else
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
    }
    (**(void (__cdecl ***)(int))(a1 + 408))(a1);
    (*(void (__cdecl **)(int))(*(_DWORD *)(a1 + 388) + 8))(a1);
    if ( !*(_BYTE *)(a1 + 65) )
    {
      if ( !*(_BYTE *)(v1 + 16) )
        (**(void (__cdecl ***)(int))(a1 + 416))(a1);
      (**(void (__cdecl ***)(int))(a1 + 412))(a1);
      if ( *(_BYTE *)(a1 + 74) )
        (**(void (__cdecl ***)(int, _DWORD))(a1 + 420))(a1, *(unsigned __int8 *)(v1 + 8));
      (**(void (__cdecl ***)(int, int))(a1 + 392))(a1, *(_BYTE *)(v1 + 8) != 0 ? 3 : 0);
      (**(void (__cdecl ***)(int, _DWORD))(a1 + 384))(a1, 0);
    }
  }
  v2 = *(_DWORD *)(a1 + 8);
  if ( v2 )
  {
    *(_DWORD *)(v2 + 12) = *(_DWORD *)(v1 + 12);
    *(_DWORD *)(*(_DWORD *)(a1 + 8) + 16) = *(_DWORD *)(v1 + 12) + (*(_BYTE *)(v1 + 8) != 0) + 1;
    LOBYTE(v2) = *(_BYTE *)(a1 + 64);
    if ( (_BYTE)v2 )
    {
      LOBYTE(v2) = *(_BYTE *)(*(_DWORD *)(a1 + 396) + 17);
      if ( !(_BYTE)v2 )
      {
        v2 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(v2 + 16) += (*(_BYTE *)(a1 + 90) != 0) + 1;
      }
    }
  }
  return v2;
}

// sub_1003E430 @ 0x1003E430
int __cdecl sub_1003E430(int a1)
{
  int result; // eax
  int v2; // esi

  result = a1;
  v2 = *(_DWORD *)(a1 + 380);
  if ( *(_BYTE *)(a1 + 74) )
    result = (*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 420) + 8))(a1);
  ++*(_DWORD *)(v2 + 12);
  return result;
}

// sub_1003E460 @ 0x1003E460
int __cdecl sub_1003E460(int a1, int a2)
{
  return (a1 + a2 - 1) / a2;
}

// sub_1003E470 @ 0x1003E470
int __cdecl sub_1003E470(int a1, int a2)
{
  return a1 + a2 - 1 - (a1 + a2 - 1) % a2;
}

// sub_1003E490 @ 0x1003E490
const void **__cdecl sub_1003E490(int a1, int a2, int a3, int a4, int a5, unsigned int a6)
{
  int v6; // ebx
  const void **result; // eax
  void **v8; // edx

  v6 = a5;
  result = (const void **)(a1 + 4 * a2);
  v8 = (void **)(a3 + 4 * a4);
  if ( a5 > 0 )
  {
    do
    {
      qmemcpy(*v8++, *result++, a6);
      --v6;
    }
    while ( v6 );
  }
  return result;
}

// sub_1003E4E0 @ 0x1003E4E0
int __cdecl sub_1003E4E0(const void *a1, void *a2, int a3)
{
  qmemcpy(a2, a1, 4 * ((unsigned int)(a3 << 7) >> 2));
  return a3 << 7;
}

// sub_1003E510 @ 0x1003E510
int __cdecl sub_1003E510(void *a1, unsigned int a2)
{
  memset(a1, 0, a2);
  return 0;
}

// FUN_1003e530 @ 0x1003E530
// [binja] int32_t sub_1003e530(int32_t arg1) __pure
int __cdecl sub_1003E530(int a1, int a2, int a3)
{
  return a3;
}

// sub_1003E540 @ 0x1003E540
int __cdecl sub_1003E540(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 48;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_1003E560 @ 0x1003E560
int sub_1003E560()
{
  return 0;
}

// sub_1003E570 @ 0x1003E570
int __cdecl sub_1003E570(int a1, char a2)
{
  _DWORD *v3; // eax
  int v4; // edi
  int v5; // ebp
  int v6; // eax
  int v7; // ebx
  _DWORD *v8; // ebp
  int v9; // edi
  int v10; // eax
  int result; // eax
  int v12; // ebp
  _DWORD *v13; // edi
  _DWORD *v14; // ebx
  int v15; // [esp+10h] [ebp-8h]
  _DWORD *v16; // [esp+14h] [ebp-4h]
  int v17; // [esp+1Ch] [ebp+4h]
  int v18; // [esp+20h] [ebp+8h]
  int v19; // [esp+20h] [ebp+8h]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 80);
  *(_DWORD *)(a1 + 384) = v3;
  v16 = v3;
  *v3 = sub_1003E6F0;
  if ( a2 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( *(_BYTE *)(*(_DWORD *)(a1 + 412) + 8) )
  {
    if ( *(int *)(a1 + 276) < 2 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    v4 = *(_DWORD *)(a1 + 384);
    v5 = *(_DWORD *)(a1 + 276);
    v15 = v4;
    v6 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * *(_DWORD *)(a1 + 32));
    *(_DWORD *)(v4 + 56) = v6;
    *(_DWORD *)(v4 + 60) = v6 + 4 * *(_DWORD *)(a1 + 32);
    v7 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v18 = v5 + 4;
      v8 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 12);
      do
      {
        v9 = *v8 * v8[6] / *(_DWORD *)(a1 + 276) * v18;
        v17 = *v8 * v8[6] / *(_DWORD *)(a1 + 276);
        v10 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 8 * v9) + 4 * v17;
        *(_DWORD *)(*(_DWORD *)(v15 + 56) + 4 * v7) = v10;
        *(_DWORD *)(*(_DWORD *)(v15 + 60) + 4 * v7++) = v10 + 4 * v9;
        v8 += 21;
      }
      while ( v7 < *(_DWORD *)(a1 + 32) );
    }
    v19 = *(_DWORD *)(a1 + 276) + 2;
  }
  else
  {
    v19 = *(_DWORD *)(a1 + 276);
  }
  result = *(_DWORD *)(a1 + 196);
  v12 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v13 = (_DWORD *)(result + 36);
    v14 = v16 + 2;
    do
    {
      *v14 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
               a1,
               1,
               *v13 * *(v13 - 2),
               v19 * (*v13 * *(v13 - 6) / *(_DWORD *)(a1 + 276)));
      result = *(_DWORD *)(a1 + 32);
      ++v12;
      ++v14;
      v13 += 21;
    }
    while ( v12 < result );
  }
  return result;
}

// sub_1003E6F0 @ 0x1003E6F0
int __cdecl sub_1003E6F0(_DWORD *a1, int a2)
{
  _DWORD *v2; // esi
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ecx
  _DWORD *v6; // edx
  int v7; // eax
  _DWORD *v8; // ebp
  int v9; // edi
  _DWORD *v10; // ecx
  _DWORD *v11; // edx
  int v12; // ebp
  _DWORD *v13; // esi
  int v14; // ebp
  _DWORD *v15; // edx
  char *v16; // ecx
  int v17; // edi
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // eax
  int *v22; // [esp+8h] [ebp-20h]
  _DWORD *v23; // [esp+Ch] [ebp-1Ch]
  int v24; // [esp+10h] [ebp-18h]
  int v25; // [esp+14h] [ebp-14h]
  _DWORD *v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  char *v28; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]
  int v30; // [esp+30h] [ebp+8h]

  v2 = a1;
  result = a1[96];
  v4 = 0;
  v29 = result;
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      *(_DWORD *)(result + 4) = sub_1003EC20;
    }
    else
    {
      *(_DWORD *)(*a1 + 20) = 4;
      return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
    }
  }
  else if ( *(_BYTE *)(a1[103] + 8) )
  {
    *(_DWORD *)(result + 4) = sub_1003E930;
    v5 = (_DWORD *)a1[96];
    v25 = a1[69];
    v27 = v5;
    v30 = 0;
    if ( (int)a1[8] > 0 )
    {
      v6 = (_DWORD *)(a1[49] + 12);
      v23 = v6;
      v22 = v5 + 2;
      while ( 1 )
      {
        v7 = *v6 * v6[6] / v2[69];
        v8 = *(_DWORD **)(v5[14] + 4 * v4);
        v9 = *v22;
        v10 = *(_DWORD **)(v5[15] + 4 * v4);
        v26 = v8;
        if ( v7 * (v25 + 2) > 0 )
        {
          v11 = v10;
          v28 = (char *)((char *)v8 - (char *)v10);
          v24 = v7 * (v25 + 2);
          do
          {
            v12 = *(_DWORD *)((char *)v11 + v9 - (_DWORD)v10);
            *v11 = v12;
            *(_DWORD *)((char *)v11++ + (_DWORD)v28) = v12;
            --v24;
          }
          while ( v24 );
          v8 = v26;
          v4 = v30;
        }
        if ( 2 * v7 > 0 )
        {
          v13 = &v10[v25 * v7];
          v14 = v9 - (_DWORD)v10;
          v15 = (_DWORD *)(v9 + 4 * v7 * (v25 - 2));
          v16 = (char *)v10 - v9;
          v17 = 2 * v7;
          do
          {
            *(_DWORD *)((char *)v15 + (_DWORD)v16) = *(_DWORD *)((char *)v13 + v14);
            *v13++ = *v15++;
            --v17;
          }
          while ( v17 );
          v8 = v26;
          v4 = v30;
        }
        if ( v7 > 0 )
        {
          v18 = 0;
          v19 = 4 * v7;
          v20 = v7;
          do
          {
            v21 = v18 - v19;
            v18 += 4;
            --v20;
            *(_DWORD *)((char *)v8 + v21) = *v8;
          }
          while ( v20 );
        }
        v30 = ++v4;
        ++v22;
        v23 += 21;
        if ( v4 >= a1[8] )
          break;
        v2 = a1;
        v5 = v27;
        v6 = v23;
      }
      result = v29;
    }
    *(_DWORD *)(result + 64) = 0;
    *(_DWORD *)(result + 68) = 0;
    *(_DWORD *)(result + 76) = 0;
    *(_DWORD *)(result + 52) = 0;
    *(_BYTE *)(result + 48) = 0;
  }
  else
  {
    *(_DWORD *)(result + 52) = 0;
    *(_DWORD *)(result + 4) = sub_1003E8C0;
    *(_BYTE *)(result + 48) = 0;
  }
  return result;
}

// sub_1003E8C0 @ 0x1003E8C0
unsigned int __cdecl sub_1003E8C0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // esi
  unsigned int result; // eax
  unsigned int v6; // ebp

  v4 = a1[96];
  if ( !*(_BYTE *)(v4 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, int))(a1[97] + 12))(a1, v4 + 8);
    if ( !result )
      return result;
    *(_BYTE *)(v4 + 48) = 1;
  }
  v6 = a1[69];
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int, int, int, int))(a1[98] + 4))(
    a1,
    v4 + 8,
    v4 + 52,
    v6,
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v4 + 52);
  if ( result >= v6 )
  {
    *(_BYTE *)(v4 + 48) = 0;
    *(_DWORD *)(v4 + 52) = 0;
  }
  return result;
}

// sub_1003E930 @ 0x1003E930
unsigned int __cdecl sub_1003E930(_DWORD *a1, int a2, unsigned int *a3, unsigned int a4)
{
  _DWORD *v4; // edi
  int v5; // ebx
  unsigned int result; // eax
  int v7; // eax
  int v8; // eax
  int v9; // eax
  int v10; // ecx
  int v11; // eax
  _DWORD *v12; // esi
  int v13; // ecx
  int v14; // ebp
  int v15; // esi
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  _DWORD *v19; // eax
  int v20; // esi
  signed int v21; // ecx
  _DWORD *v22; // edx
  int v23; // eax
  int v24; // ebp
  int v25; // esi
  int v26; // ecx
  _DWORD *v27; // edi
  int v28; // edx
  bool v29; // zf
  int v30; // [esp+10h] [ebp-18h]
  int v31; // [esp+10h] [ebp-18h]
  _DWORD *i; // [esp+14h] [ebp-14h]
  signed int v33; // [esp+14h] [ebp-14h]
  int v34; // [esp+18h] [ebp-10h]
  int v35; // [esp+18h] [ebp-10h]
  int v36; // [esp+1Ch] [ebp-Ch]
  int v37; // [esp+20h] [ebp-8h]
  int v38; // [esp+24h] [ebp-4h]
  _DWORD *v39; // [esp+30h] [ebp+8h]
  int v40; // [esp+34h] [ebp+Ch]
  _DWORD *v41; // [esp+38h] [ebp+10h]

  v4 = a1;
  v5 = a1[96];
  v38 = v5;
  if ( !*(_BYTE *)(v5 + 48) )
  {
    result = (*(int (__cdecl **)(_DWORD *, _DWORD))(a1[97] + 12))(a1, *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56));
    if ( !result )
      return result;
    v7 = *(_DWORD *)(v5 + 76) + 1;
    *(_BYTE *)(v5 + 48) = 1;
    *(_DWORD *)(v5 + 76) = v7;
  }
  v8 = *(_DWORD *)(v5 + 68);
  if ( !v8 )
  {
LABEL_9:
    v10 = *(_DWORD *)(v5 + 76);
    *(_DWORD *)(v5 + 52) = 0;
    *(_DWORD *)(v5 + 72) = a1[69] - 1;
    if ( v10 == a1[70] )
    {
      v11 = a1[49];
      v34 = a1[96];
      v30 = 0;
      if ( (int)a1[8] > 0 )
      {
        v12 = (_DWORD *)(v11 + 12);
        for ( i = (_DWORD *)(v11 + 12); ; v12 = i )
        {
          v13 = *v12 * v12[6];
          v14 = v13 / a1[69];
          v15 = v12[8] % (unsigned int)v13;
          if ( !v15 )
            v15 = v13;
          v16 = v30;
          if ( !v30 )
            *(_DWORD *)(v34 + 72) = (v15 - 1) / v14 + 1;
          v17 = 2 * v14;
          if ( 2 * v14 > 0 )
          {
            v18 = *(_DWORD *)(*(_DWORD *)(v34 + 4 * *(_DWORD *)(v34 + 64) + 56) + 4 * v30) + 4 * v15;
            v19 = (_DWORD *)v18;
            do
            {
              *v19++ = *(_DWORD *)(v18 - 4);
              --v17;
            }
            while ( v17 );
            v16 = v30;
          }
          v30 = v16 + 1;
          i += 21;
          if ( v16 + 1 >= a1[8] )
            break;
        }
      }
    }
    *(_DWORD *)(v5 + 68) = 1;
    goto LABEL_23;
  }
  v9 = v8 - 1;
  if ( v9 )
  {
    result = v9 - 1;
    if ( result )
      return result;
    (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
      a1,
      *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56),
      v5 + 52,
      *(_DWORD *)(v5 + 72),
      a2,
      a3,
      a4);
    result = *(_DWORD *)(v5 + 52);
    if ( result < *(_DWORD *)(v5 + 72) )
      return result;
    result = a4;
    *(_DWORD *)(v5 + 68) = 0;
    if ( *a3 >= a4 )
      return result;
    goto LABEL_9;
  }
LABEL_23:
  (*(void (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int, unsigned int *, unsigned int))(a1[98] + 4))(
    a1,
    *(_DWORD *)(v5 + 4 * *(_DWORD *)(v5 + 64) + 56),
    v5 + 52,
    *(_DWORD *)(v5 + 72),
    a2,
    a3,
    a4);
  result = *(_DWORD *)(v5 + 72);
  if ( *(_DWORD *)(v5 + 52) >= result )
  {
    if ( *(_DWORD *)(v5 + 76) == 1 )
    {
      v20 = a1[96];
      result = a1[49];
      v36 = a1[69];
      v21 = 0;
      v31 = v20;
      v33 = 0;
      if ( (int)a1[8] > 0 )
      {
        v22 = (_DWORD *)(result + 12);
        v41 = (_DWORD *)(result + 12);
        while ( 1 )
        {
          v23 = *v22 * v22[6] / v4[69];
          v24 = *(_DWORD *)(*(_DWORD *)(v20 + 56) + 4 * v21);
          v25 = *(_DWORD *)(*(_DWORD *)(v20 + 60) + 4 * v21);
          v37 = v24;
          if ( v23 > 0 )
          {
            v40 = 4 * v23;
            v26 = 0;
            v39 = (_DWORD *)(v25 + 4 * v23 * (v36 + 2));
            v27 = (_DWORD *)(v25 + 4 * v23 * (v36 + 1));
            v28 = v24 - v25;
            v35 = v23;
            while ( 1 )
            {
              *(_DWORD *)(v26 - v40 + v24) = *(_DWORD *)((char *)v27 + v28);
              *(_DWORD *)(v26 - v40 + v25) = *v27;
              *(_DWORD *)((char *)v39 + v28) = *(_DWORD *)(v28 + v26 + v25);
              *v39 = *(_DWORD *)(v26 + v25);
              v26 += 4;
              ++v27;
              v29 = v35 == 1;
              ++v39;
              --v35;
              if ( v29 )
                break;
              v24 = v37;
            }
            v21 = v33;
            v5 = v38;
            v4 = a1;
          }
          result = v4[8];
          v33 = ++v21;
          v41 += 21;
          if ( v21 >= (int)result )
            break;
          v22 = v41;
          v20 = v31;
        }
      }
    }
    *(_DWORD *)(v5 + 64) ^= 1u;
    *(_BYTE *)(v5 + 48) = 0;
    *(_DWORD *)(v5 + 52) = v4[69] + 1;
    *(_DWORD *)(v5 + 72) = v4[69] + 2;
    *(_DWORD *)(v5 + 68) = 2;
  }
  return result;
}

// sub_1003EC20 @ 0x1003EC20
int __cdecl sub_1003EC20(int a1, int a2, int a3, int a4)
{
  return (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int, int, int))(*(_DWORD *)(a1 + 392) + 4))(
           a1,
           0,
           0,
           0,
           a2,
           a3,
           a4);
}

// sub_1003EC50 @ 0x1003EC50
char __cdecl sub_1003EC50(int a1, char a2)
{
  _DWORD *v3; // ebp
  int v4; // eax
  int *v5; // edi
  _DWORD *v6; // ebp
  int v7; // ecx
  int v8; // ebx
  int v9; // eax
  int *v10; // ecx
  int v11; // edx
  int v13; // [esp-Ch] [ebp-18h]
  int v14; // [esp-8h] [ebp-14h]
  _DWORD *v15; // [esp+10h] [ebp+4h]
  int v16; // [esp+14h] [ebp+8h]

  v3 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 116);
  LOBYTE(v4) = a2;
  *(_DWORD *)(a1 + 388) = v3;
  v15 = v3;
  *v3 = sub_1003ED60;
  v3[2] = sub_1003EDC0;
  v3[28] = 0;
  if ( a2 )
  {
    v16 = 0;
    if ( *(int *)(a1 + 32) > 0 )
    {
      v5 = (int *)(*(_DWORD *)(a1 + 196) + 12);
      v6 = v3 + 18;
      do
      {
        v7 = *v5;
        if ( *(_BYTE *)(a1 + 200) )
          v7 *= 3;
        v8 = *(_DWORD *)(a1 + 4);
        v14 = v7;
        v13 = sub_1003E470(v5[5], *v5);
        v9 = sub_1003E470(v5[4], *(v5 - 1));
        *v6 = (*(int (__cdecl **)(int, int, int, int, int, int))(v8 + 20))(a1, 1, 1, v9, v13, v14);
        LOBYTE(v4) = v16 + 1;
        ++v6;
        v5 += 21;
        ++v16;
      }
      while ( v16 < *(_DWORD *)(a1 + 32) );
      v3 = v15;
    }
    v3[1] = sub_1003F200;
    v3[3] = sub_1003F470;
    v3[4] = v3 + 18;
  }
  else
  {
    v4 = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 1280);
    v10 = v3 + 8;
    v11 = 10;
    do
    {
      *v10++ = v4;
      v4 += 128;
      --v11;
    }
    while ( v11 );
    v3[4] = 0;
    v3[1] = sub_1003F1F0;
    v3[3] = sub_1003EF50;
  }
  return v4;
}

// sub_1003ED60 @ 0x1003ED60
_DWORD *__cdecl sub_1003ED60(_DWORD *a1)
{
  _DWORD *result; // eax
  int v2; // edi
  int v3; // ecx
  int v4; // ecx

  result = (_DWORD *)a1[97];
  v2 = a1[72];
  a1[32] = 0;
  if ( v2 <= 1 )
  {
    v3 = a1[73];
    if ( a1[70] == 1 )
      v4 = *(_DWORD *)(v3 + 72);
    else
      v4 = *(_DWORD *)(v3 + 12);
    result[7] = v4;
    result[5] = 0;
    result[6] = 0;
  }
  else
  {
    result[7] = 1;
    result[5] = 0;
    result[6] = 0;
  }
  return result;
}

// sub_1003EDC0 @ 0x1003EDC0
char __cdecl sub_1003EDC0(int a1)
{
  _DWORD *v2; // edi
  _WORD *v3; // eax
  int v4; // ebx
  int v5; // ebp
  int v6; // ecx
  int v7; // ecx
  _DWORD *v8; // eax
  int v9; // edi
  int v11; // [esp+10h] [ebp-Ch]
  _WORD **v12; // [esp+14h] [ebp-8h]
  _DWORD *v13; // [esp+18h] [ebp-4h]
  char v14; // [esp+20h] [ebp+4h]

  v2 = *(_DWORD **)(a1 + 388);
  v3 = (_WORD *)v2[4];
  v4 = 0;
  v13 = v2;
  if ( v3 )
  {
    LOBYTE(v3) = *(_BYTE *)(a1 + 73);
    if ( (_BYTE)v3 )
    {
      LOBYTE(v3) = *(_BYTE *)(a1 + 200);
      v14 = 0;
      if ( (_BYTE)v3 )
      {
        if ( *(_DWORD *)(a1 + 140) )
        {
          if ( !v2[28] )
            v2[28] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24 * *(_DWORD *)(a1 + 32));
          v5 = v2[28];
          v3 = *(_WORD **)(a1 + 196);
          if ( *(int *)(a1 + 32) > 0 )
          {
            v11 = 0;
            v12 = (_WORD **)(v3 + 38);
            while ( 1 )
            {
              v3 = *v12;
              if ( !*v12 )
                break;
              if ( !*v3 )
                break;
              if ( !v3[1] )
                break;
              if ( !v3[8] )
                break;
              if ( !v3[16] )
                break;
              if ( !v3[9] )
                break;
              if ( !v3[2] )
                break;
              v6 = *(_DWORD *)(a1 + 140);
              v3 = *(_WORD **)(v6 + v11);
              v7 = v11 + v6;
              if ( (int)v3 < 0 )
                break;
              v8 = (_DWORD *)(v7 + 4);
              v9 = 5;
              do
              {
                *(_DWORD *)((char *)v8 + v5 - v7) = *v8;
                if ( *v8 )
                  v14 = 1;
                ++v8;
                --v9;
              }
              while ( v9 );
              v5 += 24;
              ++v4;
              v11 += 256;
              v12 += 21;
              if ( v4 >= *(_DWORD *)(a1 + 32) )
              {
                LOBYTE(v3) = v14;
                if ( v14 )
                {
                  v13[3] = sub_1003F620;
                  *(_DWORD *)(a1 + 136) = 0;
                  return (char)v3;
                }
                v2 = v13;
                break;
              }
              v2 = v13;
            }
          }
        }
      }
    }
    v2[3] = sub_1003F470;
    *(_DWORD *)(a1 + 136) = 0;
  }
  else
  {
    *(_DWORD *)(a1 + 136) = 0;
  }
  return (char)v3;
}

// sub_1003EF50 @ 0x1003EF50
int __cdecl sub_1003EF50(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // ebp
  int v3; // ebx
  unsigned int v4; // ecx
  int v5; // eax
  unsigned int v6; // edi
  int v7; // ecx
  _DWORD *v8; // esi
  int v9; // edi
  int v10; // ebx
  int v11; // eax
  _DWORD *v12; // ebp
  bool v13; // cc
  int v14; // edx
  int v15; // ecx
  unsigned int v16; // edx
  unsigned int v17; // ecx
  _DWORD *v18; // eax
  bool v20; // cf
  int v21; // ecx
  int v22; // edx
  int v23; // [esp+10h] [ebp-38h]
  unsigned int v24; // [esp+14h] [ebp-34h]
  int v25; // [esp+18h] [ebp-30h]
  _DWORD *v26; // [esp+1Ch] [ebp-2Ch]
  _DWORD *v27; // [esp+20h] [ebp-28h]
  unsigned int v28; // [esp+24h] [ebp-24h]
  int v29; // [esp+28h] [ebp-20h]
  int v30; // [esp+2Ch] [ebp-1Ch]
  int i; // [esp+30h] [ebp-18h]
  int v32; // [esp+34h] [ebp-14h]
  int v33; // [esp+38h] [ebp-10h]
  unsigned int v34; // [esp+3Ch] [ebp-Ch]
  void (__cdecl *v35)(_DWORD *, _DWORD *, _DWORD, int, int); // [esp+40h] [ebp-8h]
  int v36; // [esp+44h] [ebp-4h]

  v2 = a1;
  v3 = a1[97];
  v4 = a1[77] - 1;
  v34 = a1[70] - 1;
  v5 = *(_DWORD *)(v3 + 24);
  v33 = v3;
  v28 = v4;
  v23 = v5;
  if ( v5 >= *(_DWORD *)(v3 + 28) )
  {
LABEL_25:
    v15 = v2[32];
    ++v2[34];
    v16 = v2[70];
    v17 = v15 + 1;
    v2[32] = v17;
    if ( v17 >= v16 )
    {
      (*(void (__cdecl **)(_DWORD *))(v2[99] + 12))(v2);
      return 4;
    }
    else
    {
      v18 = (_DWORD *)v2[97];
      if ( (int)v2[72] <= 1 )
      {
        v20 = v17 < v16 - 1;
        v21 = v2[73];
        if ( v20 )
          v22 = *(_DWORD *)(v21 + 12);
        else
          v22 = *(_DWORD *)(v21 + 72);
        v18[7] = v22;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
      else
      {
        v18[7] = 1;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v6 = *(_DWORD *)(v3 + 20);
      v24 = v6;
      if ( v6 <= v4 )
        break;
LABEL_24:
      v14 = *(_DWORD *)(v3 + 28);
      ++v5;
      *(_DWORD *)(v3 + 20) = 0;
      v23 = v5;
      if ( v5 >= v14 )
        goto LABEL_25;
    }
    while ( 1 )
    {
      sub_1003E510(*(void **)(v3 + 32), v2[79] << 7);
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, int))(v2[101] + 4))(v2, v3 + 32) )
        break;
      v7 = 0;
      v25 = 0;
      v32 = 0;
      if ( (int)v2[72] > 0 )
      {
        v27 = a2;
        v26 = v2 + 73;
        while ( 1 )
        {
          v8 = (_DWORD *)*v26;
          if ( *(_BYTE *)(*v26 + 48) )
          {
            v35 = *(void (__cdecl **)(_DWORD *, _DWORD *, _DWORD, int, int))(v2[102] + 4 * v8[1] + 4);
            if ( v6 >= v28 )
              v29 = v8[17];
            else
              v29 = v8[13];
            v9 = v24 * v8[16];
            v10 = *v27 + 4 * v23 * v8[9];
            v11 = 0;
            v36 = v9;
            for ( i = 0; v11 < v8[14]; i = v11 )
            {
              if ( (v2[32] < v34 || v11 + v23 < v8[18]) && v29 > 0 )
              {
                v12 = (_DWORD *)(v33 + 4 * v7 + 32);
                v30 = v29;
                do
                {
                  v35(a1, v8, *v12, v10, v9);
                  v9 += v8[9];
                  ++v12;
                  --v30;
                }
                while ( v30 );
                v11 = i;
                v9 = v36;
                v7 = v25;
                v2 = a1;
              }
              v7 += v8[13];
              v10 += 4 * v8[9];
              ++v11;
              v25 = v7;
            }
          }
          else
          {
            v7 += v8[15];
            v25 = v7;
          }
          v13 = ++v32 < v2[72];
          ++v26;
          ++v27;
          if ( !v13 )
            break;
          v6 = v24;
        }
        v3 = v33;
        v6 = v24;
      }
      v24 = ++v6;
      if ( v6 > v28 )
      {
        v4 = v28;
        v5 = v23;
        goto LABEL_24;
      }
    }
    *(_DWORD *)(v3 + 20) = v6;
    *(_DWORD *)(v3 + 24) = v23;
    return 0;
  }
}

// sub_1003F1F0 @ 0x1003F1F0
int sub_1003F1F0()
{
  return 0;
}

// sub_1003F200 @ 0x1003F200
int __cdecl sub_1003F200(_DWORD *a1)
{
  _DWORD *v1; // esi
  _DWORD *v2; // edi
  int v3; // ebx
  int v4; // eax
  unsigned int v5; // ebp
  int v6; // ebx
  int v7; // edi
  int v8; // ecx
  _DWORD *v9; // ebp
  int v10; // eax
  int v11; // edx
  int *v12; // esi
  bool v13; // cc
  int v14; // ecx
  unsigned int v16; // edx
  unsigned int v17; // ecx
  _DWORD *v18; // eax
  bool v19; // cf
  int v20; // edx
  int v21; // ecx
  _DWORD *v22; // [esp+10h] [ebp-30h]
  int v23; // [esp+10h] [ebp-30h]
  _DWORD *v24; // [esp+14h] [ebp-2Ch]
  _DWORD *v25; // [esp+18h] [ebp-28h]
  _DWORD *v26; // [esp+18h] [ebp-28h]
  int v27; // [esp+1Ch] [ebp-24h]
  int v28; // [esp+20h] [ebp-20h]
  _DWORD *v29; // [esp+24h] [ebp-1Ch]
  int v30; // [esp+28h] [ebp-18h]
  int v31; // [esp+2Ch] [ebp-14h]
  _BYTE v32[16]; // [esp+30h] [ebp-10h] BYREF

  v1 = a1;
  v2 = (_DWORD *)a1[97];
  v3 = 0;
  v29 = v2;
  if ( (int)a1[72] > 0 )
  {
    v25 = v32;
    v22 = a1 + 73;
    do
    {
      *v25 = (*(int (__cdecl **)(_DWORD *, _DWORD, int, _DWORD, int))(a1[1] + 32))(
               a1,
               v2[*(_DWORD *)(*v22 + 4) + 18],
               *(_DWORD *)(*v22 + 12) * a1[32],
               *(_DWORD *)(*v22 + 12),
               1);
      ++v3;
      ++v22;
      ++v25;
    }
    while ( v3 < a1[72] );
  }
  v4 = v2[6];
  v23 = v4;
  if ( v4 >= v2[7] )
  {
LABEL_24:
    v16 = v1[70];
    v17 = v1[32] + 1;
    v1[32] = v17;
    if ( v17 >= v16 )
    {
      (*(void (__cdecl **)(_DWORD *))(v1[99] + 12))(v1);
      return 4;
    }
    else
    {
      v18 = (_DWORD *)v1[97];
      if ( (int)v1[72] <= 1 )
      {
        v19 = v17 < v16 - 1;
        v20 = v1[73];
        if ( v19 )
          v21 = *(_DWORD *)(v20 + 12);
        else
          v21 = *(_DWORD *)(v20 + 72);
        v18[5] = 0;
        v18[6] = 0;
        v18[7] = v21;
        return 3;
      }
      else
      {
        v18[7] = 1;
        v18[5] = 0;
        v18[6] = 0;
        return 3;
      }
    }
  }
  else
  {
    while ( 1 )
    {
      v5 = v2[5];
      v30 = v5;
      if ( v5 < v1[77] )
        break;
LABEL_21:
      v14 = v2[7];
      ++v4;
      v2[5] = 0;
      v23 = v4;
      if ( v4 >= v14 )
        goto LABEL_24;
    }
    while ( 1 )
    {
      v6 = 0;
      v28 = 0;
      if ( (int)v1[72] > 0 )
      {
        v26 = v32;
        v24 = v1 + 73;
        do
        {
          v7 = *v24;
          v8 = *(_DWORD *)(*v24 + 52);
          v27 = 0;
          if ( *(int *)(*v24 + 56) > 0 )
          {
            v31 = (v5 * *(_DWORD *)(*v24 + 52)) << 7;
            v9 = (_DWORD *)(*v26 + 4 * v23);
            do
            {
              v10 = v31 + *v9;
              v11 = 0;
              if ( v8 > 0 )
              {
                v12 = &v29[v6 + 8];
                do
                {
                  *v12 = v10;
                  v8 = *(_DWORD *)(v7 + 52);
                  ++v6;
                  ++v12;
                  v10 += 128;
                  ++v11;
                }
                while ( v11 < v8 );
                v1 = a1;
              }
              ++v9;
              ++v27;
            }
            while ( v27 < *(_DWORD *)(v7 + 56) );
            v5 = v30;
          }
          v13 = ++v28 < v1[72];
          ++v24;
          ++v26;
        }
        while ( v13 );
        v2 = v29;
      }
      if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *, _DWORD *))(v1[101] + 4))(v1, v2 + 8) )
        break;
      v30 = ++v5;
      if ( v5 >= v1[77] )
      {
        v4 = v23;
        goto LABEL_21;
      }
    }
    v2[5] = v5;
    v2[6] = v23;
    return 0;
  }
}

// sub_1003F470 @ 0x1003F470
int __cdecl sub_1003F470(int a1, _DWORD *a2)
{
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // esi
  _DWORD *v7; // edi
  _DWORD *v8; // ebp
  int v9; // eax
  int *v10; // ebp
  int v11; // edx
  int v12; // ebp
  int v13; // edi
  bool v14; // zf
  bool v15; // cc
  unsigned int v16; // edx
  unsigned int v17; // eax
  int v19; // [esp+8h] [ebp-20h]
  int v20; // [esp+Ch] [ebp-1Ch]
  int v21; // [esp+10h] [ebp-18h]
  _DWORD *v22; // [esp+14h] [ebp-14h]
  _DWORD *v23; // [esp+18h] [ebp-10h]
  unsigned int v24; // [esp+1Ch] [ebp-Ch]
  int v25; // [esp+20h] [ebp-8h]
  void (__cdecl *v26)(int, int, int, int, int); // [esp+24h] [ebp-4h]
  int v27; // [esp+2Ch] [ebp+4h]
  unsigned int i; // [esp+30h] [ebp+8h]

  v3 = *(_DWORD *)(a1 + 388);
  v24 = *(_DWORD *)(a1 + 280) - 1;
  while ( 1 )
  {
    v4 = *(_DWORD *)(a1 + 124);
    v5 = *(_DWORD *)(a1 + 132);
    if ( v4 >= v5 && (v4 != v5 || *(_DWORD *)(a1 + 128) > *(_DWORD *)(a1 + 136)) )
      break;
    if ( !(**(int (__cdecl ***)(int))(a1 + 396))(a1) )
      return 0;
  }
  v6 = *(_DWORD *)(a1 + 196);
  v21 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v7 = a2;
    v8 = (_DWORD *)(v3 + 72);
    v23 = a2;
    v22 = v8;
    v25 = 4 - (_DWORD)a2;
    do
    {
      if ( *(_BYTE *)(v6 + 48) )
      {
        v9 = (*(int (__cdecl **)(int, _DWORD, int, _DWORD, _DWORD))(*(_DWORD *)(a1 + 4) + 32))(
               a1,
               *v8,
               *(_DWORD *)(v6 + 12) * *(_DWORD *)(a1 + 136),
               *(_DWORD *)(v6 + 12),
               0);
        v10 = (int *)v9;
        if ( *(_DWORD *)(a1 + 136) >= v24 )
        {
          v11 = *(_DWORD *)(v6 + 32) % *(_DWORD *)(v6 + 12);
          if ( !v11 )
            v11 = *(_DWORD *)(v6 + 12);
        }
        else
        {
          v11 = *(_DWORD *)(v6 + 12);
        }
        v26 = *(void (__cdecl **)(int, int, int, int, int))((char *)v7 + v25 + *(_DWORD *)(a1 + 408));
        v27 = *v7;
        if ( v11 > 0 )
        {
          v19 = v9;
          v20 = v11;
          do
          {
            v12 = *v10;
            v13 = 0;
            for ( i = 0; i < *(_DWORD *)(v6 + 28); ++i )
            {
              v26(a1, v6, v12, v27, v13);
              v13 += *(_DWORD *)(v6 + 36);
              v12 += 128;
            }
            v10 = (int *)(v19 + 4);
            v14 = v20 == 1;
            v27 += 4 * *(_DWORD *)(v6 + 36);
            v19 += 4;
            --v20;
          }
          while ( !v14 );
          v7 = v23;
        }
      }
      v8 = v22 + 1;
      ++v7;
      v6 += 84;
      v15 = ++v21 < *(_DWORD *)(a1 + 32);
      ++v22;
      v23 = v7;
    }
    while ( v15 );
  }
  v16 = *(_DWORD *)(a1 + 280);
  v17 = *(_DWORD *)(a1 + 136) + 1;
  *(_DWORD *)(a1 + 136) = v17;
  return 4 - (v17 < v16);
}

// sub_1003F620 @ 0x1003F620
int __cdecl sub_1003F620(_DWORD *a1, int *a2)
{
  _DWORD *v2; // esi
  int v3; // eax
  int v4; // ecx
  int v5; // edi
  unsigned int v6; // ebp
  int v7; // edx
  int v8; // ebx
  unsigned int v9; // esi
  unsigned int v10; // ecx
  int v11; // eax
  int v13; // esi
  unsigned __int16 *v14; // eax
  int v15; // eax
  __int16 *v16; // edx
  __int16 *v17; // ecx
  __int16 *v18; // eax
  int v19; // esi
  int v20; // edi
  int v21; // ebp
  int v22; // ecx
  int v23; // edx
  int v24; // eax
  int v25; // eax
  int v26; // ecx
  int v27; // edx
  int v28; // eax
  int v29; // eax
  int v30; // ecx
  int v31; // edx
  int v32; // eax
  int v33; // eax
  int v34; // ecx
  int v35; // edx
  int v36; // eax
  int v37; // eax
  int v38; // ecx
  int v39; // edx
  int v40; // eax
  int v41; // eax
  bool v42; // cc
  unsigned int v43; // edx
  unsigned int v44; // edi
  char v45; // [esp+12h] [ebp-102h]
  char v46; // [esp+13h] [ebp-101h]
  int v47; // [esp+14h] [ebp-100h]
  _DWORD *v48; // [esp+18h] [ebp-FCh]
  int v49; // [esp+1Ch] [ebp-F8h]
  _DWORD *v50; // [esp+20h] [ebp-F4h]
  int v51; // [esp+24h] [ebp-F0h]
  int v52; // [esp+28h] [ebp-ECh]
  __int16 *v53; // [esp+2Ch] [ebp-E8h]
  int v54; // [esp+30h] [ebp-E4h]
  int v55; // [esp+34h] [ebp-E0h]
  int v56; // [esp+38h] [ebp-DCh]
  int v57; // [esp+3Ch] [ebp-D8h]
  int v58; // [esp+40h] [ebp-D4h]
  unsigned int v59; // [esp+44h] [ebp-D0h]
  int v60; // [esp+48h] [ebp-CCh]
  int v61; // [esp+4Ch] [ebp-C8h]
  __int16 *v62; // [esp+50h] [ebp-C4h]
  int v63; // [esp+54h] [ebp-C0h]
  __int16 *v64; // [esp+58h] [ebp-BCh]
  int v65; // [esp+5Ch] [ebp-B8h]
  int v66; // [esp+60h] [ebp-B4h]
  int v68; // [esp+68h] [ebp-ACh]
  int v69; // [esp+6Ch] [ebp-A8h]
  int v70; // [esp+70h] [ebp-A4h]
  int v71; // [esp+74h] [ebp-A0h]
  unsigned int v72; // [esp+78h] [ebp-9Ch]
  int v73; // [esp+7Ch] [ebp-98h]
  int v74; // [esp+80h] [ebp-94h]
  int v75; // [esp+84h] [ebp-90h]
  void (__cdecl *v76)(_DWORD *, int, _BYTE *, int, int); // [esp+88h] [ebp-8Ch]
  unsigned int i; // [esp+8Ch] [ebp-88h]
  int v78; // [esp+90h] [ebp-84h]
  _BYTE v79[2]; // [esp+94h] [ebp-80h] BYREF
  __int16 v80; // [esp+96h] [ebp-7Eh]
  __int16 v81; // [esp+98h] [ebp-7Ch]
  __int16 v82; // [esp+A4h] [ebp-70h]
  __int16 v83; // [esp+A6h] [ebp-6Eh]
  __int16 v84; // [esp+B4h] [ebp-60h]

  v2 = a1;
  v3 = a1[31];
  v4 = a1[33];
  v5 = a1[97];
  v6 = a1[70] - 1;
  v75 = v5;
  for ( i = v6; v3 <= v4; v4 = a1[33] )
  {
    v7 = a1[99];
    if ( *(_BYTE *)(v7 + 17)
      || v3 == v4 && __PAIR64__(a1[32], a1[90]) >= __PAIR64__(a1[34], 1) && a1[32] != a1[34] + (a1[90] == 0) )
    {
      break;
    }
    if ( !(*(int (__cdecl **)(_DWORD *))v7)(a1) )
      return 0;
    v3 = a1[31];
  }
  v8 = a1[49];
  v69 = 0;
  v55 = v8;
  if ( (int)a1[8] > 0 )
  {
    v65 = 0;
    v48 = (_DWORD *)(v5 + 72);
    v78 = -68 - v5;
    do
    {
      if ( *(_BYTE *)(v8 + 48) )
      {
        v9 = v2[34];
        v10 = *(_DWORD *)(v8 + 12);
        if ( v9 >= v6 )
        {
          v11 = *(_DWORD *)(v8 + 32) % v10;
          v47 = v11;
          if ( !v11 )
          {
            v47 = *(_DWORD *)(v8 + 12);
            v11 = v47;
          }
          v45 = 1;
        }
        else
        {
          v47 = *(_DWORD *)(v8 + 12);
          v11 = 2 * v10;
          v45 = 0;
        }
        if ( v9 )
        {
          v13 = (*(int (__cdecl **)(_DWORD *, _DWORD, unsigned int, unsigned int, _DWORD))(a1[1] + 32))(
                  a1,
                  *v48,
                  v10 * (v9 - 1),
                  v10 + v11,
                  0)
              + 4 * *(_DWORD *)(v8 + 12);
          v57 = v13;
          v46 = 0;
        }
        else
        {
          v57 = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, int, _DWORD))(a1[1] + 32))(a1, *v48, 0, v11, 0);
          v46 = 1;
          v13 = v57;
        }
        v50 = (_DWORD *)(v65 + *(_DWORD *)(v75 + 112));
        v14 = *(unsigned __int16 **)(v8 + 76);
        v49 = *v14;
        v68 = v14[1];
        v70 = v14[8];
        v74 = v14[16];
        v73 = v14[9];
        v71 = v14[2];
        v76 = *(void (__cdecl **)(_DWORD *, int, _BYTE *, int, int))((char *)v48 + v78 + a1[102]);
        v61 = *a2;
        v15 = 0;
        v63 = 0;
        if ( v47 > 0 )
        {
          while ( 1 )
          {
            v16 = *(__int16 **)(v13 + 4 * v15);
            v53 = v16;
            if ( !v46 || (v17 = *(__int16 **)(v13 + 4 * v15), v15) )
              v17 = *(__int16 **)(v13 + 4 * v15 - 4);
            v18 = v45 && v15 == v47 - 1 ? *(__int16 **)(v13 + 4 * v15) : *(__int16 **)(v13 + 4 * v15 + 4);
            v19 = *v16;
            v20 = *v17;
            v21 = *v18;
            v58 = v20;
            v54 = v20;
            v51 = v19;
            v66 = v19;
            v60 = v21;
            v52 = v21;
            v56 = 0;
            v72 = *(_DWORD *)(v8 + 28) - 1;
            v59 = 0;
            v62 = v18 + 64;
            v64 = v17 + 64;
            do
            {
              sub_1003E4E0(v53, v79, 1);
              if ( v59 < v72 )
              {
                v19 = v53[64];
                v58 = *v64;
                v60 = *v62;
              }
              v22 = v50[1];
              if ( v22 && !v80 )
              {
                v23 = 36 * v49 * (v66 - v19);
                if ( v23 < 0 )
                {
                  v25 = ((v68 << 7) - v23) / (v68 << 8);
                  if ( v22 > 0 && v25 >= 1 << v22 )
                    v25 = (1 << v22) - 1;
                  v24 = -v25;
                }
                else
                {
                  v24 = (v23 + (v68 << 7)) / (v68 << 8);
                  if ( v22 > 0 && v24 >= 1 << v22 )
                    v24 = (1 << v22) - 1;
                }
                v8 = v55;
                v80 = v24;
              }
              v26 = v50[2];
              if ( v26 && !v82 )
              {
                v27 = 36 * v49 * (v54 - v52);
                if ( v27 < 0 )
                {
                  v29 = ((v70 << 7) - v27) / (v70 << 8);
                  if ( v26 > 0 && v29 >= 1 << v26 )
                    v29 = (1 << v26) - 1;
                  v28 = -v29;
                }
                else
                {
                  v28 = (v27 + (v70 << 7)) / (v70 << 8);
                  if ( v26 > 0 && v28 >= 1 << v26 )
                    v28 = (1 << v26) - 1;
                }
                v8 = v55;
                v82 = v28;
              }
              v30 = v50[3];
              if ( v30 && !v84 )
              {
                v31 = 9 * v49 * (v54 + v52 - 2 * v51);
                if ( v31 < 0 )
                {
                  v33 = ((v74 << 7) - v31) / (v74 << 8);
                  if ( v30 > 0 && v33 >= 1 << v30 )
                    v33 = (1 << v30) - 1;
                  v32 = -v33;
                }
                else
                {
                  v32 = (v31 + (v74 << 7)) / (v74 << 8);
                  if ( v30 > 0 && v32 >= 1 << v30 )
                    v32 = (1 << v30) - 1;
                }
                v8 = v55;
                v84 = v32;
              }
              v34 = v50[4];
              if ( v34 && !v83 )
              {
                v35 = 5 * v49 * (v20 + v60 - v21 - v58);
                if ( v35 < 0 )
                {
                  v37 = ((v73 << 7) - v35) / (v73 << 8);
                  if ( v34 > 0 && v37 >= 1 << v34 )
                    v37 = (1 << v34) - 1;
                  v36 = -v37;
                }
                else
                {
                  v36 = (v35 + (v73 << 7)) / (v73 << 8);
                  if ( v34 > 0 && v36 >= 1 << v34 )
                    v36 = (1 << v34) - 1;
                }
                v83 = v36;
              }
              v38 = v50[5];
              if ( v38 && !v81 )
              {
                v39 = 9 * v49 * (v66 + v19 - 2 * v51);
                if ( v39 < 0 )
                {
                  v41 = ((v71 << 7) - v39) / (v71 << 8);
                  if ( v38 > 0 && v41 >= 1 << v38 )
                    v41 = (1 << v38) - 1;
                  v40 = -v41;
                }
                else
                {
                  v40 = (v39 + (v71 << 7)) / (v71 << 8);
                  if ( v38 > 0 && v40 >= 1 << v38 )
                    v40 = (1 << v38) - 1;
                }
                v81 = v40;
              }
              v76(a1, v8, v79, v61, v56);
              v20 = v54;
              v21 = v52;
              v54 = v58;
              v52 = v60;
              v53 += 64;
              v66 = v51;
              v62 += 64;
              v56 += *(_DWORD *)(v8 + 36);
              v42 = v59 + 1 <= v72;
              v51 = v19;
              v64 += 64;
              ++v59;
            }
            while ( v42 );
            v61 += 4 * *(_DWORD *)(v8 + 36);
            if ( ++v63 >= v47 )
              break;
            v15 = v63;
            v13 = v57;
          }
        }
        v6 = i;
        v2 = a1;
      }
      v65 += 24;
      v8 += 84;
      v42 = ++v69 < v2[8];
      ++v48;
      ++a2;
      v55 = v8;
    }
    while ( v42 );
  }
  v43 = v2[70];
  v44 = v2[34] + 1;
  v2[34] = v44;
  return 4 - (v44 < v43);
}

// sub_1003FC90 @ 0x1003FC90
int __cdecl sub_1003FC90(int a1, int a2, _DWORD *a3)
{
  _DWORD *v3; // edi
  int v4; // ebx
  int v5; // eax
  int i; // edx
  unsigned int v7; // ecx
  unsigned int v8; // esi
  _BYTE *v9; // edi
  char v10; // bp
  unsigned int v11; // ecx
  int v12; // eax
  int v13; // ecx
  int v14; // eax
  int j; // esi
  _DWORD *v16; // edx
  int v17; // ebp
  int v18; // esi
  int v19; // ecx
  _DWORD *v20; // eax
  int v21; // edx
  int result; // eax
  int v23; // ecx
  int v24; // ebp
  _BYTE *v25; // edi
  int v26; // ebx
  int v27; // eax
  _BYTE *v28; // edx
  int *v29; // eax
  int v30; // esi
  int v31; // [esp+10h] [ebp-51Ch]
  int v32; // [esp+10h] [ebp-51Ch]
  _DWORD *v33; // [esp+14h] [ebp-518h]
  int v34; // [esp+18h] [ebp-514h]
  int v35; // [esp+1Ch] [ebp-510h]
  _DWORD *v36; // [esp+20h] [ebp-50Ch]
  _BYTE v37[1288]; // [esp+24h] [ebp-508h] BYREF

  if ( !*a3 )
    *a3 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1492);
  v3 = (_DWORD *)*a3;
  v4 = a2;
  v5 = 0;
  v36 = v3;
  v3[52] = a2;
  v31 = 0;
  for ( i = 1; i <= 16; ++i )
  {
    v7 = *(unsigned __int8 *)(i + v4);
    v8 = v7;
    if ( *(_BYTE *)(i + v4) )
    {
      v9 = &v37[v5];
      LOBYTE(v4) = i;
      BYTE1(v4) = i;
      v10 = v7;
      v11 = v7 >> 2;
      v12 = v4 << 16;
      LOWORD(v12) = v4;
      v4 = a2;
      memset32(v9, v12, v11);
      memset(&v9[4 * v11], v12, v10 & 3);
      v3 = v36;
      v5 = v8 + v31;
      v31 += v8;
    }
  }
  v37[v5] = 0;
  v13 = 0;
  v14 = 0;
  for ( j = v37[0]; v37[v14]; ++j )
  {
    if ( (char)v37[v14] == j )
    {
      v16 = &v37[4 * v14 + 260];
      do
      {
        v17 = (char)v37[++v14];
        *v16++ = v13++;
      }
      while ( v17 == j );
    }
    v13 *= 2;
  }
  v18 = 0;
  v19 = 1;
  v20 = v3 + 18;
  do
  {
    if ( *(_BYTE *)(v19 + v4) )
    {
      v21 = *(_DWORD *)&v37[4 * v18 + 260];
      v20[18] = v18;
      *(v20 - 17) = v21;
      v18 += *(unsigned __int8 *)(v19 + v4);
      *v20 = *(_DWORD *)&v37[4 * v18 + 256];
    }
    else
    {
      *v20 = -1;
    }
    ++v19;
    ++v20;
  }
  while ( v19 <= 16 );
  result = 0;
  v3[34] = 0xFFFFF;
  memset(v3 + 53, 0, 0x400u);
  v23 = 7;
  v32 = 0;
  v24 = 1;
  v35 = 7;
  do
  {
    v34 = 1;
    if ( *(_BYTE *)(v4 + v24) )
    {
      v25 = (_BYTE *)(result + a2 + 17);
      v26 = 1 << v23;
      v33 = &v37[4 * result + 260];
      do
      {
        v27 = *v33 << v23;
        if ( v26 > 0 )
        {
          v28 = (char *)v36 + v27 + 1236;
          v29 = &v36[v27 + 53];
          v30 = v26;
          do
          {
            *v29++ = v24;
            *v28++ = *v25;
            --v30;
          }
          while ( v30 );
          v23 = v35;
        }
        ++v32;
        ++v33;
        ++v25;
        ++v34;
      }
      while ( v34 <= *(unsigned __int8 *)(a2 + v24) );
      v4 = a2;
      result = v32;
    }
    ++v24;
    v35 = --v23;
  }
  while ( v23 >= 0 );
  return result;
}

// sub_1003FE80 @ 0x1003FE80
char __cdecl sub_1003FE80(unsigned __int8 **a1, int a2, int a3, int a4)
{
  int v4; // ebp
  unsigned __int8 *v5; // ebx
  unsigned __int8 *v6; // edi
  unsigned __int8 **v7; // eax
  int v8; // eax
  unsigned __int8 **v9; // eax
  unsigned __int8 *v10; // eax

  v4 = a3;
  v5 = a1[1];
  v6 = *a1;
  if ( a3 >= 25 )
  {
LABEL_19:
    *a1 = v6;
    a1[1] = v5;
    a1[4] = (unsigned __int8 *)v4;
    a1[3] = (unsigned __int8 *)a2;
    return 1;
  }
  while ( 1 )
  {
    if ( a1[2] )
      goto LABEL_14;
    if ( !v5 )
      break;
LABEL_6:
    v8 = *v6;
    --v5;
    ++v6;
    if ( v8 == 255 )
    {
      do
      {
        if ( !v5 )
        {
          if ( !(*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[5] + 5) + 12))(a1[5]) )
            return 0;
          v9 = (unsigned __int8 **)*((_DWORD *)a1[5] + 5);
          v6 = *v9;
          v5 = v9[1];
        }
        v10 = (unsigned __int8 *)*v6;
        --v5;
        ++v6;
      }
      while ( v10 == (unsigned __int8 *)255 );
      if ( v10 )
      {
        a1[2] = v10;
LABEL_14:
        if ( v4 >= a4 )
          goto LABEL_19;
        if ( !*a1[6] )
        {
          *(_DWORD *)(*(_DWORD *)a1[5] + 20) = 113;
          (*(void (__cdecl **)(unsigned __int8 *, int))(*(_DWORD *)a1[5] + 4))(a1[5], -1);
          *a1[6] = 1;
        }
        v8 = 0;
        goto LABEL_18;
      }
      v8 = 255;
    }
LABEL_18:
    v4 += 8;
    a2 = v8 | (a2 << 8);
    if ( v4 >= 25 )
      goto LABEL_19;
  }
  if ( (*(unsigned __int8 (__cdecl **)(unsigned __int8 *))(*((_DWORD *)a1[5] + 5) + 12))(a1[5]) )
  {
    v7 = (unsigned __int8 **)*((_DWORD *)a1[5] + 5);
    v6 = *v7;
    v5 = v7[1];
    goto LABEL_6;
  }
  return 0;
}

// sub_1003FF80 @ 0x1003FF80
int __cdecl sub_1003FF80(int a1, int a2, int a3, int a4, int a5)
{
  int v5; // eax
  int v7; // edx
  int v8; // eax
  int v9; // ecx
  int *v10; // edi
  int v11; // esi
  int v12; // esi

  v5 = a3;
  if ( a3 >= a5 )
  {
    v7 = a2;
  }
  else
  {
    if ( !sub_1003FE80((unsigned __int8 **)a1, a2, a3, a5) )
      return -1;
    v7 = *(_DWORD *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 16);
  }
  v8 = v5 - a5;
  v9 = a4;
  v10 = (int *)(a4 + 4 * a5 + 68);
  v11 = ((1 << a5) - 1) & (v7 >> v8);
  if ( v11 > *v10 )
  {
    do
    {
      v12 = 2 * v11;
      if ( v8 < 1 )
      {
        if ( !sub_1003FE80((unsigned __int8 **)a1, v7, v8, 1) )
          return -1;
        v7 = *(_DWORD *)(a1 + 12);
        v8 = *(_DWORD *)(a1 + 16);
      }
      --v8;
      ++v10;
      v11 = (v7 >> v8) & 1 | v12;
      ++a5;
    }
    while ( v11 > *v10 );
    v9 = a4;
  }
  *(_DWORD *)(a1 + 16) = v8;
  *(_DWORD *)(a1 + 12) = v7;
  if ( a5 <= 16 )
    return *(unsigned __int8 *)(*(_DWORD *)(v9 + 208)
                              + *(_DWORD *)(v9 + 4 * a5 + 140)
                              - *(_DWORD *)(v9 + 4 * a5)
                              + v11
                              + 17);
  *(_DWORD *)(**(_DWORD **)(a1 + 20) + 20) = 114;
  (*(void (__cdecl **)(_DWORD, int))(**(_DWORD **)(a1 + 20) + 4))(*(_DWORD *)(a1 + 20), -1);
  return 0;
}

// sub_10040070 @ 0x10040070
_DWORD *__cdecl sub_10040070(int a1)
{
  _DWORD *v1; // eax
  _DWORD *result; // eax
  int v3; // ecx

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 72);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_100400B0;
  v1[1] = sub_10040200;
  result = v1 + 10;
  v3 = 4;
  do
  {
    result[4] = 0;
    *result++ = 0;
    --v3;
  }
  while ( v3 );
  return result;
}

// sub_100400B0 @ 0x100400B0
int __cdecl sub_100400B0(_DWORD *a1)
{
  int v2; // ebx
  unsigned int v3; // edi
  unsigned int v4; // ebp
  int result; // eax
  int v6; // [esp+Ch] [ebp-8h]
  _DWORD *v7; // [esp+10h] [ebp-4h]
  _DWORD *v8; // [esp+18h] [ebp+4h]

  v2 = a1[101];
  if ( a1[90] || a1[91] != 63 || a1[92] || a1[93] )
  {
    *(_DWORD *)(*a1 + 20) = 118;
    (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
  }
  v6 = 0;
  if ( (int)a1[72] > 0 )
  {
    v7 = (_DWORD *)(v2 + 20);
    v8 = a1 + 73;
    do
    {
      v3 = *(_DWORD *)(*v8 + 20);
      v4 = *(_DWORD *)(*v8 + 24);
      if ( v3 >= 4 || !a1[v3 + 40] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v3;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      if ( v4 >= 4 || !a1[v4 + 44] )
      {
        *(_DWORD *)(*a1 + 20) = 49;
        *(_DWORD *)(*a1 + 24) = v4;
        (*(void (__cdecl **)(_DWORD *))*a1)(a1);
      }
      sub_1003FC90((int)a1, a1[v3 + 40], (_DWORD *)(v2 + 4 * v3 + 40));
      sub_1003FC90((int)a1, a1[v4 + 44], (_DWORD *)(v2 + 4 * v4 + 56));
      *v7++ = 0;
      ++v6;
      ++v8;
    }
    while ( v6 < a1[72] );
  }
  *(_DWORD *)(v2 + 12) = 0;
  *(_DWORD *)(v2 + 8) = 0;
  *(_BYTE *)(v2 + 16) = 0;
  result = a1[63];
  *(_DWORD *)(v2 + 36) = result;
  return result;
}

// sub_10040200 @ 0x10040200
char __cdecl sub_10040200(_DWORD *a1, _WORD **a2)
{
  _DWORD *v2; // esi
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // ecx
  int v8; // eax
  int v9; // edi
  int v10; // eax
  int v11; // edx
  bool v12; // cc
  int v13; // ebp
  int v14; // esi
  int v15; // ebx
  int v16; // ecx
  int v17; // edx
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  int v21; // esi
  int v22; // ebp
  int v23; // ecx
  int v24; // edx
  int v25; // ecx
  int v26; // esi
  int v27; // ecx
  int v28; // esi
  int v29; // ebp
  int v30; // edx
  int v31; // ebp
  int v32; // ecx
  int v33; // edx
  int v34; // ecx
  int v35; // esi
  int v36; // ecx
  int v37; // esi
  int v38; // ebp
  int v39; // edx
  int v40; // ecx
  int v41; // eax
  int v42; // edx
  int v43; // eax
  int *v46; // [esp+14h] [ebp-40h]
  _WORD *v47; // [esp+18h] [ebp-3Ch]
  int v48; // [esp+1Ch] [ebp-38h]
  int v49; // [esp+20h] [ebp-34h]
  int v50; // [esp+24h] [ebp-30h]
  int v51; // [esp+28h] [ebp-2Ch]
  int v52; // [esp+2Ch] [ebp-28h]
  int v53; // [esp+30h] [ebp-24h]
  int v54; // [esp+34h] [ebp-20h]
  unsigned __int8 *v55; // [esp+38h] [ebp-1Ch] BYREF
  int v56; // [esp+3Ch] [ebp-18h]
  int v57; // [esp+40h] [ebp-14h]
  int v58; // [esp+44h] [ebp-10h]
  int v59; // [esp+48h] [ebp-Ch]
  _DWORD *v60; // [esp+4Ch] [ebp-8h]
  int v61; // [esp+50h] [ebp-4h]
  int v62; // [esp+5Ch] [ebp+8h]

  v2 = a1;
  v3 = a1[101];
  v49 = v3;
  if ( a1[63] && !*(_DWORD *)(v3 + 36) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 20);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 36) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = a1[5];
  v7 = a1[94];
  v60 = a1;
  v55 = *(unsigned __int8 **)v6;
  v8 = *(_DWORD *)(v6 + 4);
  v57 = v7;
  v56 = v8;
  v9 = *(_DWORD *)(v3 + 8);
  v10 = *(_DWORD *)(v3 + 12);
  v61 = v3 + 16;
  v51 = *(_DWORD *)(v3 + 20);
  v52 = *(_DWORD *)(v3 + 24);
  v11 = *(_DWORD *)(v3 + 28);
  v54 = *(_DWORD *)(v3 + 32);
  v12 = a1[79] <= 0;
  v53 = v11;
  v48 = 0;
  if ( v12 )
    goto LABEL_69;
  v46 = a1 + 80;
LABEL_10:
  v47 = *a2;
  v13 = v2[*v46 + 73];
  v50 = *v46;
  v14 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(v13 + 20) + 40);
  v15 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(v13 + 24) + 56);
  v62 = v15;
  if ( v10 < 8 )
  {
    if ( !sub_1003FE80(&v55, v9, v10, 0) )
      return 0;
    v10 = v59;
    v9 = v58;
    if ( v59 < 8 )
    {
      v16 = 1;
LABEL_17:
      v19 = sub_1003FF80((int)&v55, v9, v10, v14, v16);
      if ( v19 < 0 )
        return 0;
      v9 = v58;
      v10 = v59;
      goto LABEL_19;
    }
  }
  v17 = (unsigned __int8)(v9 >> (v10 - 8));
  v18 = *(_DWORD *)(v14 + 4 * v17 + 212);
  if ( !v18 )
  {
    v16 = 9;
    goto LABEL_17;
  }
  v10 -= v18;
  v19 = *(unsigned __int8 *)(v17 + v14 + 1236);
LABEL_19:
  if ( !v19 )
  {
LABEL_26:
    if ( *(_BYTE *)(v13 + 48) )
    {
      v21 = *(&v51 + v50) + v19;
      *(&v51 + v50) = v21;
      *v47 = v21;
      if ( *(int *)(v13 + 36) > 1 )
      {
        v22 = 1;
        while ( 1 )
        {
          if ( v10 < 8 )
          {
            if ( !sub_1003FE80(&v55, v9, v10, 0) )
              return 0;
            v10 = v59;
            v9 = v58;
            if ( v59 < 8 )
              break;
          }
          v24 = (unsigned __int8)(v9 >> (v10 - 8));
          v25 = *(_DWORD *)(v15 + 4 * v24 + 212);
          if ( !v25 )
          {
            v23 = 9;
            goto LABEL_36;
          }
          v10 -= v25;
          v26 = *(unsigned __int8 *)(v24 + v15 + 1236);
LABEL_38:
          v27 = v26 >> 4;
          v28 = v26 & 0xF;
          if ( v28 )
          {
            v29 = v27 + v22;
            if ( v10 < v28 )
            {
              if ( !sub_1003FE80(&v55, v9, v10, v28) )
                return 0;
              v9 = v58;
              v10 = v59;
            }
            v10 -= v28;
            v30 = (v9 >> v10) & ((1 << v28) - 1);
            if ( v30 >= dword_10050690[v28] )
              v28 = (v9 >> v10) & ((1 << v28) - 1);
            else
              LOWORD(v28) = v30 + dword_100506D0[v28];
            v15 = v62;
            v47[dword_10050550[v29]] = v28;
          }
          else
          {
            if ( v27 != 15 )
              goto LABEL_68;
            v29 = v22 + 15;
          }
          v22 = v29 + 1;
          if ( v22 >= 64 )
            goto LABEL_68;
        }
        v23 = 1;
LABEL_36:
        v26 = sub_1003FF80((int)&v55, v9, v10, v15, v23);
        if ( v26 < 0 )
          return 0;
        v9 = v58;
        v10 = v59;
        goto LABEL_38;
      }
    }
    v31 = 1;
    while ( 1 )
    {
      if ( v10 < 8 )
      {
        if ( !sub_1003FE80(&v55, v9, v10, 0) )
          return 0;
        v10 = v59;
        v9 = v58;
        if ( v59 < 8 )
          break;
      }
      v33 = (unsigned __int8)(v9 >> (v10 - 8));
      v34 = *(_DWORD *)(v15 + 4 * v33 + 212);
      if ( !v34 )
      {
        v32 = 9;
        goto LABEL_58;
      }
      v10 -= v34;
      v35 = *(unsigned __int8 *)(v33 + v15 + 1236);
LABEL_60:
      v36 = v35 >> 4;
      v37 = v35 & 0xF;
      if ( v37 )
      {
        v38 = v36 + v31;
        if ( v10 < v37 )
        {
          if ( !sub_1003FE80(&v55, v9, v10, v37) )
            return 0;
          v9 = v58;
          v10 = v59;
        }
        v10 -= v37;
      }
      else
      {
        if ( v36 != 15 )
          goto LABEL_68;
        v38 = v31 + 15;
      }
      v31 = v38 + 1;
      if ( v31 >= 64 )
      {
LABEL_68:
        ++v46;
        v3 = v49;
        v12 = ++v48 < a1[79];
        ++a2;
        v2 = a1;
        if ( !v12 )
        {
LABEL_69:
          *(_DWORD *)v2[5] = v55;
          *(_DWORD *)(v2[5] + 4) = v56;
          v39 = v51;
          v2[94] = v57;
          v40 = v53;
          *(_DWORD *)(v3 + 12) = v10;
          v41 = v52;
          *(_DWORD *)(v3 + 20) = v39;
          v42 = v54;
          *(_DWORD *)(v3 + 24) = v41;
          v43 = *(_DWORD *)(v3 + 36);
          *(_DWORD *)(v3 + 8) = v9;
          *(_DWORD *)(v3 + 28) = v40;
          *(_DWORD *)(v3 + 36) = v43 - 1;
          *(_DWORD *)(v3 + 32) = v42;
          return 1;
        }
        goto LABEL_10;
      }
    }
    v32 = 1;
LABEL_58:
    v35 = sub_1003FF80((int)&v55, v9, v10, v15, v32);
    if ( v35 < 0 )
      return 0;
    v9 = v58;
    v10 = v59;
    goto LABEL_60;
  }
  if ( v10 >= v19 )
  {
LABEL_23:
    v10 -= v19;
    v20 = (v9 >> v10) & ((1 << v19) - 1);
    if ( v20 >= dword_10050690[v19] )
      v19 = (v9 >> v10) & ((1 << v19) - 1);
    else
      v19 = v20 + dword_100506D0[v19];
    goto LABEL_26;
  }
  if ( sub_1003FE80(&v55, v9, v10, v19) )
  {
    v9 = v58;
    v10 = v59;
    goto LABEL_23;
  }
  return 0;
}

// sub_100406A0 @ 0x100406A0
int __cdecl sub_100406A0(int a1)
{
  _DWORD *v1; // eax
  int v2; // eax
  char *v3; // edx
  int result; // eax
  int i; // ebx
  void *v6; // edi

  v1 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 64);
  *(_DWORD *)(a1 + 404) = v1;
  *v1 = sub_10040710;
  v1 += 11;
  *v1 = 0;
  v1[1] = 0;
  v1[2] = 0;
  v1[3] = 0;
  v2 = (**(int (__cdecl ***)(int, int, _DWORD))(a1 + 4))(a1, 1, *(_DWORD *)(a1 + 32) << 8);
  *(_DWORD *)(a1 + 140) = v2;
  v3 = (char *)v2;
  result = *(_DWORD *)(a1 + 32);
  for ( i = 0; i < result; ++i )
  {
    v6 = v3;
    v3 += 256;
    memset(v6, 0xFFu, 0x100u);
    result = *(_DWORD *)(a1 + 32);
  }
  return result;
}

// sub_10040710 @ 0x10040710
int __cdecl sub_10040710(int *a1)
{
  int v2; // eax
  bool v3; // bl
  int v4; // edi
  char v5; // cl
  int v6; // edx
  int v7; // eax
  int v8; // ebx
  int *v9; // ebp
  int v10; // edi
  int *v11; // ebp
  bool v12; // cc
  int v13; // eax
  unsigned int v14; // edi
  unsigned int v15; // edi
  int result; // eax
  int v17; // [esp+10h] [ebp-10h]
  int v18; // [esp+14h] [ebp-Ch]
  int v19; // [esp+14h] [ebp-Ch]
  _DWORD *v20; // [esp+18h] [ebp-8h]
  int *v21; // [esp+18h] [ebp-8h]
  _DWORD *v22; // [esp+1Ch] [ebp-4h]
  bool v23; // [esp+24h] [ebp+4h]

  v2 = a1[90];
  v3 = v2 == 0;
  v4 = a1[101];
  v5 = 0;
  v17 = v4;
  v23 = v2 == 0;
  if ( v2 )
  {
    v6 = a1[91];
    if ( v2 > v6 || v6 >= 64 )
      v5 = 1;
    if ( a1[72] != 1 )
      goto LABEL_8;
  }
  else if ( a1[91] )
  {
LABEL_8:
    v5 = 1;
  }
  v7 = a1[92];
  if ( v7 && a1[93] != v7 - 1 )
    v5 = 1;
  if ( a1[93] > 13 || v5 )
  {
    *(_DWORD *)(*a1 + 20) = 14;
    *(_DWORD *)(*a1 + 24) = a1[90];
    *(_DWORD *)(*a1 + 28) = a1[91];
    *(_DWORD *)(*a1 + 32) = a1[92];
    *(_DWORD *)(*a1 + 36) = a1[93];
    (*(void (__cdecl **)(int *))*a1)(a1);
  }
  v18 = 0;
  if ( a1[72] > 0 )
  {
    v20 = a1 + 73;
    do
    {
      v8 = *(_DWORD *)(*v20 + 4);
      v9 = (int *)(a1[35] + (v8 << 8));
      if ( !v23 && *v9 < 0 )
      {
        *(_DWORD *)(*a1 + 20) = 111;
        *(_DWORD *)(*a1 + 24) = v8;
        *(_DWORD *)(*a1 + 28) = 0;
        (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
      }
      v10 = a1[90];
      if ( v10 <= a1[91] )
      {
        v11 = &v9[v10];
        do
        {
          if ( a1[92] != (*v11 < 0 ? 0 : *v11) )
          {
            *(_DWORD *)(*a1 + 20) = 111;
            *(_DWORD *)(*a1 + 24) = v8;
            *(_DWORD *)(*a1 + 28) = v10;
            (*(void (__cdecl **)(int *, int))(*a1 + 4))(a1, -1);
          }
          *v11 = a1[93];
          ++v10;
          ++v11;
        }
        while ( v10 <= a1[91] );
      }
      v12 = ++v18 < a1[72];
      ++v20;
    }
    while ( v12 );
    v4 = v17;
    v3 = v23;
  }
  if ( a1[92] )
  {
    if ( v3 )
      *(_DWORD *)(v4 + 4) = sub_10040F80;
    else
      *(_DWORD *)(v4 + 4) = sub_100410E0;
  }
  else if ( v3 )
  {
    *(_DWORD *)(v4 + 4) = sub_10040A10;
  }
  else
  {
    *(_DWORD *)(v4 + 4) = sub_10040CB0;
  }
  v19 = 0;
  if ( a1[72] > 0 )
  {
    v22 = (_DWORD *)(v4 + 24);
    v21 = a1 + 73;
    do
    {
      v13 = *v21;
      if ( v3 )
      {
        if ( !a1[92] )
        {
          v14 = *(_DWORD *)(v13 + 20);
          if ( v14 >= 4 || !a1[v14 + 40] )
          {
            *(_DWORD *)(*a1 + 20) = 49;
            *(_DWORD *)(*a1 + 24) = v14;
            (*(void (__cdecl **)(int *))*a1)(a1);
          }
          sub_1003FC90((int)a1, a1[v14 + 40], (_DWORD *)(v17 + 4 * v14 + 44));
          v4 = v17;
        }
      }
      else
      {
        v15 = *(_DWORD *)(v13 + 24);
        if ( v15 >= 4 || !a1[v15 + 44] )
        {
          *(_DWORD *)(*a1 + 20) = 49;
          *(_DWORD *)(*a1 + 24) = v15;
          (*(void (__cdecl **)(int *))*a1)(a1);
        }
        sub_1003FC90((int)a1, a1[v15 + 44], (_DWORD *)(v17 + 4 * v15 + 44));
        v3 = v23;
        *(_DWORD *)(v17 + 60) = *(_DWORD *)(v17 + 4 * v15 + 44);
        v4 = v17;
      }
      *v22++ = 0;
      ++v19;
      ++v21;
    }
    while ( v19 < a1[72] );
  }
  *(_DWORD *)(v4 + 12) = 0;
  *(_DWORD *)(v4 + 8) = 0;
  *(_BYTE *)(v4 + 16) = 0;
  *(_DWORD *)(v4 + 20) = 0;
  result = a1[63];
  *(_DWORD *)(v4 + 40) = result;
  return result;
}

// sub_10040A10 @ 0x10040A10
char __cdecl sub_10040A10(_DWORD *a1, _WORD **a2)
{
  int v3; // ebx
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // eax
  int v7; // edx
  int v8; // eax
  int v9; // eax
  int v10; // esi
  int v11; // ecx
  int v12; // edx
  int v13; // ecx
  int v14; // esi
  int v15; // edx
  _DWORD *v16; // ecx
  int v17; // esi
  bool v18; // cc
  int v19; // eax
  int *v21; // [esp+10h] [ebp-44h]
  int v22; // [esp+14h] [ebp-40h]
  int v23; // [esp+18h] [ebp-3Ch]
  int v24; // [esp+1Ch] [ebp-38h]
  _WORD *v25; // [esp+20h] [ebp-34h]
  _DWORD v26[5]; // [esp+24h] [ebp-30h] BYREF
  unsigned __int8 *v27; // [esp+38h] [ebp-1Ch] BYREF
  int v28; // [esp+3Ch] [ebp-18h]
  int v29; // [esp+40h] [ebp-14h]
  int v30; // [esp+44h] [ebp-10h]
  int v31; // [esp+48h] [ebp-Ch]
  _DWORD *v32; // [esp+4Ch] [ebp-8h]
  int v33; // [esp+50h] [ebp-4h]
  int v34; // [esp+58h] [ebp+4h]

  v3 = a1[101];
  v24 = a1[93];
  if ( a1[63] && !*(_DWORD *)(v3 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 24);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 40) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = a1[5];
  v32 = a1;
  v27 = *(unsigned __int8 **)v6;
  v7 = *(_DWORD *)(v6 + 4);
  v8 = a1[94];
  v28 = v7;
  v29 = v8;
  v9 = *(_DWORD *)(v3 + 12);
  v34 = *(_DWORD *)(v3 + 8);
  v33 = v3 + 16;
  qmemcpy(v26, (const void *)(v3 + 20), sizeof(v26));
  v22 = 0;
  if ( (int)a1[79] > 0 )
  {
    v21 = a1 + 80;
    while ( 1 )
    {
      v25 = *a2;
      v23 = *v21;
      v10 = *(_DWORD *)(v3 + 4 * *(_DWORD *)(a1[*v21 + 73] + 20) + 44);
      if ( v9 < 8 )
      {
        if ( !sub_1003FE80(&v27, v34, v9, 0) )
          return 0;
        v9 = v31;
        v34 = v30;
        if ( v31 < 8 )
          break;
      }
      v12 = (unsigned __int8)(v34 >> (v9 - 8));
      v13 = *(_DWORD *)(v10 + 4 * v12 + 212);
      if ( !v13 )
      {
        v11 = 9;
        goto LABEL_17;
      }
      v9 -= v13;
      v14 = *(unsigned __int8 *)(v12 + v10 + 1236);
LABEL_19:
      if ( v14 )
      {
        if ( v9 < v14 )
        {
          if ( !sub_1003FE80(&v27, v34, v9, v14) )
            return 0;
          v9 = v31;
          v34 = v30;
        }
        v9 -= v14;
        v15 = (v34 >> v9) & ((1 << v14) - 1);
        if ( v15 >= dword_10050710[v14] )
          v14 = (v34 >> v9) & ((1 << v14) - 1);
        else
          v14 = v15 + dword_10050750[v14];
      }
      v16 = &v26[v23 + 1];
      v17 = *v16 + v14;
      *v16 = v17;
      *v25 = v17 << v24;
      v18 = ++v22 < a1[79];
      ++a2;
      ++v21;
      if ( !v18 )
        goto LABEL_27;
    }
    v11 = 1;
LABEL_17:
    v14 = sub_1003FF80((int)&v27, v34, v9, v10, v11);
    if ( v14 < 0 )
      return 0;
    v9 = v31;
    v34 = v30;
    goto LABEL_19;
  }
LABEL_27:
  *(_DWORD *)a1[5] = v27;
  *(_DWORD *)(a1[5] + 4) = v28;
  a1[94] = v29;
  *(_DWORD *)(v3 + 8) = v34;
  *(_DWORD *)(v3 + 12) = v9;
  v19 = *(_DWORD *)(v3 + 40);
  qmemcpy((void *)(v3 + 20), v26, 0x14u);
  *(_DWORD *)(v3 + 40) = v19 - 1;
  return 1;
}

// sub_10040CB0 @ 0x10040CB0
char __cdecl sub_10040CB0(_DWORD *a1, int *a2)
{
  int v3; // esi
  int v4; // eax
  _DWORD *v5; // ecx
  int v6; // ecx
  int v8; // eax
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // ebp
  int v13; // ecx
  int v14; // edx
  int v15; // ecx
  int v16; // esi
  int v17; // ebp
  int v18; // esi
  int v19; // edx
  int v20; // esi
  int v21; // esi
  int v22; // eax
  int v23; // [esp+10h] [ebp-30h]
  int v24; // [esp+14h] [ebp-2Ch]
  int v25; // [esp+18h] [ebp-28h]
  int v26; // [esp+1Ch] [ebp-24h]
  int v27; // [esp+20h] [ebp-20h]
  unsigned __int8 *v28; // [esp+24h] [ebp-1Ch] BYREF
  int v29; // [esp+28h] [ebp-18h]
  int v30; // [esp+2Ch] [ebp-14h]
  int v31; // [esp+30h] [ebp-10h]
  int v32; // [esp+34h] [ebp-Ch]
  _DWORD *v33; // [esp+38h] [ebp-8h]
  int v34; // [esp+3Ch] [ebp-4h]
  int v35; // [esp+44h] [ebp+4h]
  int v36; // [esp+44h] [ebp+4h]
  int v37; // [esp+48h] [ebp+8h]

  v3 = a1[101];
  v24 = a1[91];
  v25 = v3;
  v26 = a1[93];
  if ( a1[63] && !*(_DWORD *)(v3 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v3 + 12) / 8;
    *(_DWORD *)(v3 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v4 = 0;
    if ( (int)a1[72] > 0 )
    {
      v5 = (_DWORD *)(v3 + 24);
      do
      {
        *v5 = 0;
        ++v4;
        ++v5;
      }
      while ( v4 < a1[72] );
    }
    *(_DWORD *)(v3 + 20) = 0;
    *(_DWORD *)(v3 + 40) = a1[63];
    *(_BYTE *)(v3 + 16) = 0;
  }
  v6 = *(_DWORD *)(v3 + 20);
  v23 = v6;
  if ( v6 )
  {
    --*(_DWORD *)(v3 + 40);
    *(_DWORD *)(v3 + 20) = v6 - 1;
    return 1;
  }
  v8 = a1[5];
  v33 = a1;
  v28 = *(unsigned __int8 **)v8;
  v9 = *(_DWORD *)(v8 + 4);
  v30 = a1[94];
  v29 = v9;
  v10 = *(_DWORD *)(v3 + 8);
  v11 = *(_DWORD *)(v3 + 12);
  v34 = v3 + 16;
  v12 = *(_DWORD *)(v3 + 60);
  v27 = *a2;
  v35 = a1[90];
  v37 = v12;
  if ( v35 > v24 )
    goto LABEL_42;
  while ( 1 )
  {
    if ( v11 >= 8 )
      goto LABEL_17;
    if ( !sub_1003FE80(&v28, v10, v11, 0) )
      return 0;
    v11 = v32;
    v10 = v31;
    if ( v32 >= 8 )
    {
LABEL_17:
      v14 = (unsigned __int8)(v10 >> (v11 - 8));
      v15 = *(_DWORD *)(v12 + 4 * v14 + 212);
      if ( v15 )
      {
        v11 -= v15;
        v16 = *(unsigned __int8 *)(v14 + v37 + 1236);
        goto LABEL_22;
      }
      v13 = 9;
    }
    else
    {
      v13 = 1;
    }
    v16 = sub_1003FF80((int)&v28, v10, v11, v12, v13);
    if ( v16 < 0 )
      return 0;
    v10 = v31;
    v11 = v32;
LABEL_22:
    v17 = v16 >> 4;
    v18 = v16 & 0xF;
    if ( !v18 )
      break;
    v36 = v17 + v35;
    if ( v11 < v18 )
    {
      if ( !sub_1003FE80(&v28, v10, v11, v18) )
        return 0;
      v10 = v31;
      v11 = v32;
    }
    v11 -= v18;
    v19 = (v10 >> v11) & ((1 << v18) - 1);
    if ( v19 >= dword_10050710[v18] )
      v20 = (v10 >> v11) & ((1 << v18) - 1);
    else
      v20 = v19 + dword_10050750[v18];
    *(_WORD *)(v27 + 2 * dword_10050550[v36]) = v20 << v26;
LABEL_32:
    v35 = v36 + 1;
    if ( v35 > v24 )
      goto LABEL_41;
    v12 = v37;
  }
  if ( v17 == 15 )
  {
    v36 = v35 + 15;
    goto LABEL_32;
  }
  v21 = 1 << v17;
  if ( v17 )
  {
    if ( v11 < v17 )
    {
      if ( !sub_1003FE80(&v28, v10, v11, v17) )
        return 0;
      v10 = v31;
      v11 = v32;
    }
    v11 -= v17;
    v21 += (v21 - 1) & (v10 >> v11);
  }
  v23 = v21 - 1;
LABEL_41:
  v3 = v25;
  v6 = v23;
LABEL_42:
  *(_DWORD *)a1[5] = v28;
  *(_DWORD *)(a1[5] + 4) = v29;
  a1[94] = v30;
  *(_DWORD *)(v3 + 12) = v11;
  v22 = *(_DWORD *)(v3 + 40);
  *(_DWORD *)(v3 + 8) = v10;
  *(_DWORD *)(v3 + 40) = v22 - 1;
  *(_DWORD *)(v3 + 20) = v6;
  return 1;
}

// sub_10040F80 @ 0x10040F80
char __cdecl sub_10040F80(_DWORD *a1, _WORD **a2)
{
  int v3; // ebx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // ecx
  int v9; // eax
  int v10; // ecx
  _WORD *v11; // ebp
  int v13; // [esp+10h] [ebp-20h]
  unsigned __int8 *v14; // [esp+14h] [ebp-1Ch] BYREF
  int v15; // [esp+18h] [ebp-18h]
  int v16; // [esp+1Ch] [ebp-14h]
  int v17; // [esp+20h] [ebp-10h]
  int v18; // [esp+24h] [ebp-Ch]
  _DWORD *v19; // [esp+28h] [ebp-8h]
  int v20; // [esp+2Ch] [ebp-4h]

  v3 = 0;
  v4 = a1[101];
  v13 = 1 << a1[93];
  if ( a1[63] && !*(_DWORD *)(v4 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v4 + 12) / 8;
    *(_DWORD *)(v4 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v5 = 0;
    if ( (int)a1[72] > 0 )
    {
      v6 = (_DWORD *)(v4 + 24);
      do
      {
        *v6 = 0;
        ++v5;
        ++v6;
      }
      while ( v5 < a1[72] );
    }
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 40) = a1[63];
    *(_BYTE *)(v4 + 16) = 0;
  }
  v7 = a1[5];
  v8 = a1[94];
  v19 = a1;
  v14 = *(unsigned __int8 **)v7;
  v15 = *(_DWORD *)(v7 + 4);
  v16 = v8;
  v9 = *(_DWORD *)(v4 + 8);
  v10 = *(_DWORD *)(v4 + 12);
  v20 = v4 + 16;
  if ( (int)a1[79] > 0 )
  {
    do
    {
      v11 = *a2;
      if ( v10 < 1 )
      {
        if ( !sub_1003FE80(&v14, v9, v10, 1) )
          return 0;
        v9 = v17;
        v10 = v18;
      }
      if ( ((v9 >> --v10) & 1) != 0 )
        *v11 |= v13;
      ++v3;
      ++a2;
    }
    while ( v3 < a1[79] );
  }
  *(_DWORD *)a1[5] = v14;
  *(_DWORD *)(a1[5] + 4) = v15;
  a1[94] = v16;
  *(_DWORD *)(v4 + 8) = v9;
  --*(_DWORD *)(v4 + 40);
  *(_DWORD *)(v4 + 12) = v10;
  return 1;
}

// sub_100410E0 @ 0x100410E0
char __cdecl sub_100410E0(_DWORD *a1, int *a2)
{
  _DWORD *v2; // ebx
  int v3; // ecx
  int v4; // edi
  int v5; // eax
  _DWORD *v6; // ecx
  int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // ebp
  int v11; // esi
  int v12; // ecx
  int v13; // eax
  int v14; // eax
  int v15; // ecx
  int v16; // ebx
  int v17; // ecx
  int v18; // ebx
  int v19; // edx
  __int16 *v20; // edi
  __int16 v21; // ax
  __int16 v22; // ax
  bool v23; // cc
  int v24; // eax
  int *v25; // ecx
  int v26; // edi
  __int16 *v27; // edi
  __int16 v28; // cx
  __int16 v29; // ax
  int v30; // eax
  int v32; // ecx
  _DWORD *v33; // eax
  int v34; // edx
  int *v35; // [esp+10h] [ebp-14Ch]
  int *v36; // [esp+10h] [ebp-14Ch]
  int v37; // [esp+14h] [ebp-148h]
  int v38; // [esp+18h] [ebp-144h]
  int v39; // [esp+1Ch] [ebp-140h]
  int v40; // [esp+20h] [ebp-13Ch]
  int v41; // [esp+24h] [ebp-138h]
  int v42; // [esp+28h] [ebp-134h]
  int v43; // [esp+2Ch] [ebp-130h]
  int v44; // [esp+30h] [ebp-12Ch]
  int v45; // [esp+34h] [ebp-128h]
  unsigned __int8 *v46; // [esp+38h] [ebp-124h] BYREF
  int v47; // [esp+3Ch] [ebp-120h]
  int v48; // [esp+40h] [ebp-11Ch]
  int v49; // [esp+44h] [ebp-118h]
  int v50; // [esp+48h] [ebp-114h]
  _DWORD *v51; // [esp+4Ch] [ebp-110h]
  int v52; // [esp+50h] [ebp-10Ch]
  int v53; // [esp+54h] [ebp-108h]
  int *v54; // [esp+58h] [ebp-104h]
  _DWORD v55[64]; // [esp+5Ch] [ebp-100h] BYREF

  v2 = a1;
  v3 = a1[93];
  v39 = a1[91];
  v4 = a1[101];
  v43 = 1 << v3;
  v42 = v4;
  v45 = -1 << v3;
  if ( a1[63] && !*(_DWORD *)(v4 + 40) )
  {
    *(_DWORD *)(a1[100] + 88) += *(_DWORD *)(v4 + 12) / 8;
    *(_DWORD *)(v4 + 12) = 0;
    if ( !(*(unsigned __int8 (__cdecl **)(_DWORD *))(a1[100] + 8))(a1) )
      return 0;
    v5 = 0;
    if ( (int)a1[72] > 0 )
    {
      v6 = (_DWORD *)(v4 + 24);
      do
      {
        *v6 = 0;
        ++v5;
        ++v6;
      }
      while ( v5 < a1[72] );
    }
    *(_DWORD *)(v4 + 20) = 0;
    *(_DWORD *)(v4 + 40) = a1[63];
    *(_BYTE *)(v4 + 16) = 0;
  }
  v7 = a1[5];
  v51 = a1;
  v46 = *(unsigned __int8 **)v7;
  v8 = *(_DWORD *)(v7 + 4);
  v9 = a1[94];
  v47 = v8;
  v48 = v9;
  v10 = *(_DWORD *)(v4 + 8);
  v11 = *(_DWORD *)(v4 + 12);
  v52 = v4 + 16;
  v41 = *a2;
  v12 = a1[90];
  v38 = *(_DWORD *)(v4 + 20);
  v53 = *(_DWORD *)(v4 + 60);
  v44 = 0;
  v37 = v12;
  if ( v38 )
  {
LABEL_55:
    if ( v38 )
    {
      if ( v37 <= v39 )
      {
        v36 = &dword_10050550[v37];
        do
        {
          v27 = (__int16 *)(v41 + 2 * *v36);
          if ( *v27 )
          {
            if ( v11 < 1 )
            {
              if ( !sub_1003FE80(&v46, v10, v11, 1) )
                goto LABEL_71;
              v10 = v49;
              v11 = v50;
            }
            if ( ((v10 >> --v11) & 1) != 0 )
            {
              v28 = v43;
              v29 = *v27;
              if ( (*v27 & v43) == 0 )
              {
                if ( v29 < 0 )
                  v28 = v45;
                *v27 = v28 + v29;
              }
            }
          }
          v23 = ++v37 <= v39;
          ++v36;
        }
        while ( v23 );
        v4 = v42;
      }
      --v38;
    }
    goto LABEL_70;
  }
  if ( v12 > v39 )
  {
LABEL_70:
    *(_DWORD *)v2[5] = v46;
    *(_DWORD *)(v2[5] + 4) = v47;
    v2[94] = v48;
    v30 = *(_DWORD *)(v4 + 40) - 1;
    *(_DWORD *)(v4 + 8) = v10;
    *(_DWORD *)(v4 + 12) = v11;
    *(_DWORD *)(v4 + 40) = v30;
    *(_DWORD *)(v4 + 20) = v38;
    return 1;
  }
  v54 = v55;
  while ( 1 )
  {
    if ( v11 >= 8 )
      goto LABEL_15;
    if ( !sub_1003FE80(&v46, v10, v11, 0) )
      goto LABEL_71;
    v11 = v50;
    v10 = v49;
    if ( v50 >= 8 )
    {
LABEL_15:
      v14 = (unsigned __int8)(v10 >> (v11 - 8));
      v15 = *(_DWORD *)(v53 + 4 * v14 + 212);
      if ( v15 )
      {
        v11 -= v15;
        v16 = *(unsigned __int8 *)(v14 + v53 + 1236);
        goto LABEL_20;
      }
      v13 = 9;
    }
    else
    {
      v13 = 1;
    }
    v16 = sub_1003FF80((int)&v46, v10, v11, v53, v13);
    if ( v16 < 0 )
      goto LABEL_71;
    v10 = v49;
    v11 = v50;
LABEL_20:
    v17 = v16 >> 4;
    v18 = v16 & 0xF;
    v40 = v17;
    if ( !v18 )
      break;
    if ( v18 != 1 )
    {
      *(_DWORD *)(*a1 + 20) = 114;
      (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, -1);
    }
    if ( v11 < 1 )
    {
      if ( !sub_1003FE80(&v46, v10, v11, 1) )
        goto LABEL_71;
      v10 = v49;
      v11 = v50;
    }
    --v11;
    v19 = v37;
    if ( ((v10 >> v11) & 1) != 0 )
      v18 = v43;
    else
      v18 = v45;
    v17 = v40;
    v35 = &dword_10050550[v37];
    while ( 1 )
    {
LABEL_33:
      v20 = (__int16 *)(v41 + 2 * *v35);
      if ( *v20 )
      {
        if ( v11 < 1 )
        {
          if ( !sub_1003FE80(&v46, v10, v11, 1) )
            goto LABEL_71;
          v10 = v49;
          v11 = v50;
        }
        if ( ((v10 >> --v11) & 1) != 0 )
        {
          v21 = *v20;
          if ( (*v20 & v43) == 0 )
          {
            if ( v21 < 0 )
              v22 = v45 + v21;
            else
              v22 = v43 + v21;
            *v20 = v22;
          }
        }
      }
      else
      {
        v40 = v17 - 1;
        if ( v17 - 1 < 0 )
          break;
      }
      v19 = v37 + 1;
      v23 = ++v37 <= v39;
      ++v35;
      if ( !v23 )
        break;
      v17 = v40;
    }
    if ( v18 )
    {
      v24 = dword_10050550[v19];
      *(_WORD *)(v41 + 2 * v24) = v18;
      v25 = v54;
      *v54 = v24;
      ++v44;
      v54 = v25 + 1;
    }
    v37 = v19 + 1;
    if ( v19 + 1 > v39 )
    {
      v2 = a1;
      v4 = v42;
      goto LABEL_70;
    }
  }
  if ( v17 == 15 )
  {
    v19 = v37;
    v35 = &dword_10050550[v37];
    goto LABEL_33;
  }
  v26 = 1 << v17;
  v38 = 1 << v17;
  if ( !v17 )
    goto LABEL_54;
  if ( v11 >= v17 )
    goto LABEL_53;
  if ( sub_1003FE80(&v46, v10, v11, v17) )
  {
    v10 = v49;
    v11 = v50;
LABEL_53:
    v11 -= v40;
    v38 += (v26 - 1) & (v10 >> v11);
LABEL_54:
    v2 = a1;
    v4 = v42;
    goto LABEL_55;
  }
LABEL_71:
  v32 = v44;
  if ( v44 > 0 )
  {
    v33 = &v55[v44];
    do
    {
      v34 = *--v33;
      --v32;
      *(_WORD *)(v41 + 2 * v34) = 0;
    }
    while ( v32 );
  }
  return 0;
}

// sub_10041590 @ 0x10041590
_DWORD *__cdecl sub_10041590(int a1)
{
  _DWORD *result; // eax
  int v3; // ebx
  _DWORD *v4; // ebp
  void *v5; // eax
  _DWORD *v6; // [esp+Ch] [ebp+4h]

  result = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 84);
  *(_DWORD *)(a1 + 408) = result;
  *result = sub_10041610;
  v3 = 0;
  if ( *(int *)(a1 + 32) > 0 )
  {
    v6 = (_DWORD *)(*(_DWORD *)(a1 + 196) + 80);
    v4 = result + 11;
    do
    {
      v5 = (void *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 256);
      *v6 = v5;
      memset(v5, 0, 0x100u);
      *v4 = -1;
      result = *(_DWORD **)(a1 + 32);
      ++v3;
      ++v4;
      v6 += 21;
    }
    while ( v3 < (int)result );
  }
  return result;
}

// sub_10041610 @ 0x10041610
int __cdecl sub_10041610(int *a1)
{
  int *v1; // edi
  int result; // eax
  int v3; // ebx
  int v4; // esi
  int *v5; // ebp
  int v6; // eax
  int v7; // eax
  char *v8; // edx
  int v9; // edi
  char *v10; // ebx
  double *v11; // esi
  int v12; // edx
  unsigned __int16 *v13; // ecx
  double *v14; // eax
  unsigned __int16 v15; // bp
  int v16; // ecx
  __int16 *v17; // eax
  int v18; // edx
  int v19; // ebp
  unsigned __int16 v20; // bx
  int v21; // ecx
  char *v22; // eax
  int v23; // edx
  unsigned __int16 v24; // bp
  bool v25; // cc
  int v26; // [esp+Ch] [ebp-18h]
  int (*v27)(); // [esp+10h] [ebp-14h]
  int v28; // [esp+14h] [ebp-10h]
  int v29; // [esp+18h] [ebp-Ch]
  int v30; // [esp+1Ch] [ebp-8h]

  v1 = a1;
  result = a1[102];
  v3 = 0;
  v26 = 0;
  v27 = 0;
  v28 = 0;
  if ( a1[8] > 0 )
  {
    v4 = a1[49] + 36;
    v5 = (int *)(result + 44);
    v30 = v4;
    v29 = result + 44;
    do
    {
      switch ( *(_DWORD *)v4 )
      {
        case 1:
          v3 = 0;
          v27 = sub_100463C0;
          v26 = 0;
          break;
        case 2:
          v3 = 0;
          v27 = (int (*)())sub_10046190;
          v26 = 0;
          break;
        case 4:
          v3 = 0;
          v27 = (int (*)())sub_10045D90;
          v26 = 0;
          break;
        case 8:
          v6 = v1[17];
          if ( v6 )
          {
            v7 = v6 - 1;
            if ( v7 )
            {
              if ( v7 == 1 )
              {
                v3 = 2;
                v27 = (int (*)())sub_10045930;
                v26 = 2;
              }
              else
              {
                *(_DWORD *)(*v1 + 20) = 47;
                (*(void (__cdecl **)(int *))*v1)(v1);
              }
            }
            else
            {
              v3 = 1;
              v27 = (int (*)())sub_100454A0;
              v26 = 1;
            }
          }
          else
          {
            v3 = 0;
            v27 = (int (*)())sub_10044E50;
            v26 = 0;
          }
          break;
        default:
          *(_DWORD *)(*v1 + 20) = 6;
          *(_DWORD *)(*v1 + 24) = *(_DWORD *)v4;
          (*(void (__cdecl **)(int *))*v1)(v1);
          break;
      }
      *(v5 - 10) = (int)v27;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( *v5 != v3 )
        {
          v8 = *(char **)(v4 + 40);
          if ( v8 )
          {
            *v5 = v3;
            if ( v3 )
            {
              if ( v3 == 1 )
              {
                v16 = *(_DWORD *)(v4 + 44);
                v17 = (__int16 *)&unk_10050790;
                v18 = v8 - (char *)&unk_10050790;
                do
                {
                  v19 = *v17;
                  v20 = *(__int16 *)((char *)v17++ + v18);
                  v16 += 4;
                  *(_DWORD *)(v16 - 4) = (v19 * v20 + 2048) >> 12;
                }
                while ( (int)v17 < (int)word_10050810 );
                v3 = v26;
              }
              else
              {
                v9 = *(_DWORD *)(v4 + 44);
                v10 = v8;
                v11 = (double *)word_10050810;
                do
                {
                  v12 = v9;
                  v13 = (unsigned __int16 *)v10;
                  v9 += 32;
                  v14 = (double *)word_10050810;
                  v10 += 16;
                  do
                  {
                    v15 = *v13;
                    ++v14;
                    ++v13;
                    v12 += 4;
                    *(float *)(v12 - 4) = (double)v15 * *(v14 - 1) * *v11;
                  }
                  while ( (int)v14 < (int)dbl_10050850 );
                  ++v11;
                }
                while ( (int)v11 < (int)dbl_10050850 );
                v4 = v30;
                v3 = v26;
                v1 = a1;
              }
            }
            else
            {
              v21 = *(_DWORD *)(v4 + 44);
              v22 = v8;
              v23 = 64;
              do
              {
                v24 = *(_WORD *)v22;
                v22 += 2;
                v21 += 4;
                --v23;
                *(_DWORD *)(v21 - 4) = v24;
              }
              while ( v23 );
            }
          }
        }
      }
      result = v28 + 1;
      v5 = (int *)(v29 + 4);
      v4 += 84;
      v25 = ++v28 < v1[8];
      v29 += 4;
      v30 = v4;
    }
    while ( v25 );
  }
  return result;
}

// sub_10041850 @ 0x10041850
char __cdecl sub_10041850(int a1, char a2)
{
  _DWORD *v2; // edi
  int v3; // eax
  int v4; // eax
  int v5; // ebp
  int v6; // eax
  int v8; // [esp-8h] [ebp-10h]

  v2 = (_DWORD *)(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 28);
  *(_DWORD *)(a1 + 392) = v2;
  *v2 = sub_100418E0;
  v2[2] = 0;
  v2[3] = 0;
  LOBYTE(v3) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v3 )
  {
    v4 = *(_DWORD *)(a1 + 272);
    v2[4] = v4;
    if ( a2 )
    {
      v5 = *(_DWORD *)(a1 + 4);
      v8 = v4;
      v6 = sub_1003E470(*(_DWORD *)(a1 + 96), v4);
      v3 = (*(int (__cdecl **)(int, int, _DWORD, int, int, int))(v5 + 16))(
             a1,
             1,
             0,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v6,
             v8);
      v2[2] = v3;
    }
    else
    {
      v3 = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(
             a1,
             1,
             *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100),
             v4);
      v2[3] = v3;
    }
  }
  return v3;
}

// sub_100418E0 @ 0x100418E0
int __cdecl sub_100418E0(int a1, int a2)
{
  int result; // eax
  _DWORD *v3; // esi
  int v4; // ecx

  result = a1;
  v3 = *(_DWORD **)(a1 + 392);
  if ( a2 )
  {
    if ( a2 == 2 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10041b00;
      v3[6] = 0;
      v3[5] = 0;
    }
    else if ( a2 == 3 )
    {
      if ( !v3[2] )
      {
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
        result = (**(int (__cdecl ***)(int))a1)(a1);
      }
      v3[1] = FUN_10041a60;
      v3[6] = 0;
      v3[5] = 0;
    }
    else
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 4;
      result = (**(int (__cdecl ***)(int))a1)(a1);
      v3[6] = 0;
      v3[5] = 0;
    }
  }
  else
  {
    if ( *(_BYTE *)(a1 + 74) )
    {
      v4 = v3[3];
      v3[1] = sub_100419E0;
      if ( !v4 )
      {
        result = (*(int (__cdecl **)(int, _DWORD, _DWORD, _DWORD, int))(*(_DWORD *)(a1 + 4) + 28))(
                   a1,
                   v3[2],
                   0,
                   v3[4],
                   1);
        v3[3] = result;
        v3[6] = 0;
        v3[5] = 0;
        return result;
      }
    }
    else
    {
      result = *(_DWORD *)(a1 + 412);
      v3[1] = *(_DWORD *)(result + 4);
    }
    v3[6] = 0;
    v3[5] = 0;
  }
  return result;
}

// sub_100419E0 @ 0x100419E0
int __cdecl sub_100419E0(int a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebx
  int v8; // esi
  int v9; // edi
  unsigned int v10; // eax
  int v11; // ecx
  int result; // eax

  v7 = a6;
  v8 = a1;
  v9 = *(_DWORD *)(a1 + 392);
  v10 = a7 - *a6;
  if ( v10 > *(_DWORD *)(v9 + 16) )
    v10 = *(_DWORD *)(v9 + 16);
  v11 = *(_DWORD *)(a1 + 412);
  a1 = 0;
  (*(void (__cdecl **)(int, int, int, int, _DWORD, int *, unsigned int))(v11 + 4))(
    v8,
    a2,
    a3,
    a4,
    *(_DWORD *)(v9 + 12),
    &a1,
    v10);
  (*(void (__cdecl **)(int, _DWORD, int, int))(*(_DWORD *)(v8 + 420) + 4))(v8, *(_DWORD *)(v9 + 12), a5 + 4 * *v7, a1);
  result = a1 + *v7;
  *v7 = result;
  return result;
}

// FUN_10041a60 @ 0x10041A60
// [binja] int32_t sub_10041a60(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, void** arg5)
unsigned int __cdecl sub_10041A60(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6)
{
  _DWORD *v7; // esi
  unsigned int *v8; // ebx
  unsigned int v9; // ebp
  unsigned int v10; // eax
  unsigned int result; // eax
  unsigned int v12; // [esp+10h] [ebp+4h]

  v7 = (_DWORD *)a1[98];
  v8 = v7 + 6;
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, int))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 1);
  v9 = *v8;
  (*(void (__cdecl **)(_DWORD *, int, int, int, _DWORD, _DWORD *, _DWORD))(a1[103] + 4))(
    a1,
    a2,
    a3,
    a4,
    v7[3],
    v7 + 6,
    v7[4]);
  v10 = *v8;
  if ( *v8 > v9 )
  {
    v12 = v10 - v9;
    (*(void (__cdecl **)(_DWORD *, unsigned int, _DWORD, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v9, 0, v10 - v9);
    *a6 += v12;
  }
  result = v7[4];
  if ( *v8 >= result )
  {
    v7[5] += result;
    *v8 = 0;
  }
  return result;
}

// FUN_10041b00 @ 0x10041B00
// [binja] int32_t sub_10041b00(void* arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
unsigned int __cdecl sub_10041B00(_DWORD *a1, int a2, int a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // esi
  unsigned int v8; // edi
  unsigned int result; // eax
  unsigned int v10; // ecx

  v7 = (_DWORD *)a1[98];
  if ( !v7[6] )
    v7[3] = (*(int (__cdecl **)(_DWORD *, _DWORD, _DWORD, _DWORD, _DWORD))(a1[1] + 28))(a1, v7[2], v7[5], v7[4], 0);
  v8 = v7[4] - v7[6];
  if ( v8 > a7 - *a6 )
    v8 = a7 - *a6;
  if ( v8 > a1[24] - v7[5] )
    v8 = a1[24] - v7[5];
  (*(void (__cdecl **)(_DWORD *, int, int, unsigned int))(a1[105] + 4))(a1, v7[3] + 4 * v7[6], a5 + 4 * *a6, v8);
  *a6 += v8;
  result = v7[4];
  v10 = v8 + v7[6];
  v7[6] = v10;
  if ( v10 >= result )
  {
    v7[5] += result;
    v7[6] = 0;
  }
  return result;
}

// sub_10041BA0 @ 0x10041BA0
int __cdecl sub_10041BA0(int a1)
{
  int v2; // ebp
  int result; // eax
  int v4; // ebx
  _DWORD *v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  int v9; // eax
  int v10; // edi
  int v11; // eax
  int v12; // [esp-8h] [ebp-28h]
  int v13; // [esp+10h] [ebp-10h]
  int v14; // [esp+14h] [ebp-Ch]
  int v15; // [esp+18h] [ebp-8h]
  char v16; // [esp+24h] [ebp+4h]

  v2 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 160);
  *(_DWORD *)(a1 + 412) = v2;
  *(_DWORD *)v2 = sub_10041DA0;
  *(_DWORD *)(v2 + 4) = sub_10041DC0;
  *(_BYTE *)(v2 + 8) = 0;
  v13 = v2;
  if ( *(_BYTE *)(a1 + 264) )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 23;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  if ( !*(_BYTE *)(a1 + 72) || (v16 = 1, *(int *)(a1 + 276) <= 1) )
    v16 = 0;
  result = *(_DWORD *)(a1 + 32);
  v14 = 0;
  if ( result > 0 )
  {
    v4 = *(_DWORD *)(a1 + 196) + 36;
    v5 = (_DWORD *)(v2 + 52);
    do
    {
      v6 = *(_DWORD *)(a1 + 276);
      v15 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 28) / v6;
      v7 = *(_DWORD *)(a1 + 272);
      v8 = *(_DWORD *)v4 * *(_DWORD *)(v4 - 24) / v6;
      v9 = *(_DWORD *)(a1 + 268);
      v5[12] = v8;
      if ( *(_BYTE *)(v4 + 12) )
      {
        if ( v15 != v9 || v8 != v7 )
        {
          if ( 2 * v15 == v9 )
          {
            if ( v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
                *v5 = sub_100420E0;
              else
                *v5 = sub_10041FF0;
LABEL_29:
              v10 = *(_DWORD *)(a1 + 4);
              v12 = *(_DWORD *)(a1 + 272);
              v11 = sub_1003E470(*(_DWORD *)(a1 + 92), *(_DWORD *)(a1 + 268));
              *(v5 - 10) = (*(int (__cdecl **)(int, int, int, int))(v10 + 8))(a1, 1, v11, v12);
              goto LABEL_30;
            }
            if ( 2 * v15 == v9 && 2 * v8 == v7 )
            {
              if ( v16 && *(_DWORD *)(v4 + 4) > 2u )
              {
                *v5 = sub_100421B0;
                *(_BYTE *)(v13 + 8) = 1;
              }
              else
              {
                *v5 = sub_10042050;
              }
              goto LABEL_29;
            }
          }
          if ( v9 % v15 || v7 % v8 )
          {
            *(_DWORD *)(*(_DWORD *)a1 + 20) = 37;
            (**(void (__cdecl ***)(int))a1)(a1);
          }
          else
          {
            *v5 = sub_10041ED0;
            *(_BYTE *)(v14 + v13 + 140) = v9 / v15;
            *(_BYTE *)(v14 + v13 + 150) = v7 / v8;
          }
          goto LABEL_29;
        }
        *v5 = sub_10041EB0;
      }
      else
      {
        *v5 = sub_10041EC0;
      }
LABEL_30:
      result = v14 + 1;
      ++v5;
      v4 += 84;
      ++v14;
    }
    while ( v14 < *(_DWORD *)(a1 + 32) );
  }
  return result;
}

// sub_10041DA0 @ 0x10041DA0
int __cdecl sub_10041DA0(_DWORD *a1)
{
  int v1; // ecx
  int result; // eax

  v1 = a1[103];
  *(_DWORD *)(v1 + 92) = a1[68];
  result = a1[24];
  *(_DWORD *)(v1 + 96) = result;
  return result;
}

// sub_10041DC0 @ 0x10041DC0
_DWORD *__cdecl sub_10041DC0(_DWORD *a1, _DWORD *a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  int v8; // ebx
  int v9; // eax
  int v11; // esi
  bool v12; // cc
  unsigned int v13; // esi
  signed int v14; // ecx
  _DWORD *result; // eax
  int v16; // [esp+10h] [ebp-4h]
  int v17; // [esp+18h] [ebp+4h]

  v8 = a1[103];
  if ( *(_DWORD *)(v8 + 92) >= a1[68] )
  {
    v9 = a1[8];
    v16 = 0;
    v17 = a1[49];
    if ( v9 > 0 )
    {
      v11 = v8 + 12;
      do
      {
        (*(void (__cdecl **)(_DWORD *, int, int, int))(v11 + 40))(a1, v17, *a2 + 4 * *a3 * *(_DWORD *)(v11 + 88), v11);
        v11 += 4;
        ++a2;
        v12 = ++v16 < a1[8];
        v17 += 84;
      }
      while ( v12 );
    }
    *(_DWORD *)(v8 + 92) = 0;
  }
  v13 = a1[68] - *(_DWORD *)(v8 + 92);
  if ( v13 > *(_DWORD *)(v8 + 96) )
    v13 = *(_DWORD *)(v8 + 96);
  if ( v13 > a7 - *a6 )
    v13 = a7 - *a6;
  (*(void (__cdecl **)(_DWORD *, int, _DWORD, int, unsigned int))(a1[104] + 4))(
    a1,
    v8 + 12,
    *(_DWORD *)(v8 + 92),
    a5 + 4 * *a6,
    v13);
  *a6 += v13;
  v14 = v13 + *(_DWORD *)(v8 + 92);
  *(_DWORD *)(v8 + 96) -= v13;
  *(_DWORD *)(v8 + 92) = v14;
  result = (_DWORD *)a1[68];
  if ( v14 >= (int)result )
  {
    ++*a3;
    return a3;
  }
  return result;
}

// sub_10041EB0 @ 0x10041EB0
_DWORD *__cdecl sub_10041EB0(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = a3;
  return a4;
}

// sub_10041EC0 @ 0x10041EC0
_DWORD *__cdecl sub_10041EC0(int a1, int a2, int a3, _DWORD *a4)
{
  *a4 = 0;
  return a4;
}

// sub_10041ED0 @ 0x10041ED0
int __cdecl sub_10041ED0(int a1, int a2, char **a3, int *a4)
{
  int v4; // ebx
  int v5; // eax
  int v6; // edi
  int v7; // edx
  int result; // eax
  char *v9; // esi
  char *v10; // ecx
  unsigned int v11; // ebp
  char v12; // al
  int v13; // eax
  void **v14; // [esp+Ch] [ebp-10h]
  int v15; // [esp+10h] [ebp-Ch]
  int v16; // [esp+14h] [ebp-8h]
  int v17; // [esp+18h] [ebp-4h]
  int v18; // [esp+24h] [ebp+8h]

  v4 = a1;
  v5 = *(_DWORD *)(a2 + 4) + *(_DWORD *)(a1 + 412);
  v17 = *a4;
  v6 = *(unsigned __int8 *)(v5 + 140);
  v7 = *(unsigned __int8 *)(v5 + 150);
  result = 0;
  v16 = v6;
  v18 = 0;
  v15 = v7;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v14 = (void **)*a4;
    do
    {
      v9 = (char *)*v14;
      v10 = *a3;
      v11 = (unsigned int)*v14 + *(_DWORD *)(v4 + 92);
      if ( (unsigned int)*v14 < v11 )
      {
        do
        {
          v12 = *v10++;
          if ( v6 > 0 )
          {
            LOBYTE(v4) = v12;
            BYTE1(v4) = v12;
            v13 = v4 << 16;
            LOWORD(v13) = v4;
            v4 = a1;
            memset32(v9, v13, (unsigned int)v6 >> 2);
            v7 = v15;
            memset(&v9[4 * ((unsigned int)v6 >> 2)], v13, v6 & 3);
            v6 = v16;
            v9 += v16;
          }
        }
        while ( (unsigned int)v9 < v11 );
        result = v18;
      }
      if ( v7 > 1 )
      {
        sub_1003E490(v17, result, v17, result + 1, v7 - 1, *(_DWORD *)(v4 + 92));
        v7 = v15;
        result = v18;
      }
      ++a3;
      result += v7;
      v18 = result;
      v14 += v7;
    }
    while ( result < *(_DWORD *)(v4 + 272) );
  }
  return result;
}

// sub_10041FF0 @ 0x10041FF0
int __cdecl sub_10041FF0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v4; // edi
  int result; // eax
  int v6; // ebp
  _BYTE *v7; // eax
  char *v8; // esi
  unsigned int v9; // ecx
  char v10; // dl
  _BYTE *v11; // eax
  int v12; // [esp+18h] [ebp+10h]

  v4 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v12 = 0;
  if ( result > 0 )
  {
    v6 = a3 - (_DWORD)v4;
    do
    {
      v7 = *v4;
      v8 = *(_BYTE **)((char *)v4 + v6);
      v9 = (unsigned int)&(*v4)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v4 < v9 )
      {
        do
        {
          v10 = *v8++;
          *v7 = v10;
          v11 = v7 + 1;
          *v11 = v10;
          v7 = v11 + 1;
        }
        while ( (unsigned int)v7 < v9 );
      }
      result = v12 + 1;
      ++v4;
      ++v12;
    }
    while ( v12 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_10042050 @ 0x10042050
int __cdecl sub_10042050(int a1, int a2, char **a3, int *a4)
{
  int v5; // ebp
  int result; // eax
  int v7; // esi
  _BYTE *v8; // eax
  char *v9; // edi
  unsigned int v10; // ecx
  char v11; // dl
  _BYTE *v12; // eax
  _BYTE **v13; // [esp+10h] [ebp+4h]

  v5 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v7 = 0;
  if ( result > 0 )
  {
    v13 = (_BYTE **)*a4;
    do
    {
      v8 = *v13;
      v9 = *a3;
      v10 = (unsigned int)&(*v13)[*(_DWORD *)(a1 + 92)];
      if ( (unsigned int)*v13 < v10 )
      {
        do
        {
          v11 = *v9++;
          *v8 = v11;
          v12 = v8 + 1;
          *v12 = v11;
          v8 = v12 + 1;
        }
        while ( (unsigned int)v8 < v10 );
      }
      sub_1003E490(v5, v7, v5, v7 + 1, 1, *(_DWORD *)(a1 + 92));
      result = *(_DWORD *)(a1 + 272);
      v7 += 2;
      ++a3;
      v13 += 2;
    }
    while ( v7 < result );
  }
  return result;
}

// sub_100420E0 @ 0x100420E0
int __cdecl sub_100420E0(int a1, int a2, int a3, _BYTE ***a4)
{
  _BYTE **v4; // edi
  int result; // eax
  int v6; // esi
  unsigned __int8 *v7; // ecx
  _BYTE *v8; // eax
  int v9; // edx
  unsigned __int8 *v10; // ecx
  _BYTE *v11; // eax
  int v12; // ebp
  int v13; // edx
  _BYTE *v14; // eax
  int v15; // edx
  int v16; // [esp+10h] [ebp+Ch]
  int v17; // [esp+14h] [ebp+10h]

  v4 = *a4;
  result = *(_DWORD *)(a1 + 272);
  v17 = 0;
  if ( result > 0 )
  {
    v6 = a3 - (_DWORD)v4;
    v16 = a3 - (_DWORD)v4;
    do
    {
      v7 = *(_BYTE **)((char *)v4 + v6);
      v8 = *v4;
      v9 = *v7;
      *v8 = v9;
      v10 = v7 + 1;
      *++v8 = (3 * v9 + *v10 + 2) >> 2;
      v11 = v8 + 1;
      if ( *(_DWORD *)(a2 + 40) != 2 )
      {
        v12 = *(_DWORD *)(a2 + 40) - 2;
        do
        {
          v13 = *v10++;
          *v11 = (*(v10 - 2) + 3 * v13 + 1) >> 2;
          v14 = v11 + 1;
          *v14 = (*v10 + 3 * v13 + 2) >> 2;
          v11 = v14 + 1;
          --v12;
        }
        while ( v12 );
        v6 = v16;
      }
      v15 = *v10;
      ++v4;
      *v11 = (*(v10 - 1) + 3 * v15 + 1) >> 2;
      v11[1] = v15;
      result = ++v17;
    }
    while ( v17 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_100421B0 @ 0x100421B0
int __cdecl sub_100421B0(int a1, int a2, int a3, int *a4)
{
  int result; // eax
  int v5; // esi
  int v6; // edi
  int v7; // ecx
  _BYTE **i; // eax
  unsigned __int8 *v9; // ebp
  unsigned __int8 *v10; // edi
  _BYTE *v11; // ecx
  int v12; // esi
  int v13; // eax
  unsigned __int8 *v14; // edi
  unsigned __int8 *v15; // ebp
  _BYTE *v16; // ecx
  int v17; // edx
  int v18; // esi
  _BYTE *v19; // ecx
  int v20; // [esp+4h] [ebp-14h]
  int v21; // [esp+8h] [ebp-10h]
  int v22; // [esp+Ch] [ebp-Ch]
  int v23; // [esp+10h] [ebp-8h]
  _BYTE **v24; // [esp+14h] [ebp-4h]
  int v25; // [esp+28h] [ebp+10h]

  v23 = *a4;
  result = 0;
  v5 = 0;
  v20 = 0;
  v25 = 0;
  if ( *(int *)(a1 + 272) > 0 )
  {
    v6 = a3;
    do
    {
      v7 = 0;
      v22 = 0;
      for ( i = (_BYTE **)(v23 + 4 * result); ; i = v24 )
      {
        v9 = *(unsigned __int8 **)(v6 + 4 * v5);
        v10 = v7 ? *(unsigned __int8 **)(v6 + 4 * v5 + 4) : *(unsigned __int8 **)(v6 + 4 * v5 - 4);
        v11 = *i;
        v24 = i + 1;
        ++v20;
        v12 = *v10 + 3 * *v9;
        v13 = v10[1] + 3 * v9[1];
        *v11 = (4 * v12 + 8) >> 4;
        v14 = v10 + 2;
        v15 = v9 + 2;
        *++v11 = (v12 + v13 + 2 * v12 + 7) >> 4;
        v16 = v11 + 1;
        v17 = v12;
        v18 = v13;
        if ( *(_DWORD *)(a2 + 40) == 2 )
        {
          v5 = v25;
          v6 = a3;
        }
        else
        {
          v21 = *(_DWORD *)(a2 + 40) - 2;
          do
          {
            v13 = *v14 + 3 * *v15;
            *v16 = (3 * v18 + v17 + 8) >> 4;
            ++v14;
            ++v15;
            v19 = v16 + 1;
            *v19 = (3 * v18 + v13 + 7) >> 4;
            v16 = v19 + 1;
            v17 = v18;
            v18 = v13;
            --v21;
          }
          while ( v21 );
          v6 = a3;
          v5 = v25;
        }
        *v16 = (v13 + v17 + 2 * v13 + 8) >> 4;
        v16[1] = (4 * v13 + 7) >> 4;
        v7 = ++v22;
        if ( v22 >= 2 )
          break;
      }
      result = v20;
      v25 = ++v5;
    }
    while ( v20 < *(_DWORD *)(a1 + 272) );
  }
  return result;
}

// sub_10042310 @ 0x10042310
char __cdecl sub_10042310(int a1)
{
  void (**v1)(); // edi
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ecx
  int v7; // eax

  v1 = (void (**)())(**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 24);
  *(_DWORD *)(a1 + 416) = v1;
  *v1 = nullsub_4;
  switch ( *(_DWORD *)(a1 + 36) )
  {
    case 1:
      if ( *(_DWORD *)(a1 + 32) != 1 )
        goto LABEL_9;
      break;
    case 2:
    case 3:
      if ( *(_DWORD *)(a1 + 32) != 3 )
        goto LABEL_9;
      break;
    case 4:
    case 5:
      if ( *(_DWORD *)(a1 + 32) != 4 )
        goto LABEL_9;
      break;
    default:
      if ( *(int *)(a1 + 32) < 1 )
      {
LABEL_9:
        *(_DWORD *)(*(_DWORD *)a1 + 20) = 8;
        (**(void (__cdecl ***)(int))a1)(a1);
      }
      break;
  }
  if ( *(_DWORD *)(a1 + 40) != 1 )
  {
    if ( *(_DWORD *)(a1 + 40) == 2 )
    {
      v3 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 3;
      if ( v3 == 3 )
      {
        v1[1] = (void (*)())sub_10042590;
        sub_100424D0(a1);
        goto LABEL_31;
      }
      if ( v3 == 2 )
      {
        v1[1] = (void (*)())sub_100426C0;
        goto LABEL_31;
      }
    }
    else if ( *(_DWORD *)(a1 + 40) == 4 )
    {
      v2 = *(_DWORD *)(a1 + 36);
      *(_DWORD *)(a1 + 100) = 4;
      if ( v2 == 5 )
      {
        v1[1] = (void (*)())sub_10042780;
        sub_100424D0(a1);
        goto LABEL_31;
      }
      if ( v2 == 4 )
      {
        v1[1] = (void (*)())sub_100426C0;
        goto LABEL_31;
      }
    }
    else if ( *(_DWORD *)(a1 + 40) == *(_DWORD *)(a1 + 36) )
    {
      *(_DWORD *)(a1 + 100) = *(_DWORD *)(a1 + 32);
      v1[1] = (void (*)())sub_100426C0;
      goto LABEL_31;
    }
    goto LABEL_27;
  }
  v4 = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a1 + 100) = 1;
  if ( v4 != 1 && v4 != 3 )
  {
LABEL_27:
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 25;
    (**(void (__cdecl ***)(int))a1)(a1);
    goto LABEL_31;
  }
  v1[1] = (void (*)())sub_10042750;
  v5 = 1;
  if ( *(int *)(a1 + 32) > 1 )
  {
    v6 = 84;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 196) + v6 + 48) = 0;
      ++v5;
      v6 += 84;
    }
    while ( v5 < *(_DWORD *)(a1 + 32) );
  }
LABEL_31:
  LOBYTE(v7) = *(_BYTE *)(a1 + 74);
  if ( (_BYTE)v7 )
  {
    *(_DWORD *)(a1 + 104) = 1;
  }
  else
  {
    v7 = *(_DWORD *)(a1 + 100);
    *(_DWORD *)(a1 + 104) = v7;
  }
  return v7;
}

// sub_100424D0 @ 0x100424D0
int __cdecl sub_100424D0(int a1)
{
  _DWORD *v1; // esi
  int result; // eax
  int v3; // edi
  int v4; // edx
  int v5; // ecx
  int v6; // [esp+14h] [ebp+4h]

  v1 = *(_DWORD **)(a1 + 416);
  v1[2] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[3] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v1[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v6 = 5990656;
  v3 = -14831872;
  v4 = -11728000;
  v5 = 2919680;
  do
  {
    *(_DWORD *)(result + v1[2]) = v4 >> 16;
    *(_DWORD *)(result + v1[3]) = v3 >> 16;
    *(_DWORD *)(result + v1[4]) = v6;
    *(_DWORD *)(result + v1[5]) = v5;
    v5 -= 22554;
    v4 += 91881;
    v3 += 116130;
    result += 4;
    v6 -= 46802;
  }
  while ( v5 >= -2831590 );
  return result;
}

// sub_10042590 @ 0x10042590
unsigned __int8 *__cdecl sub_10042590(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned __int8 *result; // eax
  _DWORD *v9; // esi
  int v10; // edi
  int v11; // ebp
  int v12; // ecx
  int v13; // esi
  int v14; // ebp
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // [esp+0h] [ebp-20h]
  int v19; // [esp+4h] [ebp-1Ch]
  int v20; // [esp+8h] [ebp-18h]
  int v21; // [esp+Ch] [ebp-14h]
  int v22; // [esp+10h] [ebp-10h]
  int v23; // [esp+14h] [ebp-Ch]
  int v24; // [esp+18h] [ebp-8h]
  int v25; // [esp+1Ch] [ebp-4h]
  int v26; // [esp+24h] [ebp+4h]
  int v27; // [esp+24h] [ebp+4h]
  int v28; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[104];
  v18 = a1[23];
  v6 = a1[71];
  v20 = v5[2];
  v24 = v5[3];
  v7 = v5[4];
  v21 = v5[5];
  result = (unsigned __int8 *)(a5 - 1);
  v23 = v6;
  v22 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = a2;
    v10 = 4 * a3;
    do
    {
      v11 = *(_DWORD *)(*v9 + v10);
      result = *(unsigned __int8 **)(v10 + v9[1]);
      v26 = *(_DWORD *)(v9[2] + v10);
      v12 = *a4++;
      v10 += 4;
      v25 = v10;
      if ( v18 )
      {
        v13 = v11 - (_DWORD)result;
        v14 = v26 - (_DWORD)result;
        v28 = v13;
        v19 = v26 - (_DWORD)result;
        v27 = v18;
        while ( 1 )
        {
          v12 += 3;
          v15 = result[v13];
          v16 = *result;
          v17 = result[v14];
          *(_BYTE *)(v12 - 3) = *(_BYTE *)(v15 + *(_DWORD *)(v20 + 4 * v17) + v6);
          v6 = v23;
          *(_BYTE *)(v12 - 2) = *(_BYTE *)(v15 + ((*(_DWORD *)(v22 + 4 * v17) + *(_DWORD *)(v21 + 4 * v16)) >> 16) + v23);
          *(_BYTE *)(v12 - 1) = *(_BYTE *)(v15 + *(_DWORD *)(v24 + 4 * v16) + v23);
          ++result;
          if ( !--v27 )
            break;
          v13 = v28;
          v14 = v19;
        }
        v9 = a2;
        v10 = v25;
      }
      --a5;
    }
    while ( a5 );
  }
  return result;
}

// sub_100426C0 @ 0x100426C0
int __cdecl sub_100426C0(int a1, _DWORD *a2, int a3, _DWORD *a4, int a5)
{
  int v5; // edx
  int v6; // edi
  int result; // eax
  int v8; // esi
  _DWORD *v9; // ebp
  _BYTE *v10; // ecx
  _BYTE *v11; // eax
  bool v12; // zf
  int v13; // [esp+4h] [ebp-4h]
  int v14; // [esp+Ch] [ebp+4h]

  v5 = *(_DWORD *)(a1 + 32);
  v6 = *(_DWORD *)(a1 + 92);
  result = a5 - 1;
  v13 = v6;
  if ( a5 - 1 >= 0 )
  {
    v14 = 4 * a3;
    do
    {
      v8 = 0;
      if ( v5 > 0 )
      {
        v9 = a2;
        do
        {
          v10 = *(_BYTE **)(*v9 + v14);
          v11 = (_BYTE *)(v8 + *a4);
          if ( v6 )
          {
            do
            {
              *v11 = *v10++;
              v11 += v5;
              --v6;
            }
            while ( v6 );
            v6 = v13;
          }
          ++v8;
          ++v9;
        }
        while ( v8 < v5 );
      }
      result = a5 - 1;
      v12 = a5 == 1;
      v14 += 4;
      ++a4;
      --a5;
    }
    while ( !v12 );
  }
  return result;
}

// sub_10042750 @ 0x10042750
const void **__cdecl sub_10042750(int a1, int *a2, int a3, int a4, int a5)
{
  return sub_1003E490(*a2, a3, a4, 0, a5, *(_DWORD *)(a1 + 92));
}

// sub_10042780 @ 0x10042780
unsigned __int8 *__cdecl sub_10042780(_DWORD *a1, _DWORD *a2, int a3, int *a4, int a5)
{
  _DWORD *v5; // eax
  int v6; // edx
  int v7; // ecx
  unsigned __int8 *result; // eax
  _DWORD *v9; // edi
  int v10; // esi
  int v11; // ebp
  int v12; // ecx
  int v13; // esi
  int v14; // ebp
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // [esp+0h] [ebp-24h]
  int v19; // [esp+4h] [ebp-20h]
  int v20; // [esp+8h] [ebp-1Ch]
  int v21; // [esp+Ch] [ebp-18h]
  int v22; // [esp+10h] [ebp-14h]
  int v23; // [esp+14h] [ebp-10h]
  int v24; // [esp+18h] [ebp-Ch]
  int v25; // [esp+1Ch] [ebp-8h]
  int v26; // [esp+20h] [ebp-4h]
  int v27; // [esp+28h] [ebp+4h]
  int v28; // [esp+28h] [ebp+4h]
  int v29; // [esp+30h] [ebp+Ch]
  int v30; // [esp+30h] [ebp+Ch]

  v5 = (_DWORD *)a1[104];
  v18 = a1[23];
  v6 = a1[71];
  v21 = v5[2];
  v25 = v5[3];
  v7 = v5[4];
  v22 = v5[5];
  result = (unsigned __int8 *)(a5 - 1);
  v24 = v6;
  v23 = v7;
  if ( a5 - 1 >= 0 )
  {
    v9 = a2;
    v10 = 4 * a3;
    do
    {
      v11 = *(_DWORD *)(*v9 + v10);
      result = *(unsigned __int8 **)(v10 + v9[1]);
      v27 = *(_DWORD *)(v9[2] + v10);
      v29 = *(_DWORD *)(v10 + v9[3]);
      v12 = *a4++;
      v10 += 4;
      v26 = v10;
      if ( v18 )
      {
        v13 = v11 - (_DWORD)result;
        v14 = v27 - (_DWORD)result;
        v19 = v13;
        v20 = v27 - (_DWORD)result;
        v30 = v29 - (_DWORD)result;
        v28 = v18;
        while ( 1 )
        {
          v12 += 4;
          v15 = result[v13];
          v16 = *result;
          v17 = result[v14];
          *(_BYTE *)(v12 - 4) = *(_BYTE *)(v6 - *(_DWORD *)(v21 + 4 * v17) - v15 + 255);
          v6 = v24;
          *(_BYTE *)(v12 - 3) = *(_BYTE *)(v24
                                         - ((*(_DWORD *)(v23 + 4 * v17) + *(_DWORD *)(v22 + 4 * v16)) >> 16)
                                         - v15
                                         + 255);
          *(_BYTE *)(v12 - 2) = *(_BYTE *)(v24 - *(_DWORD *)(v25 + 4 * v16) - v15 + 255);
          *(_BYTE *)(v12 - 1) = (result++)[v30];
          if ( !--v28 )
            break;
          v13 = v19;
          v14 = v20;
        }
        v9 = a2;
        v10 = v26;
      }
      --a5;
    }
    while ( a5 );
  }
  return result;
}

// sub_100428E0 @ 0x100428E0
int __cdecl sub_100428E0(int a1)
{
  int v1; // esi
  int v2; // ecx
  _DWORD *v3; // esi
  int result; // eax
  int v5; // edi
  int v6; // edx
  int v7; // ecx
  int v8; // [esp+14h] [ebp+4h]

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 48);
  *(_DWORD *)(a1 + 412) = v1;
  *(_DWORD *)v1 = sub_10042A10;
  *(_BYTE *)(v1 + 8) = 0;
  v2 = *(_DWORD *)(a1 + 92) * *(_DWORD *)(a1 + 100);
  *(_DWORD *)(v1 + 40) = v2;
  if ( *(_DWORD *)(a1 + 272) == 2 )
  {
    *(_DWORD *)(v1 + 4) = sub_10042A30;
    *(_DWORD *)(v1 + 12) = sub_10042C90;
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, v2);
  }
  else
  {
    *(_DWORD *)(v1 + 4) = sub_10042B00;
    *(_DWORD *)(v1 + 12) = sub_10042B40;
    *(_DWORD *)(v1 + 32) = 0;
  }
  v3 = *(_DWORD **)(a1 + 412);
  v3[4] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[5] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[6] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  v3[7] = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 1024);
  result = 0;
  v8 = 5990656;
  v5 = -14831872;
  v6 = -11728000;
  v7 = 2919680;
  do
  {
    *(_DWORD *)(result + v3[4]) = v6 >> 16;
    *(_DWORD *)(result + v3[5]) = v5 >> 16;
    *(_DWORD *)(result + v3[6]) = v8;
    *(_DWORD *)(result + v3[7]) = v7;
    v7 -= 22554;
    v6 += 91881;
    v5 += 116130;
    result += 4;
    v8 -= 46802;
  }
  while ( v7 >= -2831590 );
  return result;
}

// sub_10042A10 @ 0x10042A10
int __cdecl sub_10042A10(int a1)
{
  int result; // eax

  result = *(_DWORD *)(a1 + 412);
  *(_BYTE *)(result + 36) = 0;
  *(_DWORD *)(result + 44) = *(_DWORD *)(a1 + 96);
  return result;
}

// sub_10042A30 @ 0x10042A30
char __cdecl sub_10042A30(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6, int a7)
{
  _DWORD *v7; // ebp
  int v8; // esi
  _DWORD *v9; // ebx
  unsigned int v10; // edi
  int v11; // eax
  char result; // al
  int v13; // [esp+10h] [ebp-8h] BYREF
  int v14; // [esp+14h] [ebp-4h]

  v7 = a3;
  v8 = *(_DWORD *)(a1 + 412);
  if ( *(_BYTE *)(v8 + 36) )
  {
    v9 = a6;
    sub_1003E490(v8 + 32, 0, a5 + 4 * *a6, 0, 1, *(_DWORD *)(v8 + 40));
    v10 = 1;
    *(_BYTE *)(v8 + 36) = 0;
  }
  else
  {
    v10 = 2;
    if ( *(_DWORD *)(v8 + 44) < 2u )
      v10 = *(_DWORD *)(v8 + 44);
    v9 = a6;
    v11 = *a6;
    if ( v10 > a7 - *a6 )
      v10 = a7 - *a6;
    v13 = *(_DWORD *)(a5 + 4 * v11);
    if ( v10 <= 1 )
    {
      v14 = *(_DWORD *)(v8 + 32);
      *(_BYTE *)(v8 + 36) = 1;
    }
    else
    {
      v14 = *(_DWORD *)(a5 + 4 * v11 + 4);
    }
    v7 = a3;
    (*(void (__cdecl **)(int, int, _DWORD, int *))(v8 + 12))(a1, a2, *a3, &v13);
  }
  *v9 += v10;
  result = *(_BYTE *)(v8 + 36);
  *(_DWORD *)(v8 + 44) -= v10;
  if ( !result )
    ++*v7;
  return result;
}

// sub_10042B00 @ 0x10042B00
int __cdecl sub_10042B00(int a1, int a2, _DWORD *a3, int a4, int a5, _DWORD *a6)
{
  int result; // eax

  result = (*(int (__cdecl **)(int, int, _DWORD, int))(*(_DWORD *)(a1 + 412) + 12))(a1, a2, *a3, a5 + 4 * *a6);
  ++*a6;
  ++*a3;
  return result;
}

// sub_10042B40 @ 0x10042B40
_BYTE *__cdecl sub_10042B40(_DWORD *a1, _DWORD *a2, int a3, _BYTE **a4)
{
  _DWORD *v4; // ebp
  _DWORD *v5; // eax
  int v6; // ecx
  unsigned __int8 *v7; // edi
  unsigned __int8 *v8; // ebx
  unsigned __int8 *v9; // esi
  _BYTE *result; // eax
  int v11; // ebp
  int v12; // edx
  int v13; // esi
  int v14; // edx
  int v15; // ebx
  unsigned __int8 *v16; // edi
  int v17; // ebx
  int v18; // ebp
  int v19; // ebp
  int v20; // esi
  int v21; // edx
  int v22; // ebp
  int v23; // esi
  int v24; // edi
  unsigned __int8 *v25; // [esp+10h] [ebp-14h]
  int v26; // [esp+14h] [ebp-10h]
  int v27; // [esp+18h] [ebp-Ch]
  int v28; // [esp+1Ch] [ebp-8h]
  int v29; // [esp+20h] [ebp-4h]
  int v30; // [esp+2Ch] [ebp+8h]
  int v31; // [esp+30h] [ebp+Ch]
  unsigned __int8 *v32; // [esp+34h] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[103];
  v6 = a1[71];
  v29 = v5[4];
  v28 = v5[5];
  v27 = v5[6];
  v26 = v5[7];
  v7 = *(unsigned __int8 **)(*a2 + 4 * a3);
  v8 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  v9 = *(unsigned __int8 **)(a2[1] + 4 * a3);
  result = *a4;
  if ( a1[23] >> 1 )
  {
    v30 = a1[23] >> 1;
    do
    {
      v25 = v9 + 1;
      result += 6;
      v11 = *v9;
      v12 = *v8;
      v32 = v8 + 1;
      v31 = *(_DWORD *)(v29 + 4 * v12);
      v13 = *(_DWORD *)(v27 + 4 * v12) + *(_DWORD *)(v26 + 4 * v11);
      v14 = *(_DWORD *)(v28 + 4 * v11);
      v15 = *v7;
      v13 >>= 16;
      v16 = v7 + 1;
      *(result - 6) = *(_BYTE *)(v15 + v31 + v6);
      *(result - 5) = *(_BYTE *)(v13 + v15 + v6);
      *(result - 4) = *(_BYTE *)(v6 + v14 + v15);
      v17 = *v16;
      v7 = v16 + 1;
      v18 = v17;
      *(result - 3) = *(_BYTE *)(v17 + v31 + v6);
      LOBYTE(v17) = *(_BYTE *)(v17 + v13 + v6);
      v9 = v25;
      *(result - 2) = v17;
      v8 = v32;
      *(result - 1) = *(_BYTE *)(v6 + v14 + v18);
      --v30;
    }
    while ( v30 );
    v4 = a1;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v19 = *v9;
    v20 = *(_DWORD *)(v26 + 4 * v19);
    v21 = *v8;
    v22 = *(_DWORD *)(v28 + 4 * v19);
    v23 = (*(_DWORD *)(v27 + 4 * v21) + v20) >> 16;
    v24 = *v7;
    *result = *(_BYTE *)(v24 + *(_DWORD *)(v29 + 4 * v21) + v6);
    result[1] = *(_BYTE *)(v24 + v23 + v6);
    result[2] = *(_BYTE *)(v22 + v24 + v6);
  }
  return result;
}

// sub_10042C90 @ 0x10042C90
char __cdecl sub_10042C90(_DWORD *a1, _DWORD *a2, int a3, int a4)
{
  _DWORD *v4; // ebx
  _DWORD *v5; // ecx
  int v6; // eax
  unsigned __int8 **v8; // esi
  unsigned __int8 *v9; // edi
  int v10; // esi
  unsigned __int8 *v11; // ebp
  unsigned __int8 *v12; // edi
  _BYTE *v13; // ecx
  _BYTE *v14; // esi
  int v15; // ebx
  int v16; // edx
  int v17; // ebp
  int v18; // edi
  int v19; // edx
  _BYTE *v20; // esi
  int v21; // edx
  int v22; // edx
  int v23; // edx
  int v24; // ebx
  int v25; // edx
  int v26; // edi
  int v27; // edx
  int v28; // ebp
  int v29; // ecx
  int v31; // [esp+10h] [ebp-1Ch]
  unsigned __int8 *v32; // [esp+14h] [ebp-18h]
  unsigned __int8 *v33; // [esp+18h] [ebp-14h]
  int v34; // [esp+1Ch] [ebp-10h]
  int v35; // [esp+20h] [ebp-Ch]
  int v36; // [esp+24h] [ebp-8h]
  int v37; // [esp+28h] [ebp-4h]
  int v38; // [esp+30h] [ebp+4h]
  unsigned __int8 *v39; // [esp+34h] [ebp+8h]
  unsigned __int8 *v40; // [esp+38h] [ebp+Ch]
  int v41; // [esp+3Ch] [ebp+10h]

  v4 = a1;
  v5 = (_DWORD *)a1[103];
  v34 = v5[4];
  v6 = a1[71];
  v37 = v5[5];
  v35 = v5[7];
  v36 = v5[6];
  v8 = (unsigned __int8 **)(*a2 + 8 * a3);
  v9 = *v8;
  v40 = v8[1];
  v10 = a2[1];
  v11 = *(unsigned __int8 **)(a2[2] + 4 * a3);
  v39 = v9;
  v12 = *(unsigned __int8 **)(v10 + 4 * a3);
  v13 = *(_BYTE **)a4;
  v14 = *(_BYTE **)(a4 + 4);
  if ( a1[23] >> 1 )
  {
    v31 = a1[23] >> 1;
    while ( 1 )
    {
      v15 = *v12;
      v16 = *v11;
      v32 = v12 + 1;
      v33 = v11 + 1;
      v17 = *(_DWORD *)(v34 + 4 * v16);
      v18 = *(_DWORD *)(v36 + 4 * v16) + *(_DWORD *)(v35 + 4 * v15);
      v41 = *(_DWORD *)(v37 + 4 * v15);
      v19 = *v39;
      v18 >>= 16;
      v13 += 6;
      v20 = v14 + 3;
      *(v13 - 6) = *(_BYTE *)(v19 + v17 + v6);
      *(v13 - 5) = *(_BYTE *)(v19 + v18 + v6);
      *(v13 - 4) = *(_BYTE *)(v41 + v19 + v6);
      v21 = v39[1];
      v39 += 2;
      *(v13 - 3) = *(_BYTE *)(v21 + v17 + v6);
      *(v13 - 2) = *(_BYTE *)(v21 + v18 + v6);
      *(v13 - 1) = *(_BYTE *)(v41 + v21 + v6);
      v22 = *v40;
      *(v20 - 3) = *(_BYTE *)(v22 + v17 + v6);
      *(v20 - 2) = *(_BYTE *)(v22 + v18 + v6);
      *(v20 - 1) = *(_BYTE *)(v41 + v22 + v6);
      v23 = v40[1];
      v40 += 2;
      *v20 = *(_BYTE *)(v23 + v17 + v6);
      v20[1] = *(_BYTE *)(v23 + v18 + v6);
      v20[2] = *(_BYTE *)(v41 + v23 + v6);
      v14 = v20 + 3;
      if ( !--v31 )
        break;
      v12 = v32;
      v11 = v33;
    }
    v4 = a1;
    v12 = v32;
    v11 = v33;
  }
  if ( (v4[23] & 1) != 0 )
  {
    v24 = *v11;
    v25 = *v12;
    v38 = *(_DWORD *)(v34 + 4 * v24);
    v26 = *(_DWORD *)(v36 + 4 * v24) + *(_DWORD *)(v35 + 4 * v25);
    v27 = *(_DWORD *)(v37 + 4 * v25);
    v26 >>= 16;
    v28 = *v39;
    *v13 = *(_BYTE *)(v28 + v38 + v6);
    v13[1] = *(_BYTE *)(v26 + v28 + v6);
    v13[2] = *(_BYTE *)(v6 + v27 + v28);
    v29 = *v40;
    *v14 = *(_BYTE *)(v29 + v38 + v6);
    v14[1] = *(_BYTE *)(v29 + v26 + v6);
    LOBYTE(v6) = *(_BYTE *)(v27 + v29 + v6);
    v14[2] = v6;
  }
  return v6;
}

// sub_10042EA0 @ 0x10042EA0
int __cdecl sub_10042EA0(int a1)
{
  int v1; // edi
  int i; // ebp
  int v3; // ebp
  int result; // eax

  v1 = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 44);
  *(_DWORD *)(a1 + 420) = v1;
  *(_DWORD *)v1 = sub_10043070;
  *(_DWORD *)(v1 + 12) = sub_10044200;
  *(_DWORD *)(v1 + 32) = 0;
  *(_DWORD *)(v1 + 40) = 0;
  if ( *(_DWORD *)(a1 + 100) != 3 )
  {
    *(_DWORD *)(*(_DWORD *)a1 + 20) = 46;
    (**(void (__cdecl ***)(int))a1)(a1);
  }
  *(_DWORD *)(v1 + 24) = (**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 128);
  for ( i = 0; i < 128; i += 4 )
    *(_DWORD *)(*(_DWORD *)(v1 + 24) + i) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(a1, 1, 4096);
  *(_BYTE *)(v1 + 28) = 1;
  if ( *(_BYTE *)(a1 + 90) )
  {
    v3 = *(_DWORD *)(a1 + 84);
    if ( v3 < 8 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 55;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 8;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    if ( v3 > 256 )
    {
      *(_DWORD *)(*(_DWORD *)a1 + 20) = 56;
      *(_DWORD *)(*(_DWORD *)a1 + 24) = 256;
      (**(void (__cdecl ***)(int))a1)(a1);
    }
    *(_DWORD *)(v1 + 16) = (*(int (__cdecl **)(int, int, int, int))(*(_DWORD *)(a1 + 4) + 8))(a1, 1, v3, 3);
    *(_DWORD *)(v1 + 20) = v3;
  }
  else
  {
    *(_DWORD *)(v1 + 16) = 0;
  }
  result = *(_DWORD *)(a1 + 76);
  if ( result )
    *(_DWORD *)(a1 + 76) = 2;
  if ( *(_DWORD *)(a1 + 76) == 2 )
  {
    *(_DWORD *)(v1 + 32) = (*(int (__cdecl **)(int, int, int))(*(_DWORD *)(a1 + 4) + 4))(
                             a1,
                             1,
                             6 * (*(_DWORD *)(a1 + 92) + 2));
    return sub_10042FD0(a1);
  }
  return result;
}

// sub_10042FD0 @ 0x10042FD0
_DWORD *__cdecl sub_10042FD0(int a1)
{
  int v1; // esi
  _DWORD *result; // eax
  int v3; // ebp
  int v4; // ecx
  int v5; // ebx
  _DWORD *v6; // esi
  _DWORD *v7; // edi
  int v8; // edx
  _DWORD *v9; // esi
  _DWORD *v10; // edi
  _DWORD *v11; // edi
  int v12; // esi

  v1 = *(_DWORD *)(a1 + 420);
  result = (_DWORD *)((**(int (__cdecl ***)(int, int, int))(a1 + 4))(a1, 1, 2044) + 1020);
  v3 = 16;
  *(_DWORD *)(v1 + 40) = result;
  v4 = 0;
  v5 = 0;
  v6 = result;
  v7 = result;
  v8 = 16;
  do
  {
    *v6 = v4;
    *v7 = v5;
    ++v6;
    --v7;
    ++v4;
    --v5;
    --v3;
  }
  while ( v3 );
  v9 = result + 16;
  v10 = result - 16;
  do
  {
    *v9 = v4;
    *v10 = -v4;
    ++v8;
    ++v9;
    --v10;
    v4 += (v8 & 1) == 0;
  }
  while ( v8 < 48 );
  if ( v8 <= 255 )
  {
    v11 = &result[v8];
    result -= v8;
    v12 = 256 - v8;
    do
    {
      *v11 = v4;
      *result = -v4;
      ++v11;
      --result;
      --v12;
    }
    while ( v12 );
  }
  return result;
}

// sub_10043070 @ 0x10043070
char __cdecl sub_10043070(_DWORD *a1, char a2)
{
  int v3; // edi
  int v4; // ebp
  unsigned int v5; // ebp
  char result; // al
  void **v7; // esi
  int v8; // ebp
  void **v9; // [esp+10h] [ebp+4h]

  v3 = a1[105];
  v9 = *(void ***)(v3 + 24);
  if ( a1[19] )
    a1[19] = 2;
  if ( a2 )
  {
    *(_DWORD *)(v3 + 4) = sub_10043190;
    *(_DWORD *)(v3 + 8) = sub_10043A20;
    *(_BYTE *)(v3 + 28) = 1;
  }
  else
  {
    if ( a1[19] == 2 )
      *(_DWORD *)(v3 + 4) = sub_10043740;
    else
      *(_DWORD *)(v3 + 4) = sub_10043210;
    *(_DWORD *)(v3 + 8) = nullsub_4;
    v4 = a1[28];
    if ( v4 < 1 )
    {
      *(_DWORD *)(*a1 + 20) = 55;
      *(_DWORD *)(*a1 + 24) = 1;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( v4 > 256 )
    {
      *(_DWORD *)(*a1 + 20) = 56;
      *(_DWORD *)(*a1 + 24) = 256;
      (*(void (__cdecl **)(_DWORD *))*a1)(a1);
    }
    if ( a1[19] == 2 )
    {
      v5 = 6 * (a1[23] + 2);
      if ( !*(_DWORD *)(v3 + 32) )
        *(_DWORD *)(v3 + 32) = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, 6 * (a1[23] + 2));
      sub_1003E510(*(void **)(v3 + 32), v5);
      if ( !*(_DWORD *)(v3 + 40) )
        sub_10042FD0((int)a1);
      *(_BYTE *)(v3 + 36) = 0;
    }
  }
  result = *(_BYTE *)(v3 + 28);
  if ( result )
  {
    v7 = v9;
    v8 = 32;
    do
    {
      result = sub_1003E510(*v7++, 0x1000u);
      --v8;
    }
    while ( v8 );
    *(_BYTE *)(v3 + 28) = 0;
  }
  return result;
}

// sub_10043190 @ 0x10043190
int __cdecl sub_10043190(int a1, unsigned __int8 **a2, int a3, int a4)
{
  int v4; // ebp
  int result; // eax
  int v6; // esi
  unsigned __int8 *v8; // ecx
  int v9; // edi
  int v10; // edx
  int v11; // eax
  _WORD *v12; // eax
  int v13; // [esp+Ch] [ebp+4h]

  v4 = *(_DWORD *)(a1 + 92);
  result = a4;
  v6 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  if ( a4 > 0 )
  {
    v13 = a4;
    do
    {
      v8 = *a2;
      if ( v4 )
      {
        v9 = v4;
        do
        {
          v10 = (v8[2] >> 3) + 32 * (v8[1] >> 2);
          v11 = *(_DWORD *)(v6 + 4 * (*v8 >> 3));
          ++*(_WORD *)(v11 + 2 * v10);
          v12 = (_WORD *)(v11 + 2 * v10);
          if ( !*v12 )
            *v12 = -1;
          v8 += 3;
          --v9;
        }
        while ( v9 );
      }
      ++a2;
      result = --v13;
    }
    while ( v13 );
  }
  return result;
}

// sub_10043210 @ 0x10043210
_DWORD *__cdecl sub_10043210(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  _DWORD *result; // eax
  int v5; // edx
  int v6; // ecx
  unsigned __int8 *v7; // esi
  _BYTE *v8; // ebp
  unsigned int v9; // ecx
  int v10; // eax
  unsigned __int8 *v11; // esi
  unsigned int v12; // ecx
  int v13; // edx
  _WORD *v14; // edi
  bool v15; // zf
  int v16; // [esp+4h] [ebp-Ch]
  int v17; // [esp+8h] [ebp-8h]
  int v18; // [esp+Ch] [ebp-4h]
  int v19; // [esp+18h] [ebp+8h]
  int v20; // [esp+20h] [ebp+10h]

  result = a1;
  v16 = *(_DWORD *)(a1[105] + 24);
  v5 = a1[23];
  v17 = v5;
  if ( a4 > 0 )
  {
    result = a3;
    v6 = a2 - (_DWORD)a3;
    v18 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      v7 = *(unsigned __int8 **)((char *)result + v6);
      v8 = (_BYTE *)*result;
      if ( v5 )
      {
        v20 = v5;
        do
        {
          v9 = v7[1];
          v10 = *v7 >> 3;
          v11 = v7 + 1;
          v12 = v9 >> 2;
          v13 = v11[1] >> 3;
          v14 = (_WORD *)(*(_DWORD *)(v16 + 4 * v10) + 2 * (v13 + 32 * v12));
          v7 = v11 + 2;
          if ( !*v14 )
            sub_100432E0(a1, v10, v12, v13);
          *v8++ = *(_BYTE *)v14 - 1;
          --v20;
        }
        while ( v20 );
        v5 = v17;
        result = a3;
        v6 = v18;
      }
      ++result;
      v15 = v19 == 1;
      a3 = result;
      --v19;
    }
    while ( !v15 );
  }
  return result;
}

// sub_100432E0 @ 0x100432E0
int __cdecl sub_100432E0(_DWORD *a1, int a2, int a3, int a4)
{
  int v4; // ebx
  int v5; // esi
  int v6; // edx
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int *v10; // eax
  int v11; // eax
  int v12; // edx
  int v13; // eax
  int v14; // edi
  int v15; // ecx
  int v16; // eax
  int v17; // ecx
  int v18; // ebx
  int v19; // eax
  int v20; // ecx
  int v21; // ecx
  int v22; // ebx
  int v23; // eax
  bool v24; // cc
  unsigned __int8 *v25; // edx
  _DWORD *v26; // ebx
  int v27; // ecx
  int v28; // edi
  int v29; // eax
  int v30; // esi
  int result; // eax
  int v32; // [esp+10h] [ebp-5B0h]
  int v33; // [esp+10h] [ebp-5B0h]
  int v34; // [esp+14h] [ebp-5ACh]
  int v35; // [esp+14h] [ebp-5ACh]
  int *v36; // [esp+18h] [ebp-5A8h]
  int *v37; // [esp+18h] [ebp-5A8h]
  int v38; // [esp+1Ch] [ebp-5A4h]
  int v39; // [esp+1Ch] [ebp-5A4h]
  int v40; // [esp+24h] [ebp-59Ch]
  int v41; // [esp+28h] [ebp-598h]
  int v42; // [esp+2Ch] [ebp-594h]
  int v43; // [esp+30h] [ebp-590h]
  int v44; // [esp+34h] [ebp-58Ch]
  int v45; // [esp+3Ch] [ebp-584h]
  _BYTE v46[128]; // [esp+40h] [ebp-580h] BYREF
  _BYTE v47[256]; // [esp+C0h] [ebp-500h] BYREF
  _BYTE v48[1024]; // [esp+1C0h] [ebp-400h] BYREF
  int v49; // [esp+5C8h] [ebp+8h]
  int v50; // [esp+5CCh] [ebp+Ch]
  int v51; // [esp+5CCh] [ebp+Ch]
  int v52; // [esp+5D0h] [ebp+10h]
  int v53; // [esp+5D0h] [ebp+10h]

  v50 = a3 >> 3;
  v4 = a2 >> 2;
  v5 = 32 * v50 + 2;
  v43 = *(_DWORD *)(a1[105] + 24);
  v6 = a1[28];
  v52 = a4 >> 2;
  v7 = 32 * v52 + 4;
  v8 = 32 * (a2 >> 2) + 4;
  v9 = (2 * v8 + 24) >> 1;
  v49 = a2 >> 2;
  v34 = v7;
  v41 = v6;
  v40 = (2 * v7 + 24) >> 1;
  v38 = 0x7FFFFFFF;
  v32 = 0;
  if ( v6 > 0 )
  {
    v36 = (int *)v48;
    v10 = (int *)a1[29];
    v45 = *v10;
    v42 = v10[1];
    v44 = v10[2];
    while ( 1 )
    {
      v11 = *(unsigned __int8 *)(v45 + v32);
      if ( v11 < v8 )
      {
        v12 = 2 * (v11 - v8) * 2 * (v11 - v8);
        v13 = v11 - (v8 + 24);
        goto LABEL_9;
      }
      v14 = v8 + 24;
      if ( v11 > v8 + 24 )
        break;
      v12 = 0;
      if ( v11 > v9 )
        goto LABEL_8;
      v13 = v11 - v14;
LABEL_9:
      v15 = *(unsigned __int8 *)(v42 + v32);
      v16 = 2 * v13 * 2 * v13;
      if ( v15 < v5 )
      {
        v12 += 3 * (v15 - v5) * 3 * (v15 - v5);
        v17 = v15 - (32 * v50 + 30);
        goto LABEL_16;
      }
      v18 = 32 * v50 + 30;
      if ( v15 > v18 )
      {
        v12 += 3 * (v15 - v18) * 3 * (v15 - v18);
LABEL_15:
        v17 = v15 - v5;
        goto LABEL_16;
      }
      if ( v15 > (2 * v5 + 28) >> 1 )
        goto LABEL_15;
      v17 = v15 - v18;
LABEL_16:
      v19 = 3 * v17 * 3 * v17 + v16;
      v20 = *(unsigned __int8 *)(v44 + v32);
      v7 = 32 * v52 + 4;
      if ( v20 < v34 )
      {
        v12 += (v20 - v34) * (v20 - v34);
        v7 = 32 * v52 + 4;
        v21 = v20 - (32 * v52 + 28);
        goto LABEL_23;
      }
      v22 = 32 * v52 + 28;
      if ( v20 > v22 )
      {
        v7 = 32 * v52 + 4;
        v12 += (v20 - v22) * (v20 - v22);
LABEL_22:
        v21 = v20 - v7;
        goto LABEL_23;
      }
      if ( v20 > v40 )
        goto LABEL_22;
      v21 = v20 - v22;
LABEL_23:
      *v36 = v12;
      v23 = v21 * v21 + v19;
      if ( v23 < v38 )
        v38 = v23;
      ++v36;
      v6 = v41;
      if ( ++v32 >= v41 )
      {
        v4 = v49;
        goto LABEL_27;
      }
      v9 = (2 * v8 + 24) >> 1;
    }
    v12 = 2 * (v11 - v14) * 2 * (v11 - v14);
LABEL_8:
    v13 = v11 - v8;
    goto LABEL_9;
  }
LABEL_27:
  v35 = 0;
  v33 = 0;
  if ( v6 > 0 )
  {
    v37 = (int *)v48;
    do
    {
      if ( *v37 <= v38 )
        v47[v35++] = v33;
      v24 = ++v33 < v6;
      ++v37;
    }
    while ( v24 );
  }
  sub_100435E0(a1, v8, v5, v7, v35, v47, v46);
  v53 = 4 * v52;
  v51 = 8 * v50;
  v25 = v46;
  v26 = (_DWORD *)(v43 + 16 * v4);
  v39 = 4;
  do
  {
    v27 = 2 * (v53 + 32 * v51);
    v28 = 8;
    do
    {
      v29 = v27 + *v26;
      v30 = 4;
      do
      {
        v29 += 2;
        *(_WORD *)(v29 - 2) = *v25++ + 1;
        --v30;
      }
      while ( v30 );
      v27 += 64;
      --v28;
    }
    while ( v28 );
    ++v26;
    result = --v39;
  }
  while ( v39 );
  return result;
}

// sub_100435E0 @ 0x100435E0
int __cdecl sub_100435E0(int a1, int a2, int a3, int a4, int a5, int a6, _BYTE *a7)
{
  int result; // eax
  int v8; // edx
  _DWORD *v9; // edi
  int v10; // eax
  int v11; // esi
  int v12; // ebp
  int v13; // ecx
  int v14; // edi
  _BYTE *v15; // ebx
  int *v16; // esi
  int v17; // eax
  int v18; // ecx
  int v19; // ebp
  bool v20; // zf
  int v21; // [esp+4h] [ebp-220h]
  int v22; // [esp+8h] [ebp-21Ch]
  int i; // [esp+Ch] [ebp-218h]
  int v24; // [esp+10h] [ebp-214h]
  int v25; // [esp+14h] [ebp-210h]
  int v26; // [esp+18h] [ebp-20Ch]
  int v27; // [esp+1Ch] [ebp-208h]
  int v28; // [esp+20h] [ebp-204h]
  _DWORD v29[128]; // [esp+24h] [ebp-200h] BYREF

  memset32(v29, 0x7FFFFFFF, 0x80u);
  result = 0;
  for ( i = 0; i < a5; ++i )
  {
    v8 = *(unsigned __int8 *)(result + a6);
    v9 = *(_DWORD **)(a1 + 116);
    v21 = 4;
    v10 = 2 * (a2 - *(unsigned __int8 *)(v8 + *v9));
    v11 = 3 * (a3 - *(unsigned __int8 *)(v9[1] + v8));
    v12 = 8 * (9 * (a3 - *(unsigned __int8 *)(v9[1] + v8)) + 18);
    v27 = v12;
    v13 = a4 - *(unsigned __int8 *)(v9[2] + v8);
    v14 = v10 * v10 + v11 * v11 + v13 * v13;
    v15 = a7;
    v28 = 16 * (v13 + 4);
    v16 = v29;
    v26 = 32 * (v10 + 8);
    while ( 1 )
    {
      v17 = v14;
      v22 = v14;
      v25 = v12;
      v24 = 8;
      do
      {
        v18 = v28;
        v19 = 4;
        do
        {
          if ( v17 < *v16 )
          {
            *v16 = v17;
            *v15 = v8;
          }
          v17 += v18;
          v18 += 128;
          ++v16;
          ++v15;
          --v19;
        }
        while ( v19 );
        v17 = v25 + v22;
        v25 += 288;
        v20 = v24 == 1;
        v22 = v17;
        --v24;
      }
      while ( !v20 );
      v14 += v26;
      v26 += 512;
      if ( !--v21 )
        break;
      v12 = v27;
    }
    result = i + 1;
  }
  return result;
}

// sub_10043740 @ 0x10043740
int __cdecl sub_10043740(_DWORD *a1, int a2, _BYTE **a3, int a4)
{
  int v4; // esi
  int v5; // ecx
  int *v6; // eax
  int result; // eax
  _BYTE **v8; // ebx
  int v9; // ebp
  unsigned __int8 *v10; // eax
  _WORD *v11; // ebx
  int v12; // esi
  int v13; // ebp
  int v14; // edi
  int v15; // esi
  int v16; // edi
  int v17; // ebp
  int v18; // ecx
  int v19; // edx
  bool v20; // zf
  unsigned __int16 *v21; // ecx
  int v22; // eax
  int v23; // edi
  int v24; // ecx
  int v25; // ebp
  int v26; // eax
  int v27; // edi
  int v28; // eax
  int v29; // ebp
  __int16 v30; // dx
  int v31; // [esp+4h] [ebp-58h]
  __int16 v32; // [esp+8h] [ebp-54h]
  __int16 v33; // [esp+Ch] [ebp-50h]
  __int16 v34; // [esp+10h] [ebp-4Ch]
  int v35; // [esp+14h] [ebp-48h]
  __int16 v36; // [esp+18h] [ebp-44h]
  __int16 v37; // [esp+1Ch] [ebp-40h]
  __int16 v38; // [esp+20h] [ebp-3Ch]
  int v39; // [esp+24h] [ebp-38h]
  int v40; // [esp+28h] [ebp-34h]
  int v41; // [esp+2Ch] [ebp-30h]
  _BYTE **v42; // [esp+30h] [ebp-2Ch]
  int v43; // [esp+34h] [ebp-28h]
  int v44; // [esp+38h] [ebp-24h]
  int v45; // [esp+3Ch] [ebp-20h]
  unsigned __int16 *v46; // [esp+48h] [ebp-14h]
  int v47; // [esp+4Ch] [ebp-10h]
  int v48; // [esp+50h] [ebp-Ch]
  int v49; // [esp+54h] [ebp-8h]
  int v50; // [esp+58h] [ebp-4h]
  _BYTE *v51; // [esp+64h] [ebp+8h]
  int v52; // [esp+68h] [ebp+Ch]
  int v53; // [esp+6Ch] [ebp+10h]

  v4 = a1[105];
  v35 = a1[71];
  v45 = *(_DWORD *)(v4 + 24);
  v5 = a1[23];
  v6 = (int *)a1[29];
  v31 = *(_DWORD *)(v4 + 40);
  v47 = *v6;
  v48 = v6[1];
  v49 = v6[2];
  result = a4;
  v41 = v4;
  v50 = v5;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v42 = a3;
    v44 = a2 - (_DWORD)a3;
    v43 = a4;
    while ( 1 )
    {
      v10 = *(_BYTE **)((char *)v8 + v9);
      v52 = (int)v10;
      v51 = *v8;
      if ( *(_BYTE *)(v4 + 36) )
      {
        v52 = (int)&v10[2 * v5 - 3 + v5];
        v51 = &(*v8)[v5 - 1];
        v11 = (_WORD *)(*(_DWORD *)(v4 + 32) + 2 * (3 * v5 + 3));
        v10 = (unsigned __int8 *)v52;
        v39 = -1;
        v53 = -3;
        *(_BYTE *)(v4 + 36) = 0;
      }
      else
      {
        v11 = *(_WORD **)(v4 + 32);
        v39 = 1;
        v53 = 3;
        *(_BYTE *)(v4 + 36) = 1;
      }
      v12 = 0;
      v38 = 0;
      v37 = 0;
      v36 = 0;
      v13 = 0;
      v14 = 0;
      v34 = 0;
      v33 = 0;
      v32 = 0;
      if ( v5 )
      {
        v40 = v5;
        while ( 1 )
        {
          v15 = *(unsigned __int8 *)(*v10 + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53] + v12 + 8) >> 4)) + v35);
          v16 = *(unsigned __int8 *)(v10[1] + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53 + 1] + v14 + 8) >> 4)) + v35);
          v17 = *(unsigned __int8 *)(v10[2] + *(_DWORD *)(v31 + 4 * (((__int16)v11[v53 + 2] + v13 + 8) >> 4)) + v35);
          v18 = (v17 >> 3) + 32 * (v16 >> 2);
          v19 = *(_DWORD *)(v45 + 4 * (v15 >> 3));
          v20 = *(_WORD *)(v19 + 2 * v18) == 0;
          v21 = (unsigned __int16 *)(v19 + 2 * v18);
          v46 = v21;
          if ( v20 )
          {
            sub_100432E0(a1, v15 >> 3, v16 >> 2, v17 >> 3);
            v21 = v46;
          }
          v22 = *v21 - 1;
          *v51 = v22;
          v23 = v16 - *(unsigned __int8 *)(v22 + v48);
          v24 = v15 - *(unsigned __int8 *)(v22 + v47);
          v25 = v17 - *(unsigned __int8 *)(v22 + v49);
          *v11 = 3 * v24 + v32;
          v32 = 5 * v24 + v36;
          v12 = 7 * v24;
          v36 = v24;
          LOWORD(v24) = v23;
          v26 = 2 * v23;
          v23 *= 3;
          v11[1] = v23 + v33;
          v27 = v26 + v23;
          v33 = v27 + v37;
          v14 = v26 + v27;
          v37 = v24;
          LOWORD(v24) = v25;
          v28 = 2 * v25;
          v25 *= 3;
          v11[2] = v25 + v34;
          v29 = v28 + v25;
          v30 = v29 + v38;
          v38 = v24;
          v13 = v28 + v29;
          v34 = v30;
          v52 += v53;
          v11 += v53;
          v20 = v40 == 1;
          v51 += v39;
          --v40;
          if ( v20 )
            break;
          v10 = (unsigned __int8 *)v52;
        }
        v5 = v50;
        v4 = v41;
      }
      else
      {
        v4 = v41;
      }
      *v11 = v32;
      v11[1] = v33;
      v11[2] = v34;
      v8 = v42 + 1;
      result = v43 - 1;
      v20 = v43 == 1;
      ++v42;
      --v43;
      if ( v20 )
        break;
      v9 = v44;
    }
  }
  return result;
}

// sub_10043A20 @ 0x10043A20
int __cdecl sub_10043A20(_DWORD *a1)
{
  _DWORD *v1; // ebp
  int (__cdecl **v2)(_DWORD *, int, int); // ecx
  int v3; // edi
  int v4; // esi
  _DWORD *v5; // ebx
  int v6; // eax
  _DWORD *v7; // edi
  int v8; // esi
  int *v9; // ecx
  int *v10; // eax
  int v11; // esi
  int *v12; // eax
  int v13; // esi
  int v14; // ebp
  int v15; // ebp
  int v16; // eax
  int v17; // eax
  int v18; // eax
  bool v19; // cc
  int i; // esi
  int v21; // ecx
  int result; // eax
  int v23; // [esp+10h] [ebp-18h]
  int v24; // [esp+14h] [ebp-14h]
  int v25; // [esp+14h] [ebp-14h]
  int v26; // [esp+18h] [ebp-10h]
  _DWORD *v27; // [esp+1Ch] [ebp-Ch]
  int v28; // [esp+20h] [ebp-8h]
  int v29; // [esp+24h] [ebp-4h]

  v1 = a1;
  v2 = (int (__cdecl **)(_DWORD *, int, int))a1[1];
  v3 = a1[105];
  a1[29] = *(_DWORD *)(v3 + 16);
  v4 = *(_DWORD *)(v3 + 20);
  v28 = v3;
  v29 = v4;
  v5 = (_DWORD *)(*v2)(a1, 1, 32 * v4);
  v27 = v5;
  *v5 = 0;
  v5[1] = 31;
  v5[2] = 0;
  v5[3] = 63;
  v5[4] = 0;
  v5[5] = 31;
  sub_10043C40(a1, v5);
  v23 = 1;
  if ( v4 > 1 )
  {
    v6 = 2;
    v26 = 2;
    v7 = v5 + 11;
    do
    {
      if ( v6 > v4 )
      {
        v11 = 0;
        v9 = 0;
        if ( v6 > 0 )
        {
          v12 = v5 + 6;
          v25 = v23;
          do
          {
            if ( *v12 > v11 )
            {
              v9 = v12 - 6;
              v11 = *v12;
            }
            v12 += 8;
            --v25;
          }
          while ( v25 );
        }
      }
      else
      {
        v8 = 0;
        v9 = 0;
        if ( v6 > 0 )
        {
          v10 = v5 + 7;
          v24 = v23;
          do
          {
            if ( *v10 > v8 && *(v10 - 1) > 0 )
            {
              v9 = v10 - 7;
              v8 = *v10;
            }
            v10 += 8;
            --v24;
          }
          while ( v24 );
        }
      }
      if ( !v9 )
        break;
      *(v7 - 2) = v9[1];
      *v7 = v9[3];
      v7[2] = v9[5];
      *(v7 - 3) = *v9;
      *(v7 - 1) = v9[2];
      v7[1] = v9[4];
      v13 = 12 * (v9[3] - v9[2]);
      v14 = 1;
      if ( 16 * (v9[1] - *v9) > v13 )
      {
        v13 = 16 * (v9[1] - *v9);
        v14 = 0;
      }
      if ( 8 * (v9[5] - v9[4]) > v13 )
        v14 = 2;
      if ( v14 )
      {
        v15 = v14 - 1;
        if ( v15 )
        {
          if ( v15 == 1 )
          {
            v16 = (v9[5] + v9[4]) / 2;
            v9[5] = v16;
            v7[1] = v16 + 1;
          }
        }
        else
        {
          v17 = (v9[2] + v9[3]) / 2;
          v9[3] = v17;
          *(v7 - 1) = v17 + 1;
        }
      }
      else
      {
        v18 = (*v9 + v9[1]) / 2;
        v9[1] = v18;
        *(v7 - 3) = v18 + 1;
      }
      v1 = a1;
      sub_10043C40(a1, v9);
      sub_10043C40(a1, v7 - 3);
      v4 = v29;
      v5 = v27;
      v6 = v26 + 2;
      v7 += 8;
      v19 = ++v23 < v29;
      v26 += 2;
    }
    while ( v19 );
    v3 = v28;
  }
  for ( i = 0; i < v23; v5 += 8 )
    sub_10044070(v1, v5, i++);
  v21 = *v1;
  v1[28] = v23;
  *(_DWORD *)(v21 + 20) = 95;
  *(_DWORD *)(*v1 + 24) = v23;
  result = (*(int (__cdecl **)(_DWORD *, int))(*v1 + 4))(v1, 1);
  *(_BYTE *)(v3 + 28) = 1;
  return result;
}

// sub_10043C40 @ 0x10043C40
int __cdecl sub_10043C40(int a1, int *a2)
{
  int v2; // ecx
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // edx
  int v7; // edi
  int v8; // edx
  _WORD *v9; // ecx
  int v10; // eax
  _DWORD *v12; // ecx
  int v13; // edx
  _WORD *v14; // ecx
  int v15; // eax
  bool v17; // cc
  int v18; // esi
  int v19; // edi
  _DWORD *v20; // edx
  int v21; // ecx
  _WORD *v22; // eax
  int v24; // esi
  int v25; // edi
  _DWORD *v26; // edx
  _WORD *v27; // eax
  int v28; // ecx
  int v30; // eax
  int v31; // edi
  int v32; // edx
  _DWORD *v33; // esi
  int v34; // ecx
  _WORD *v35; // eax
  int v36; // eax
  int v37; // edi
  int v38; // edx
  _DWORD *v39; // esi
  _WORD *v40; // eax
  int v41; // ecx
  int v42; // ebx
  int result; // eax
  int v44; // ebp
  int v45; // edx
  _WORD *v46; // eax
  int v47; // ecx
  bool v48; // zf
  int v49; // [esp+10h] [ebp-20h]
  int v50; // [esp+14h] [ebp-1Ch]
  int v51; // [esp+18h] [ebp-18h]
  int v52; // [esp+1Ch] [ebp-14h]
  int v53; // [esp+20h] [ebp-10h]
  int v54; // [esp+20h] [ebp-10h]
  int v55; // [esp+20h] [ebp-10h]
  int v56; // [esp+20h] [ebp-10h]
  int v57; // [esp+20h] [ebp-10h]
  int v58; // [esp+20h] [ebp-10h]
  int v59; // [esp+20h] [ebp-10h]
  int v60; // [esp+24h] [ebp-Ch]
  int v61; // [esp+24h] [ebp-Ch]
  int v62; // [esp+28h] [ebp-8h]
  _DWORD *v63; // [esp+2Ch] [ebp-4h]
  _DWORD *v64; // [esp+2Ch] [ebp-4h]
  _DWORD *v65; // [esp+2Ch] [ebp-4h]
  int v66; // [esp+34h] [ebp+4h]

  v2 = a2[1];
  v3 = a2[5];
  v4 = a2[4];
  v5 = a2[2];
  v60 = *(_DWORD *)(*(_DWORD *)(a1 + 420) + 24);
  v6 = *a2;
  v7 = a2[3];
  v49 = *a2;
  v50 = v2;
  v66 = v5;
  v51 = v7;
  v52 = v4;
  v62 = v3;
  if ( *a2 < v2 )
  {
    v53 = *a2;
    if ( *a2 <= v2 )
    {
      v63 = (_DWORD *)(v60 + 4 * v6);
      while ( v5 > v7 )
      {
LABEL_12:
        ++v53;
        ++v63;
        if ( v53 > v2 )
          goto LABEL_15;
      }
      v8 = *v63 + 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v9 = (_WORD *)v8;
        v10 = a2[4];
        if ( v4 <= v3 )
          break;
LABEL_10:
        ++v5;
        v8 += 64;
        if ( v5 > v7 )
        {
          v6 = *a2;
          v2 = a2[1];
          v5 = a2[2];
          goto LABEL_12;
        }
      }
      while ( !*v9++ )
      {
        if ( ++v10 > v3 )
        {
          v7 = a2[3];
          goto LABEL_10;
        }
      }
      v7 = a2[3];
      v5 = a2[2];
      *a2 = v53;
      v2 = v50;
      v49 = v53;
      v6 = v53;
    }
LABEL_15:
    if ( v2 > v6 )
    {
      v54 = v2;
      v12 = (_DWORD *)(v60 + 4 * v2);
      v64 = v12;
      while ( v5 > v7 )
      {
LABEL_25:
        v12 = v64 - 1;
        v17 = --v54 < v6;
        --v64;
        if ( v17 )
          goto LABEL_28;
      }
      v13 = *v12 + 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v14 = (_WORD *)v13;
        v15 = v4;
        if ( v4 <= v3 )
          break;
LABEL_23:
        ++v5;
        v13 += 64;
        if ( v5 > v7 )
        {
          v6 = v49;
          v5 = v66;
          goto LABEL_25;
        }
      }
      while ( !*v14++ )
      {
        if ( ++v15 > v3 )
        {
          v7 = v51;
          goto LABEL_23;
        }
      }
      v7 = v51;
      v5 = v66;
      v50 = v54;
      a2[1] = v54;
    }
  }
LABEL_28:
  if ( v5 < v7 )
  {
    v55 = v5;
    if ( v5 <= v7 )
    {
      v18 = 2 * (v4 + 32 * v5);
      while ( 1 )
      {
        v19 = v49;
        if ( v49 <= v50 )
          break;
LABEL_37:
        v18 += 64;
        if ( ++v55 > v51 )
          goto LABEL_40;
      }
      v20 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v21 = v4;
        v22 = (_WORD *)(v18 + *v20);
        if ( v52 <= v3 )
          break;
LABEL_36:
        v4 = v52;
        ++v19;
        ++v20;
        if ( v19 > v50 )
          goto LABEL_37;
      }
      while ( !*v22++ )
      {
        if ( ++v21 > v3 )
          goto LABEL_36;
      }
      v4 = v52;
      v66 = v55;
      a2[2] = v55;
LABEL_40:
      v7 = v51;
      v5 = v66;
    }
    if ( v7 > v5 )
    {
      v56 = v7;
      v24 = 2 * (v4 + 32 * v7);
      while ( 1 )
      {
        v25 = v49;
        if ( v49 <= v50 )
          break;
LABEL_49:
        v24 -= 64;
        if ( --v56 < v66 )
          goto LABEL_52;
      }
      v26 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v27 = (_WORD *)(*v26 + v24);
        v28 = v4;
        if ( v52 <= v3 )
          break;
LABEL_48:
        v4 = v52;
        ++v25;
        ++v26;
        if ( v25 > v50 )
          goto LABEL_49;
      }
      while ( !*v27++ )
      {
        if ( ++v28 > v3 )
          goto LABEL_48;
      }
      v4 = v52;
      v51 = v56;
      a2[3] = v56;
    }
  }
LABEL_52:
  if ( v4 < v3 )
  {
    v30 = v4;
    v57 = v4;
    if ( v4 <= v3 )
    {
      while ( 1 )
      {
        v31 = v49;
        if ( v49 <= v50 )
          break;
LABEL_61:
        v57 = ++v30;
        if ( v30 > v3 )
          goto LABEL_64;
      }
      v32 = 2 * (v30 + 32 * v66);
      v33 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v34 = v66;
        v35 = (_WORD *)(v32 + *v33);
        if ( v66 <= v51 )
          break;
LABEL_59:
        ++v31;
        ++v33;
        if ( v31 > v50 )
        {
          v3 = v62;
          v30 = v57;
          goto LABEL_61;
        }
      }
      while ( !*v35 )
      {
        ++v34;
        v35 += 32;
        if ( v34 > v51 )
          goto LABEL_59;
      }
      v4 = v57;
      v3 = v62;
      v52 = v57;
      a2[4] = v57;
    }
LABEL_64:
    if ( v3 > v4 )
    {
      v36 = v3;
      v58 = v3;
      while ( 1 )
      {
        v37 = v49;
        if ( v49 <= v50 )
          break;
LABEL_73:
        v58 = --v36;
        if ( v36 < v4 )
          goto LABEL_76;
      }
      v38 = 2 * (v36 + 32 * v66);
      v39 = (_DWORD *)(v60 + 4 * v49);
      while ( 1 )
      {
        v40 = (_WORD *)(*v39 + v38);
        v41 = v66;
        if ( v66 <= v51 )
          break;
LABEL_71:
        ++v37;
        ++v39;
        if ( v37 > v50 )
        {
          v3 = v62;
          v36 = v58;
          goto LABEL_73;
        }
      }
      while ( !*v40 )
      {
        ++v41;
        v40 += 32;
        if ( v41 > v51 )
          goto LABEL_71;
      }
      v3 = v58;
      v62 = v58;
      a2[5] = v58;
    }
  }
LABEL_76:
  v42 = v3 - v4;
  a2[6] = 16 * (v50 - v49) * 16 * (v50 - v49) + 12 * (v51 - v66) * 12 * (v51 - v66) + 8 * v42 * 8 * v42;
  result = v49;
  v44 = 0;
  if ( v49 > v50 )
  {
    a2[7] = 0;
  }
  else
  {
    v65 = (_DWORD *)(v60 + 4 * v49);
    v59 = v50 - v49 + 1;
    do
    {
      if ( v66 <= v51 )
      {
        v45 = *v65 + 2 * (v52 + 32 * v66);
        v61 = v51 - v66 + 1;
        do
        {
          v46 = (_WORD *)v45;
          if ( v52 <= v62 )
          {
            v47 = v42 + 1;
            do
            {
              if ( *v46 )
                ++v44;
              ++v46;
              --v47;
            }
            while ( v47 );
          }
          v45 += 64;
          --v61;
        }
        while ( v61 );
      }
      result = v59 - 1;
      v48 = v59 == 1;
      ++v65;
      --v59;
    }
    while ( !v48 );
    a2[7] = v44;
  }
  return result;
}

// sub_10044070 @ 0x10044070
int __cdecl sub_10044070(int a1, int *a2, int a3)
{
  int v3; // ebx
  int v4; // ebp
  int v5; // esi
  int v6; // ecx
  int v7; // eax
  int v8; // edi
  unsigned __int16 *v9; // ebx
  int v10; // eax
  int v11; // edx
  int v12; // ecx
  int v13; // esi
  int v14; // eax
  bool v15; // zf
  int result; // eax
  int v17; // [esp+10h] [ebp-30h]
  int v18; // [esp+14h] [ebp-2Ch]
  int v19; // [esp+18h] [ebp-28h]
  int v20; // [esp+1Ch] [ebp-24h]
  int v21; // [esp+20h] [ebp-20h]
  unsigned __int16 *v22; // [esp+24h] [ebp-1Ch]
  int v23; // [esp+28h] [ebp-18h]
  int v24; // [esp+2Ch] [ebp-14h]
  int v25; // [esp+30h] [ebp-10h]
  int v26; // [esp+34h] [ebp-Ch]
  int v27; // [esp+3Ch] [ebp-4h]
  _DWORD *v28; // [esp+48h] [ebp+8h]

  v3 = a1;
  v4 = a2[4];
  v5 = a2[2];
  v6 = a2[1];
  v25 = a2[3];
  v7 = *a2;
  v8 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v27 = v5;
  v26 = v4;
  v21 = a2[5];
  if ( *a2 <= v6 )
  {
    v17 = 8 * v7 + 4;
    v28 = (_DWORD *)(*(_DWORD *)(*(_DWORD *)(a1 + 420) + 24) + 4 * v7);
    v24 = v6 - v7 + 1;
    do
    {
      if ( v5 <= v25 )
      {
        v9 = (unsigned __int16 *)(*v28 + 2 * (v4 + 32 * v5));
        v10 = v25 - v5 + 1;
        v11 = 4 * v5 + 2;
        v22 = v9;
        v23 = v10;
        do
        {
          if ( v4 <= v21 )
          {
            v12 = 8 * v4 + 4;
            v13 = v21 - v4 + 1;
            do
            {
              v14 = *v9++;
              if ( (_WORD)v14 )
              {
                v18 += v14 * v17;
                v8 += v14;
                v19 += v14 * v11;
                v4 = v26;
                v20 += v14 * v12;
              }
              v12 += 8;
              --v13;
            }
            while ( v13 );
            v10 = v23;
            v5 = v27;
          }
          v9 = v22 + 32;
          v11 += 4;
          --v10;
          v22 += 32;
          v23 = v10;
        }
        while ( v10 );
        v3 = a1;
      }
      v15 = v24 == 1;
      ++v28;
      v17 += 8;
      --v24;
    }
    while ( !v15 );
  }
  *(_BYTE *)(**(_DWORD **)(v3 + 116) + a3) = ((v8 >> 1) + v18) / v8;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 4) + a3) = ((v8 >> 1) + v19) / v8;
  result = ((v8 >> 1) + v20) / v8;
  *(_BYTE *)(*(_DWORD *)(*(_DWORD *)(v3 + 116) + 8) + a3) = result;
  return result;
}

// sub_10044200 @ 0x10044200
int __cdecl sub_10044200(int a1)
{
  *(_BYTE *)(*(_DWORD *)(a1 + 420) + 28) = 1;
  return a1;
}

// sub_10044210 @ 0x10044210
int __cdecl sub_10044210(_DWORD *a1)
{
  _DWORD *v2; // eax
  _DWORD *v3; // ebx
  int v4; // ebp
  _DWORD *v5; // eax
  int v6; // eax
  int v7; // esi
  _DWORD *v8; // ebx
  int v9; // ecx
  int v10; // ebp
  int v11; // eax
  int v12; // eax
  int i; // edx
  int j; // ecx
  int v15; // ebp
  bool v16; // zf
  bool v17; // cc
  int result; // eax
  int v19; // ebp
  int v20; // esi
  _DWORD *v21; // ebx
  int v22; // [esp+10h] [ebp-28h]
  int v23; // [esp+14h] [ebp-24h]
  int *v24; // [esp+18h] [ebp-20h]
  int v25; // [esp+1Ch] [ebp-1Ch]
  int v26; // [esp+20h] [ebp-18h]
  int v27; // [esp+24h] [ebp-14h]
  _DWORD *v28; // [esp+28h] [ebp-10h]
  int v29; // [esp+2Ch] [ebp-Ch]
  int v30; // [esp+30h] [ebp-8h]
  int v31; // [esp+34h] [ebp-4h]
  int v32; // [esp+3Ch] [ebp+4h]

  v2 = (_DWORD *)(*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 88);
  a1[105] = v2;
  *v2 = sub_10044690;
  v2[2] = nullsub_4;
  v2[3] = sub_10044E30;
  v2[17] = 0;
  v2[13] = 0;
  if ( (int)a1[25] > 4 )
  {
    *(_DWORD *)(*a1 + 20) = 54;
    *(_DWORD *)(*a1 + 24) = 4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  if ( (int)a1[21] > 256 )
  {
    *(_DWORD *)(*a1 + 20) = 56;
    *(_DWORD *)(*a1 + 24) = 256;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v3 = (_DWORD *)a1[105];
  v28 = v3;
  v4 = sub_10044450(a1, v3 + 8);
  v23 = v4;
  if ( a1[25] == 3 )
  {
    v5 = (_DWORD *)(*a1 + 24);
    *v5 = v4;
    v5[1] = v3[8];
    v5[2] = v3[9];
    v5[3] = v3[10];
    *(_DWORD *)(*a1 + 20) = 93;
  }
  else
  {
    *(_DWORD *)(*a1 + 20) = 94;
    *(_DWORD *)(*a1 + 24) = v4;
  }
  (*(void (__cdecl **)(_DWORD *, int))(*a1 + 4))(a1, 1);
  v6 = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v4, a1[25]);
  v7 = v4;
  v31 = v6;
  v26 = v4;
  v27 = 0;
  if ( (int)a1[25] > 0 )
  {
    v8 = (_DWORD *)v6;
    v24 = v28 + 8;
    do
    {
      v9 = *v24;
      v7 /= *v24;
      if ( *v24 > 0 )
      {
        v10 = v9 - 1;
        v11 = (v9 - 1) / 2;
        v29 = v9 - 1;
        v30 = v11;
        v22 = 0;
        v32 = 0;
        v25 = *v24;
        while ( 1 )
        {
          v12 = (v32 + v11) / v10;
          for ( i = v22; i < v23; i += v26 )
          {
            for ( j = 0; j < v7; *(_BYTE *)(i + v15) = v12 )
            {
              v15 = j + *v8;
              ++j;
            }
          }
          v16 = v25 == 1;
          v32 += 255;
          v22 += v7;
          --v25;
          if ( v16 )
            break;
          v10 = v29;
          v11 = v30;
        }
        v4 = v23;
      }
      ++v24;
      ++v8;
      v17 = v27 + 1 < a1[25];
      v26 = v7;
      ++v27;
    }
    while ( v17 );
    v6 = v31;
    v3 = v28;
  }
  v3[4] = v6;
  v3[5] = v4;
  sub_10044540(a1);
  result = a1[19];
  if ( result == 2 )
  {
    result = a1[105];
    v19 = 2 * a1[23] + 4;
    v20 = 0;
    if ( (int)a1[25] > 0 )
    {
      v21 = (_DWORD *)(result + 68);
      do
      {
        *v21 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v19);
        result = a1[25];
        ++v20;
        ++v21;
      }
      while ( v20 < result );
    }
  }
  return result;
}

// sub_10044450 @ 0x10044450
int __cdecl sub_10044450(_DWORD *a1, void *a2)
{
  signed int v2; // esi
  int v3; // ebp
  int v4; // eax
  int v5; // ecx
  int v6; // ebp
  int v7; // ebx
  signed int v8; // edx
  signed int v9; // ebp
  int v10; // esi
  int v11; // edi
  char v13; // [esp+13h] [ebp-Dh]
  signed int *v14; // [esp+14h] [ebp-Ch]
  signed int v15; // [esp+18h] [ebp-8h]
  int v16; // [esp+1Ch] [ebp-4h]

  v2 = a1[25];
  v15 = v2;
  v16 = a1[21];
  v3 = 1;
  do
  {
    v4 = ++v3;
    if ( v2 > 1 )
    {
      v5 = v2 - 1;
      do
      {
        v4 *= v3;
        --v5;
      }
      while ( v5 );
    }
  }
  while ( v4 <= a1[21] );
  v6 = v3 - 1;
  if ( v6 < 2 )
  {
    *(_DWORD *)(*a1 + 20) = 55;
    *(_DWORD *)(*a1 + 24) = v4;
    (*(void (__cdecl **)(_DWORD *))*a1)(a1);
  }
  v7 = 1;
  if ( v2 > 0 )
  {
    v8 = v2;
    memset32(a2, v6, v2);
    do
    {
      v7 *= v6;
      --v8;
    }
    while ( v8 );
  }
  while ( 2 )
  {
    v9 = 0;
    v13 = 0;
    if ( v2 > 0 )
    {
      v14 = (signed int *)&dbl_10050950;
      while ( 1 )
      {
        v10 = a1[10] == 2 ? *v14 : v9;
        v11 = *((_DWORD *)a2 + v10);
        if ( (v11 + 1) * (v7 / v11) > v16 )
          break;
        *((_DWORD *)a2 + v10) = v11 + 1;
        v7 = (v11 + 1) * (v7 / v11);
        ++v9;
        v13 = 1;
        ++v14;
        if ( v9 >= v15 )
          goto LABEL_12;
      }
      if ( v13 )
      {
LABEL_12:
        v2 = v15;
        continue;
      }
    }
    return v7;
  }
}

// sub_10044540 @ 0x10044540
int __cdecl sub_10044540(_DWORD *a1)
{
  int v1; // esi
  int result; // eax
  int v3; // ecx
  int v4; // edi
  _BYTE *v5; // ebp
  int v6; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // ecx
  int v10; // eax
  _BYTE *v11; // edx
  int v12; // [esp+8h] [ebp-18h]
  int *v13; // [esp+Ch] [ebp-14h]
  int v14; // [esp+10h] [ebp-10h]
  int v15; // [esp+14h] [ebp-Ch]
  int v16; // [esp+18h] [ebp-8h]
  _BYTE *v17; // [esp+1Ch] [ebp-4h]

  v1 = a1[105];
  v16 = v1;
  if ( a1[19] == 1 )
  {
    v12 = 510;
    *(_BYTE *)(v1 + 28) = 1;
  }
  else
  {
    v12 = 0;
    *(_BYTE *)(v1 + 28) = 0;
  }
  *(_DWORD *)(v1 + 24) = (*(int (__cdecl **)(_DWORD *, int, int, _DWORD))(a1[1] + 8))(a1, 1, v12 + 256, a1[25]);
  result = *(_DWORD *)(v1 + 20);
  v3 = 0;
  v15 = 0;
  if ( (int)a1[25] > 0 )
  {
    v13 = (int *)(v1 + 32);
    while ( 1 )
    {
      v4 = *v13;
      v14 = result / *v13;
      if ( v12 )
        *(_DWORD *)(*(_DWORD *)(v1 + 24) + 4 * v3) += 255;
      v5 = *(_BYTE **)(*(_DWORD *)(v1 + 24) + 4 * v3);
      v6 = 0;
      v17 = v5;
      v7 = 0;
      v8 = (v4 + 254) / (2 * v4 - 2);
      do
      {
        if ( v7 > v8 )
        {
          v9 = 510 * v6;
          do
          {
            v9 += 510;
            ++v6;
            v8 = (v9 + v4 + 254) / (2 * v4 - 2);
          }
          while ( v7 > v8 );
          v3 = v15;
          v5 = v17;
        }
        v5[v7++] = v6 * v14;
      }
      while ( v7 <= 255 );
      if ( v12 )
      {
        v10 = 1;
        v11 = v5 - 1;
        do
        {
          *v11 = *v5;
          v5[v10 + 255] = v5[255];
          ++v10;
          --v11;
        }
        while ( v10 <= 255 );
      }
      result = (int)a1;
      v15 = ++v3;
      ++v13;
      if ( v3 >= a1[25] )
        break;
      result = v14;
      v1 = v16;
    }
  }
  return result;
}

// sub_10044690 @ 0x10044690
int __cdecl sub_10044690(_DWORD *a1)
{
  int v2; // esi
  int result; // eax
  int v4; // edi
  int v5; // eax
  int v6; // eax
  void **v7; // ecx
  int v8; // esi
  _DWORD *v9; // ebp
  int v10; // edi
  unsigned int v11; // ebp
  void **v12; // esi
  char v13; // al
  int v14; // ebp
  int v15; // ecx
  int *v16; // edi
  int v17; // esi
  int v18; // eax
  _DWORD *v19; // edx
  int v20; // eax
  int v21; // esi
  double *v22; // ebp
  int v23; // edi
  int i; // ecx
  int v25; // eax
  int *v26; // [esp+10h] [ebp-Ch]
  int v27; // [esp+14h] [ebp-8h]
  int v28; // [esp+18h] [ebp-4h]
  void **v29; // [esp+20h] [ebp+4h]
  int v30; // [esp+20h] [ebp+4h]

  v2 = a1[105];
  a1[29] = *(_DWORD *)(v2 + 16);
  result = a1[19];
  v4 = 0;
  a1[28] = *(_DWORD *)(v2 + 20);
  if ( result )
  {
    v5 = result - 1;
    if ( v5 )
    {
      if ( v5 == 1 )
      {
        v6 = *(_DWORD *)(v2 + 68);
        v7 = (void **)(v2 + 68);
        *(_DWORD *)(v2 + 4) = sub_10044C70;
        *(_BYTE *)(v2 + 84) = 0;
        v29 = (void **)(v2 + 68);
        if ( !v6 )
        {
          v8 = 2 * a1[23] + 4;
          if ( (int)a1[25] > 0 )
          {
            v9 = (_DWORD *)(a1[105] + 68);
            do
            {
              *v9 = (*(int (__cdecl **)(_DWORD *, int, int))(a1[1] + 4))(a1, 1, v8);
              ++v4;
              ++v9;
            }
            while ( v4 < a1[25] );
            v7 = v29;
          }
        }
        result = a1[25];
        v10 = 0;
        v11 = 2 * a1[23] + 4;
        if ( result > 0 )
        {
          v12 = v7;
          do
          {
            sub_1003E510(*v12, v11);
            result = a1[25];
            ++v10;
            ++v12;
          }
          while ( v10 < result );
        }
      }
      else
      {
        *(_DWORD *)(*a1 + 20) = 47;
        return (*(int (__cdecl **)(_DWORD *))*a1)(a1);
      }
    }
    else
    {
      if ( a1[25] == 3 )
        *(_DWORD *)(v2 + 4) = sub_10044B40;
      else
        *(_DWORD *)(v2 + 4) = sub_10044A10;
      v13 = *(_BYTE *)(v2 + 28);
      *(_DWORD *)(v2 + 48) = 0;
      if ( !v13 )
        sub_10044540(a1);
      result = *(_DWORD *)(v2 + 52);
      if ( !result )
      {
        result = a1[25];
        v14 = a1[105];
        v15 = 0;
        v28 = v14;
        v30 = 0;
        if ( result > 0 )
        {
          v16 = (int *)(v14 + 52);
          v26 = (int *)(v14 + 52);
          do
          {
            v17 = *(v16 - 5);
            v18 = 0;
            if ( v15 <= 0 )
              goto LABEL_28;
            v19 = (_DWORD *)(v14 + 32);
            while ( v17 != *v19 )
            {
              ++v18;
              ++v19;
              if ( v18 >= v15 )
                goto LABEL_28;
            }
            v20 = *(_DWORD *)(v14 + 4 * v18 + 52);
            if ( !v20 )
            {
LABEL_28:
              v27 = (*(int (__cdecl **)(_DWORD *, int, int))a1[1])(a1, 1, 1024);
              v21 = (v17 << 9) - 512;
              v22 = dbl_10050850;
              v23 = v27;
              do
              {
                for ( i = 0; i < 16; ++i )
                {
                  v23 += 4;
                  v25 = (65025 - 510 * *((unsigned __int8 *)v22 + i)) / v21;
                  *(_DWORD *)(v23 - 4) = v25;
                }
                v22 += 2;
              }
              while ( (int)v22 < (int)&dbl_10050950 );
              v20 = v27;
              v16 = v26;
              v14 = v28;
              v15 = v30;
            }
            *v16 = v20;
            result = a1[25];
            ++v15;
            ++v16;
            v30 = v15;
            v26 = v16;
          }
          while ( v15 < result );
        }
      }
    }
  }
  else if ( a1[25] == 3 )
  {
    *(_DWORD *)(v2 + 4) = sub_10044950;
  }
  else
  {
    *(_DWORD *)(v2 + 4) = sub_10044890;
  }
  return result;
}

// sub_10044890 @ 0x10044890
int __cdecl sub_10044890(_DWORD *a1, int a2, _DWORD *a3, int a4)
{
  int v4; // ebp
  int v5; // edi
  int result; // eax
  _DWORD *v7; // edx
  int v8; // ebx
  unsigned __int8 *v9; // esi
  char v10; // cl
  int *v11; // eax
  int v12; // ebx
  bool v13; // zf
  int *v14; // [esp+8h] [ebp-10h]
  int v15; // [esp+Ch] [ebp-Ch]
  int v16; // [esp+10h] [ebp-8h]
  int v17; // [esp+14h] [ebp-4h]
  _BYTE *v18; // [esp+1Ch] [ebp+4h]
  int v19; // [esp+20h] [ebp+8h]
  int v20; // [esp+28h] [ebp+10h]

  v4 = a1[23];
  v5 = a1[25];
  result = a4;
  v14 = *(int **)(a1[105] + 24);
  v17 = v4;
  v15 = v5;
  if ( a4 > 0 )
  {
    v7 = a3;
    v8 = a2 - (_DWORD)a3;
    v16 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      v9 = *(unsigned __int8 **)((char *)v7 + v8);
      v18 = (_BYTE *)*v7;
      if ( v4 )
      {
        v20 = v4;
        do
        {
          v10 = 0;
          if ( v5 > 0 )
          {
            v11 = v14;
            do
            {
              v12 = *v11++;
              v10 += *(_BYTE *)(v12 + *v9++);
              --v5;
            }
            while ( v5 );
            v5 = v15;
          }
          *v18++ = v10;
          --v20;
        }
        while ( v20 );
        v8 = v16;
        v7 = a3;
        v4 = v17;
      }
      ++v7;
      result = v19 - 1;
      v13 = v19 == 1;
      a3 = v7;
      --v19;
    }
    while ( !v13 );
  }
  return result;
}

// sub_10044950 @ 0x10044950
int __cdecl sub_10044950(int a1, int a2, _DWORD *a3, int a4)
{
  int *v4; // eax
  int v5; // edx
  int result; // eax
  int v7; // edi
  _DWORD *v8; // ecx
  int v9; // edx
  unsigned __int8 *v10; // eax
  _BYTE *v11; // esi
  char v12; // cl
  int v13; // edx
  unsigned __int8 *v14; // eax
  char v15; // bl
  bool v16; // zf
  int v17; // [esp+4h] [ebp-10h]
  int v18; // [esp+8h] [ebp-Ch]
  int v19; // [esp+Ch] [ebp-8h]
  int v20; // [esp+10h] [ebp-4h]
  _DWORD *v21; // [esp+18h] [ebp+4h]
  int v22; // [esp+20h] [ebp+Ch]

  v4 = *(int **)(*(_DWORD *)(a1 + 420) + 24);
  v17 = *v4;
  v5 = v4[1];
  v19 = v4[2];
  result = a4;
  v7 = *(_DWORD *)(a1 + 92);
  v18 = v5;
  v20 = v7;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v21 = a3;
    v22 = a2 - (_DWORD)a3;
    do
    {
      v10 = *(unsigned __int8 **)((char *)v8 + v9);
      v11 = (_BYTE *)*v8;
      if ( v7 )
      {
        do
        {
          v12 = *(_BYTE *)(*v10 + v17);
          v13 = v10[1];
          v14 = v10 + 1;
          v15 = *(_BYTE *)(v14[1] + v19);
          v10 = v14 + 2;
          *v11++ = v15 + *(_BYTE *)(v13 + v18) + v12;
          --v7;
        }
        while ( v7 );
        v7 = v20;
        v8 = v21;
        v9 = v22;
      }
      ++v8;
      result = a4 - 1;
      v16 = a4 == 1;
      v21 = v8;
      --a4;
    }
    while ( !v16 );
  }
  return result;
}

// sub_10044A10 @ 0x10044A10
int __cdecl sub_10044A10(_DWORD *a1, int a2, void **a3, int a4)
{
  _DWORD *v4; // edi
  int result; // eax
  void **v6; // ebx
  int v7; // esi
  int v8; // edx
  int v9; // esi
  int v10; // ebp
  _BYTE *v11; // ecx
  int v12; // edi
  int v13; // esi
  unsigned __int8 *v14; // eax
  bool v15; // zf
  int v16; // [esp+4h] [ebp-1Ch]
  _DWORD *v17; // [esp+8h] [ebp-18h]
  void **v18; // [esp+Ch] [ebp-14h]
  int v19; // [esp+10h] [ebp-10h]
  int v20; // [esp+14h] [ebp-Ch]
  int v21; // [esp+18h] [ebp-8h]
  char v22; // [esp+1Ch] [ebp-4h]
  unsigned int v23; // [esp+24h] [ebp+4h]
  int v24; // [esp+28h] [ebp+8h]
  unsigned int v25; // [esp+2Ch] [ebp+Ch]
  _DWORD *v26; // [esp+30h] [ebp+10h]

  v4 = (_DWORD *)a1[105];
  result = a4;
  v17 = v4;
  v16 = a1[25];
  v23 = a1[23];
  if ( a4 > 0 )
  {
    v6 = a3;
    v18 = a3;
    v21 = a2 - (_DWORD)a3;
    v19 = a4;
    do
    {
      sub_1003E510(*v6, v23);
      v7 = v4[12];
      v8 = 0;
      v22 = v7;
      v24 = 0;
      if ( v16 > 0 )
      {
        v9 = v7 << 6;
        v20 = v9;
        v26 = v4 + 13;
        while ( 1 )
        {
          v10 = *(_DWORD *)(v4[6] + 4 * v8);
          v11 = *v6;
          v12 = v9 + *v26;
          v13 = 0;
          v14 = (unsigned __int8 *)(*(char **)((char *)v6 + v21) + v8);
          if ( v23 )
          {
            v25 = v23;
            do
            {
              *v11 += *(_BYTE *)(*v14 + *(_DWORD *)(v12 + 4 * v13) + v10);
              v14 += v16;
              ++v11;
              v13 = ((_BYTE)v13 + 1) & 0xF;
              --v25;
            }
            while ( v25 );
            v8 = v24;
            v6 = v18;
          }
          v24 = ++v8;
          ++v26;
          if ( v8 >= v16 )
            break;
          v9 = v20;
          v4 = v17;
        }
        v4 = v17;
        LOBYTE(v7) = v22;
      }
      ++v6;
      result = v19 - 1;
      v15 = v19 == 1;
      v4[12] = ((_BYTE)v7 + 1) & 0xF;
      v18 = v6;
      --v19;
    }
    while ( !v15 );
  }
  return result;
}

// sub_10044B40 @ 0x10044B40
int __cdecl sub_10044B40(int a1, int a2, _BYTE **a3, int a4)
{
  _DWORD *v4; // edx
  int *v5; // eax
  int v6; // esi
  int result; // eax
  _BYTE **v8; // ebx
  int v9; // eax
  unsigned __int8 *v10; // eax
  int v11; // ebp
  int v12; // edi
  int v13; // esi
  char v14; // cl
  int v15; // edx
  unsigned __int8 *v16; // eax
  int v17; // ebx
  bool v18; // zf
  int v19; // [esp+4h] [ebp-24h]
  int v20; // [esp+8h] [ebp-20h]
  int v21; // [esp+Ch] [ebp-1Ch]
  int v22; // [esp+10h] [ebp-18h]
  int v23; // [esp+14h] [ebp-14h]
  int v24; // [esp+18h] [ebp-10h]
  int v25; // [esp+1Ch] [ebp-Ch]
  _DWORD *v26; // [esp+20h] [ebp-8h]
  int v27; // [esp+24h] [ebp-4h]
  _BYTE *v28; // [esp+2Ch] [ebp+4h]
  int v29; // [esp+30h] [ebp+8h]
  int v30; // [esp+38h] [ebp+10h]

  v4 = *(_DWORD **)(a1 + 420);
  v5 = (int *)v4[6];
  v22 = *v5;
  v6 = v5[1];
  result = v5[2];
  v20 = *(_DWORD *)(a1 + 92);
  v26 = v4;
  v23 = v6;
  v25 = result;
  if ( a4 > 0 )
  {
    v8 = a3;
    v9 = a2 - (_DWORD)a3;
    v19 = a2 - (_DWORD)a3;
    v29 = a4;
    while ( 1 )
    {
      v10 = *(_BYTE **)((char *)v8 + v9);
      v28 = *v8;
      v27 = v4[12];
      v11 = (v27 << 6) + v4[14];
      v12 = (v27 << 6) + v4[13];
      v24 = (v27 << 6) + v4[15];
      v13 = 0;
      v21 = v11;
      if ( v20 )
      {
        v30 = v20;
        while ( 1 )
        {
          v14 = *(_BYTE *)(*v10 + *(_DWORD *)(v12 + 4 * v13) + v22);
          v15 = v10[1];
          v16 = v10 + 1;
          v17 = v16[1] + *(_DWORD *)(v24 + 4 * v13);
          v10 = v16 + 2;
          *v28 = *(_BYTE *)(v17 + v25) + *(_BYTE *)(v15 + *(_DWORD *)(v11 + 4 * v13) + v23) + v14;
          v13 = ((_BYTE)v13 + 1) & 0xF;
          v18 = v30 == 1;
          ++v28;
          --v30;
          if ( v18 )
            break;
          v11 = v21;
        }
        v4 = v26;
        v8 = a3;
      }
      v4[12] = ((_BYTE)v27 + 1) & 0xF;
      ++v8;
      result = v29 - 1;
      v18 = v29 == 1;
      a3 = v8;
      --v29;
      if ( v18 )
        break;
      v9 = v19;
    }
  }
  return result;
}

// sub_10044C70 @ 0x10044C70
int __cdecl sub_10044C70(_DWORD *a1, int a2, void **a3, int a4)
{
  int v4; // edx
  int v5; // ebx
  int v6; // esi
  int result; // eax
  void **v8; // edi
  int v9; // edx
  _BYTE *v10; // ebp
  unsigned __int8 *v11; // ecx
  int v12; // edi
  _WORD *v13; // esi
  int v14; // eax
  __int16 v15; // bx
  int v16; // eax
  int v17; // eax
  int v18; // ecx
  int v19; // edx
  bool v20; // zf
  int v21; // [esp+8h] [ebp-30h]
  void **v22; // [esp+Ch] [ebp-2Ch]
  __int16 v23; // [esp+10h] [ebp-28h]
  int v24; // [esp+14h] [ebp-24h]
  unsigned int v25; // [esp+18h] [ebp-20h]
  int v26; // [esp+1Ch] [ebp-1Ch]
  int v27; // [esp+20h] [ebp-18h]
  int v28; // [esp+24h] [ebp-14h]
  int v29; // [esp+28h] [ebp-10h]
  int v30; // [esp+2Ch] [ebp-Ch]
  int v31; // [esp+30h] [ebp-8h]
  int v32; // [esp+34h] [ebp-4h]
  unsigned int v33; // [esp+3Ch] [ebp+4h]
  __int16 v34; // [esp+40h] [ebp+8h]
  unsigned __int8 *v35; // [esp+44h] [ebp+Ch]
  _DWORD *v36; // [esp+48h] [ebp+10h]

  v4 = a1[71];
  v5 = a1[105];
  v6 = a1[25];
  result = a4;
  v27 = v5;
  v21 = v6;
  v33 = a1[23];
  v30 = v4;
  if ( a4 > 0 )
  {
    v8 = a3;
    v22 = a3;
    v29 = a2 - (_DWORD)a3;
    v28 = a4;
    do
    {
      sub_1003E510(*v8, v33);
      v9 = 0;
      v26 = 0;
      if ( v6 > 0 )
      {
        v36 = (_DWORD *)(v5 + 68);
        do
        {
          v10 = *v8;
          v11 = (unsigned __int8 *)(*(char **)((char *)v8 + v29) + v9);
          v35 = v11;
          if ( *(_BYTE *)(v5 + 84) )
          {
            v10 += v33 - 1;
            v11 += v6 * (v33 - 1);
            v12 = -1;
            v24 = -v6;
            v35 = v11;
            v13 = (_WORD *)(*v36 + 2 * v33 + 2);
          }
          else
          {
            v24 = v6;
            v13 = (_WORD *)*v36;
            v12 = 1;
          }
          v31 = *(_DWORD *)(*(_DWORD *)(v5 + 24) + 4 * v9);
          v14 = *(_DWORD *)(*(_DWORD *)(v5 + 16) + 4 * v9);
          v15 = 0;
          v32 = v14;
          v16 = 0;
          v34 = 0;
          v23 = 0;
          if ( v33 )
          {
            v25 = v33;
            do
            {
              v17 = *(unsigned __int8 *)(*v11 + (((__int16)v13[v12] + v16 + 8) >> 4) + v30);
              v18 = *(unsigned __int8 *)(v17 + v31);
              *v10 += v18;
              v10 += v12;
              v19 = v17 - *(unsigned __int8 *)(v18 + v32);
              *v13 = 3 * v19 + v34;
              v15 = 5 * v19 + v23;
              v23 = v19;
              v16 = 7 * v19;
              v11 = &v35[v24];
              v20 = v25 == 1;
              v34 = v15;
              v35 += v24;
              v13 += v12;
              --v25;
            }
            while ( !v20 );
            v9 = v26;
          }
          v8 = v22;
          ++v9;
          *v13 = v15;
          v5 = v27;
          v26 = v9;
          ++v36;
          v6 = v21;
        }
        while ( v9 < v21 );
      }
      *(_BYTE *)(v5 + 84) = *(_BYTE *)(v5 + 84) == 0;
      ++v8;
      result = v28 - 1;
      v20 = v28 == 1;
      v22 = v8;
      --v28;
    }
    while ( !v20 );
  }
  return result;
}

// sub_10044E30 @ 0x10044E30
int __cdecl sub_10044E30(int a1)
{
  *(_DWORD *)(*(_DWORD *)a1 + 20) = 45;
  return (**(int (__cdecl ***)(int))a1)(a1);
}

// sub_10044E50 @ 0x10044E50
int __cdecl sub_10044E50(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // edx
  __int16 *v6; // ebx
  int v7; // ebp
  int *v8; // ecx
  __int16 v9; // ax
  int v10; // eax
  __int16 v11; // di
  __int16 v12; // bp
  int v13; // esi
  int v14; // ebp
  int v15; // edi
  int v16; // eax
  int v17; // esi
  int v18; // eax
  int v19; // ebx
  int v20; // eax
  int v21; // edi
  int v22; // esi
  int v23; // ebx
  __int16 *v24; // esi
  int v25; // edi
  int v26; // ebx
  _BYTE *v27; // ecx
  char v28; // al
  int v29; // edx
  int v30; // ebp
  int v31; // edi
  int v32; // eax
  int v33; // esi
  int v34; // edx
  int v35; // esi
  int v36; // edi
  int v37; // eax
  int v38; // ebp
  int v39; // eax
  int v40; // eax
  bool v41; // zf
  int result; // eax
  __int16 v43; // [esp+Ch] [ebp-138h]
  int v44; // [esp+Ch] [ebp-138h]
  int v45; // [esp+Ch] [ebp-138h]
  __int16 v46; // [esp+10h] [ebp-134h]
  __int16 v47; // [esp+10h] [ebp-134h]
  int v48; // [esp+10h] [ebp-134h]
  int v49; // [esp+10h] [ebp-134h]
  int v50; // [esp+10h] [ebp-134h]
  int v51; // [esp+14h] [ebp-130h]
  int v52; // [esp+14h] [ebp-130h]
  __int16 *v53; // [esp+14h] [ebp-130h]
  int v54; // [esp+18h] [ebp-12Ch]
  int v55; // [esp+18h] [ebp-12Ch]
  int v56; // [esp+1Ch] [ebp-128h]
  __int16 v57; // [esp+20h] [ebp-124h]
  int v58; // [esp+20h] [ebp-124h]
  __int16 v60; // [esp+24h] [ebp-120h]
  int v61; // [esp+24h] [ebp-120h]
  int v62; // [esp+24h] [ebp-120h]
  __int16 *v63; // [esp+28h] [ebp-11Ch]
  int v64; // [esp+28h] [ebp-11Ch]
  int v65; // [esp+2Ch] [ebp-118h]
  int v66; // [esp+2Ch] [ebp-118h]
  __int16 v67; // [esp+30h] [ebp-114h]
  int v68; // [esp+30h] [ebp-114h]
  int v69; // [esp+34h] [ebp-110h]
  int v70; // [esp+34h] [ebp-110h]
  int v71; // [esp+38h] [ebp-10Ch]
  int v72; // [esp+38h] [ebp-10Ch]
  int v73; // [esp+3Ch] [ebp-108h]
  int v74; // [esp+3Ch] [ebp-108h]
  int v75; // [esp+40h] [ebp-104h]
  _BYTE v76[256]; // [esp+44h] [ebp-100h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  v6 = a3;
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v75 = v7;
  v63 = a3;
  v8 = (int *)v76;
  v65 = 8;
  do
  {
    v46 = v6[40];
    v57 = v6[32];
    v60 = v6[24];
    v43 = v6[56];
    v9 = v6[48];
    v67 = v6[8];
    if ( (unsigned __int16)v43 | (unsigned __int16)(v9 | v46 | v57 | v60 | v6[16] | v67) )
    {
      v11 = v6[16] * v5[16];
      v12 = v9 * v5[48];
      v13 = 4433 * (__int16)(v11 + v12);
      v14 = v13 - 15137 * v12;
      v51 = v13 + 6270 * v11;
      v15 = v57 * v5[32];
      v16 = *v5 * *v6;
      v17 = v15 + v16;
      v18 = (v16 - v15) << 13;
      v17 <<= 13;
      v19 = v17 + v51;
      v73 = v17 - v51;
      v69 = v18 - v14;
      v71 = v18 + v14;
      LOWORD(v17) = v43 * v5[56];
      v58 = v19;
      LOWORD(v15) = v46 * v5[40];
      LOWORD(v18) = v60 * v5[24];
      v52 = v67 * v5[8];
      LOWORD(v14) = v17 + v18;
      v47 = v18;
      v61 = 9633 * (__int16)(v17 + v18 + v15 + v52);
      v54 = -7373 * (__int16)(v17 + v52);
      v20 = -20995 * (__int16)(v15 + v18);
      v44 = v61 - 16069 * (__int16)v14;
      v56 = v61 - 3196 * (__int16)(v15 + v52);
      v21 = v20 + v56 + 16819 * (__int16)v15;
      v48 = v20 + v44 + 25172 * v47;
      v22 = v44 + v54 + 2446 * (__int16)v17;
      v23 = v54 + (__int16)v52 + v56 + 12298 * (__int16)v52;
      v8[56] = (v58 - v23 + 1024) >> 11;
      *v8 = (v58 + v23 + 1024) >> 11;
      v8[48] = (v71 - v48 + 1024) >> 11;
      v8[8] = (v71 + v48 + 1024) >> 11;
      v7 = v75;
      v8[40] = (v69 - v21 + 1024) >> 11;
      v8[16] = (v69 + v21 + 1024) >> 11;
      v6 = v63 + 1;
      v8[24] = (v73 + v22 + 1024) >> 11;
      v8[32] = (v73 - v22 + 1024) >> 11;
    }
    else
    {
      v10 = 4 * *v5 * *v6++;
      *v8 = v10;
      v8[8] = v10;
      v8[16] = v10;
      v8[24] = v10;
      v8[32] = v10;
      v8[40] = v10;
      v8[48] = v10;
      v8[56] = v10;
    }
    ++v5;
    v63 = v6;
    ++v8;
    --v65;
  }
  while ( v65 );
  v24 = (__int16 *)v76;
  v53 = (__int16 *)v76;
  v68 = 8;
  do
  {
    v25 = *((_DWORD *)v24 + 6);
    v26 = *((_DWORD *)v24 + 7);
    v27 = (_BYTE *)(a5 + *a4);
    v66 = *((_DWORD *)v24 + 4);
    v64 = *((_DWORD *)v24 + 5);
    v45 = *((_DWORD *)v24 + 3);
    v49 = *((_DWORD *)v24 + 1);
    if ( v26 | v25 | v64 | v66 | v45 | *((_DWORD *)v24 + 2) | v49 )
    {
      v29 = 4433 * (__int16)(v25 + *((_DWORD *)v24 + 2));
      v30 = v29 - 15137 * (__int16)v25;
      v31 = v29 + 6270 * v24[4];
      v32 = (*(_DWORD *)v24 - v66) << 13;
      v33 = (*(_DWORD *)v24 + v66) << 13;
      v34 = v33 + v31;
      v35 = v33 - v31;
      v36 = v32 + v30;
      v70 = v32 - v30;
      v62 = 9633 * (__int16)(v26 + v45 + v49 + v64);
      v55 = -7373 * (__int16)(v26 + v49);
      v37 = -20995 * (__int16)(v45 + v64);
      v72 = v62 - 16069 * (__int16)(v26 + v45) + v55 + 2446 * v53[14];
      v74 = v37 + v62 - 3196 * (__int16)(v49 + v64) + 16819 * v53[10];
      v38 = v62 - 3196 * (__int16)(v49 + v64);
      v50 = v37 + v62 - 16069 * (__int16)(v26 + v45) + 25172 * v53[6];
      v39 = v53[2] + v38 + 12298 * v53[2];
      v7 = v75;
      v40 = v55 + v39;
      *v27 = *(_BYTE *)((((v34 + v40 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[7] = *(_BYTE *)((((v34 - v40 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[1] = *(_BYTE *)((((v36 + v50 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[6] = *(_BYTE *)((((v36 - v50 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[2] = *(_BYTE *)((((v70 + v74 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[5] = *(_BYTE *)((((v70 - v74 + 0x20000) >> 18) & 0x3FF) + v75);
      v27[3] = *(_BYTE *)((((v35 + v72 + 0x20000) >> 18) & 0x3FF) + v75);
      LOBYTE(v40) = *(_BYTE *)((((v35 - v72 + 0x20000) >> 18) & 0x3FF) + v75);
      v24 = v53;
      v27[4] = v40;
    }
    else
    {
      v28 = *(_BYTE *)((((*(_DWORD *)v24 + 16) >> 5) & 0x3FF) + v7);
      *v27 = v28;
      v27[1] = v28;
      v27[2] = v28;
      v27[3] = v28;
      v27[4] = v28;
      v27[5] = v28;
      v27[6] = v28;
      v27[7] = v28;
    }
    v24 += 16;
    result = v68 - 1;
    v41 = v68 == 1;
    v53 = v24;
    ++a4;
    --v68;
  }
  while ( !v41 );
  return result;
}

// sub_100454A0 @ 0x100454A0
int __cdecl sub_100454A0(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  __int16 *v5; // edx
  _DWORD *v6; // ecx
  int v7; // esi
  int *v8; // eax
  __int16 v9; // bx
  int v10; // edi
  int v11; // edx
  int v12; // esi
  int v13; // edi
  int v14; // ebx
  int v15; // ebp
  int v16; // edx
  int v17; // edi
  int v18; // esi
  int v19; // ebx
  int v20; // ebp
  int v21; // edi
  int v22; // edx
  int v23; // edi
  int v24; // esi
  int v25; // ebx
  int v26; // ebp
  int v27; // esi
  int v28; // ebp
  int v29; // edi
  int v30; // ebx
  int v31; // edx
  int v32; // esi
  int v33; // ebp
  int v34; // ebx
  int v35; // edi
  int *v36; // ecx
  int v37; // edi
  _BYTE *v38; // eax
  int v39; // edx
  char v40; // dl
  int v41; // ecx
  int v42; // ebp
  int v43; // edx
  int v44; // ebx
  int v45; // ecx
  int v46; // edi
  int v47; // ebp
  int v48; // ecx
  int v49; // edx
  int v50; // ecx
  int v51; // edx
  bool v52; // zf
  int result; // eax
  __int16 *v54; // [esp+10h] [ebp-130h]
  int v55; // [esp+10h] [ebp-130h]
  int v56; // [esp+10h] [ebp-130h]
  int v57; // [esp+14h] [ebp-12Ch]
  int v58; // [esp+14h] [ebp-12Ch]
  int v59; // [esp+18h] [ebp-128h]
  int v60; // [esp+18h] [ebp-128h]
  int v61; // [esp+18h] [ebp-128h]
  __int16 v62; // [esp+1Ch] [ebp-124h]
  int v63; // [esp+1Ch] [ebp-124h]
  int v64; // [esp+1Ch] [ebp-124h]
  __int16 v65; // [esp+20h] [ebp-120h]
  int v66; // [esp+20h] [ebp-120h]
  __int16 v68; // [esp+24h] [ebp-11Ch]
  int *v69; // [esp+24h] [ebp-11Ch]
  __int16 v70; // [esp+28h] [ebp-118h]
  int v71; // [esp+28h] [ebp-118h]
  int v72; // [esp+28h] [ebp-118h]
  __int16 v73; // [esp+2Ch] [ebp-114h]
  int v74; // [esp+2Ch] [ebp-114h]
  int v75; // [esp+2Ch] [ebp-114h]
  __int16 v76; // [esp+30h] [ebp-110h]
  int v77; // [esp+30h] [ebp-110h]
  int v78; // [esp+30h] [ebp-110h]
  int v79; // [esp+34h] [ebp-10Ch]
  int v80; // [esp+34h] [ebp-10Ch]
  int v81; // [esp+38h] [ebp-108h]
  int v82; // [esp+38h] [ebp-108h]
  int v83; // [esp+3Ch] [ebp-104h]
  int v84; // [esp+3Ch] [ebp-104h]
  _BYTE v85[256]; // [esp+40h] [ebp-100h] BYREF

  v5 = a3;
  v6 = *(_DWORD **)(a2 + 80);
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v81 = v7;
  v54 = a3;
  v8 = (int *)v85;
  v59 = 8;
  do
  {
    v9 = v5[48];
    v62 = v5[56];
    v73 = v5[40];
    v65 = v5[32];
    v68 = v5[24];
    v70 = v5[8];
    v76 = v5[16];
    if ( (unsigned __int16)v62 | (unsigned __int16)(v9 | v73 | v65 | v68 | v76 | v70) )
    {
      v11 = *v6 * *v5;
      v12 = v76 * v6[16];
      v13 = v65 * v6[32];
      v14 = v9 * v6[48];
      v15 = v13 + v11;
      v16 = v11 - v13;
      v17 = v14 + v12;
      v18 = ((362 * (v12 - v14)) >> 8) - (v14 + v12);
      v19 = v17 + v15;
      v20 = v15 - v17;
      v21 = v18 + v16;
      v79 = v16 - v18;
      v22 = v70 * v6[8];
      v77 = v19;
      v83 = v21;
      v23 = v68 * v6[24];
      v24 = v73 * v6[40];
      v66 = v20;
      v25 = v62 * v6[56];
      v26 = v24 + v23;
      v27 = v24 - v23;
      v63 = v26;
      v28 = v25 + v22;
      v29 = v22 - v25;
      v57 = v25 + v22 + v63;
      v30 = (473 * (v22 - v25 + v27)) >> 8;
      v31 = v30 + ((-669 * v27) >> 8) - v57;
      v74 = v30;
      v32 = ((362 * (v28 - v63)) >> 8) - v31;
      *v8 = v77 + v57;
      v8[56] = v77 - v57;
      v33 = v31 + v83;
      v8[48] = v83 - v31;
      v34 = v32 + v79;
      v8[40] = v79 - v32;
      v35 = v32 + ((277 * v29) >> 8) - v74;
      v8[24] = v66 - v35;
      v5 = v54 + 1;
      v8[32] = v35 + v66;
      v7 = v81;
      v8[8] = v33;
      v8[16] = v34;
    }
    else
    {
      v10 = *v6 * *v5++;
      *v8 = v10;
      v8[8] = v10;
      v8[16] = v10;
      v8[24] = v10;
      v8[32] = v10;
      v8[40] = v10;
      v8[48] = v10;
      v8[56] = v10;
    }
    ++v6;
    v54 = v5;
    ++v8;
    --v59;
  }
  while ( v59 );
  v36 = (int *)v85;
  v69 = (int *)v85;
  v78 = 8;
  do
  {
    v37 = v36[2];
    v38 = (_BYTE *)(a5 + *a4);
    v58 = v36[7];
    v71 = v36[1];
    v55 = v36[6];
    v60 = v36[5];
    v39 = v36[4];
    v82 = v36[3];
    if ( v58 | v55 | v60 | v39 | v82 | v37 | v71 )
    {
      v41 = *v36;
      v42 = v41 + v39;
      v43 = v41 - v39;
      v44 = v37 + v55;
      v45 = 181 * (v37 - v55);
      v46 = v37 + v55 + v42;
      v47 = v42 - v44;
      v48 = (char)(v45 >> 7) - v44;
      v84 = v48 + v43;
      v80 = v43 - v48;
      v49 = v60 - v82;
      v64 = v82 + v60;
      v61 = v71 + v58;
      v72 = v71 - v58;
      v75 = (473 * (v49 + v72)) >> 8;
      v50 = v75 + ((-669 * v49) >> 8) - (v64 + v61);
      v56 = ((362 * (v61 - v64)) >> 8) - v50;
      v51 = v56 + ((277 * v72) >> 8) - v75;
      *v38 = *(_BYTE *)((((v46 + v64 + v61) >> 5) & 0x3FF) + v7);
      v38[7] = *(_BYTE *)((((v46 - (v64 + v61)) >> 5) & 0x3FF) + v7);
      v38[1] = *(_BYTE *)((((v50 + v84) >> 5) & 0x3FF) + v7);
      v38[6] = *(_BYTE *)((((v84 - v50) >> 5) & 0x3FF) + v7);
      v38[2] = *(_BYTE *)((((v80 + v56) >> 5) & 0x3FF) + v7);
      v38[5] = *(_BYTE *)((((v80 - v56) >> 5) & 0x3FF) + v7);
      v38[4] = *(_BYTE *)((((v51 + v47) >> 5) & 0x3FF) + v7);
      v36 = v69;
      v38[3] = *(_BYTE *)(v7 + (((v47 - v51) >> 5) & 0x3FF));
    }
    else
    {
      v40 = *(_BYTE *)(((*v36 >> 5) & 0x3FF) + v7);
      *v38 = v40;
      v38[1] = v40;
      v38[2] = v40;
      v38[3] = v40;
      v38[4] = v40;
      v38[5] = v40;
      v38[6] = v40;
      v38[7] = v40;
    }
    v36 += 8;
    result = v78 - 1;
    v52 = v78 == 1;
    v69 = v36;
    ++a4;
    --v78;
  }
  while ( !v52 );
  return result;
}

// sub_10045930 @ 0x10045930
int __cdecl sub_10045930(int a1, int a2, __int16 *a3, _DWORD *a4, int a5)
{
  float *v6; // ecx
  int v7; // ebx
  float *v8; // eax
  __int16 v9; // si
  __int16 v10; // di
  double v11; // st7
  double v12; // st6
  double v13; // st7
  double v14; // st6
  double v15; // st7
  double v16; // st6
  double v17; // st5
  double v18; // st4
  double v19; // st6
  double v20; // st5
  float *v22; // esi
  double v23; // st7
  _BYTE *v24; // edi
  double v25; // st6
  double v26; // st7
  double v27; // st6
  double v28; // st5
  double v29; // st4
  int result; // eax
  float v31; // [esp+10h] [ebp-124h]
  float v32; // [esp+10h] [ebp-124h]
  float v33; // [esp+14h] [ebp-120h]
  float v34; // [esp+14h] [ebp-120h]
  float v35; // [esp+14h] [ebp-120h]
  float v36; // [esp+14h] [ebp-120h]
  float v37; // [esp+14h] [ebp-120h]
  float v38; // [esp+14h] [ebp-120h]
  float v39; // [esp+18h] [ebp-11Ch]
  float v40; // [esp+18h] [ebp-11Ch]
  float v41; // [esp+18h] [ebp-11Ch]
  float v42; // [esp+18h] [ebp-11Ch]
  float v43; // [esp+1Ch] [ebp-118h]
  float v44; // [esp+1Ch] [ebp-118h]
  float v45; // [esp+1Ch] [ebp-118h]
  float v46; // [esp+20h] [ebp-114h]
  float v47; // [esp+20h] [ebp-114h]
  float v48; // [esp+20h] [ebp-114h]
  int v49; // [esp+24h] [ebp-110h]
  float v50; // [esp+24h] [ebp-110h]
  float v51; // [esp+24h] [ebp-110h]
  float v52; // [esp+28h] [ebp-10Ch]
  float v53; // [esp+28h] [ebp-10Ch]
  int v54; // [esp+28h] [ebp-10Ch]
  float v55; // [esp+2Ch] [ebp-108h]
  float v56; // [esp+2Ch] [ebp-108h]
  float v57; // [esp+30h] [ebp-104h]
  float v58; // [esp+30h] [ebp-104h]
  char v59; // [esp+34h] [ebp-100h] BYREF
  char v60; // [esp+3Ch] [ebp-F8h] BYREF

  v6 = *(float **)(a2 + 80);
  v7 = *(_DWORD *)(a1 + 284) + 128;
  v8 = (float *)&v59;
  v49 = 8;
  do
  {
    v9 = a3[56];
    v10 = a3[48];
    v11 = (double)*a3 * *v6;
    if ( (unsigned __int16)v9 | (unsigned __int16)(v10 | a3[40] | a3[32] | a3[24] | a3[16] | a3[8]) )
    {
      v52 = v6[16] * (double)a3[16];
      v12 = v6[32] * (double)a3[32];
      v46 = v6[48] * (double)v10;
      v39 = v12 + v11;
      v13 = v11 - v12;
      v14 = v46 + v52;
      v33 = (v52 - v46) * 1.4142135 - v14;
      v57 = v14 + v39;
      v47 = v39 - v14;
      v53 = v33 + v13;
      v15 = v13 - v33;
      v16 = v6[8] * (double)a3[8];
      v17 = v6[24] * (double)a3[24];
      v18 = v6[40] * (double)a3[40];
      v43 = v6[56] * (double)v9;
      v31 = v18 + v17;
      v40 = v18 - v17;
      v34 = v43 + v16;
      v19 = v16 - v43;
      v44 = v34 + v31;
      v20 = (v19 + v40) * 1.847759;
      v55 = v20 - v40 * 2.613126 - v44;
      v35 = (v34 - v31) * 1.4142135 - v55;
      v41 = v19 * 1.0823922 - v20 + v35;
      *v8 = v44 + v57;
      v8[56] = v57 - v44;
      v8[8] = v55 + v53;
      v8[48] = v53 - v55;
      v8[16] = v35 + v15;
      v8[40] = v15 - v35;
      v8[32] = v41 + v47;
      v8[24] = v47 - v41;
    }
    else
    {
      *v8 = v11;
      v8[8] = v11;
      v8[16] = v11;
      v8[24] = v11;
      v8[32] = v11;
      v8[40] = v11;
      v8[48] = v11;
      v8[56] = v11;
    }
    ++a3;
    ++v6;
    ++v8;
    --v49;
  }
  while ( v49 );
  v22 = (float *)&v60;
  v54 = 8;
  do
  {
    v23 = v22[2] + *(v22 - 2);
    v24 = (_BYTE *)(a5 + *a4);
    v50 = *(v22 - 2) - v22[2];
    v25 = v22[4] + *v22;
    v36 = (*v22 - v22[4]) * 1.4142135 - v25;
    v58 = v25 + v23;
    v26 = v23 - v25;
    v27 = v36 + v50;
    v48 = v50 - v36;
    v28 = v22[3] + v22[1];
    v29 = v22[3] - v22[1];
    v37 = v22[5] + *(v22 - 1);
    v51 = *(v22 - 1) - v22[5];
    v45 = v37 + v28;
    v32 = (v51 + v29) * 1.847759;
    v56 = v32 - v29 * 2.613126 - v45;
    v38 = (v37 - v28) * 1.4142135 - v56;
    v42 = v51 * 1.0823922 - v32 + v38;
    *v24 = *(_BYTE *)((((int)((__int64)(v45 + v58) + 4) >> 3) & 0x3FF) + v7);
    v24[7] = *(_BYTE *)((((int)((__int64)(v58 - v45) + 4) >> 3) & 0x3FF) + v7);
    v24[1] = *(_BYTE *)((((int)((__int64)(v56 + v27) + 4) >> 3) & 0x3FF) + v7);
    v24[6] = *(_BYTE *)((((int)((__int64)(v27 - v56) + 4) >> 3) & 0x3FF) + v7);
    v24[2] = *(_BYTE *)((((int)((__int64)(v38 + v48) + 4) >> 3) & 0x3FF) + v7);
    v24[5] = *(_BYTE *)((((int)((__int64)(v48 - v38) + 4) >> 3) & 0x3FF) + v7);
    v24[4] = *(_BYTE *)((((int)((__int64)(v42 + v26) + 4) >> 3) & 0x3FF) + v7);
    v24[3] = *(_BYTE *)((((int)((__int64)(v26 - v42) + 4) >> 3) & 0x3FF) + v7);
    v22 += 8;
    ++a4;
    result = --v54;
  }
  while ( v54 );
  return result;
}

// sub_10045D90 @ 0x10045D90
_BYTE *__cdecl sub_10045D90(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // edi
  int v6; // ebp
  _WORD *v7; // eax
  int v8; // edx
  int *v9; // ecx
  unsigned __int16 v10; // si
  __int16 v11; // dx
  int v12; // edx
  int v13; // eax
  int v14; // ecx
  int v15; // ebx
  __int16 v16; // bp
  int v17; // edx
  int v18; // ecx
  int v19; // esi
  int v20; // edx
  bool v21; // cc
  _BYTE *result; // eax
  int v23; // edi
  int v24; // ebx
  _BYTE *v25; // ecx
  char v26; // dl
  int v27; // esi
  int v28; // eax
  int v29; // edx
  int v30; // esi
  int v31; // ebx
  int v32; // eax
  bool v33; // zf
  __int16 v34; // [esp+10h] [ebp-A0h]
  int v35; // [esp+10h] [ebp-A0h]
  __int16 v37; // [esp+14h] [ebp-9Ch]
  int v38; // [esp+14h] [ebp-9Ch]
  int v39; // [esp+14h] [ebp-9Ch]
  __int16 v40; // [esp+18h] [ebp-98h]
  int v41; // [esp+18h] [ebp-98h]
  __int16 v42; // [esp+1Ch] [ebp-94h]
  _BYTE *v43; // [esp+1Ch] [ebp-94h]
  int *v44; // [esp+20h] [ebp-90h]
  int v45; // [esp+20h] [ebp-90h]
  int v46; // [esp+24h] [ebp-8Ch]
  int v47; // [esp+24h] [ebp-8Ch]
  _WORD *v48; // [esp+28h] [ebp-88h]
  int v49; // [esp+2Ch] [ebp-84h]
  _BYTE v50[32]; // [esp+30h] [ebp-80h] BYREF
  _BYTE v51[96]; // [esp+50h] [ebp-60h] BYREF

  v5 = *(_DWORD **)(a2 + 80);
  v6 = *(_DWORD *)(a1 + 284) + 128;
  v7 = (_WORD *)(a3 + 96);
  v8 = 8;
  v9 = (int *)v51;
  v49 = v6;
  v46 = 8;
  v48 = (_WORD *)(a3 + 96);
  v44 = (int *)v51;
  do
  {
    if ( v8 != 4 )
    {
      v10 = v7[8];
      v42 = *(v7 - 24);
      v34 = *(v7 - 32);
      v37 = *(v7 - 40);
      v40 = *v7;
      v11 = *(v7 - 8);
      if ( v10 | (unsigned __int16)(v11 | v42 | v37 | *v7 | v34) )
      {
        v13 = (*v5 * (__int16)*(v7 - 48)) << 14;
        v14 = 15137 * (__int16)(v34 * v5[16]) - 6270 * (__int16)(v40 * v5[48]);
        v15 = v14 + v13;
        v35 = v13 - v14;
        LOWORD(v13) = v11 * v5[40];
        v16 = v37 * v5[8];
        v38 = (__int16)(v10 * v5[56]);
        v17 = (__int16)(v42 * v5[24]);
        v18 = v16;
        v19 = 8697 * v16 + 11893 * (__int16)v13 - 17799 * v17 - 1730 * v38;
        v6 = v49;
        v20 = 20995 * v18 + 7373 * v17 - 4926 * (__int16)v13 - 4176 * v38;
        v9 = v44;
        *(v44 - 8) = (v15 + v20 + 2048) >> 12;
        v44[8] = (v35 - v19 + 2048) >> 12;
        v7 = v48;
        v44[16] = (v15 - v20 + 2048) >> 12;
        *v44 = (v35 + v19 + 2048) >> 12;
      }
      else
      {
        v12 = 4 * *v5 * (__int16)*(v7 - 48);
        *(v9 - 8) = v12;
        *v9 = v12;
        v9[8] = v12;
        v9[16] = v12;
      }
    }
    ++v7;
    ++v9;
    ++v5;
    v8 = v46 - 1;
    v21 = v46 - 1 <= 0;
    v48 = v7;
    v44 = v9;
    --v46;
  }
  while ( !v21 );
  result = v50;
  v43 = v50;
  v45 = 4;
  do
  {
    v23 = *((_DWORD *)result + 3);
    v24 = *((_DWORD *)result + 7);
    v25 = (_BYTE *)(*a4 + a5);
    v47 = *((_DWORD *)result + 5);
    v41 = *((_DWORD *)result + 1);
    if ( *((_DWORD *)result + 6) | v24 | v47 | v23 | v41 | *((_DWORD *)result + 2) )
    {
      v27 = *(_DWORD *)result;
      v28 = 15137 * *((__int16 *)result + 4) - 6270 * *((__int16 *)result + 12);
      v39 = (__int16)v24;
      v27 <<= 14;
      v29 = v28 + v27;
      v30 = v27 - v28;
      v31 = 8697 * (__int16)v41 + 11893 * (__int16)v47 - 17799 * (__int16)v23 - 1730 * (__int16)v24;
      v6 = v49;
      v32 = 20995 * (__int16)v41 + 7373 * (__int16)v23 - 4926 * (__int16)v47 - 4176 * v39;
      *v25 = *(_BYTE *)((((v29 + v32 + 0x40000) >> 19) & 0x3FF) + v49);
      v25[3] = *(_BYTE *)((((v29 - v32 + 0x40000) >> 19) & 0x3FF) + v49);
      result = v43;
      v25[1] = *(_BYTE *)((((v30 + v31 + 0x40000) >> 19) & 0x3FF) + v49);
      v25[2] = *(_BYTE *)((((v30 - v31 + 0x40000) >> 19) & 0x3FF) + v49);
    }
    else
    {
      v26 = *(_BYTE *)((((*(_DWORD *)result + 16) >> 5) & 0x3FF) + v6);
      *v25 = v26;
      v25[1] = v26;
      v25[2] = v26;
      v25[3] = v26;
    }
    result += 32;
    v33 = v45 == 1;
    v43 = result;
    ++a4;
    --v45;
  }
  while ( !v33 );
  return result;
}

// sub_10046190 @ 0x10046190
int __cdecl sub_10046190(int a1, int a2, int a3, _DWORD *a4, int a5)
{
  _DWORD *v5; // ecx
  int v6; // eax
  _WORD *v7; // edi
  _BYTE *v8; // ebx
  __int16 v9; // bp
  __int16 v10; // dx
  int v11; // eax
  int v12; // eax
  int v13; // eax
  int v14; // edx
  _BYTE *v15; // ecx
  _BYTE *v16; // edi
  char v17; // al
  int v18; // eax
  int v19; // esi
  bool v20; // zf
  int result; // eax
  int v22; // [esp+10h] [ebp-44h]
  _BYTE v23[64]; // [esp+14h] [ebp-40h] BYREF
  int v24; // [esp+58h] [ebp+4h]
  int v26; // [esp+5Ch] [ebp+8h]

  v5 = *(_DWORD **)(a2 + 80);
  v22 = *(_DWORD *)(a1 + 284) + 128;
  v6 = 8;
  v24 = 8;
  v7 = (_WORD *)(a3 + 48);
  v8 = (_BYTE *)(v23 - (_BYTE *)v5);
  do
  {
    if ( v6 != 6 && v6 != 4 && v6 != 2 )
    {
      v9 = v7[32];
      v10 = v7[16];
      v11 = (__int16)*(v7 - 24);
      if ( *v7 | (unsigned __int16)(*(v7 - 16) | v10 | v9) )
      {
        v13 = (*v5 * v11) << 15;
        v14 = 6967 * (__int16)(v10 * v5[40])
            - 5906 * (__int16)(v9 * v5[56])
            - 10426 * (__int16)(*v7 * v5[24])
            + 29692 * (__int16)(*(v7 - 16) * v5[8]);
        *(_DWORD *)((char *)v5 + (_DWORD)v8) = (v14 + v13 + 4096) >> 13;
        v12 = (v13 - v14 + 4096) >> 13;
      }
      else
      {
        v12 = 4 * *v5 * v11;
        *(_DWORD *)((char *)v5 + (_DWORD)v8) = v12;
      }
      *(_DWORD *)((char *)v5 + (_DWORD)v8 + 32) = v12;
      v6 = v24;
    }
    ++v7;
    ++v5;
    v24 = --v6;
  }
  while ( v6 > 0 );
  v15 = v23;
  v26 = 2;
  do
  {
    v16 = (_BYTE *)(*a4 + a5);
    if ( *((_DWORD *)v15 + 7) | *((_DWORD *)v15 + 5) | *((_DWORD *)v15 + 1) | *((_DWORD *)v15 + 3) )
    {
      v18 = *(_DWORD *)v15 << 15;
      v19 = 6967 * *((__int16 *)v15 + 10)
          + 29692 * *((__int16 *)v15 + 2)
          - 5906 * *((__int16 *)v15 + 14)
          - 10426 * *((__int16 *)v15 + 6);
      *v16 = *(_BYTE *)((((v19 + v18 + 0x80000) >> 20) & 0x3FF) + v22);
      v17 = *(_BYTE *)((((v18 - v19 + 0x80000) >> 20) & 0x3FF) + v22);
    }
    else
    {
      v17 = *(_BYTE *)((((*(_DWORD *)v15 + 16) >> 5) & 0x3FF) + v22);
      *v16 = v17;
    }
    v16[1] = v17;
    v15 += 32;
    result = v26 - 1;
    v20 = v26 == 1;
    ++a4;
    --v26;
  }
  while ( !v20 );
  return result;
}

// sub_100463C0 @ 0x100463C0
char __cdecl sub_100463C0(int a1, int a2, unsigned __int16 *a3, _DWORD *a4, int a5)
{
  char result; // al

  result = *(_BYTE *)((((*a3 * **(_DWORD **)(a2 + 80) + 4) >> 3) & 0x3FF) + *(_DWORD *)(a1 + 284) + 128);
  *(_BYTE *)(*a4 + a5) = result;
  return result;
}

// sub_10046400 @ 0x10046400
int __cdecl sub_10046400(int a1, int *a2, int a3, int a4)
{
  int v4; // eax
  int result; // eax
  int v6; // esi
  _DWORD v7[14]; // [esp+8h] [ebp-38h] BYREF

  v7[1] = a4;
  v7[0] = a3;
  v4 = *a2;
  v7[3] = a1;
  v7[4] = v4;
  v7[8] = 0;
  v7[9] = 0;
  result = sub_100475B0(v7, a113_0, 56);
  if ( !result )
  {
    v6 = sub_100475D0(v7, 4);
    if ( v6 == 1 )
    {
      *a2 = v7[5];
      return sub_100473F0(v7);
    }
    else
    {
      sub_100473F0(v7);
      result = -5;
      if ( v6 )
        return v6;
    }
  }
  return result;
}

// sub_100464A0 @ 0x100464A0
int __cdecl sub_100464A0(_DWORD *a1, int a2)
{
  unsigned int v2; // eax
  int v3; // ecx
  bool v4; // zf
  int v5; // ecx
  unsigned int v6; // edx
  unsigned int v7; // eax
  int v8; // edx
  int v9; // eax
  int v10; // esi
  unsigned int v11; // edx
  int v12; // ecx
  int v13; // ecx
  unsigned int v14; // edi
  _DWORD *v15; // eax
  int v16; // edx
  unsigned int v17; // ecx
  int v18; // eax
  int v19; // eax
  int v20; // esi
  unsigned int v21; // edx
  int v22; // ecx
  int v23; // ecx
  unsigned int v24; // edi
  _DWORD *v25; // eax
  int v26; // esi
  int v27; // eax
  int v28; // eax
  int v29; // esi
  unsigned int v30; // edx
  int v31; // ecx
  int v32; // ecx
  unsigned int v33; // edi
  _DWORD *v34; // eax
  int v36; // eax
  int v37; // [esp+10h] [ebp-4h]

  v37 = 0xFFFF;
  if ( (unsigned int)(a1[3] - 5) < 0xFFFF )
    v37 = a1[3] - 5;
  while ( 1 )
  {
    v2 = a1[27];
    if ( v2 <= 1 )
    {
      sub_10046740(a1);
      v2 = a1[27];
      if ( !v2 )
        break;
    }
    v3 = a1[25];
    a1[27] = 0;
    v4 = v2 + v3 == 0;
    a1[25] = v2 + v3;
    v5 = a1[21];
    v6 = a1[25];
    v7 = v5 + v37;
    if ( !v4 && v6 < v7 )
      goto LABEL_43;
    a1[25] = v7;
    a1[27] = v6 - v7;
    if ( v5 < 0 )
      v8 = 0;
    else
      v8 = v5 + a1[12];
    sub_10047B90(a1, v8, v37, 0);
    v9 = *a1;
    a1[21] = a1[25];
    v10 = *(_DWORD *)(v9 + 28);
    v11 = *(_DWORD *)(v10 + 20);
    if ( v11 > *(_DWORD *)(v9 + 16) )
      v11 = *(_DWORD *)(v9 + 16);
    if ( v11 )
    {
      qmemcpy(*(void **)(v9 + 12), *(const void **)(v10 + 16), v11);
      v12 = *(_DWORD *)(v9 + 28);
      *(_DWORD *)(v9 + 12) += v11;
      *(_DWORD *)(v12 + 16) += v11;
      v13 = *(_DWORD *)(v9 + 28);
      v14 = *(_DWORD *)(v9 + 16) - v11;
      *(_DWORD *)(v9 + 20) += v11;
      *(_DWORD *)(v9 + 16) = v14;
      *(_DWORD *)(v13 + 20) -= v11;
      v15 = *(_DWORD **)(v9 + 28);
      if ( !v15[5] )
        v15[4] = v15[2];
    }
    if ( *(_DWORD *)(*a1 + 16) )
    {
LABEL_43:
      v16 = a1[21];
      v17 = a1[25] - v16;
      if ( v17 < a1[9] - 262 )
        continue;
      if ( v16 < 0 )
        v18 = 0;
      else
        v18 = v16 + a1[12];
      sub_10047B90(a1, v18, v17, 0);
      v19 = *a1;
      a1[21] = a1[25];
      v20 = *(_DWORD *)(v19 + 28);
      v21 = *(_DWORD *)(v20 + 20);
      if ( v21 > *(_DWORD *)(v19 + 16) )
        v21 = *(_DWORD *)(v19 + 16);
      if ( v21 )
      {
        qmemcpy(*(void **)(v19 + 12), *(const void **)(v20 + 16), v21);
        v22 = *(_DWORD *)(v19 + 28);
        *(_DWORD *)(v19 + 12) += v21;
        *(_DWORD *)(v22 + 16) += v21;
        v23 = *(_DWORD *)(v19 + 28);
        v24 = *(_DWORD *)(v19 + 16) - v21;
        *(_DWORD *)(v19 + 20) += v21;
        *(_DWORD *)(v19 + 16) = v24;
        *(_DWORD *)(v23 + 20) -= v21;
        v25 = *(_DWORD **)(v19 + 28);
        if ( !v25[5] )
          v25[4] = v25[2];
      }
      if ( *(_DWORD *)(*a1 + 16) )
        continue;
    }
    return 0;
  }
  if ( !a2 )
    return 0;
  v26 = a1[21];
  if ( v26 < 0 )
    v27 = 0;
  else
    v27 = v26 + a1[12];
  sub_10047B90(a1, v27, a1[25] - v26, a2 == 4);
  a1[21] = a1[25];
  v28 = *a1;
  v29 = *(_DWORD *)(*a1 + 28);
  v30 = *(_DWORD *)(v29 + 20);
  if ( v30 > *(_DWORD *)(*a1 + 16) )
    v30 = *(_DWORD *)(*a1 + 16);
  if ( v30 )
  {
    qmemcpy(*(void **)(v28 + 12), *(const void **)(v29 + 16), v30);
    v31 = *(_DWORD *)(v28 + 28);
    *(_DWORD *)(v28 + 12) += v30;
    *(_DWORD *)(v31 + 16) += v30;
    v32 = *(_DWORD *)(v28 + 28);
    v33 = *(_DWORD *)(v28 + 16) - v30;
    *(_DWORD *)(v28 + 20) += v30;
    *(_DWORD *)(v28 + 16) = v33;
    *(_DWORD *)(v32 + 20) -= v30;
    v34 = *(_DWORD **)(v28 + 28);
    if ( !v34[5] )
      v34[4] = v34[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v36 = -(a2 != 4);
  LOBYTE(v36) = v36 & 0xFE;
  return v36 + 3;
}

// sub_10046740 @ 0x10046740
unsigned int __cdecl sub_10046740(int a1)
{
  unsigned int v2; // edx
  unsigned int v3; // eax
  int v4; // esi
  unsigned int v5; // ecx
  int v6; // eax
  unsigned int v7; // ecx
  int v8; // esi
  int v9; // ecx
  _WORD *v10; // ecx
  __int16 v11; // ax
  unsigned int v12; // esi
  _WORD *v13; // ecx
  __int16 v14; // ax
  _DWORD *v15; // ebp
  unsigned int result; // eax
  char *v17; // edi
  unsigned int v18; // esi
  int v19; // ecx
  int v20; // eax
  unsigned int v21; // ecx
  int v22; // esi
  char v23; // al
  char *v24; // edi
  const void *v25; // esi
  int v26; // ecx
  unsigned int v27; // ebp
  unsigned __int8 *v28; // edi
  int v29; // esi
  int v30; // ecx
  unsigned int v31; // [esp+10h] [ebp-4h]
  unsigned int v32; // [esp+18h] [ebp+4h]
  int v33; // [esp+18h] [ebp+4h]
  unsigned int v34; // [esp+18h] [ebp+4h]

  v2 = *(_DWORD *)(a1 + 36);
  v31 = v2;
  do
  {
    v3 = *(_DWORD *)(a1 + 100);
    v4 = *(_DWORD *)(a1 + 108);
    v5 = *(_DWORD *)(a1 + 52) - v3 - v4;
    v32 = v5;
    if ( v5 )
    {
      if ( v5 == -1 )
      {
        v33 = -2;
        goto LABEL_20;
      }
    }
    else if ( !v3 && !v4 )
    {
      v33 = v2;
LABEL_20:
      v5 = v33;
      goto LABEL_21;
    }
    if ( v3 >= v2 + *(_DWORD *)(a1 + 36) - 262 )
    {
      qmemcpy(*(void **)(a1 + 48), (const void *)(*(_DWORD *)(a1 + 48) + v2), v2);
      v6 = *(_DWORD *)(a1 + 84);
      v7 = *(_DWORD *)(a1 + 100) - v2;
      *(_DWORD *)(a1 + 104) -= v2;
      v8 = *(_DWORD *)(a1 + 68);
      *(_DWORD *)(a1 + 100) = v7;
      v9 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)(a1 + 84) = v6 - v2;
      v10 = (_WORD *)(v9 + 2 * v8);
      do
      {
        if ( (unsigned __int16)*--v10 < v2 )
          v11 = 0;
        else
          v11 = *v10 - v2;
        --v8;
        *v10 = v11;
      }
      while ( v8 );
      v12 = v2;
      v13 = (_WORD *)(*(_DWORD *)(a1 + 56) + 2 * v2);
      do
      {
        if ( (unsigned __int16)*--v13 < v2 )
          v14 = 0;
        else
          v14 = *v13 - v2;
        --v12;
        *v13 = v14;
      }
      while ( v12 );
      v33 = v2 + v32;
      goto LABEL_20;
    }
LABEL_21:
    v15 = *(_DWORD **)a1;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
    if ( !result )
      break;
    v17 = (char *)(*(_DWORD *)(a1 + 48) + *(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 108));
    v18 = v15[1];
    v34 = v18;
    if ( v18 > v5 )
    {
      v34 = v5;
      v18 = v5;
    }
    if ( v18 )
    {
      v19 = v15[7];
      v15[1] -= v18;
      if ( !*(_DWORD *)(v19 + 24) )
      {
        v20 = sub_10049190(v15[12], *v15, v18);
        v2 = v31;
        v15[12] = v20;
      }
      v21 = v18;
      v22 = *v15;
      v23 = v21;
      v21 >>= 2;
      qmemcpy(v17, (const void *)*v15, 4 * v21);
      v25 = (const void *)(v22 + 4 * v21);
      v24 = &v17[4 * v21];
      LOBYTE(v21) = v23;
      result = v34;
      qmemcpy(v24, v25, v21 & 3);
      v26 = v15[2];
      *v15 += v34;
      v15[2] = v34 + v26;
    }
    else
    {
      result = 0;
    }
    v27 = result + *(_DWORD *)(a1 + 108);
    *(_DWORD *)(a1 + 108) = v27;
    if ( v27 >= 3 )
    {
      v28 = (unsigned __int8 *)(*(_DWORD *)(a1 + 100) + *(_DWORD *)(a1 + 48));
      v29 = *v28;
      v30 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)(a1 + 64) = v29;
      result = *(_DWORD *)(a1 + 76);
      *(_DWORD *)(a1 + 64) = result & (v28[1] ^ (v29 << v30));
    }
    if ( v27 >= 0x106 )
      break;
    result = *(_DWORD *)(*(_DWORD *)a1 + 4);
  }
  while ( result );
  return result;
}

// sub_100468E0 @ 0x100468E0
int __cdecl sub_100468E0(_DWORD *a1, int a2)
{
  int v2; // edi
  unsigned int v3; // eax
  int v4; // edx
  int v5; // ecx
  int v6; // eax
  char v7; // cl
  __int16 v8; // ax
  unsigned __int16 v9; // ax
  int v10; // edx
  int v11; // eax
  unsigned int v12; // eax
  unsigned int v13; // edx
  unsigned int v14; // ebx
  BOOL v15; // esi
  int v16; // edi
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  int v20; // eax
  int v21; // eax
  unsigned int v22; // ecx
  unsigned __int8 *v23; // edx
  int v24; // ecx
  int v25; // eax
  unsigned __int8 v26; // al
  int v27; // ecx
  int v28; // eax
  int v29; // eax
  int v30; // esi
  unsigned int v31; // edx
  int v32; // ecx
  int v33; // ecx
  unsigned int v34; // edi
  _DWORD *v35; // eax
  int v36; // ecx
  int v37; // eax
  int v38; // eax
  int v39; // esi
  unsigned int v40; // edx
  int v41; // ecx
  int v42; // ecx
  unsigned int v43; // edi
  _DWORD *v44; // eax
  int v46; // eax
  int v47; // [esp+10h] [ebp-8h]

  v2 = 0;
  v47 = 0;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 < 0x106 )
    {
      sub_10046740((int)a1);
      v3 = a1[27];
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = a1[25];
      HIWORD(v2) = 0;
      v5 = a1[15];
      v6 = a1[19] & (*(unsigned __int8 *)(a1[12] + v4 + 2) ^ (a1[16] << a1[20]));
      a1[16] = v6;
      LOWORD(v2) = *(_WORD *)(v5 + 2 * v6);
      v47 = (unsigned __int16)v2;
      *(_WORD *)(a1[14] + 2 * (v4 & a1[11])) = v2;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    if ( v2 && a1[25] - v2 <= (unsigned int)(a1[9] - 262) && a1[32] != 2 )
      a1[22] = sub_10046D00(a1, v2);
    if ( a1[22] < 3u )
    {
      v26 = *(_BYTE *)(a1[25] + a1[12]);
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v26;
      ++LOWORD(a1[v26 + 35]);
      v15 = a1[1446] == a1[1445] - 1;
      --a1[27];
    }
    else
    {
      v7 = a1[22];
      v8 = *((_WORD *)a1 + 50) - *((_WORD *)a1 + 52);
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v8;
      v9 = v8 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v7 - 3;
      v10 = (unsigned __int8)byte_10051268[(unsigned __int8)(v7 - 3)];
      ++LOWORD(a1[v10 + 292]);
      if ( v9 >= 0x100u )
        v11 = (unsigned __int8)byte_10051168[v9 >> 7];
      else
        v11 = (unsigned __int8)byte_10051068[v9];
      ++LOWORD(a1[v11 + 608]);
      v12 = a1[22];
      v13 = a1[30];
      v14 = a1[27] - v12;
      v15 = a1[1446] == a1[1445] - 1;
      a1[27] = v14;
      if ( v12 > v13 || v14 < 3 )
      {
        v22 = v12 + a1[25];
        v23 = (unsigned __int8 *)(v22 + a1[12]);
        a1[25] = v22;
        v24 = a1[20];
        a1[22] = 0;
        v25 = *v23;
        a1[16] = v25;
        a1[16] = a1[19] & (v23[1] ^ (v25 << v24));
        goto LABEL_24;
      }
      a1[22] = v12 - 1;
      do
      {
        v16 = a1[16];
        v17 = a1[25] + 1;
        a1[25] = v17;
        v18 = v17;
        v19 = a1[15];
        v20 = a1[19] & ((v16 << a1[20]) ^ *(unsigned __int8 *)(v17 + a1[12] + 2));
        HIWORD(v2) = 0;
        a1[16] = v20;
        LOWORD(v2) = *(_WORD *)(v19 + 2 * v20);
        v47 = (unsigned __int16)v2;
        *(_WORD *)(a1[14] + 2 * (a1[11] & v18)) = v2;
        *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        v21 = a1[22] - 1;
        a1[22] = v21;
      }
      while ( v21 );
    }
    ++a1[25];
LABEL_24:
    if ( v15 )
    {
      v27 = a1[21];
      if ( v27 < 0 )
        v28 = 0;
      else
        v28 = a1[12] + v27;
      sub_10047B90(a1, v28, a1[25] - v27, 0);
      a1[21] = a1[25];
      v29 = *a1;
      v30 = *(_DWORD *)(*a1 + 28);
      v31 = *(_DWORD *)(v30 + 20);
      if ( v31 > *(_DWORD *)(*a1 + 16) )
        v31 = *(_DWORD *)(*a1 + 16);
      if ( v31 )
      {
        qmemcpy(*(void **)(v29 + 12), *(const void **)(v30 + 16), v31);
        v32 = *(_DWORD *)(v29 + 28);
        *(_DWORD *)(v29 + 12) += v31;
        *(_DWORD *)(v32 + 16) += v31;
        v33 = *(_DWORD *)(v29 + 28);
        v34 = *(_DWORD *)(v29 + 16) - v31;
        *(_DWORD *)(v29 + 20) += v31;
        *(_DWORD *)(v29 + 16) = v34;
        *(_DWORD *)(v33 + 20) -= v31;
        v35 = *(_DWORD **)(v29 + 28);
        if ( !v35[5] )
          v35[4] = v35[2];
        v2 = v47;
      }
      if ( !*(_DWORD *)(*a1 + 16) )
        return 0;
    }
  }
  v36 = a1[21];
  if ( v36 < 0 )
    v37 = 0;
  else
    v37 = v36 + a1[12];
  sub_10047B90(a1, v37, a1[25] - v36, a2 == 4);
  a1[21] = a1[25];
  v38 = *a1;
  v39 = *(_DWORD *)(*a1 + 28);
  v40 = *(_DWORD *)(v39 + 20);
  if ( v40 > *(_DWORD *)(*a1 + 16) )
    v40 = *(_DWORD *)(*a1 + 16);
  if ( v40 )
  {
    qmemcpy(*(void **)(v38 + 12), *(const void **)(v39 + 16), v40);
    v41 = *(_DWORD *)(v38 + 28);
    *(_DWORD *)(v38 + 12) += v40;
    *(_DWORD *)(v41 + 16) += v40;
    v42 = *(_DWORD *)(v38 + 28);
    v43 = *(_DWORD *)(v38 + 16) - v40;
    *(_DWORD *)(v38 + 20) += v40;
    *(_DWORD *)(v38 + 16) = v43;
    *(_DWORD *)(v42 + 20) -= v40;
    v44 = *(_DWORD **)(v38 + 28);
    if ( !v44[5] )
      v44[4] = v44[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v46 = -(a2 != 4);
  LOBYTE(v46) = v46 & 0xFE;
  return v46 + 3;
}

// sub_10046D00 @ 0x10046D00
unsigned int __cdecl sub_10046D00(_DWORD *a1, int a2)
{
  int v3; // esi
  unsigned int v4; // edx
  unsigned int v5; // ebp
  unsigned int v6; // eax
  _BYTE *v7; // ecx
  _BYTE *v8; // ebx
  _BYTE *v10; // edx
  char v11; // al
  _BYTE *v12; // edx
  _BYTE *v13; // ecx
  _BYTE *v14; // edx
  char v15; // al
  _BYTE *v16; // edx
  char v17; // al
  _BYTE *v18; // edx
  char v19; // al
  _BYTE *v20; // edx
  char v21; // al
  _BYTE *v22; // edx
  char v23; // al
  _BYTE *v24; // edx
  char v25; // al
  _BYTE *v26; // edx
  char v27; // al
  _BYTE *v28; // edx
  char v29; // al
  _BYTE *v30; // edx
  int v31; // edx
  unsigned int result; // eax
  char v33; // [esp+13h] [ebp-11h]
  unsigned int v34; // [esp+14h] [ebp-10h]
  int v35; // [esp+18h] [ebp-Ch]
  unsigned int v36; // [esp+1Ch] [ebp-8h]
  unsigned int v37; // [esp+20h] [ebp-4h]
  char v38; // [esp+28h] [ebp+4h]

  v3 = a1[9];
  v4 = a1[25];
  v5 = a1[28];
  v34 = a1[29];
  v6 = a1[34];
  v7 = (_BYTE *)(v4 + a1[12]);
  v35 = v6;
  if ( v4 <= v3 - 262 )
    v36 = 0;
  else
    v36 = v4 - v3 + 262;
  v8 = v7 + 258;
  v38 = v7[v5 - 1];
  v33 = v7[v5];
  if ( v5 >= a1[33] )
    v34 >>= 2;
  v37 = a1[27];
  if ( v6 > v37 )
    v35 = a1[27];
  do
  {
    v10 = (_BYTE *)(a2 + a1[12]);
    if ( v10[v5] == v33 && v10[v5 - 1] == v38 && *v10 == *v7 )
    {
      v11 = v10[1];
      v12 = v10 + 1;
      if ( v11 == v7[1] )
      {
        v13 = v7 + 2;
        v14 = v12 + 1;
        do
        {
          v15 = *++v13;
          v16 = v14 + 1;
          if ( v15 != *v16 )
            break;
          v17 = *++v13;
          v18 = v16 + 1;
          if ( v17 != *v18 )
            break;
          v19 = *++v13;
          v20 = v18 + 1;
          if ( v19 != *v20 )
            break;
          v21 = *++v13;
          v22 = v20 + 1;
          if ( v21 != *v22 )
            break;
          v23 = *++v13;
          v24 = v22 + 1;
          if ( v23 != *v24 )
            break;
          v25 = *++v13;
          v26 = v24 + 1;
          if ( v25 != *v26 )
            break;
          v27 = *++v13;
          v28 = v26 + 1;
          if ( v27 != *v28 )
            break;
          v29 = *++v13;
          v14 = v28 + 1;
          if ( v29 != *v14 )
            break;
        }
        while ( v13 < v8 );
        v30 = v13;
        v7 = v8 - 258;
        v31 = v30 - v8 + 258;
        if ( v31 > (int)v5 )
        {
          a1[26] = a2;
          v5 = v31;
          if ( v31 >= v35 )
            break;
          v38 = v7[v31 - 1];
          v33 = v7[v31];
        }
      }
    }
    a2 = *(unsigned __int16 *)(a1[14] + 2 * (a2 & a1[11]));
    if ( (unsigned __int16)a2 <= v36 )
      break;
    --v34;
  }
  while ( v34 );
  result = v37;
  if ( v5 <= v37 )
    return v5;
  return result;
}

// sub_10046E70 @ 0x10046E70
int __cdecl sub_10046E70(_DWORD *a1, int a2)
{
  unsigned int v3; // eax
  int v4; // esi
  int v5; // edx
  int v6; // eax
  unsigned __int16 v7; // cx
  int v8; // ecx
  unsigned int v9; // eax
  unsigned int v10; // eax
  unsigned int v11; // edi
  __int16 v12; // ax
  unsigned __int16 v13; // ax
  int v14; // eax
  int v15; // eax
  BOOL v16; // ebp
  unsigned int v17; // ecx
  unsigned int v18; // esi
  int v19; // edx
  int v20; // eax
  unsigned __int16 v21; // cx
  int v22; // eax
  int v23; // edx
  int v24; // eax
  int v25; // edx
  int v26; // ecx
  int v27; // eax
  int v28; // esi
  unsigned int v29; // edx
  int v30; // ecx
  int v31; // ecx
  unsigned int v32; // edi
  _DWORD *v33; // eax
  unsigned __int8 v34; // al
  int v35; // ecx
  int v36; // eax
  int v37; // eax
  int v38; // esi
  unsigned int v39; // edx
  int v40; // ecx
  int v41; // ecx
  unsigned int v42; // edi
  _DWORD *v43; // eax
  int v44; // ecx
  int v45; // edx
  int v46; // ecx
  int v47; // eax
  int v48; // esi
  int v49; // eax
  int v50; // eax
  int v51; // esi
  unsigned int v52; // edx
  int v53; // ecx
  int v54; // ecx
  unsigned int v55; // edi
  _DWORD *v56; // eax
  int v58; // eax
  int v59; // [esp+10h] [ebp-8h]
  unsigned __int8 v60; // [esp+1Ch] [ebp+4h]
  unsigned __int8 v61; // [esp+1Ch] [ebp+4h]

  v59 = 0;
  while ( 1 )
  {
    v3 = a1[27];
    if ( v3 < 0x106 )
    {
      sub_10046740((int)a1);
      v3 = a1[27];
      if ( v3 < 0x106 && !a2 )
        return 0;
      if ( !v3 )
        break;
    }
    if ( v3 >= 3 )
    {
      v4 = a1[25];
      v5 = a1[15];
      v6 = a1[19] & (*(unsigned __int8 *)(a1[12] + v4 + 2) ^ (a1[16] << a1[20]));
      a1[16] = v6;
      v7 = *(_WORD *)(v5 + 2 * v6);
      v59 = v7;
      *(_WORD *)(a1[14] + 2 * (v4 & a1[11])) = v7;
      *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
    }
    v8 = a1[26];
    a1[28] = a1[22];
    a1[23] = v8;
    a1[22] = 2;
    if ( v59 && a1[28] < a1[30] && a1[25] - v59 <= (unsigned int)(a1[9] - 262) )
    {
      if ( a1[32] != 2 )
        a1[22] = sub_10046D00(a1, v59);
      v9 = a1[22];
      if ( v9 <= 5 && (a1[32] == 1 || v9 == 3 && (unsigned int)(a1[25] - a1[26]) > 0x1000) )
        a1[22] = 2;
    }
    v10 = a1[28];
    if ( v10 < 3 || a1[22] > v10 )
    {
      if ( a1[24] )
      {
        v34 = *(_BYTE *)(a1[25] + a1[12] - 1);
        *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
        *(_BYTE *)(a1[1444] + a1[1446]++) = v34;
        ++LOWORD(a1[v34 + 35]);
        if ( a1[1446] == a1[1445] - 1 )
        {
          v35 = a1[21];
          if ( v35 < 0 )
            v36 = 0;
          else
            v36 = a1[12] + v35;
          sub_10047B90(a1, v36, a1[25] - v35, 0);
          a1[21] = a1[25];
          v37 = *a1;
          v38 = *(_DWORD *)(*a1 + 28);
          v39 = *(_DWORD *)(v38 + 20);
          if ( v39 > *(_DWORD *)(*a1 + 16) )
            v39 = *(_DWORD *)(*a1 + 16);
          if ( v39 )
          {
            qmemcpy(*(void **)(v37 + 12), *(const void **)(v38 + 16), v39);
            v40 = *(_DWORD *)(v37 + 28);
            *(_DWORD *)(v37 + 12) += v39;
            *(_DWORD *)(v40 + 16) += v39;
            v41 = *(_DWORD *)(v37 + 28);
            v42 = *(_DWORD *)(v37 + 16) - v39;
            *(_DWORD *)(v37 + 20) += v39;
            *(_DWORD *)(v37 + 16) = v42;
            *(_DWORD *)(v41 + 20) -= v39;
            v43 = *(_DWORD **)(v37 + 28);
            if ( !v43[5] )
              v43[4] = v43[2];
          }
        }
        v44 = a1[27] - 1;
        ++a1[25];
        v45 = *a1;
        a1[27] = v44;
        if ( !*(_DWORD *)(v45 + 16) )
          return 0;
      }
      else
      {
        v46 = a1[25] + 1;
        v47 = a1[27] - 1;
        a1[24] = 1;
        a1[25] = v46;
        a1[27] = v47;
      }
    }
    else
    {
      v11 = a1[25] + a1[27] - 3;
      v60 = v10 - 3;
      v12 = *((_WORD *)a1 + 50) - *((_WORD *)a1 + 46) - 1;
      *(_WORD *)(a1[1447] + 2 * a1[1446]) = v12;
      v13 = v12 - 1;
      *(_BYTE *)(a1[1444] + a1[1446]++) = v60;
      ++LOWORD(a1[(unsigned __int8)byte_10051268[v60] + 292]);
      if ( v13 >= 0x100u )
        v14 = (unsigned __int8)byte_10051168[v13 >> 7];
      else
        v14 = (unsigned __int8)byte_10051068[v13];
      ++LOWORD(a1[v14 + 608]);
      v15 = a1[28];
      v16 = a1[1446] == a1[1445] - 1;
      a1[27] += 1 - v15;
      a1[28] = v15 - 2;
      do
      {
        v17 = a1[25] + 1;
        v18 = v17;
        a1[25] = v17;
        if ( v17 <= v11 )
        {
          v19 = a1[15];
          v20 = a1[19] & (*(unsigned __int8 *)(a1[12] + v17 + 2) ^ (a1[16] << a1[20]));
          a1[16] = v20;
          v21 = *(_WORD *)(v19 + 2 * v20);
          v59 = v21;
          *(_WORD *)(a1[14] + 2 * (v18 & a1[11])) = v21;
          *(_WORD *)(a1[15] + 2 * a1[16]) = *((_WORD *)a1 + 50);
        }
        v22 = a1[28] - 1;
        a1[28] = v22;
      }
      while ( v22 );
      v23 = a1[25];
      a1[24] = 0;
      ++v23;
      a1[22] = 2;
      a1[25] = v23;
      v24 = v23;
      if ( v16 )
      {
        v25 = a1[21];
        if ( v25 < 0 )
          v26 = 0;
        else
          v26 = v25 + a1[12];
        sub_10047B90(a1, v26, v24 - v25, 0);
        a1[21] = a1[25];
        v27 = *a1;
        v28 = *(_DWORD *)(*a1 + 28);
        v29 = *(_DWORD *)(v28 + 20);
        if ( v29 > *(_DWORD *)(*a1 + 16) )
          v29 = *(_DWORD *)(*a1 + 16);
        if ( v29 )
        {
          qmemcpy(*(void **)(v27 + 12), *(const void **)(v28 + 16), v29);
          v30 = *(_DWORD *)(v27 + 28);
          *(_DWORD *)(v27 + 12) += v29;
          *(_DWORD *)(v30 + 16) += v29;
          v31 = *(_DWORD *)(v27 + 28);
          v32 = *(_DWORD *)(v27 + 16) - v29;
          *(_DWORD *)(v27 + 20) += v29;
          *(_DWORD *)(v27 + 16) = v32;
          *(_DWORD *)(v31 + 20) -= v29;
          v33 = *(_DWORD **)(v27 + 28);
          if ( !v33[5] )
            v33[4] = v33[2];
        }
        if ( !*(_DWORD *)(*a1 + 16) )
          return 0;
      }
    }
  }
  if ( a1[24] )
  {
    v61 = *(_BYTE *)(a1[25] + a1[12] - 1);
    *(_WORD *)(a1[1447] + 2 * a1[1446]) = 0;
    *(_BYTE *)(a1[1444] + a1[1446]++) = v61;
    ++LOWORD(a1[v61 + 35]);
    a1[24] = 0;
  }
  v48 = a1[21];
  if ( v48 < 0 )
    v49 = 0;
  else
    v49 = v48 + a1[12];
  sub_10047B90(a1, v49, a1[25] - v48, a2 == 4);
  a1[21] = a1[25];
  v50 = *a1;
  v51 = *(_DWORD *)(*a1 + 28);
  v52 = *(_DWORD *)(v51 + 20);
  if ( v52 > *(_DWORD *)(*a1 + 16) )
    v52 = *(_DWORD *)(*a1 + 16);
  if ( v52 )
  {
    qmemcpy(*(void **)(v50 + 12), *(const void **)(v51 + 16), v52);
    v53 = *(_DWORD *)(v50 + 28);
    *(_DWORD *)(v50 + 12) += v52;
    *(_DWORD *)(v53 + 16) += v52;
    v54 = *(_DWORD *)(v50 + 28);
    v55 = *(_DWORD *)(v50 + 16) - v52;
    *(_DWORD *)(v50 + 20) += v52;
    *(_DWORD *)(v50 + 16) = v55;
    *(_DWORD *)(v54 + 20) -= v52;
    v56 = *(_DWORD **)(v50 + 28);
    if ( !v56[5] )
      v56[4] = v56[2];
  }
  if ( !*(_DWORD *)(*a1 + 16) )
    return a2 != 4 ? 0 : 2;
  v58 = -(a2 != 4);
  LOBYTE(v58) = v58 & 0xFE;
  return v58 + 3;
}

// sub_100473F0 @ 0x100473F0
int __cdecl sub_100473F0(_DWORD *a1)
{
  int v1; // eax
  int v2; // eax

  if ( !a1 )
    return -2;
  v1 = a1[7];
  if ( !v1 || !a1[9] )
    return -2;
  v2 = *(_DWORD *)(v1 + 20);
  if ( v2 )
    sub_1004A100(v2, a1);
  ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
  a1[7] = 0;
  return 0;
}

// sub_10047440 @ 0x10047440
int __cdecl sub_10047440(_DWORD *a1, int a2, _BYTE *a3, int a4)
{
  int v5; // eax
  int v6; // eax
  int v7; // ecx
  _DWORD *v8; // eax
  void (__cdecl *v9)(_DWORD, _DWORD); // ecx
  int v10; // eax
  int v11; // eax

  if ( !a3 || *a3 != a113_0[0] || a4 != 56 )
    return -6;
  if ( !a1 )
    return -2;
  v5 = a1[8];
  a1[6] = 0;
  if ( !v5 )
  {
    a1[8] = FUN_10047a00;
    a1[10] = 0;
  }
  if ( !a1[9] )
    a1[9] = FUN_10047a20;
  v6 = ((int (__cdecl *)(_DWORD, int, int))a1[8])(a1[10], 1, 24);
  a1[7] = v6;
  if ( !v6 )
    return -4;
  v7 = a2;
  *(_DWORD *)(v6 + 20) = 0;
  *(_DWORD *)(a1[7] + 12) = 0;
  if ( a2 < 0 )
  {
    v7 = -a2;
    *(_DWORD *)(a1[7] + 12) = 1;
  }
  if ( v7 < 8 || v7 > 15 )
  {
    v10 = a1[7];
    if ( v10 && a1[9] )
    {
      v11 = *(_DWORD *)(v10 + 20);
      if ( v11 )
        sub_1004A100(v11, a1);
      ((void (__cdecl *)(_DWORD, _DWORD))a1[9])(a1[10], a1[7]);
      a1[7] = 0;
    }
    return -2;
  }
  else
  {
    *(_DWORD *)(a1[7] + 16) = v7;
    *(_DWORD *)(a1[7] + 20) = sub_10049340(a1, *(_DWORD *)(a1[7] + 12) == 0 ? sub_10049190 : 0, 1 << v7);
    v8 = (_DWORD *)a1[7];
    if ( v8[5] )
    {
      if ( v8 )
      {
        a1[5] = 0;
        a1[2] = 0;
        a1[6] = 0;
        *v8 = v8[3] != 0 ? 7 : 0;
        sub_100492C0(*(_DWORD *)(a1[7] + 20), a1, 0);
      }
      return 0;
    }
    else
    {
      if ( v8 )
      {
        v9 = (void (__cdecl *)(_DWORD, _DWORD))a1[9];
        if ( v9 )
        {
          v9(a1[10], a1[7]);
          a1[7] = 0;
        }
      }
      return -4;
    }
  }
}

// sub_100475B0 @ 0x100475B0
int __cdecl sub_100475B0(_DWORD *a1, _BYTE *a2, int a3)
{
  return sub_10047440(a1, 15, a2, a3);
}

// sub_100475D0 @ 0x100475D0
int __cdecl sub_100475D0(unsigned __int8 **a1, int a2)
{
  int v2; // edi
  unsigned int v3; // ebx
  unsigned __int8 *v4; // eax
  unsigned __int8 *v5; // ecx
  unsigned __int8 *v6; // eax
  int v7; // ecx
  unsigned __int8 *v8; // edx
  unsigned __int8 *v9; // edx
  unsigned __int8 *v10; // eax
  unsigned __int8 *v11; // ebx
  int v12; // ecx
  unsigned __int8 *v13; // eax
  int v14; // eax
  unsigned __int8 *v15; // eax
  unsigned __int8 *v16; // eax
  unsigned __int8 *v17; // edx
  unsigned __int8 *v18; // eax
  unsigned __int8 *v19; // ecx
  unsigned __int8 *v20; // eax
  unsigned __int8 *v21; // ecx
  unsigned __int8 *v22; // eax
  unsigned __int8 *v23; // ecx
  int v24; // edx
  unsigned __int8 *v25; // eax
  unsigned __int8 *v26; // eax
  unsigned __int8 *v27; // edx
  unsigned __int8 *v28; // eax
  unsigned __int8 *v30; // ecx
  unsigned __int8 *v31; // ecx
  unsigned __int8 *v32; // eax
  unsigned __int8 *v33; // edx
  unsigned __int8 *v34; // edx
  unsigned __int8 *v35; // eax
  unsigned __int8 *v36; // ecx
  unsigned __int8 *v37; // eax
  unsigned __int8 *v38; // ecx
  int v39; // edx
  unsigned __int8 *v40; // eax
  unsigned __int8 *v41; // eax
  unsigned __int8 *v42; // eax
  unsigned int v43; // [esp+18h] [ebp+8h]

  if ( !a1 || !a1[7] || !*a1 )
    return -2;
  v2 = -5;
  v3 = a2 != 4 ? 0 : 0xFFFFFFFB;
  v43 = v3;
  while ( 2 )
  {
    v4 = a1[7];
    switch ( *(_DWORD *)v4 )
    {
      case 0:
        v5 = a1[1];
        if ( !v5 )
          return v2;
        a1[1] = v5 - 1;
        v2 = v3;
        ++a1[2];
        *((_DWORD *)v4 + 1) = **a1;
        v6 = a1[7];
        v7 = *((_DWORD *)v6 + 1) & 0xF;
        ++*a1;
        if ( (_BYTE)v7 != 8 )
        {
          *(_DWORD *)v6 = 13;
          v8 = a1[7];
          a1[6] = (unsigned __int8 *)aUnknownCompres_1;
          *((_DWORD *)v8 + 1) = 5;
          continue;
        }
        if ( (unsigned int)((*((_DWORD *)v6 + 1) >> 4) + 8) > *((_DWORD *)v6 + 4) )
        {
          *(_DWORD *)v6 = 13;
          v9 = a1[7];
          a1[6] = (unsigned __int8 *)aInvalidWindowS_0;
          *((_DWORD *)v9 + 1) = 5;
          continue;
        }
        *(_DWORD *)v6 = 1;
LABEL_12:
        v10 = a1[1];
        if ( !v10 )
          return v2;
        a1[1] = v10 - 1;
        v2 = v3;
        v11 = a1[7];
        ++a1[2];
        v12 = *(*a1)++;
        if ( (v12 + (*((_DWORD *)v11 + 1) << 8)) % 0x1Fu )
        {
          *(_DWORD *)v11 = 13;
          v13 = a1[7];
          v3 = v43;
          a1[6] = (unsigned __int8 *)aIncorrectHeade_0;
          *((_DWORD *)v13 + 1) = 5;
          continue;
        }
        if ( (v12 & 0x20) == 0 )
        {
          *(_DWORD *)v11 = 7;
          v3 = v43;
          continue;
        }
        v3 = v43;
        *(_DWORD *)a1[7] = 2;
LABEL_35:
        v28 = a1[1];
        if ( !v28 )
          return v2;
        v30 = *a1;
        ++a1[2];
        a1[1] = v28 - 1;
        v2 = v3;
        *((_DWORD *)a1[7] + 2) = *v30 << 24;
        v31 = a1[7];
        ++*a1;
        *(_DWORD *)v31 = 3;
LABEL_38:
        v32 = a1[1];
        if ( !v32 )
          return v2;
        v33 = *a1;
        a1[1] = v32 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v33 << 16;
        v34 = a1[7];
        ++*a1;
        *(_DWORD *)v34 = 4;
LABEL_41:
        v35 = a1[1];
        if ( !v35 )
          return v2;
        v36 = *a1;
        a1[1] = v35 - 1;
        ++a1[2];
        v2 = v3;
        *((_DWORD *)a1[7] + 2) += *v36 << 8;
        ++*a1;
        *(_DWORD *)a1[7] = 5;
LABEL_44:
        v37 = a1[1];
        if ( !v37 )
          return v2;
        v38 = *a1;
        v39 = (int)(a1[2] + 1);
        a1[1] = v37 - 1;
        v40 = a1[7];
        a1[2] = (unsigned __int8 *)v39;
        *((_DWORD *)v40 + 2) += *v38;
        ++*a1;
        v41 = a1[7];
        a1[12] = (unsigned __int8 *)*((_DWORD *)v41 + 2);
        *(_DWORD *)v41 = 6;
        return 2;
      case 1:
        goto LABEL_12;
      case 2:
        goto LABEL_35;
      case 3:
        goto LABEL_38;
      case 4:
        goto LABEL_41;
      case 5:
        goto LABEL_44;
      case 6:
        *(_DWORD *)a1[7] = 13;
        v42 = a1[7];
        a1[6] = (unsigned __int8 *)aNeedDictionary_0;
        *((_DWORD *)v42 + 1) = 0;
        return -2;
      case 7:
        v14 = sub_10049400(*((_DWORD *)v4 + 5), a1, v2);
        v2 = v14;
        if ( v14 == -3 )
        {
          *(_DWORD *)a1[7] = 13;
          *((_DWORD *)a1[7] + 1) = 0;
        }
        else
        {
          if ( !v14 )
            v2 = v3;
          if ( v2 != 1 )
            return v2;
          v2 = v3;
          sub_100492C0(*((_DWORD *)a1[7] + 5), a1, a1[7] + 4);
          v15 = a1[7];
          if ( *((_DWORD *)v15 + 3) )
          {
            *(_DWORD *)v15 = 12;
          }
          else
          {
            *(_DWORD *)v15 = 8;
LABEL_25:
            v16 = a1[1];
            if ( !v16 )
              return v2;
            v17 = a1[7];
            a1[1] = v16 - 1;
            ++a1[2];
            v2 = v3;
            *((_DWORD *)v17 + 2) = *(*a1)++ << 24;
            *(_DWORD *)a1[7] = 9;
LABEL_27:
            v18 = a1[1];
            if ( !v18 )
              return v2;
            v19 = *a1;
            ++a1[2];
            a1[1] = v18 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v19 << 16;
            ++*a1;
            *(_DWORD *)a1[7] = 10;
LABEL_29:
            v20 = a1[1];
            if ( !v20 )
              return v2;
            v21 = *a1;
            ++a1[2];
            a1[1] = v20 - 1;
            v2 = v3;
            *((_DWORD *)a1[7] + 2) += *v21 << 8;
            ++*a1;
            *(_DWORD *)a1[7] = 11;
LABEL_31:
            v22 = a1[1];
            if ( !v22 )
              return v2;
            v23 = *a1;
            v24 = (int)(a1[2] + 1);
            a1[1] = v22 - 1;
            v25 = a1[7];
            a1[2] = (unsigned __int8 *)v24;
            v2 = v3;
            *((_DWORD *)v25 + 2) += *v23;
            ++*a1;
            v26 = a1[7];
            if ( *((_DWORD *)v26 + 1) == *((_DWORD *)v26 + 2) )
            {
              *(_DWORD *)a1[7] = 12;
              return 1;
            }
            *(_DWORD *)v26 = 13;
            v27 = a1[7];
            a1[6] = (unsigned __int8 *)aIncorrectDataC_0;
            *((_DWORD *)v27 + 1) = 5;
          }
        }
        continue;
      case 8:
        goto LABEL_25;
      case 9:
        goto LABEL_27;
      case 0xA:
        goto LABEL_29;
      case 0xB:
        goto LABEL_31;
      case 0xC:
        return 1;
      case 0xD:
        return -3;
      default:
        return -2;
    }
  }
}

// FUN_10047a00 @ 0x10047A00
// [binja] int32_t sub_10047a00(uint32_t arg1, uint32_t arg2)
void *__cdecl FUN_10047a00(int a1, size_t Count, size_t Size)
{
  return calloc(Count, Size);
}

// FUN_10047a20 @ 0x10047A20
// [binja] int32_t sub_10047a20(int32_t arg1)
void __cdecl sub_10047A20(int a1, void *Block)
{
  free(Block);
}

// sub_10047A30 @ 0x10047A30
int __cdecl sub_10047A30(int a1, _BYTE *a2, int a3, int a4)
{
  int result; // eax
  int v5; // ecx
  int v6; // esi
  int v7; // ecx
  int v8; // edi
  int v9; // esi
  int v10; // esi
  int v11; // ecx
  int v13; // esi
  int v14; // edx
  int v15; // edx
  int v16; // esi
  int v17; // ebx
  int v18; // esi
  int v19; // ebx
  int v20; // edx
  int v21; // edx
  int v22; // ebx
  int v23; // edx
  int v24; // esi
  int v25; // ecx

  result = a1;
  v5 = *(_DWORD *)(a1 + 5812);
  if ( v5 <= 13 )
  {
    *(_WORD *)(a1 + 5808) |= a4 << v5;
    *(_DWORD *)(a1 + 5812) = v5 + 3;
  }
  else
  {
    v6 = a4 << v5;
    v7 = *(_DWORD *)(a1 + 8);
    *(_WORD *)(a1 + 5808) |= v6;
    *(_BYTE *)(v7 + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v8 = *(_DWORD *)(a1 + 8);
    LOBYTE(v7) = *(_BYTE *)(a1 + 5809);
    v9 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v9;
    *(_BYTE *)(v8 + v9) = v7;
    v10 = *(_DWORD *)(a1 + 5812);
    ++*(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 5812) = v10 - 13;
    *(_WORD *)(a1 + 5808) = (unsigned __int16)a4 >> (16 - v10);
  }
  v11 = *(_DWORD *)(a1 + 5812);
  if ( v11 <= 8 )
  {
    if ( v11 <= 0 )
      goto LABEL_9;
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v13 = *(_DWORD *)(a1 + 8);
    v14 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v14;
    *(_BYTE *)(v13 + v14) = *(_BYTE *)(a1 + 5809);
  }
  ++*(_DWORD *)(a1 + 20);
LABEL_9:
  v15 = *(_DWORD *)(a1 + 8);
  v16 = *(_DWORD *)(a1 + 20);
  *(_WORD *)(a1 + 5808) = 0;
  *(_DWORD *)(a1 + 5812) = 0;
  *(_DWORD *)(a1 + 5804) = 8;
  *(_BYTE *)(v15 + v16) = a3;
  v17 = *(_DWORD *)(a1 + 8);
  v18 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v18;
  *(_BYTE *)(v17 + v18) = BYTE1(a3);
  v19 = *(_DWORD *)(a1 + 8);
  v20 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v20;
  *(_BYTE *)(v19 + v20) = ~(_BYTE)a3;
  v21 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v21;
  *(_BYTE *)(*(_DWORD *)(a1 + 8) + v21) = ~BYTE1(a3);
  v22 = *(_DWORD *)(a1 + 20) + 1;
  *(_DWORD *)(a1 + 20) = v22;
  v23 = v22;
  if ( a3 )
  {
    v24 = a3;
    do
    {
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + v23) = *a2;
      v25 = *(_DWORD *)(a1 + 20) + 1;
      ++a2;
      --v24;
      *(_DWORD *)(a1 + 20) = v25;
      v23 = v25;
    }
    while ( v24 );
  }
  return result;
}

// sub_10047B90 @ 0x10047B90
int __cdecl sub_10047B90(int a1, _BYTE *a2, int a3, int a4)
{
  int v4; // ebp
  unsigned int v6; // ebx
  int v7; // edi
  unsigned int v8; // edx
  unsigned __int16 *v9; // eax
  int v10; // ecx
  unsigned __int16 v11; // di
  unsigned __int16 *v12; // eax
  int v13; // ecx
  unsigned __int16 v14; // bp
  unsigned __int16 *v15; // ecx
  int v16; // eax
  unsigned __int16 v17; // di
  int i; // eax
  int v19; // edx
  unsigned int v20; // ecx
  unsigned int v21; // eax
  bool v22; // zf
  int v23; // ecx
  int v24; // edi
  int v25; // edi
  int v26; // edx
  int v27; // edx
  int v28; // edx
  int v29; // ecx
  int v30; // ebx
  int v31; // edx
  int v32; // edx
  int v33; // ecx
  int v34; // ebp
  int v35; // ebx
  int v36; // eax
  int v37; // edi
  int v38; // edi
  int v39; // edx
  int v40; // edx
  int v41; // ecx
  int v42; // eax
  int v43; // edi
  int v44; // edi
  int v45; // edx
  int v46; // edx
  int v47; // ecx
  int v48; // edi
  int v49; // edi
  int v50; // edx
  int v51; // edx
  int j; // edi
  int v53; // ecx
  unsigned __int16 v54; // ax
  int v55; // edx
  int v56; // ecx
  int v57; // ebx
  int v58; // edx
  int v59; // edx
  _WORD *v60; // eax
  int v61; // ecx
  _WORD *v62; // eax
  int v63; // ecx
  _WORD *v64; // eax
  int v65; // ecx
  int result; // eax
  int v67; // [esp+14h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+Ch]

  v4 = a3;
  v6 = 0;
  v7 = 0;
  if ( *(int *)(a1 + 124) <= 0 )
  {
    v21 = a3 + 5;
LABEL_16:
    v20 = v21;
    goto LABEL_17;
  }
  if ( *(_BYTE *)(a1 + 28) == 2 )
  {
    v8 = 0;
    v9 = (unsigned __int16 *)(a1 + 140);
    v10 = 7;
    do
    {
      v11 = *v9;
      v9 += 2;
      v8 += v11;
      --v10;
    }
    while ( v10 );
    v12 = (unsigned __int16 *)(a1 + 168);
    v13 = 121;
    do
    {
      v14 = *v12;
      v12 += 2;
      v6 += v14;
      --v13;
    }
    while ( v13 );
    v15 = (unsigned __int16 *)(a1 + 652);
    v16 = 128;
    do
    {
      v17 = *v15;
      v15 += 2;
      v8 += v17;
      --v16;
    }
    while ( v16 );
    v4 = a3;
    *(_BYTE *)(a1 + 28) = v8 <= v6 >> 2;
  }
  sub_100480F0(a1, a1 + 2832);
  sub_100480F0(a1, a1 + 2844);
  sub_10048660(a1, a1 + 140, *(_DWORD *)(a1 + 2836));
  sub_10048660(a1, a1 + 2432, *(_DWORD *)(a1 + 2848));
  sub_100480F0(a1, a1 + 2856);
  for ( i = 18; i >= 3; --i )
  {
    if ( *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[i] + 2678) )
      break;
  }
  v19 = 3 * i + 17 + *(_DWORD *)(a1 + 5792);
  v7 = i;
  v20 = (unsigned int)(v19 + 10) >> 3;
  v21 = (unsigned int)(*(_DWORD *)(a1 + 5796) + 10) >> 3;
  *(_DWORD *)(a1 + 5792) = v19;
  if ( v21 <= v20 )
    goto LABEL_16;
LABEL_17:
  if ( v4 + 4 <= v20 && a2 )
  {
    sub_10047A30(a1, a2, v4, a4);
  }
  else
  {
    v22 = v21 == v20;
    v23 = *(_DWORD *)(a1 + 5812);
    if ( v22 )
    {
      if ( v23 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= (a4 + 2) << v23;
        *(_DWORD *)(a1 + 5812) = v23 + 3;
      }
      else
      {
        v24 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= (a4 + 2) << v23;
        *(_BYTE *)(v24 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v25 = *(_DWORD *)(a1 + 8);
        v26 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v26;
        *(_BYTE *)(v26 + v25) = *(_BYTE *)(a1 + 5809);
        v27 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v27 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(a4 + 2) >> (16 - v27);
      }
      sub_10048CD0(a1, &unk_10050B70, &unk_10050FF0);
    }
    else
    {
      if ( v23 <= 13 )
      {
        *(_WORD *)(a1 + 5808) |= (a4 + 4) << v23;
        *(_DWORD *)(a1 + 5812) = v23 + 3;
      }
      else
      {
        v28 = (a4 + 4) << v23;
        v29 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v28;
        *(_BYTE *)(v29 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v30 = *(_DWORD *)(a1 + 8);
        v31 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v31;
        *(_BYTE *)(v31 + v30) = *(_BYTE *)(a1 + 5809);
        v32 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v32 - 13;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(a4 + 4) >> (16 - v32);
      }
      v33 = *(_DWORD *)(a1 + 5812);
      v34 = *(_DWORD *)(a1 + 2848) + 1;
      v35 = *(_DWORD *)(a1 + 2836) + 1;
      v68 = v7 + 1;
      v67 = v35;
      v36 = *(_DWORD *)(a1 + 2836) - 256;
      if ( v33 <= 11 )
      {
        *(_WORD *)(a1 + 5808) |= v36 << v33;
        *(_DWORD *)(a1 + 5812) = v33 + 5;
      }
      else
      {
        v37 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v36 << v33;
        *(_BYTE *)(v37 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v38 = *(_DWORD *)(a1 + 8);
        v39 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v39;
        *(_BYTE *)(v39 + v38) = *(_BYTE *)(a1 + 5809);
        v40 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v40 - 11;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v36 >> (16 - v40);
      }
      v41 = *(_DWORD *)(a1 + 5812);
      v42 = v34 - 1;
      if ( v41 <= 11 )
      {
        *(_WORD *)(a1 + 5808) |= v42 << v41;
        *(_DWORD *)(a1 + 5812) = v41 + 5;
      }
      else
      {
        v43 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= v42 << v41;
        *(_BYTE *)(v43 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v44 = *(_DWORD *)(a1 + 8);
        v45 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v45;
        *(_BYTE *)(v45 + v44) = *(_BYTE *)(a1 + 5809);
        v46 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v46 - 11;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)v42 >> (16 - v46);
      }
      v47 = *(_DWORD *)(a1 + 5812);
      if ( v47 <= 12 )
      {
        *(_WORD *)(a1 + 5808) |= (v68 - 4) << v47;
        *(_DWORD *)(a1 + 5812) = v47 + 4;
      }
      else
      {
        v48 = *(_DWORD *)(a1 + 20);
        *(_WORD *)(a1 + 5808) |= (v68 - 4) << v47;
        *(_BYTE *)(v48 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
        v49 = *(_DWORD *)(a1 + 8);
        v50 = *(_DWORD *)(a1 + 20) + 1;
        *(_DWORD *)(a1 + 20) = v50;
        *(_BYTE *)(v50 + v49) = *(_BYTE *)(a1 + 5809);
        v51 = *(_DWORD *)(a1 + 5812);
        ++*(_DWORD *)(a1 + 20);
        *(_DWORD *)(a1 + 5812) = v51 - 12;
        *(_WORD *)(a1 + 5808) = (unsigned __int16)(v68 - 4) >> (16 - v51);
      }
      for ( j = 0; j < v68; ++j )
      {
        v53 = *(_DWORD *)(a1 + 5812);
        if ( v53 <= 13 )
        {
          *(_WORD *)(a1 + 5808) |= *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[j] + 2678) << v53;
          *(_DWORD *)(a1 + 5812) = v53 + 3;
        }
        else
        {
          v54 = *(_WORD *)(a1 + 4 * (unsigned __int8)byte_10050B5C[j] + 2678);
          v55 = v54 << v53;
          v56 = *(_DWORD *)(a1 + 20);
          *(_WORD *)(a1 + 5808) |= v55;
          *(_BYTE *)(v56 + *(_DWORD *)(a1 + 8)) = *(_BYTE *)(a1 + 5808);
          v57 = *(_DWORD *)(a1 + 8);
          v58 = *(_DWORD *)(a1 + 20) + 1;
          *(_DWORD *)(a1 + 20) = v58;
          *(_BYTE *)(v58 + v57) = *(_BYTE *)(a1 + 5809);
          v59 = *(_DWORD *)(a1 + 5812);
          ++*(_DWORD *)(a1 + 20);
          v35 = v67;
          *(_DWORD *)(a1 + 5812) = v59 - 13;
          *(_WORD *)(a1 + 5808) = v54 >> (16 - v59);
        }
      }
      sub_10048750(a1, a1 + 140, v35 - 1);
      sub_10048750(a1, a1 + 2432, v34 - 1);
      sub_10048CD0(a1, a1 + 140, a1 + 2432);
    }
  }
  v60 = (_WORD *)(a1 + 140);
  v61 = 286;
  do
  {
    *v60 = 0;
    v60 += 2;
    --v61;
  }
  while ( v61 );
  v62 = (_WORD *)(a1 + 2432);
  v63 = 30;
  do
  {
    *v62 = 0;
    v62 += 2;
    --v63;
  }
  while ( v63 );
  v64 = (_WORD *)(a1 + 2676);
  v65 = 19;
  do
  {
    *v64 = 0;
    v64 += 2;
    --v65;
  }
  while ( v65 );
  result = a4;
  *(_WORD *)(a1 + 1164) = 1;
  *(_DWORD *)(a1 + 5796) = 0;
  *(_DWORD *)(a1 + 5792) = 0;
  *(_DWORD *)(a1 + 5800) = 0;
  *(_DWORD *)(a1 + 5784) = 0;
  if ( a4 )
    return sub_10049110(a1);
  return result;
}

// sub_100480F0 @ 0x100480F0
unsigned int __cdecl sub_100480F0(_DWORD *a1, int a2)
{
  int v2; // edi
  int *v4; // eax
  _WORD *v5; // edx
  int v6; // ebx
  int v7; // ebp
  int v8; // eax
  int v9; // ecx
  int v10; // ecx
  int v11; // eax
  int v12; // ecx
  int i; // edi
  _WORD *v14; // ebx
  int v15; // eax
  int v16; // edi
  int v17; // eax
  int v18; // edx
  int v19; // ecx
  char v20; // cl
  int v21; // ecx
  int v22; // eax
  _WORD *v23; // ebx
  int *v24; // eax
  int v25; // edx
  int v26; // ebp
  int v27; // edx
  int v28; // eax
  int v29; // edx
  int v30; // ecx
  int v31; // eax
  int v32; // edi
  int v33; // edx
  bool v34; // zf
  int v35; // edi
  int v36; // eax
  _WORD *j; // ecx
  int v38; // edi
  _WORD *v39; // ebp
  int v40; // eax
  int v41; // ebp
  int v42; // ecx
  _WORD *v43; // edx
  int v44; // eax
  __int16 *v45; // ecx
  __int16 v46; // ax
  char *v47; // edx
  int v48; // esi
  __int16 v49; // di
  unsigned int result; // eax
  _WORD *v51; // edi
  int v52; // ebx
  int v53; // edx
  unsigned int v54; // ecx
  int v55; // esi
  _WORD *v56; // [esp+10h] [ebp-48h]
  int v57; // [esp+14h] [ebp-44h]
  int v58; // [esp+18h] [ebp-40h]
  int v59; // [esp+1Ch] [ebp-3Ch]
  int v60; // [esp+20h] [ebp-38h]
  _WORD *v61; // [esp+20h] [ebp-38h]
  int v62; // [esp+24h] [ebp-34h]
  int v63; // [esp+28h] [ebp-30h]
  int v64; // [esp+2Ch] [ebp-2Ch]
  int v65; // [esp+30h] [ebp-28h]
  __int16 *v66; // [esp+34h] [ebp-24h]
  __int16 v67; // [esp+38h] [ebp-20h]
  char v68; // [esp+3Ah] [ebp-1Eh] BYREF
  int *v69; // [esp+5Ch] [ebp+4h]
  int v70; // [esp+5Ch] [ebp+4h]
  int v71; // [esp+60h] [ebp+8h]

  v2 = a2;
  v57 = -1;
  v4 = *(int **)(a2 + 8);
  v5 = *(_WORD **)a2;
  v56 = *(_WORD **)a2;
  v6 = *v4;
  v7 = v4[3];
  v8 = 0;
  a1[1299] = 573;
  for ( a1[1298] = 0; v8 < v7; v5 += 2 )
  {
    if ( *v5 )
    {
      v57 = v8;
      v9 = a1[1298] + 1;
      a1[1298] = v9;
      a1[v9 + 725] = v8;
      *((_BYTE *)a1 + v8 + 5200) = 0;
    }
    else
    {
      v5[1] = 0;
    }
    ++v8;
  }
  v10 = a1[1298];
  if ( v10 < 2 )
  {
    do
    {
      if ( v57 >= 2 )
        v11 = 0;
      else
        v11 = ++v57;
      v12 = v10 + 1;
      a1[1298] = v12;
      a1[v12 + 725] = v11;
      v56[2 * v11] = 1;
      *((_BYTE *)a1 + v11 + 5200) = 0;
      --a1[1448];
      if ( v6 )
        a1[1449] -= *(unsigned __int16 *)(v6 + 4 * v11 + 2);
      v10 = a1[1298];
    }
    while ( v10 < 2 );
    v2 = a2;
  }
  *(_DWORD *)(v2 + 4) = v57;
  for ( i = a1[1298] / 2; i >= 1; --i )
    sub_10048580(a1, v56, i);
  v14 = &v56[2 * v7];
  do
  {
    v15 = a1[1298];
    v16 = a1[726];
    a1[726] = a1[v15 + 725];
    a1[1298] = v15 - 1;
    sub_10048580(a1, v56, 1);
    v17 = a1[726];
    v18 = a1[1299] - 1;
    a1[1299] = v18;
    a1[v18 + 725] = v16;
    v19 = a1[1299] - 1;
    a1[1299] = v19;
    a1[v19 + 725] = v17;
    *v14 = v56[2 * v16] + v56[2 * v17];
    if ( *((_BYTE *)a1 + v16 + 5200) < *((_BYTE *)a1 + v17 + 5200) )
      v20 = *((_BYTE *)a1 + v17 + 5200);
    else
      v20 = *((_BYTE *)a1 + v16 + 5200);
    *((_BYTE *)a1 + v7 + 5200) = v20 + 1;
    v56[2 * v17 + 1] = v7;
    v56[2 * v16 + 1] = v7;
    a1[726] = v7++;
    v14 += 2;
    sub_10048580(a1, v56, 1);
  }
  while ( (int)a1[1298] >= 2 );
  v21 = a1[726];
  v22 = a1[1299] - 1;
  a1[1299] = v22;
  v66 = (__int16 *)(a1 + 717);
  a1[v22 + 725] = v21;
  v23 = *(_WORD **)a2;
  v24 = *(int **)(a2 + 8);
  v62 = *(_DWORD *)(a2 + 4);
  v25 = v24[1];
  v26 = v24[4];
  v59 = *v24;
  v63 = v24[2];
  memset(a1 + 717, 0, 0x20u);
  v64 = v25;
  v65 = v26;
  v58 = 0;
  v23[2 * a1[a1[1299] + 725] + 1] = 0;
  v27 = a1[1299] + 1;
  if ( v27 < 573 )
  {
    v69 = &a1[v27 + 725];
    v28 = 573 - v27;
    v29 = 573;
    v60 = v28;
    v71 = 573;
    do
    {
      v30 = *v69;
      v31 = (unsigned __int16)v23[2 * (unsigned __int16)v23[2 * *v69 + 1] + 1] + 1;
      if ( v31 > v26 )
      {
        v31 = v26;
        ++v58;
      }
      v23[2 * v30 + 1] = v31;
      if ( v30 <= v62 )
      {
        ++*((_WORD *)a1 + v31 + 1434);
        v32 = 0;
        if ( v30 >= v63 )
          v32 = *(_DWORD *)(v64 + 4 * (v30 - v63));
        v33 = (unsigned __int16)v23[2 * v30];
        a1[1448] += v33 * (v32 + v31);
        if ( v59 )
        {
          v26 = v65;
          a1[1449] += v33 * (v32 + *(unsigned __int16 *)(v59 + 4 * v30 + 2));
        }
        v29 = 573;
      }
      v34 = v60 == 1;
      ++v69;
      --v60;
    }
    while ( !v34 );
    v35 = v58;
    if ( v58 )
    {
      do
      {
        v36 = v26 - 1;
        for ( j = (_WORD *)a1 + v26 + 1433; !*j; --v36 )
          --j;
        --*((_WORD *)a1 + v36 + 1434);
        *((_WORD *)a1 + v36 + 1435) += 2;
        --*((_WORD *)a1 + v26 + 1434);
        v35 -= 2;
      }
      while ( v35 > 0 );
      v38 = v26;
      if ( v26 )
      {
        v39 = (_WORD *)a1 + v26 + 1434;
        v61 = v39;
        do
        {
          v40 = (unsigned __int16)*v39;
          v70 = v40;
          if ( *v39 )
          {
            v41 = (int)&a1[v29 + 725];
            do
            {
              v42 = *(_DWORD *)(v41 - 4);
              v41 -= 4;
              --v71;
              if ( v42 <= v62 )
              {
                v43 = &v23[2 * v42 + 1];
                HIWORD(v44) = 0;
                if ( (unsigned __int16)*v43 != v38 )
                {
                  LOWORD(v44) = *v43;
                  a1[1448] += (unsigned __int16)v23[2 * v42] * (v38 - v44);
                  *v43 = v38;
                }
                v40 = --v70;
              }
            }
            while ( v40 );
            v29 = v71;
          }
          --v38;
          v39 = --v61;
        }
        while ( v38 );
      }
    }
  }
  v45 = v66;
  v46 = 0;
  v47 = &v68;
  v48 = 15;
  do
  {
    v49 = *v45++;
    v47 += 2;
    v46 = 2 * (v46 + v49);
    --v48;
    *((_WORD *)v47 - 1) = v46;
  }
  while ( v48 );
  result = v57;
  if ( v57 >= 0 )
  {
    v51 = v56;
    v52 = v57 + 1;
    do
    {
      v53 = (unsigned __int16)v51[1];
      if ( (_WORD)v53 )
      {
        result = (unsigned __int16)(*(&v67 + v53))++;
        v54 = 0;
        do
        {
          v55 = result & 1;
          result >>= 1;
          v54 = 2 * (v55 | v54);
          --v53;
        }
        while ( v53 > 0 );
        *v51 = v54 >> 1;
      }
      v51 += 2;
      --v52;
    }
    while ( v52 );
  }
  return result;
}

// sub_10048580 @ 0x10048580
int __cdecl sub_10048580(int a1, int a2, int a3)
{
  int result; // eax
  int v4; // edx
  int v5; // ebp
  int v6; // ecx
  bool v7; // cc
  int v8; // esi
  int v9; // ebp
  unsigned __int16 v10; // dx
  unsigned __int16 v11; // bx
  int v12; // esi
  unsigned __int16 v13; // dx
  unsigned __int16 v14; // bx
  int v15; // edx
  int v16; // edx
  int v17; // [esp+14h] [ebp+4h]

  result = a1;
  v4 = *(_DWORD *)(a1 + 5192);
  v5 = *(_DWORD *)(a1 + 4 * a3 + 2900);
  v6 = 2 * a3;
  v7 = 2 * a3 < v4;
  v17 = v5;
  if ( 2 * a3 > v4 )
  {
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  else
  {
    while ( 1 )
    {
      if ( v7 )
      {
        v8 = *(_DWORD *)(result + 4 * v6 + 2904);
        v9 = *(_DWORD *)(result + 4 * v6 + 2900);
        v10 = *(_WORD *)(a2 + 4 * v8);
        v11 = *(_WORD *)(a2 + 4 * v9);
        if ( v10 < v11 || v10 == v11 && *(_BYTE *)(v8 + result + 5200) <= *(_BYTE *)(result + v9 + 5200) )
          ++v6;
        v5 = v17;
      }
      v12 = *(_DWORD *)(result + 4 * v6 + 2900);
      v13 = *(_WORD *)(a2 + 4 * v5);
      v14 = *(_WORD *)(a2 + 4 * v12);
      if ( v13 < v14 )
      {
LABEL_12:
        *(_DWORD *)(result + 4 * a3 + 2900) = v5;
        return result;
      }
      if ( v13 == v14 && *(_BYTE *)(result + v5 + 5200) <= *(_BYTE *)(v12 + result + 5200) )
        break;
      v15 = a3;
      a3 = v6;
      v6 *= 2;
      *(_DWORD *)(result + 4 * v15 + 2900) = v12;
      v16 = *(_DWORD *)(result + 5192);
      v7 = v6 < v16;
      if ( v6 > v16 )
        goto LABEL_12;
    }
    *(_DWORD *)(result + 4 * a3 + 2900) = v5;
  }
  return result;
}

// sub_10048660 @ 0x10048660
int __cdecl sub_10048660(_WORD *a1, int a2, int a3)
{
  int result; // eax
  int v4; // ecx
  int v5; // edi
  int v6; // edx
  int v7; // esi
  unsigned __int16 *v8; // ebp
  int v9; // eax
  int v10; // [esp+Ch] [ebp-4h]
  int v11; // [esp+18h] [ebp+8h]

  result = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v5 = 0;
  v10 = -1;
  v6 = 7;
  v7 = 4;
  if ( !(_WORD)v4 )
  {
    v6 = 138;
    v7 = 3;
  }
  *(_WORD *)(a2 + 4 * a3 + 6) = -1;
  if ( a3 >= 0 )
  {
    v11 = a3 + 1;
    v8 = (unsigned __int16 *)(result + 6);
    do
    {
      v9 = v4;
      v4 = *v8;
      if ( ++v5 >= v6 || v9 != v4 )
      {
        if ( v5 >= v7 )
        {
          if ( v9 )
          {
            if ( v9 != v10 )
              ++a1[2 * v9 + 1338];
            ++a1[1370];
          }
          else if ( v5 > 10 )
          {
            ++a1[1374];
          }
          else
          {
            ++a1[1372];
          }
        }
        else
        {
          a1[2 * v9 + 1338] += v5;
        }
        v5 = 0;
        v10 = v9;
        if ( v4 )
        {
          if ( v9 == v4 )
          {
            v6 = 6;
            v7 = 3;
          }
          else
          {
            v6 = 7;
            v7 = 4;
          }
        }
        else
        {
          v6 = 138;
          v7 = 3;
        }
      }
      v8 += 2;
      result = --v11;
    }
    while ( v11 );
  }
  return result;
}

// sub_10048750 @ 0x10048750
int __cdecl sub_10048750(int a1, unsigned int a2, int a3)
{
  __int64 v3; // rax
  int v4; // ebx
  int v5; // ecx
  int v6; // esi
  int v7; // edi
  int v8; // ebp
  int v9; // ecx
  int v10; // esi
  int v11; // edi
  int v12; // ecx
  int v13; // ebx
  int v14; // edi
  int v15; // edi
  int v16; // ecx
  int v17; // esi
  int v18; // edi
  int v19; // ecx
  int v20; // ebx
  int v21; // edi
  int v22; // edi
  int v23; // ecx
  int v24; // esi
  int v25; // edi
  int v26; // ecx
  int v27; // ebx
  int v28; // edi
  int v29; // edi
  int v30; // ecx
  int v31; // esi
  int v32; // ecx
  int v33; // edi
  int v34; // esi
  int v35; // esi
  int v36; // ecx
  int v37; // ecx
  int v38; // esi
  int v39; // edi
  int v40; // ecx
  int v41; // ebx
  int v42; // edi
  int v43; // edi
  int v44; // ecx
  int v45; // esi
  int v46; // ecx
  int v47; // edi
  int v48; // esi
  int v49; // esi
  int v50; // ecx
  int v51; // esi
  int v52; // edi
  int v53; // ecx
  int v54; // ebx
  int v55; // edi
  int v56; // edi
  int v57; // ecx
  int v58; // esi
  int v59; // ecx
  int v60; // edi
  int v61; // esi
  int v62; // esi
  bool v63; // zf
  int v65; // [esp+Ch] [ebp-8h]
  int v66; // [esp+10h] [ebp-4h]
  int v67; // [esp+18h] [ebp+4h]
  int v68; // [esp+1Ch] [ebp+8h]
  unsigned __int16 *v69; // [esp+20h] [ebp+Ch]

  v3 = a2;
  v4 = *(unsigned __int16 *)(a2 + 2);
  v65 = -1;
  v5 = 7;
  v6 = 4;
  if ( !(_WORD)v4 )
  {
    v5 = 138;
    v6 = 3;
  }
  if ( a3 >= 0 )
  {
    v7 = a3 + 1;
    v69 = (unsigned __int16 *)(a2 + 6);
    LODWORD(v3) = a1;
    v66 = v7;
    do
    {
      v8 = v4;
      ++HIDWORD(v3);
      v4 = *v69;
      v67 = v4;
      v68 = HIDWORD(v3);
      if ( SHIDWORD(v3) < v5 && v8 == v4 )
        goto LABEL_44;
      if ( SHIDWORD(v3) < v6 )
      {
        do
        {
          v9 = *(_DWORD *)(v3 + 5812);
          v10 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v9 <= 16 - (unsigned __int16)v10 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v9;
            *(_DWORD *)(v3 + 5812) = v10 + v9;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v11 = WORD2(v3) << v9;
            v12 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v11;
            *(_BYTE *)(v12 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v13 = *(_DWORD *)(v3 + 8);
            LOBYTE(v12) = *(_BYTE *)(v3 + 5809);
            v14 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v14;
            *(_BYTE *)(v14 + v13) = v12;
            v15 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v15);
            *(_DWORD *)(v3 + 5812) = v15 + v10 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        while ( HIDWORD(v3) );
        goto LABEL_39;
      }
      if ( v8 )
      {
        if ( v8 != v65 )
        {
          v16 = *(_DWORD *)(v3 + 5812);
          v17 = *(unsigned __int16 *)(v3 + 4 * v8 + 2678);
          if ( v16 <= 16 - (unsigned __int16)v17 )
          {
            *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 4 * v8 + 2676) << v16;
            *(_DWORD *)(v3 + 5812) = v17 + v16;
          }
          else
          {
            WORD2(v3) = *(_WORD *)(v3 + 4 * v8 + 2676);
            v18 = WORD2(v3) << v16;
            v19 = *(_DWORD *)(v3 + 8);
            *(_WORD *)(v3 + 5808) |= v18;
            *(_BYTE *)(v19 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
            v20 = *(_DWORD *)(v3 + 8);
            LOBYTE(v19) = *(_BYTE *)(v3 + 5809);
            v21 = *(_DWORD *)(v3 + 20) + 1;
            *(_DWORD *)(v3 + 20) = v21;
            *(_BYTE *)(v21 + v20) = v19;
            v22 = *(_DWORD *)(v3 + 5812);
            ++*(_DWORD *)(v3 + 20);
            *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v22);
            *(_DWORD *)(v3 + 5812) = v22 + v17 - 16;
            HIDWORD(v3) = v68;
          }
          v68 = --HIDWORD(v3);
        }
        v23 = *(_DWORD *)(v3 + 5812);
        v24 = *(unsigned __int16 *)(v3 + 2742);
        if ( v23 <= 16 - (unsigned __int16)v24 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2740) << v23;
          *(_DWORD *)(v3 + 5812) = v24 + v23;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2740);
          v25 = WORD2(v3) << v23;
          v26 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v25;
          *(_BYTE *)(v26 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v27 = *(_DWORD *)(v3 + 8);
          LOBYTE(v26) = *(_BYTE *)(v3 + 5809);
          v28 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v28;
          *(_BYTE *)(v28 + v27) = v26;
          v29 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v29);
          *(_DWORD *)(v3 + 5812) = v29 + v24 - 16;
          HIDWORD(v3) = v68;
        }
        v30 = *(_DWORD *)(v3 + 5812);
        if ( v30 > 14 )
        {
          HIDWORD(v3) -= 3;
          v31 = HIDWORD(v3) << v30;
          v32 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v31;
          *(_BYTE *)(v32 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v33 = *(_DWORD *)(v3 + 8);
          LOBYTE(v32) = *(_BYTE *)(v3 + 5809);
          v34 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v34;
          *(_BYTE *)(v34 + v33) = v32;
          v35 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v35 - 14;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v35);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v30;
        v36 = v30 + 2;
      }
      else if ( SHIDWORD(v3) > 10 )
      {
        v50 = *(_DWORD *)(v3 + 5812);
        v51 = *(unsigned __int16 *)(v3 + 2750);
        if ( v50 <= 16 - (unsigned __int16)v51 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2748) << v50;
          *(_DWORD *)(v3 + 5812) = v51 + v50;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2748);
          v52 = WORD2(v3) << v50;
          v53 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v52;
          *(_BYTE *)(v53 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v54 = *(_DWORD *)(v3 + 8);
          LOBYTE(v53) = *(_BYTE *)(v3 + 5809);
          v55 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v55;
          *(_BYTE *)(v55 + v54) = v53;
          v56 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v56);
          *(_DWORD *)(v3 + 5812) = v56 + v51 - 16;
          HIDWORD(v3) = v68;
        }
        v57 = *(_DWORD *)(v3 + 5812);
        if ( v57 > 9 )
        {
          HIDWORD(v3) -= 11;
          v58 = HIDWORD(v3) << v57;
          v59 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v58;
          *(_BYTE *)(v59 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v60 = *(_DWORD *)(v3 + 8);
          LOBYTE(v59) = *(_BYTE *)(v3 + 5809);
          v61 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v61;
          *(_BYTE *)(v61 + v60) = v59;
          v62 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v62 - 9;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v62);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 11) << v57;
        v36 = v57 + 7;
      }
      else
      {
        v37 = *(_DWORD *)(v3 + 5812);
        v38 = *(unsigned __int16 *)(v3 + 2746);
        if ( v37 <= 16 - (unsigned __int16)v38 )
        {
          *(_WORD *)(v3 + 5808) |= *(_WORD *)(v3 + 2744) << v37;
          *(_DWORD *)(v3 + 5812) = v38 + v37;
        }
        else
        {
          WORD2(v3) = *(_WORD *)(v3 + 2744);
          v39 = WORD2(v3) << v37;
          v40 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v39;
          *(_BYTE *)(v40 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v41 = *(_DWORD *)(v3 + 8);
          LOBYTE(v40) = *(_BYTE *)(v3 + 5809);
          v42 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v42;
          *(_BYTE *)(v42 + v41) = v40;
          v43 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v43);
          *(_DWORD *)(v3 + 5812) = v43 + v38 - 16;
          HIDWORD(v3) = v68;
        }
        v44 = *(_DWORD *)(v3 + 5812);
        if ( v44 > 13 )
        {
          HIDWORD(v3) -= 3;
          v45 = HIDWORD(v3) << v44;
          v46 = *(_DWORD *)(v3 + 8);
          *(_WORD *)(v3 + 5808) |= v45;
          *(_BYTE *)(v46 + *(_DWORD *)(v3 + 20)) = *(_BYTE *)(v3 + 5808);
          v47 = *(_DWORD *)(v3 + 8);
          LOBYTE(v46) = *(_BYTE *)(v3 + 5809);
          v48 = *(_DWORD *)(v3 + 20) + 1;
          *(_DWORD *)(v3 + 20) = v48;
          *(_BYTE *)(v48 + v47) = v46;
          v49 = *(_DWORD *)(v3 + 5812);
          ++*(_DWORD *)(v3 + 20);
          *(_DWORD *)(v3 + 5812) = v49 - 13;
          *(_WORD *)(v3 + 5808) = WORD2(v3) >> (16 - v49);
          goto LABEL_39;
        }
        *(_WORD *)(v3 + 5808) |= (HIDWORD(v3) - 3) << v44;
        v36 = v44 + 3;
      }
      *(_DWORD *)(v3 + 5812) = v36;
LABEL_39:
      v4 = v67;
      HIDWORD(v3) = 0;
      v65 = v8;
      if ( v67 )
      {
        if ( v8 == v67 )
        {
          v5 = 6;
          v6 = 3;
        }
        else
        {
          v5 = 7;
          v6 = 4;
        }
      }
      else
      {
        v5 = 138;
        v6 = 3;
      }
LABEL_44:
      v63 = v66 == 1;
      v69 += 2;
      --v66;
    }
    while ( !v63 );
  }
  return v3;
}

// sub_10048CD0 @ 0x10048CD0
int __cdecl sub_10048CD0(int a1, int a2, int a3)
{
  int result; // eax
  unsigned int v4; // ecx
  int v5; // ebp
  int v6; // edi
  int v7; // edx
  int v8; // ecx
  unsigned __int16 v9; // si
  int v10; // edx
  int v11; // ecx
  int v12; // ebx
  int v13; // edx
  int v14; // edx
  int v15; // ecx
  int v16; // ecx
  int v17; // ebx
  int v18; // esi
  unsigned __int16 v19; // si
  int v20; // ebp
  int v21; // ebx
  char v22; // cl
  int v23; // ebx
  __int16 v24; // si
  int v25; // ecx
  __int16 v26; // bp
  int v27; // ecx
  int v28; // esi
  int v29; // edx
  int v30; // ecx
  int v31; // ebp
  int v32; // ebx
  char v33; // cl
  int v34; // ebx
  unsigned int v35; // edi
  int v36; // ebx
  int v37; // ecx
  int v38; // esi
  unsigned __int16 v39; // dx
  int v40; // ebp
  int v41; // ebx
  char v42; // cl
  int v43; // ebx
  int v44; // edx
  int v45; // edx
  unsigned int v46; // edi
  int v47; // ecx
  unsigned int v48; // esi
  int v49; // ecx
  int v50; // ebx
  int v51; // esi
  int v52; // esi
  int v53; // ecx
  int v54; // esi
  unsigned __int16 v55; // dx
  int v56; // edi
  int v57; // ecx
  int v58; // ebx
  int v59; // edi
  int v60; // edi
  int v61; // [esp+10h] [ebp-8h]
  unsigned int v62; // [esp+14h] [ebp-4h]
  int v63; // [esp+1Ch] [ebp+4h]
  int v64; // [esp+1Ch] [ebp+4h]

  result = a1;
  v4 = 0;
  v5 = a2;
  if ( *(_DWORD *)(a1 + 5784) )
  {
    while ( 1 )
    {
      v6 = *(unsigned __int16 *)(*(_DWORD *)(result + 5788) + 2 * v4);
      v7 = *(unsigned __int8 *)(v4 + *(_DWORD *)(result + 5776));
      v62 = v4 + 1;
      if ( !(_WORD)v6 )
        break;
      v16 = *(_DWORD *)(result + 5812);
      v17 = (unsigned __int8)byte_10051268[v7];
      v63 = v17;
      v18 = *(unsigned __int16 *)(v5 + 4 * v17 + 1030);
      v61 = (unsigned __int16)v18;
      if ( v16 <= 16 - (unsigned __int16)v18 )
      {
        v26 = *(_WORD *)(a2 + 4 * v17 + 1028) << v16;
        v27 = *(_DWORD *)(result + 5812);
        *(_WORD *)(result + 5808) |= v26;
        v25 = v18 + v27;
      }
      else
      {
        v19 = *(_WORD *)(a2 + 4 * v17 + 1028);
        v20 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v19 << v16;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v20) = *(_BYTE *)(result + 5808);
        v21 = *(_DWORD *)(result + 20) + 1;
        v22 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v21;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v21) = v22;
        v23 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v24 = v19 >> (16 - v23);
        v25 = v23 + v61 - 16;
        v17 = v63;
        *(_WORD *)(result + 5808) = v24;
      }
      *(_DWORD *)(result + 5812) = v25;
      v28 = dword_10050A24[v17];
      if ( v28 )
      {
        v29 = v7 - dword_10051368[v17];
        v30 = *(_DWORD *)(result + 5812);
        if ( v30 <= 16 - v28 )
        {
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_DWORD *)(result + 5812) = v28 + v30;
        }
        else
        {
          v31 = *(_DWORD *)(result + 8);
          *(_WORD *)(result + 5808) |= v29 << v30;
          *(_BYTE *)(*(_DWORD *)(result + 20) + v31) = *(_BYTE *)(result + 5808);
          v32 = *(_DWORD *)(result + 20) + 1;
          v33 = *(_BYTE *)(result + 5809);
          *(_DWORD *)(result + 20) = v32;
          *(_BYTE *)(*(_DWORD *)(result + 8) + v32) = v33;
          v34 = *(_DWORD *)(result + 5812);
          ++*(_DWORD *)(result + 20);
          *(_WORD *)(result + 5808) = (unsigned __int16)v29 >> (16 - v34);
          *(_DWORD *)(result + 5812) = v34 + v28 - 16;
        }
      }
      v35 = v6 - 1;
      if ( v35 >= 0x100 )
        v36 = (unsigned __int8)byte_10051168[v35 >> 7];
      else
        v36 = (unsigned __int8)byte_10051068[v35];
      v37 = *(_DWORD *)(result + 5812);
      v38 = *(unsigned __int16 *)(a3 + 4 * v36 + 2);
      v64 = v36;
      if ( v37 <= 16 - (unsigned __int16)v38 )
      {
        v5 = a2;
        *(_WORD *)(result + 5808) |= *(_WORD *)(a3 + 4 * v36) << v37;
        *(_DWORD *)(result + 5812) = v38 + v37;
      }
      else
      {
        v39 = *(_WORD *)(a3 + 4 * v36);
        v40 = *(_DWORD *)(result + 8);
        *(_WORD *)(result + 5808) |= v39 << v37;
        *(_BYTE *)(*(_DWORD *)(result + 20) + v40) = *(_BYTE *)(result + 5808);
        v41 = *(_DWORD *)(result + 20) + 1;
        v42 = *(_BYTE *)(result + 5809);
        *(_DWORD *)(result + 20) = v41;
        *(_BYTE *)(*(_DWORD *)(result + 8) + v41) = v42;
        v43 = *(_DWORD *)(result + 5812);
        ++*(_DWORD *)(result + 20);
        v5 = a2;
        *(_WORD *)(result + 5808) = v39 >> (16 - v43);
        v44 = v43 + v38 - 16;
        v36 = v64;
        *(_DWORD *)(result + 5812) = v44;
      }
      v45 = dword_10050A98[v36];
      if ( !v45 )
        goto LABEL_24;
      v46 = v35 - dword_100513DC[v36];
      v47 = *(_DWORD *)(result + 5812);
      if ( v47 <= 16 - v45 )
      {
        *(_WORD *)(result + 5808) |= v46 << v47;
        v15 = v45 + v47;
LABEL_23:
        *(_DWORD *)(result + 5812) = v15;
        goto LABEL_24;
      }
      v48 = v46 << v47;
      v49 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v48;
      *(_BYTE *)(v49 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v50 = *(_DWORD *)(result + 8);
      LOBYTE(v49) = *(_BYTE *)(result + 5809);
      v51 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v51;
      *(_BYTE *)(v51 + v50) = v49;
      v52 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      *(_DWORD *)(result + 5812) = v52 + v45 - 16;
      *(_WORD *)(result + 5808) = (unsigned __int16)v46 >> (16 - v52);
LABEL_24:
      v4 = v62;
      if ( v62 >= *(_DWORD *)(result + 5784) )
        goto LABEL_25;
    }
    LOWORD(v6) = *(_WORD *)(v5 + 4 * v7 + 2);
    v8 = *(_DWORD *)(result + 5812);
    if ( v8 <= 16 - (unsigned __int16)v6 )
    {
      *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 4 * v7) << v8;
      v15 = v6 + v8;
    }
    else
    {
      v9 = *(_WORD *)(v5 + 4 * v7);
      v10 = v9 << v8;
      v11 = *(_DWORD *)(result + 8);
      *(_WORD *)(result + 5808) |= v10;
      *(_BYTE *)(v11 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
      v12 = *(_DWORD *)(result + 8);
      v13 = *(_DWORD *)(result + 20) + 1;
      *(_DWORD *)(result + 20) = v13;
      *(_BYTE *)(v13 + v12) = *(_BYTE *)(result + 5809);
      v14 = *(_DWORD *)(result + 5812);
      ++*(_DWORD *)(result + 20);
      v15 = v14 + v6 - 16;
      *(_WORD *)(result + 5808) = v9 >> (16 - v14);
    }
    goto LABEL_23;
  }
LABEL_25:
  v53 = *(_DWORD *)(result + 5812);
  v54 = *(unsigned __int16 *)(v5 + 1026);
  if ( v53 <= 16 - (unsigned __int16)v54 )
  {
    *(_WORD *)(result + 5808) |= *(_WORD *)(v5 + 1024) << v53;
    *(_DWORD *)(result + 5812) = v54 + v53;
  }
  else
  {
    v55 = *(_WORD *)(v5 + 1024);
    v56 = v55 << v53;
    v57 = *(_DWORD *)(result + 8);
    *(_WORD *)(result + 5808) |= v56;
    *(_BYTE *)(v57 + *(_DWORD *)(result + 20)) = *(_BYTE *)(result + 5808);
    v58 = *(_DWORD *)(result + 8);
    LOBYTE(v57) = *(_BYTE *)(result + 5809);
    v59 = *(_DWORD *)(result + 20) + 1;
    *(_DWORD *)(result + 20) = v59;
    *(_BYTE *)(v59 + v58) = v57;
    v60 = *(_DWORD *)(result + 5812);
    ++*(_DWORD *)(result + 20);
    *(_WORD *)(result + 5808) = v55 >> (16 - v60);
    *(_DWORD *)(result + 5812) = v60 + v54 - 16;
  }
  *(_DWORD *)(result + 5804) = *(unsigned __int16 *)(v5 + 1026);
  return result;
}

// sub_10049110 @ 0x10049110
int __cdecl sub_10049110(int a1)
{
  int result; // eax
  int v2; // edx
  int v3; // esi
  int v4; // edx

  result = a1;
  v2 = *(_DWORD *)(a1 + 5812);
  if ( v2 <= 8 )
  {
    if ( v2 > 0 )
      *(_BYTE *)(*(_DWORD *)(a1 + 8) + (*(_DWORD *)(a1 + 20))++) = *(_BYTE *)(a1 + 5808);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  else
  {
    *(_BYTE *)(*(_DWORD *)(a1 + 8) + *(_DWORD *)(a1 + 20)) = *(_BYTE *)(a1 + 5808);
    v3 = *(_DWORD *)(a1 + 8);
    v4 = *(_DWORD *)(a1 + 20) + 1;
    *(_DWORD *)(a1 + 20) = v4;
    *(_BYTE *)(v3 + v4) = *(_BYTE *)(a1 + 5809);
    ++*(_DWORD *)(a1 + 20);
    *(_WORD *)(a1 + 5808) = 0;
    *(_DWORD *)(a1 + 5812) = 0;
  }
  return result;
}

// sub_10049190 @ 0x10049190
int __cdecl sub_10049190(unsigned int a1, unsigned __int8 *a2, unsigned int a3)
{
  unsigned __int8 *v3; // esi
  unsigned int v4; // ecx
  unsigned int v5; // edi
  unsigned int i; // ebx
  int v8; // eax
  unsigned int v9; // ebp
  int v10; // edx
  int v11; // ecx
  int v12; // edi
  int v13; // ecx
  int v14; // edi
  int v15; // ecx
  int v16; // edi
  int v17; // ecx
  int v18; // edi
  int v19; // ecx
  int v20; // edi
  int v21; // ecx
  int v22; // edi
  int v23; // ecx
  int v24; // edi
  int v25; // ecx
  int v26; // edi
  int v27; // ecx
  int v28; // edi
  int v29; // ecx
  int v30; // edi
  int v31; // ecx
  int v32; // edi
  int v33; // ecx
  int v34; // edi
  int v35; // ecx
  int v36; // edi
  int v37; // ecx
  int v38; // edi
  int v39; // ecx
  int v40; // edi

  v3 = a2;
  v4 = (unsigned __int16)a1;
  v5 = HIWORD(a1);
  if ( !a2 )
    return 1;
  for ( i = a3; i; v5 %= 0xFFF1u )
  {
    v8 = i;
    if ( i >= 0x15B0 )
      v8 = 5552;
    i -= v8;
    if ( v8 >= 16 )
    {
      v9 = (unsigned int)v8 >> 4;
      v8 += -16 * ((unsigned int)v8 >> 4);
      do
      {
        v10 = *v3;
        v3 += 16;
        v11 = v10 + v4;
        v12 = v11 + v5;
        v13 = *(v3 - 15) + v11;
        v14 = v13 + v12;
        v15 = *(v3 - 14) + v13;
        v16 = v15 + v14;
        v17 = *(v3 - 13) + v15;
        v18 = v17 + v16;
        v19 = *(v3 - 12) + v17;
        v20 = v19 + v18;
        v21 = *(v3 - 11) + v19;
        v22 = v21 + v20;
        v23 = *(v3 - 10) + v21;
        v24 = v23 + v22;
        v25 = *(v3 - 9) + v23;
        v26 = v25 + v24;
        v27 = *(v3 - 8) + v25;
        v28 = v27 + v26;
        v29 = *(v3 - 7) + v27;
        v30 = v29 + v28;
        v31 = *(v3 - 6) + v29;
        v32 = v31 + v30;
        v33 = *(v3 - 5) + v31;
        v34 = v33 + v32;
        v35 = *(v3 - 4) + v33;
        v36 = v35 + v34;
        v37 = *(v3 - 3) + v35;
        v38 = v37 + v36;
        v39 = *(v3 - 2) + v37;
        v40 = v39 + v38;
        v4 = *(v3 - 1) + v39;
        v5 = v4 + v40;
        --v9;
      }
      while ( v9 );
    }
    for ( ; v8; --v8 )
    {
      v4 += *v3++;
      v5 += v4;
    }
    v4 %= 0xFFF1u;
  }
  return v4 | (v5 << 16);
}

// sub_100492C0 @ 0x100492C0
int (__cdecl *__cdecl sub_100492C0(_DWORD *a1, int a2, _DWORD *a3))(_DWORD, _DWORD, _DWORD)
{
  int v3; // eax
  int (__cdecl *result)(_DWORD, _DWORD, _DWORD); // eax

  if ( a3 )
    *a3 = a1[15];
  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    sub_1004A980(a1[1], a2);
  v3 = a1[10];
  *a1 = 0;
  a1[13] = v3;
  a1[12] = v3;
  result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  a1[7] = 0;
  a1[8] = 0;
  if ( result )
  {
    result = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))result(0, 0, 0);
    a1[15] = result;
    *(_DWORD *)(a2 + 48) = result;
  }
  return result;
}

// sub_10049340 @ 0x10049340
int __cdecl sub_10049340(int a1, int (__cdecl *a2)(_DWORD, _DWORD, _DWORD), int a3)
{
  int result; // eax
  _DWORD *v4; // esi
  int v5; // eax
  int v6; // eax
  int v7; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, 64);
  v4 = (_DWORD *)result;
  if ( result )
  {
    v5 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 8, 1440);
    v4[9] = v5;
    if ( v5 )
    {
      v6 = (*(int (__cdecl **)(_DWORD, int, int))(a1 + 32))(*(_DWORD *)(a1 + 40), 1, a3);
      v4[10] = v6;
      if ( v6 )
      {
        *v4 = 0;
        v4[11] = v6 + a3;
        v4[14] = a2;
        v4[7] = 0;
        v4[8] = 0;
        v4[13] = v6;
        v4[12] = v6;
        if ( a2 )
        {
          v7 = a2(0, 0, 0);
          v4[15] = v7;
          *(_DWORD *)(a1 + 48) = v7;
        }
        return (int)v4;
      }
      else
      {
        (*(void (__cdecl **)(_DWORD, _DWORD))(a1 + 36))(*(_DWORD *)(a1 + 40), v4[9]);
        (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
        return 0;
      }
    }
    else
    {
      (*(void (__cdecl **)(_DWORD, _DWORD *))(a1 + 36))(*(_DWORD *)(a1 + 40), v4);
      return 0;
    }
  }
  return result;
}

// sub_10049400 @ 0x10049400
int __cdecl sub_10049400(_DWORD *a1, unsigned __int8 **a2, int a3)
{
  unsigned int v4; // ebp
  char *v5; // ecx
  unsigned int v6; // eax
  int v7; // eax
  unsigned int v8; // esi
  unsigned __int8 *v9; // eax
  unsigned __int8 *v10; // edi
  int v11; // edx
  unsigned int v12; // ebp
  int v13; // ecx
  int v14; // eax
  unsigned int v15; // esi
  unsigned __int8 *v16; // edi
  unsigned __int8 *v17; // eax
  int v18; // edx
  unsigned int v19; // edi
  unsigned int v20; // ecx
  char *v21; // ecx
  char *v22; // edx
  unsigned int v23; // eax
  unsigned int v24; // esi
  int v25; // eax
  char *v26; // edx
  unsigned int v27; // esi
  unsigned int v28; // eax
  unsigned int v29; // eax
  unsigned int v30; // eax
  unsigned int v31; // ecx
  unsigned int v32; // edi
  unsigned __int8 *v33; // esi
  unsigned __int8 *v34; // eax
  int v35; // edx
  unsigned int v36; // eax
  unsigned int v37; // ecx
  unsigned __int8 **v38; // esi
  int v39; // eax
  unsigned int v40; // edi
  unsigned __int8 *v41; // eax
  char v42; // cl
  int v43; // eax
  unsigned int v44; // edx
  unsigned int v45; // ecx
  unsigned int v46; // eax
  int v47; // edx
  int v48; // ecx
  int v49; // eax
  int v50; // edx
  unsigned int v51; // eax
  int v52; // eax
  int v53; // ecx
  int v54; // eax
  int v55; // eax
  int v56; // edx
  unsigned int v57; // edi
  int v58; // eax
  int v59; // ecx
  unsigned int v60; // eax
  int v61; // eax
  unsigned __int8 *v62; // edi
  unsigned __int8 *v63; // edx
  int v64; // eax
  char *v65; // ecx
  unsigned __int8 *v66; // edi
  unsigned int v67; // eax
  int v68; // eax
  int v69; // ebp
  int result; // eax
  unsigned __int8 *v71; // ebp
  unsigned __int8 *v72; // ebp
  unsigned __int8 *v73; // esi
  unsigned __int8 *v74; // ebp
  int v75; // ebp
  unsigned __int8 *v76; // ebp
  unsigned __int8 *v77; // edx
  unsigned __int8 *v78; // ebp
  unsigned __int8 *v79; // esi
  unsigned __int8 *v80; // esi
  unsigned __int8 *v81; // ebp
  unsigned __int8 *v82; // edi
  unsigned __int8 *v83; // edx
  unsigned __int8 *v84; // esi
  unsigned __int8 *v85; // ebp
  unsigned __int8 *v86; // ecx
  unsigned __int8 *v87; // edx
  bool v88; // zf
  unsigned __int8 *v89; // edi
  unsigned __int8 *v90; // ecx
  unsigned __int8 *v91; // edi
  unsigned __int8 *v92; // ecx
  unsigned __int8 *v93; // edi
  char *v94; // ecx
  unsigned __int8 *v95; // ebp
  unsigned __int8 *v96; // ebp
  unsigned __int8 *v97; // esi
  unsigned __int8 *v98; // ebp
  unsigned __int8 *v99; // esi
  unsigned __int8 *v100; // ebp
  int v101; // [esp-1Ch] [ebp-5Ch]
  int v102; // [esp-14h] [ebp-54h]
  int v103; // [esp-8h] [ebp-48h]
  int v104; // [esp-8h] [ebp-48h]
  unsigned __int8 *v105; // [esp+10h] [ebp-30h]
  unsigned __int8 *v106; // [esp+14h] [ebp-2Ch]
  unsigned int v107; // [esp+18h] [ebp-28h]
  int v108; // [esp+18h] [ebp-28h]
  int v109; // [esp+18h] [ebp-28h]
  int v110; // [esp+18h] [ebp-28h]
  int v111; // [esp+1Ch] [ebp-24h] BYREF
  unsigned int v112; // [esp+20h] [ebp-20h] BYREF
  int v113; // [esp+24h] [ebp-1Ch] BYREF
  int v114; // [esp+28h] [ebp-18h] BYREF
  int v115; // [esp+2Ch] [ebp-14h] BYREF
  int v116; // [esp+30h] [ebp-10h] BYREF
  unsigned int v117; // [esp+34h] [ebp-Ch]
  int v118; // [esp+38h] [ebp-8h] BYREF
  int v119; // [esp+3Ch] [ebp-4h] BYREF
  char *v120; // [esp+44h] [ebp+4h]
  int v121; // [esp+4Ch] [ebp+Ch]

  v4 = a1[7];
  v105 = *a2;
  v5 = (char *)a1[13];
  v107 = a1[8];
  v6 = a1[12];
  v106 = a2[1];
  v120 = v5;
  if ( (unsigned int)v5 >= v6 )
    v7 = a1[11] - (_DWORD)v5;
  else
    v7 = v6 - (_DWORD)v5 - 1;
  v111 = v7;
  while ( 2 )
  {
    switch ( *a1 )
    {
      case 0:
        v8 = v107;
        if ( v4 >= 3 )
        {
          v10 = v105;
LABEL_12:
          a1[6] = v8 & 1;
          switch ( (unsigned __int8)(v8 & 7) >> 1 )
          {
            case 0:
              v12 = v4 - 3;
              *a1 = 1;
              v13 = v12 & 7;
              v4 = v12 - v13;
              v107 = v8 >> 3 >> v13;
              continue;
            case 1:
              inflate_trees_fixed(&v116, &v115, &v114, &v113);
              v14 = sub_1004A190(v116, v115, v114, v113, a2);
              a1[1] = v14;
              if ( v14 )
              {
                v107 = v8 >> 3;
                v4 -= 3;
                *a1 = 6;
                continue;
              }
              a1[8] = v8;
              a1[7] = v4;
              v71 = a2[2];
              a2[1] = v106;
              a2[2] = &v71[v10 - *a2];
              *a2 = v10;
              a1[13] = v120;
              result = sub_1004B0E0(a1, a2, -4);
              break;
            case 2:
              v107 = v8 >> 3;
              v4 -= 3;
              *a1 = 3;
              continue;
            case 3:
              *a1 = 9;
              a2[6] = (unsigned __int8 *)aInvalidBlockTy_0;
              a1[8] = v8 >> 3;
              a1[7] = v4 - 3;
              v72 = a2[2];
              a2[1] = v106;
              a2[2] = &v72[v10 - *a2];
              *a2 = v10;
              a1[13] = v120;
              return sub_1004B0E0(a1, a2, -3);
            default:
              continue;
          }
        }
        else
        {
          v9 = v106;
          v10 = v105;
          while ( v9 )
          {
            --v9;
            a3 = 0;
            v11 = *v10 << v4;
            v4 += 8;
            v106 = v9;
            v8 |= v11;
            ++v10;
            v107 = v8;
            v105 = v10;
            if ( v4 >= 3 )
              goto LABEL_12;
          }
          a1[8] = v8;
          a1[7] = v4;
          v69 = (int)&a2[2][v10 - *a2];
          a2[1] = 0;
          a2[2] = (unsigned __int8 *)v69;
          *a2 = v10;
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, a3);
        }
        return result;
      case 1:
        v15 = v107;
        v16 = v106;
        v17 = v105;
        if ( v4 >= 0x20 )
          goto LABEL_20;
        do
        {
          if ( !v16 )
          {
            a1[8] = v15;
            a1[7] = v4;
            v73 = *a2;
            v74 = a2[2];
            a2[1] = 0;
            *a2 = v17;
            a2[2] = &v74[v17 - v73];
            a1[13] = v120;
            return sub_1004B0E0(a1, a2, a3);
          }
          a3 = 0;
          --v16;
          v18 = *v17 << v4;
          v4 += 8;
          v106 = v16;
          v15 |= v18;
          v105 = ++v17;
        }
        while ( v4 < 0x20 );
LABEL_20:
        if ( (unsigned __int16)v15 != ~v15 >> 16 )
        {
          *a1 = 9;
          a2[6] = (unsigned __int8 *)aInvalidStoredB_0;
          a1[8] = v15;
          a1[7] = v4;
          v75 = (int)&a2[2][v17 - *a2];
          *a2 = v17;
          a2[1] = v16;
          a2[2] = (unsigned __int8 *)v75;
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -3);
        }
        v4 = 0;
        a1[1] = (unsigned __int16)v15;
        v107 = 0;
        if ( (_WORD)v15 )
        {
          *a1 = 2;
          continue;
        }
LABEL_47:
        *a1 = a1[6] != 0 ? 7 : 0;
        continue;
      case 2:
        v19 = (unsigned int)v106;
        if ( !v106 )
        {
          a1[8] = v107;
          a1[7] = v4;
          v76 = a2[2];
          v77 = (unsigned __int8 *)(v105 - *a2);
          *a2 = v105;
          a2[1] = 0;
          a2[2] = &v76[(_DWORD)v77];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, a3);
        }
        v20 = v111;
        if ( v111 )
          goto LABEL_42;
        v21 = (char *)a1[11];
        v22 = v120;
        if ( v120 == v21 )
        {
          v23 = a1[12];
          v24 = a1[10];
          if ( v23 != v24 )
          {
            v22 = (char *)a1[10];
            v120 = v22;
            v20 = v24 >= v23 ? (unsigned int)&v21[-v24] : v23 - v24 - 1;
            v111 = v20;
            if ( v20 )
              goto LABEL_42;
          }
        }
        a1[13] = v22;
        v25 = sub_1004B0E0(a1, a2, a3);
        v26 = (char *)a1[13];
        v27 = a1[12];
        v121 = v25;
        v120 = v26;
        if ( (unsigned int)v26 >= v27 )
          v20 = a1[11] - (_DWORD)v26;
        else
          v20 = v27 - (_DWORD)v26 - 1;
        v28 = a1[11];
        v111 = v20;
        v112 = v28;
        if ( v26 == (char *)v28 )
        {
          v29 = a1[10];
          if ( v27 != v29 )
          {
            v26 = (char *)a1[10];
            v120 = v26;
            if ( v29 >= v27 )
              v20 = v112 - v29;
            else
              v20 = v27 - v29 - 1;
            v111 = v20;
          }
        }
        if ( !v20 )
        {
          a1[8] = v107;
          a1[7] = v4;
          v78 = *a2;
          v79 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v79[v105 - v78];
          a1[13] = v26;
          return sub_1004B0E0(a1, a2, v121);
        }
        v19 = (unsigned int)v106;
LABEL_42:
        v30 = a1[1];
        a3 = 0;
        if ( v30 > v19 )
          v30 = v19;
        if ( v30 > v20 )
          v30 = v20;
        qmemcpy(v120, v105, v30);
        v105 += v30;
        v31 = a1[1] - v30;
        v106 -= v30;
        v120 += v30;
        v111 -= v30;
        a1[1] = v31;
        if ( !v31 )
          goto LABEL_47;
        continue;
      case 3:
        v32 = v107;
        if ( v4 >= 0xE )
          goto LABEL_52;
        v33 = v106;
        v34 = v105;
        do
        {
          if ( !v33 )
          {
            a1[8] = v32;
            a1[7] = v4;
            v80 = *a2;
            v81 = a2[2];
            *a2 = v105;
            a2[1] = 0;
            a2[2] = &v81[v105 - v80];
            a1[13] = v120;
            return sub_1004B0E0(a1, a2, a3);
          }
          --v33;
          a3 = 0;
          v35 = *v34 << v4;
          v4 += 8;
          v106 = v33;
          v32 |= v35;
          v105 = ++v34;
        }
        while ( v4 < 0xE );
LABEL_52:
        v36 = v32 & 0x3FFF;
        a1[1] = v36;
        v37 = v32 & 0x1F;
        if ( v37 > 0x1D || (v32 & 0x3E0) > 0x3A0 )
        {
          *a1 = 9;
          a2[6] = (unsigned __int8 *)aTooManyLengthO_0;
          a1[8] = v32;
          a1[7] = v4;
          v84 = *a2;
          v85 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v85[v105 - v84];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -3);
        }
        v38 = a2;
        v39 = ((int (__cdecl *)(unsigned __int8 *, unsigned int, int))a2[8])(a2[10], ((v36 >> 5) & 0x1F) + v37 + 258, 4);
        a1[3] = v39;
        if ( !v39 )
        {
          a1[8] = v32;
          a1[7] = v4;
          v82 = *a2;
          v83 = a2[2];
          a2[1] = v106;
          *a2 = v105;
          a2[2] = &v83[v105 - v82];
          a1[13] = v120;
          return sub_1004B0E0(a1, a2, -4);
        }
        v40 = v32 >> 14;
        v4 -= 14;
        a1[2] = 0;
        *a1 = 4;
LABEL_57:
        if ( a1[2] < (unsigned int)((a1[1] >> 10) + 4) )
        {
          while ( v4 >= 3 )
          {
LABEL_62:
            v43 = v40 & 7;
            v4 -= 3;
            v40 >>= 3;
            *(_DWORD *)(a1[3] + 4 * dword_10051454[a1[2]]) = v43;
            v44 = a1[2] + 1;
            a1[2] = v44;
            if ( v44 >= (a1[1] >> 10) + 4 )
              goto LABEL_63;
          }
          v41 = v105;
          while ( v106 )
          {
            --v106;
            v42 = v4;
            v4 += 8;
            a3 = 0;
            v40 |= *v41++ << v42;
            v105 = v41;
            if ( v4 >= 3 )
              goto LABEL_62;
          }
          goto LABEL_107;
        }
LABEL_63:
        if ( a1[2] < 0x13u )
        {
          do
          {
            *(_DWORD *)(a1[3] + 4 * dword_10051454[a1[2]]) = 0;
            v45 = a1[2] + 1;
            a1[2] = v45;
          }
          while ( v45 < 0x13 );
        }
        v103 = a1[9];
        v102 = a1[3];
        a1[4] = 7;
        v108 = sub_1004A9A0(v102, a1 + 4, a1 + 5, v103, v38);
        if ( v108 )
        {
          ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
          v88 = v108 == -3;
LABEL_112:
          if ( v88 )
            *a1 = 9;
          a1[8] = v40;
          a1[7] = v4;
          v91 = *v38;
          v38[1] = v106;
          v92 = v38[2];
          *v38 = v105;
          v38[2] = &v92[v105 - v91];
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, v108);
        }
        a1[2] = 0;
        *a1 = 5;
LABEL_68:
        if ( a1[2] < ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
        {
          while ( 1 )
          {
            v46 = a1[4];
            if ( v4 < v46 )
              break;
LABEL_72:
            v48 = a1[5];
            v49 = v40 & dword_10059608[v46];
            v50 = *(unsigned __int8 *)(v48 + 8 * v49 + 1);
            v109 = v50;
            v51 = *(_DWORD *)(v48 + 8 * v49 + 4);
            v117 = v51;
            if ( v51 >= 0x10 )
            {
              v53 = 7;
              if ( v51 != 18 )
                v53 = v51 - 14;
              v111 = v53;
              v54 = -(v51 != 18);
              LOBYTE(v54) = v54 & 0xF8;
              v112 = v50 + v53;
              v55 = v54 + 11;
              if ( v4 < v50 + v53 )
              {
                while ( v106 )
                {
                  a3 = 0;
                  --v106;
                  v56 = *v105 << v4;
                  v4 += 8;
                  v40 |= v56;
                  ++v105;
                  if ( v4 >= v112 )
                  {
                    v50 = v109;
                    goto LABEL_80;
                  }
                }
                goto LABEL_107;
              }
LABEL_80:
              v57 = v40 >> v50;
              v58 = (v57 & dword_10059608[v111]) + v55;
              v40 = v57 >> v111;
              v110 = v58;
              v4 -= v50 + v111;
              v111 = a1[2];
              if ( v111 + v58 > ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
                goto LABEL_110;
              if ( v117 == 16 )
              {
                v52 = v111;
                if ( !v111 )
                {
LABEL_110:
                  ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
                  *a1 = 9;
                  v38[6] = (unsigned __int8 *)aInvalidBitLeng_0;
                  a1[8] = v40;
                  a1[7] = v4;
                  v89 = *v38;
                  v38[1] = v106;
                  v90 = v38[2];
                  *v38 = v105;
                  v38[2] = &v90[v105 - v89];
                  a1[13] = v120;
                  return sub_1004B0E0(a1, v38, -3);
                }
                v59 = *(_DWORD *)(a1[3] + 4 * v111 - 4);
              }
              else
              {
                v52 = v111;
                v59 = 0;
              }
              do
              {
                ++v52;
                *(_DWORD *)(a1[3] + 4 * v52 - 4) = v59;
                --v110;
              }
              while ( v110 );
            }
            else
            {
              v4 -= v50;
              v40 >>= v50;
              *(_DWORD *)(a1[3] + 4 * a1[2]) = v51;
              v52 = a1[2] + 1;
            }
            a1[2] = v52;
            if ( a1[2] >= ((a1[1] >> 5) & 0x1F) + (a1[1] & 0x1Fu) + 258 )
              goto LABEL_87;
          }
          while ( v106 )
          {
            a3 = 0;
            --v106;
            v47 = *v105 << v4;
            v4 += 8;
            v40 |= v47;
            ++v105;
            if ( v4 >= v46 )
              goto LABEL_72;
          }
LABEL_107:
          a1[8] = v40;
          a1[7] = v4;
          v86 = v38[2];
          v87 = (unsigned __int8 *)(v105 - *v38);
          *v38 = v105;
          v38[2] = &v86[(_DWORD)v87];
          v38[1] = 0;
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, a3);
        }
LABEL_87:
        v60 = a1[1];
        v104 = a1[9];
        v101 = a1[3];
        a1[5] = 0;
        v112 = 9;
        v111 = 6;
        v108 = sub_1004AF20((v60 & 0x1F) + 257, ((v60 >> 5) & 0x1F) + 1, v101, &v112, &v111, &v119, &v118, v104, v38);
        ((void (__cdecl *)(unsigned __int8 *, _DWORD))v38[9])(v38[10], a1[3]);
        if ( v108 )
        {
          v88 = v108 == -3;
          goto LABEL_112;
        }
        v61 = sub_1004A190(v112, v111, v119, v118, v38);
        if ( !v61 )
        {
          a1[8] = v40;
          a1[7] = v4;
          v93 = *v38;
          v38[1] = v106;
          v38[2] += v105 - v93;
          *v38 = v105;
          a1[13] = v120;
          return sub_1004B0E0(a1, v38, -4);
        }
        a1[1] = v61;
        *a1 = 6;
LABEL_91:
        a1[8] = v40;
        a1[7] = v4;
        v62 = *v38;
        v38[1] = v106;
        v63 = v38[2];
        *v38 = v105;
        v38[2] = &v63[v105 - v62];
        a1[13] = v120;
        v64 = sub_1004A1D0(a1, v38, a3);
        if ( v64 != 1 )
          return sub_1004B0E0(a1, v38, v64);
        a3 = 0;
        sub_1004A980(a1[1], v38);
        v65 = (char *)a1[13];
        v66 = *v38;
        v4 = a1[7];
        v107 = a1[8];
        v67 = a1[12];
        v105 = *v38;
        v106 = v38[1];
        v120 = v65;
        if ( (unsigned int)v65 >= v67 )
          v68 = a1[11] - (_DWORD)v65;
        else
          v68 = v67 - (_DWORD)v65 - 1;
        v111 = v68;
        if ( !a1[6] )
        {
          *a1 = 0;
          continue;
        }
        *a1 = 7;
LABEL_118:
        a1[13] = v65;
        v64 = sub_1004B0E0(a1, v38, a3);
        v94 = (char *)a1[13];
        if ( (char *)a1[12] != v94 )
        {
          a1[7] = v4;
          a1[8] = v107;
          v95 = *v38;
          v38[1] = v106;
          *v38 = v66;
          v38[2] += v66 - v95;
          a1[13] = v94;
          return sub_1004B0E0(a1, v38, v64);
        }
        *a1 = 8;
LABEL_123:
        a1[8] = v107;
        a1[7] = v4;
        v96 = *v38;
        v38[1] = v106;
        v38[2] += v66 - v96;
        *v38 = v66;
        a1[13] = v94;
        return sub_1004B0E0(a1, v38, 1);
      case 4:
        v40 = v107;
        v38 = a2;
        goto LABEL_57;
      case 5:
        v40 = v107;
        v38 = a2;
        goto LABEL_68;
      case 6:
        v40 = v107;
        v38 = a2;
        goto LABEL_91;
      case 7:
        v65 = v120;
        v38 = a2;
        v66 = v105;
        goto LABEL_118;
      case 8:
        v94 = v120;
        v38 = a2;
        v66 = v105;
        goto LABEL_123;
      case 9:
        a1[8] = v107;
        a1[7] = v4;
        v97 = *a2;
        v98 = a2[2];
        a2[1] = v106;
        *a2 = v105;
        a2[2] = &v98[v105 - v97];
        a1[13] = v120;
        return sub_1004B0E0(a1, a2, -3);
      default:
        a1[8] = v107;
        a1[7] = v4;
        v99 = *a2;
        v100 = a2[2];
        a2[1] = v106;
        *a2 = v105;
        a2[2] = &v100[v105 - v99];
        a1[13] = v120;
        return sub_1004B0E0(a1, a2, -2);
    }
  }
}

// sub_1004A100 @ 0x1004A100
int __cdecl sub_1004A100(_DWORD *a1, int a2)
{
  int v2; // eax
  int (__cdecl *v3)(_DWORD, _DWORD, _DWORD); // eax
  int v4; // eax

  if ( *a1 == 4 || *a1 == 5 )
    (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[3]);
  if ( *a1 == 6 )
    sub_1004A980(a1[1], a2);
  v2 = a1[10];
  a1[13] = v2;
  a1[12] = v2;
  v3 = (int (__cdecl *)(_DWORD, _DWORD, _DWORD))a1[14];
  *a1 = 0;
  a1[7] = 0;
  a1[8] = 0;
  if ( v3 )
  {
    v4 = v3(0, 0, 0);
    a1[15] = v4;
    *(_DWORD *)(a2 + 48) = v4;
  }
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[10]);
  (*(void (__cdecl **)(_DWORD, _DWORD))(a2 + 36))(*(_DWORD *)(a2 + 40), a1[9]);
  (*(void (__cdecl **)(_DWORD, _DWORD *))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
  return 0;
}

// sub_1004A190 @ 0x1004A190
int __cdecl sub_1004A190(char a1, char a2, int a3, int a4, int a5)
{
  int result; // eax

  result = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 1, 28);
  if ( result )
  {
    *(_BYTE *)(result + 16) = a1;
    *(_BYTE *)(result + 17) = a2;
    *(_DWORD *)result = 0;
    *(_DWORD *)(result + 20) = a3;
    *(_DWORD *)(result + 24) = a4;
  }
  return result;
}

// sub_1004A1D0 @ 0x1004A1D0
int __cdecl sub_1004A1D0(_DWORD *a1, unsigned __int8 **a2, int a3)
{
  _DWORD *v5; // eax
  unsigned __int8 *v6; // ebp
  unsigned int v7; // ebx
  unsigned int v8; // ecx
  _BYTE *v9; // edx
  int v10; // ecx
  unsigned __int8 *v11; // ebx
  unsigned __int8 *v12; // ecx
  int v13; // eax
  unsigned int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  unsigned int v17; // eax
  char v18; // cl
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  unsigned int v23; // eax
  char v24; // cl
  int v25; // ecx
  int v26; // ecx
  unsigned int v27; // eax
  char v28; // cl
  int v29; // ecx
  int v30; // ecx
  int v31; // ecx
  unsigned int v32; // eax
  char v33; // cl
  int v34; // ecx
  unsigned int v35; // eax
  unsigned int v36; // eax
  unsigned int v37; // ecx
  int v38; // eax
  int v39; // eax
  unsigned int v40; // eax
  int v41; // ecx
  unsigned int v42; // ecx
  int v43; // eax
  int v44; // ecx
  unsigned int v45; // eax
  unsigned int v46; // ecx
  int v47; // eax
  int v48; // eax
  unsigned int v49; // eax
  int v50; // ecx
  unsigned int v51; // ecx
  int v52; // eax
  unsigned __int8 *v53; // eax
  unsigned __int8 *v54; // ecx
  unsigned __int8 *v56; // ebx
  unsigned __int8 *v57; // ebx
  unsigned __int8 *v58; // ecx
  int v59; // eax
  unsigned __int8 *v60; // ebx
  unsigned __int8 *v61; // ebx
  unsigned __int8 *v62; // ebx
  _DWORD *v63; // [esp+10h] [ebp-10h]
  unsigned int v64; // [esp+14h] [ebp-Ch]
  unsigned int v65; // [esp+18h] [ebp-8h]
  unsigned __int8 *v66; // [esp+18h] [ebp-8h]
  unsigned int v67; // [esp+18h] [ebp-8h]
  unsigned int v68; // [esp+18h] [ebp-8h]
  unsigned int v69; // [esp+18h] [ebp-8h]
  _BYTE *v70; // [esp+1Ch] [ebp-4h]
  unsigned int v71; // [esp+24h] [ebp+4h]
  unsigned int v72; // [esp+28h] [ebp+8h]
  int v73; // [esp+2Ch] [ebp+Ch]

  v5 = (_DWORD *)a1[1];
  v6 = *a2;
  v7 = a1[7];
  v72 = (unsigned int)a2[1];
  v8 = a1[12];
  v71 = a1[8];
  v9 = (_BYTE *)a1[13];
  v63 = v5;
  if ( (unsigned int)v9 >= v8 )
    v10 = a1[11] - (_DWORD)v9;
  else
    v10 = v8 - (_DWORD)v9 - 1;
  v64 = v10;
  while ( 2 )
  {
    switch ( *v5 )
    {
      case 0:
        if ( v64 >= 0x102 && v72 >= 0xA )
        {
          a1[8] = v71;
          a1[7] = v7;
          v11 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          v12 = a2[2];
          *a2 = v6;
          a2[2] = &v12[v6 - v11];
          a1[13] = v9;
          v13 = sub_1004B220(*((unsigned __int8 *)v63 + 16), *((unsigned __int8 *)v63 + 17), v63[5], v63[6], a1, a2);
          v6 = *a2;
          v7 = a1[7];
          v72 = (unsigned int)a2[1];
          v14 = a1[12];
          v71 = a1[8];
          v9 = (_BYTE *)a1[13];
          a3 = v13;
          v15 = (unsigned int)v9 >= v14 ? a1[11] - (_DWORD)v9 : v14 - (_DWORD)v9 - 1;
          v64 = v15;
          if ( v13 )
          {
            *v63 = v13 != 1 ? 9 : 7;
            v5 = v63;
            continue;
          }
        }
        v5 = v63;
        v16 = *((unsigned __int8 *)v63 + 16);
        *v63 = 1;
        v63[3] = v16;
        v63[2] = v63[5];
        goto LABEL_14;
      case 1:
LABEL_14:
        v17 = v5[3];
        v65 = v17;
        if ( v7 >= v17 )
          goto LABEL_17;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v18 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v19 = (*v6 << v18) | v71;
          v17 = v65;
          ++v6;
          v71 = v19;
        }
        while ( v7 < v65 );
LABEL_17:
        v66 = (unsigned __int8 *)(v63[2] + 8 * (v71 & dword_10059608[v17]));
        v20 = v66[1];
        v71 >>= v20;
        v7 -= v20;
        v21 = *v66;
        if ( *v66 )
        {
          if ( (v21 & 0x10) != 0 )
          {
            v5 = v63;
            v63[2] = v21 & 0xF;
            v22 = *((_DWORD *)v66 + 1);
            *v63 = 2;
            v63[1] = v22;
          }
          else
          {
            if ( (v21 & 0x40) == 0 )
              goto LABEL_22;
            v5 = v63;
            if ( (v21 & 0x20) == 0 )
            {
              *v63 = 9;
              a2[6] = (unsigned __int8 *)aInvalidLiteral_0;
LABEL_88:
              a1[8] = v71;
              a1[7] = v7;
              v56 = *a2;
              a2[1] = (unsigned __int8 *)v72;
              a2[2] += v6 - v56;
              *a2 = v6;
              a1[13] = v9;
              return sub_1004B0E0(a1, a2, -3);
            }
            *v63 = 7;
          }
        }
        else
        {
          v5 = v63;
          v63[2] = *((_DWORD *)v66 + 1);
          *v63 = 6;
        }
        continue;
      case 2:
        v23 = v5[2];
        v67 = v23;
        if ( v7 >= v23 )
          goto LABEL_28;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v24 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v25 = (*v6 << v24) | v71;
          v23 = v67;
          ++v6;
          v71 = v25;
        }
        while ( v7 < v67 );
LABEL_28:
        v63[1] += v71 & dword_10059608[v23];
        v71 >>= v67;
        v7 -= v67;
        v5 = v63;
        v26 = *((unsigned __int8 *)v63 + 17);
        *v63 = 3;
        v63[3] = v26;
        v63[2] = v63[6];
LABEL_29:
        v27 = v5[3];
        v68 = v27;
        if ( v7 < v27 )
        {
          while ( v72 )
          {
            v28 = v7;
            --v72;
            v7 += 8;
            a3 = 0;
            v29 = (*v6 << v28) | v71;
            v27 = v68;
            ++v6;
            v71 = v29;
            if ( v7 >= v68 )
              goto LABEL_32;
          }
LABEL_86:
          a1[7] = v7;
          a1[8] = v71;
          v53 = a2[2];
          v54 = (unsigned __int8 *)(v6 - *a2);
          a2[1] = 0;
          *a2 = v6;
          a2[2] = &v53[(_DWORD)v54];
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, a3);
        }
LABEL_32:
        v66 = (unsigned __int8 *)(v63[2] + 8 * (v71 & dword_10059608[v27]));
        v30 = v66[1];
        v7 -= v30;
        v71 >>= v30;
        v21 = *v66;
        if ( (v21 & 0x10) != 0 )
        {
          v5 = v63;
          v63[2] = v21 & 0xF;
          v31 = *((_DWORD *)v66 + 1);
          *v63 = 4;
          v63[3] = v31;
        }
        else
        {
          if ( (v21 & 0x40) != 0 )
          {
            *v63 = 9;
            a2[6] = (unsigned __int8 *)aInvalidDistanc_0;
            goto LABEL_88;
          }
LABEL_22:
          v63[3] = v21;
          v5 = v63;
          v63[2] = &v66[8 * *((_DWORD *)v66 + 1)];
        }
        continue;
      case 3:
        goto LABEL_29;
      case 4:
        v32 = v5[2];
        v69 = v32;
        if ( v7 >= v32 )
          goto LABEL_39;
        do
        {
          if ( !v72 )
            goto LABEL_86;
          v33 = v7;
          --v72;
          v7 += 8;
          a3 = 0;
          v34 = (*v6 << v33) | v71;
          v32 = v69;
          ++v6;
          v71 = v34;
        }
        while ( v7 < v69 );
LABEL_39:
        v63[3] += v71 & dword_10059608[v32];
        v71 >>= v69;
        v7 -= v69;
        *v63 = 5;
LABEL_40:
        v35 = v63[3];
        if ( (unsigned int)&v9[-a1[10]] >= v35 )
          v70 = &v9[-v35];
        else
          v70 = &v9[a1[11] - a1[10] - v63[3]];
        v5 = v63;
        if ( !v63[1] )
        {
LABEL_65:
          *v5 = 0;
          continue;
        }
        while ( v64 )
        {
LABEL_62:
          ++v9;
          a3 = 0;
          *(v9 - 1) = *v70++;
          --v64;
          if ( v70 == (_BYTE *)a1[11] )
            v70 = (_BYTE *)a1[10];
          v44 = v5[1] - 1;
          v5[1] = v44;
          if ( !v44 )
            goto LABEL_65;
        }
        if ( v9 == (_BYTE *)a1[11] )
        {
          v36 = a1[12];
          v37 = a1[10];
          if ( v36 != v37 )
          {
            v9 = (_BYTE *)a1[10];
            v38 = v37 >= v36 ? a1[11] - v37 : v36 - v37 - 1;
            v64 = v38;
            if ( v38 )
              goto LABEL_61;
          }
        }
        a1[13] = v9;
        v39 = sub_1004B0E0(a1, a2, a3);
        v9 = (_BYTE *)a1[13];
        v73 = v39;
        v40 = a1[12];
        if ( (unsigned int)v9 >= v40 )
          v41 = a1[11] - (_DWORD)v9;
        else
          v41 = v40 - (_DWORD)v9 - 1;
        v64 = v41;
        if ( v9 == (_BYTE *)a1[11] )
        {
          v42 = a1[10];
          if ( v40 != v42 )
          {
            v9 = (_BYTE *)a1[10];
            if ( v42 >= v40 )
              v43 = a1[11] - v42;
            else
              v43 = v40 - v42 - 1;
            v64 = v43;
          }
        }
        if ( v64 )
        {
LABEL_61:
          v5 = v63;
          goto LABEL_62;
        }
LABEL_89:
        a1[8] = v71;
        a1[7] = v7;
        v57 = *a2;
        a2[1] = (unsigned __int8 *)v72;
        v58 = a2[2];
        *a2 = v6;
        a2[2] = &v58[v6 - v57];
        a1[13] = v9;
        return sub_1004B0E0(a1, a2, v73);
      case 5:
        goto LABEL_40;
      case 6:
        if ( v64 )
          goto LABEL_84;
        if ( v9 != (_BYTE *)a1[11]
          || (v45 = a1[12], v46 = a1[10], v45 == v46)
          || ((v9 = (_BYTE *)a1[10], v46 >= v45) ? (v47 = a1[11] - v46) : (v47 = v45 - v46 - 1), (v64 = v47) == 0) )
        {
          a1[13] = v9;
          v48 = sub_1004B0E0(a1, a2, a3);
          v9 = (_BYTE *)a1[13];
          v73 = v48;
          v49 = a1[12];
          if ( (unsigned int)v9 >= v49 )
            v50 = a1[11] - (_DWORD)v9;
          else
            v50 = v49 - (_DWORD)v9 - 1;
          v64 = v50;
          if ( v9 == (_BYTE *)a1[11] )
          {
            v51 = a1[10];
            if ( v49 != v51 )
            {
              v9 = (_BYTE *)a1[10];
              if ( v51 >= v49 )
                v52 = a1[11] - v51;
              else
                v52 = v49 - v51 - 1;
              v64 = v52;
            }
          }
          if ( !v64 )
            goto LABEL_89;
        }
        v5 = v63;
LABEL_84:
        a3 = 0;
        *v9++ = *((_BYTE *)v5 + 8);
        --v64;
        *v5 = 0;
        continue;
      case 7:
        if ( v7 > 7 )
        {
          v7 -= 8;
          --v6;
          ++v72;
        }
        a1[13] = v9;
        v59 = sub_1004B0E0(a1, a2, a3);
        v9 = (_BYTE *)a1[13];
        if ( (_BYTE *)a1[12] == v9 )
        {
          *v63 = 8;
LABEL_95:
          a1[8] = v71;
          a1[7] = v7;
          v61 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          a2[2] += v6 - v61;
          *a2 = v6;
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, 1);
        }
        else
        {
          a1[7] = v7;
          a1[8] = v71;
          v60 = *a2;
          a2[1] = (unsigned __int8 *)v72;
          a2[2] += v6 - v60;
          *a2 = v6;
          a1[13] = v9;
          return sub_1004B0E0(a1, a2, v59);
        }
      case 8:
        goto LABEL_95;
      case 9:
        goto LABEL_88;
      default:
        a1[8] = v71;
        a1[7] = v7;
        v62 = *a2;
        a2[1] = (unsigned __int8 *)v72;
        a2[2] += v6 - v62;
        *a2 = v6;
        a1[13] = v9;
        return sub_1004B0E0(a1, a2, -2);
    }
  }
}

// sub_1004A980 @ 0x1004A980
int __cdecl sub_1004A980(int a1, int a2)
{
  return (*(int (__cdecl **)(_DWORD, int))(a2 + 36))(*(_DWORD *)(a2 + 40), a1);
}

// sub_1004A9A0 @ 0x1004A9A0
int __cdecl sub_1004A9A0(int a1, _DWORD *a2, int a3, int a4, int a5)
{
  int v5; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // [esp-10h] [ebp-1Ch]
  int v10; // [esp+8h] [ebp-4h] BYREF

  v10 = 0;
  v5 = (*(int (__cdecl **)(_DWORD, int, int))(a5 + 32))(*(_DWORD *)(a5 + 40), 19, 4);
  if ( !v5 )
    return -4;
  v7 = sub_1004AA50(a1, 19, 19, 0, 0, a3, a2, a4, &v10, v5);
  v8 = v7;
  if ( v7 == -3 )
  {
    v9 = *(_DWORD *)(a5 + 40);
    *(_DWORD *)(a5 + 24) = aOversubscribed_2;
    (*(void (__cdecl **)(int, int))(a5 + 36))(v9, v5);
    return -3;
  }
  else
  {
    if ( v7 == -5 || !*a2 )
    {
      *(_DWORD *)(a5 + 24) = aIncompleteDyna_0;
      v8 = -3;
    }
    (*(void (__cdecl **)(_DWORD, int))(a5 + 36))(*(_DWORD *)(a5 + 40), v5);
    return v8;
  }
}

// sub_1004AA50 @ 0x1004AA50
int __cdecl sub_1004AA50(
        int *a1,
        unsigned int a2,
        unsigned int a3,
        int a4,
        int a5,
        _DWORD *a6,
        unsigned int *a7,
        int a8,
        unsigned int *a9,
        unsigned int *a10)
{
  int *v10; // ecx
  unsigned int v11; // edi
  unsigned int v12; // edx
  int v13; // eax
  unsigned int v15; // ecx
  _DWORD *v16; // eax
  unsigned int v17; // ebp
  signed int v18; // eax
  unsigned int v19; // edx
  int *v20; // esi
  int v21; // esi
  _DWORD *v22; // ebx
  int v23; // esi
  int v24; // ebx
  int v25; // esi
  int v26; // ecx
  unsigned int v27; // edx
  int v28; // ebx
  int *v29; // edx
  unsigned int v30; // ebx
  int v31; // ecx
  int v32; // edx
  int v33; // ebx
  unsigned int v34; // esi
  int v35; // edx
  unsigned int v36; // ecx
  unsigned int v37; // edx
  unsigned int v38; // ecx
  unsigned int v39; // eax
  _DWORD *v40; // ebp
  unsigned int v41; // eax
  unsigned int v42; // edi
  unsigned int v43; // eax
  unsigned int v44; // eax
  unsigned int v45; // edx
  int v46; // eax
  unsigned int v47; // eax
  int v48; // ecx
  char v49; // dl
  int v50; // esi
  int v51; // edx
  unsigned int v52; // eax
  _DWORD *v53; // ecx
  unsigned int i; // eax
  int v55; // edx
  _DWORD *v56; // eax
  int v57; // edx
  unsigned int v58; // [esp+10h] [ebp-100h]
  signed int v59; // [esp+14h] [ebp-FCh]
  int v60; // [esp+18h] [ebp-F8h]
  int *v61; // [esp+1Ch] [ebp-F4h]
  unsigned int *v62; // [esp+1Ch] [ebp-F4h]
  unsigned int v63; // [esp+20h] [ebp-F0h]
  char v64; // [esp+20h] [ebp-F0h]
  int v65; // [esp+24h] [ebp-ECh]
  _DWORD *v66; // [esp+28h] [ebp-E8h]
  signed int v67; // [esp+2Ch] [ebp-E4h]
  int v68; // [esp+30h] [ebp-E0h]
  unsigned int v69; // [esp+34h] [ebp-DCh]
  unsigned int v70; // [esp+38h] [ebp-D8h]
  unsigned int v71; // [esp+3Ch] [ebp-D4h]
  int v72; // [esp+40h] [ebp-D0h]
  int v73; // [esp+44h] [ebp-CCh]
  signed int v74; // [esp+48h] [ebp-C8h]
  _DWORD *v75; // [esp+4Ch] [ebp-C4h]
  unsigned int v76; // [esp+50h] [ebp-C0h]
  int v77; // [esp+54h] [ebp-BCh] BYREF
  _DWORD v78[14]; // [esp+58h] [ebp-B8h] BYREF
  int v79; // [esp+90h] [ebp-80h] BYREF
  int v80; // [esp+94h] [ebp-7Ch] BYREF
  _DWORD v81[15]; // [esp+98h] [ebp-78h]
  _DWORD v82[15]; // [esp+D4h] [ebp-3Ch] BYREF
  int v83; // [esp+118h] [ebp+8h]

  v10 = a1;
  v11 = 0;
  v12 = a2;
  v77 = 0;
  memset(v78, 0, sizeof(v78));
  v79 = 0;
  do
  {
    v13 = *v10++;
    --v12;
    ++v78[v13 - 1];
  }
  while ( v12 );
  if ( v77 == a2 )
  {
    *a6 = 0;
    *a7 = 0;
    return 0;
  }
  v15 = 1;
  v16 = v78;
  v17 = *a7;
  v58 = *a7;
  do
  {
    if ( *v16 )
      break;
    ++v15;
    ++v16;
  }
  while ( v15 <= 0xF );
  v18 = v15;
  v59 = v15;
  if ( v17 < v15 )
  {
    v58 = v15;
    v17 = v15;
  }
  v19 = 15;
  v20 = &v79;
  do
  {
    if ( *v20 )
      break;
    --v19;
    --v20;
  }
  while ( v19 );
  v67 = v19;
  if ( v17 > v19 )
  {
    v58 = v19;
    v17 = v19;
  }
  *a7 = v17;
  v21 = 1 << v15;
  if ( v15 < v19 )
  {
    v22 = &v78[v15 - 1];
    do
    {
      v23 = v21 - *v22;
      if ( v23 < 0 )
        return -3;
      ++v15;
      ++v22;
      v21 = 2 * v23;
    }
    while ( v15 < v19 );
  }
  v63 = v19;
  v24 = v78[v19 - 1];
  v25 = v21 - v24;
  v73 = v25;
  if ( v25 < 0 )
    return -3;
  v81[0] = 0;
  v78[v19 - 1] = v25 + v24;
  v26 = 0;
  v27 = v19 - 1;
  if ( v27 )
  {
    v28 = 0;
    do
    {
      v26 += v78[v28++];
      --v27;
      v81[v28] = v26;
    }
    while ( v27 );
  }
  v29 = a1;
  v30 = 0;
  do
  {
    v31 = *v29++;
    v61 = v29;
    if ( v31 )
    {
      v32 = v81[v31 - 1];
      a10[v32] = v30;
      v25 = v73;
      v81[v31 - 1] = v32 + 1;
      v29 = v61;
    }
    ++v30;
  }
  while ( v30 < a2 );
  v33 = -v17;
  v62 = a10;
  v83 = v81[v63 - 1];
  v70 = 0;
  v80 = 0;
  v60 = -1;
  v82[0] = 0;
  v72 = 0;
  v71 = 0;
  if ( v18 > v67 )
  {
LABEL_66:
    if ( !v25 || v67 == 1 )
      return 0;
    return -5;
  }
  else
  {
    v34 = v69;
    v64 = v18 - 1;
    v66 = &v78[v18 - 1];
    while ( 1 )
    {
      v35 = *v66 - 1;
      v65 = v35;
      if ( *v66 )
        break;
LABEL_64:
      ++v18;
      ++v66;
      v59 = v18;
      ++v64;
      if ( v18 > v67 )
      {
        v25 = v73;
        goto LABEL_66;
      }
    }
    while ( 1 )
    {
      v36 = v33 + v17;
      if ( v18 > (int)(v33 + v17) )
        break;
LABEL_49:
      BYTE1(v68) = v18 - v33;
      if ( v62 < &a10[v83] )
      {
        v34 = *v62;
        if ( *v62 >= a3 )
        {
          v50 = 4 * (v34 - a3);
          v49 = *(_BYTE *)(v50 + a5) + 80;
          v34 = *(_DWORD *)(v50 + a4);
        }
        else
        {
          v49 = v34 < 0x100 ? 0 : 96;
        }
        LOBYTE(v68) = v49;
        ++v62;
      }
      else
      {
        LOBYTE(v68) = -64;
      }
      v51 = 1 << (v18 - v33);
      v52 = v11 >> v33;
      if ( v11 >> v33 < v71 )
      {
        v53 = (_DWORD *)(v72 + 8 * v52);
        do
        {
          v52 += v51;
          *v53 = v68;
          v53[1] = v34;
          v53 += 2 * v51;
        }
        while ( v52 < v71 );
      }
      for ( i = 1 << v64; (i & v11) != 0; i >>= 1 )
        v11 ^= i;
      v55 = v60;
      v11 ^= i;
      v56 = &v81[v60 - 1];
      v70 = v11;
      if ( (v11 & ((1 << v33) - 1)) != *v56 )
      {
        do
        {
          --v55;
          v33 -= v58;
          --v56;
        }
        while ( (v11 & ((1 << v33) - 1)) != *v56 );
        v60 = v55;
      }
      v17 = v58;
      v57 = v65--;
      v18 = v59;
      if ( !v57 )
        goto LABEL_64;
      v35 = v65;
    }
    v76 = v35 + 1;
    while ( 1 )
    {
      v33 += v17;
      ++v60;
      v37 = v67 - v33;
      v74 = v17 + v36;
      if ( v67 - v33 > v17 )
        v37 = v17;
      v38 = v18 - v33;
      v39 = 1 << (v18 - v33);
      if ( v39 > v76 )
      {
        v40 = v66;
        v41 = -1 - v65 + v39;
        if ( v38 < v37 && ++v38 < v37 )
        {
          do
          {
            v42 = v40[1];
            ++v40;
            v43 = 2 * v41;
            if ( v43 <= v42 )
              break;
            v41 = v43 - v42;
            ++v38;
          }
          while ( v38 < v37 );
        }
      }
      v44 = *a9;
      v71 = 1 << v38;
      v45 = *a9 + (1 << v38);
      if ( v45 > 0x5A0 )
        return -4;
      *a9 = v45;
      v46 = a8 + 8 * v44;
      v72 = v46;
      v75 = &v82[v60];
      *v75 = v46;
      v11 = v70;
      if ( v60 )
      {
        LOBYTE(v68) = v38;
        v81[v60 - 1] = v70;
        BYTE1(v68) = v58;
        v47 = v70 >> (v33 - v58);
        v48 = *(v75 - 1);
        v34 = ((v72 - v48) >> 3) - v47;
        *(_DWORD *)(v48 + 8 * v47) = v68;
        *(_DWORD *)(v48 + 8 * v47 + 4) = v34;
      }
      else
      {
        *a6 = v46;
      }
      v36 = v74;
      LOBYTE(v18) = v59;
      if ( v59 <= v74 )
        goto LABEL_49;
      v17 = v58;
      v18 = v59;
    }
  }
}

// sub_1004AF20 @ 0x1004AF20
int __cdecl sub_1004AF20(
        unsigned int a1,
        unsigned int a2,
        int *a3,
        unsigned int *a4,
        unsigned int *a5,
        _DWORD *a6,
        _DWORD *a7,
        int a8,
        int a9)
{
  unsigned int *v9; // edi
  int v11; // eax
  int v12; // esi
  int v13; // eax
  int v14; // [esp-Ch] [ebp-20h]
  int v15; // [esp-8h] [ebp-1Ch]
  int v16; // [esp-8h] [ebp-1Ch]
  int v17; // [esp-8h] [ebp-1Ch]
  unsigned int v18; // [esp+10h] [ebp-4h] BYREF

  v14 = *(_DWORD *)(a9 + 40);
  v18 = 0;
  v9 = (unsigned int *)(*(int (__cdecl **)(int, int, int))(a9 + 32))(v14, 288, 4);
  if ( !v9 )
    return -4;
  v11 = sub_1004AA50(a3, a1, 0x101u, (int)&unk_100514D0, (int)&unk_1005154C, a6, a4, a8, &v18, v9);
  v12 = v11;
  if ( v11 )
  {
    if ( v11 == -3 )
    {
      v17 = *(_DWORD *)(a9 + 40);
      *(_DWORD *)(a9 + 24) = aOversubscribed_4;
      (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v17, v9);
      return -3;
    }
    if ( v11 == -4 )
      goto LABEL_20;
LABEL_19:
    *(_DWORD *)(a9 + 24) = aIncompleteLite_0;
    v12 = -3;
    goto LABEL_20;
  }
  if ( !*a4 )
    goto LABEL_19;
  v13 = sub_1004AA50(&a3[a1], a2, 0, (int)&unk_100515C8, (int)&unk_10051640, a7, a5, a8, &v18, v9);
  v12 = v13;
  if ( v13 )
  {
    switch ( v13 )
    {
      case -3:
        v15 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aOversubscribed_3;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v15, v9);
        return -3;
      case -5:
        v16 = *(_DWORD *)(a9 + 40);
        *(_DWORD *)(a9 + 24) = aIncompleteDist_0;
        (*(void (__cdecl **)(int, unsigned int *))(a9 + 36))(v16, v9);
        return -3;
      case -4:
        goto LABEL_20;
    }
  }
  else if ( *a5 || a1 <= 0x101 )
  {
    (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
    return 0;
  }
  *(_DWORD *)(a9 + 24) = aEmptyDistanceT_0;
  v12 = -3;
LABEL_20:
  (*(void (__cdecl **)(_DWORD, unsigned int *))(a9 + 36))(*(_DWORD *)(a9 + 40), v9);
  return v12;
}

// inflate_trees_fixed @ 0x1004B0B0
// zlib (internal): return fixed Huffman trees
int __cdecl sub_1004B0B0(_DWORD *a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a1 = dword_10058410;
  *a2 = dword_10058414;
  *a3 = &unk_10058418;
  *a4 = &unk_10059418;
  return 0;
}

// sub_1004B0E0 @ 0x1004B0E0
int __cdecl sub_1004B0E0(_DWORD *a1, _DWORD *a2, int a3)
{
  unsigned int v3; // ebp
  char *v4; // edi
  unsigned int v5; // eax
  unsigned int v6; // ebp
  unsigned int v7; // edx
  int (__cdecl *v8)(_DWORD, char *, unsigned int); // eax
  int v9; // eax
  char *v10; // eax
  char *v11; // ecx
  char *v12; // esi
  unsigned int v13; // ebp
  unsigned int v14; // eax
  unsigned int v15; // edx
  int (__cdecl *v16)(_DWORD, char *, unsigned int); // eax
  int v17; // eax
  char *v18; // edi
  char *v20; // [esp+10h] [ebp-4h]
  char *v21; // [esp+10h] [ebp-4h]

  v3 = a1[13];
  v4 = (char *)a1[12];
  v20 = (char *)a2[3];
  if ( (unsigned int)v4 > v3 )
    v3 = a1[11];
  v5 = a2[4];
  v6 = v3 - (_DWORD)v4;
  if ( v6 > v5 )
    v6 = a2[4];
  if ( v6 && a3 == -5 )
    a3 = 0;
  v7 = v6 + a2[5];
  a2[4] = v5 - v6;
  a2[5] = v7;
  v8 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
  if ( v8 )
  {
    v9 = v8(a1[15], v4, v6);
    a1[15] = v9;
    a2[12] = v9;
  }
  qmemcpy(v20, v4, v6);
  v10 = &v4[v6];
  v11 = (char *)a1[11];
  v21 = &v20[v6];
  if ( &v4[v6] == v11 )
  {
    v12 = (char *)a1[10];
    if ( (char *)a1[13] == v11 )
      a1[13] = v12;
    v13 = a1[13] - (_DWORD)v12;
    v14 = a2[4];
    if ( v13 > v14 )
      v13 = a2[4];
    if ( v13 && a3 == -5 )
      a3 = 0;
    v15 = v13 + a2[5];
    a2[4] = v14 - v13;
    a2[5] = v15;
    v16 = (int (__cdecl *)(_DWORD, char *, unsigned int))a1[14];
    if ( v16 )
    {
      v17 = v16(a1[15], v12, v13);
      a1[15] = v17;
      a2[12] = v17;
    }
    qmemcpy(v21, v12, 4 * (v13 >> 2));
    v18 = &v21[4 * (v13 >> 2)];
    v21 += v13;
    v10 = &v12[v13];
    qmemcpy(v18, &v12[4 * (v13 >> 2)], v13 & 3);
  }
  a2[3] = v21;
  a1[12] = v10;
  return a3;
}

// sub_1004B220 @ 0x1004B220
int __cdecl sub_1004B220(int a1, int a2, int a3, int a4, _DWORD *a5, unsigned __int8 **a6)
{
  _BYTE *v6; // ebx
  unsigned int v7; // esi
  unsigned int v8; // edx
  unsigned __int8 **v9; // edi
  unsigned __int8 *v10; // ebp
  unsigned int v11; // eax
  int v12; // esi
  int v13; // ebx
  _BYTE *v14; // esi
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ebx
  unsigned int v19; // eax
  unsigned int i; // edx
  int v21; // esi
  int v22; // ebx
  int v23; // esi
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  unsigned int j; // ebx
  char v28; // cl
  unsigned int v29; // edi
  int v30; // esi
  _BYTE *v31; // ecx
  _BYTE *v32; // esi
  unsigned int v33; // edi
  int v34; // ecx
  unsigned int v35; // ebx
  unsigned int v36; // ecx
  unsigned int v37; // esi
  unsigned int v38; // ecx
  unsigned __int8 *v39; // ebp
  unsigned __int8 *v40; // edx
  int v41; // ecx
  unsigned int v43; // ecx
  unsigned __int8 *v44; // ebp
  unsigned __int8 *v45; // edx
  unsigned __int8 *v46; // ecx
  unsigned __int8 *v47; // ebp
  unsigned __int8 *v48; // edx
  unsigned __int8 *v49; // ecx
  unsigned int v50; // [esp+10h] [ebp-14h]
  _BYTE *v51; // [esp+14h] [ebp-10h]
  unsigned int v52; // [esp+18h] [ebp-Ch]
  int v53; // [esp+1Ch] [ebp-8h]
  int v54; // [esp+20h] [ebp-4h]
  unsigned int v55; // [esp+28h] [ebp+4h]

  v6 = (_BYTE *)a5[13];
  v7 = a5[12];
  v8 = a5[8];
  v9 = a6;
  v51 = v6;
  v10 = *a6;
  v50 = (unsigned int)a6[1];
  v11 = a5[7];
  if ( (unsigned int)v6 >= v7 )
    v52 = a5[11] - (_DWORD)v6;
  else
    v52 = v7 - (_DWORD)v6 - 1;
  v53 = dword_10059608[a1];
  v54 = dword_10059608[a2];
  while ( 1 )
  {
    for ( ; v11 < 0x14; ++v10 )
    {
      --v50;
      v12 = *v10 << v11;
      v11 += 8;
      v8 |= v12;
    }
    v13 = *(unsigned __int8 *)(a3 + 8 * (v8 & v53));
    v14 = (_BYTE *)(a3 + 8 * (v8 & v53));
    if ( *v14 )
      break;
LABEL_27:
    v34 = (unsigned __int8)v14[1];
    v8 >>= v34;
    v11 -= v34;
    *v51++ = v14[4];
    --v52;
LABEL_28:
    if ( v52 < 0x102 || v50 < 0xA )
    {
      v38 = (unsigned int)&v9[1][-v50];
      if ( v11 >> 3 < v38 )
        v38 = v11 >> 3;
      v39 = &v10[-v38];
      a5[8] = v8;
      a5[7] = v11 - 8 * v38;
      v40 = *v9;
      v9[1] = (unsigned __int8 *)(v50 + v38);
      v41 = (int)&v9[2][v39 - v40];
      *v9 = v39;
      v9[2] = (unsigned __int8 *)v41;
      a5[13] = v51;
      return 0;
    }
  }
  v15 = (unsigned __int8)v14[1];
  v8 >>= v15;
  v11 -= v15;
  if ( (v13 & 0x10) != 0 )
  {
LABEL_12:
    v18 = v13 & 0xF;
    v19 = v11 - v18;
    v55 = *((_DWORD *)v14 + 1) + (v8 & dword_10059608[v18]);
    for ( i = v8 >> v18; v19 < 0xF; ++v10 )
    {
      --v50;
      v21 = *v10 << v19;
      v19 += 8;
      i |= v21;
    }
    v22 = *(unsigned __int8 *)(a4 + 8 * (i & v54));
    v23 = a4 + 8 * (i & v54);
    v24 = *(unsigned __int8 *)(v23 + 1);
    v8 = i >> v24;
    v11 = v19 - v24;
    if ( (v22 & 0x10) == 0 )
    {
      while ( (v22 & 0x40) == 0 )
      {
        v25 = *(_DWORD *)(v23 + 4) + (v8 & dword_10059608[v22]);
        v22 = *(unsigned __int8 *)(v23 + 8 * v25);
        v23 += 8 * v25;
        v26 = *(unsigned __int8 *)(v23 + 1);
        v8 >>= v26;
        v11 -= v26;
        if ( (v22 & 0x10) != 0 )
          goto LABEL_17;
      }
      v35 = v50;
      v36 = (unsigned int)&v9[1][-v50];
      v37 = v11 >> 3;
      v9[6] = (unsigned __int8 *)aInvalidDistanc_0;
      if ( v11 >> 3 < v36 )
LABEL_41:
        v36 = v37;
LABEL_42:
      v47 = &v10[-v36];
      a5[8] = v8;
      a5[7] = v11 - 8 * v36;
      v48 = *v9;
      v9[1] = (unsigned __int8 *)(v35 + v36);
      v49 = v9[2];
      *v9 = v47;
      v9[2] = &v49[v47 - v48];
      a5[13] = v51;
      return -3;
    }
LABEL_17:
    for ( j = v22 & 0xF; v11 < j; ++v10 )
    {
      --v50;
      v28 = v11;
      v11 += 8;
      v8 |= *v10 << v28;
    }
    v29 = *(_DWORD *)(v23 + 4) + (v8 & dword_10059608[j]);
    v8 >>= j;
    v11 -= j;
    v52 -= v55;
    v30 = a5[10];
    v31 = v51;
    if ( (unsigned int)&v51[-v30] < v29 )
    {
      v33 = v29 + v30 - (_DWORD)v51;
      v32 = (_BYTE *)(a5[11] - v33);
      if ( v55 > v33 )
      {
        v55 -= v33;
        do
        {
          *v31++ = *v32++;
          --v33;
        }
        while ( v33 );
        v32 = (_BYTE *)a5[10];
      }
    }
    else
    {
      *v51 = v51[-v29];
      v31 = v51 + 2;
      v32 = &v51[-v29 + 2];
      v51[1] = v51[-v29 + 1];
      v55 -= 2;
    }
    do
    {
      *v31++ = *v32++;
      --v55;
    }
    while ( v55 );
    v9 = a6;
    v51 = v31;
    goto LABEL_28;
  }
  while ( (v13 & 0x40) == 0 )
  {
    v16 = *((_DWORD *)v14 + 1) + (v8 & dword_10059608[v13]);
    v13 = (unsigned __int8)v14[8 * v16];
    v14 += 8 * v16;
    if ( !v13 )
      goto LABEL_27;
    v17 = (unsigned __int8)v14[1];
    v8 >>= v17;
    v11 -= v17;
    if ( (v13 & 0x10) != 0 )
      goto LABEL_12;
  }
  if ( (v13 & 0x20) == 0 )
  {
    v35 = v50;
    v36 = (unsigned int)&v9[1][-v50];
    v37 = v11 >> 3;
    v9[6] = (unsigned __int8 *)aInvalidLiteral_0;
    if ( v11 >> 3 < v36 )
      goto LABEL_41;
    goto LABEL_42;
  }
  v43 = (unsigned int)&v9[1][-v50];
  if ( v11 >> 3 < v43 )
    v43 = v11 >> 3;
  v44 = &v10[-v43];
  a5[8] = v8;
  a5[7] = v11 - 8 * v43;
  v45 = *v9;
  v9[1] = (unsigned __int8 *)(v50 + v43);
  v46 = v9[2];
  *v9 = v44;
  v9[2] = &v46[v44 - v45];
  a5[13] = v51;
  return 1;
}
